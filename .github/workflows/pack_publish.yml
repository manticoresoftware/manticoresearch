name: ðŸ“¦ Pack and publish
run-name: ðŸ“¦ Pack and publish ${{ github.sha }}

#on: workflow_call
on:
  workflow_run:
    workflows: [ ðŸ”¬ Test ]
    types: [ completed ]
    branches: [ master ]
  pull_request:
    branches: [ master ]
    types: [opened, synchronize, reopened, labeled, unlabeled]
    paths-ignore:
      - 'manual/**'
      - 'cmake/GetGALERA.cmake'
      - 'galera_packaging/**'
  push:
    branches:
      - manticore-*
    paths-ignore:
      - 'manual/**'
      - 'cmake/GetGALERA.cmake'
      - 'galera_packaging/**'
    tags:
      - 'release*'
      - 'pack_publish'

# cancels the previous workflow run when a new one appears in the same branch (e.g. master or a PR's branch)
concurrency:
  group: pack_${{ github.ref }}
  cancel-in-progress: true

jobs:
  check_branch:
    name: Check branch existence
    runs-on: ubuntu-22.04
    outputs:
      columnar_locator: ${{ steps.set_locator.outputs.columnar_locator }}
    steps:
      - name: Check if branch exists in manticoresoftware/manticoresearch
        id: check_branch
        if: github.ref_name != 'master'
        run: |
          # Extract the actual branch name for pull requests
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
          else
            BRANCH_NAME="${{ github.ref_name }}"
          fi
          
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://api.github.com/repos/manticoresoftware/columnar/branches/$BRANCH_NAME)
          if [ "$HTTP_STATUS" -eq "200" ]; then
            echo "branch_exists=true" >> $GITHUB_OUTPUT
            echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          else
            echo "branch_exists=false" >> $GITHUB_OUTPUT
            echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          fi
      - name: Set Columnar Locator
        id: set_locator
        run: |
          if [[ "${{ github.ref_name }}" != "master" && "${{ steps.check_branch.outputs.branch_exists }}" == "true" ]]; then
            echo "columnar_locator=GIT_REPOSITORY https://github.com/manticoresoftware/columnar.git GIT_TAG ${{ steps.check_branch.outputs.branch_name }}" >> $GITHUB_OUTPUT
          else
            echo "columnar_locator=" >> $GITHUB_OUTPUT
          fi
  pack:
    name: OK to pack?
    runs-on: ubuntu-22.04
    outputs:
      version: ${{ steps.semver-tagger.outputs.version }}
      version_full: ${{ steps.semver-tagger.outputs.version_full }}
      version_rpm: ${{ steps.semver-tagger.outputs.version_rpm }}
      version_deb: ${{ steps.semver-tagger.outputs.version_deb }}
      target: ${{ steps.semver-tagger.outputs.target }}
      should_continue: ${{ steps.check-should-continue.outputs.should_continue }}
    if: |
      (
        github.event_name == 'pull_request'
        &&
        (
          contains(
            github.event.pull_request.labels.*.name, 'pack'
          )
          ||
          contains(
            github.event.pull_request.labels.*.name, 'publish'
          )
        )
      )
      ||
      (
        github.event_name == 'workflow_run'
        &&
        github.event.workflow_run.conclusion == 'success'
        &&
        github.ref == 'refs/heads/master'
      )
      ||
      (
        github.event_name == 'push'
        &&
        (
          startsWith(
            github.ref, 'refs/heads/manticore-'
          )
          ||
          contains(
            github.ref, 'refs/tags/pack_publish'
          )
        )
      )
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      - name: Update version
        id: semver-tagger
        uses: manticoresoftware/semver-tagger-action@main  
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          conventional_commits_authors: alexey@manticoresearch.com
          ignore_patterns: '\.md$|^test/|^manual/|\.clt|\.github|\.patterns|\.yml|\.gitignore'
      - name: Check if we should continue packing
        id: check-should-continue
        run: |
          # Continue if version was updated, if we have the "pack" label on PR, or if target is "release"
          if [[ "${{ steps.semver-tagger.outputs.version_updated }}" == "true" ]]; then
            echo "Continuing because version was updated"
            echo "should_continue=true" >> $GITHUB_OUTPUT
          elif [[ "${{ steps.semver-tagger.outputs.target }}" == "release" ]]; then
            echo "Continuing because target is release"
            echo "should_continue=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "pull_request" && "${{ contains(github.event.pull_request.labels.*.name, 'pack') }}" == "true" ]]; then
            echo "Continuing because PR has 'pack' label"
            echo "should_continue=true" >> $GITHUB_OUTPUT
          elif [[ "${{ contains(github.ref, 'refs/tags/pack_publish') }}" == "true" ]]; then
            echo "Continuing because commit has 'pack_publish' tag"
            echo "should_continue=true" >> $GITHUB_OUTPUT
          else
            echo "Skipping packing because version wasn't updated, target is not release, and there's no 'pack' label or tag"
            echo "should_continue=false" >> $GITHUB_OUTPUT
          fi
      - run: |
          echo "# Packing and publishing all for commit ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "* Commit URL: [${{ github.sha }}](/${{ github.repository }}/commit/${{ github.sha }})" >> $GITHUB_STEP_SUMMARY
          echo "* Initiated by: [@${{ github.actor }}](https://github.com/${{ github.actor }})" >> $GITHUB_STEP_SUMMARY
          echo "* Ref: ${{ github.ref_type }} \"${{ github.ref_name }}\"" >> $GITHUB_STEP_SUMMARY
          echo "* Attempt: ${{ github.run_attempt }}" >> $GITHUB_STEP_SUMMARY
          echo "* Version updated: ${{ steps.semver-tagger.outputs.version_updated }}" >> $GITHUB_STEP_SUMMARY
          echo "* Should continue packing: ${{ steps.check-should-continue.outputs.should_continue }}" >> $GITHUB_STEP_SUMMARY

#  debug_info:
#    name: Debug GitHub Event Info
#    runs-on: ubuntu-22.04
#    steps:
#      - name: Print GitHub Event Info
#        run: |
#          echo "GitHub Event Name: ${{ github.event_name }}"
#          echo "GitHub Ref: ${{ github.ref }}"
#          echo "GitHub Ref Type: ${{ github.ref_type }}"
#          echo "GitHub Ref Name: ${{ github.ref_name }}"
#          echo "GitHub Actor: ${{ github.actor }}"
#          echo "GitHub Repository: ${{ github.repository }}"
#          echo "GitHub SHA: ${{ github.sha }}"
#          echo "GitHub Run Number: ${{ github.run_number }}"
#          echo "GitHub Run Attempt: ${{ github.run_attempt }}"
#          echo "GitHub Workflow: ${{ github.workflow }}"
#          echo "GitHub Event JSON:"
#          echo '${{ toJSON(github.event) }}'

  # Job to check dependencies using check_deps_in_repos.sh
  # Runs on every PR, workflow_run, or push event matching the conditions
  check_deps:
    needs: pack
    if: needs.pack.outputs.should_continue == 'true'
    name: Check deps test
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      # We have to checkout to access .github/workflows/ in further steps
      - name: Run dependency check script
        run: |
          bash dist/check_deps_in_repos.sh --target ${{ needs.pack.outputs.target }}

  pack_debian_ubuntu:
    name: Debian/Ubuntu packages
    uses: ./.github/workflows/build_template.yml
    needs: [pack, check_branch, check_deps]
    if: needs.pack.outputs.should_continue == 'true'
    strategy:
      fail-fast: false
      matrix:
        DISTR: [bionic, focal, jammy, bullseye, bookworm]
        arch: [x86_64, aarch64]
    with:
      COLUMNAR_LOCATOR: ${{ needs.check_branch.outputs.columnar_locator }}
      DISTR: ${{ matrix.DISTR }}
      arch: ${{ matrix.arch }}
      cmake_command: |
        mkdir build
        cd build
        cmake -DPACK=1 ..
        export CMAKE_TOOLCHAIN_FILE=$(pwd)/dist/build_dockers/cross/linux.cmake
        cmake --build . --target package
      cache_key: pack_${{ matrix.DISTR }}_${{ matrix.arch }}
      artifact_list: "build/manticore*deb"
      version: ${{ needs.pack.outputs.version }}
      build_tag: ${{ needs.pack.outputs.target == 'dev' && 'dev' || '' }}

  pack_rhel:
    name: RHEL packages
    uses: ./.github/workflows/build_template.yml
    needs: [pack, check_branch, check_deps]
    if: needs.pack.outputs.should_continue == 'true'
    strategy:
      fail-fast: false
      matrix:
        DISTR: [rhel7, rhel8, rhel9, rhel10]
        arch: [x86_64, aarch64]
    with:
      COLUMNAR_LOCATOR: ${{ needs.check_branch.outputs.columnar_locator }}
      DISTR: ${{ matrix.DISTR }}
      arch: ${{ matrix.arch }}
      boost_url_key: boost_rhel_feb17
      cmake_command: |
        ln -s $(pwd) /builds_manticoresearch_dev_usr_src_debug_manticore_component_src_0
        cd /builds_manticoresearch_dev_usr_src_debug_manticore_component_src_0
        mkdir build
        cd build
        cmake -DPACK=1 ..
        export CMAKE_TOOLCHAIN_FILE=$(pwd)/dist/build_dockers/cross/linux.cmake
        cmake --build . --target package
      cache_key: pack_${{ matrix.DISTR }}_${{ matrix.arch }}
      artifact_list: "build/manticore*rpm"
      version: ${{ needs.pack.outputs.version }}
      build_tag: ${{ needs.pack.outputs.target == 'dev' && 'dev' || '' }}

  pack_macos:
    name: MacOS packages
    uses: ./.github/workflows/build_template.yml
    needs: [pack, check_branch, check_deps]
    if: needs.pack.outputs.should_continue == 'true'
    strategy:
      fail-fast: false
      matrix:
        DISTR: [macos]
        arch: [x86_64, arm64]
    with:
      COLUMNAR_LOCATOR: ${{ needs.check_branch.outputs.columnar_locator }}
      DISTR: ${{ matrix.DISTR }}
      arch: ${{ matrix.arch }}
      HOMEBREW_PREFIX: /opt/homebrew
      cmake_command: |
        mkdir build
        cd build
        cmake -DPACK=1 ..
        export CMAKE_TOOLCHAIN_FILE=$(pwd)/dist/build_dockers/cross/osx.cmake
        cmake --build . --target package
      cache_key: pack_${{ matrix.DISTR }}_${{ matrix.arch }}
      artifact_list: "build/manticore*tar.gz"
      version: ${{ needs.pack.outputs.version }}
      build_tag: ${{ needs.pack.outputs.target == 'dev' && 'dev' || '' }}

  pack_windows:
    name: Windows x64 package
    uses: ./.github/workflows/build_template.yml
    needs: [pack, check_branch, check_deps]
    if: needs.pack.outputs.should_continue == 'true'
    with:
      COLUMNAR_LOCATOR: ${{ needs.check_branch.outputs.columnar_locator }}
      DISTR: windows
      arch: x64
      sysroot_url_key: roots_mysql83_jan17
      boost_url_key: boost_80
      cmake_command: |
        mkdir build
        cd build
        cmake -DPACK=1 ..
        export CMAKE_TOOLCHAIN_FILE=$(pwd)/dist/build_dockers/cross/windows.cmake
        cmake --build . --target package
      cache_key: pack_windows_x64
      artifact_list: "build/manticore*exe build/manticore*zip"
      version: ${{ needs.pack.outputs.version }}
      build_tag: ${{ needs.pack.outputs.target == 'dev' && 'dev' || '' }}

  build_nsis:
    name: Making Windows NSIS installer
    needs: [pack_windows, pack]
    if: needs.pack.outputs.should_continue == 'true'
    runs-on: ubuntu-22.04
    container:
      image: manticoresearch/build_nsis:1.0.0
    env:
      CI_COMMIT_SHA: ${{ github.sha }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      - name: Patch version
        run: |
          sed -i "s/0\.0\.0/${{ needs.pack.outputs.version }}/g" src/sphinxversion.h.in
      - name: Initialization
        # without adding the safe.directory the script fails to do git show ...
        run: git config --global --add safe.directory /__w/manticoresearch/manticoresearch
      - name: Make installer
        # TODO: remove the hardcoded paths /builds/ below
        run: |
          mkdir -p /builds/manticoresearch/dev/build/
          /bin/bash dist/build_dockers/nsis/nsis_src_parser.sh ${{ needs.pack.outputs.target }}
        shell: bash
      - run: mv /builds/manticoresearch/dev/build build
      - name: Upload artifact
        uses: manticoresoftware/upload_artifact_with_retries@main
        with:
          name: win_installer
          path: build/manticore-*.exe

  # virtual job to simplify the CI
  publish:
    name: OK to publish?
    runs-on: ubuntu-22.04
    # This job depends on all the package preparation jobs that have to pass before we can start publishing packages
    needs: [pack_debian_ubuntu, pack_rhel, pack_macos, build_nsis]
    if: |
      (github.repository == 'manticoresoftware/manticoresearch')
      && (
        (github.event_name == 'pull_request' && (contains(github.event.pull_request.labels.*.name, 'publish')))
        || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
        || (github.event_name == 'push' && startsWith(github.ref, 'refs/heads/manticore-'))
        || (github.event_name == 'push' && contains(github.ref, 'refs/tags/pack_publish'))
      )
    steps:
      - run: echo "Ready to publish"

  publish_debian_ubuntu:
    needs: [publish, pack]
    strategy:
      fail-fast: true
      matrix:
        DISTR: [bionic, focal, jammy, bullseye, bookworm]
        arch: [x86_64, aarch64]
    runs-on: ubuntu-22.04
    name: ${{ matrix.DISTR }} ${{ matrix.arch }} publishing
    steps:
      - uses: manticoresoftware/publish_to_repo@main
        with:
          ssh_key: ${{ secrets.REPO_SSH_KEY }}
          distr: ${{ matrix.DISTR }}
          arch: ${{ matrix.arch }}
          artifact: build_${{ matrix.DISTR }}_RelWithDebInfo_${{ matrix.arch }}
          type: deb
          delimiter: "-"
          target: ${{ needs.pack.outputs.target }}

  publish_rhel:
    needs: [publish, pack]
    strategy:
      fail-fast: true
      matrix:
        DISTR: [7, 8, 9, 10]
        arch: [x86_64, aarch64]
    runs-on: ubuntu-22.04
    name: RHEL ${{ matrix.DISTR }} ${{ matrix.arch }} publishing
    steps:
      - uses: manticoresoftware/publish_to_repo@main
        with:
          ssh_key: ${{ secrets.REPO_SSH_KEY }}
          distr: ${{ matrix.DISTR }}
          arch: ${{ matrix.arch }}
          artifact: build_rhel${{ matrix.DISTR }}_RelWithDebInfo_${{ matrix.arch }}
          type: rpm
          delimiter: "_"
          target: ${{ needs.pack.outputs.target }}

  publish_macos:
    name: Publishing MacOS
    needs: [publish, pack]
    strategy:
      fail-fast: true
      matrix:
        arch: [x86_64, arm64]
    runs-on: ubuntu-22.04
    steps:
      - uses: manticoresoftware/publish_to_repo@main
        with:
          ssh_key: ${{ secrets.REPO_SSH_KEY }}
          distr: macos
          arch: ${{ matrix.arch }}
          artifact: build_macos_RelWithDebInfo_${{ matrix.arch }}
          type: arc
          delimiter: "-"
          target: ${{ needs.pack.outputs.target }}

  publish_windows:
    name: Publishing Windows packages to repo.manticoresearch.com
    needs: [publish, pack]
    runs-on: ubuntu-22.04
    steps:
      - uses: manticoresoftware/publish_to_repo@main
        with:
          ssh_key: ${{ secrets.REPO_SSH_KEY }}
          distr: windows
          arch: x64
          artifact: build_windows_RelWithDebInfo_x64
          type: arc
          delimiter: "-"
          target: ${{ needs.pack.outputs.target }}

  # Test Windows installer without Docker/Buddy on GitHub Actions
  test_windows_installer:
    name: Test Windows NSIS installer
    needs: [publish_windows, pack]
    runs-on: windows-latest
    steps:
    - name: Download Windows installer artifact
      uses: actions/download-artifact@v4
      with:
        name: win_installer
        path: ./installer
    
    - name: Extract and Install Manticore
      timeout-minutes: 5
      run: |
        echo "=== EXTRACTING INSTALLER ==="
        tar -xf ./installer/artifact.tar -C ./installer
        
        $installer = "./installer/build/manticore-*.exe"
        $installerFile = Get-ChildItem $installer | Select-Object -First 1
        
        if (-not $installerFile) {
          echo "ERROR: Installer not found!"
          Get-ChildItem ./installer -Recurse
          exit 1
        }
        
        echo "=== INSTALLING MANTICORE ==="
        echo "Installing from: $($installerFile.FullName)"
        
        $process = Start-Process -FilePath $installerFile.FullName -ArgumentList "/S /NOEXECUTOR" -Wait -PassThru -NoNewWindow
        echo "Installation process exited with code: $($process.ExitCode)"
        
        # Wait for installation to complete and verify with MySQL if available
        $mysqlPath = "C:\tools\mysql\current\bin\mysql.exe"
        if (Test-Path $mysqlPath) {
          Start-Sleep -Seconds 5
          & $mysqlPath -P9306 -h127.0.0.1 -e "SELECT 1" 2>$null
          if ($LASTEXITCODE -eq 0) {
            echo "MySQL connection verified installation is complete"
          } else {
            echo "MySQL not ready yet, waiting..."
            Start-Sleep -Seconds 5
          }
        } else {
          Start-Sleep -Seconds 10
        }
      shell: pwsh
    
    - name: Test Manticore Full Functionality
      run: |
        echo "=== VERIFYING INSTALLATION ==="
        
        $installPath = "C:\Program Files (x86)\Manticore"
        if (-not (Test-Path $installPath)) {
          echo "ERROR: Manticore not installed at expected path: $installPath"
          exit 1
        }
        
        echo "Manticore installed at: $installPath"
        
        $searchdPath = "$installPath\bin\searchd.exe"
        $indexerPath = "$installPath\bin\indexer.exe"
        
        if (-not (Test-Path $searchdPath)) {
          echo "ERROR: searchd.exe not found at: $searchdPath"
          exit 1
        }
        
        if (-not (Test-Path $indexerPath)) {
          echo "ERROR: indexer.exe not found at: $indexerPath"
          exit 1
        }
        
        echo "searchd.exe found at: $searchdPath"
        echo "indexer.exe found at: $indexerPath"
        
        & $searchdPath --version
        
        # Disable Buddy before starting Manticore
        $configPath = "$installPath\etc\manticoresearch\manticore.conf"
        if (Test-Path $configPath) {
          $config = Get-Content $configPath -Raw
          # Add buddy_path with empty value to disable it
          $config = $config -replace "(searchd\s*\{)", "`$1`n    buddy_path = "
          Set-Content -Path $configPath -Value $config -Force
        }
        
        echo "=== STARTING MANTICORE SERVICE ==="
        
        Push-Location $installPath
        
        $process = Start-Process -FilePath $searchdPath -PassThru -NoNewWindow
        
        # Smart wait for daemon to be ready
        echo "Waiting for Manticore daemon to be ready..."
        $maxAttempts = 30
        $attempt = 0
        $allPortsReady = $false
        
        while ($attempt -lt $maxAttempts -and -not $allPortsReady) {
          Start-Sleep -Seconds 1
          $attempt++
          
          # Check if process is still running
          $manticoreProcess = Get-Process -Name "searchd" -ErrorAction SilentlyContinue
          if (-not $manticoreProcess) {
            echo "ERROR: Manticore searchd process died during startup"
            exit 1
          }
          
          # Check all three ports
          $port9306 = Test-NetConnection -ComputerName localhost -Port 9306 -WarningAction SilentlyContinue -InformationLevel Quiet
          $port9308 = Test-NetConnection -ComputerName localhost -Port 9308 -WarningAction SilentlyContinue -InformationLevel Quiet
          $port9312 = Test-NetConnection -ComputerName localhost -Port 9312 -WarningAction SilentlyContinue -InformationLevel Quiet
          
          if ($port9306 -and $port9308 -and $port9312) {
            $allPortsReady = $true
            echo "All ports are ready after $attempt seconds"
          }
        }
        
        if (-not $allPortsReady) {
          echo "ERROR: Manticore did not start properly within $maxAttempts seconds"
          echo "Port 9306 status: $port9306"
          echo "Port 9308 status: $port9308"
          echo "Port 9312 status: $port9312"
          exit 1
        }
        
        $manticoreProcess = Get-Process -Name "searchd" -ErrorAction SilentlyContinue
        echo "Manticore searchd is running (PID: $($manticoreProcess.Id))"
        
        Pop-Location
        
        echo "=== TESTING MANTICORE PORTS WITH POWERSHELL ==="
        
        # Test all three ports
        echo "Testing port 9306 (MySQL protocol)..."
        $connection = Test-NetConnection -ComputerName localhost -Port 9306 -WarningAction SilentlyContinue -InformationLevel Quiet
        if ($connection) {
          echo "âœ“ Port 9306 (MySQL) is listening"
        } else {
          echo "ERROR: Port 9306 is not listening"
          exit 1
        }
        
        echo "Testing port 9308 (HTTP API)..."
        try {
          $response = Invoke-WebRequest -Uri "http://localhost:9308/" -UseBasicParsing
          if ($response.StatusCode -eq 200) {
            echo "âœ“ Port 9308 (HTTP API) is accessible - Status: $($response.StatusCode)"
          } else {
            echo "ERROR: Port 9308 returned status: $($response.StatusCode)"
            exit 1
          }
        } catch {
          echo "ERROR: Port 9308 test failed: $_"
          exit 1
        }
        
        echo "Testing port 9312 (Sphinx protocol)..."
        try {
          $response = Invoke-WebRequest -Uri "http://localhost:9312/" -UseBasicParsing
          if ($response.StatusCode -eq 200) {
            echo "âœ“ Port 9312 (Sphinx/HTTP) is accessible - Status: $($response.StatusCode)"
          } else {
            echo "ERROR: Port 9312 returned status: $($response.StatusCode)"
            exit 1
          }
        } catch {
          echo "ERROR: Port 9312 test failed: $_"
          exit 1
        }
        
        echo "=== TESTING MANTICORE FUNCTIONALITY WITH POWERSHELL ==="
        
        # Test 1: Basic SELECT query
        echo "`nTest 1: Testing SELECT 1..."
        try {
          $jsonBody = '{"query":"SELECT 1"}'
          $bytes = [System.Text.Encoding]::UTF8.GetBytes($jsonBody)
          $response1 = Invoke-WebRequest -Uri "http://localhost:9308/sql" -Method POST `
            -Body $bytes -ContentType "application/json; charset=utf-8" -UseBasicParsing
          $result = $response1.Content | ConvertFrom-Json
          echo "Response: $($result | ConvertTo-Json -Compress)"
          echo "âœ“ SELECT 1 query successful"
        } catch {
          echo "ERROR: SELECT 1 query failed: $_"
          if ($_.ErrorDetails.Message) {
            echo "Error details: $($_.ErrorDetails.Message)"
          }
          exit 1
        }
        
        # Test 2: Create table
        echo "`nTest 2: Creating table..."
        try {
          $jsonBody = '{"query":"CREATE TABLE test_table (title text, content text, gid integer)"}'
          $bytes = [System.Text.Encoding]::UTF8.GetBytes($jsonBody)
          $response2 = Invoke-WebRequest -Uri "http://localhost:9308/sql" -Method POST `
            -Body $bytes -ContentType "application/json; charset=utf-8" -UseBasicParsing
          $result = $response2.Content | ConvertFrom-Json
          echo "Response: $($result | ConvertTo-Json -Compress)"
          echo "âœ“ CREATE TABLE successful"
        } catch {
          echo "ERROR: CREATE TABLE failed: $_"
          if ($_.ErrorDetails.Message) {
            echo "Error details: $($_.ErrorDetails.Message)"
          }
          exit 1
        }
        
        # Test 3: Insert data
        echo "`nTest 3: Inserting data..."
        try {
          # Use single quotes inside SQL, backticks for escaping PowerShell quotes
          $jsonBody = "{`"query`":`"INSERT INTO test_table VALUES (1, 'Hello World', 'This is a test document', 100)`"}"
          $bytes = [System.Text.Encoding]::UTF8.GetBytes($jsonBody)
          $response3 = Invoke-WebRequest -Uri "http://localhost:9308/sql" -Method POST `
            -Body $bytes -ContentType "application/json; charset=utf-8" -UseBasicParsing
          $result = $response3.Content | ConvertFrom-Json
          echo "Response: $($result | ConvertTo-Json -Compress)"
          echo "âœ“ INSERT successful"
        } catch {
          echo "ERROR: INSERT failed: $_"
          if ($_.ErrorDetails.Message) {
            echo "Error details: $($_.ErrorDetails.Message)"
          }
          exit 1
        }
        
        # Test 4: Insert more data
        echo "`nTest 4: Inserting more data..."
        try {
          $jsonBody = "{`"query`":`"INSERT INTO test_table VALUES (2, 'Test Document', 'Another test content', 200)`"}"
          $bytes = [System.Text.Encoding]::UTF8.GetBytes($jsonBody)
          $response4 = Invoke-WebRequest -Uri "http://localhost:9308/sql" -Method POST `
            -Body $bytes -ContentType "application/json; charset=utf-8" -UseBasicParsing
          $result = $response4.Content | ConvertFrom-Json
          echo "Response: $($result | ConvertTo-Json -Compress)"
          echo "âœ“ Second INSERT successful"
        } catch {
          echo "ERROR: Second INSERT failed: $_"
          if ($_.ErrorDetails.Message) {
            echo "Error details: $($_.ErrorDetails.Message)"
          }
          exit 1
        }
        
        # Test 5: Search with MATCH
        echo "`nTest 5: Testing MATCH search..."
        try {
          $jsonBody = "{`"query`":`"SELECT * FROM test_table WHERE MATCH('Hello')`"}"
          $bytes = [System.Text.Encoding]::UTF8.GetBytes($jsonBody)
          $response5 = Invoke-WebRequest -Uri "http://localhost:9308/sql" -Method POST `
            -Body $bytes -ContentType "application/json; charset=utf-8" -UseBasicParsing
          $result = $response5.Content | ConvertFrom-Json
          echo "Response: $($result | ConvertTo-Json -Compress)"
          if ($result.hits.total -gt 0) {
            echo "âœ“ MATCH search successful - found $($result.hits.total) results"
          } else {
            echo "ERROR: MATCH search returned no results"
            exit 1
          }
        } catch {
          echo "ERROR: MATCH search failed: $_"
          if ($_.ErrorDetails.Message) {
            echo "Error details: $($_.ErrorDetails.Message)"
          }
          exit 1
        }
        
        # Test 6: Select all
        echo "`nTest 6: Testing SELECT ALL..."
        try {
          $jsonBody = '{"query":"SELECT * FROM test_table"}'
          $bytes = [System.Text.Encoding]::UTF8.GetBytes($jsonBody)
          $response6 = Invoke-WebRequest -Uri "http://localhost:9308/sql" -Method POST `
            -Body $bytes -ContentType "application/json; charset=utf-8" -UseBasicParsing
          $result = $response6.Content | ConvertFrom-Json
          echo "Response: $($result | ConvertTo-Json -Compress)"
          if ($result.hits.total -eq 2) {
            echo "âœ“ SELECT ALL returned 2 records"
          } else {
            echo "ERROR: SELECT ALL expected 2 records, got $($result.hits.total)"
            exit 1
          }
        } catch {
          echo "ERROR: SELECT ALL failed: $_"
          if ($_.ErrorDetails.Message) {
            echo "Error details: $($_.ErrorDetails.Message)"
          }
          exit 1
        }
        
        # Test 7: Update data
        echo "`nTest 7: Testing UPDATE..."
        try {
          $jsonBody = '{"query":"UPDATE test_table SET gid=300 WHERE id=1"}'
          $bytes = [System.Text.Encoding]::UTF8.GetBytes($jsonBody)
          $response7 = Invoke-WebRequest -Uri "http://localhost:9308/sql" -Method POST `
            -Body $bytes -ContentType "application/json; charset=utf-8" -UseBasicParsing
          $result = $response7.Content | ConvertFrom-Json
          echo "Response: $($result | ConvertTo-Json -Compress)"
          echo "âœ“ UPDATE successful"
        } catch {
          echo "ERROR: UPDATE failed: $_"
          if ($_.ErrorDetails.Message) {
            echo "Error details: $($_.ErrorDetails.Message)"
          }
          exit 1
        }
        
        # Test 8: Delete data
        echo "`nTest 8: Testing DELETE..."
        try {
          $jsonBody = '{"query":"DELETE FROM test_table WHERE id=2"}'
          $bytes = [System.Text.Encoding]::UTF8.GetBytes($jsonBody)
          $response8 = Invoke-WebRequest -Uri "http://localhost:9308/sql" -Method POST `
            -Body $bytes -ContentType "application/json; charset=utf-8" -UseBasicParsing
          $result = $response8.Content | ConvertFrom-Json
          echo "Response: $($result | ConvertTo-Json -Compress)"
          echo "âœ“ DELETE successful"
        } catch {
          echo "ERROR: DELETE failed: $_"
          if ($_.ErrorDetails.Message) {
            echo "Error details: $($_.ErrorDetails.Message)"
          }
          exit 1
        }
        
        # Test 9: Verify deletion
        echo "`nTest 9: Verifying deletion..."
        try {
          $jsonBody = '{"query":"SELECT * FROM test_table"}'
          $bytes = [System.Text.Encoding]::UTF8.GetBytes($jsonBody)
          $response9 = Invoke-WebRequest -Uri "http://localhost:9308/sql" -Method POST `
            -Body $bytes -ContentType "application/json; charset=utf-8" -UseBasicParsing
          $result = $response9.Content | ConvertFrom-Json
          echo "Response: $($result | ConvertTo-Json -Compress)"
          if ($result.hits.total -eq 1) {
            echo "âœ“ DELETE verified, 1 record remains"
          } else {
            echo "ERROR: Expected 1 record after DELETE, got $($result.hits.total)"
            exit 1
          }
        } catch {
          echo "ERROR: DELETE verification failed: $_"
          if ($_.ErrorDetails.Message) {
            echo "Error details: $($_.ErrorDetails.Message)"
          }
          exit 1
        }
        
        # Test 10: Show tables
        echo "`nTest 10: Testing SHOW TABLES..."
        try {
          $jsonBody = '{"query":"SHOW TABLES"}'
          $bytes = [System.Text.Encoding]::UTF8.GetBytes($jsonBody)
          $response10 = Invoke-WebRequest -Uri "http://localhost:9308/sql" -Method POST `
            -Body $bytes -ContentType "application/json; charset=utf-8" -UseBasicParsing
          $result = $response10.Content | ConvertFrom-Json
          echo "Response: $($result | ConvertTo-Json -Compress)"
          $tableFound = $false
          foreach ($row in $result.data) {
            if ($row.Index -eq "test_table") {
              $tableFound = $true
              break
            }
          }
          if ($tableFound) {
            echo "âœ“ SHOW TABLES successful - test_table found"
          } else {
            echo "ERROR: test_table not found in SHOW TABLES"
            exit 1
          }
        } catch {
          echo "ERROR: SHOW TABLES failed: $_"
          if ($_.ErrorDetails.Message) {
            echo "Error details: $($_.ErrorDetails.Message)"
          }
          exit 1
        }
        
        # Test 11: Drop table
        echo "`nTest 11: Testing DROP TABLE..."
        try {
          $jsonBody = '{"query":"DROP TABLE test_table"}'
          $bytes = [System.Text.Encoding]::UTF8.GetBytes($jsonBody)
          $response11 = Invoke-WebRequest -Uri "http://localhost:9308/sql" -Method POST `
            -Body $bytes -ContentType "application/json; charset=utf-8" -UseBasicParsing
          $result = $response11.Content | ConvertFrom-Json
          echo "Response: $($result | ConvertTo-Json -Compress)"
          echo "âœ“ DROP TABLE successful"
        } catch {
          echo "ERROR: DROP TABLE failed: $_"
          if ($_.ErrorDetails.Message) {
            echo "Error details: $($_.ErrorDetails.Message)"
          }
          exit 1
        }
        
        # Test 12: Verify table dropped
        echo "`nTest 12: Verifying table dropped..."
        try {
          $jsonBody = '{"query":"SHOW TABLES"}'
          $bytes = [System.Text.Encoding]::UTF8.GetBytes($jsonBody)
          $response12 = Invoke-WebRequest -Uri "http://localhost:9308/sql" -Method POST `
            -Body $bytes -ContentType "application/json; charset=utf-8" -UseBasicParsing
          $result = $response12.Content | ConvertFrom-Json
          echo "Response: $($result | ConvertTo-Json -Compress)"
          $tableFound = $false
          if ($result.data) {
            foreach ($row in $result.data) {
              if ($row.Index -eq "test_table") {
                $tableFound = $true
                break
              }
            }
          }
          if (-not $tableFound) {
            echo "âœ“ Table successfully dropped"
          } else {
            echo "ERROR: Table still exists after DROP"
            exit 1
          }
        } catch {
          echo "ERROR: DROP verification failed: $_"
          if ($_.ErrorDetails.Message) {
            echo "Error details: $($_.ErrorDetails.Message)"
          }
          exit 1
        }
        
        # Test MySQL connection if mysql client is available
        $mysqlPath = "C:\tools\mysql\current\bin\mysql.exe"
        if (Test-Path $mysqlPath) {
          echo "=== TESTING MYSQL PROTOCOL ==="
          & $mysqlPath -P9306 -h127.0.0.1 -e "SELECT 1"
          if ($LASTEXITCODE -eq 0) {
            echo "âœ“ MySQL protocol connection successful"
          } else {
            echo "ERROR: MySQL connection failed"
            exit 1
          }
        }
        
        echo ""
        echo "=== ALL TESTS COMPLETED SUCCESSFULLY ==="
        echo "âœ“ Installation verified"
        echo "âœ“ Daemon is running"
        echo "âœ“ All ports are accessible via PowerShell"
        echo "âœ“ HTTP API is functional"
        echo "âœ“ CREATE TABLE works"
        echo "âœ“ INSERT works"
        echo "âœ“ SELECT works"
        echo "âœ“ MATCH search works"
        echo "âœ“ UPDATE works"
        echo "âœ“ DELETE works"
        echo "âœ“ DROP TABLE works"
        echo "âœ“ All basic functionality verified"
      shell: pwsh

  publish_nsis:
    name: Publishing Windows NSIS installer
    needs: [test_windows_installer, publish, pack]
    runs-on: ubuntu-22.04
    steps:
      - uses: manticoresoftware/publish_to_repo@main
        with:
          ssh_key: ${{ secrets.REPO_SSH_KEY }}
          distr:
          arch:
          artifact: win_installer
          type: arc
          delimiter: "-"
          target: ${{ needs.pack.outputs.target }}

  build_docker:
    name: Building and pushing docker
    needs: [publish_debian_ubuntu, pack]
    runs-on: ubuntu-22.04
    env:
      DOCKER_USER: ${{ secrets.DOCKER_USER }}
      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
      GHCR_USER: ${{ secrets.GHCR_USER }}
      GHCR_PASSWORD: ${{ secrets.GHCR_PASSWORD }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      - name: Patch version
        run: |
          sed -i "s/0\.0\.0/${{ needs.pack.outputs.version }}/g" src/sphinxversion.h.in
      - name: Calculate short commit hash
        id: sha
        run: echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          image: tonistiigi/binfmt:qemu-v7.0.0-28
      - name: Building docker
        run: CI_COMMIT_SHORT_SHA=${{ steps.sha.outputs.sha_short }} /bin/bash dist/dockerhub_deploy.sh

  clt_rhel_dev_installation:
    name: Testing RHEL dev packages installation
    needs: publish_rhel
    strategy:
      fail-fast: false
      matrix:
        image: [ "almalinux:8", "almalinux:9", "almalinux:10", "oraclelinux:9", "amazonlinux:latest" ]
    runs-on: ubuntu-22.04
    steps:
      - uses: manticoresoftware/clt@0.6.9
        with:
          image: ${{ matrix.image }}
          test_prefix: test/clt-tests/installation/rhel-dev-
          run_args: -e TELEMETRY=0

  clt_deb_dev_installation:
    name: Testing DEB dev packages installation
    needs: publish_debian_ubuntu
    strategy:
      fail-fast: false
      matrix:
        image: [ "ubuntu:bionic", "ubuntu:focal", "ubuntu:jammy", "debian:bullseye", "debian:bookworm" ]
    runs-on: ubuntu-22.04
    steps:
      - uses: manticoresoftware/clt@0.6.9
        with:
          image: ${{ matrix.image }}
          test_prefix: test/clt-tests/installation/deb-dev-
          run_args: -e TELEMETRY=0
