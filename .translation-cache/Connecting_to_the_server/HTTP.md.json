{
  "89a4d0b05dd4222645dee42143927059536d546d51fa6419b9dcbf1d477dac9e": {
    "original": "While the `/sql` endpoint is useful for controlling Manticore programmatically from your application, there's also the `/cli` endpoint. This makes it easier to **manually maintain a Manticore instance** using curl or your browser. It accepts both POST and GET HTTP methods. Everything inputted after `/cli?` is understood by Manticore, even if it's not manually escaped with curl or automatically encoded by the browser. No `query` parameter is required. Importantly, the `+` sign is not changed to a space, eliminating the need for encoding it. For the POST method, Manticore accepts everything exactly as it is, without any changes. The response is in tabular format, similar to an SQL result set you might see in a MySQL client.\n\n<!-- request POST -->\n\nCODE_BLOCK_18\n\n<!-- response POST -->\n\nCODE_BLOCK_19\n\n<!-- request GET -->\n\nCODE_BLOCK_20\n\n<!-- response GET -->\n\nCODE_BLOCK_21\n\n<!-- request Browser -->\n\n![using /cli in browser](cli_browser.png)\n\n<!-- request curl example -->\n\nCODE_BLOCK_22\n\n<!-- response curl example -->\n\nCODE_BLOCK_23\n\n<!-- end -->\n\n### /cli_json\n\n> NOTE: The `/cli_json` endpoint is designed for manual interaction with Manticore using tools like curl or a browser. It is not intended for use in automated scripts. Use the `/sql` endpoint instead.\n\n<!-- example cli_json -->\n\nThe `/cli_json` endpoint provides the same functionality as `/cli`, but the response format is JSON. It includes:\n\n- `columns` section describing the schema.\n\n- `data` section with the actual data.\n\n- Summary section with \"total\", \"error\", and \"warning\".\n\n<!-- request POST -->\n\nCODE_BLOCK_24\n\n<!-- response POST -->\n\nCODE_BLOCK_25\n\n<!-- request GET -->\n\nCODE_BLOCK_26\n\n<!-- response GET -->\n\nCODE_BLOCK_27\n\n<!-- request curl example -->\n\nCODE_BLOCK_28\n\n<!-- response curl example -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n### Keep-alive\n\nHTTP keep-alive is supported for the `/sql`, `/sql?mode=raw`, and `/cli_json` endpoints, but not for the `/cli` endpoint. This feature enables stateful interactions via the HTTP JSON interface, provided the client also supports keep-alive. For example, using the [/cli_json](../Connecting_to_the_server/HTTP.md#/cli_json) endpoint, you can run a `SHOW META` command after a `SELECT` query, and it will behave similarly to interactions with Manticore through a MySQL client.\n\n<!-- proofread -->",
    "translations": {
      "chinese": "虽然 `/sql` 端点对于从您的应用程序以编程方式控制 Manticore 非常有用，但还有 `/cli` 端点。它使得使用 curl 或浏览器**手动维护 Manticore 实例**变得更容易。它接受 POST 和 GET 两种 HTTP 方法。`/cli?` 之后输入的所有内容都会被 Manticore 理解，即使没有通过 curl 手动转义或浏览器自动编码。无需 `query` 参数。重要的是，`+` 符号不会被转换为空格，消除了对其进行编码的需求。对于 POST 方法，Manticore 接受所有内容，完全不做任何更改。响应以表格格式返回，类似于您在 MySQL 客户端中看到的 SQL 结果集。\n\n<!-- request POST -->\n\nCODE_BLOCK_18\n\n<!-- response POST -->\n\nCODE_BLOCK_19\n\n<!-- request GET -->\n\nCODE_BLOCK_20\n\n<!-- response GET -->\n\nCODE_BLOCK_21\n\n<!-- request Browser -->\n\n![using /cli in browser](cli_browser.png)\n\n<!-- request curl example -->\n\nCODE_BLOCK_22\n\n<!-- response curl example -->\n\nCODE_BLOCK_23\n\n<!-- end -->\n\n### /cli_json\n\n> 注意：`/cli_json` 端点设计用于使用 curl 或浏览器等工具与 Manticore 进行手动交互。不适合用于自动化脚本。请改用 `/sql` 端点。\n\n<!-- example cli_json -->\n\n`/cli_json` 端点提供与 `/cli` 相同的功能，但响应格式为 JSON。它包括：\n\n- 描述模式的 `columns` 部分。\n\n- 包含实际数据的 `data` 部分。\n\n- 包含 “total”、“error” 和 “warning” 的摘要部分。\n\n<!-- request POST -->\n\nCODE_BLOCK_24\n\n<!-- response POST -->\n\nCODE_BLOCK_25\n\n<!-- request GET -->\n\nCODE_BLOCK_26\n\n<!-- response GET -->\n\nCODE_BLOCK_27\n\n<!-- request curl example -->\n\nCODE_BLOCK_28\n\n<!-- response curl example -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n### Keep-alive\n\nHTTP keep-alive 支持 `/sql`、`/sql?mode=raw` 和 `/cli_json` 端点，但不支持 `/cli` 端点。此功能使得通过 HTTP JSON 接口进行有状态交互成为可能，前提是客户端也支持 keep-alive。例如，使用 [/cli_json](../Connecting_to_the_server/HTTP.md#/cli_json) 端点，您可以在执行 `SELECT` 查询后运行 `SHOW META` 命令，其行为类似于通过 MySQL 客户端与 Manticore 的交互。\n\n<!-- proofread -->",
      "russian": "While the `/sql` endpoint is useful for controlling Manticore programmatically from your application, there's also the `/cli` endpoint. This makes it easier to **manually maintain a Manticore instance** using curl or your browser. It accepts both POST and GET HTTP methods. Everything inputted after `/cli?` is understood by Manticore, even if it's not manually escaped with curl or automatically encoded by the browser. No `query` parameter is required. Importantly, the `+` sign is not changed to a space, eliminating the need for encoding it. For the POST method, Manticore accepts everything exactly as it is, without any changes. The response is in tabular format, similar to an SQL result set you might see in a MySQL client.\n\n<!-- request POST -->\n\nCODE_BLOCK_18\n\n<!-- response POST -->\n\nCODE_BLOCK_19\n\n<!-- request GET -->\n\nCODE_BLOCK_20\n\n<!-- response GET -->\n\nCODE_BLOCK_21\n\n<!-- request Browser -->\n\n![using /cli in browser](cli_browser.png)\n\n<!-- request curl example -->\n\nCODE_BLOCK_22\n\n<!-- response curl example -->\n\nCODE_BLOCK_23\n\n<!-- end -->\n\n### /cli_json\n\n> NOTE: The `/cli_json` endpoint is designed for manual interaction with Manticore using tools like curl or a browser. It is not intended for use in automated scripts. Use the `/sql` endpoint instead.\n\n<!-- example cli_json -->\n\nThe `/cli_json` endpoint provides the same functionality as `/cli`, but the response format is JSON. It includes:\n\n- `columns` section describing the schema.\n\n- `data` section with the actual data.\n\n- Summary section with \"total\", \"error\", and \"warning\".\n\n<!-- request POST -->\n\nCODE_BLOCK_24\n\n<!-- response POST -->\n\nCODE_BLOCK_25\n\n<!-- request GET -->\n\nCODE_BLOCK_26\n\n<!-- response GET -->\n\nCODE_BLOCK_27\n\n<!-- request curl example -->\n\nCODE_BLOCK_28\n\n<!-- response curl example -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n### Keep-alive\n\nHTTP keep-alive is supported for the `/sql`, `/sql?mode=raw`, and `/cli_json` endpoints, but not for the `/cli` endpoint. This feature enables stateful interactions via the HTTP JSON interface, provided the client also supports keep-alive. For example, using the [/cli_json](../Connecting_to_the_server/HTTP.md#/cli_json) endpoint, you can run a `SHOW META` command after a `SELECT` query, and it will behave similarly to interactions with Manticore through a MySQL client.\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "66f6efeba16ed88382b93bbedf5a424055f2c1c1edf833516f871a3d1adcf26f": {
    "original": "# HTTP\n\nYou can connect to Manticore Search through HTTP/HTTPS.\n\n## Configuration\n\n<!-- example HTTP -->\n\nBy default, Manticore listens for HTTP, HTTPS, and binary requests on ports 9308 and 9312.\n\nIn the \"searchd\" section of your configuration file, you can define the HTTP port using the `listen` directive as follows:\n\nBoth lines are valid and have the same meaning (except for the port number). They both define listeners that will serve all API/HTTP/HTTPS protocols. There are no special requirements, and any HTTP client can be used to connect to Manticore.\n\n<!-- request HTTP -->\n\nCODE_BLOCK_0\n\n<!-- end -->\n\nAll HTTP endpoints return `application/json` content type. For the most part, endpoints use JSON payloads for requests. However, there are some exceptions that use NDJSON or simple URL-encoded payloads.\n\nCurrently, there is no user authentication. Therefore, make sure that the HTTP interface is not accessible to anyone outside your network. As Manticore functions like any other web server, you can use a reverse proxy, such as Nginx, to implement HTTP authentication or caching.\n\n<!-- example HTTPS -->\n\nThe HTTP protocol also supports [SSL encryption](../Security/SSL.md):\n\nIf you specify `:https` instead of `:http` **only** secured connections will be accepted. Otherwise in case of no valid key/certificate provided, but the client trying to connect via https - the connection will be dropped. If you make not HTTPS, but an HTTP request to 9443 it will respond with HTTP code 400.\n\n<!-- request HTTPS -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n### VIP Connection\n\n<!-- example VIP -->\n\nSeparate HTTP interface can be used for 'VIP' connections. In this case, the connection bypasses a thread pool and always creates a new dedicated thread. This is useful for managing Manticore Search during periods of severe overload when the server might stall or not allow regular port connections.\n\nFor more information on the `listen` directive, see [this section](../Server_settings/Searchd.md#listen).\n\n<!-- request VIP -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n## SQL over HTTP\n\nManticore provides `/sql`, `/cli`, and `/cli_json` endpoints for running SQL queries over HTTP. Each endpoint is designed for specific use cases:\n\n* `/sql`: Suitable for programmatic usage from applications.\n\n  - The `/sql` endpoint accepts only SELECT statements and returns the response in HTTP JSON format.\n\n  - The `/sql?mode=raw` endpoint accepts any SQL query and returns the response in raw format, similar to what you would receive via mysql.\n\n* `/cli`: Intended **only for manual use** (e.g., via curl or browser). **Not recommended for scripts.**\n\n* `/cli_json`: Similar to `/cli`, but returns results in JSON format. **Not recommended for scripts.**\n\n### /sql\n\n<!-- example SQL_over_HTTP -->\n\nGeneral syntax:\n\n* `curl \"localhost:6780/sql[?mode=raw]&query={URL_ENCODED_QUERY}\"`\n\n* `curl localhost:6780/sql[?mode=raw] -d \"[query={URL_ENCODED_QUERY}|{NOT_URL_ENCODED_QUERY}]\"`\n\nThe `/sql` endpoint accepts an SQL query via the HTTP JSON interface:\n\n* Without `mode=raw`- only [SELECTs](../Searching/Full_text_matching/Basic_usage.md#SQL) are allowed, returning the response in JSON format.\n\n* With [mode=raw](../Connecting_to_the_server/HTTP.md#mode=raw) - any SQL query is permitted, returning the response in raw format.\n\nThe endpoint can handle HTTP requests using either the GET or the POST method. For sending queries, you can:\n\n1. **Using GET:** Include the query in the `query` parameter of the URL, like `/sql?query=your_encoded_query_here`. It's **important to URL encode** this parameter to avoid errors, especially if the query includes an `=` sign, which might be interpreted as part of the URL syntax rather than the query.\n\n2. **Using POST:** You can also send the query within the body of a POST request. When using this method:\n\n   - If you send the query as a parameter named `query`, **ensure it is URL encoded**.\n\n   - If you send the query directly as plain text (a raw POST body), **do not URL encode it**. This is useful when the query is long or complex, or if the query is stored in a file and you want to send it as is by pointing your HTTP client (e.g., `curl`) to it.\n\nThis approach keeps the usage of GET and POST distinct and avoids any confusion about combining methods in a single request.\n\nWithout `mode=raw` the response is a JSON containing information about the hits and the execution time. The response format is the same as the [json/search](../Searching/Full_text_matching/Basic_usage.md#HTTP-JSON) endpoint. Note that the `/sql` endpoint only supports single search requests. For processing a multi-query, see the section below about the [raw mode](../Connecting_to_the_server/HTTP.md#mode=raw).\n\n<!-- request POST -->\n\nCODE_BLOCK_3\n\n<!-- response POST -->\n\nCODE_BLOCK_4\n\n<!-- request POST URL-encoded -->\n\nCODE_BLOCK_5\n\n<!-- response POST URL-encoded -->\n\nCODE_BLOCK_6\n\n<!-- request GET URL-encoded -->\n\nCODE_BLOCK_7\n\n<!-- response GET URL-encoded -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n#### mode=raw\n\n<!-- example mode=raw -->\n\nThe `/sql` endpoint also includes a special \"raw\" mode, which allows you to send **any valid SQL queries, including multi-queries**. The response is a JSON array containing one or more result sets. You can activate this mode by using the option `mode=raw`.\n\n<!-- request POST -->\n\nCODE_BLOCK_9\n\n<!-- response POST -->\n\nCODE_BLOCK_10\n\n<!-- request POST URL-encoded -->\n\nCODE_BLOCK_11\n\n<!-- response POST URL-encoded -->\n\nCODE_BLOCK_12\n\n<!-- request POST URL-encoded 2nd way -->\n\nCODE_BLOCK_13\n\n<!-- response POST URL-encoded 2nd way -->\n\nCODE_BLOCK_14\n\n<!-- request GET URL-encoded -->\n\nCODE_BLOCK_15\n\n<!-- response GET URL-encoded -->\n\nCODE_BLOCK_16\n\n<!-- request curl examples -->\n\nCODE_BLOCK_17\n\n<!-- end -->\n\n### /cli\n\n<!-- example cli -->\n\n> NOTE: `/cli` requires [Manticore Buddy](../Installation/Manticore_Buddy.md). If it doesn't work, make sure Buddy is installed.\n\n> NOTE: The `/cli` endpoint is designed for manual interaction with Manticore using tools like curl or a browser. It is not intended for use in automated scripts. Use the `/sql` endpoint instead.",
    "translations": {
      "chinese": "# HTTP\n\n您可以通过 HTTP/HTTPS 连接到 Manticore Search。\n\n## 配置\n\n<!-- example HTTP -->\n\n默认情况下，Manticore 在端口 9308 和 9312 上监听 HTTP、HTTPS 和二进制请求。\n\n在配置文件的 \"searchd\" 部分，您可以使用 `listen` 指令定义 HTTP 端口，如下所示：\n\n这两行都是有效的，且含义相同（端口号除外）。它们都定义了将服务所有 API/HTTP/HTTPS 协议的监听器。没有特殊要求，任何 HTTP 客户端都可以用来连接 Manticore。\n\n<!-- request HTTP -->\n\nCODE_BLOCK_0\n\n<!-- end -->\n\n所有 HTTP 端点返回 `application/json` 内容类型。大多数情况下，端点使用 JSON 负载进行请求。然而，也有一些例外，使用 NDJSON 或简单的 URL 编码负载。\n\n目前没有用户认证。因此，请确保 HTTP 接口不对网络外部的任何人开放。由于 Manticore 的功能类似于其他 Web 服务器，您可以使用反向代理（如 Nginx）来实现 HTTP 认证或缓存。\n\n<!-- example HTTPS -->\n\nHTTP 协议也支持 [SSL 加密](../Security/SSL.md)：\n\n如果您指定 `:https` 而不是 `:http`，**只接受安全连接**。否则，如果没有提供有效的密钥/证书，但客户端尝试通过 https 连接，连接将被断开。如果您对 9443 端口发起非 HTTPS 而是 HTTP 请求，它将返回 HTTP 代码 400。\n\n<!-- request HTTPS -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n### VIP 连接\n\n<!-- example VIP -->\n\n可以为“VIP”连接使用单独的 HTTP 接口。在这种情况下，连接绕过线程池，总是创建一个新的专用线程。这在服务器严重过载、可能停滞或不允许常规端口连接时管理 Manticore Search 非常有用。\n\n有关 `listen` 指令的更多信息，请参见[本节](../Server_settings/Searchd.md#listen)。\n\n<!-- request VIP -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n## 通过 HTTP 使用 SQL\n\nManticore 提供 `/sql`、`/cli` 和 `/cli_json` 端点，用于通过 HTTP 运行 SQL 查询。每个端点针对特定用例设计：\n\n* `/sql`：适合应用程序的编程使用。\n\n  - `/sql` 端点仅接受 SELECT 语句，并以 HTTP JSON 格式返回响应。\n\n  - `/sql?mode=raw` 端点接受任何 SQL 查询，并以原始格式返回响应，类似于通过 mysql 接收的格式。\n\n* `/cli`：仅供手动使用（例如通过 curl 或浏览器）。**不推荐用于脚本。**\n\n* `/cli_json`：类似于 `/cli`，但以 JSON 格式返回结果。**不推荐用于脚本。**\n\n### /sql\n\n<!-- example SQL_over_HTTP -->\n\n通用语法：\n\n* `curl \"localhost:6780/sql[?mode=raw]&query={URL_ENCODED_QUERY}\"`\n\n* `curl localhost:6780/sql[?mode=raw] -d \"[query={URL_ENCODED_QUERY}|{NOT_URL_ENCODED_QUERY}]\"`\n\n`/sql` 端点通过 HTTP JSON 接口接受 SQL 查询：\n\n* 不带 `mode=raw` - 只允许 [SELECT](../Searching/Full_text_matching/Basic_usage.md#SQL) 语句，返回 JSON 格式响应。\n\n* 带有 [mode=raw](../Connecting_to_the_server/HTTP.md#mode=raw) - 允许任何 SQL 查询，返回原始格式响应。\n\n该端点可以使用 GET 或 POST 方法处理 HTTP 请求。发送查询时，您可以：\n\n1. **使用 GET：** 将查询包含在 URL 的 `query` 参数中，如 `/sql?query=your_encoded_query_here`。**重要的是对该参数进行 URL 编码**，以避免错误，特别是当查询中包含 `=` 符号时，否则可能被解释为 URL 语法的一部分而非查询内容。\n\n2. **使用 POST：** 您也可以在 POST 请求的正文中发送查询。使用此方法时：\n\n   - 如果将查询作为名为 `query` 的参数发送，**确保它是 URL 编码的**。\n\n   - 如果直接以纯文本（原始 POST 正文）发送查询，**不要进行 URL 编码**。当查询较长或复杂，或者查询存储在文件中并希望通过指向该文件的 HTTP 客户端（例如 `curl`）直接发送时，这种方式很有用。\n\n这种方法保持了 GET 和 POST 的使用区分，避免了在单个请求中混合方法的混淆。\n\n不带 `mode=raw` 时，响应是包含命中信息和执行时间的 JSON。响应格式与 [json/search](../Searching/Full_text_matching/Basic_usage.md#HTTP-JSON) 端点相同。请注意，`/sql` 端点仅支持单个搜索请求。有关处理多查询，请参见下面关于 [raw 模式](../Connecting_to_the_server/HTTP.md#mode=raw) 的部分。\n\n<!-- request POST -->\n\nCODE_BLOCK_3\n\n<!-- response POST -->\n\nCODE_BLOCK_4\n\n<!-- request POST URL-encoded -->\n\nCODE_BLOCK_5\n\n<!-- response POST URL-encoded -->\n\nCODE_BLOCK_6\n\n<!-- request GET URL-encoded -->\n\nCODE_BLOCK_7\n\n<!-- response GET URL-encoded -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n#### mode=raw\n\n<!-- example mode=raw -->\n\n`/sql` 端点还包括一个特殊的“raw”模式，允许您发送**任何有效的 SQL 查询，包括多查询**。响应是一个包含一个或多个结果集的 JSON 数组。您可以通过使用选项 `mode=raw` 来激活此模式。\n\n<!-- request POST -->\n\nCODE_BLOCK_9\n\n<!-- response POST -->\n\nCODE_BLOCK_10\n\n<!-- request POST URL-encoded -->\n\nCODE_BLOCK_11\n\n<!-- response POST URL-encoded -->\n\nCODE_BLOCK_12\n\n<!-- request POST URL-encoded 2nd way -->\n\nCODE_BLOCK_13\n\n<!-- response POST URL-encoded 2nd way -->\n\nCODE_BLOCK_14\n\n<!-- request GET URL-encoded -->\n\nCODE_BLOCK_15\n\n<!-- response GET URL-encoded -->\n\nCODE_BLOCK_16\n\n<!-- request curl examples -->\n\nCODE_BLOCK_17\n\n<!-- end -->\n\n### /cli\n\n<!-- example cli -->\n\n> 注意：`/cli` 需要 [Manticore Buddy](../Installation/Manticore_Buddy.md)。如果无法使用，请确保已安装 Buddy。\n\n> 注意：`/cli` 端点设计用于使用 curl 或浏览器等工具手动与 Manticore 交互。不适合自动化脚本使用。请改用 `/sql` 端点。",
      "russian": "# HTTP\n\nВы можете подключаться к Manticore Search через HTTP/HTTPS.\n\n## Конфигурация\n\n<!-- example HTTP -->\n\nПо умолчанию Manticore слушает HTTP, HTTPS и бинарные запросы на портах 9308 и 9312.\n\nВ разделе \"searchd\" вашего конфигурационного файла вы можете определить HTTP-порт с помощью директивы `listen` следующим образом:\n\nОбе строки допустимы и имеют одинаковое значение (за исключением номера порта). Обе они определяют слушатели, которые будут обслуживать все протоколы API/HTTP/HTTPS. Нет никаких специальных требований, и любой HTTP-клиент может использоваться для подключения к Manticore.\n\n<!-- request HTTP -->\n\nCODE_BLOCK_0\n\n<!-- end -->\n\nВсе HTTP-эндпоинты возвращают контент типа `application/json`. В основном, эндпоинты используют JSON-пейлоады для запросов. Однако есть некоторые исключения, которые используют NDJSON или простые URL-кодированные пейлоады.\n\nВ настоящее время нет аутентификации пользователей. Поэтому убедитесь, что HTTP-интерфейс недоступен для всех вне вашей сети. Поскольку Manticore функционирует как любой другой веб-сервер, вы можете использовать обратный прокси, например Nginx, для реализации HTTP-аутентификации или кэширования.\n\n<!-- example HTTPS -->\n\nHTTP-протокол также поддерживает [SSL-шифрование](../Security/SSL.md):\n\nЕсли вы укажете `:https` вместо `:http`, **будут приниматься только защищённые соединения**. В противном случае, если не предоставлен действительный ключ/сертификат, а клиент пытается подключиться через https — соединение будет разорвано. Если вы сделаете не HTTPS, а HTTP-запрос на 9443, он ответит HTTP-кодом 400.\n\n<!-- request HTTPS -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n### VIP-подключение\n\n<!-- example VIP -->\n\nОтдельный HTTP-интерфейс может использоваться для 'VIP' подключений. В этом случае соединение обходит пул потоков и всегда создаёт новый выделенный поток. Это полезно для управления Manticore Search в периоды сильной перегрузки, когда сервер может зависать или не разрешать обычные подключения к порту.\n\nДля получения дополнительной информации о директиве `listen` смотрите [этот раздел](../Server_settings/Searchd.md#listen).\n\n<!-- request VIP -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n## SQL через HTTP\n\nManticore предоставляет эндпоинты `/sql`, `/cli` и `/cli_json` для выполнения SQL-запросов через HTTP. Каждый эндпоинт предназначен для определённых случаев использования:\n\n* `/sql`: Подходит для программного использования из приложений.\n\n  - Эндпоинт `/sql` принимает только SELECT-запросы и возвращает ответ в формате HTTP JSON.\n\n  - Эндпоинт `/sql?mode=raw` принимает любой SQL-запрос и возвращает ответ в сыром формате, аналогично тому, что вы получили бы через mysql.\n\n* `/cli`: Предназначен **только для ручного использования** (например, через curl или браузер). **Не рекомендуется для скриптов.**\n\n* `/cli_json`: Похож на `/cli`, но возвращает результаты в формате JSON. **Не рекомендуется для скриптов.**\n\n### /sql\n\n<!-- example SQL_over_HTTP -->\n\nОбщий синтаксис:\n\n* `curl \"localhost:6780/sql[?mode=raw]&query={URL_ENCODED_QUERY}\"`\n\n* `curl localhost:6780/sql[?mode=raw] -d \"[query={URL_ENCODED_QUERY}|{NOT_URL_ENCODED_QUERY}]\"`\n\nЭндпоинт `/sql` принимает SQL-запрос через HTTP JSON интерфейс:\n\n* Без `mode=raw` разрешены только [SELECT](../Searching/Full_text_matching/Basic_usage.md#SQL), возвращая ответ в формате JSON.\n\n* С [mode=raw](../Connecting_to_the_server/HTTP.md#mode=raw) разрешён любой SQL-запрос, возвращая ответ в сыром формате.\n\nЭндпоинт может обрабатывать HTTP-запросы как методом GET, так и POST. Для отправки запросов вы можете:\n\n1. **Используя GET:** Включите запрос в параметр `query` URL, например `/sql?query=your_encoded_query_here`. Важно **кодировать этот параметр в URL**, чтобы избежать ошибок, особенно если запрос содержит знак `=`, который может быть интерпретирован как часть синтаксиса URL, а не запроса.\n\n2. **Используя POST:** Вы также можете отправить запрос в теле POST-запроса. При использовании этого метода:\n\n   - Если вы отправляете запрос как параметр с именем `query`, **убедитесь, что он URL-кодирован**.\n\n   - Если вы отправляете запрос напрямую как простой текст (сырой POST body), **не кодируйте его в URL**. Это полезно, когда запрос длинный или сложный, или если запрос хранится в файле и вы хотите отправить его как есть, указав HTTP-клиенту (например, `curl`) на этот файл.\n\nТакой подход сохраняет различие между использованием GET и POST и избегает путаницы при комбинировании методов в одном запросе.\n\nБез `mode=raw` ответ — это JSON, содержащий информацию о найденных совпадениях и времени выполнения. Формат ответа такой же, как у эндпоинта [json/search](../Searching/Full_text_matching/Basic_usage.md#HTTP-JSON). Обратите внимание, что эндпоинт `/sql` поддерживает только одиночные поисковые запросы. Для обработки мультизапроса смотрите раздел ниже о [сыром режиме](../Connecting_to_the_server/HTTP.md#mode=raw).\n\n<!-- request POST -->\n\nCODE_BLOCK_3\n\n<!-- response POST -->\n\nCODE_BLOCK_4\n\n<!-- request POST URL-encoded -->\n\nCODE_BLOCK_5\n\n<!-- response POST URL-encoded -->\n\nCODE_BLOCK_6\n\n<!-- request GET URL-encoded -->\n\nCODE_BLOCK_7\n\n<!-- response GET URL-encoded -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n#### mode=raw\n\n<!-- example mode=raw -->\n\nЭндпоинт `/sql` также включает специальный \"сырой\" режим, который позволяет отправлять **любые валидные SQL-запросы, включая мультизапросы**. Ответ — это JSON-массив, содержащий один или несколько наборов результатов. Вы можете активировать этот режим, используя опцию `mode=raw`.\n\n<!-- request POST -->\n\nCODE_BLOCK_9\n\n<!-- response POST -->\n\nCODE_BLOCK_10\n\n<!-- request POST URL-encoded -->\n\nCODE_BLOCK_11\n\n<!-- response POST URL-encoded -->\n\nCODE_BLOCK_12\n\n<!-- request POST URL-encoded 2nd way -->\n\nCODE_BLOCK_13\n\n<!-- response POST URL-encoded 2nd way -->\n\nCODE_BLOCK_14\n\n<!-- request GET URL-encoded -->\n\nCODE_BLOCK_15\n\n<!-- response GET URL-encoded -->\n\nCODE_BLOCK_16\n\n<!-- request curl examples -->\n\nCODE_BLOCK_17\n\n<!-- end -->\n\n### /cli\n\n<!-- example cli -->\n\n> ПРИМЕЧАНИЕ: `/cli` требует [Manticore Buddy](../Installation/Manticore_Buddy.md). Если он не работает, убедитесь, что Buddy установлен.\n\n> ПРИМЕЧАНИЕ: Эндпоинт `/cli` предназначен для ручного взаимодействия с Manticore с помощью таких инструментов, как curl или браузер. Он не предназначен для использования в автоматизированных скриптах. Используйте вместо него эндпоинт `/sql`."
    },
    "is_code_or_comment": false
  },
  "dc8e682a3b7a69fd8828cf334cfa622e21e18e96dcc22bf30c1b8d88b1996756": {
    "original": "While the `/sql` endpoint is useful for controlling Manticore programmatically from your application, there's also the `/cli` endpoint. This makes it easier to **manually maintain a Manticore instance** using curl or your browser. It accepts both POST and GET HTTP methods. Everything inputted after `/cli?` is understood by Manticore, even if it's not manually escaped with curl or automatically encoded by the browser. No `query` parameter is required. Importantly, the `+` sign is not changed to a space, eliminating the need for encoding it. For the POST method, Manticore accepts everything exactly as it is, without any changes. The response is in tabular format, similar to an SQL result set you might see in a MySQL client.\n\n<!-- request POST -->\n\nCODE_BLOCK_18\n\n<!-- response POST -->\n\nCODE_BLOCK_19\n\n<!-- request GET -->\n\nCODE_BLOCK_20\n\n<!-- response GET -->\n\nCODE_BLOCK_21\n\n<!-- request Browser -->\n\n![using /cli in browser](cli_browser.png)\n\n<!-- request curl example -->\n\nCODE_BLOCK_22\n\n<!-- response curl example -->\n\nCODE_BLOCK_23\n\n<!-- end -->\n\n### /cli_json\n\n> NOTE: The `/cli_json` endpoint is designed for manual interaction with Manticore using tools like curl or a browser. It is not intended for use in automated scripts. Use the `/sql` endpoint instead.\n\n<!-- example cli_json -->\n\nThe `/cli_json` endpoint provides the same functionality as `/cli`, but the response format is JSON. It includes:\n\n- `columns` section describing the schema.\n\n- `data` section with the actual data.\n\n- Summary section with \"total\", \"error\", and \"warning\".\n\n<!-- request POST -->\n\nCODE_BLOCK_24\n\n<!-- response POST -->\n\nCODE_BLOCK_25\n\n<!-- request GET -->\n\nCODE_BLOCK_26\n\n<!-- response GET -->\n\nCODE_BLOCK_27\n\n<!-- request curl example -->\n\nCODE_BLOCK_28\n\n<!-- response curl example -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n### Persistent connections\n\nPersistent connection imply, client send not only one query and then drop connection, but keep connection established, and send many queries. So, name resolving (if any) happened only once; tcp window size is also established. Also, daemon may provide connection-wide state, like meta-info and profile of previous queries.\n\nIf you connect via HTTP 1.0 proto, you need to add `connection: keep-alive` header.\n\nIf you connect via HTTP 1.1 proto, connection will be persistent by default. In this case, in terminating query it is desirable to add header `connection: close`, to explicitly say that you've finished and connection then dropped.\n\n### HTTP state\n\nOn established connection daemon keep some state and may provide it for later queries.\n\nState is kept for the `/sql`, `/sql?mode=raw`, and `/cli_json` endpoints, but not for the `/cli` endpoint. This feature enables stateful interactions via the HTTP JSON interface. For example, using the [/cli_json](../Connecting_to_the_server/HTTP.md#/cli_json) endpoint, you can run a `SHOW META` command after a `SELECT` query, and it will behave similarly to interactions with Manticore through a MySQL client.\n\nTo run multiple queries using sphinxql via one connection with curl, you need to write your commands with `--next` key:\n\nCODE_BLOCK_30\n\nNotice; this will NOT work:\n\nCODE_BLOCK_31\n\nBecause it is special case, batch of queries, or  [multi-query](../Searching/Multi-queries.md), with its own benefits and limitations.",
    "translations": {
      "chinese": "尽管 `/sql` 端点对于从您的应用程序以编程方式控制 Manticore 非常有用，但还有 `/cli` 端点。它使得使用 curl 或您的浏览器**手动维护 Manticore 实例**更加简单。它接受 POST 和 GET 两种 HTTP 方法。所有输入在 `/cli?` 之后的内容都会被 Manticore 识别，即使没有用 curl 手动转义或浏览器自动编码也没关系。无需 `query` 参数。重要的是，`+` 符号不会被转换为空格，消除了对其编码的需求。对于 POST 方法，Manticore 会完全原样接受所有内容，不作任何更改。响应以表格格式返回，类似于您在 MySQL 客户端中看到的 SQL 结果集。\n\n<!-- request POST -->\n\nCODE_BLOCK_18\n\n<!-- response POST -->\n\nCODE_BLOCK_19\n\n<!-- request GET -->\n\nCODE_BLOCK_20\n\n<!-- response GET -->\n\nCODE_BLOCK_21\n\n<!-- request Browser -->\n\n![using /cli in browser](cli_browser.png)\n\n<!-- request curl example -->\n\nCODE_BLOCK_22\n\n<!-- response curl example -->\n\nCODE_BLOCK_23\n\n<!-- end -->\n\n### /cli_json\n\n> 注意：`/cli_json` 端点设计用于使用 curl 或浏览器等工具与 Manticore 进行手动交互。不建议用于自动化脚本，自动化脚本请使用 `/sql` 端点。\n\n<!-- example cli_json -->\n\n`/cli_json` 端点提供与 `/cli` 相同的功能，但响应格式为 JSON。它包括：\n\n- 描述模式的 `columns` 部分。\n\n- 包含实际数据的 `data` 部分。\n\n- 总结部分，包括 \"total\"、\"error\" 和 \"warning\"。\n\n<!-- request POST -->\n\nCODE_BLOCK_24\n\n<!-- response POST -->\n\nCODE_BLOCK_25\n\n<!-- request GET -->\n\nCODE_BLOCK_26\n\n<!-- response GET -->\n\nCODE_BLOCK_27\n\n<!-- request curl example -->\n\nCODE_BLOCK_28\n\n<!-- response curl example -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n### 持久连接\n\n持久连接意味着客户端不仅发送一个查询然后断开连接，而是保持连接建立状态，并发送多个查询。因此，名称解析（如果有）只发生一次；TCP 窗口大小也得以维持。同时，守护进程可能为整个连接提供状态，比如前一个查询的元信息和配置文件。\n\n如果你通过 HTTP 1.0 协议连接，需要添加 `connection: keep-alive` 头。\n\n如果你通过 HTTP 1.1 协议连接，连接默认是持久的。在终止查询时，建议添加头 `connection: close`，以明确表示你已完成操作，连接随后会被断开。\n\n### HTTP 状态\n\n在已建立的连接上，守护进程保持一些状态，并可为后续查询提供。\n\n状态会被保留在 `/sql`、`/sql?mode=raw` 和 `/cli_json` 端点，但不保留在 `/cli` 端点。此功能支持通过 HTTP JSON 接口进行有状态交互。例如，通过使用 [/cli_json](../Connecting_to_the_server/HTTP.md#/cli_json) 端点，在进行 `SELECT` 查询后运行 `SHOW META` 命令，其行为类似于通过 MySQL 客户端与 Manticore 的交互。\n\n要通过 curl 使用单个连接运行多个 sphinxql 查询，需要使用 `--next` 关键字编写命令：\n\nCODE_BLOCK_30\n\n注意；下面的写法将不会工作：\n\nCODE_BLOCK_31\n\n因为这是一个特殊情况——查询批处理，或[多查询](../Searching/Multi-queries.md)，具有其自身的优点和局限。",
      "russian": "В то время как конечная точка `/sql` полезна для программного управления Manticore из вашего приложения, существует также конечная точка `/cli`. Это упрощает **ручное управление экземпляром Manticore** с помощью curl или браузера. Она принимает оба HTTP метода POST и GET. Всё, что вводится после `/cli?`, понимается Manticore, даже если это не экранировано вручную с помощью curl или не кодируется автоматически браузером. Параметр `query` не требуется. Важно, что знак `+` не преобразуется в пробел, что устраняет необходимость его кодирования. Для метода POST Manticore принимает всё точно таким, какое оно есть, без изменений. Ответ представлен в табличном формате, аналогичном результату SQL запроса, который вы можете видеть в MySQL клиенте.\n\n<!-- request POST -->\n\nCODE_BLOCK_18\n\n<!-- response POST -->\n\nCODE_BLOCK_19\n\n<!-- request GET -->\n\nCODE_BLOCK_20\n\n<!-- response GET -->\n\nCODE_BLOCK_21\n\n<!-- request Browser -->\n\n![using /cli in browser](cli_browser.png)\n\n<!-- request curl example -->\n\nCODE_BLOCK_22\n\n<!-- response curl example -->\n\nCODE_BLOCK_23\n\n<!-- end -->\n\n### /cli_json\n\n> ПРИМЕЧАНИЕ: Конечная точка `/cli_json` предназначена для ручного взаимодействия с Manticore с помощью таких инструментов, как curl или браузер. Она не предназначена для использования в автоматизированных скриптах. Вместо этого используйте конечную точку `/sql`.\n\n<!-- example cli_json -->\n\nКонечная точка `/cli_json` предоставляет ту же функциональность, что и `/cli`, но формат ответа — JSON. Она включает:\n\n- раздел `columns`, описывающий схему.\n\n- раздел `data` с актуальными данными.\n\n- раздел сводки с \"total\", \"error\" и \"warning\".\n\n<!-- request POST -->\n\nCODE_BLOCK_24\n\n<!-- response POST -->\n\nCODE_BLOCK_25\n\n<!-- request GET -->\n\nCODE_BLOCK_26\n\n<!-- response GET -->\n\nCODE_BLOCK_27\n\n<!-- request curl example -->\n\nCODE_BLOCK_28\n\n<!-- response curl example -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n### Постоянные соединения\n\nПостоянные соединения означают, что клиент отправляет не один запрос и затем закрывает соединение, а держит соединение открытым и отправляет много запросов. Таким образом, разрешение имени (если есть) происходит только один раз; также устанавливается размер TCP окна. Кроме того, демон может предоставлять состояние, распространяющееся на всё соединение, например мета-информацию и профиль предыдущих запросов.\n\nЕсли вы подключаетесь по протоколу HTTP 1.0, необходимо добавить заголовок `connection: keep-alive`.\n\nЕсли вы подключаетесь по протоколу HTTP 1.1, соединение по умолчанию будет постоянным. В этом случае в завершающем запросе желательно добавить заголовок `connection: close`, чтобы явно указать, что вы завершили, и затем соединение будет закрыто.\n\n### Состояние HTTP\n\nПри установленном соединении демон сохраняет некоторое состояние и может предоставлять его для последующих запросов.\n\nСостояние сохраняется для конечных точек `/sql`, `/sql?mode=raw` и `/cli_json`, но не для конечной точки `/cli`. Эта функция позволяет реализовать состояние при взаимодействиях через HTTP JSON интерфейс. Например, используя конечную точку [/cli_json](../Connecting_to_the_server/HTTP.md#/cli_json), вы можете выполнить команду `SHOW META` после запроса `SELECT`, и это будет вести себя аналогично взаимодействию с Manticore через MySQL клиент.\n\nЧтобы выполнить несколько запросов, используя sphinxql через одно соединение с curl, нужно писать команды с ключом `--next`:\n\nCODE_BLOCK_30\n\nОбратите внимание; это НЕ сработает:\n\nCODE_BLOCK_31\n\nПотому что это особый случай — пакет запросов, или [мульти-запрос](../Searching/Multi-queries.md), со своими преимуществами и ограничениями."
    },
    "is_code_or_comment": false
  }
}
