{
  "a02dade0abc08c418ca08821580e7e39a9a691ecf57bc2e64ab2e05fd13d9122": {
    "original": "# Adding a distributed table with remote agents\n\nTo understand how to add a distributed table with remote agents, it is important to first have a basic understanding of  [distributed tables](../Creating_a_table/Creating_a_distributed_table/Creating_a_distributed_table.md) In this article, we will focus on how to use a distributed table as the basis for creating a cluster of Manticore instances.\n\n<!-- example conf dist 1 -->\n\nHere is an example of how to split data over 4 servers, each serving one of the shards:\n\n<!-- intro -->\n\n##### ini:\n\n<!-- request ini -->\n\nCODE_BLOCK_0\n\n<!-- end -->\n\nIn the event of a server failure, the distributed table will still work, but the results from the failed shard will be missing.\n\n<!-- example conf dist 2 -->\n\nNow that we've added mirrors, each shard is found on 2 servers. By default, the master (the searchd instance with the distributed table) will randomly pick one of the mirrors.\n\nThe mode used for picking mirrors can be set using the [ha_strategy](../Creating_a_cluster/Remote_nodes/Load_balancing.md#ha_strategy) setting. In addition to the default `random` mode there's also `ha_strategy = roundrobin`.\n\nMore advanced strategies based on latency-weighted probabilities include `noerrors` and `nodeads`. These not only take out mirrors with issues but also monitor response times and do balancing. If a mirror responds slower (for example, due to some operations running on it), it will receive fewer requests. When the mirror recovers and provides better times, it will receive more requests.\n\n<!-- intro -->\n\n##### ini:\n\n<!-- request ini -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 添加带远程代理的分布式表\n\n要理解如何添加带远程代理的分布式表，首先需要对[分布式表](../Creating_a_table/Creating_a_distributed_table/Creating_a_distributed_table.md)有一个基本的了解。本文将重点介绍如何使用分布式表作为创建 Manticore 实例集群的基础。\n\n<!-- example conf dist 1 -->\n\n下面是一个如何将数据分布到4台服务器上的示例，每台服务器服务于一个分片：\n\n<!-- intro -->\n\n##### ini:\n\n<!-- request ini -->\n\nCODE_BLOCK_0\n\n<!-- end -->\n\n在服务器故障的情况下，分布式表仍然可以工作，但来自故障分片的结果将会缺失。\n\n<!-- example conf dist 2 -->\n\n现在我们添加了镜像，每个分片在2台服务器上都有副本。默认情况下，主节点（带有分布式表的 searchd 实例）会随机选择其中一个镜像。\n\n选择镜像的模式可以通过[ha_strategy](../Creating_a_cluster/Remote_nodes/Load_balancing.md#ha_strategy)设置来配置。除了默认的 `random` 模式外，还有 `ha_strategy = roundrobin`。\n\n基于延迟加权概率的更高级策略包括 `noerrors` 和 `nodeads`。这些策略不仅排除有问题的镜像，还监控响应时间并进行负载均衡。如果某个镜像响应较慢（例如，由于其上运行了一些操作），它将收到较少的请求。当该镜像恢复并提供更好的响应时间时，它将收到更多请求。\n\n<!-- intro -->\n\n##### ini:\n\n<!-- request ini -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "# Добавление распределённой таблицы с удалёнными агентами\n\nЧтобы понять, как добавить распределённую таблицу с удалёнными агентами, важно сначала иметь базовое представление о [распределённых таблицах](../Creating_a_table/Creating_a_distributed_table/Creating_a_distributed_table.md). В этой статье мы сосредоточимся на том, как использовать распределённую таблицу в качестве основы для создания кластера экземпляров Manticore.\n\n<!-- example conf dist 1 -->\n\nВот пример того, как разделить данные на 4 сервера, каждый из которых обслуживает один из шардов:\n\n<!-- intro -->\n\n##### ini:\n\n<!-- request ini -->\n\nCODE_BLOCK_0\n\n<!-- end -->\n\nВ случае сбоя сервера распределённая таблица продолжит работать, но результаты с вышедшего из строя шарда будут отсутствовать.\n\n<!-- example conf dist 2 -->\n\nТеперь, когда мы добавили зеркала, каждый шард находится на 2 серверах. По умолчанию мастер (экземпляр searchd с распределённой таблицей) будет случайным образом выбирать одно из зеркал.\n\nРежим выбора зеркал можно задать с помощью настройки [ha_strategy](../Creating_a_cluster/Remote_nodes/Load_balancing.md#ha_strategy). Помимо режима по умолчанию `random`, существует также `ha_strategy = roundrobin`.\n\nБолее продвинутые стратегии, основанные на вероятностях с учётом задержек, включают `noerrors` и `nodeads`. Они не только исключают зеркала с проблемами, но и отслеживают время отклика и выполняют балансировку. Если зеркало отвечает медленнее (например, из-за выполняющихся на нём операций), оно будет получать меньше запросов. Когда зеркало восстанавливается и обеспечивает лучшее время отклика, оно будет получать больше запросов.\n\n<!-- intro -->\n\n##### ini:\n\n<!-- request ini -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
