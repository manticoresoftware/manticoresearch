{
  "7221752a33da0b9963ea3553b878eb2cddd53dac8095d4e5c095b0f91b7ef710": {
    "original": "# Joining a replication cluster\n\n<!-- example joining a replication cluster 1 -->\n\nTo join an existing cluster, you must specify at least:\n\n* The [name](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster) of the cluster\n\n* The `host:port` of another node in the cluster you are joining\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nCODE_BLOCK_1\n\n<!-- request PHP -->\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_3\n\n<!-- response Python -->\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_5\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_7\n\n<!-- response javascript -->\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_9\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_10\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_11\n\n<!-- end -->\n\n<!-- example joining a replication cluster 1_1 -->\n\nIn most cases, the above is sufficient when there is a single replication cluster. However, if you are creating multiple replication clusters, you must also set the [path](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster) and ensure that the directory is available.\n\n<!-- request SQL -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\nA node joins a cluster by obtaining data from a specified node and, if successful, updates the node lists across all other cluster nodes in the same way as if it was done manually through [ALTER CLUSTER ... UPDATE nodes](../../Creating_a_cluster/Setting_up_replication/Managing_replication_nodes.md). This list is used to re-join nodes to the cluster upon restart.\n\nThere are two lists of nodes:\n\n1.`cluster_<name>_nodes_set`: used to re-join nodes to the cluster upon restart. It is updated across all nodes in the same way as [ALTER CLUSTER ... UPDATE nodes](../../Creating_a_cluster/Setting_up_replication/Managing_replication_nodes.md) does. `JOIN CLUSTER` command performs this update automatically. The [Cluster status](../../Creating_a_cluster/Setting_up_replication/Replication_cluster_status.md) displays this list as `cluster_<name>_nodes_set`.\n\n2. `cluster_<name>_nodes_view`:  this list contains all active nodes used for replication and does not require manual management. [ALTER CLUSTER ... UPDATE nodes](../../Creating_a_cluster/Setting_up_replication/Managing_replication_nodes.md) actually copies this list of nodes to the list of nodes used to re-join upon restart. The [Cluster status](../../Creating_a_cluster/Setting_up_replication/Replication_cluster_status.md) displays this list as `cluster_<name>_nodes_view`.\n\n<!-- example joining a replication cluster  2 -->\n\nWhen nodes are located in different network segments or data centers, the [nodes](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster) option may be set explicitly. This minimizes traffic between nodes and utilizes gateway nodes for intercommunication between data centers. The following code joins an existing cluster using the [nodes](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster) option.\n\n> **Note:** The cluster `cluster_<name>_nodes_set` list is not updated automatically when this syntax is used. To update it, use [ALTER CLUSTER ... UPDATE nodes](../../Creating_a_cluster/Setting_up_replication/Managing_replication_nodes.md).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_13\n\n<!-- request JSON -->\n\nCODE_BLOCK_14\n\n<!-- request PHP -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_16\n\n<!-- response Python -->\n\nCODE_BLOCK_17\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_18\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_19\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_20\n\n<!-- response javascript -->\n\nCODE_BLOCK_21\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_23\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_24\n\n<!-- end -->\n\nThe `JOIN CLUSTER` command works synchronously and completes as soon as the node receives all data from the other nodes in the cluster and is in sync with them.\n\nThe `JOIN CLUSTER` operation can fail with an error message indicating a duplicate [server_id](../../Server_settings/Searchd.md#server_id). This occurs when the joining node has the same `server_id` as an existing node in the cluster. To resolve this issue, ensure that each node in the replication cluster has a unique [server_id](../../Server_settings/Searchd.md#server_id). You can change the default [server_id](../../Server_settings/Searchd.md#server_id) in the \"searchd\" section of your configuration file to a unique value before attempting to join the cluster.\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 加入复制集群\n\n<!-- example joining a replication cluster 1 -->\n\n要加入现有集群，您必须至少指定：\n\n* 集群的 [名称](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster)\n\n* 您要加入的集群中另一个节点的 `host:port`\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nCODE_BLOCK_1\n\n<!-- request PHP -->\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_3\n\n<!-- response Python -->\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_5\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_7\n\n<!-- response javascript -->\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_9\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_10\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_11\n\n<!-- end -->\n\n<!-- example joining a replication cluster 1_1 -->\n\n在大多数情况下，当只有一个复制集群时，上述内容已足够。然而，如果您正在创建多个复制集群，则还必须设置 [路径](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster) 并确保该目录可用。\n\n<!-- request SQL -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n节点通过从指定节点获取数据来加入集群，如果成功，则会以与手动通过 [ALTER CLUSTER ... UPDATE nodes](../../Creating_a_cluster/Setting_up_replication/Managing_replication_nodes.md) 操作相同的方式更新所有其他集群节点的节点列表。此列表用于在重启时重新加入节点到集群。\n\n有两个节点列表：\n\n1.`cluster_<name>_nodes_set`：用于在重启时重新加入节点到集群。它会以与 [ALTER CLUSTER ... UPDATE nodes](../../Creating_a_cluster/Setting_up_replication/Managing_replication_nodes.md) 相同的方式在所有节点间更新。`JOIN CLUSTER` 命令会自动执行此更新。[集群状态](../../Creating_a_cluster/Setting_up_replication/Replication_cluster_status.md) 显示此列表为 `cluster_<name>_nodes_set`。\n\n2. `cluster_<name>_nodes_view`：此列表包含所有用于复制的活动节点，无需手动管理。[ALTER CLUSTER ... UPDATE nodes](../../Creating_a_cluster/Setting_up_replication/Managing_replication_nodes.md) 实际上是将此节点列表复制到用于重启时重新加入的节点列表中。[集群状态](../../Creating_a_cluster/Setting_up_replication/Replication_cluster_status.md) 显示此列表为 `cluster_<name>_nodes_view`。\n\n<!-- example joining a replication cluster  2 -->\n\n当节点位于不同的网络段或数据中心时，可以显式设置 [nodes](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster) 选项。这可以最小化节点间的流量，并利用网关节点实现数据中心间的通信。以下代码使用 [nodes](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster) 选项加入现有集群。\n\n> **注意：** 使用此语法时，集群的 `cluster_<name>_nodes_set` 列表不会自动更新。要更新它，请使用 [ALTER CLUSTER ... UPDATE nodes](../../Creating_a_cluster/Setting_up_replication/Managing_replication_nodes.md)。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_13\n\n<!-- request JSON -->\n\nCODE_BLOCK_14\n\n<!-- request PHP -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_16\n\n<!-- response Python -->\n\nCODE_BLOCK_17\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_18\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_19\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_20\n\n<!-- response javascript -->\n\nCODE_BLOCK_21\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_23\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_24\n\n<!-- end -->\n\n`JOIN CLUSTER` 命令是同步执行的，一旦节点从集群中的其他节点接收完所有数据并与它们同步，即完成操作。\n\n`JOIN CLUSTER` 操作可能会失败，并显示重复的 [server_id](../../Server_settings/Searchd.md#server_id) 错误信息。这种情况发生在加入的节点与集群中已有节点的 `server_id` 相同。为解决此问题，请确保复制集群中的每个节点具有唯一的 [server_id](../../Server_settings/Searchd.md#server_id)。您可以在配置文件的 \"searchd\" 部分将默认的 [server_id](../../Server_settings/Searchd.md#server_id) 更改为唯一值，然后再尝试加入集群。\n\n<!-- proofread -->",
      "russian": "# Присоединение к кластеру репликации\n\n<!-- example joining a replication cluster 1 -->\n\nЧтобы присоединиться к существующему кластеру, необходимо указать как минимум:\n\n* [имя](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster) кластера\n\n* `host:port` другого узла в кластере, к которому вы присоединяетесь\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nCODE_BLOCK_1\n\n<!-- request PHP -->\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_3\n\n<!-- response Python -->\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_5\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_7\n\n<!-- response javascript -->\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_9\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_10\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_11\n\n<!-- end -->\n\n<!-- example joining a replication cluster 1_1 -->\n\nВ большинстве случаев вышеуказанного достаточно, если существует один кластер репликации. Однако, если вы создаёте несколько кластеров репликации, необходимо также задать [путь](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster) и убедиться, что директория доступна.\n\n<!-- request SQL -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\nУзел присоединяется к кластеру, получая данные от указанного узла и, в случае успеха, обновляет списки узлов на всех остальных узлах кластера так же, как если бы это было сделано вручную через [ALTER CLUSTER ... UPDATE nodes](../../Creating_a_cluster/Setting_up_replication/Managing_replication_nodes.md). Этот список используется для повторного присоединения узлов к кластеру при перезапуске.\n\nСуществует два списка узлов:\n\n1.`cluster_<name>_nodes_set`: используется для повторного присоединения узлов к кластеру при перезапуске. Он обновляется на всех узлах так же, как это делает [ALTER CLUSTER ... UPDATE nodes](../../Creating_a_cluster/Setting_up_replication/Managing_replication_nodes.md). Команда `JOIN CLUSTER` выполняет это обновление автоматически. [Статус кластера](../../Creating_a_cluster/Setting_up_replication/Replication_cluster_status.md) отображает этот список как `cluster_<name>_nodes_set`.\n\n2. `cluster_<name>_nodes_view`: этот список содержит все активные узлы, используемые для репликации, и не требует ручного управления. [ALTER CLUSTER ... UPDATE nodes](../../Creating_a_cluster/Setting_up_replication/Managing_replication_nodes.md) фактически копирует этот список узлов в список узлов, используемых для повторного присоединения при перезапуске. [Статус кластера](../../Creating_a_cluster/Setting_up_replication/Replication_cluster_status.md) отображает этот список как `cluster_<name>_nodes_view`.\n\n<!-- example joining a replication cluster  2 -->\n\nКогда узлы расположены в разных сетевых сегментах или дата-центрах, опция [nodes](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster) может быть задана явно. Это минимизирует трафик между узлами и использует шлюзовые узлы для межсоединения между дата-центрами. Следующий код присоединяется к существующему кластеру с использованием опции [nodes](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster).\n\n> **Примечание:** список кластера `cluster_<name>_nodes_set` не обновляется автоматически при использовании этого синтаксиса. Для его обновления используйте [ALTER CLUSTER ... UPDATE nodes](../../Creating_a_cluster/Setting_up_replication/Managing_replication_nodes.md).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_13\n\n<!-- request JSON -->\n\nCODE_BLOCK_14\n\n<!-- request PHP -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_16\n\n<!-- response Python -->\n\nCODE_BLOCK_17\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_18\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_19\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_20\n\n<!-- response javascript -->\n\nCODE_BLOCK_21\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_23\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_24\n\n<!-- end -->\n\nКоманда `JOIN CLUSTER` работает синхронно и завершается, как только узел получает все данные от других узлов кластера и синхронизируется с ними.\n\nОперация `JOIN CLUSTER` может завершиться с ошибкой, указывающей на дублирование [server_id](../../Server_settings/Searchd.md#server_id). Это происходит, когда присоединяющийся узел имеет такой же `server_id`, как и существующий узел в кластере. Чтобы решить эту проблему, убедитесь, что каждый узел в кластере репликации имеет уникальный [server_id](../../Server_settings/Searchd.md#server_id). Вы можете изменить значение по умолчанию [server_id](../../Server_settings/Searchd.md#server_id) в разделе \"searchd\" вашего конфигурационного файла на уникальное значение перед попыткой присоединения к кластеру.\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "503bbd34df544dda270d2dfe2995ea121d0608853f3644b498569085ce45f093": {
    "original": "# Joining a replication cluster\n\n<!-- example joining a replication cluster 1 -->\n\nTo join an existing cluster, you must specify at least:\n\n* The [name](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster) of the cluster\n\n* The `host:port` of another node in the cluster you are joining\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nCODE_BLOCK_1\n\n<!-- request PHP -->\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_3\n\n<!-- response Python -->\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_5\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_7\n\n<!-- response javascript -->\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_9\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_10\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_11\n\n<!-- end -->\n\n<!-- example joining a replication cluster 1_1 -->\n\nIn most cases, the above is sufficient when there is a single replication cluster. However, if you are creating multiple replication clusters, you must also set the [path](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster) and ensure that the directory is available.\n\n<!-- request SQL -->\n\nCODE_BLOCK_12\n\n<!-- request JSON -->\n\nCODE_BLOCK_13\n\n<!-- end -->\n\nA node joins a cluster by obtaining data from a specified node and, if successful, updates the node lists across all other cluster nodes in the same way as if it was done manually through [ALTER CLUSTER ... UPDATE nodes](../../Creating_a_cluster/Setting_up_replication/Managing_replication_nodes.md). This list is used to re-join nodes to the cluster upon restart.\n\nThere are two lists of nodes:\n\n1.`cluster_<name>_nodes_set`: used to re-join nodes to the cluster upon restart. It is updated across all nodes in the same way as [ALTER CLUSTER ... UPDATE nodes](../../Creating_a_cluster/Setting_up_replication/Managing_replication_nodes.md) does. `JOIN CLUSTER` command performs this update automatically. The [Cluster status](../../Creating_a_cluster/Setting_up_replication/Replication_cluster_status.md) displays this list as `cluster_<name>_nodes_set`.\n\n2. `cluster_<name>_nodes_view`:  this list contains all active nodes used for replication and does not require manual management. [ALTER CLUSTER ... UPDATE nodes](../../Creating_a_cluster/Setting_up_replication/Managing_replication_nodes.md) actually copies this list of nodes to the list of nodes used to re-join upon restart. The [Cluster status](../../Creating_a_cluster/Setting_up_replication/Replication_cluster_status.md) displays this list as `cluster_<name>_nodes_view`.\n\n<!-- example joining a replication cluster  2 -->\n\nWhen nodes are located in different network segments or data centers, the [nodes](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster) option may be set explicitly. This minimizes traffic between nodes and utilizes gateway nodes for intercommunication between data centers. The following code joins an existing cluster using the [nodes](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster) option.\n\n> **Note:** The cluster `cluster_<name>_nodes_set` list is not updated automatically when this syntax is used. To update it, use [ALTER CLUSTER ... UPDATE nodes](../../Creating_a_cluster/Setting_up_replication/Managing_replication_nodes.md).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_14\n\n<!-- request JSON -->\n\nCODE_BLOCK_15\n\n<!-- request PHP -->\n\nCODE_BLOCK_16\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_17\n\n<!-- response Python -->\n\nCODE_BLOCK_18\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_19\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_20\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_21\n\n<!-- response javascript -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_23\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_24\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_25\n\n<!-- end -->\n\nThe `JOIN CLUSTER` command works synchronously and completes as soon as the node receives all data from the other nodes in the cluster and is in sync with them.\n\nThe `JOIN CLUSTER` operation can fail with an error message indicating a duplicate [server_id](../../Server_settings/Searchd.md#server_id). This occurs when the joining node has the same `server_id` as an existing node in the cluster. To resolve this issue, ensure that each node in the replication cluster has a unique [server_id](../../Server_settings/Searchd.md#server_id). You can change the default [server_id](../../Server_settings/Searchd.md#server_id) in the \"searchd\" section of your configuration file to a unique value before attempting to join the cluster.\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 加入复制集群\n\n<!-- example joining a replication cluster 1 -->\n\n要加入现有集群，您必须至少指定：\n\n* 集群的 [名称](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster)\n\n* 您要加入的集群中另一个节点的 `host:port`\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nCODE_BLOCK_1\n\n<!-- request PHP -->\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_3\n\n<!-- response Python -->\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_5\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_7\n\n<!-- response javascript -->\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_9\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_10\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_11\n\n<!-- end -->\n\n<!-- example joining a replication cluster 1_1 -->\n\n在大多数情况下，当只有一个复制集群时，上述内容已经足够。但是，如果您正在创建多个复制集群，还必须设置 [路径](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster) 并确保该目录可用。\n\n<!-- request SQL -->\n\nCODE_BLOCK_12\n\n<!-- request JSON -->\n\nCODE_BLOCK_13\n\n<!-- end -->\n\n节点通过从指定节点获取数据来加入集群，如果成功，则会以与手动通过 [ALTER CLUSTER ... UPDATE nodes](../../Creating_a_cluster/Setting_up_replication/Managing_replication_nodes.md) 操作相同的方式，更新所有其他集群节点的节点列表。该列表用于在重启时重新连接节点到集群。\n\n有两个节点列表：\n\n1.`cluster_<name>_nodes_set`：用于在重启时重新连接节点到集群。它会在所有节点上以与 [ALTER CLUSTER ... UPDATE nodes](../../Creating_a_cluster/Setting_up_replication/Managing_replication_nodes.md) 相同的方式更新。`JOIN CLUSTER` 命令会自动执行此更新。[集群状态](../../Creating_a_cluster/Setting_up_replication/Replication_cluster_status.md) 显示该列表为 `cluster_<name>_nodes_set`。\n\n2.`cluster_<name>_nodes_view`：此列表包含所有用于复制的活动节点，无需手动管理。[ALTER CLUSTER ... UPDATE nodes](../../Creating_a_cluster/Setting_up_replication/Managing_replication_nodes.md) 实际上是将此活动节点列表复制到用于重启后重新连接的节点列表。[集群状态](../../Creating_a_cluster/Setting_up_replication/Replication_cluster_status.md) 显示该列表为 `cluster_<name>_nodes_view`。\n\n<!-- example joining a replication cluster  2 -->\n\n当节点位于不同网络段或数据中心时，可能需要显式设置 [nodes](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster) 选项。这可以最大限度地减少节点之间的流量，并利用网关节点进行数据中心间的通信。以下代码使用 [nodes](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster) 选项加入现有集群。\n\n> **注意：** 当使用此语法时，集群的 `cluster_<name>_nodes_set` 列表不会自动更新。要更新它，请使用 [ALTER CLUSTER ... UPDATE nodes](../../Creating_a_cluster/Setting_up_replication/Managing_replication_nodes.md)。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_14\n\n<!-- request JSON -->\n\nCODE_BLOCK_15\n\n<!-- request PHP -->\n\nCODE_BLOCK_16\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_17\n\n<!-- response Python -->\n\nCODE_BLOCK_18\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_19\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_20\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_21\n\n<!-- response javascript -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_23\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_24\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_25\n\n<!-- end -->\n\n`JOIN CLUSTER` 命令是同步工作的，并在节点接收到集群中其他所有节点的数据且与之同步后完成执行。\n\n`JOIN CLUSTER` 操作可能会失败，并显示关于重复 [server_id](../../Server_settings/Searchd.md#server_id) 的错误信息。这通常发生在加入的节点与集群中已存在的节点具有相同的 `server_id`。要解决此问题，请确保复制集群中的每个节点具有唯一的 [server_id](../../Server_settings/Searchd.md#server_id)。您可以在配置文件的 \"searchd\" 部分将默认的 [server_id](../../Server_settings/Searchd.md#server_id) 更改为唯一值，然后再尝试加入集群。\n\n<!-- proofread -->",
      "russian": "# Вступление в кластер репликации\n\n<!-- example joining a replication cluster 1 -->\n\nЧтобы присоединиться к существующему кластеру, необходимо указать как минимум:\n\n* [имя](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster) кластера\n\n* `host:port` другого узла в кластере, к которому вы присоединяетесь\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nCODE_BLOCK_1\n\n<!-- request PHP -->\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_3\n\n<!-- response Python -->\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_5\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_7\n\n<!-- response javascript -->\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_9\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_10\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_11\n\n<!-- end -->\n\n<!-- example joining a replication cluster 1_1 -->\n\nВ большинстве случаев вышеуказанного достаточно, если есть один кластер репликации. Однако, если вы создаёте несколько кластеров репликации, необходимо также указать [путь](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster) и убедиться, что каталог доступен.\n\n<!-- request SQL -->\n\nCODE_BLOCK_12\n\n<!-- request JSON -->\n\nCODE_BLOCK_13\n\n<!-- end -->\n\nУзел присоединяется к кластеру, получая данные от указанного узла и, если это успешно, обновляет списки узлов по всем другим узлам кластера тем же способом, как если бы это было сделано вручную через [ALTER CLUSTER ... UPDATE nodes](../../Creating_a_cluster/Setting_up_replication/Managing_replication_nodes.md). Этот список используется для повторного присоединения узлов к кластеру при перезапуске.\n\nСуществуют два списка узлов:\n\n1. `cluster_<name>_nodes_set`: используется для повторного присоединения узлов к кластеру при перезапуске. Обновляется во всех узлах так же, как это делает [ALTER CLUSTER ... UPDATE nodes](../../Creating_a_cluster/Setting_up_replication/Managing_replication_nodes.md). Команда `JOIN CLUSTER` автоматически выполняет это обновление. [Статус кластера](../../Creating_a_cluster/Setting_up_replication/Replication_cluster_status.md) отображает этот список как `cluster_<name>_nodes_set`.\n\n2. `cluster_<name>_nodes_view`: этот список содержит все активные узлы, используемые для репликации, и не требует ручного управления. [ALTER CLUSTER ... UPDATE nodes](../../Creating_a_cluster/Setting_up_replication/Managing_replication_nodes.md) на самом деле копирует этот список узлов в список узлов, используемый для повторного присоединения при перезапуске. [Статус кластера](../../Creating_a_cluster/Setting_up_replication/Replication_cluster_status.md) отображает этот список как `cluster_<name>_nodes_view`.\n\n<!-- example joining a replication cluster  2 -->\n\nКогда узлы находятся в разных сетевых сегментах или дата-центрах, опция [nodes](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster) может быть задана явно. Это минимизирует трафик между узлами и использует шлюзовые узлы для межсоединения между дата-центрами. Следующий код присоединяется к существующему кластеру, используя опцию [nodes](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster).\n\n> **Примечание:** список `cluster_<name>_nodes_set` кластера не обновляется автоматически при использовании данного синтаксиса. Чтобы обновить его, используйте [ALTER CLUSTER ... UPDATE nodes](../../Creating_a_cluster/Setting_up_replication/Managing_replication_nodes.md).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_14\n\n<!-- request JSON -->\n\nCODE_BLOCK_15\n\n<!-- request PHP -->\n\nCODE_BLOCK_16\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_17\n\n<!-- response Python -->\n\nCODE_BLOCK_18\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_19\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_20\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_21\n\n<!-- response javascript -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_23\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_24\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_25\n\n<!-- end -->\n\nКоманда `JOIN CLUSTER` работает синхронно и завершается, как только узел получает все данные от других узлов кластера и синхронизируется с ними.\n\nОперация `JOIN CLUSTER` может завершиться ошибкой с сообщением о дублирующемся [server_id](../../Server_settings/Searchd.md#server_id). Это происходит, когда присоединяющийся узел имеет тот же `server_id`, что и существующий узел в кластере. Чтобы устранить эту проблему, убедитесь, что каждый узел в кластере репликации имеет уникальный [server_id](../../Server_settings/Searchd.md#server_id). Вы можете изменить значение по умолчанию [server_id](../../Server_settings/Searchd.md#server_id) в секции \"searchd\" вашего файла конфигурации на уникальное перед попыткой присоединения к кластеру.\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
