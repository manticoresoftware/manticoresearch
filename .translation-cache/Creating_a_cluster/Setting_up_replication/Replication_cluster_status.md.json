{
  "255a1b2ae17073efe31dc7a7b1d36416d04840f7b8f3d7edfc30a5d9ef54a35d": {
    "original": "# Replication cluster status\n\n<!-- example Example -->\n\nYou can view the cluster status information by checking the node status. This can be done using the [Node status](../../Node_info_and_management/Node_status.md) command, which displays various information about the node, including the cluster status variables.\n\nThe output format for the cluster status variables is as follows:  `cluster_name_variable_name` `variable_value`. Most of the variables are described in the [Galera Documentation Status Variables](https://galeracluster.com/library/documentation/galera-status-variables.html). In addition to these variables, Manticore Search also displays:\n\n* `cluster_name` - the name of the cluster, as defined in the [replication setup](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster)\n\n* `node_state` - the current state of the node: `closed`, `destroyed`, `joining`, `donor`, `synced`\n\n* `indexes_count` - the number of tables managed by the cluster\n\n* `indexes` - a list of table names managed by the cluster\n\n* `nodes_set` - the list of nodes in the cluster defined using the `CREATE`, `JOIN` or `ALTER UPDATE` commands\n\n* `nodes_view` - the actual list of nodes in the cluster that the current node can see.\n\n* `state_uuid` - UUID state of the cluster. If it matches the value in local_state_uuid, the local and cluster nodes are in sync.\n\n* `conf_id` - total number of cluster membership changes that have taken place.\n\n* `status` - cluster component status. Possible values are primary (primary group configuration, quorum present), non_primary (non-primary group configuration, quorum lost), or disconnected (not connected to group, retrying).\n\n* `size` - number of nodes currently in the cluster.\n\n* `local_index` - the node's index in the cluster.\n\n* `last_error` - the last recorded error message related to a cluster operation. The message provides a high-level summary of the problem. For more detailed context, you should consult the `searchd.log` file.\n\n### SST Progress Metrics\n\nDuring a State Snapshot Transfer (SST), a node provisions another by transferring a full data copy. This happens when a new node joins the cluster [JOIN CLUSTER](Creating_a_cluster/Setting_up_replication/Joining_a_replication_cluster.md) or when new tables are added [ALTER CLUSTER ADD](Creating_a_cluster/Setting_up_replication/Adding_and_removing_a_table_from_a_replication_cluster.md#Adding-and-removing-a-table-from-a-replication-cluster). While an SST is active, the following additional status variables will be available on both the donor and joiner nodes, with their progress kept in sync.\n\n* `cluster_name_sst_total` - The overall progress of the entire SST operation, from 0 to 100. This is the primary counter to watch.\n\n* `cluster_name_sst_stage` - The name of the current work phase. The process cycles through these stages for each table being transferred:\n\n    * `await nodes sync`\n\n    * `block checksum calculate`\n\n    * `analyze remote`\n\n    * `send files`\n\n    * `activate tables`\n\n* `cluster_name_sst_stage_total` - The progress of the current stage, from 0 to 100.\n\n* `cluster_name_sst_tables` - The total number of tables being transferred in the SST.\n\n* `cluster_name_sst_table` - The name and index of the table currently being processed (e.g., `3 (products)`).\n\nFor most use cases, `cluster_name_sst_total` is sufficient. However, the other counters can be useful for investigating stalls or performance issues during a specific SST stage or on a particular table.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- response SQL-->\n\nCODE_BLOCK_1\n\n<!-- request JSON -->\n\nCODE_BLOCK_2\n\n<!-- response JSON-->\n\nCODE_BLOCK_3\n\n<!-- request PHP -->\n\nCODE_BLOCK_4\n\n<!-- response PHP -->\n\nCODE_BLOCK_5\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_6\n\n<!-- response Python -->\n\nCODE_BLOCK_7\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_8\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_9\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_10\n\n<!-- response Javascript -->\n\nCODE_BLOCK_11\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_12\n\n<!-- response Java -->\n\nCODE_BLOCK_13\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_14\n\n<!-- response C# -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_16\n\n<!-- response Rust -->\n\nCODE_BLOCK_17\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "russian": "# Статус кластера репликации\n\n<!-- example Example -->\n\nВы можете просмотреть информацию о статусе кластера, проверив статус узла. Это можно сделать с помощью команды [Node status](../../Node_info_and_management/Node_status.md), которая отображает различную информацию об узле, включая переменные статуса кластера.\n\nФормат вывода переменных статуса кластера следующий:  `cluster_name_variable_name` `variable_value`. Большинство переменных описаны в [Galera Documentation Status Variables](https://galeracluster.com/library/documentation/galera-status-variables.html). В дополнение к этим переменным, Manticore Search также отображает:\n\n* `cluster_name` - имя кластера, как определено в [настройке репликации](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster)\n\n* `node_state` - текущее состояние узла: `closed`, `destroyed`, `joining`, `donor`, `synced`\n\n* `indexes_count` - количество таблиц, управляемых кластером\n\n* `indexes` - список имен таблиц, управляемых кластером\n\n* `nodes_set` - список узлов в кластере, определенный с помощью команд `CREATE`, `JOIN` или `ALTER UPDATE`\n\n* `nodes_view` - фактический список узлов в кластере, которые видит текущий узел.\n\n* `state_uuid` - UUID состояния кластера. Если он совпадает со значением в local_state_uuid, локальные и кластерные узлы синхронизированы.\n\n* `conf_id` - общее количество изменений членства в кластере, которые произошли.\n\n* `status` - статус компонента кластера. Возможные значения: primary (конфигурация первичной группы, кворум присутствует), non_primary (конфигурация непервичной группы, кворум потерян), или disconnected (не подключен к группе, повторная попытка).\n\n* `size` - количество узлов, в настоящее время находящихся в кластере.\n\n* `local_index` - индекс узла в кластере.\n\n* `last_error` - последнее зарегистрированное сообщение об ошибке, связанной с операцией кластера. Сообщение предоставляет общий обзор проблемы. Для более подробного контекста следует обратиться к файлу `searchd.log`.\n\n### Метрики прогресса SST\n\nВо время передачи снимка состояния (SST) один узел обеспечивает другой, передавая полную копию данных. Это происходит, когда новый узел присоединяется к кластеру [JOIN CLUSTER](Creating_a_cluster/Setting_up_replication/Joining_a_replication_cluster.md) или когда добавляются новые таблицы [ALTER CLUSTER ADD](Creating_a_cluster/Setting_up_replication/Adding_and_removing_a_table_from_a_replication_cluster.md#Adding-and-removing-a-table-from-a-replication-cluster). Пока SST активен, на узлах-доноре и присоединяющемся будут доступны следующие дополнительные переменные статуса, прогресс которых синхронизирован.\n\n* `cluster_name_sst_total` - общий прогресс всей операции SST, от 0 до 100. Это основной счетчик для отслеживания.\n\n* `cluster_name_sst_stage` - название текущей фазы работы. Процесс проходит через эти стадии для каждой передаваемой таблицы:\n\n    * `await nodes sync`\n\n    * `block checksum calculate`\n\n    * `analyze remote`\n\n    * `send files`\n\n    * `activate tables`\n\n* `cluster_name_sst_stage_total` - прогресс текущей стадии, от 0 до 100.\n\n* `cluster_name_sst_tables` - общее количество таблиц, передаваемых в SST.\n\n* `cluster_name_sst_table` - имя и индекс таблицы, которая в данный момент обрабатывается (например, `3 (products)`).\n\nДля большинства случаев использования достаточно `cluster_name_sst_total`. Однако другие счетчики могут быть полезны для расследования зависаний или проблем с производительностью на конкретной стадии SST или с определенной таблицей.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- response SQL-->\n\nCODE_BLOCK_1\n\n<!-- request JSON -->\n\nCODE_BLOCK_2\n\n<!-- response JSON-->\n\nCODE_BLOCK_3\n\n<!-- request PHP -->\n\nCODE_BLOCK_4\n\n<!-- response PHP -->\n\nCODE_BLOCK_5\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_6\n\n<!-- response Python -->\n\nCODE_BLOCK_7\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_8\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_9\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_10\n\n<!-- response Javascript -->\n\nCODE_BLOCK_11\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_12\n\n<!-- response Java -->\n\nCODE_BLOCK_13\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_14\n\n<!-- response C# -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_16\n\n<!-- response Rust -->\n\nCODE_BLOCK_17\n\n<!-- end -->\n\n<!-- proofread -->",
      "chinese": "# 复制集群状态\n\n<!-- example Example -->\n\n您可以通过检查节点状态来查看集群状态信息。这可以使用[节点状态](../../Node_info_and_management/Node_status.md)命令完成，该命令显示有关节点的各种信息，包括集群状态变量。\n\n集群状态变量的输出格式如下：`cluster_name_variable_name` `variable_value`。大多数变量在[Galera 文档状态变量](https://galeracluster.com/library/documentation/galera-status-variables.html)中有描述。除了这些变量外，Manticore Search 还显示：\n\n* `cluster_name` - 集群的名称，如[复制设置](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster)中定义\n\n* `node_state` - 节点的当前状态：`closed`，`destroyed`，`joining`，`donor`，`synced`\n\n* `indexes_count` - 集群管理的表的数量\n\n* `indexes` - 集群管理的表名列表\n\n* `nodes_set` - 使用 `CREATE`、`JOIN` 或 `ALTER UPDATE` 命令定义的集群节点列表\n\n* `nodes_view` - 当前节点可见的集群实际节点列表。\n\n* `state_uuid` - 集群的 UUID 状态。如果它与 local_state_uuid 中的值匹配，则本地和集群节点同步。\n\n* `conf_id` - 集群成员变更的总次数。\n\n* `status` - 集群组件状态。可能的值为 primary（主组配置，存在法定人数）、non_primary（非主组配置，失去法定人数）或 disconnected（未连接到组，正在重试）。\n\n* `size` - 当前集群中的节点数。\n\n* `local_index` - 节点在集群中的索引。\n\n* `last_error` - 与集群操作相关的最后记录的错误消息。该消息提供问题的高级摘要。有关更详细的上下文，应查阅 `searchd.log` 文件。\n\n### SST 进度指标\n\n在状态快照传输（SST）期间，节点通过传输完整数据副本来为另一个节点提供数据。当新节点加入集群 [JOIN CLUSTER](Creating_a_cluster/Setting_up_replication/Joining_a_replication_cluster.md) 或添加新表 [ALTER CLUSTER ADD](Creating_a_cluster/Setting_up_replication/Adding_and_removing_a_table_from_a_replication_cluster.md#Adding-and-removing-a-table-from-a-replication-cluster) 时会发生此情况。在 SST 活动期间，以下额外的状态变量将在捐赠节点和加入节点上可用，其进度保持同步。\n\n* `cluster_name_sst_total` - 整个 SST 操作的总体进度，范围从 0 到 100。这是主要的计数器。\n\n* `cluster_name_sst_stage` - 当前工作阶段的名称。该过程为每个传输的表循环经过以下阶段：\n\n    * `await nodes sync`\n\n    * `block checksum calculate`\n\n    * `analyze remote`\n\n    * `send files`\n\n    * `activate tables`\n\n* `cluster_name_sst_stage_total` - 当前阶段的进度，范围从 0 到 100。\n\n* `cluster_name_sst_tables` - SST 中传输的表的总数。\n\n* `cluster_name_sst_table` - 当前处理的表的名称和索引（例如，`3 (products)`）。\n\n对于大多数用例，`cluster_name_sst_total` 就足够了。然而，其他计数器对于调查特定 SST 阶段或特定表上的停滞或性能问题非常有用。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- response SQL-->\n\nCODE_BLOCK_1\n\n<!-- request JSON -->\n\nCODE_BLOCK_2\n\n<!-- response JSON-->\n\nCODE_BLOCK_3\n\n<!-- request PHP -->\n\nCODE_BLOCK_4\n\n<!-- response PHP -->\n\nCODE_BLOCK_5\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_6\n\n<!-- response Python -->\n\nCODE_BLOCK_7\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_8\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_9\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_10\n\n<!-- response Javascript -->\n\nCODE_BLOCK_11\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_12\n\n<!-- response Java -->\n\nCODE_BLOCK_13\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_14\n\n<!-- response C# -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_16\n\n<!-- response Rust -->\n\nCODE_BLOCK_17\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "93261f7db5f3785815e45a689da401e2f1044603b6276c1a38e2f2647560f4c2": {
    "original": "# Replication cluster status\n\n<!-- example Example -->\n\nYou can view the cluster status information by checking the node status. This can be done using the [Node status](../../Node_info_and_management/Node_status.md) command, which displays various information about the node, including the cluster status variables.\n\nThe output format for the cluster status variables is as follows:  `cluster_name_variable_name` `variable_value`. Most of the variables are described in the [Galera Documentation Status Variables](https://galeracluster.com/library/documentation/galera-status-variables.html). In addition to these variables, Manticore Search also displays:\n\n* `cluster_name` - the name of the cluster, as defined in the [replication setup](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster)\n\n* `node_state` - the current state of the node: `closed`, `destroyed`, `joining`, `donor`, `synced`\n\n* `indexes_count` - the number of tables managed by the cluster\n\n* `indexes` - a list of table names managed by the cluster\n\n* `nodes_set` - the list of nodes in the cluster defined using the `CREATE`, `JOIN` or `ALTER UPDATE` commands\n\n* `nodes_view` - the actual list of nodes in the cluster that the current node can see.\n\n* `state_uuid` - UUID state of the cluster. If it matches the value in local_state_uuid, the local and cluster nodes are in sync.\n\n* `conf_id` - total number of cluster membership changes that have taken place.\n\n* `status` - cluster component status. Possible values are primary (primary group configuration, quorum present), non_primary (non-primary group configuration, quorum lost), or disconnected (not connected to group, retrying).\n\n* `size` - number of nodes currently in the cluster.\n\n* `local_index` - the node's index in the cluster.\n\n* `last_error` - the last recorded error message related to a cluster operation. The message provides a high-level summary of the problem. For more detailed context, you should consult the `searchd.log` file.\n\n### SST Progress Variables\n\nDuring a State Snapshot Transfer (SST), a node provisions another by transferring a full data copy. This happens when a new node joins the cluster [JOIN CLUSTER](Creating_a_cluster/Setting_up_replication/Joining_a_replication_cluster.md) or when new tables are added [`ALTER CLUSTER ADD`](Creating_a_cluster/Setting_up_replication/Adding_and_removing_a_table_from_a_replication_cluster.md#Adding-and-removing-a-table-from-a-replication-cluster). While an SST is active, the following additional status variables will be available on both the donor and joiner nodes, with their progress kept in sync.\n\n* `cluster_name_sst_total` - The overall progress of the entire SST operation, from 0 to 100. This is the primary counter to watch.\n\n* `cluster_name_sst_stage` - The name of the current work phase. The process cycles through these stages for each table being transferred:\n\n    * `await nodes sync`\n\n    * `block checksum calculate`\n\n    * `analyze remote`\n\n    * `send files`\n\n    * `activate tables`\n\n* `cluster_name_sst_stage_total` - The progress of the current stage, from 0 to 100.\n\n* `cluster_name_sst_tables` - The total number of tables being transferred in the SST.\n\n* `cluster_name_sst_table` - The name and index of the table currently being processed (e.g., `3 (products)`).\n\nFor most use cases, `cluster_name_sst_total` is sufficient. However, the other counters can be useful for investigating stalls or performance issues during a specific SST stage or on a particular table.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- response SQL-->\n\nCODE_BLOCK_1\n\n<!-- request JSON -->\n\nCODE_BLOCK_2\n\n<!-- response JSON-->\n\nCODE_BLOCK_3\n\n<!-- request PHP -->\n\nCODE_BLOCK_4\n\n<!-- response PHP -->\n\nCODE_BLOCK_5\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_6\n\n<!-- response Python -->\n\nCODE_BLOCK_7\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_8\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_9\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_10\n\n<!-- response Javascript -->\n\nCODE_BLOCK_11\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_12\n\n<!-- response Java -->\n\nCODE_BLOCK_13\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_14\n\n<!-- response C# -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_16\n\n<!-- response Rust -->\n\nCODE_BLOCK_17\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 复制集群状态\n\n<!-- example Example -->\n\n您可以通过检查节点状态来查看集群状态信息。可以使用[节点状态](../../Node_info_and_management/Node_status.md)命令来完成，该命令显示有关节点的各种信息，包括集群状态变量。\n\n集群状态变量的输出格式如下：`cluster_name_variable_name` `variable_value`。大多数变量在[Galera 文档状态变量](https://galeracluster.com/library/documentation/galera-status-variables.html)中有描述。除了这些变量之外，Manticore Search 还显示：\n\n* `cluster_name` - 集群的名称，如[复制设置](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster)中所定义\n\n* `node_state` - 节点的当前状态：`closed`，`destroyed`，`joining`，`donor`，`synced`\n\n* `indexes_count` - 集群管理的表数量\n\n* `indexes` - 集群管理的表名列表\n\n* `nodes_set` - 使用 `CREATE`、`JOIN` 或 `ALTER UPDATE` 命令定义的集群中节点列表\n\n* `nodes_view` - 当前节点可见的集群中实际节点列表\n\n* `state_uuid` - 集群的 UUID 状态。如果它与 local_state_uuid 中的值匹配，则本地节点与集群节点同步。\n\n* `conf_id` - 发生的集群成员变更的总次数。\n\n* `status` - 集群组件状态。可能的值有 primary（主组配置，有仲裁），non_primary（非主组配置，丢失仲裁），或 disconnected（未连接到组，正在重试）。\n\n* `size` - 当前集群中的节点数量。\n\n* `local_index` - 节点在集群中的索引。\n\n* `last_error` - 与集群操作相关的最近记录的错误消息。该消息为问题提供了高层次摘要。有关更详细的上下文，应查看 `searchd.log` 文件。\n\n### SST 进度变量\n\n在状态快照传输（SST）期间，一个节点通过传输完整数据副本给另一个节点进行预配。当新节点加入集群[JOIN CLUSTER](Creating_a_cluster/Setting_up_replication/Joining_a_replication_cluster.md)或添加新表[`ALTER CLUSTER ADD`](Creating_a_cluster/Setting_up_replication/Adding_and_removing_a_table_from_a_replication_cluster.md#Adding-and-removing-a-table-from-a-replication-cluster)时，会发生这种情况。当 SST 活动时，捐赠者和加入者节点上都会有以下额外状态变量，且它们的进度保持同步。\n\n* `cluster_name_sst_total` - 整个 SST 操作的总体进度，范围从 0 到 100。这是主要关注的计数器。\n\n* `cluster_name_sst_stage` - 当前工作阶段的名称。该过程对每个被传输的表依次循环以下阶段：\n\n    * `await nodes sync`\n\n    * `block checksum calculate`\n\n    * `analyze remote`\n\n    * `send files`\n\n    * `activate tables`\n\n* `cluster_name_sst_stage_total` - 当前阶段的进度，范围从 0 到 100。\n\n* `cluster_name_sst_tables` - SST 中被传输的表的总数。\n\n* `cluster_name_sst_table` - 当前正在处理的表的名称和索引（例如，`3 (products)`）。\n\n对于大多数用例，`cluster_name_sst_total` 就足够了。然而，其他计数器对于调查在特定 SST 阶段或特定表上发生的停滞或性能问题非常有用。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- response SQL-->\n\nCODE_BLOCK_1\n\n<!-- request JSON -->\n\nCODE_BLOCK_2\n\n<!-- response JSON-->\n\nCODE_BLOCK_3\n\n<!-- request PHP -->\n\nCODE_BLOCK_4\n\n<!-- response PHP -->\n\nCODE_BLOCK_5\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_6\n\n<!-- response Python -->\n\nCODE_BLOCK_7\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_8\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_9\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_10\n\n<!-- response Javascript -->\n\nCODE_BLOCK_11\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_12\n\n<!-- response Java -->\n\nCODE_BLOCK_13\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_14\n\n<!-- response C# -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_16\n\n<!-- response Rust -->\n\nCODE_BLOCK_17\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "# Статус кластера репликации\n\n<!-- example Example -->\n\nВы можете просмотреть информацию о статусе кластера, проверив статус узла. Это можно сделать с помощью команды [Node status](../../Node_info_and_management/Node_status.md), которая отображает различную информацию об узле, включая переменные статуса кластера.\n\nФормат вывода для переменных статуса кластера следующий: `cluster_name_variable_name` `variable_value`. Большинство переменных описаны в [документации Galera Status Variables](https://galeracluster.com/library/documentation/galera-status-variables.html). Помимо этих переменных, Manticore Search также отображает:\n\n* `cluster_name` - имя кластера, как определено в [настройке репликации](../../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md#Replication-cluster)\n\n* `node_state` - текущее состояние узла: `closed`, `destroyed`, `joining`, `donor`, `synced`\n\n* `indexes_count` - количество таблиц, управляемых кластером\n\n* `indexes` - список имен таблиц, управляемых кластером\n\n* `nodes_set` - список узлов в кластере, определённых с помощью команд `CREATE`, `JOIN` или `ALTER UPDATE`\n\n* `nodes_view` - фактический список узлов в кластере, которые текущий узел видит.\n\n* `state_uuid` - UUID состояния кластера. Если оно совпадает со значением в local_state_uuid, локальные и кластерные узлы синхронизированы.\n\n* `conf_id` - общее количество изменений членства в кластере, которые произошли.\n\n* `status` - статус компонента кластера. Возможные значения: primary (конфигурация основного кластера, кворум присутствует), non_primary (конфигурация неосновного кластера, кворум потерян) или disconnected (не подключен к группе, повторная попытка).\n\n* `size` - количество узлов, в настоящее время находящихся в кластере.\n\n* `local_index` - индекс узла в кластере.\n\n* `last_error` - последнее зафиксированное сообщение об ошибке, связанной с операцией в кластере. Сообщение даёт общий обзор проблемы. Для более детальной информации следует обратиться к файлу `searchd.log`.\n\n### Переменные прогресса SST\n\nВо время передачи состояния (SST) один узел предоставляет другому полную копию данных. Это происходит, когда новый узел присоединяется к кластеру [JOIN CLUSTER](Creating_a_cluster/Setting_up_replication/Joining_a_replication_cluster.md) или когда добавляются новые таблицы [`ALTER CLUSTER ADD`](Creating_a_cluster/Setting_up_replication/Adding_and_removing_a_table_from_a_replication_cluster.md#Adding-and-removing-a-table-from-a-replication-cluster). Пока SST активен, на узлах-доноре и присоединяющемся будут доступны следующие дополнительные переменные статуса, прогресс которых синхронизирован.\n\n* `cluster_name_sst_total` - общий прогресс всей операции SST, от 0 до 100. Это основной счётчик для отслеживания.\n\n* `cluster_name_sst_stage` - название текущей фазы работы. Процесс проходит через эти этапы для каждой передаваемой таблицы:\n\n    * `await nodes sync`\n\n    * `block checksum calculate`\n\n    * `analyze remote`\n\n    * `send files`\n\n    * `activate tables`\n\n* `cluster_name_sst_stage_total` - прогресс текущего этапа, от 0 до 100.\n\n* `cluster_name_sst_tables` - общее количество таблиц, передаваемых в SST.\n\n* `cluster_name_sst_table` - имя и индекс таблицы, которая обрабатывается в данный момент (например, `3 (products)`).\n\nДля большинства сценариев использования достаточно `cluster_name_sst_total`. Однако другие счётчики могут быть полезны при исследовании задержек или проблем с производительностью на конкретном этапе SST или в определённой таблице.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- response SQL-->\n\nCODE_BLOCK_1\n\n<!-- request JSON -->\n\nCODE_BLOCK_2\n\n<!-- response JSON-->\n\nCODE_BLOCK_3\n\n<!-- request PHP -->\n\nCODE_BLOCK_4\n\n<!-- response PHP -->\n\nCODE_BLOCK_5\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_6\n\n<!-- response Python -->\n\nCODE_BLOCK_7\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_8\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_9\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_10\n\n<!-- response Javascript -->\n\nCODE_BLOCK_11\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_12\n\n<!-- response Java -->\n\nCODE_BLOCK_13\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_14\n\n<!-- response C# -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_16\n\n<!-- response Rust -->\n\nCODE_BLOCK_17\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
