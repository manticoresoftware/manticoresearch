{
  "8b51eb65c59210529151d5b9efb595c75aa3e55f0f841046c8a6045cecf508b7": {
    "original": "The `listen_tfo` option allows for the use of the TCP_FASTOPEN flag for all listeners. By default, it is managed by the system, but it can be explicitly turned off by setting it to '0'.\n\nFor more information about the TCP Fast Open extension, please refer to [Wikipedia](https://en.wikipedia.org/wiki/TCP_Fast_Open).  In short, it allows to eliminate one TCP round-trip when establishing a connection.\n\nIn practice, using TFO can optimize the client-agent network efficiency, similar to when `agent_persistent`  is in use, but without holding active connections and without limitations on the maximum number of connections.\n\nMost modern operating systems support TFO. Linux (as one of the most progressive) has supported it since 2011, with kernels starting from 3.7 (for the server side). Windows has supported it since some builds of Windows 10. Other systems, such as FreeBSD and MacOS, are also in the game.\n\nFor Linux systems, the server checks the variable `/proc/sys/net/ipv4/tcp_fastopen` and behaves accordingly. Bit 0 manages the client side, while bit 1 rules the listeners. By default, the system has this parameter set to 1, i.e., clients are enabled and listeners are disabled.\n\n### persistent_connections_limit\n\nCODE_BLOCK_13\n\nThe `persistent_connections_limit` option defines the maximum number of simultaneous persistent connections to remote persistent agents. This is an instance-wide setting and must be defined in the searchd configuration section. Each time a connection to an agent defined under `agent_persistent` is made, we attempt to reuse an existing connection (if one exists) or create a new connection and save it for future use. However, in some cases it may be necessary to limit the number of persistent connections. This directive defines the limit and affects the number of connections to each agent's host across all distributed tables.\n\nIt is recommended to set this value equal to or less than the [max_connections](../../Server_settings/Searchd.md#max_connections) option in the agent's configuration.\n\n## Distributed snippets creation\n\nA special case of a distributed table is a single local and multiple remotes, which is used exclusively for  [distributed snippets creation](../../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#Distributed-snippets-creation), when snippets are sourced from files. In this case, the local table may act as a \"template\" table, providing settings for tokenization when building snippets.\n\n### snippets_file_prefix\n\nCODE_BLOCK_14\n\nThe `snippets_file_prefix` is an optional prefix that can be added to the local file names when generating snippets. The default value is the current working folder.\n\nTo learn more about distributed snippets creation, see  [CALL SNIPPETS](../../Searching/Highlighting.md).\n\n## Distributed percolate tables (DPQ tables)\n\nYou can create a distributed table from multiple [percolate](../../Creating_a_table/Local_tables/Percolate_table.md) tables. The syntax for constructing this type of table is the same as for other distributed tables, and can include multiple`local` tables as well as `agents`.\n\nFor DPQ, the operations of listing stored queries and searching through them (using [CALL PQ](../../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ)) are transparent and work as if all the tables were one single local table. However, data manipulation statements such as `insert`, `replace`, `truncate` are not available.\n\nIf you include a non-percolate table in the list of agents, the behavior will be undefined. If the incorrect agent has the same schema as the outer schema of the PQ table (id, query, tags, filters), it will not trigger an error when listing stored PQ rules, and may pollute the list of actual PQ rules stored in PQ tables with its own non-PQ strings. As a result, be cautious and aware of the confusion that this may cause. A`CALL PQ` to such an incorrect agent will trigger an error.\n\nFor more information on making queries to a distributed percolate table, see [making queries to a distribute percolate table](../../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ).\n\n<!-- proofread -->",
    "translations": {
      "chinese": "`listen_tfo` 选项允许对所有监听器使用 TCP_FASTOPEN 标志。默认情况下，它由系统管理，但可以通过将其设置为 '0' 明确关闭。\n\n有关 TCP Fast Open 扩展的更多信息，请参阅 [Wikipedia](https://en.wikipedia.org/wiki/TCP_Fast_Open)。简而言之，它允许在建立连接时消除一次 TCP 往返。\n\n在实践中，使用 TFO 可以优化客户端代理的网络效率，类似于使用 `agent_persistent` 时的效果，但无需保持活动连接且不受最大连接数的限制。\n\n大多数现代操作系统都支持 TFO。Linux（作为最先进的系统之一）自 2011 年起支持它，内核版本从 3.7 开始支持（针对服务器端）。Windows 自某些 Windows 10 版本开始支持它。其他系统，如 FreeBSD 和 MacOS，也支持该功能。\n\n对于 Linux 系统，服务器会检查变量 `/proc/sys/net/ipv4/tcp_fastopen` 并据此行为。第 0 位管理客户端，第 1 位管理监听器。默认情况下，系统将此参数设置为 1，即启用客户端，禁用监听器。\n\n### persistent_connections_limit\n\nCODE_BLOCK_13\n\n`persistent_connections_limit` 选项定义了与远程持久代理的最大同时持久连接数。这是一个实例范围的设置，必须在 searchd 配置部分定义。每次连接到 `agent_persistent` 下定义的代理时，我们尝试重用现有连接（如果存在）或创建新连接并保存以供将来使用。然而，在某些情况下，可能需要限制持久连接的数量。该指令定义了限制，并影响所有分布式表中每个代理主机的连接数。\n\n建议将此值设置为代理配置中 [max_connections](../../Server_settings/Searchd.md#max_connections) 选项的相等或更小值。\n\n## 分布式片段创建\n\n分布式表的一个特殊情况是单个本地表和多个远程表，这种情况专门用于 [分布式片段创建](../../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#Distributed-snippets-creation)，当片段来源于文件时。在这种情况下，本地表可以作为“模板”表，提供构建片段时的分词设置。\n\n### snippets_file_prefix\n\nCODE_BLOCK_14\n\n`snippets_file_prefix` 是一个可选前缀，可以在生成片段时添加到本地文件名。默认值是当前工作文件夹。\n\n要了解有关分布式片段创建的更多信息，请参阅 [CALL SNIPPETS](../../Searching/Highlighting.md)。\n\n## 分布式预查询表（DPQ 表）\n\n您可以从多个 [percolate](../../Creating_a_table/Local_tables/Percolate_table.md) 表创建分布式表。构建此类表的语法与其他分布式表相同，可以包含多个 `local` 表以及 `agents`。\n\n对于 DPQ，列出存储查询和通过它们搜索（使用 [CALL PQ](../../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ)）的操作是透明的，表现得就像所有表都是一个单一的本地表。然而，数据操作语句如 `insert`、`replace`、`truncate` 不可用。\n\n如果在代理列表中包含非预查询表，行为将不确定。如果错误的代理具有与 PQ 表外层模式（id、query、tags、filters）相同的模式，列出存储的 PQ 规则时不会触发错误，可能会用其自身的非 PQ 字符串污染 PQ 表中实际存储的 PQ 规则列表。因此，请谨慎并意识到这可能引起的混淆。对这样的错误代理执行 `CALL PQ` 会触发错误。\n\n有关对分布式预查询表进行查询的更多信息，请参阅 [对分布式预查询表进行查询](../../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ)。\n\n<!-- proofread -->",
      "russian": "Опция `listen_tfo` позволяет использовать флаг TCP_FASTOPEN для всех слушателей. По умолчанию он управляется системой, но его можно явно отключить, установив значение '0'.\n\nДля получения дополнительной информации о расширении TCP Fast Open, пожалуйста, обратитесь к [Wikipedia](https://en.wikipedia.org/wiki/TCP_Fast_Open). Кратко, это позволяет исключить один круговой обмен TCP при установлении соединения.\n\nНа практике использование TFO может оптимизировать сетевую эффективность клиента-агента, аналогично использованию `agent_persistent`, но без удержания активных соединений и без ограничений на максимальное количество соединений.\n\nБольшинство современных операционных систем поддерживают TFO. Linux (как одна из самых прогрессивных) поддерживает его с 2011 года, начиная с ядер версии 3.7 (для серверной стороны). Windows поддерживает его с некоторых сборок Windows 10. Другие системы, такие как FreeBSD и MacOS, также поддерживают эту функцию.\n\nДля систем Linux сервер проверяет переменную `/proc/sys/net/ipv4/tcp_fastopen` и ведет себя соответственно. Бит 0 управляет клиентской стороной, а бит 1 — слушателями. По умолчанию в системе этот параметр установлен в 1, то есть клиенты включены, а слушатели отключены.\n\n### persistent_connections_limit\n\nCODE_BLOCK_13\n\nОпция `persistent_connections_limit` определяет максимальное количество одновременных постоянных соединений с удалёнными постоянными агентами. Это настройка на уровне экземпляра и должна быть определена в разделе конфигурации searchd. Каждый раз при установлении соединения с агентом, определённым в `agent_persistent`, мы пытаемся повторно использовать существующее соединение (если оно есть) или создать новое и сохранить его для будущего использования. Однако в некоторых случаях может потребоваться ограничить количество постоянных соединений. Эта директива задаёт лимит и влияет на количество соединений с хостом каждого агента во всех распределённых таблицах.\n\nРекомендуется устанавливать это значение равным или меньшим, чем опция [max_connections](../../Server_settings/Searchd.md#max_connections) в конфигурации агента.\n\n## Создание распределённых сниппетов\n\nОсобым случаем распределённой таблицы является одна локальная и несколько удалённых, которая используется исключительно для [создания распределённых сниппетов](../../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#Distributed-snippets-creation), когда сниппеты берутся из файлов. В этом случае локальная таблица может выступать в роли \"шаблонной\" таблицы, предоставляя настройки для токенизации при построении сниппетов.\n\n### snippets_file_prefix\n\nCODE_BLOCK_14\n\n`snippets_file_prefix` — это необязательный префикс, который можно добавить к локальным именам файлов при генерации сниппетов. Значение по умолчанию — текущая рабочая папка.\n\nЧтобы узнать больше о создании распределённых сниппетов, смотрите [CALL SNIPPETS](../../Searching/Highlighting.md).\n\n## Распределённые перколяторные таблицы (DPQ таблицы)\n\nВы можете создать распределённую таблицу из нескольких [перколяторных](../../Creating_a_table/Local_tables/Percolate_table.md) таблиц. Синтаксис построения такого типа таблиц такой же, как и для других распределённых таблиц, и может включать несколько `local` таблиц, а также `agents`.\n\nДля DPQ операции перечисления сохранённых запросов и поиска по ним (с использованием [CALL PQ](../../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ)) прозрачны и работают так, как если бы все таблицы были одной локальной таблицей. Однако операции изменения данных, такие как `insert`, `replace`, `truncate`, недоступны.\n\nЕсли в список агентов включена не перколяторная таблица, поведение будет неопределённым. Если неправильный агент имеет ту же схему, что и внешняя схема PQ таблицы (id, query, tags, filters), это не вызовет ошибку при перечислении сохранённых правил PQ и может загрязнить список фактических правил PQ, хранящихся в PQ таблицах, своими собственными не-PQ строками. В результате будьте осторожны и осознавайте возможную путаницу. Вызов `CALL PQ` к такому неправильному агенту вызовет ошибку.\n\nДля получения дополнительной информации о выполнении запросов к распределённой перколяторной таблице смотрите [выполнение запросов к распределённой перколяторной таблице](../../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ).\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "9acadf87429d56a1ce43f8a4e96f9a94e62f7bf6b922705e3f7c09b9df3b09e3": {
    "original": "Using persistent master-agent connections reduces TCP port pressure and saves time on connection handshakes, making it more efficient.\n\n## agent_blackhole\n\nCODE_BLOCK_9\n\nThe `agent_blackhole` directive allows you to forward queries to remote agents without waiting for or processing their responses. This is useful for debugging or testing production clusters, as you can set up a separate debugging/testing instance and forward requests to it from the production master (aggregator) instance, without interfering with production work. The master searchd will attempt to connect to the blackhole agent and send queries as normal, but will not wait for or process any responses, and all network errors on the blackhole agents will be ignored. The format of the value is identical to that of the regular `agent` directive.\n\n## agent_connect_timeout\n\nCODE_BLOCK_10\n\nThe `agent_connect_timeout` directive defines the timeout for connecting to remote agents. By default, the value is assumed to be in milliseconds, but can have [another suffix](../../Server_settings/Special_suffixes.md)). The default value is 1000 (1 second).\n\nWhen connecting to remote agents, `searchd` will wait for this amount of time at most to complete the connection successfully. If the timeout is reached but the connection has not been established, and `retries` are enabled, a retry will be initiated.\n\n## agent_query_timeout\n\nCODE_BLOCK_11\n\nThe `agent_query_timeout` sets the amount of time that searchd will wait for a remote agent to complete a query. The default value is 3000 milliseconds (3 seconds), but can be `suffixed` to indicate a different unit of time.\n\nAfter establishing a connection, `searchd` will wait for a maximum of agent_query_timeout for remote queries to complete. Note that this timeout is separate from the `agent_connection_timeout` and the total possible delay caused by a remote agent will be the sum of both values. If the agent_query_timeout is reached, the query will **not** be retried, instead, a warning will be produced.\n\nNote that behavior is also affected by [reset_network_timeout_on_packet](../../Server_settings/Searchd.md#reset_network_timeout_on_packet)\n\n## agent_retry_count\n\nThe `agent_retry_count` is an integer that specifies how many times Manticore will attempt to connect and query remote agents in a distributed table before reporting a fatal query error. It works similarly to `agent_retry_count` defined in the \"searchd\" section of the configuration file but applies specifically to the table.\n\n## mirror_retry_count\n\n`mirror_retry_count` serves the same purpose as `agent_retry_count`.  If both values are provided, `mirror_retry_count` will take precedence, and a warning will be raised.\n\n## Instance-wide options\n\nThe following options manage the overall behavior of remote agents and are specified in **the searchd section of the configuration file**. They set default values for the entire Manticore instance.\n\n* `agent_connect_timeout` - default value for the `agent_connect_timeout` parameter.\n\n* `agent_query_timeout` - default value for the `agent_query_timeout` parameter. This can also be overridden on a per-query basis using the same setting name in a distributed (network) table.\n\n* `agent_retry_count` is an integer that specifies the number of times Manticore will attempt to connect and query remote agents in a distributed table before reporting a fatal query error. The default value is 0 (i.e. no retries). This value can also be specified on a per-query basis using the 'OPTION retry_count=XXX' clause. If a per-query option is provided, it will take precedence over the value specified in the config.\n\nNote, that if you use **agent mirrors** in the definition of your distributed table, the server will select a different mirror before each connection attempt according to the specified [ha_strategy](../../Creating_a_cluster/Remote_nodes/Load_balancing.md#ha_strategy) specified. In this case the [agent_retry_count](../../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_retry_count) will be aggregated for all mirrors in the set.\n\nFor example, if you have 10 mirrors and set `agent_retry_count=5`, he server will attempt up to 50 retries (assuming an average of 5 tries per every 10 mirrors). In case of the option `ha_strategy = roundrobin`, it will actually be exactly 5 tries per mirror.\n\nAt the same time, the value provided as the [retry_count](../../Searching/Options.md#retry_count) option in the `agent` definition serves as an absolute limit. In other words, the `[retry_count=2]` option in the agent definition means there will be a maximum of 2 tries, regardless of whether there is 1 or 10 mirrors in the line.\n\n### agent_retry_delay\n\nThe `agent_retry_delay` is an integer value that determines the amount of time, in milliseconds, that Manticore Search will wait before retrying to query a remote agent in case of a failure. This value can be specified either globally in the searchd configuration or on a per-query basis using the `OPTION retry_delay=XXX` clause. If both options are provided, the per-query option will take precedence over the global one. The default value is 500 milliseconds (0.5 seconds). This option is only relevant if agent_retry_count or the per-query `OPTION retry_count` are non-zero.\n\n### client_timeout\n\nThe `client_timeout` option sets the maximum waiting time between requests when using persistent connections. This value is expressed in seconds or with a time suffix. The default value is 5 minutes.\n\nExample:\n\nCODE_BLOCK_12\n\n### hostname_lookup\n\nThe `hostname_lookup` option defines the strategy for renewing hostnames. By default, the IP addresses of agent host names are cached at server start to avoid excessive access to DNS. However, in some cases, the IP can change dynamically (e.g. cloud hosting) and it may be desirable to not cache the IPs. Setting this option to `request` disables the caching and queries the DNS for each query. The IP addresses can also be manually renewed using the `FLUSH HOSTNAMES` command.\n\n### listen_tfo",
    "translations": {
      "chinese": "使用持久的主-代理连接可以减少 TCP 端口压力并节省连接握手时间，从而提高效率。\n\n## agent_blackhole\n\nCODE_BLOCK_9\n\n`agent_blackhole` 指令允许您将查询转发到远程代理，而无需等待或处理它们的响应。这对于调试或测试生产集群非常有用，因为您可以设置一个单独的调试/测试实例，并从生产主（聚合器）实例将请求转发到该实例，而不会干扰生产工作。主 searchd 将尝试连接到黑洞代理并正常发送查询，但不会等待或处理任何响应，且所有黑洞代理上的网络错误将被忽略。该值的格式与常规的 `agent` 指令相同。\n\n## agent_connect_timeout\n\nCODE_BLOCK_10\n\n`agent_connect_timeout` 指令定义连接到远程代理的超时时间。默认情况下，值被假定为毫秒，但可以有[其他后缀](../../Server_settings/Special_suffixes.md))。默认值为 1000（1 秒）。\n\n连接到远程代理时，`searchd` 最多等待此时间以成功完成连接。如果达到超时但连接尚未建立，并且启用了 `retries`，则会启动重试。\n\n## agent_query_timeout\n\nCODE_BLOCK_11\n\n`agent_query_timeout` 设置 searchd 等待远程代理完成查询的时间。默认值为 3000 毫秒（3 秒），但可以通过后缀表示不同的时间单位。\n\n建立连接后，`searchd` 将最多等待 agent_query_timeout 时间以完成远程查询。请注意，此超时与 `agent_connection_timeout` 是分开的，远程代理可能导致的总延迟是两者之和。如果达到 agent_query_timeout，查询将**不会**重试，而是会产生警告。\n\n请注意，行为还受 [reset_network_timeout_on_packet](../../Server_settings/Searchd.md#reset_network_timeout_on_packet) 的影响。\n\n## agent_retry_count\n\n`agent_retry_count` 是一个整数，指定 Manticore 在报告致命查询错误之前，在分布式表中尝试连接和查询远程代理的次数。它的工作方式类似于配置文件中 \"searchd\" 部分定义的 `agent_retry_count`，但专门应用于表。\n\n## mirror_retry_count\n\n`mirror_retry_count` 的作用与 `agent_retry_count` 相同。如果同时提供了两个值，`mirror_retry_count` 将优先，并会发出警告。\n\n## 实例范围选项\n\n以下选项管理远程代理的整体行为，并在**配置文件的 searchd 部分**中指定。它们为整个 Manticore 实例设置默认值。\n\n* `agent_connect_timeout` - `agent_connect_timeout` 参数的默认值。\n\n* `agent_query_timeout` - `agent_query_timeout` 参数的默认值。此值也可以在分布式（网络）表中使用相同的设置名称按查询覆盖。\n\n* `agent_retry_count` 是一个整数，指定 Manticore 在报告致命查询错误之前，在分布式表中尝试连接和查询远程代理的次数。默认值为 0（即不重试）。此值也可以通过 'OPTION retry_count=XXX' 子句按查询指定。如果提供了按查询选项，它将优先于配置文件中指定的值。\n\n注意，如果您在分布式表的定义中使用了**代理镜像**，服务器将在每次连接尝试之前根据指定的 [ha_strategy](../../Creating_a_cluster/Remote_nodes/Load_balancing.md#ha_strategy) 选择不同的镜像。在这种情况下，[agent_retry_count](../../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_retry_count) 将针对集合中的所有镜像进行汇总。\n\n例如，如果您有 10 个镜像并设置 `agent_retry_count=5`，服务器将尝试最多 50 次重试（假设每 10 个镜像平均尝试 5 次）。如果选项为 `ha_strategy = roundrobin`，则每个镜像实际上正好尝试 5 次。\n\n同时，`agent` 定义中提供的 [retry_count](../../Searching/Options.md#retry_count) 选项作为绝对限制。换句话说，代理定义中的 `[retry_count=2]` 选项意味着最多尝试 2 次，无论线路中有 1 个还是 10 个镜像。\n\n### agent_retry_delay\n\n`agent_retry_delay` 是一个整数值，表示 Manticore Search 在失败后重试查询远程代理之前等待的时间，单位为毫秒。此值可以在 searchd 配置中全局指定，也可以通过 `OPTION retry_delay=XXX` 子句按查询指定。如果同时提供了两个选项，按查询选项优先于全局选项。默认值为 500 毫秒（0.5 秒）。此选项仅在 agent_retry_count 或按查询的 `OPTION retry_count` 非零时相关。\n\n### client_timeout\n\n`client_timeout` 选项设置使用持久连接时请求之间的最大等待时间。该值以秒或带时间后缀的形式表示。默认值为 5 分钟。\n\n示例：\n\nCODE_BLOCK_12\n\n### hostname_lookup\n\n`hostname_lookup` 选项定义更新主机名的策略。默认情况下，代理主机名的 IP 地址在服务器启动时缓存，以避免过度访问 DNS。然而，在某些情况下，IP 可能动态变化（例如云托管），可能希望不缓存 IP。将此选项设置为 `request` 会禁用缓存，并在每次查询时查询 DNS。IP 地址也可以使用 `FLUSH HOSTNAMES` 命令手动更新。\n\n### listen_tfo",
      "russian": "Использование постоянных соединений мастер-агент снижает нагрузку на TCP-порты и экономит время на установку соединений, делая процесс более эффективным.\n\n## agent_blackhole\n\nCODE_BLOCK_9\n\nДиректива `agent_blackhole` позволяет пересылать запросы удалённым агентам без ожидания или обработки их ответов. Это полезно для отладки или тестирования производственных кластеров, так как можно настроить отдельный экземпляр для отладки/тестирования и пересылать запросы к нему с производственного мастер-экземпляра (агрегатора), не мешая работе в продакшене. Мастер searchd будет пытаться подключиться к blackhole-агенту и отправлять запросы как обычно, но не будет ждать или обрабатывать ответы, а все сетевые ошибки на blackhole-агентах будут игнорироваться. Формат значения идентичен формату обычной директивы `agent`.\n\n## agent_connect_timeout\n\nCODE_BLOCK_10\n\nДиректива `agent_connect_timeout` задаёт таймаут подключения к удалённым агентам. По умолчанию значение считается в миллисекундах, но может иметь [другой суффикс](../../Server_settings/Special_suffixes.md)). Значение по умолчанию — 1000 (1 секунда).\n\nПри подключении к удалённым агентам `searchd` будет ждать не более этого времени для успешного установления соединения. Если таймаут достигнут, но соединение не установлено, и включены `retries`, будет предпринята повторная попытка.\n\n## agent_query_timeout\n\nCODE_BLOCK_11\n\nДиректива `agent_query_timeout` задаёт время ожидания выполнения запроса удалённым агентом. Значение по умолчанию — 3000 миллисекунд (3 секунды), но может иметь `суффикс` для указания другой единицы времени.\n\nПосле установления соединения `searchd` будет ждать не более agent_query_timeout для завершения удалённых запросов. Обратите внимание, что этот таймаут отличается от `agent_connection_timeout`, и общая возможная задержка, вызванная удалённым агентом, будет суммой обоих значений. Если таймаут agent_query_timeout достигнут, запрос **не** будет повторяться, вместо этого будет выдано предупреждение.\n\nОбратите внимание, что поведение также зависит от [reset_network_timeout_on_packet](../../Server_settings/Searchd.md#reset_network_timeout_on_packet)\n\n## agent_retry_count\n\nДиректива `agent_retry_count` — целое число, указывающее, сколько раз Manticore попытается подключиться и выполнить запрос к удалённым агентам в распределённой таблице, прежде чем сообщить о фатальной ошибке запроса. Работает аналогично `agent_retry_count`, определённому в разделе \"searchd\" конфигурационного файла, но применяется конкретно к таблице.\n\n## mirror_retry_count\n\n`mirror_retry_count` выполняет ту же функцию, что и `agent_retry_count`. Если заданы оба значения, приоритет будет у `mirror_retry_count`, и будет выдано предупреждение.\n\n## Параметры на уровне экземпляра\n\nСледующие параметры управляют общим поведением удалённых агентов и задаются в **разделе searchd конфигурационного файла**. Они устанавливают значения по умолчанию для всего экземпляра Manticore.\n\n* `agent_connect_timeout` — значение по умолчанию для параметра `agent_connect_timeout`.\n\n* `agent_query_timeout` — значение по умолчанию для параметра `agent_query_timeout`. Его также можно переопределить для каждого запроса, используя то же имя параметра в распределённой (сетевой) таблице.\n\n* `agent_retry_count` — целое число, указывающее количество попыток подключения и запроса к удалённым агентам в распределённой таблице до сообщения о фатальной ошибке. Значение по умолчанию — 0 (т.е. без повторных попыток). Это значение также можно задать для каждого запроса с помощью опции 'OPTION retry_count=XXX'. Если задана опция для конкретного запроса, она имеет приоритет над значением из конфигурации.\n\nОбратите внимание, что если вы используете **agent mirrors** в определении вашей распределённой таблицы, сервер будет выбирать другой mirror перед каждой попыткой подключения согласно указанной [ha_strategy](../../Creating_a_cluster/Remote_nodes/Load_balancing.md#ha_strategy). В этом случае значение [agent_retry_count](../../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_retry_count) будет суммироваться для всех mirrors в наборе.\n\nНапример, если у вас 10 mirrors и задано `agent_retry_count=5`, сервер попытается выполнить до 50 повторных попыток (в среднем 5 попыток на каждые 10 mirrors). В случае опции `ha_strategy = roundrobin` будет ровно 5 попыток на каждый mirror.\n\nПри этом значение, заданное в опции [retry_count](../../Searching/Options.md#retry_count) в определении `agent`, служит абсолютным лимитом. Другими словами, опция `[retry_count=2]` в определении агента означает максимум 2 попытки, независимо от того, 1 или 10 mirrors в строке.\n\n### agent_retry_delay\n\nДиректива `agent_retry_delay` — целочисленное значение, определяющее время в миллисекундах, которое Manticore Search будет ждать перед повторной попыткой запроса к удалённому агенту в случае сбоя. Это значение можно задать глобально в конфигурации searchd или для каждого запроса с помощью опции `OPTION retry_delay=XXX`. Если заданы обе опции, приоритет имеет опция для конкретного запроса. Значение по умолчанию — 500 миллисекунд (0.5 секунды). Эта опция актуальна только если `agent_retry_count` или опция `OPTION retry_count` для запроса не равны нулю.\n\n### client_timeout\n\nОпция `client_timeout` задаёт максимальное время ожидания между запросами при использовании постоянных соединений. Значение указывается в секундах или с суффиксом времени. Значение по умолчанию — 5 минут.\n\nПример:\n\nCODE_BLOCK_12\n\n### hostname_lookup\n\nОпция `hostname_lookup` определяет стратегию обновления имён хостов. По умолчанию IP-адреса имён агентов кэшируются при запуске сервера, чтобы избежать чрезмерных обращений к DNS. Однако в некоторых случаях IP может динамически меняться (например, облачный хостинг), и может быть желательно не кэшировать IP. Установка этой опции в `request` отключает кэширование и выполняет запросы к DNS для каждого запроса. IP-адреса также можно обновить вручную с помощью команды `FLUSH HOSTNAMES`.\n\n### listen_tfo"
    },
    "is_code_or_comment": false
  },
  "dcd05be388471933c5cf43eb6b4bad6db503f2956c8f68ba4231b10523386f8d": {
    "original": "# Remote tables\n\nA remote table in Manticore Search is represented by the [agent](../../Creating_a_table/Creating_a_distributed_table/Creating_a_distributed_table.md) prefix in the definition of a distributed table. A distributed table can include a combination of local and remote tables. If there are no local tables provided, the distributed table will be purely remote and serve as a proxy only. For example, you might have a Manticore instance that listens on multiple ports and serves different protocols, and then redirects queries to backend servers that only accept connections via Manticore's internal binary protocol, using persistent connections to reduce the overhead of establishing connections.\n\nEven though a purely remote distributed table doesn't serve local tables itself, it still consumes machine resources, as it still needs to perform final calculations, such as merging results and calculating final aggregated values.\n\n## agent\n\nCODE_BLOCK_0\n\n`agent` directive declares the remote agents that are searched each time the enclosing distributed table is searched. These agents are essentially pointers to networked tables. The value specified includes the address and can also include multiple alternatives (agent mirrors) for either the address only or the address and table list.\n\nThe address specification must be one of the following:\n\nCODE_BLOCK_1\n\nThe `hostname` is the remote host name, `port` is the remote TCP port number, `table-list` is a comma-separated list of table names, and square brackets [] indicate an optional clause.\n\nIf the table name is omitted, it is assumed to be the same table as the one where this line is defined. In other words, when defining agents for the 'mycoolindex' distributed table, you can simply point to the address, and it will be assumed that you are querying the mycoolindex table on the agent's endpoints.\n\nIf the port number is omitted, it is assumed to be **9312**. If it is defined but invalid (e.g. 70000), the agent will be skipped.\n\nYou can point each agent to one or more remote tables residing on one or more networked servers with no restrictions. This enables several different usage modes:\n\n* Sharding over multiple agent servers and creating an arbitrary cluster topology\n\n* Sharding over multiple agent servers mirrored for high availability and load balancing purposes\n\n* Sharding within localhost to utilize multiple cores (however, it is simpler just to use multiple local tables)\n\nAll agents are searched in parallel. The index list is passed verbatim to the remote agent. The exact way that list is searched within the agent (i.e. sequentially or in parallel) depends solely on the agent's configuration (see the [threads](../../Server_settings/Searchd.md#threads) setting). The master has no remote control over this.\n\nIt is important to note that the `LIMIT`, option is ignored in agent queries. This is because each agent can contain different tables, so it is the responsibility of the client to apply the limit to the final result set. This is why the query to a physical table is different from the query to a distributed table when viewed in the query logs. The query cannot be a simple copy of the original query, as this would not produce the correct results.\n\nFor example, if a client makes a query SELECT ... LIMIT 10, 10, and there are two agents, with the second agent having only 10 documents, broadcasting the original `LIMIT 10, 10` query would result in receiving 0 documents from the second agent. However, `LIMIT 10,10` should return documents 10-20 from the resulting set. To resolve this, the query must be sent to the agents with a broader limit, such as the default max_matches value of 1000.\n\nFor instance, if there is a distributed table dist that refers to the remote table user, a client query `SELECT * FROM dist LIMIT 10,10` would be converted to `SELECT * FROM user LIMIT 0,1000` and sent to the remote table user. Once the distributed table receives the result, it will apply the LIMIT 10,10 and return the requested 10 documents.\n\nCODE_BLOCK_2\n\nthe query will be converted to:\n\nCODE_BLOCK_3\n\nAdditionally, the value can specify options for each individual agent, such as:\n\n* [ha_strategy](../../Creating_a_cluster/Remote_nodes/Load_balancing.md#ha_strategy) - `random`, `roundrobin`, `nodeads`, `noerrors` (overrides the global `ha_strategy` setting for the particular agent)\n\n* `conn` - `pconn`, persistent (equivalent to setting `agent_persistent` at the table level)\n\n* `blackhole` `0`,`1` (identical to the [agent_blackhole](../../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_blackhole) setting for the agent)\n\n* `retry_count` an integer value (corresponding to [agent_retry_count](../../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_retry_count) , but the provided value will not be multiplied by the number of mirrors)\n\nCODE_BLOCK_4\n\nExample:\n\nCODE_BLOCK_5\n\nFor optimal performance, it's recommended to place remote tables that reside on the same server within the same record. For instance, instead of:\n\nCODE_BLOCK_6\n\nyou should prefer:\n\nCODE_BLOCK_7\n\n## agent_persistent\n\nCODE_BLOCK_8\n\nThe `agent_persistent` option allows you to persistently connect to an agent, meaning the connection will not be dropped after a query is executed. The syntax for this directive is the same as the `agent` directive. However, instead of opening a new connection to the agent for each query and then closing it, the master will keep a connection open and reuse it for subsequent queries. The maximum number of persistent connections per agent host is defined by the [persistent_connections_limit](../../Server_settings/Searchd.md#persistent_connections_limit) option in the searchd section.\n\nIt's important to note that the [persistent_connections_limit](../../Server_settings/Searchd.md#persistent_connections_limit) must be set to a value greater than 0 in order to use persistent agent connections. If it's not defined, it defaults to 0, and the `agent_persistent` directive will act the same as the `agent`directive.",
    "translations": {
      "chinese": "# 远程表\n\nManticore Search 中的远程表由分布式表定义中的 [agent](../../Creating_a_table/Creating_a_distributed_table/Creating_a_distributed_table.md) 前缀表示。分布式表可以包含本地表和远程表的组合。如果没有提供本地表，分布式表将纯粹是远程的，仅作为代理。例如，您可能有一个监听多个端口并服务不同协议的 Manticore 实例，然后将查询重定向到仅通过 Manticore 内部二进制协议接受连接的后端服务器，使用持久连接以减少建立连接的开销。\n\n即使纯远程分布式表本身不提供本地表，它仍然会消耗机器资源，因为它仍需要执行最终计算，例如合并结果和计算最终聚合值。\n\n## agent\n\nCODE_BLOCK_0\n\n`agent` 指令声明每次搜索包含的分布式表时要搜索的远程代理。这些代理本质上是指向网络表的指针。指定的值包括地址，也可以包括多个备选项（代理镜像），用于仅地址或地址和表列表。\n\n地址规范必须是以下之一：\n\nCODE_BLOCK_1\n\n`hostname` 是远程主机名，`port` 是远程 TCP 端口号，`table-list` 是以逗号分隔的表名列表，方括号 [] 表示可选子句。\n\n如果省略表名，则假定为定义此行的同一表。换句话说，在为 'mycoolindex' 分布式表定义代理时，您可以仅指向地址，系统将假定您正在查询代理端点上的 mycoolindex 表。\n\n如果省略端口号，则假定为 **9312**。如果定义了但无效（例如 70000），则该代理将被跳过。\n\n您可以将每个代理指向一个或多个位于一个或多个网络服务器上的远程表，没有限制。这支持多种使用模式：\n\n* 在多个代理服务器上分片并创建任意集群拓扑\n\n* 在多个代理服务器上分片，镜像以实现高可用性和负载均衡\n\n* 在本地主机内分片以利用多个核心（不过，使用多个本地表更简单）\n\n所有代理并行搜索。索引列表原样传递给远程代理。该列表在代理内的具体搜索方式（即顺序或并行）完全取决于代理的配置（参见 [threads](../../Server_settings/Searchd.md#threads) 设置）。主服务器无法远程控制此行为。\n\n需要注意的是，`LIMIT` 选项在代理查询中被忽略。这是因为每个代理可能包含不同的表，因此客户端负责对最终结果集应用限制。这就是为什么查询物理表与查询分布式表在查询日志中显示不同的原因。查询不能简单复制原始查询，因为这样不会产生正确结果。\n\n例如，如果客户端发出查询 SELECT ... LIMIT 10, 10，且有两个代理，第二个代理只有 10 个文档，广播原始 `LIMIT 10, 10` 查询将导致从第二个代理收到 0 个文档。然而，`LIMIT 10,10` 应该返回结果集中的第 10 到 20 个文档。为解决此问题，必须向代理发送更宽松的限制查询，例如默认的 max_matches 值 1000。\n\n例如，如果有一个分布式表 dist 指向远程表 user，客户端查询 `SELECT * FROM dist LIMIT 10,10` 会被转换为 `SELECT * FROM user LIMIT 0,1000` 并发送到远程表 user。一旦分布式表收到结果，它将应用 LIMIT 10,10 并返回请求的 10 个文档。\n\nCODE_BLOCK_2\n\n查询将被转换为：\n\nCODE_BLOCK_3\n\n此外，值可以为每个单独代理指定选项，例如：\n\n* [ha_strategy](../../Creating_a_cluster/Remote_nodes/Load_balancing.md#ha_strategy) - `random`，`roundrobin`，`nodeads`，`noerrors`（覆盖特定代理的全局 `ha_strategy` 设置）\n\n* `conn` - `pconn`，持久连接（等同于在表级设置 `agent_persistent`）\n\n* `blackhole` `0`，`1`（与代理的 [agent_blackhole](../../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_blackhole) 设置相同）\n\n* `retry_count` 整数值（对应 [agent_retry_count](../../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_retry_count)，但提供的值不会乘以镜像数量）\n\nCODE_BLOCK_4\n\n示例：\n\nCODE_BLOCK_5\n\n为获得最佳性能，建议将位于同一服务器上的远程表放在同一条记录中。例如，不要这样写：\n\nCODE_BLOCK_6\n\n而应优先这样写：\n\nCODE_BLOCK_7\n\n## agent_persistent\n\nCODE_BLOCK_8\n\n`agent_persistent` 选项允许您与代理保持持久连接，即查询执行后连接不会断开。该指令的语法与 `agent` 指令相同。但不是为每个查询打开新连接然后关闭，主服务器会保持连接打开并重用它进行后续查询。每个代理主机的最大持久连接数由 searchd 部分的 [persistent_connections_limit](../../Server_settings/Searchd.md#persistent_connections_limit) 选项定义。\n\n需要注意的是，必须将 [persistent_connections_limit](../../Server_settings/Searchd.md#persistent_connections_limit) 设置为大于 0 的值才能使用持久代理连接。如果未定义，则默认为 0，`agent_persistent` 指令将与 `agent` 指令行为相同。",
      "russian": "# Удалённые таблицы\n\nУдалённая таблица в Manticore Search представлена префиксом [agent](../../Creating_a_table/Creating_a_distributed_table/Creating_a_distributed_table.md) в определении распределённой таблицы. Распределённая таблица может включать комбинацию локальных и удалённых таблиц. Если локальные таблицы не указаны, распределённая таблица будет полностью удалённой и служить только в качестве прокси. Например, у вас может быть экземпляр Manticore, который слушает на нескольких портах и обслуживает разные протоколы, а затем перенаправляет запросы на серверы бэкенда, которые принимают соединения только через внутренний бинарный протокол Manticore, используя постоянные соединения для уменьшения накладных расходов на установление соединений.\n\nХотя полностью удалённая распределённая таблица сама по себе не обслуживает локальные таблицы, она всё равно потребляет ресурсы машины, так как ей всё равно нужно выполнять окончательные вычисления, такие как слияние результатов и вычисление итоговых агрегированных значений.\n\n## agent\n\nCODE_BLOCK_0\n\nДиректива `agent` объявляет удалённых агентов, которые ищутся каждый раз при поиске во включённой распределённой таблице. Эти агенты по сути являются указателями на сетевые таблицы. Указанное значение включает адрес и может также включать несколько альтернатив (зеркал агентов) либо только для адреса, либо для адреса и списка таблиц.\n\nСпецификация адреса должна быть одной из следующих:\n\nCODE_BLOCK_1\n\n`hostname` — это имя удалённого хоста, `port` — номер удалённого TCP-порта, `table-list` — список имён таблиц, разделённых запятыми, а квадратные скобки [] обозначают необязательное условие.\n\nЕсли имя таблицы опущено, предполагается, что это та же таблица, где определена эта строка. Другими словами, при определении агентов для распределённой таблицы 'mycoolindex' вы можете просто указать адрес, и будет предполагаться, что вы запрашиваете таблицу mycoolindex на конечных точках агента.\n\nЕсли номер порта опущен, предполагается значение **9312**. Если он указан, но недействителен (например, 70000), агент будет пропущен.\n\nВы можете указать каждому агенту одну или несколько удалённых таблиц, расположенных на одном или нескольких сетевых серверах без ограничений. Это позволяет несколько различных режимов использования:\n\n* Шардирование по нескольким серверам агентов и создание произвольной топологии кластера\n\n* Шардирование по нескольким серверам агентов, зеркалированным для высокой доступности и балансировки нагрузки\n\n* Шардирование внутри localhost для использования нескольких ядер (однако проще просто использовать несколько локальных таблиц)\n\nВсе агенты ищутся параллельно. Список индексов передаётся удалённому агенту дословно. Точный способ поиска по этому списку внутри агента (т.е. последовательно или параллельно) зависит исключительно от конфигурации агента (см. настройку [threads](../../Server_settings/Searchd.md#threads)). Мастер не имеет удалённого контроля над этим.\n\nВажно отметить, что опция `LIMIT` игнорируется в запросах к агентам. Это связано с тем, что каждый агент может содержать разные таблицы, поэтому ответственность за применение ограничения к итоговому набору результатов лежит на клиенте. Именно поэтому запрос к физической таблице отличается от запроса к распределённой таблице при просмотре логов запросов. Запрос не может быть простой копией исходного запроса, так как это не даст правильных результатов.\n\nНапример, если клиент выполняет запрос SELECT ... LIMIT 10, 10, и есть два агента, при этом у второго агента всего 10 документов, то трансляция исходного запроса `LIMIT 10, 10` приведёт к получению 0 документов от второго агента. Однако `LIMIT 10,10` должен вернуть документы с 10 по 20 из итогового набора. Чтобы решить эту проблему, запрос должен быть отправлен агентам с более широким лимитом, например, с использованием значения max_matches по умолчанию 1000.\n\nНапример, если есть распределённая таблица dist, которая ссылается на удалённую таблицу user, запрос клиента `SELECT * FROM dist LIMIT 10,10` будет преобразован в `SELECT * FROM user LIMIT 0,1000` и отправлен удалённой таблице user. После получения результата распределённая таблица применит LIMIT 10,10 и вернёт запрошенные 10 документов.\n\nCODE_BLOCK_2\n\nзапрос будет преобразован в:\n\nCODE_BLOCK_3\n\nКроме того, значение может указывать опции для каждого отдельного агента, такие как:\n\n* [ha_strategy](../../Creating_a_cluster/Remote_nodes/Load_balancing.md#ha_strategy) - `random`, `roundrobin`, `nodeads`, `noerrors` (переопределяет глобальную настройку `ha_strategy` для конкретного агента)\n\n* `conn` - `pconn`, persistent (эквивалентно установке `agent_persistent` на уровне таблицы)\n\n* `blackhole` `0`,`1` (идентично настройке [agent_blackhole](../../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_blackhole) для агента)\n\n* `retry_count` целочисленное значение (соответствует [agent_retry_count](../../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_retry_count), но указанное значение не будет умножаться на количество зеркал)\n\nCODE_BLOCK_4\n\nПример:\n\nCODE_BLOCK_5\n\nДля оптимальной производительности рекомендуется размещать удалённые таблицы, находящиеся на одном сервере, в одной записи. Например, вместо:\n\nCODE_BLOCK_6\n\nследует предпочесть:\n\nCODE_BLOCK_7\n\n## agent_persistent\n\nCODE_BLOCK_8\n\nОпция `agent_persistent` позволяет устанавливать постоянное соединение с агентом, то есть соединение не будет разрываться после выполнения запроса. Синтаксис этой директивы такой же, как у директивы `agent`. Однако вместо открытия нового соединения с агентом для каждого запроса и последующего его закрытия, мастер будет поддерживать открытое соединение и повторно использовать его для последующих запросов. Максимальное количество постоянных соединений на хост агента определяется опцией [persistent_connections_limit](../../Server_settings/Searchd.md#persistent_connections_limit) в разделе searchd.\n\nВажно отметить, что [persistent_connections_limit](../../Server_settings/Searchd.md#persistent_connections_limit) должен быть установлен в значение больше 0 для использования постоянных соединений с агентом. Если он не определён, по умолчанию равен 0, и директива `agent_persistent` будет работать так же, как директива `agent`."
    },
    "is_code_or_comment": false
  }
}
