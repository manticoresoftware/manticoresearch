{
  "8a845d377d4d5bcd847d327db1d220392984432c0261e5a0e3448bc44c7cad85": {
    "original": "<!-- request C# -->\n\nCODE_BLOCK_220\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_221\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_222\n\n<!-- end -->\n\n<!-- example for any/all MVA -->\n\nIt supports filtering and aggregation, but not sorting. Filtering can be done using a condition that requires at least one element to pass (using [ANY()](../Functions/Arrays_and_conditions_functions.md#ANY%28%29)) or all elements ([ALL()](../Functions/Arrays_and_conditions_functions.md#ALL%28%29)) to pass.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_223\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_224\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_225\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_226\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_227\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_228\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_229\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_230\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_231\n\n<!-- end -->\n\n<!-- example for least/greatest MVA -->\n\nInformation like [least](../Functions/Mathematical_functions.md#LEAST%28%29) or [greatest](../Functions/Mathematical_functions.md#GREATEST%28%29) element and length of the list can be extracted. An example shows ordering by the least element of a multi-value attribute.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_232\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_233\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_234\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_235\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_236\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_237\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_238\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_239\n\n<!-- request Rust -->\n\nCODE_BLOCK_240\n\n<!-- end -->\n\n<!-- example for grouping by MVA -->\n\nWhen grouping by a multi-value attribute, a document will contribute to as many groups as there are different values associated with that document. For instance, if a collection contains exactly one document having a 'product_codes' multi-value attribute with values 5, 7, and 11, grouping on 'product_codes' will produce 3 groups with `COUNT(*)`equal to 1 and `GROUPBY()` key values of 5, 7, and 11, respectively. Also, note that grouping by multi-value attributes may lead to duplicate documents in the result set because each document can participate in many groups.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_241\n\n<!-- response mysql -->\n\nCODE_BLOCK_242\n\n<!-- end -->\n\n<!-- example for MVA value order -->\n\nThe order of the numbers inserted as values of multivalued attributes is not preserved. Values are stored internally as a sorted set.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_243\n\n<!-- response mysql -->\n\nCODE_BLOCK_244\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_245\n\n<!-- response JSON -->\n\nCODE_BLOCK_246\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_247\n\n<!-- response PHP -->\n\nCODE_BLOCK_248\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_249\n\n<!-- response Python -->\n\nCODE_BLOCK_250\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_251\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_252\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_253\n\n<!-- response javascript -->\n\nCODE_BLOCK_254\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_255\n\n<!-- response java -->\n\nCODE_BLOCK_256\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_257\n\n<!-- response C# -->\n\nCODE_BLOCK_258\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_259\n\n<!-- response Rust -->\n\nCODE_BLOCK_260\n\n<!-- end -->\n\n## Multi-value big integer\n\n<!-- example for creating MVA64 -->\n\nA data type that allows storing variable-length lists of 64-bit signed integers. It has the same functionality as multi-value integer.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_261\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_262\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_263\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_264\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_265\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_266\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_267\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_268\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_269\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_270\n\n<!-- end -->\n\n## Columnar attribute properties\n\nWhen you use the columnar storage you can specify the following properties for the attributes.\n\n<!-- example fast_fetch -->\n\n### fast_fetch\n\nBy default, Manticore Columnar storage stores all attributes in a columnar fashion, as well as in a special docstore row by row. This enables fast execution of queries like `SELECT * FROM ...`, especially when fetching a large number of records at once. However, if you are sure that you do not need it or wish to save disk space, you can disable it by specifying `fast_fetch='0'` when creating a table or (if you are defining a table in a config) by using `columnar_no_fast_fetch` as shown in the following example.\n\n<!-- request RT mode -->\n\nCODE_BLOCK_271\n\n<!-- response RT mode -->\n\nCODE_BLOCK_272\n\n<!-- request Plain mode -->\n\nCODE_BLOCK_273\n\n<!-- response Plain mode -->\n\nCODE_BLOCK_274\n\n<!-- end -->",
    "translations": {
      "chinese": "<!-- request C# -->\n\nCODE_BLOCK_220\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_221\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_222\n\n<!-- end -->\n\n<!-- example for any/all MVA -->\n\nIt supports filtering and aggregation, but not sorting. Filtering can be done using a condition that requires at least one element to pass (using [ANY()](../Functions/Arrays_and_conditions_functions.md#ANY%28%29)) or all elements ([ALL()](../Functions/Arrays_and_conditions_functions.md#ALL%28%29)) to pass.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_223\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_224\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_225\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_226\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_227\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_228\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_229\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_230\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_231\n\n<!-- end -->\n\n<!-- example for least/greatest MVA -->\n\nInformation like [least](../Functions/Mathematical_functions.md#LEAST%28%29) or [greatest](../Functions/Mathematical_functions.md#GREATEST%28%29) element and length of the list can be extracted. An example shows ordering by the least element of a multi-value attribute.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_232\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_233\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_234\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_235\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_236\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_237\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_238\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_239\n\n<!-- request Rust -->\n\nCODE_BLOCK_240\n\n<!-- end -->\n\n<!-- example for grouping by MVA -->\n\nWhen grouping by a multi-value attribute, a document will contribute to as many groups as there are different values associated with that document. For instance, if a collection contains exactly one document having a 'product_codes' multi-value attribute with values 5, 7, and 11, grouping on 'product_codes' will produce 3 groups with `COUNT(*)`equal to 1 and `GROUPBY()` key values of 5, 7, and 11, respectively. Also, note that grouping by multi-value attributes may lead to duplicate documents in the result set because each document can participate in many groups.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_241\n\n<!-- response mysql -->\n\nCODE_BLOCK_242\n\n<!-- end -->\n\n<!-- example for MVA value order -->\n\nThe order of the numbers inserted as values of multivalued attributes is not preserved. Values are stored internally as a sorted set.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_243\n\n<!-- response mysql -->\n\nCODE_BLOCK_244\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_245\n\n<!-- response JSON -->\n\nCODE_BLOCK_246\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_247\n\n<!-- response PHP -->\n\nCODE_BLOCK_248\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_249\n\n<!-- response Python -->\n\nCODE_BLOCK_250\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_251\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_252\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_253\n\n<!-- response javascript -->\n\nCODE_BLOCK_254\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_255\n\n<!-- response java -->\n\nCODE_BLOCK_256\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_257\n\n<!-- response C# -->\n\nCODE_BLOCK_258\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_259\n\n<!-- response Rust -->\n\nCODE_BLOCK_260\n\n<!-- end -->\n\n## Multi-value big integer\n\n<!-- example for creating MVA64 -->\n\nA data type that allows storing variable-length lists of 64-bit signed integers. It has the same functionality as multi-value integer.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_261\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_262\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_263\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_264\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_265\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_266\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_267\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_268\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_269\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_270\n\n<!-- end -->\n\n## Columnar attribute properties\n\nWhen you use the columnar storage you can specify the following properties for the attributes.\n\n<!-- example fast_fetch -->\n\n### fast_fetch\n\nBy default, Manticore Columnar storage stores all attributes in a columnar fashion, as well as in a special docstore row by row. This enables fast execution of queries like `SELECT * FROM ...`, especially when fetching a large number of records at once. However, if you are sure that you do not need it or wish to save disk space, you can disable it by specifying `fast_fetch='0'` when creating a table or (if you are defining a table in a config) by using `columnar_no_fast_fetch` as shown in the following example.\n\n<!-- request RT mode -->\n\nCODE_BLOCK_271\n\n<!-- response RT mode -->\n\nCODE_BLOCK_272\n\n<!-- request Plain mode -->\n\nCODE_BLOCK_273\n\n<!-- response Plain mode -->\n\nCODE_BLOCK_274\n\n<!-- end -->",
      "russian": "<!-- request C# -->\n\nCODE_BLOCK_220\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_221\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_222\n\n<!-- end -->\n\n<!-- example for any/all MVA -->\n\nIt supports filtering and aggregation, but not sorting. Filtering can be done using a condition that requires at least one element to pass (using [ANY()](../Functions/Arrays_and_conditions_functions.md#ANY%28%29)) or all elements ([ALL()](../Functions/Arrays_and_conditions_functions.md#ALL%28%29)) to pass.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_223\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_224\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_225\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_226\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_227\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_228\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_229\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_230\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_231\n\n<!-- end -->\n\n<!-- example for least/greatest MVA -->\n\nInformation like [least](../Functions/Mathematical_functions.md#LEAST%28%29) or [greatest](../Functions/Mathematical_functions.md#GREATEST%28%29) element and length of the list can be extracted. An example shows ordering by the least element of a multi-value attribute.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_232\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_233\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_234\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_235\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_236\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_237\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_238\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_239\n\n<!-- request Rust -->\n\nCODE_BLOCK_240\n\n<!-- end -->\n\n<!-- example for grouping by MVA -->\n\nWhen grouping by a multi-value attribute, a document will contribute to as many groups as there are different values associated with that document. For instance, if a collection contains exactly one document having a 'product_codes' multi-value attribute with values 5, 7, and 11, grouping on 'product_codes' will produce 3 groups with `COUNT(*)`equal to 1 and `GROUPBY()` key values of 5, 7, and 11, respectively. Also, note that grouping by multi-value attributes may lead to duplicate documents in the result set because each document can participate in many groups.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_241\n\n<!-- response mysql -->\n\nCODE_BLOCK_242\n\n<!-- end -->\n\n<!-- example for MVA value order -->\n\nThe order of the numbers inserted as values of multivalued attributes is not preserved. Values are stored internally as a sorted set.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_243\n\n<!-- response mysql -->\n\nCODE_BLOCK_244\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_245\n\n<!-- response JSON -->\n\nCODE_BLOCK_246\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_247\n\n<!-- response PHP -->\n\nCODE_BLOCK_248\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_249\n\n<!-- response Python -->\n\nCODE_BLOCK_250\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_251\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_252\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_253\n\n<!-- response javascript -->\n\nCODE_BLOCK_254\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_255\n\n<!-- response java -->\n\nCODE_BLOCK_256\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_257\n\n<!-- response C# -->\n\nCODE_BLOCK_258\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_259\n\n<!-- response Rust -->\n\nCODE_BLOCK_260\n\n<!-- end -->\n\n## Multi-value big integer\n\n<!-- example for creating MVA64 -->\n\nA data type that allows storing variable-length lists of 64-bit signed integers. It has the same functionality as multi-value integer.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_261\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_262\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_263\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_264\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_265\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_266\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_267\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_268\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_269\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_270\n\n<!-- end -->\n\n## Columnar attribute properties\n\nWhen you use the columnar storage you can specify the following properties for the attributes.\n\n<!-- example fast_fetch -->\n\n### fast_fetch\n\nBy default, Manticore Columnar storage stores all attributes in a columnar fashion, as well as in a special docstore row by row. This enables fast execution of queries like `SELECT * FROM ...`, especially when fetching a large number of records at once. However, if you are sure that you do not need it or wish to save disk space, you can disable it by specifying `fast_fetch='0'` when creating a table or (if you are defining a table in a config) by using `columnar_no_fast_fetch` as shown in the following example.\n\n<!-- request RT mode -->\n\nCODE_BLOCK_271\n\n<!-- response RT mode -->\n\nCODE_BLOCK_272\n\n<!-- request Plain mode -->\n\nCODE_BLOCK_273\n\n<!-- response Plain mode -->\n\nCODE_BLOCK_274\n\n<!-- end -->"
    },
    "is_code_or_comment": true
  },
  "ebf2d048c990241251976e91a5b664f422b2a4814be5b46bb618320e271a4f4a": {
    "original": "Integers can be stored in shorter sizes than 32-bit by specifying a bit count. For example, if we want to store a numeric value which we know is not going to be bigger than 8, the type can be defined as `bit(3)`. Bitcount integers perform slower than the full-size ones, but they require less RAM. They are saved in 32-bit chunks, so in order to save space, they should be grouped at the end of attribute definitions (otherwise a bitcount integer between 2 full-size integers will occupy 32 bits as well).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_93\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_94\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_95\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_96\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_97\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_98\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_99\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_100\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_101\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_102\n\n<!-- end -->\n\n## Big Integer\n\n<!-- example for bigints  -->\n\nBig integers (bigint) are 64-bit wide **signed** integers.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_103\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_104\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_105\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_106\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_107\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_108\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_109\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_110\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_111\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_112\n\n<!-- end -->\n\n## Boolean\n\n<!-- example for boolean  -->\n\nDeclares a boolean attribute. It's equivalent to an integer attribute with bit count of 1.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_113\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_114\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_115\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_116\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_117\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_118\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_119\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_120\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_121\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_122\n\n<!-- end -->\n\n## Timestamps\n\n<!-- example for timestamps  -->\n\nThe timestamp type represents Unix timestamps, which are stored as 32-bit integers. Unlike basic integers, the timestamp type allows the use of [time and date](../Functions/Date_and_time_functions.md) functions. Conversion from string values follows these rules:\n\n- Numbers without delimiters, at least 10 characters long, are converted to timestamps as is.\n\n- `%Y-%m-%dT%H:%M:%E*S%Z`\n\n- `%Y-%m-%d'T'%H:%M:%S%Z`\n\n- `%Y-%m-%dT%H:%M:%E*S`\n\n- `%Y-%m-%dT%H:%M:%s`\n\n- `%Y-%m-%dT%H:%M`\n\n- `%Y-%m-%dT%H`\n\n- `%Y-%m-%d`\n\n- `%Y-%m`\n\n- `%Y`\n\nThe meanings of these conversion specifiers are detailed in the [strptime manual](https://man7.org/linux/man-pages/man3/strptime.3.html), except for `%E*S`, which stands for milliseconds.\n\nNote that auto-conversion of timestamps is not supported in plain tables.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_123\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_124\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_125\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_126\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_127\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_128\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_129\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_130\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_131\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_132\n\n<!-- end -->\n\n## Float\n\n<!-- example for float -->\n\nReal numbers are stored as 32-bit IEEE 754 single precision floats.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_133\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_134\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_135\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_136\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_137\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_138\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_139\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_140\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_141\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_142\n\n<!-- end -->\n\n<!-- example for eps comparison -->\n\nUnlike integer types, comparing two floating-point numbers for equality is not recommended due to potential rounding errors. A more reliable approach is to use a near-equal comparison, by checking the absolute error margin.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_143\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_144\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_145\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_146\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_147\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_148\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_149\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->",
    "translations": {
      "chinese": "整数可以通过指定位数来存储为小于32位的大小。例如，如果我们想存储一个我们知道不会大于8的数值，则类型可以定义为 `bit(3)`。位数整数的性能比全尺寸整数慢，但它们需要更少的内存。它们以32位块保存，因此为了节省空间，应该将它们放在属性定义的末尾（否则位数整数夹在两个全尺寸整数之间时，也会占用32位）。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_93\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_94\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_95\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_96\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_97\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_98\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_99\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_100\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_101\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_102\n\n<!-- end -->\n\n## 大整数\n\n<!-- example for bigints  -->\n\n大整数（bigint）是64位宽的**有符号**整数。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_103\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_104\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_105\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_106\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_107\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_108\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_109\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_110\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_111\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_112\n\n<!-- end -->\n\n## 布尔值\n\n<!-- example for boolean  -->\n\n声明一个布尔属性。它等同于位数为1的整数属性。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_113\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_114\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_115\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_116\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_117\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_118\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_119\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_120\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_121\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_122\n\n<!-- end -->\n\n## 时间戳\n\n<!-- example for timestamps  -->\n\n时间戳类型表示Unix时间戳，存储为32位整数。与基本整数不同，时间戳类型允许使用[时间和日期](../Functions/Date_and_time_functions.md)函数。字符串值的转换遵循以下规则：\n\n- 没有分隔符且长度至少为10个字符的数字，按原样转换为时间戳。\n\n- `%Y-%m-%dT%H:%M:%E*S%Z`\n\n- `%Y-%m-%d'T'%H:%M:%S%Z`\n\n- `%Y-%m-%dT%H:%M:%E*S`\n\n- `%Y-%m-%dT%H:%M:%s`\n\n- `%Y-%m-%dT%H:%M`\n\n- `%Y-%m-%dT%H`\n\n- `%Y-%m-%d`\n\n- `%Y-%m`\n\n- `%Y`\n\n这些转换说明符的含义详见[strptime手册](https://man7.org/linux/man-pages/man3/strptime.3.html)，其中 `%E*S` 表示毫秒。\n\n注意，普通表中不支持时间戳的自动转换。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_123\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_124\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_125\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_126\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_127\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_128\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_129\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_130\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_131\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_132\n\n<!-- end -->\n\n## 浮点数\n\n<!-- example for float -->\n\n实数存储为32位IEEE 754单精度浮点数。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_133\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_134\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_135\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_136\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_137\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_138\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_139\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_140\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_141\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_142\n\n<!-- end -->\n\n<!-- example for eps comparison -->\n\n与整数类型不同，由于可能存在舍入误差，不建议直接比较两个浮点数是否相等。更可靠的方法是使用近似相等比较，通过检查绝对误差范围。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_143\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_144\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_145\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_146\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_147\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_148\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_149\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->",
      "russian": "Целые числа могут храниться в меньших размерах, чем 32-битные, путем указания количества бит. Например, если мы хотим сохранить числовое значение, которое, как мы знаем, не будет больше 8, тип можно определить как `bit(3)`. Целые числа с битовой длиной работают медленнее, чем полноразмерные, но требуют меньше оперативной памяти. Они сохраняются в 32-битных блоках, поэтому для экономии места их следует группировать в конце определения атрибутов (иначе целое число с битовой длиной между двумя полноразмерными целыми также займет 32 бита).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_93\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_94\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_95\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_96\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_97\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_98\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_99\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_100\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_101\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_102\n\n<!-- end -->\n\n## Большое целое число\n\n<!-- example for bigints  -->\n\nБольшие целые числа (bigint) — это 64-битные **знаковые** целые числа.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_103\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_104\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_105\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_106\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_107\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_108\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_109\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_110\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_111\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_112\n\n<!-- end -->\n\n## Булевый тип\n\n<!-- example for boolean  -->\n\nОбъявляет булевый атрибут. Это эквивалентно целочисленному атрибуту с битовой длиной 1.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_113\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_114\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_115\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_116\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_117\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_118\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_119\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_120\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_121\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_122\n\n<!-- end -->\n\n## Метки времени\n\n<!-- example for timestamps  -->\n\nТип timestamp представляет собой Unix-метки времени, которые хранятся как 32-битные целые числа. В отличие от базовых целых чисел, тип timestamp позволяет использовать функции [времени и даты](../Functions/Date_and_time_functions.md). Преобразование из строковых значений происходит по следующим правилам:\n\n- Числа без разделителей, длиной не менее 10 символов, преобразуются в метки времени как есть.\n\n- `%Y-%m-%dT%H:%M:%E*S%Z`\n\n- `%Y-%m-%d'T'%H:%M:%S%Z`\n\n- `%Y-%m-%dT%H:%M:%E*S`\n\n- `%Y-%m-%dT%H:%M:%s`\n\n- `%Y-%m-%dT%H:%M`\n\n- `%Y-%m-%dT%H`\n\n- `%Y-%m-%d`\n\n- `%Y-%m`\n\n- `%Y`\n\nЗначения этих спецификаторов преобразования подробно описаны в [руководстве strptime](https://man7.org/linux/man-pages/man3/strptime.3.html), за исключением `%E*S`, который обозначает миллисекунды.\n\nОбратите внимание, что автоматическое преобразование меток времени не поддерживается в простых таблицах.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_123\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_124\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_125\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_126\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_127\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_128\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_129\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_130\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_131\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_132\n\n<!-- end -->\n\n## Число с плавающей точкой\n\n<!-- example for float -->\n\nВещественные числа хранятся как 32-битные числа с плавающей точкой одинарной точности по стандарту IEEE 754.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_133\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_134\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_135\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_136\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_137\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_138\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_139\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_140\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_141\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_142\n\n<!-- end -->\n\n<!-- example for eps comparison -->\n\nВ отличие от целочисленных типов, сравнивать два числа с плавающей точкой на равенство не рекомендуется из-за возможных ошибок округления. Более надежный подход — использовать сравнение с допуском, проверяя абсолютную погрешность.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_143\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_144\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_145\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_146\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_147\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_148\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_149\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->"
    },
    "is_code_or_comment": false
  },
  "32178099ef9da77bac37d9a5a593f162575af08a28c41650d348d421c4a44862": {
    "original": "Float vector attributes allow storing variable-length lists of floats, primarily used for machine learning applications and similarity searches. This type differs from [multi-valued attributes](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29) (MVAs) in several important ways:\n\n- Preserves the exact order of values (unlike MVAs which may reorder)\n\n- Retains duplicate values (unlike MVAs which deduplicate)\n\n- No additional processing during insertion (unlike MVAs which sort and deduplicate)\n\nFloat vector attributes allow storing variable-length lists of floats, primarily used for machine learning applications and similarity searches. \n\n### Usage and Limitations\n\n- Currently only supported in real-time tables\n\n- Can only be utilized in KNN (k-nearest neighbor) searches\n\n- Not supported in plain tables or other functions/expressions\n\n- When used with KNN settings, you cannot `UPDATE` `float_vector` values. Use `REPLACE` instead\n\n- When used without KNN settings, you can `UPDATE` `float_vector` values\n\n- Float vectors cannot be used in regular filters or sorting\n\n- The only way to filter by `float_vector` values is through vector search operations (KNN)\n\n### Common Use Cases\n\n- Text embeddings for semantic search\n\n- Recommendation system vectors\n\n- Image embeddings for similarity search\n\n- Feature vectors for machine learning\n\n** Keep in mind that the `float_vector` data type is not compatible with the [Auto schema](../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md#Auto-schema) mechanism. **\n\nFor more details on setting up float vectors and using them in searches, see [KNN search](../Searching/KNN.md).\n\n### Auto Embeddings (Recommended)\n\nThe most convenient way to work with float vectors is using **auto embeddings**. This feature automatically generates embeddings from your text data using machine learning models, eliminating the need to manually compute and insert vectors.\n\n#### Benefits of Auto Embeddings\n\n- **Simplified workflow**: Just insert text, embeddings are generated automatically\n\n- **No manual vector computation**: No need to run separate embedding models\n\n- **Consistent embeddings**: Same model ensures consistent vector representations\n\n- **Multiple model support**: Choose from [sentence-transformers](https://huggingface.co/sentence-transformers/models), OpenAI, Voyage, and Jina models\n\n- **Flexible field selection**: Control which fields are used for embedding generation\n\n#### Creating tables with auto embeddings\n\nWhen creating a table with auto embeddings, specify these additional parameters:\n\n- `MODEL_NAME`: The embedding model to use for automatic vector generation\n\n- `FROM`: Which fields to use for embedding generation (empty string means all text/string fields)\n\n**Supported embedding models:**\n\n- **Sentence Transformers**: Any [suitable BERT-based Hugging Face model](https://huggingface.co/sentence-transformers/models) (e.g., `sentence-transformers/all-MiniLM-L6-v2`) — no API key needed. Manticore downloads the model when you create the table.\n\n- **OpenAI**: OpenAI embedding models like `openai/text-embedding-ada-002` - requires `API_KEY='<OPENAI_API_KEY>'` parameter\n\n- **Voyage**: Voyage AI embedding models - requires `API_KEY='<VOYAGE_API_KEY>'` parameter\n\n- **Jina**: Jina AI embedding models - requires `API_KEY='<JINA_API_KEY>'` parameter\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nUsing [sentence-transformers model](https://huggingface.co/sentence-transformers/models) (no API key needed)\n\nCODE_BLOCK_199\n\nUsing OpenAI model (requires API_KEY parameter)\n\nCODE_BLOCK_200\n\nUsing all text fields for embeddings (FROM is empty)\n\nCODE_BLOCK_201\n\n<!-- end -->\n\n#### FROM parameter usage\n\nThe `FROM` parameter controls which fields are used for embedding generation:\n\n- **Specific fields**: `FROM='title'` - only the title field is used\n\n- **Multiple fields**: `FROM='title,description'` - both title and description are concatenated and used\n\n- **All text fields**: `FROM=''` (empty) - all `text` (full-text field) and `string` (string attribute) fields in the table are used\n\n- **Empty vectors**: You can still insert empty vectors using `()` to exclude documents from vector search\n\n#### Inserting data with auto embeddings\n\nWhen using auto embeddings, **do not specify the vector field** in your INSERT statements. The embeddings are automatically generated from the specified text fields:\n\nCODE_BLOCK_202\n\n### Manual Float Vector Usage\n\n<!-- example for creating float_vector -->\n\nAlternatively, you can work with manually computed float vectors. \n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_203\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_204\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_205\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_206\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_207\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_208\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_209\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_210\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_211\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_212\n\n<!-- end -->\n\n## Multi-value integer (MVA)\n\n<!-- example for creating MVA32 -->\n\nMulti-value attributes allow storing variable-length lists of 32-bit unsigned integers. This can be useful for storing one-to-many numeric values, such as tags, product categories, and properties.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_213\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_214\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_215\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_216\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_217\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_218\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_219\n\n<!-- intro -->\n\n##### C#:",
    "translations": {
      "chinese": "Float vector attributes allow storing variable-length lists of floats, primarily used for machine learning applications and similarity searches. This type differs from [multi-valued attributes](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29) (MVAs) in several important ways:\n\n- Preserves the exact order of values (unlike MVAs which may reorder)\n\n- Retains duplicate values (unlike MVAs which deduplicate)\n\n- No additional processing during insertion (unlike MVAs which sort and deduplicate)\n\nFloat vector attributes allow storing variable-length lists of floats, primarily used for machine learning applications and similarity searches. \n\n### Usage and Limitations\n\n- Currently only supported in real-time tables\n\n- Can only be utilized in KNN (k-nearest neighbor) searches\n\n- Not supported in plain tables or other functions/expressions\n\n- When used with KNN settings, you cannot `UPDATE` `float_vector` values. Use `REPLACE` instead\n\n- When used without KNN settings, you can `UPDATE` `float_vector` values\n\n- Float vectors cannot be used in regular filters or sorting\n\n- The only way to filter by `float_vector` values is through vector search operations (KNN)\n\n### Common Use Cases\n\n- Text embeddings for semantic search\n\n- Recommendation system vectors\n\n- Image embeddings for similarity search\n\n- Feature vectors for machine learning\n\n** Keep in mind that the `float_vector` data type is not compatible with the [Auto schema](../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md#Auto-schema) mechanism. **\n\nFor more details on setting up float vectors and using them in searches, see [KNN search](../Searching/KNN.md).\n\n### Auto Embeddings (Recommended)\n\nThe most convenient way to work with float vectors is using **auto embeddings**. This feature automatically generates embeddings from your text data using machine learning models, eliminating the need to manually compute and insert vectors.\n\n#### Benefits of Auto Embeddings\n\n- **Simplified workflow**: Just insert text, embeddings are generated automatically\n\n- **No manual vector computation**: No need to run separate embedding models\n\n- **Consistent embeddings**: Same model ensures consistent vector representations\n\n- **Multiple model support**: Choose from [sentence-transformers](https://huggingface.co/sentence-transformers/models), OpenAI, Voyage, and Jina models\n\n- **Flexible field selection**: Control which fields are used for embedding generation\n\n#### Creating tables with auto embeddings\n\nWhen creating a table with auto embeddings, specify these additional parameters:\n\n- `MODEL_NAME`: The embedding model to use for automatic vector generation\n\n- `FROM`: Which fields to use for embedding generation (empty string means all text/string fields)\n\n**Supported embedding models:**\n\n- **Sentence Transformers**: Any [suitable BERT-based Hugging Face model](https://huggingface.co/sentence-transformers/models) (e.g., `sentence-transformers/all-MiniLM-L6-v2`) — no API key needed. Manticore downloads the model when you create the table.\n\n- **OpenAI**: OpenAI embedding models like `openai/text-embedding-ada-002` - requires `API_KEY='<OPENAI_API_KEY>'` parameter\n\n- **Voyage**: Voyage AI embedding models - requires `API_KEY='<VOYAGE_API_KEY>'` parameter\n\n- **Jina**: Jina AI embedding models - requires `API_KEY='<JINA_API_KEY>'` parameter\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nUsing [sentence-transformers model](https://huggingface.co/sentence-transformers/models) (no API key needed)\n\nCODE_BLOCK_199\n\nUsing OpenAI model (requires API_KEY parameter)\n\nCODE_BLOCK_200\n\nUsing all text fields for embeddings (FROM is empty)\n\nCODE_BLOCK_201\n\n<!-- end -->\n\n#### FROM parameter usage\n\nThe `FROM` parameter controls which fields are used for embedding generation:\n\n- **Specific fields**: `FROM='title'` - only the title field is used\n\n- **Multiple fields**: `FROM='title,description'` - both title and description are concatenated and used\n\n- **All text fields**: `FROM=''` (empty) - all `text` (full-text field) and `string` (string attribute) fields in the table are used\n\n- **Empty vectors**: You can still insert empty vectors using `()` to exclude documents from vector search\n\n#### Inserting data with auto embeddings\n\nWhen using auto embeddings, **do not specify the vector field** in your INSERT statements. The embeddings are automatically generated from the specified text fields:\n\nCODE_BLOCK_202\n\n### Manual Float Vector Usage\n\n<!-- example for creating float_vector -->\n\nAlternatively, you can work with manually computed float vectors. \n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_203\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_204\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_205\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_206\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_207\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_208\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_209\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_210\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_211\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_212\n\n<!-- end -->\n\n## Multi-value integer (MVA)\n\n<!-- example for creating MVA32 -->\n\nMulti-value attributes allow storing variable-length lists of 32-bit unsigned integers. This can be useful for storing one-to-many numeric values, such as tags, product categories, and properties.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_213\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_214\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_215\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_216\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_217\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_218\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_219\n\n<!-- intro -->\n\n##### C#:",
      "russian": "Атрибуты векторных чисел с плавающей запятой позволяют хранить списки переменной длины из чисел с плавающей запятой, преимущественно используемые для приложений машинного обучения и поиска по сходству. Этот тип отличается от [мультизначных атрибутов](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29) (MVA) по нескольким важным аспектам:\n\n- Сохраняет точный порядок значений (в отличие от MVA, которые могут менять порядок)\n\n- Сохраняет дублирующиеся значения (в отличие от MVA, которые удаляют дубликаты)\n\n- Нет дополнительной обработки при вставке (в отличие от MVA, которые сортируют и удаляют дубликаты)\n\nАтрибуты векторных чисел с плавающей запятой позволяют хранить списки переменной длины из чисел с плавающей запятой, преимущественно используемые для приложений машинного обучения и поиска по сходству.\n\n### Использование и ограничения\n\n- В настоящее время поддерживаются только в таблицах реального времени\n\n- Могут использоваться только в поисках KNN (k-ближайших соседей)\n\n- Не поддерживаются в обычных таблицах или других функциях/выражениях\n\n- При использовании с настройками KNN нельзя `UPDATE` значения `float_vector`. Используйте `REPLACE`\n\n- При использовании без настроек KNN можно `UPDATE` значения `float_vector`\n\n- Векторы с плавающей запятой нельзя использовать в обычных фильтрах или сортировке\n\n- Единственный способ фильтровать по значениям `float_vector` — через операции векторного поиска (KNN)\n\n### Распространённые случаи использования\n\n- Текстовые эмбеддинги для семантического поиска\n\n- Векторы рекомендательных систем\n\n- Эмбеддинги изображений для поиска по сходству\n\n- Векторы признаков для машинного обучения\n\n** Имейте в виду, что тип данных `float_vector` несовместим с механизмом [Auto schema](../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md#Auto-schema). **\n\nДля получения подробной информации о настройке векторов с плавающей запятой и их использовании в поисках смотрите [KNN search](../Searching/KNN.md).\n\n### Автоматические эмбеддинги (рекомендуется)\n\nСамый удобный способ работы с векторами с плавающей запятой — использование **автоматических эмбеддингов**. Эта функция автоматически генерирует эмбеддинги из ваших текстовых данных с помощью моделей машинного обучения, устраняя необходимость вручную вычислять и вставлять векторы.\n\n#### Преимущества автоматических эмбеддингов\n\n- **Упрощённый рабочий процесс**: Просто вставляйте текст, эмбеддинги генерируются автоматически\n\n- **Нет необходимости вручную вычислять векторы**: Не нужно запускать отдельные модели эмбеддингов\n\n- **Последовательные эмбеддинги**: Одна и та же модель обеспечивает согласованное представление векторов\n\n- **Поддержка нескольких моделей**: Выбор из моделей [sentence-transformers](https://huggingface.co/sentence-transformers/models), OpenAI, Voyage и Jina\n\n- **Гибкий выбор полей**: Контроль над тем, какие поля используются для генерации эмбеддингов\n\n#### Создание таблиц с автоматическими эмбеддингами\n\nПри создании таблицы с автоматическими эмбеддингами укажите следующие дополнительные параметры:\n\n- `MODEL_NAME`: модель эмбеддингов для автоматической генерации векторов\n\n- `FROM`: какие поля использовать для генерации эмбеддингов (пустая строка означает все текстовые/строковые поля)\n\n**Поддерживаемые модели эмбеддингов:**\n\n- **Sentence Transformers**: Любая [подходящая модель BERT на Hugging Face](https://huggingface.co/sentence-transformers/models) (например, `sentence-transformers/all-MiniLM-L6-v2`) — API ключ не требуется. Manticore загружает модель при создании таблицы.\n\n- **OpenAI**: Модели эмбеддингов OpenAI, например `openai/text-embedding-ada-002` — требует параметр `API_KEY='<OPENAI_API_KEY>'`\n\n- **Voyage**: Модели эмбеддингов Voyage AI — требует параметр `API_KEY='<VOYAGE_API_KEY>'`\n\n- **Jina**: Модели эмбеддингов Jina AI — требует параметр `API_KEY='<JINA_API_KEY>'`\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nИспользование модели [sentence-transformers](https://huggingface.co/sentence-transformers/models) (API ключ не требуется)\n\nCODE_BLOCK_199\n\nИспользование модели OpenAI (требуется параметр API_KEY)\n\nCODE_BLOCK_200\n\nИспользование всех текстовых полей для эмбеддингов (FROM пустой)\n\nCODE_BLOCK_201\n\n<!-- end -->\n\n#### Использование параметра FROM\n\nПараметр `FROM` контролирует, какие поля используются для генерации эмбеддингов:\n\n- **Конкретные поля**: `FROM='title'` — используется только поле title\n\n- **Несколько полей**: `FROM='title,description'` — объединяются и используются поля title и description\n\n- **Все текстовые поля**: `FROM=''` (пусто) — используются все поля типа `text` (полнотекстовые поля) и `string` (строковые атрибуты) в таблице\n\n- **Пустые векторы**: Можно вставлять пустые векторы с помощью `()`, чтобы исключить документы из векторного поиска\n\n#### Вставка данных с автоматическими эмбеддингами\n\nПри использовании автоматических эмбеддингов **не указывайте поле вектора** в ваших операторах INSERT. Эмбеддинги автоматически генерируются из указанных текстовых полей:\n\nCODE_BLOCK_202\n\n### Ручное использование векторов с плавающей запятой\n\n<!-- example for creating float_vector -->\n\nВ качестве альтернативы можно работать с вручную вычисленными векторами с плавающей запятой.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_203\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_204\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_205\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_206\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_207\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_208\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_209\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_210\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_211\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_212\n\n<!-- end -->\n\n## Мультизначное целое число (MVA)\n\n<!-- example for creating MVA32 -->\n\nМультизначные атрибуты позволяют хранить списки переменной длины из 32-битных беззнаковых целых чисел. Это может быть полезно для хранения числовых значений один-ко-многим, таких как теги, категории продуктов и свойства.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_213\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_214\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_215\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_216\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_217\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_218\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_219\n\n<!-- intro -->\n\n##### C#:"
    },
    "is_code_or_comment": false
  },
  "727a6887f94e3730f874d92d1d83f54cee7bd08819aea9136d5193416c655761": {
    "original": "CODE_BLOCK_150\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_151\n\n<!-- end -->\n\n<!-- example for float mul -->\n\nAnother alternative, which can also be used to perform `IN(attr,val1,val2,val3)` is to compare floats as integers by choosing a multiplier factor and convert the floats to integers in operations. The following example illustrates modifying `IN(attr,2.0,2.5,3.5)` to work with integer values.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_152\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_153\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_154\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_155\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_156\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_157\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_158\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_159\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_160\n\n<!-- end -->\n\n<!-- example float_accuracy -->\n\nFloat values in Manticore are displayed with precision to ensure they reflect the exact stored value. This approach was introduced to prevent precision loss, especially for cases like geographical coordinates, where rounding to 6 decimal places caused inaccuracies.\n\nNow, Manticore first outputs a number with 6 digits, then parses and compares it to the original value. If they don't match, additional digits are added until they do.\n\nFor example, if a float value was inserted as `19.45`, Manticore will display it as `19.450001` to accurately represent the stored value.\n\n<!-- request Example -->\n\nCODE_BLOCK_161\n\n<!-- end -->\n\n## JSON\n\n<!-- example for creating json -->\n\nThis data type allows for the storage of JSON objects, which is particularly useful for handling schema-less data. When defining JSON values, ensure that the opening and closing curly braces `{` and `}` are included for objects, or square brackets `[` and `]` for arrays. While JSON is not supported by columnar storage, it can be stored in traditional row-wise storage. It's worth noting that both storage types can be combined within the same table.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_162\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_163\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_164\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_165\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_166\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_167\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_168\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_169\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_170\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_171\n\n<!-- end -->\n\n<!-- example for INDEXOF() json -->\n\nJSON properties can be used in most operations. There are also special functions such as [ALL()](../Functions/Arrays_and_conditions_functions.md#ALL%28%29), [ANY()](../Functions/Arrays_and_conditions_functions.md#ANY%28%29), [GREATEST()](../Functions/Mathematical_functions.md#GREATEST%28%29), [LEAST()](../Functions/Mathematical_functions.md#LEAST%28%29) and [INDEXOF()](../Functions/Arrays_and_conditions_functions.md#INDEXOF%28%29) that allow traversal of property arrays.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_172\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_173\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_174\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_175\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_176\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_177\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_178\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_179\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_180\n\n<!-- end -->\n\n<!-- example for REGEX() json -->\n\nText properties are treated the same as strings, so it's not possible to use them in full-text match expressions. However, string functions such as [REGEX()](../Functions/String_functions.md#REGEX%28%29) can be used.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_181\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_182\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_183\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_184\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_185\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_186\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_187\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_188\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_189\n\n<!-- end -->\n\n<!-- example for DOUBLE() -->\n\nIn the case of JSON properties, enforcing data type may be required for proper functionality in certain situations. For example, when working with float values, [DOUBLE()](../Functions/Type_casting_functions.md#DOUBLE%28%29) must be used for proper sorting.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_190\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_191\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_192\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_193\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_194\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_195\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_196\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_197\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_198\n\n<!-- end -->\n\n## Float vector\n\n<!-- example float_vector_auto -->",
    "translations": {
      "chinese": "CODE_BLOCK_150\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_151\n\n<!-- end -->\n\n<!-- example for float mul -->\n\n另一种替代方法，也可以用来执行 `IN(attr,val1,val2,val3)`，是通过选择一个乘数因子，将浮点数转换为整数进行比较。下面的示例演示了如何修改 `IN(attr,2.0,2.5,3.5)` 以使用整数值。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_152\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_153\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_154\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_155\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_156\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_157\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_158\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_159\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_160\n\n<!-- end -->\n\n<!-- example float_accuracy -->\n\nManticore 中的浮点值以精确的精度显示，以确保它们反映存储的确切值。引入这种方法是为了防止精度丢失，特别是在地理坐标等情况下，四舍五入到小数点后6位会导致不准确。\n\n现在，Manticore 首先输出一个6位数字，然后解析并与原始值比较。如果不匹配，则会添加更多数字，直到匹配为止。\n\n例如，如果插入的浮点值是 `19.45`，Manticore 会显示为 `19.450001`，以准确表示存储的值。\n\n<!-- request Example -->\n\nCODE_BLOCK_161\n\n<!-- end -->\n\n## JSON\n\n<!-- example for creating json -->\n\n此数据类型允许存储 JSON 对象，这对于处理无模式数据特别有用。在定义 JSON 值时，确保包含对象的起始和结束大括号 `{` 和 `}`，或数组的方括号 `[` 和 `]`。虽然列式存储不支持 JSON，但它可以存储在传统的行存储中。值得注意的是，这两种存储类型可以在同一个表中结合使用。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_162\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_163\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_164\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_165\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_166\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_167\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_168\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_169\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_170\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_171\n\n<!-- end -->\n\n<!-- example for INDEXOF() json -->\n\nJSON 属性可以用于大多数操作。还有一些特殊函数，如 [ALL()](../Functions/Arrays_and_conditions_functions.md#ALL%28%29)、[ANY()](../Functions/Arrays_and_conditions_functions.md#ANY%28%29)、[GREATEST()](../Functions/Mathematical_functions.md#GREATEST%28%29)、[LEAST()](../Functions/Mathematical_functions.md#LEAST%28%29) 和 [INDEXOF()](../Functions/Arrays_and_conditions_functions.md#INDEXOF%28%29)，允许遍历属性数组。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_172\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_173\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_174\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_175\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_176\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_177\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_178\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_179\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_180\n\n<!-- end -->\n\n<!-- example for REGEX() json -->\n\n文本属性被视为字符串，因此不能在全文匹配表达式中使用它们。但是，可以使用字符串函数，如 [REGEX()](../Functions/String_functions.md#REGEX%28%29)。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_181\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_182\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_183\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_184\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_185\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_186\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_187\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_188\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_189\n\n<!-- end -->\n\n<!-- example for DOUBLE() -->\n\n对于 JSON 属性，在某些情况下可能需要强制数据类型以确保功能正常。例如，在处理浮点值时，必须使用 [DOUBLE()](../Functions/Type_casting_functions.md#DOUBLE%28%29) 以实现正确排序。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_190\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_191\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_192\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_193\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_194\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_195\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_196\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_197\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_198\n\n<!-- end -->\n\n## Float vector\n\n<!-- example float_vector_auto -->",
      "russian": "CODE_BLOCK_150\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_151\n\n<!-- end -->\n\n<!-- example for float mul -->\n\nЕще одна альтернатива, которая также может использоваться для выполнения `IN(attr,val1,val2,val3)` — сравнивать числа с плавающей точкой как целые, выбирая множитель и преобразуя числа с плавающей точкой в целые в операциях. Следующий пример иллюстрирует изменение `IN(attr,2.0,2.5,3.5)` для работы с целочисленными значениями.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_152\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_153\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_154\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_155\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_156\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_157\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_158\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_159\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_160\n\n<!-- end -->\n\n<!-- example float_accuracy -->\n\nЧисла с плавающей точкой в Manticore отображаются с точностью, чтобы отражать точное сохраненное значение. Этот подход был введен для предотвращения потери точности, особенно в случаях, таких как географические координаты, где округление до 6 знаков после запятой приводило к неточностям.\n\nТеперь Manticore сначала выводит число с 6 знаками, затем парсит и сравнивает его с исходным значением. Если они не совпадают, добавляются дополнительные знаки, пока не совпадут.\n\nНапример, если значение с плавающей точкой было вставлено как `19.45`, Manticore отобразит его как `19.450001`, чтобы точно представить сохраненное значение.\n\n<!-- request Example -->\n\nCODE_BLOCK_161\n\n<!-- end -->\n\n## JSON\n\n<!-- example for creating json -->\n\nЭтот тип данных позволяет хранить JSON-объекты, что особенно полезно для работы с данными без схемы. При определении JSON-значений убедитесь, что включены открывающие и закрывающие фигурные скобки `{` и `}` для объектов или квадратные скобки `[` и `]` для массивов. Хотя JSON не поддерживается колонковым хранением, он может храниться в традиционном построчном хранении. Стоит отметить, что оба типа хранения могут комбинироваться в одной таблице.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_162\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_163\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_164\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_165\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_166\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_167\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_168\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_169\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_170\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_171\n\n<!-- end -->\n\n<!-- example for INDEXOF() json -->\n\nСвойства JSON могут использоваться в большинстве операций. Также существуют специальные функции, такие как [ALL()](../Functions/Arrays_and_conditions_functions.md#ALL%28%29), [ANY()](../Functions/Arrays_and_conditions_functions.md#ANY%28%29), [GREATEST()](../Functions/Mathematical_functions.md#GREATEST%28%29), [LEAST()](../Functions/Mathematical_functions.md#LEAST%28%29) и [INDEXOF()](../Functions/Arrays_and_conditions_functions.md#INDEXOF%28%29), которые позволяют обходить массивы свойств.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_172\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_173\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_174\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_175\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_176\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_177\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_178\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_179\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_180\n\n<!-- end -->\n\n<!-- example for REGEX() json -->\n\nТекстовые свойства обрабатываются так же, как строки, поэтому их нельзя использовать в выражениях полнотекстового поиска. Однако можно использовать строковые функции, такие как [REGEX()](../Functions/String_functions.md#REGEX%28%29).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_181\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_182\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_183\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_184\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_185\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_186\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_187\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_188\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_189\n\n<!-- end -->\n\n<!-- example for DOUBLE() -->\n\nВ случае свойств JSON может потребоваться принудительное указание типа данных для правильной работы в некоторых ситуациях. Например, при работе с числами с плавающей точкой необходимо использовать [DOUBLE()](../Functions/Type_casting_functions.md#DOUBLE%28%29) для правильной сортировки.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_190\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_191\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_192\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_193\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_194\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_195\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_196\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_197\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_198\n\n<!-- end -->\n\n## Float vector\n\n<!-- example float_vector_auto -->"
    },
    "is_code_or_comment": false
  },
  "c3cec35d7d24740df51cf3bd5118c8d84a9020b5ed22e180090270793ad1ba43": {
    "original": "This behavior can be overridden by explicitly specifying that the text is only indexed.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_43\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_44\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_45\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_46\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_47\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_48\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_49\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_50\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_51\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_52\n\n<!-- end -->\n\n<!-- example for field naming  -->\n\nFields are named, and you can limit your searches to a single field (e.g. search through \"title\" only) or a subset of fields (e.g. \"title\" and \"abstract\" only). You can have up to 256 full-text fields.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_53\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_54\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_55\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_56\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_57\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_58\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_59\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_60\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_61\n\n<!-- end -->\n\n### String\n\n<!-- example for string attributes  -->\n\nUnlike full-text fields, string attributes (just `string` or `string/text attribute`) are stored as they are received and cannot be used in full-text searches. Instead, they are returned in results, can be used in the `WHERE` clause for comparison filtering or `REGEX`, and can be used for sorting and aggregation. In general, it's not recommended to store large texts in string attributes, but use string attributes for metadata like names, titles, tags, keys.\n\nIf you want to also index the string attribute, you can specify both as `string attribute indexed`. It will allow full-text searching and works as an attribute.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_62\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_63\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_64\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_65\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_66\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_67\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_68\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_69\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_70\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_71\n\n<!-- end -->\n\n<details>\n\n<summary>More</summary>\n\n<!-- example string field -->\n\nYou can create a full-text field that is also stored as a string attribute. This approach creates a full-text field and a string attribute that have the same name. Note that you can't add a `stored` property to store the data as a string attribute and in the document storage at the same time.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\n`string attribute indexed` means that we're working with a string data type that is stored as an attribute and indexed as a full-text field.\n\nCODE_BLOCK_72\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_73\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_74\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_75\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_76\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_77\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_78\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_79\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_80\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_81\n\n<!-- end -->\n\n</details>\n\n### Storing binary data in Manticore\n\n<!-- example binary -->\n\nManticore doesn't have a dedicated field type for binary data, but you can store it safely by using base64 encoding and the `text stored` or `string stored` field types (which are synonyms). If you don't encode the binary data, parts of it may get lost — for example, Manticore trims the end of a string if it encounters a null-byte.\n\nHere is an example where we encode the `ls` command using base64, store it in Manticore, and then decode it to verify that the MD5 checksum remains unchanged:\n\n<!-- request Example -->\n\nCODE_BLOCK_82\n\n<!-- end -->\n\n## Integer\n\n<!-- example for integers  -->\n\nInteger type allows storing 32 bit **unsigned** integer values.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_83\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_84\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_85\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_86\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_87\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_88\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_89\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_90\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_91\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_92\n\n<!-- end -->\n\n<!-- example for bit integers  -->",
    "translations": {
      "chinese": "此行为可以通过显式指定文本仅被索引来覆盖。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_43\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_44\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_45\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_46\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_47\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_48\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_49\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_50\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_51\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_52\n\n<!-- end -->\n\n<!-- example for field naming  -->\n\n字段是有名称的，您可以将搜索限制在单个字段（例如仅搜索“title”）或字段子集（例如仅“title”和“abstract”）中。您最多可以有256个全文字段。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_53\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_54\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_55\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_56\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_57\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_58\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_59\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_60\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_61\n\n<!-- end -->\n\n### 字符串\n\n<!-- example for string attributes  -->\n\n与全文字段不同，字符串属性（仅 `string` 或 `string/text attribute`）按接收的原样存储，不能用于全文搜索。相反，它们会在结果中返回，可以在 `WHERE` 子句中用于比较过滤或 `REGEX`，并且可以用于排序和聚合。通常，不建议在字符串属性中存储大量文本，而是将字符串属性用于元数据，如名称、标题、标签、键。\n\n如果您还想索引字符串属性，可以同时指定为 `string attribute indexed`。这将允许全文搜索，并且作为属性工作。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_62\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_63\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_64\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_65\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_66\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_67\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_68\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_69\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_70\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_71\n\n<!-- end -->\n\n<details>\n\n<summary>更多</summary>\n\n<!-- example string field -->\n\n您可以创建一个全文字段，同时也作为字符串属性存储。这种方法创建了一个全文字段和一个具有相同名称的字符串属性。请注意，您不能添加 `stored` 属性来同时将数据存储为字符串属性和文档存储。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\n`string attribute indexed` 意味着我们正在处理一个作为属性存储并作为全文字段索引的字符串数据类型。\n\nCODE_BLOCK_72\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_73\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_74\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_75\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_76\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_77\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_78\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_79\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_80\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_81\n\n<!-- end -->\n\n</details>\n\n### 在 Manticore 中存储二进制数据\n\n<!-- example binary -->\n\nManticore 没有专门的二进制数据字段类型，但您可以通过使用 base64 编码和 `text stored` 或 `string stored` 字段类型（它们是同义词）安全地存储它。如果不对二进制数据进行编码，部分数据可能会丢失——例如，如果遇到空字节，Manticore 会截断字符串末尾。\n\n下面是一个示例，我们使用 base64 编码 `ls` 命令，将其存储在 Manticore 中，然后解码以验证 MD5 校验和保持不变：\n\n<!-- request Example -->\n\nCODE_BLOCK_82\n\n<!-- end -->\n\n## 整数\n\n<!-- example for integers  -->\n\n整数类型允许存储32位**无符号**整数值。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_83\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_84\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_85\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_86\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_87\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_88\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_89\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_90\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_91\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_92\n\n<!-- end -->\n\n<!-- example for bit integers  -->",
      "russian": "Это поведение можно переопределить, явно указав, что текст индексируется только.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_43\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_44\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_45\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_46\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_47\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_48\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_49\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_50\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_51\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_52\n\n<!-- end -->\n\n<!-- example for field naming  -->\n\nПоля имеют имена, и вы можете ограничить поиск одним полем (например, искать только по \"title\") или подмножеством полей (например, только \"title\" и \"abstract\"). Вы можете иметь до 256 полнотекстовых полей.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_53\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_54\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_55\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_56\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_57\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_58\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_59\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_60\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_61\n\n<!-- end -->\n\n### Строка\n\n<!-- example for string attributes  -->\n\nВ отличие от полнотекстовых полей, строковые атрибуты (просто `string` или `string/text attribute`) хранятся в том виде, в каком они получены, и не могут использоваться в полнотекстовом поиске. Вместо этого они возвращаются в результатах, могут использоваться в условии `WHERE` для фильтрации по сравнению или `REGEX`, а также для сортировки и агрегации. В общем, не рекомендуется хранить большие тексты в строковых атрибутах, лучше использовать строковые атрибуты для метаданных, таких как имена, заголовки, теги, ключи.\n\nЕсли вы хотите также индексировать строковый атрибут, вы можете указать его как `string attribute indexed`. Это позволит полнотекстовый поиск и будет работать как атрибут.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_62\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_63\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_64\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_65\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_66\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_67\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_68\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_69\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_70\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_71\n\n<!-- end -->\n\n<details>\n\n<summary>Подробнее</summary>\n\n<!-- example string field -->\n\nВы можете создать полнотекстовое поле, которое также хранится как строковый атрибут. Такой подход создаёт полнотекстовое поле и строковый атрибут с одинаковым именем. Обратите внимание, что нельзя добавить свойство `stored`, чтобы одновременно хранить данные как строковый атрибут и в хранилище документов.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\n`string attribute indexed` означает, что мы работаем со строковым типом данных, который хранится как атрибут и индексируется как полнотекстовое поле.\n\nCODE_BLOCK_72\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_73\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_74\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_75\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_76\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_77\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_78\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_79\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_80\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_81\n\n<!-- end -->\n\n</details>\n\n### Хранение бинарных данных в Manticore\n\n<!-- example binary -->\n\nВ Manticore нет специального типа поля для бинарных данных, но вы можете безопасно хранить их, используя кодирование base64 и типы полей `text stored` или `string stored` (которые являются синонимами). Если не кодировать бинарные данные, их части могут потеряться — например, Manticore обрезает конец строки, если встречает нулевой байт.\n\nВот пример, где мы кодируем команду `ls` с помощью base64, сохраняем её в Manticore, а затем декодируем, чтобы проверить, что контрольная сумма MD5 осталась неизменной:\n\n<!-- request Example -->\n\nCODE_BLOCK_82\n\n<!-- end -->\n\n## Целое число\n\n<!-- example for integers  -->\n\nТип integer позволяет хранить 32-битные **беззнаковые** целочисленные значения.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_83\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_84\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_85\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_86\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_87\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_88\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_89\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_90\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_91\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_92\n\n<!-- end -->\n\n<!-- example for bit integers  -->"
    },
    "is_code_or_comment": false
  },
  "900b4b92b398fa7973cc2573759f57d62f082a4b2826a949177c12f11e032d94": {
    "original": "### How to switch between the storages\n\nThe traditional row-wise storage is the default, so if you want everything to be stored in a row-wise fashion, you don't need to do anything when you create a table.\n\nTo enable the columnar storage you need to:\n\n* specify `engine='columnar'` in [CREATE TABLE](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Creating-a-real-time-table-online-via-CREATE-TABLE) to make all attributes of the table columnar. Then, if you want to keep a specific attribute row-wise, you need to add `engine='rowwise'` when you declare it. For example:\n\nCODE_BLOCK_19\n\n* specify `engine='columnar'` for a specific attribute in `CREATE TABLE` to make it columnar. For example:\n\nCODE_BLOCK_20\n\nor\n\nCODE_BLOCK_21\n\n* in the [plain mode](../Read_this_first.md#Real-time-mode-vs-plain-mode) you need to list attributes you want to be columnar in [columnar_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#columnar_attrs).\n\nBelow is the list of data types supported by Manticore Search:\n\n## Document ID\n\nThe document identifier is a mandatory attribute that must be a unique 64-bit unsigned integer. Document IDs can be explicitly specified when creating a table, but they are always enabled even if not specified. Document IDs cannot be updated.\n\nWhen you create a table, you can specify ID explicitly, but regardless of the data type you use, it will always behave as described above - stored as unsigned 64-bit but exposed as signed 64-bit integer.\n\nCODE_BLOCK_22\n\nYou can also omit specifying ID at all, it will be enabled automatically.\n\nCODE_BLOCK_23\n\nWhen working with document IDs, it's important to know that they are stored internally as unsigned 64-bit integers but are handled differently depending on the interface:\n\n**MySQL/SQL interface:**\n\n* IDs greater than 2^63-1 will appear as negative numbers.\n\n* When filtering by such large IDs, you must use their signed representation.\n\n* Use the [UINT64()](../Functions/Type_casting_functions.md#UINT64%28%29) function to view the actual unsigned value.\n\n**JSON/HTTP interface:**\n\n* IDs are always displayed as their original unsigned values, regardless of size.\n\n* Both signed and unsigned representations can be used for filtering.\n\n* Insert operations accept the full unsigned 64-bit range.\n\nFor example, let's create a table and insert some values around 2^63:\n\nCODE_BLOCK_24\n\nSome IDs appear as negative numbers in the results because they exceed 2^63-1. However, using `UINT64(id)` can reveal their actual unsigned values:\n\nCODE_BLOCK_25\n\nFor querying documents with IDs less than 2^63, you can use the unsigned value directly:\n\nCODE_BLOCK_26\n\nHowever, for IDs starting from 2^63, you need to use the signed value:\n\nCODE_BLOCK_27\n\nIf you use an unsigned value instead, you will get an error:\n\nCODE_BLOCK_28\n\nValues that do not fit within 64 bits will trigger a similar error:\n\nCODE_BLOCK_29\n\n### Interface differences with large IDs\n\nThe behavior differences between MySQL/SQL and JSON/HTTP interfaces become more apparent with very large document IDs. Here's a comprehensive example:\n\n**MySQL/SQL interface:**\n\nCODE_BLOCK_30\n\n**JSON/HTTP interface:**\n\nCODE_BLOCK_31\n\nThis means when working with large document IDs:\n\n1. **MySQL interface** requires using the signed representation for queries but can display the unsigned value with `UINT64()`\n\n2. **JSON interface** consistently uses unsigned values for display and accepts both representations for filtering\n\n## Character data types\n\nGeneral syntax:\n\nCODE_BLOCK_32\n\n**Properties:**\n\n1. `indexed` - full-text indexed (can be used in full-text queries)\n\n2. `stored` - stored in a docstore (stored on disk, not in RAM, lazy read)\n\n3. `attribute` - makes it a string attribute (can sort/group by it)\n\nSpecifying at least one property overrides all the default ones (see below), i.e., if you decide to use a custom combination of properties, you need to list all the properties you want.\n\n**No properties specified:**\n\n`string` and `text` are aliases, but if you don't specify any properties, they by default mean different things:\n\n* just `string` by default means `attribute` (see details [below](../Creating_a_table/Data_types.md#Text)).\n\n* just `text` by default means `stored` + `indexed` (see details [below](../Creating_a_table/Data_types.md#String)).\n\n### Text\n\n<!-- example working with text -->\n\nThe text (just `text` or `text/string indexed`) data type forms the full-text part of the table. Text fields are indexed and can be searched for keywords.\n\nText is passed through an analyzer pipeline that converts the text to words, applies morphology transformations, etc. Eventually, a full-text table (a special data structure that enables quick searches for a keyword) gets built from that text.\n\nFull-text fields can only be used in the `MATCH()` clause and cannot be used for sorting or aggregation. Words are stored in an inverted index along with references to the fields they belong to and positions in the field. This allows searching a word inside each field and using advanced operators like proximity. By default, the original text of the fields is both indexed and stored in document storage. It means that the original text can be returned with the query results and used in [search result highlighting](../Searching/Highlighting.md).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_33\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_34\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_35\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_36\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_37\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_38\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_39\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_40\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_41\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_42\n\n<!-- end -->\n\n<!-- example working with indexed only  -->",
    "translations": {
      "chinese": "### 如何在存储方式之间切换\n\n传统的行存储是默认的，因此如果您希望所有内容都以行存储方式存储，创建表时无需做任何操作。\n\n要启用列存储，您需要：\n\n* 在 [CREATE TABLE](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Creating-a-real-time-table-online-via-CREATE-TABLE) 中指定 `engine='columnar'`，使表的所有属性都为列存储。然后，如果您想保持某个特定属性为行存储，需要在声明该属性时添加 `engine='rowwise'`。例如：\n\nCODE_BLOCK_19\n\n* 在 `CREATE TABLE` 中为特定属性指定 `engine='columnar'`，使其为列存储。例如：\n\nCODE_BLOCK_20\n\n或\n\nCODE_BLOCK_21\n\n* 在 [plain 模式](../Read_this_first.md#Real-time-mode-vs-plain-mode) 中，您需要在 [columnar_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#columnar_attrs) 中列出您希望为列存储的属性。\n\n以下是 Manticore Search 支持的数据类型列表：\n\n## 文档 ID\n\n文档标识符是一个必需的属性，必须是唯一的 64 位无符号整数。创建表时可以显式指定文档 ID，但即使未指定，文档 ID 也始终启用。文档 ID 不能被更新。\n\n创建表时，您可以显式指定 ID，但无论使用何种数据类型，它始终按上述方式行为——存储为无符号 64 位，但以有符号 64 位整数形式暴露。\n\nCODE_BLOCK_22\n\n您也可以完全省略指定 ID，它会自动启用。\n\nCODE_BLOCK_23\n\n在处理文档 ID 时，重要的是要知道它们在内部存储为无符号 64 位整数，但根据接口不同，处理方式有所不同：\n\n**MySQL/SQL 接口：**\n\n* 大于 2^63-1 的 ID 会显示为负数。\n\n* 过滤此类大 ID 时，必须使用它们的有符号表示。\n\n* 使用 [UINT64()](../Functions/Type_casting_functions.md#UINT64%28%29) 函数查看实际的无符号值。\n\n**JSON/HTTP 接口：**\n\n* ID 始终以其原始无符号值显示，无论大小。\n\n* 过滤时可以使用有符号和无符号表示。\n\n* 插入操作接受完整的无符号 64 位范围。\n\n例如，创建一个表并插入一些接近 2^63 的值：\n\nCODE_BLOCK_24\n\n某些 ID 在结果中显示为负数，因为它们超过了 2^63-1。然而，使用 `UINT64(id)` 可以显示它们的实际无符号值：\n\nCODE_BLOCK_25\n\n查询 ID 小于 2^63 的文档时，可以直接使用无符号值：\n\nCODE_BLOCK_26\n\n但对于从 2^63 开始的 ID，您需要使用有符号值：\n\nCODE_BLOCK_27\n\n如果使用无符号值，则会出现错误：\n\nCODE_BLOCK_28\n\n超出 64 位范围的值会触发类似错误：\n\nCODE_BLOCK_29\n\n### 大 ID 的接口差异\n\nMySQL/SQL 和 JSON/HTTP 接口在处理非常大的文档 ID 时行为差异更明显。以下是一个完整示例：\n\n**MySQL/SQL 接口：**\n\nCODE_BLOCK_30\n\n**JSON/HTTP 接口：**\n\nCODE_BLOCK_31\n\n这意味着在处理大文档 ID 时：\n\n1. **MySQL 接口** 查询时需要使用有符号表示，但可以用 `UINT64()` 显示无符号值\n\n2. **JSON 接口** 始终使用无符号值显示，过滤时接受两种表示\n\n## 字符数据类型\n\n通用语法：\n\nCODE_BLOCK_32\n\n**属性：**\n\n1. `indexed` - 全文索引（可用于全文查询）\n\n2. `stored` - 存储在文档存储中（存储在磁盘上，不在内存中，延迟读取）\n\n3. `attribute` - 使其成为字符串属性（可用于排序/分组）\n\n指定至少一个属性会覆盖所有默认属性（见下文），即如果您决定使用自定义属性组合，需要列出所有想要的属性。\n\n**未指定属性时：**\n\n`string` 和 `text` 是别名，但如果不指定任何属性，它们默认含义不同：\n\n* 仅 `string` 默认表示 `attribute`（详见[下文](../Creating_a_table/Data_types.md#Text)）。\n\n* 仅 `text` 默认表示 `stored` + `indexed`（详见[下文](../Creating_a_table/Data_types.md#String)）。\n\n### Text\n\n<!-- example working with text -->\n\ntext（仅 `text` 或 `text/string indexed`）数据类型构成表的全文部分。文本字段被索引，可以搜索关键词。\n\n文本通过分析器管道处理，将文本转换为单词，应用形态学变换等。最终，从该文本构建全文表（一种特殊数据结构，支持快速关键词搜索）。\n\n全文字段只能用于 `MATCH()` 子句，不能用于排序或聚合。单词存储在倒排索引中，附带它们所属字段的引用和字段中的位置。这允许在每个字段内搜索单词，并使用高级操作符如邻近搜索。默认情况下，字段的原始文本既被索引又存储在文档存储中。这意味着原始文本可以随查询结果返回，并用于[搜索结果高亮](../Searching/Highlighting.md)。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_33\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_34\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_35\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_36\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_37\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_38\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_39\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_40\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_41\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_42\n\n<!-- end -->\n\n<!-- example working with indexed only  -->",
      "russian": "### Как переключаться между хранилищами\n\nТрадиционное построчное хранение является значением по умолчанию, поэтому если вы хотите, чтобы всё хранилось построчно, вам не нужно ничего делать при создании таблицы.\n\nЧтобы включить колонковое хранение, нужно:\n\n* указать `engine='columnar'` в [CREATE TABLE](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Creating-a-real-time-table-online-via-CREATE-TABLE), чтобы все атрибуты таблицы были колонковыми. Если вы хотите, чтобы конкретный атрибут оставался построчным, нужно добавить `engine='rowwise'` при его объявлении. Например:\n\nCODE_BLOCK_19\n\n* указать `engine='columnar'` для конкретного атрибута в `CREATE TABLE`, чтобы сделать его колонковым. Например:\n\nCODE_BLOCK_20\n\nили\n\nCODE_BLOCK_21\n\n* в [plain режиме](../Read_this_first.md#Real-time-mode-vs-plain-mode) нужно перечислить атрибуты, которые вы хотите сделать колонковыми, в [columnar_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#columnar_attrs).\n\nНиже приведён список типов данных, поддерживаемых Manticore Search:\n\n## Идентификатор документа\n\nИдентификатор документа — обязательный атрибут, который должен быть уникальным 64-битным беззнаковым целым числом. Идентификаторы документов могут быть явно указаны при создании таблицы, но они всегда включены, даже если не указаны. Идентификаторы документов нельзя обновлять.\n\nПри создании таблицы вы можете явно указать ID, но независимо от используемого типа данных он всегда будет вести себя, как описано выше — храниться как беззнаковое 64-битное число, но отображаться как знаковое 64-битное целое.\n\nCODE_BLOCK_22\n\nВы также можете вообще не указывать ID, он будет включён автоматически.\n\nCODE_BLOCK_23\n\nПри работе с идентификаторами документов важно знать, что они хранятся внутренне как беззнаковые 64-битные целые, но обрабатываются по-разному в зависимости от интерфейса:\n\n**Интерфейс MySQL/SQL:**\n\n* Идентификаторы больше 2^63-1 будут отображаться как отрицательные числа.\n\n* При фильтрации по таким большим ID нужно использовать их знаковое представление.\n\n* Используйте функцию [UINT64()](../Functions/Type_casting_functions.md#UINT64%28%29), чтобы увидеть фактическое беззнаковое значение.\n\n**Интерфейс JSON/HTTP:**\n\n* ID всегда отображаются как их исходные беззнаковые значения, независимо от размера.\n\n* Для фильтрации можно использовать как знаковое, так и беззнаковое представление.\n\n* Операции вставки принимают полный диапазон беззнаковых 64-битных чисел.\n\nНапример, создадим таблицу и вставим несколько значений около 2^63:\n\nCODE_BLOCK_24\n\nНекоторые ID в результатах отображаются как отрицательные числа, потому что они превышают 2^63-1. Однако использование `UINT64(id)` позволяет увидеть их фактические беззнаковые значения:\n\nCODE_BLOCK_25\n\nДля запросов документов с ID меньше 2^63 можно использовать беззнаковое значение напрямую:\n\nCODE_BLOCK_26\n\nОднако для ID, начиная с 2^63, нужно использовать знаковое значение:\n\nCODE_BLOCK_27\n\nЕсли использовать беззнаковое значение вместо этого, будет ошибка:\n\nCODE_BLOCK_28\n\nЗначения, не помещающиеся в 64 бита, вызовут аналогичную ошибку:\n\nCODE_BLOCK_29\n\n### Различия интерфейсов при больших ID\n\nРазличия в поведении между интерфейсами MySQL/SQL и JSON/HTTP становятся более заметными при очень больших идентификаторах документов. Вот полный пример:\n\n**Интерфейс MySQL/SQL:**\n\nCODE_BLOCK_30\n\n**Интерфейс JSON/HTTP:**\n\nCODE_BLOCK_31\n\nЭто означает, что при работе с большими идентификаторами документов:\n\n1. **Интерфейс MySQL** требует использования знакового представления для запросов, но может отображать беззнаковое значение с помощью `UINT64()`\n\n2. **Интерфейс JSON** последовательно использует беззнаковые значения для отображения и принимает оба представления для фильтрации\n\n## Типы данных символов\n\nОбщий синтаксис:\n\nCODE_BLOCK_32\n\n**Свойства:**\n\n1. `indexed` — полнотекстовый индекс (можно использовать в полнотекстовых запросах)\n\n2. `stored` — хранится в docstore (хранится на диске, не в ОЗУ, ленивое чтение)\n\n3. `attribute` — делает его строковым атрибутом (можно сортировать/группировать по нему)\n\nУказание хотя бы одного свойства отменяет все свойства по умолчанию (см. ниже), то есть если вы решите использовать пользовательскую комбинацию свойств, нужно перечислить все свойства, которые хотите.\n\n**Если свойства не указаны:**\n\n`string` и `text` — это синонимы, но если не указать свойства, они по умолчанию означают разное:\n\n* просто `string` по умолчанию означает `attribute` (подробности [ниже](../Creating_a_table/Data_types.md#Text)).\n\n* просто `text` по умолчанию означает `stored` + `indexed` (подробности [ниже](../Creating_a_table/Data_types.md#String)).\n\n### Текст\n\n<!-- example working with text -->\n\nТип данных текст (просто `text` или `text/string indexed`) формирует полнотекстовую часть таблицы. Текстовые поля индексируются и по ним можно искать ключевые слова.\n\nТекст проходит через конвейер анализатора, который разбивает текст на слова, применяет морфологические преобразования и т. д. В итоге из этого текста строится полнотекстовая таблица (специальная структура данных, позволяющая быстро искать ключевое слово).\n\nПолнотекстовые поля можно использовать только в условии `MATCH()` и нельзя использовать для сортировки или агрегации. Слова хранятся в обратном индексе вместе с ссылками на поля, которым они принадлежат, и позициями в поле. Это позволяет искать слово внутри каждого поля и использовать расширенные операторы, например, близость. По умолчанию исходный текст полей индексируется и хранится в хранилище документов. Это значит, что исходный текст можно вернуть в результатах запроса и использовать в [подсветке результатов поиска](../Searching/Highlighting.md).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_33\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_34\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_35\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_36\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_37\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_38\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_39\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_40\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_41\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_42\n\n<!-- end -->\n\n<!-- example working with indexed only  -->"
    },
    "is_code_or_comment": false
  },
  "0aab980fdd4555824cfc4996037f6c2f608dcceffa8416dfaf6f9747e829946a": {
    "original": "# Data types\n\n## Full-text fields and attributes\n\nManticore's data types can be split into two categories: full-text fields and attributes.\n\n### Field name syntax\n\nField names in Manticore must follow these rules:\n\n* Can contain letters (a-z, A-Z), numbers (0-9), and hyphens (-)\n\n* Must start with a letter\n\n* Numbers can only appear after letters\n\n* Underscore (`_`) is the only allowed special character\n\n* Field names are case-insensitive\n\nFor example:\n\n* Valid field names: `title`, `product_id`, `user_name_2`\n\n* Invalid field names: `2title`, `-price`, `user@name`\n\n### Full-text fields\n\nFull-text fields:\n\n* can be indexed with natural language processing algorithms, therefore can be searched for keywords\n\n* cannot be used for sorting or grouping\n\n* original document's content can be retrieved\n\n* original document's content can be used for highlighting\n\nFull-text fields are represented by the data type `text`. All other data types are called \"attributes\".\n\n### Attributes\n\nAttributes are non-full-text values associated with each document that can be used to perform non-full-text filtering, sorting and grouping during a search.\n\nIt is often desired to process full-text search results based not only on matching document ID and its rank, but also on a number of other per-document values. For example, one might need to sort news search results by date and then relevance, or search through products within a specified price range, or limit a blog search to posts made by selected users, or group results by month. To do this efficiently, Manticore enables not only full-text fields, but also additional attributes to be added to each document. These attributes can be used to filter, sort, or group full-text matches, or to search only by attributes.\n\nThe attributes, unlike full-text fields, are not full-text indexed. They are stored in the table, but it is not possible to search them as full-text.\n\n<!-- example attributes or fields -->\n\nA good example for attributes would be a forum posts table. Assume that only the title and content fields need to be full-text searchable - but that sometimes it is also required to limit search to a certain author or a sub-forum (i.e., search only those rows that have some specific values of author_id or forum_id); or to sort matches by post_date column; or to group matching posts by month of the post_date and calculate per-group match counts.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_1\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_3\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request Javascript -->\n\nCODE_BLOCK_5\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_7\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_9\n\n<!-- end -->\n\n<!-- example filtered query -->\n\nThis example shows running a full-text query filtered by `author_id`, `forum_id` and sorted by `post_date`.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_10\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_11\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_12\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_13\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_14\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_16\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_17\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_18\n\n<!-- end -->\n\n### Row-wise and columnar attribute storages\n\nManticore supports two types of attribute storages:\n\n* row-wise - traditional storage available in Manticore Search out of the box\n\n* columnar - provided by [Manticore Columnar Library](https://github.com/manticoresoftware/columnar)\n\nAs can be understood from their names, they store data differently. The traditional **row-wise storage**:\n\n* stores attributes uncompressed\n\n* all attributes of the same document are stored in one row close to each other\n\n* rows are stored one by one\n\n* accessing attributes is basically done by just multiplying the row ID by the stride (length of a single vector) and getting the requested attribute from the calculated memory location. It gives very low random access latency.\n\n* attributes have to be in memory to get acceptable performance, otherwise due to the row-wise nature of the storage Manticore may have to read from disk too much unneeded data which is in many cases suboptimal.\n\nWith **the columnar storage**:\n\n* each attribute is stored independently of all other attributes in its separate \"column\"\n\n* storage is split into blocks of 65536 entries\n\n* the blocks are stored compressed. This often allows storing just a few distinct values instead of storing all of them like in the row-wise storage. High compression ratio allows reading from disk faster and makes the memory requirement much lower\n\n* when data is indexed, storage scheme is selected for each block independently. For example, if all values in a block are the same, it gets \"const\" storage and only one value is stored for the whole block. If there are less than 256 unique values per block, it gets \"table\" storage and stores indexes to a table of values instead of the values themselves\n\n* search in a block can be early rejected if it's clear the requested value is not present in the block.\n\nThe columnar storage was designed to handle large data volume that does not fit into RAM, so the recommendations are:\n\n* if you have enough memory for all your attributes you will benefit from the row-wise storage\n\n* otherwise, the columnar storage can still give you decent performance with a much lower memory footprint which will allow you to store much more documents in your table",
    "translations": {
      "chinese": "# 数据类型\n\n## 全文字段和属性\n\nManticore 的数据类型可以分为两类：全文字段和属性。\n\n### 字段名称语法\n\nManticore 中的字段名称必须遵循以下规则：\n\n* 可以包含字母（a-z，A-Z）、数字（0-9）和连字符（-）\n\n* 必须以字母开头\n\n* 数字只能出现在字母之后\n\n* 下划线（`_`）是唯一允许的特殊字符\n\n* 字段名称不区分大小写\n\n例如：\n\n* 有效的字段名称：`title`，`product_id`，`user_name_2`\n\n* 无效的字段名称：`2title`，`-price`，`user@name`\n\n### 全文字段\n\n全文字段：\n\n* 可以用自然语言处理算法进行索引，因此可以搜索关键词\n\n* 不能用于排序或分组\n\n* 可以检索原始文档内容\n\n* 可以使用原始文档内容进行高亮显示\n\n全文字段由数据类型 `text` 表示。所有其他数据类型称为“属性”。\n\n### 属性\n\n属性是与每个文档关联的非全文值，可用于在搜索期间执行非全文过滤、排序和分组。\n\n通常希望不仅基于匹配的文档 ID 及其排名来处理全文搜索结果，还基于多个每个文档的值。例如，可能需要按日期然后按相关性对新闻搜索结果进行排序，或者在指定价格范围内搜索产品，或者将博客搜索限制为特定用户发布的帖子，或者按月份对结果进行分组。为了高效实现这些功能，Manticore 不仅支持全文字段，还允许为每个文档添加额外的属性。这些属性可用于过滤、排序或分组全文匹配，或仅通过属性进行搜索。\n\n属性与全文字段不同，不进行全文索引。它们存储在表中，但不能像全文那样搜索。\n\n<!-- example attributes or fields -->\n\n属性的一个好例子是论坛帖子表。假设只有标题和内容字段需要全文搜索——但有时也需要限制搜索到某个作者或子论坛（即仅搜索具有特定 author_id 或 forum_id 值的行）；或者按 post_date 列排序匹配结果；或者按 post_date 的月份对匹配帖子进行分组并计算每组的匹配计数。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_1\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_3\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request Javascript -->\n\nCODE_BLOCK_5\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_7\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_9\n\n<!-- end -->\n\n<!-- example filtered query -->\n\n此示例展示了运行一个通过 `author_id`、`forum_id` 过滤并按 `post_date` 排序的全文查询。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_10\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_11\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_12\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_13\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_14\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_16\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_17\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_18\n\n<!-- end -->\n\n### 行存和列存属性存储\n\nManticore 支持两种类型的属性存储：\n\n* 行存——Manticore Search 默认提供的传统存储\n\n* 列存——由 [Manticore Columnar Library](https://github.com/manticoresoftware/columnar) 提供\n\n顾名思义，它们以不同方式存储数据。传统的**行存储**：\n\n* 存储未压缩的属性\n\n* 同一文档的所有属性存储在一行中，彼此相邻\n\n* 行按顺序存储\n\n* 访问属性基本上是通过将行 ID 乘以步幅（单个向量的长度），然后从计算出的内存位置获取请求的属性。这提供了非常低的随机访问延迟。\n\n* 属性必须在内存中才能获得可接受的性能，否则由于行存储的特性，Manticore 可能需要从磁盘读取过多不必要的数据，这在许多情况下是次优的。\n\n而**列存储**：\n\n* 每个属性独立存储在其单独的“列”中，与其他属性无关\n\n* 存储被分割成 65536 条目的块\n\n* 块以压缩形式存储。这通常允许只存储少数不同的值，而不是像行存储那样存储所有值。高压缩比允许更快地从磁盘读取，并大大降低内存需求\n\n* 索引数据时，每个块独立选择存储方案。例如，如果一个块中的所有值都相同，则采用“const”存储，整个块只存储一个值。如果每个块中唯一值少于 256 个，则采用“table”存储，存储指向值表的索引而非值本身\n\n* 如果明确请求的值不在块中，则可以提前拒绝该块的搜索。\n\n列存储设计用于处理无法全部装入内存的大量数据，因此建议：\n\n* 如果你有足够的内存存放所有属性，使用行存储会更有利\n\n* 否则，列存储仍能提供不错的性能，同时大幅降低内存占用，这将允许你在表中存储更多文档",
      "russian": "# Типы данных\n\n## Полнотекстовые поля и атрибуты\n\nТипы данных Manticore можно разделить на две категории: полнотекстовые поля и атрибуты.\n\n### Синтаксис имени поля\n\nИмена полей в Manticore должны соответствовать следующим правилам:\n\n* Могут содержать буквы (a-z, A-Z), цифры (0-9) и дефисы (-)\n\n* Должны начинаться с буквы\n\n* Цифры могут появляться только после букв\n\n* Подчеркивание (`_`) — единственный разрешённый специальный символ\n\n* Имена полей не чувствительны к регистру\n\nНапример:\n\n* Допустимые имена полей: `title`, `product_id`, `user_name_2`\n\n* Недопустимые имена полей: `2title`, `-price`, `user@name`\n\n### Полнотекстовые поля\n\nПолнотекстовые поля:\n\n* могут индексироваться с помощью алгоритмов обработки естественного языка, поэтому по ним можно искать ключевые слова\n\n* не могут использоваться для сортировки или группировки\n\n* можно получить исходное содержимое документа\n\n* исходное содержимое документа можно использовать для подсветки\n\nПолнотекстовые поля представлены типом данных `text`. Все остальные типы данных называются «атрибутами».\n\n### Атрибуты\n\nАтрибуты — это не полнотекстовые значения, связанные с каждым документом, которые можно использовать для фильтрации, сортировки и группировки по неполнотекстовым критериям во время поиска.\n\nЧасто требуется обрабатывать результаты полнотекстового поиска не только на основе совпадения ID документа и его ранга, но и на основе ряда других значений, связанных с документом. Например, может понадобиться отсортировать результаты поиска новостей по дате, а затем по релевантности, или искать товары в заданном ценовом диапазоне, или ограничить поиск по блогу постами, сделанными выбранными пользователями, или сгруппировать результаты по месяцу. Для эффективного выполнения таких задач Manticore позволяет добавлять к каждому документу не только полнотекстовые поля, но и дополнительные атрибуты. Эти атрибуты можно использовать для фильтрации, сортировки или группировки полнотекстовых совпадений, а также для поиска только по атрибутам.\n\nАтрибуты, в отличие от полнотекстовых полей, не индексируются полнотекстово. Они хранятся в таблице, но по ним нельзя выполнять полнотекстовый поиск.\n\n<!-- example attributes or fields -->\n\nХорошим примером атрибутов может служить таблица сообщений форума. Предположим, что полнотекстовым поиском должны быть доступны только поля title и content — но иногда требуется ограничить поиск определённым автором или подфорумом (то есть искать только те строки, у которых есть конкретные значения author_id или forum_id); или сортировать совпадения по столбцу post_date; или группировать совпадающие сообщения по месяцу из post_date и подсчитывать количество совпадений в каждой группе.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_1\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_3\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request Javascript -->\n\nCODE_BLOCK_5\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_7\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_9\n\n<!-- end -->\n\n<!-- example filtered query -->\n\nВ этом примере показан запуск полнотекстового запроса с фильтрацией по `author_id`, `forum_id` и сортировкой по `post_date`.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_10\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_11\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_12\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_13\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_14\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_16\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_17\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_18\n\n<!-- end -->\n\n### Строковое и колонковое хранение атрибутов\n\nManticore поддерживает два типа хранения атрибутов:\n\n* строковое — традиционное хранение, доступное в Manticore Search из коробки\n\n* колонковое — предоставляется [Manticore Columnar Library](https://github.com/manticoresoftware/columnar)\n\nКак можно понять из названий, они хранят данные по-разному. Традиционное **строковое хранение**:\n\n* хранит атрибуты без сжатия\n\n* все атрибуты одного документа хранятся в одной строке рядом друг с другом\n\n* строки хранятся одна за другой\n\n* доступ к атрибутам осуществляется просто умножением ID строки на шаг (длину одного вектора) и получением нужного атрибута из рассчитанного адреса в памяти. Это обеспечивает очень низкую задержку случайного доступа.\n\n* атрибуты должны находиться в памяти для достижения приемлемой производительности, иначе из-за строковой природы хранения Manticore может читать с диска слишком много ненужных данных, что во многих случаях не оптимально.\n\nВ случае **колонкового хранения**:\n\n* каждый атрибут хранится независимо от всех остальных в отдельной «колонке»\n\n* хранилище разбито на блоки по 65536 записей\n\n* блоки хранятся в сжатом виде. Это часто позволяет хранить всего несколько различных значений вместо хранения всех значений, как в строковом хранении. Высокое сжатие позволяет быстрее читать с диска и значительно снижает требования к памяти\n\n* при индексировании данных схема хранения выбирается для каждого блока отдельно. Например, если все значения в блоке одинаковы, он получает «const» хранение, и для всего блока хранится только одно значение. Если в блоке менее 256 уникальных значений, он получает «table» хранение и хранит индексы в таблицу значений вместо самих значений\n\n* поиск в блоке может быть досрочно отклонён, если ясно, что запрашиваемое значение отсутствует в блоке.\n\nКолонковое хранение было разработано для обработки больших объёмов данных, которые не помещаются в ОЗУ, поэтому рекомендации таковы:\n\n* если у вас достаточно памяти для всех атрибутов, вы получите выгоду от строкового хранения\n\n* в противном случае колонковое хранение всё равно может обеспечить достойную производительность с гораздо меньшим потреблением памяти, что позволит хранить гораздо больше документов в таблице"
    },
    "is_code_or_comment": false
  },
  "ed2c4f0e583d8ce3d6235d06c9e033c921aa523b0428a5a2070fe6ddd3f9a31a": {
    "original": "Float vector attributes allow storing variable-length lists of floats, primarily used for machine learning applications and similarity searches. This type differs from [multi-valued attributes](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29) (MVAs) in several important ways:\n\n- Preserves the exact order of values (unlike MVAs which may reorder)\n\n- Retains duplicate values (unlike MVAs which deduplicate)\n\n- No additional processing during insertion (unlike MVAs which sort and deduplicate)\n\nFloat vector attributes allow storing variable-length lists of floats, primarily used for machine learning applications and similarity searches. \n\n### Usage and Limitations\n\n- Currently only supported in real-time tables\n\n- Can only be utilized in KNN (k-nearest neighbor) searches\n\n- Not supported in plain tables or other functions/expressions\n\n- When used with KNN settings, you cannot `UPDATE` `float_vector` values. Use `REPLACE` instead\n\n- When used without KNN settings, you can `UPDATE` `float_vector` values\n\n- Float vectors cannot be used in regular filters or sorting\n\n- The only way to filter by `float_vector` values is through vector search operations (KNN)\n\n### Common Use Cases\n\n- Text embeddings for semantic search\n\n- Recommendation system vectors\n\n- Image embeddings for similarity search\n\n- Feature vectors for machine learning\n\n** Keep in mind that the `float_vector` data type is not compatible with the [Auto schema](../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md#Auto-schema) mechanism. **\n\nFor more details on setting up float vectors and using them in searches, see [KNN search](../Searching/KNN.md).\n\n### Auto Embeddings (Recommended)\n\nThe most convenient way to work with float vectors is using **auto embeddings**. This feature automatically generates embeddings from your text data using machine learning models, eliminating the need to manually compute and insert vectors.\n\n#### Benefits of Auto Embeddings\n\n- **Simplified workflow**: Just insert text, embeddings are generated automatically\n\n- **No manual vector computation**: No need to run separate embedding models\n\n- **Consistent embeddings**: Same model ensures consistent vector representations\n\n- **Multiple model support**: Choose from [sentence-transformers](https://huggingface.co/sentence-transformers/models), OpenAI, Voyage, and Jina models\n\n- **Flexible field selection**: Control which fields are used for embedding generation\n\n#### Creating tables with auto embeddings\n\nWhen creating a table with auto embeddings, specify these additional parameters:\n\n- `MODEL_NAME`: The embedding model to use for automatic vector generation\n\n- `FROM`: Which fields to use for embedding generation (empty string means all text/string fields)\n\n**Supported embedding models:**\n\n- **Sentence Transformers**: Any [suitable BERT-based Hugging Face model](https://huggingface.co/sentence-transformers/models) (e.g., `sentence-transformers/all-MiniLM-L6-v2`) — no API key needed. Manticore downloads the model when you create the table.\n\n- **OpenAI**: OpenAI embedding models like `openai/text-embedding-ada-002` - requires `API_KEY='<OPENAI_API_KEY>'` parameter\n\n- **Voyage**: Voyage AI embedding models - requires `API_KEY='<VOYAGE_API_KEY>'` parameter\n\n- **Jina**: Jina AI embedding models - requires `API_KEY='<JINA_API_KEY>'` parameter\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nUsing [sentence-transformers model](https://huggingface.co/sentence-transformers/models) (no API key needed)\n\nCODE_BLOCK_199\n\nUsing OpenAI model (requires API_KEY parameter)\n\nCODE_BLOCK_200\n\nUsing all text fields for embeddings (FROM is empty)\n\nCODE_BLOCK_201\n\n<!-- end -->\n\n#### FROM parameter usage\n\nThe `FROM` parameter controls which fields are used for embedding generation:\n\n- **Specific fields**: `FROM='title'` - only the title field is used\n\n- **Multiple fields**: `FROM='title,description'` - both title and description are concatenated and used\n\n- **All text fields**: `FROM=''` (empty) - all `text` (full-text field) and `string` (string attribute) fields in the table are used\n\n- **Empty vectors**: You can still insert empty vectors using `()` to exclude documents from vector search\n\n#### Inserting data with auto embeddings\n\nWhen using auto embeddings, **do not specify the vector field** in your INSERT statements. The embeddings are automatically generated from the specified text fields:\n\nCODE_BLOCK_202\n\n### Manual Float Vector Usage\n\n<!-- example for creating float_vector -->\n\nAlternatively, you can work with manually computed float vectors. \n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_203\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_204\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_205\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_206\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_207\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_208\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_209\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_210\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_211\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_212\n\n<!-- end -->\n\n## Multi-value integer (MVA)\n\n<!-- example for creating MVA32 -->\n\nMulti-value attributes allow storing variable-length lists of 32-bit unsigned integers. This can be useful for storing one-to-many numeric values, such as tags, product categories, and properties.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_213\n\nor\n\nCODE_BLOCK_214\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_215\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_216\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_217\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_218\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_219\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_220\n\n<!-- intro -->",
    "translations": {
      "chinese": "浮点向量属性允许存储可变长度的浮点列表，主要用于机器学习应用和相似性搜索。这种类型与[多值属性](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29) （MVA）在几个重要方面不同：\n\n- 保留值的准确顺序（不同于可能重新排序的MVA）\n\n- 保留重复值（不同于去重的MVA）\n\n- 插入时无额外处理（不同于排序和去重的MVA）\n\n浮点向量属性允许存储可变长度的浮点列表，主要用于机器学习应用和相似性搜索。 \n\n### 用法和限制\n\n- 目前仅支持实时表\n\n- 只能用于KNN（k近邻）搜索\n\n- 不支持在普通表或其他函数/表达式中使用\n\n- 使用KNN设置时，不能`UPDATE` `float_vector`值。请使用`REPLACE`\n\n- 不使用KNN设置时，可以`UPDATE` `float_vector`值\n\n- 浮点向量不能用于常规过滤或排序\n\n- 通过`float_vector`值过滤唯一方式是向量搜索操作（KNN）\n\n### 常见用例\n\n- 用于语义搜索的文本嵌入\n\n- 推荐系统向量\n\n- 用于相似性搜索的图像嵌入\n\n- 机器学习的特征向量\n\n** 请记住，`float_vector`数据类型不兼容[自动模式](../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md#Auto-schema)机制。**\n\n有关设置浮点向量和在搜索中使用的更多详细信息，请参见[KNN搜索](../Searching/KNN.md)。\n\n### 自动嵌入（推荐）\n\n使用**自动嵌入**是操作浮点向量最方便的方式。此功能使用机器学习模型自动从文本数据生成嵌入，无需手动计算和插入向量。\n\n#### 自动嵌入的好处\n\n- **简化流程**：只需插入文本，嵌入自动生成\n\n- **无需手动计算向量**：无需运行单独的嵌入模型\n\n- **嵌入一致性**：同一模型确保向量表示一致\n\n- **多模型支持**：可选择[sentence-transformers](https://huggingface.co/sentence-transformers/models)、OpenAI、Voyage 和 Jina 模型\n\n- **灵活字段选择**：可控制用于生成嵌入的字段\n\n#### 创建带自动嵌入的表\n\n创建使用自动嵌入的表时，指定以下附加参数：\n\n- `MODEL_NAME`：用于自动生成向量的嵌入模型\n\n- `FROM`：用于生成嵌入的字段（空字符串表示所有文本/字符串字段）\n\n**支持的嵌入模型：**\n\n- **Sentence Transformers**：任何[合适的基于BERT的Hugging Face模型](https://huggingface.co/sentence-transformers/models)（如`sentence-transformers/all-MiniLM-L6-v2`）— 无需API密钥。Manticore在创建表时下载模型。\n\n- **OpenAI**：OpenAI嵌入模型，如`openai/text-embedding-ada-002` - 需要`API_KEY='<OPENAI_API_KEY>'`参数\n\n- **Voyage**：Voyage AI嵌入模型 - 需要`API_KEY='<VOYAGE_API_KEY>'`参数\n\n- **Jina**：Jina AI嵌入模型 - 需要`API_KEY='<JINA_API_KEY>'`参数\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\n使用[sentence-transformers模型](https://huggingface.co/sentence-transformers/models)（无需API密钥）\n\nCODE_BLOCK_199\n\n使用OpenAI模型（需要API_KEY参数）\n\nCODE_BLOCK_200\n\n使用所有文本字段作为嵌入（FROM为空）\n\nCODE_BLOCK_201\n\n<!-- end -->\n\n#### FROM 参数用法\n\n`FROM`参数控制哪些字段用于生成嵌入：\n\n- **特定字段**：`FROM='title'` - 仅使用标题字段\n\n- **多个字段**：`FROM='title,description'` - 标题和描述拼接后使用\n\n- **所有文本字段**：`FROM=''`（为空） - 使用表中所有`text`（全文字段）和`string`（字符串属性）字段\n\n- **空向量**：仍可使用`()`插入空向量，以排除文档参与向量搜索\n\n#### 使用自动嵌入插入数据\n\n使用自动嵌入时，**请勿在INSERT语句中指定向量字段**。嵌入会自动从指定的文本字段生成：\n\nCODE_BLOCK_202\n\n### 手动浮点向量使用\n\n<!-- example for creating float_vector -->\n\n或者，您可以使用手动计算的浮点向量。 \n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_203\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_204\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_205\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_206\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_207\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_208\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_209\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_210\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_211\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_212\n\n<!-- end -->\n\n## 多值整数（MVA）\n\n<!-- example for creating MVA32 -->\n\n多值属性允许存储可变长度的32位无符号整数列表。这对于存储一对多的数值非常有用，例如标签、产品类别和属性。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_213\n\n或者\n\nCODE_BLOCK_214\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_215\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_216\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_217\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_218\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_219\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_220\n\n<!-- intro -->",
      "russian": "Атрибуты вектора с плавающей точкой позволяют хранить списки переменной длины из чисел с плавающей точкой, преимущественно используемые для задач машинного обучения и поиска по сходству. Этот тип отличается от [многозначных атрибутов](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29) (MVA) по нескольким важным аспектам:\n\n- Сохраняет точный порядок значений (в отличие от MVA, которые могут менять порядок)\n\n- Сохраняет дубликаты значений (в отличие от MVA, которые удаляют дубликаты)\n\n- Нет дополнительной обработки при вставке (в отличие от MVA, которые сортируют и удаляют дубликаты)\n\nАтрибуты вектора с плавающей точкой позволяют хранить списки переменной длины из чисел с плавающей точкой, преимущественно используемые для задач машинного обучения и поиска по сходству.\n\n### Использование и ограничения\n\n- В настоящее время поддерживаются только в таблицах реального времени\n\n- Могут использоваться только в KNN-поисках (k-ближайших соседей)\n\n- Не поддерживаются в обычных таблицах или в других функциях/выражениях\n\n- При использовании с настройками KNN нельзя `UPDATE` значения `float_vector`. Используйте `REPLACE`\n\n- При использовании без настроек KNN можно `UPDATE` значения `float_vector`\n\n- Векторы с плавающей точкой нельзя использовать в обычных фильтрах или сортировках\n\n- Единственный способ фильтровать по значениям `float_vector` — через операции векторного поиска (KNN)\n\n### Распространённые случаи использования\n\n- Встраивания текста для семантического поиска\n\n- Векторы для систем рекомендаций\n\n- Встраивания изображений для поиска по сходству\n\n- Векторы признаков для машинного обучения\n\n** Учтите, что тип данных `float_vector` несовместим с механизмом [Auto schema](../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md#Auto-schema). **\n\nДля подробностей по настройке векторов с плавающей точкой и использованию их в поисках смотрите [KNN search](../Searching/KNN.md).\n\n### Автоматические встраивания (рекомендуется)\n\nСамый удобный способ работы с векторами с плавающей точкой — использование **автоматических встраиваний**. Эта функция автоматически генерирует встраивания из текстовых данных с помощью моделей машинного обучения, избавляя от необходимости вручную вычислять и вставлять векторы.\n\n#### Преимущества автоматических встраиваний\n\n- **Упрощённый рабочий процесс**: просто вставляйте текст — встраивания генерируются автоматически\n\n- **Нет необходимости в ручном вычислении векторов**: не нужно запускать отдельные модели генерации векторов\n\n- **Постоянство встраиваний**: одна и та же модель обеспечивает согласованное представление векторов\n\n- **Поддержка нескольких моделей**: выбирайте из моделей [sentence-transformers](https://huggingface.co/sentence-transformers/models), OpenAI, Voyage и Jina\n\n- **Гибкий выбор полей**: управлять тем, какие поля используются для генерации встраиваний\n\n#### Создание таблиц с автоматическими встраиваниями\n\nПри создании таблицы с автоembedding укажите следующие дополнительные параметры:\n\n- `MODEL_NAME`: модель встраивания для автоматической генерации векторов\n\n- `FROM`: какие поля использовать для генерации встраиваний (пустая строка — все текстовые/строковые поля)\n\n**Поддерживаемые модели встраиваний:**\n\n- **Sentence Transformers**: любая [подходящая модел ь Hugging Face на базе BERT](https://huggingface.co/sentence-transformers/models) (например, `sentence-transformers/all-MiniLM-L6-v2`) — API ключ не нужен. Manticore загружает модель при создании таблицы.\n\n- **OpenAI**: модели встраивания OpenAI, например `openai/text-embedding-ada-002` — требует параметр `API_KEY='<OPENAI_API_KEY>'`\n\n- **Voyage**: модели встраивания Voyage AI — требует параметр `API_KEY='<VOYAGE_API_KEY>'`\n\n- **Jina**: модели встраивания Jina AI — требует параметр `API_KEY='<JINA_API_KEY>'`\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nИспользование модели [sentence-transformers](https://huggingface.co/sentence-transformers/models) (API ключ не нужен)\n\nCODE_BLOCK_199\n\nИспользование модели OpenAI (требуется параметр API_KEY)\n\nCODE_BLOCK_200\n\nИспользование всех текстовых полей для встраиваний (FROM пустой)\n\nCODE_BLOCK_201\n\n<!-- end -->\n\n#### Использование параметра FROM\n\nПараметр `FROM` контролирует, какие поля используются для генерации встраиваний:\n\n- **Конкретные поля**: `FROM='title'` — используется только поле title\n\n- **Несколько полей**: `FROM='title,description'` — поля title и description объединяются и используются\n\n- **Все текстовые поля**: `FROM=''` (пусто) — используются все поля `text` (поля полного текста) и `string` (строковые атрибуты) таблицы\n\n- **Пустые векторы**: можно вставлять пустые векторы с помощью `()`, чтобы исключить документы из векторного поиска\n\n#### Вставка данных с автоматическими встраиваниями\n\nПри использовании автоembedding **не указывайте векторное поле** в командах INSERT. Встраивания будут созданы автоматически из указанных текстовых полей:\n\nCODE_BLOCK_202\n\n### Ручное использование векторов с плавающей точкой\n\n<!-- example for creating float_vector -->\n\nКроме того, можно работать с вручную вычисленными векторами с плавающей точкой.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_203\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_204\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_205\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_206\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_207\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_208\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_209\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_210\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_211\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_212\n\n<!-- end -->\n\n## Многозначное целочисленное значение (MVA)\n\n<!-- example for creating MVA32 -->\n\nМногозначные атрибуты позволяют хранить списки переменной длины из 32-битных беззнаковых целых чисел. Это может быть полезно для хранения значений один-ко-многим, таких как теги, категории товаров и свойства.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_213\n\nили\n\nCODE_BLOCK_214\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_215\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_216\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_217\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_218\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_219\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_220\n\n<!-- intro -->"
    },
    "is_code_or_comment": false
  },
  "18b20987511e429b4ad703445c8a732902778d8af5ea0073f5752dc40b692f97": {
    "original": "##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_221\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_222\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_223\n\n<!-- end -->\n\n<!-- example for any/all MVA -->\n\nIt supports filtering and aggregation, but not sorting. Filtering can be done using a condition that requires at least one element to pass (using [ANY()](../Functions/Arrays_and_conditions_functions.md#ANY%28%29)) or all elements ([ALL()](../Functions/Arrays_and_conditions_functions.md#ALL%28%29)) to pass.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_224\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_225\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_226\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_227\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_228\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_229\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_230\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_231\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_232\n\n<!-- end -->\n\n<!-- example for least/greatest MVA -->\n\nInformation like [least](../Functions/Mathematical_functions.md#LEAST%28%29) or [greatest](../Functions/Mathematical_functions.md#GREATEST%28%29) element and length of the list can be extracted. An example shows ordering by the least element of a multi-value attribute.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_233\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_234\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_235\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_236\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_237\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_238\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_239\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_240\n\n<!-- request Rust -->\n\nCODE_BLOCK_241\n\n<!-- end -->\n\n<!-- example for grouping by MVA -->\n\nWhen grouping by a multi-value attribute, a document will contribute to as many groups as there are different values associated with that document. For instance, if a collection contains exactly one document having a 'product_codes' multi-value attribute with values 5, 7, and 11, grouping on 'product_codes' will produce 3 groups with `COUNT(*)`equal to 1 and `GROUPBY()` key values of 5, 7, and 11, respectively. Also, note that grouping by multi-value attributes may lead to duplicate documents in the result set because each document can participate in many groups.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_242\n\n<!-- response mysql -->\n\nCODE_BLOCK_243\n\n<!-- end -->\n\n<!-- example for MVA value order -->\n\nThe order of the numbers inserted as values of multivalued attributes is not preserved. Values are stored internally as a sorted set.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_244\n\n<!-- response mysql -->\n\nCODE_BLOCK_245\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_246\n\n<!-- response JSON -->\n\nCODE_BLOCK_247\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_248\n\n<!-- response PHP -->\n\nCODE_BLOCK_249\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_250\n\n<!-- response Python -->\n\nCODE_BLOCK_251\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_252\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_253\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_254\n\n<!-- response javascript -->\n\nCODE_BLOCK_255\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_256\n\n<!-- response java -->\n\nCODE_BLOCK_257\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_258\n\n<!-- response C# -->\n\nCODE_BLOCK_259\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_260\n\n<!-- response Rust -->\n\nCODE_BLOCK_261\n\n<!-- end -->\n\n## Multi-value big integer\n\n<!-- example for creating MVA64 -->\n\nA data type that allows storing variable-length lists of 64-bit signed integers. It has the same functionality as multi-value integer.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_262\n\nor\n\nCODE_BLOCK_263\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_264\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_265\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_266\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_267\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_268\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_269\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_270\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_271\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_272\n\n<!-- end -->\n\n## Columnar attribute properties\n\nWhen you use the columnar storage you can specify the following properties for the attributes.\n\n<!-- example fast_fetch -->\n\n### fast_fetch\n\nBy default, Manticore Columnar storage stores all attributes in a columnar fashion, as well as in a special docstore row by row. This enables fast execution of queries like `SELECT * FROM ...`, especially when fetching a large number of records at once. However, if you are sure that you do not need it or wish to save disk space, you can disable it by specifying `fast_fetch='0'` when creating a table or (if you are defining a table in a config) by using `columnar_no_fast_fetch` as shown in the following example.\n\n<!-- request RT mode -->\n\nCODE_BLOCK_273\n\n<!-- response RT mode -->\n\nCODE_BLOCK_274\n\n<!-- request Plain mode -->\n\nCODE_BLOCK_275\n\n<!-- response Plain mode -->\n\nCODE_BLOCK_276\n\n<!-- end -->",
    "translations": {
      "chinese": "##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_221\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_222\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_223\n\n<!-- end -->\n\n<!-- example for any/all MVA -->\n\n它支持过滤和聚合，但不支持排序。过滤可以使用条件进行，该条件要求至少有一个元素通过（使用 [ANY()](../Functions/Arrays_and_conditions_functions.md#ANY%28%29)）或所有元素通过（[ALL()](../Functions/Arrays_and_conditions_functions.md#ALL%28%29)）。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_224\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_225\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_226\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_227\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_228\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_229\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_230\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_231\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_232\n\n<!-- end -->\n\n<!-- example for least/greatest MVA -->\n\n可以提取诸如 [least](../Functions/Mathematical_functions.md#LEAST%28%29) 或 [greatest](../Functions/Mathematical_functions.md#GREATEST%28%29) 元素以及列表长度等信息。示例显示了按多值属性的最小元素进行排序。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_233\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_234\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_235\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_236\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_237\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_238\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_239\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_240\n\n<!-- request Rust -->\n\nCODE_BLOCK_241\n\n<!-- end -->\n\n<!-- example for grouping by MVA -->\n\n当按多值属性分组时，一个文档将贡献给与该文档关联的不同值数量相等的多个组。例如，如果集合中恰有一个文档具有“product_codes”多值属性，其值为5、7和11，则按“product_codes”分组将生成3个组，每个组的 `COUNT(*)` 为1，`GROUPBY()` 键值分别是5、7和11。另请注意，按多值属性分组可能导致结果集中出现重复文档，因为每个文档可以参与多个组。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_242\n\n<!-- response mysql -->\n\nCODE_BLOCK_243\n\n<!-- end -->\n\n<!-- example for MVA value order -->\n\n作为多值属性值插入的数字的顺序不会被保留。值内部以排序集合的形式存储。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_244\n\n<!-- response mysql -->\n\nCODE_BLOCK_245\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_246\n\n<!-- response JSON -->\n\nCODE_BLOCK_247\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_248\n\n<!-- response PHP -->\n\nCODE_BLOCK_249\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_250\n\n<!-- response Python -->\n\nCODE_BLOCK_251\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_252\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_253\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_254\n\n<!-- response javascript -->\n\nCODE_BLOCK_255\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_256\n\n<!-- response java -->\n\nCODE_BLOCK_257\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_258\n\n<!-- response C# -->\n\nCODE_BLOCK_259\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_260\n\n<!-- response Rust -->\n\nCODE_BLOCK_261\n\n<!-- end -->\n\n## 多值大整数\n\n<!-- example for creating MVA64 -->\n\n一种允许存储可变长度64位有符号整数列表的数据类型。它具有与多值整数相同的功能。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_262\n\nor\n\nCODE_BLOCK_263\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_264\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_265\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_266\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_267\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_268\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_269\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_270\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_271\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_272\n\n<!-- end -->\n\n## 列存属性属性\n\n当您使用列存储时，您可以为属性指定以下属性。\n\n<!-- example fast_fetch -->\n\n### fast_fetch\n\n默认情况下，Manticore 列存储以列的方式存储所有属性，同时也以特殊的文档存储逐行存储。这使得像 `SELECT * FROM ...` 这样的查询能够快速执行，尤其是在一次获取大量记录时。但如果您确定不需要它或者想节省磁盘空间，可以在创建表时通过指定 `fast_fetch='0'` 禁用它，或者（如果您在配置中定义表）使用 `columnar_no_fast_fetch`，如下例所示。\n\n<!-- request RT mode -->\n\nCODE_BLOCK_273\n\n<!-- response RT mode -->\n\nCODE_BLOCK_274\n\n<!-- request Plain mode -->\n\nCODE_BLOCK_275\n\n<!-- response Plain mode -->\n\nCODE_BLOCK_276\n\n<!-- end -->",
      "russian": "##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_221\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_222\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_223\n\n<!-- end -->\n\n<!-- example for any/all MVA -->\n\nПоддерживается фильтрация и агрегация, но не сортировка. Фильтрация может быть выполнена с помощью условия, требующего, чтобы хотя бы один элемент прошёл проверку (используя [ANY()](../Functions/Arrays_and_conditions_functions.md#ANY%28%29)) или все элементы ([ALL()](../Functions/Arrays_and_conditions_functions.md#ALL%28%29)) прошли проверку.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_224\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_225\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_226\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_227\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_228\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_229\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_230\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_231\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_232\n\n<!-- end -->\n\n<!-- example for least/greatest MVA -->\n\nМожно получить информацию, как [наименьший](../Functions/Mathematical_functions.md#LEAST%28%29), так и [наибольший](../Functions/Mathematical_functions.md#GREATEST%28%29) элемент, а также длину списка. В примере показана сортировка по наименьшему элементу множества значений атрибута.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_233\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_234\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_235\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_236\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_237\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_238\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_239\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_240\n\n<!-- request Rust -->\n\nCODE_BLOCK_241\n\n<!-- end -->\n\n<!-- example for grouping by MVA -->\n\nПри группировке по атрибуту с множественными значениями, документ будет участвовать в таком количестве групп, сколько у него различных значений этого атрибута. Например, если в коллекции есть ровно один документ с мультизначным атрибутом 'product_codes' со значениями 5, 7 и 11, группировка по 'product_codes' создаст 3 группы с `COUNT(*)` равным 1 и ключами `GROUPBY()` 5, 7 и 11 соответственно. Также стоит отметить, что группировка по многозначным атрибутам может привести к дублированию документов в результирующем наборе, поскольку один документ может участвовать во многих группах.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_242\n\n<!-- response mysql -->\n\nCODE_BLOCK_243\n\n<!-- end -->\n\n<!-- example for MVA value order -->\n\nПорядок чисел, вставляемых как значения многозначных атрибутов, не сохраняется. Значения хранятся внутренне в виде отсортированного множества.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_244\n\n<!-- response mysql -->\n\nCODE_BLOCK_245\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_246\n\n<!-- response JSON -->\n\nCODE_BLOCK_247\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_248\n\n<!-- response PHP -->\n\nCODE_BLOCK_249\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_250\n\n<!-- response Python -->\n\nCODE_BLOCK_251\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_252\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_253\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_254\n\n<!-- response javascript -->\n\nCODE_BLOCK_255\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_256\n\n<!-- response java -->\n\nCODE_BLOCK_257\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_258\n\n<!-- response C# -->\n\nCODE_BLOCK_259\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_260\n\n<!-- response Rust -->\n\nCODE_BLOCK_261\n\n<!-- end -->\n\n## Многозначное большое целое число\n\n<!-- example for creating MVA64 -->\n\nТип данных, позволяющий хранить списки переменной длины из 64-битных знаковых целых чисел. Имеет ту же функциональность, что и многозначное целое число.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_262\n\nили\n\nCODE_BLOCK_263\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_264\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_265\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_266\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_267\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_268\n\n<!-- intro -->\n\n##### java:\n\n<!-- request java -->\n\nCODE_BLOCK_269\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_270\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_271\n\n<!-- intro -->\n\n##### config:\n\n<!-- request config -->\n\nCODE_BLOCK_272\n\n<!-- end -->\n\n## Свойства колонно-ориентированных атрибутов\n\nПри использовании колоночного хранения для атрибутов можно задать следующие свойства.\n\n<!-- example fast_fetch -->\n\n### fast_fetch\n\nПо умолчанию Manticore Columnar хранит все атрибуты и в колонно-ориентированном формате, и в специальном docstore построчно. Это обеспечивает быструю обработку запросов типа `SELECT * FROM ...`, особенно при выборке большого количества записей за один раз. Однако, если вы уверены, что это не нужно или хотите сэкономить пространство на диске, вы можете отключить данную возможность, указав `fast_fetch='0'` при создании таблицы или (если таблица определяется в конфиге) используя `columnar_no_fast_fetch`, как показано в следующем примере.\n\n<!-- request RT mode -->\n\nCODE_BLOCK_273\n\n<!-- response RT mode -->\n\nCODE_BLOCK_274\n\n<!-- request Plain mode -->\n\nCODE_BLOCK_275\n\n<!-- response Plain mode -->\n\nCODE_BLOCK_276\n\n<!-- end -->"
    },
    "is_code_or_comment": false
  }
}
