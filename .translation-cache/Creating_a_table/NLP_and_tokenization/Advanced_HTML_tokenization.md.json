{
  "71172f28c10d63c793a47917d0e33acd95bab4121ecf9b4f86a5a1b537857fe3": {
    "original": "    * When followed by a letter. This is considered part of an abbreviation (e.g. \"S.T.A.L.K.E.R.\" or \"Goldman Sachs S.p.A.\").\n\n    * When followed by a comma. This is considered an abbreviation followed by a comma (e.g. \"Telecom Italia S.p.A., founded in 1994\").\n\n    * When followed by a space and a lowercase letter. This is considered an abbreviation within a sentence (e.g. \"News Corp. announced in February\").\n\n    * When preceded by a space and an uppercase letter, and followed by a space. This is considered a middle initial (e.g. \"John D. Doe\").\n\nParagraph boundaries are detected at every block-level HTML tag, including: ADDRESS, BLOCKQUOTE, CAPTION, CENTER, DD, DIV, DL, DT, H1, H2, H3, H4, H5, LI, MENU, OL, P, PRE, TABLE, TBODY, TD, TFOOT, TH, THEAD, TR, and UL.\n\nBoth sentences and paragraphs increment the keyword position counter by 1.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_34\n\n<!-- request JSON -->\n\nCODE_BLOCK_35\n\n<!-- request PHP -->\n\nCODE_BLOCK_36\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_37\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_38\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_39\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_40\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_41\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_42\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n### index_zones\n\n<!-- example index_zones -->\n\nCODE_BLOCK_44\n\nA list of HTML/XML zones within a field to be indexed. The default is an empty string (no zones will be indexed).\n\nA \"zone\" is defined as everything between an opening and a matching closing tag, and all spans sharing the same tag name are referred to as a \"zone.\" For example, everything between `<H1>` and `</H1>` in a document field belongs to the H1 zone.\n\nThe `index_zones` directive enables zone indexing, but the HTML [stripper](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#html_strip) must also be enabled (by setting `html_strip = 1`). The value of `index_zones` should be a comma-separated list of tag names and wildcards (ending with a star) to be indexed as zones.\n\nZones can be nested and overlap, as long as every opening tag has a matching tag. Zones can also be used for matching with the ZONE operator, as described in the [extended_query_syntax](../../Searching/Full_text_matching/Operators.md#ZONE-limit-operator).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_45\n\n<!-- request JSON -->\n\nCODE_BLOCK_46\n\n<!-- request PHP -->\n\nCODE_BLOCK_47\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_48\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_49\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_50\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_51\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_52\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_53\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_54\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "    * 当后面跟着一个字母时。这被视为缩写的一部分（例如 \"S.T.A.L.K.E.R.\" 或 \"Goldman Sachs S.p.A.\"）。\n\n    * 当后面跟着一个逗号时。这被视为缩写后跟逗号（例如 \"Telecom Italia S.p.A., founded in 1994\"）。\n\n    * 当后面跟着一个空格和一个小写字母时。这被视为句子中的缩写（例如 \"News Corp. announced in February\"）。\n\n    * 当前面跟着一个空格和一个大写字母，且后面跟着一个空格时。这被视为中间名的首字母（例如 \"John D. Doe\"）。\n\n段落边界在每个块级 HTML 标签处检测，包括：ADDRESS、BLOCKQUOTE、CAPTION、CENTER、DD、DIV、DL、DT、H1、H2、H3、H4、H5、LI、MENU、OL、P、PRE、TABLE、TBODY、TD、TFOOT、TH、THEAD、TR 和 UL。\n\n句子和段落都会使关键字位置计数器增加 1。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_34\n\n<!-- request JSON -->\n\nCODE_BLOCK_35\n\n<!-- request PHP -->\n\nCODE_BLOCK_36\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_37\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_38\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_39\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_40\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_41\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_42\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n### index_zones\n\n<!-- example index_zones -->\n\nCODE_BLOCK_44\n\n字段内要索引的 HTML/XML 区域列表。默认值为空字符串（不索引任何区域）。\n\n“区域”定义为开标签和匹配的闭标签之间的所有内容，所有共享相同标签名称的跨度都称为一个“区域”。例如，文档字段中 `<H1>` 和 `</H1>` 之间的所有内容属于 H1 区域。\n\n`index_zones` 指令启用区域索引，但必须同时启用 HTML [剥离器](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#html_strip)（通过设置 `html_strip = 1`）。`index_zones` 的值应为以逗号分隔的标签名称和通配符（以星号结尾）的列表，用于作为区域索引。\n\n区域可以嵌套和重叠，只要每个开标签都有匹配的闭标签。区域也可以用于使用 ZONE 操作符进行匹配，如 [extended_query_syntax](../../Searching/Full_text_matching/Operators.md#ZONE-limit-operator) 中所述。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_45\n\n<!-- request JSON -->\n\nCODE_BLOCK_46\n\n<!-- request PHP -->\n\nCODE_BLOCK_47\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_48\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_49\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_50\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_51\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_52\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_53\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_54\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "    * Когда за ним следует буква. Это считается частью аббревиатуры (например, \"S.T.A.L.K.E.R.\" или \"Goldman Sachs S.p.A.\").\n\n    * Когда за ним следует запятая. Это считается аббревиатурой, за которой следует запятая (например, \"Telecom Italia S.p.A., основанная в 1994 году\").\n\n    * Когда за ним следует пробел и строчная буква. Это считается аббревиатурой внутри предложения (например, \"News Corp. объявила в феврале\").\n\n    * Когда перед ним стоит пробел и заглавная буква, а после него пробел. Это считается инициалом среднего имени (например, \"John D. Doe\").\n\nГраницы абзацев определяются на каждом блочном HTML-теге, включая: ADDRESS, BLOCKQUOTE, CAPTION, CENTER, DD, DIV, DL, DT, H1, H2, H3, H4, H5, LI, MENU, OL, P, PRE, TABLE, TBODY, TD, TFOOT, TH, THEAD, TR и UL.\n\nИ предложения, и абзацы увеличивают счетчик позиции ключевого слова на 1.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_34\n\n<!-- request JSON -->\n\nCODE_BLOCK_35\n\n<!-- request PHP -->\n\nCODE_BLOCK_36\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_37\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_38\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_39\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_40\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_41\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_42\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n### index_zones\n\n<!-- example index_zones -->\n\nCODE_BLOCK_44\n\nСписок HTML/XML зон внутри поля для индексирования. По умолчанию это пустая строка (зоны не будут индексироваться).\n\n«Зона» определяется как все, что находится между открывающим и соответствующим закрывающим тегом, и все спаны с одинаковым именем тега называются «зоной». Например, все, что находится между `<H1>` и `</H1>` в поле документа, принадлежит зоне H1.\n\nДиректива `index_zones` включает индексирование зон, но HTML [stripper](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#html_strip) также должен быть включен (установкой `html_strip = 1`). Значение `index_zones` должно быть списком через запятую имен тегов и подстановочных знаков (заканчивающихся звездочкой), которые будут индексироваться как зоны.\n\nЗоны могут быть вложенными и перекрываться, при условии, что каждый открывающий тег имеет соответствующий закрывающий тег. Зоны также могут использоваться для сопоставления с оператором ZONE, как описано в [extended_query_syntax](../../Searching/Full_text_matching/Operators.md#ZONE-limit-operator).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_45\n\n<!-- request JSON -->\n\nCODE_BLOCK_46\n\n<!-- request PHP -->\n\nCODE_BLOCK_47\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_48\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_49\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_50\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_51\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_52\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_53\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_54\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "5558c53627951c92d8bd49b393582615df4f88f3cbf56ca32b515a40e8475f39": {
    "original": "# Advanced HTML tokenization\n\n## Stripping HTML tags\n\n### html_strip\n\n<!-- example html_strip -->\n\nCODE_BLOCK_0\n\nThis option determines whether HTML markup should be stripped from the incoming full-text data. The default value is 0, which disables stripping. To enable stripping, set the value to 1.\n\nHTML tags and entities are considered as markup and will be processed.\n\nHTML tags are removed, while the contents between them (e.g. everything between `<p>` and `</p>`) are left intact. You can choose to keep and index tag attributes (e.g. HREF attribute in an A tag or ALT in an IMG tag). Some well-known inline tags, such as A, B, I, S, U, BASEFONT, BIG, EM, FONT, IMG, LABEL, SMALL, SPAN, STRIKE, STRONG, SUB, SUP, and TT, are completely removed. All other tags are treated as block level and are replaced with whitespace. For example, the text `te<b>st</b>` will be indexed as a single keyword 'test', while `te<p>st</p>` will be indexed as two keywords 'te' and 'st'.\n\nHTML entities are decoded and replaced with their corresponding UTF-8 characters. The stripper supports both numeric forms (e.g. `&#239;`) and text forms (e.g. `&oacute;` or `&nbsp;`) of entities, and supports all entities specified by the HTML4 standard.\n\nThe stripper is designed to work with properly formed HTML and XHTML, but may produce unexpected results on malformed input (such as HTML with stray `<'s` or unclosed `>'s`).\n\nPlease note that only the tags themselves, as well as HTML comments, are stripped. To strip the contents of the tags, including embedded scripts, see the [html_remove_elements](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#html_remove_elements) option. There are no restrictions on tag names, meaning that everything that looks like a valid tag start, end, or comment will be stripped.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- request JSON -->\n\nCODE_BLOCK_2\n\n<!-- request PHP -->\n\nCODE_BLOCK_3\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_5\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_7\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_9\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n### html_index_attrs\n\n<!-- example html_index_attrs -->\n\nCODE_BLOCK_11\n\nThe html_index_attrs option allows you to specify which HTML markup attributes should be indexed even though other HTML markup is stripped. The default value is empty, meaning no attributes will be indexed.\n\nThe format of the option is a per-tag enumeration of indexable attributes, as demonstrated in the example above. The contents of the specified attributes will be retained and indexed, providing a way to extract additional information from your full-text data.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_12\n\n<!-- request JSON -->\n\nCODE_BLOCK_13\n\n<!-- request PHP -->\n\nCODE_BLOCK_14\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_16\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_17\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_18\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_19\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_20\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_21\n\n<!-- end -->\n\n### html_remove_elements\n\n<!-- example html_remove_elements -->\n\nCODE_BLOCK_22\n\nA list of HTML elements whose contents, along with the elements themselves, will be stripped. Optional, the default is an empty string (do not strip contents of any elements).\n\nThis option allows you to remove the contents of elements, meaning everything between the opening and closing tags. It is useful for removing embedded scripts, CSS, etc. The short tag form for empty elements (e.g. <br/>) is properly supported, and the text following such a tag will not be removed.\n\nThe value is a comma-separated list of element (tag) names, the contents of which should be removed. Tag names are case-insensitive.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_23\n\n<!-- request JSON -->\n\nCODE_BLOCK_24\n\n<!-- request PHP -->\n\nCODE_BLOCK_25\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_26\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_27\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_28\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_29\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_30\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_31\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_32\n\n<!-- end -->\n\n## Extracting important parts from HTML\n\n### index_sp\n\n<!-- example index_sp -->\n\nCODE_BLOCK_33\n\nControls detection and indexing of sentence and paragraph boundaries. Optional, default is 0 (no detection or indexing).\n\nThis directive enables the detection and indexing of sentence and paragraph boundaries, making it possible for the [SENTENCE](../../Searching/Full_text_matching/Operators.md#SENTENCE-and-PARAGRAPH-operators)  and [PARAGRAPH](../../Searching/Full_text_matching/Operators.md#SENTENCE-and-PARAGRAPH-operators)  operators to work. Sentence boundary detection is based on plain text analysis, and only requires setting `index_sp = 1` to enable it. Paragraph detection, however, relies on HTML markup and occurs during the [HTML stripping process](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#html_strip). As such, to index paragraph boundaries, both the index_sp directive and the html_strip directive must be set to 1.\n\nThe following rules are used to determine sentence boundaries:\n\n* Question marks (?) and exclamation marks (!) always indicate a sentence boundary.\n\n* Trailing dots (.) indicate a sentence boundary, except in the following cases:",
    "translations": {
      "chinese": "# 高级 HTML 分词\n\n## 去除 HTML 标签\n\n### html_strip\n\n<!-- example html_strip -->\n\nCODE_BLOCK_0\n\n此选项决定是否应从传入的全文数据中去除 HTML 标记。默认值为 0，表示禁用去除。要启用去除，请将值设置为 1。\n\nHTML 标签和实体被视为标记并将被处理。\n\nHTML 标签会被移除，而它们之间的内容（例如 `<p>` 和 `</p>` 之间的所有内容）则保持不变。您可以选择保留并索引标签属性（例如 A 标签中的 HREF 属性或 IMG 标签中的 ALT 属性）。一些知名的内联标签，如 A、B、I、S、U、BASEFONT、BIG、EM、FONT、IMG、LABEL、SMALL、SPAN、STRIKE、STRONG、SUB、SUP 和 TT，会被完全移除。所有其他标签被视为块级标签，并被替换为空白。例如，文本 `te<b>st</b>` 会被索引为单个关键词 'test'，而 `te<p>st</p>` 会被索引为两个关键词 'te' 和 'st'。\n\nHTML 实体会被解码并替换为对应的 UTF-8 字符。去除器支持数字形式的实体（例如 `&#239;`）和文本形式的实体（例如 `&oacute;` 或 `&nbsp;`），并支持 HTML4 标准指定的所有实体。\n\n该去除器设计用于处理格式正确的 HTML 和 XHTML，但在处理格式错误的输入（如带有多余的 `<` 或未闭合的 `>` 的 HTML）时可能产生意外结果。\n\n请注意，只有标签本身以及 HTML 注释会被去除。要去除标签内容，包括嵌入的脚本，请参见 [html_remove_elements](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#html_remove_elements) 选项。标签名称没有限制，意味着所有看起来像有效标签开始、结束或注释的内容都会被去除。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- request JSON -->\n\nCODE_BLOCK_2\n\n<!-- request PHP -->\n\nCODE_BLOCK_3\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_5\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_7\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_9\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n### html_index_attrs\n\n<!-- example html_index_attrs -->\n\nCODE_BLOCK_11\n\nhtml_index_attrs 选项允许您指定即使其他 HTML 标记被去除，也应被索引的 HTML 标记属性。默认值为空，表示不索引任何属性。\n\n该选项的格式是按标签列举可索引属性，如上例所示。指定属性的内容将被保留并索引，提供了一种从全文数据中提取额外信息的方法。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_12\n\n<!-- request JSON -->\n\nCODE_BLOCK_13\n\n<!-- request PHP -->\n\nCODE_BLOCK_14\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_16\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_17\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_18\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_19\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_20\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_21\n\n<!-- end -->\n\n### html_remove_elements\n\n<!-- example html_remove_elements -->\n\nCODE_BLOCK_22\n\n一个 HTML 元素列表，其内容及元素本身将被去除。可选，默认值为空字符串（不去除任何元素内容）。\n\n此选项允许您去除元素的内容，即开闭标签之间的所有内容。它对于去除嵌入的脚本、CSS 等非常有用。空元素的短标签形式（例如 <br/>）被正确支持，且该标签之后的文本不会被去除。\n\n该值是以逗号分隔的元素（标签）名称列表，指定应去除其内容。标签名称不区分大小写。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_23\n\n<!-- request JSON -->\n\nCODE_BLOCK_24\n\n<!-- request PHP -->\n\nCODE_BLOCK_25\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_26\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_27\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_28\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_29\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_30\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_31\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_32\n\n<!-- end -->\n\n## 从 HTML 中提取重要部分\n\n### index_sp\n\n<!-- example index_sp -->\n\nCODE_BLOCK_33\n\n控制句子和段落边界的检测和索引。可选，默认值为 0（不检测也不索引）。\n\n此指令启用句子和段落边界的检测和索引，使得 [SENTENCE](../../Searching/Full_text_matching/Operators.md#SENTENCE-and-PARAGRAPH-operators) 和 [PARAGRAPH](../../Searching/Full_text_matching/Operators.md#SENTENCE-and-PARAGRAPH-operators) 操作符能够工作。句子边界检测基于纯文本分析，只需设置 `index_sp = 1` 即可启用。段落检测则依赖于 HTML 标记，并在 [HTML 去除过程](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#html_strip) 中进行。因此，要索引段落边界，必须同时将 index_sp 指令和 html_strip 指令设置为 1。\n\n以下规则用于确定句子边界：\n\n* 问号 (?) 和感叹号 (!) 总是表示句子边界。\n\n* 句末点号 (.) 表示句子边界，除以下情况外：",
      "russian": "# Расширенная токенизация HTML\n\n## Удаление HTML-тегов\n\n### html_strip\n\n<!-- example html_strip -->\n\nCODE_BLOCK_0\n\nЭтот параметр определяет, следует ли удалять HTML-разметку из входных полнотекстовых данных. Значение по умолчанию — 0, что отключает удаление. Чтобы включить удаление, установите значение в 1.\n\nHTML-теги и сущности считаются разметкой и будут обработаны.\n\nHTML-теги удаляются, а содержимое между ними (например, всё между `<p>` и `</p>`) остаётся нетронутым. Вы можете выбрать сохранение и индексирование атрибутов тегов (например, атрибут HREF в теге A или ALT в теге IMG). Некоторые известные встроенные теги, такие как A, B, I, S, U, BASEFONT, BIG, EM, FONT, IMG, LABEL, SMALL, SPAN, STRIKE, STRONG, SUB, SUP и TT, полностью удаляются. Все остальные теги считаются блочными и заменяются пробелом. Например, текст `te<b>st</b>` будет индексироваться как одно ключевое слово 'test', а `te<p>st</p>` — как два ключевых слова 'te' и 'st'.\n\nHTML-сущности декодируются и заменяются соответствующими символами UTF-8. Удалитель поддерживает как числовые формы (например, `&#239;`), так и текстовые формы (например, `&oacute;` или `&nbsp;`) сущностей, а также все сущности, указанные в стандарте HTML4.\n\nУдалитель предназначен для работы с корректно сформированным HTML и XHTML, но может давать неожиданные результаты при некорректном вводе (например, HTML с лишними символами `<` или незакрытыми `>`).\n\nОбратите внимание, что удаляются только сами теги и HTML-комментарии. Чтобы удалить содержимое тегов, включая встроенные скрипты, смотрите опцию [html_remove_elements](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#html_remove_elements). Нет ограничений на имена тегов, то есть всё, что выглядит как корректное начало, конец или комментарий тега, будет удалено.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- request JSON -->\n\nCODE_BLOCK_2\n\n<!-- request PHP -->\n\nCODE_BLOCK_3\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_5\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_7\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_9\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n### html_index_attrs\n\n<!-- example html_index_attrs -->\n\nCODE_BLOCK_11\n\nОпция html_index_attrs позволяет указать, какие атрибуты HTML-разметки должны индексироваться, даже если остальная HTML-разметка удаляется. Значение по умолчанию — пустая строка, что означает, что атрибуты не индексируются.\n\nФормат опции — перечисление индексируемых атрибутов для каждого тега, как показано в примере выше. Содержимое указанных атрибутов сохраняется и индексируется, что позволяет извлекать дополнительную информацию из полнотекстовых данных.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_12\n\n<!-- request JSON -->\n\nCODE_BLOCK_13\n\n<!-- request PHP -->\n\nCODE_BLOCK_14\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_16\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_17\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_18\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_19\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_20\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_21\n\n<!-- end -->\n\n### html_remove_elements\n\n<!-- example html_remove_elements -->\n\nCODE_BLOCK_22\n\nСписок HTML-элементов, содержимое которых вместе с самими элементами будет удалено. Необязательно, значение по умолчанию — пустая строка (не удалять содержимое ни одного элемента).\n\nЭта опция позволяет удалять содержимое элементов, то есть всё между открывающим и закрывающим тегами. Это полезно для удаления встроенных скриптов, CSS и т. п. Короткая форма тега для пустых элементов (например, <br/>) поддерживается корректно, и текст после такого тега удалён не будет.\n\nЗначение — список имён элементов (тегов), разделённых запятыми, содержимое которых следует удалить. Имена тегов не чувствительны к регистру.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_23\n\n<!-- request JSON -->\n\nCODE_BLOCK_24\n\n<!-- request PHP -->\n\nCODE_BLOCK_25\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_26\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_27\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_28\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_29\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_30\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_31\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_32\n\n<!-- end -->\n\n## Извлечение важных частей из HTML\n\n### index_sp\n\n<!-- example index_sp -->\n\nCODE_BLOCK_33\n\nУправляет обнаружением и индексированием границ предложений и абзацев. Необязательно, значение по умолчанию — 0 (обнаружение и индексирование отключены).\n\nЭта директива включает обнаружение и индексирование границ предложений и абзацев, что позволяет работать операторам [SENTENCE](../../Searching/Full_text_matching/Operators.md#SENTENCE-and-PARAGRAPH-operators) и [PARAGRAPH](../../Searching/Full_text_matching/Operators.md#SENTENCE-and-PARAGRAPH-operators). Обнаружение границ предложений основано на анализе простого текста и требует только установки `index_sp = 1` для включения. Обнаружение абзацев, однако, опирается на HTML-разметку и происходит во время [процесса удаления HTML](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#html_strip). Поэтому для индексирования границ абзацев обе директивы — index_sp и html_strip — должны быть установлены в 1.\n\nДля определения границ предложений используются следующие правила:\n\n* Вопросительные знаки (?) и восклицательные знаки (!) всегда указывают на границу предложения.\n\n* Заканчивающиеся точки (.) указывают на границу предложения, за исключением следующих случаев:"
    },
    "is_code_or_comment": false
  }
}
