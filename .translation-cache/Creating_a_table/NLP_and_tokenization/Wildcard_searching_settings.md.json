{
  "3d7e62566b9a23d19e8e908a9e92471a3d9e49479b4df7ab3802cec78867ffda": {
    "original": "This directive does not affect [indexer](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#Indexer-tool) in any way, it only affects [searchd](../../Starting_the_server/Manually.md).\n\n## expansion_limit\n\nCODE_BLOCK_41\n\nMaximum number of expanded keywords for a single wildcard. Details are [here](../../Server_settings/Searchd.md#expansion_limit).\n\n<!-- proofread -->",
    "translations": {
      "chinese": "该指令不会以任何方式影响[indexer](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#Indexer-tool)，它只影响[searchd](../../Starting_the_server/Manually.md)。\n\n## expansion_limit\n\nCODE_BLOCK_41\n\n单个通配符的最大扩展关键字数。详细信息见[这里](../../Server_settings/Searchd.md#expansion_limit)。\n\n<!-- proofread -->",
      "russian": "This directive does not affect [indexer](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#Indexer-tool) in any way, it only affects [searchd](../../Starting_the_server/Manually.md).\n\n## expansion_limit\n\nCODE_BLOCK_41\n\nМаксимальное количество расширенных ключевых слов для одного шаблона с подстановочными знаками. Подробнее [здесь](../../Server_settings/Searchd.md#expansion_limit).\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "77e08b9bf3402710166faf1eb4cf1ad399656cab6a27238df7cb82247c010d1b": {
    "original": "##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_18\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_19\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_20\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_21\n\n<!-- end -->\n\n## prefix_fields\n\n<!-- example prefix_fields -->\n\nCODE_BLOCK_22\n\nThe prefix_fields setting is used to limit prefix indexing to specific full-text fields in [dict=crc](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict) mode. By default, all fields are indexed in prefix mode, but because prefix indexing can affect both indexing and searching performance, it may be desired to limit it to certain fields.\n\nTo limit prefix indexing to specific fields, use the prefix_fields setting followed by a comma-separated list of field names. If prefix_fields is not set, then all fields will be indexed in prefix mode.\n\n<!-- intro -->\n\n##### CONFIG:\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_23\n\n<!-- end -->\n\n## infix_fields\n\n<!-- example infix_fields -->\n\nCODE_BLOCK_24\n\nThe infix_fields setting allows you to specify a list of full-text fields to limit infix indexing to. This applies to [dict=crc](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict) only and is optional, with the default being to index all fields in infix mode.\n\nThis setting is similar to [prefix_fields](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict), but instead allows you to limit infix indexing to specific fields.\n\n<!-- intro -->\n\n##### CONFIG:\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_25\n\n<!-- end -->\n\n## max_substring_len\n\n<!-- example max_substring_len -->\n\nCODE_BLOCK_26\n\nThe max_substring_len directive sets the maximum substring length to be indexed for either prefix or infix searches. This setting is optional, and its default value is 0 (which means that all possible substrings are indexed). It only applies to [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict).\n\nBy default, substring indexing in [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict) indexes  **all** possible substrings as separate keywords, which can result in an overly large full-text index. Therefore, the max_substring_len directive allows you to skip too-long substrings that will probably never be searched for.\n\nFor example, a test table of 10,000 blog posts takes up a different amount of disk space depending on the settings:\n\n* 6.4 MB baseline (no substrings)\n\n* 24.3 MB (3.8x) with min_prefix_len = 3\n\n* 22.2 MB (3.5x) with min_prefix_len = 3, max_substring_len = 8\n\n* 19.3 MB (3.0x) with min_prefix_len = 3, max_substring_len = 6\n\n* 94.3 MB (14.7x) with min_infix_len = 3\n\n* 84.6 MB (13.2x) with min_infix_len = 3, max_substring_len = 8\n\n* 70.7 MB (11.0x) with min_infix_len = 3, max_substring_len = 6\n\nTherefore, limiting the max substring length can save 10-15% of the table size.\n\nWhen using dict=keywords mode, there is no performance impact associated with substring length. Therefore, this directive is not applicable and is intentionally forbidden in that case. However, if required, you can still limit the length of a substring that you search for in the application code.\n\n<!-- intro -->\n\n##### CONFIG:\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_27\n\n<!-- end -->\n\n## expand_keywords\n\n<!-- example expand_keywords -->\n\nCODE_BLOCK_28\n\nThis setting expands keywords with their exact forms and/or with stars when possible. The supported values are:\n\n* 1 -  expand to both the exact form and the form with the stars. For instance,`running` will become `(running | *running* | =running)`\n\n* `exact` - - augment the keyword with only its exact form. For instance, `running` will become `(running | =running)`\n\n* `star` - augment the keyword by adding `*` around it. For instance, `running` will become `(running | *running*)`\n\nThis setting is optional, and the default value is 0 (keywords are not expanded).\n\nQueries against tables with `expand_keywords` feature enabled are internally expanded as follows: if the table was built with prefix or infix indexing enabled, every keyword gets internally replaced with a disjunction of the keyword itself and a respective prefix or infix (keyword with stars). If the table was built with both stemming and [index_exact_words](../../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words) enabled, exact form is also added.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_29\n\n<!-- request JSON -->\n\nCODE_BLOCK_30\n\n<!-- request PHP -->\n\nCODE_BLOCK_31\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_32\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_33\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_34\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_35\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_36\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_37\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_38\n\n<!-- end -->\n\n<!-- example expand_keywords2 -->\n\nExpanded queries take naturally longer to complete, but can possibly improve the search quality, as the documents with exact form matches should be ranked generally higher than documents with stemmed or infix matches.\n\n**Note that the existing query syntax does not allow to emulate this kind of expansion**, because internal expansion works on keyword level and expands keywords within phrase or quorum operators too (which is not possible through the query syntax). Take a look at the examples and how expand_keywords affects the search result weights and how \"runsy\" is found by \"runs\" w/o the need to add a star:\n\n<!-- intro -->\n\n##### expand_keywords is enabled\n\n<!-- request expand_keywords_enabled -->\n\nCODE_BLOCK_39\n\n<!-- intro -->\n\n##### expand_keywords is disabled\n\n<!-- request expand_keywords_disabled -->\n\nCODE_BLOCK_40\n\n<!-- end -->",
    "translations": {
      "chinese": "##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_18\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_19\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_20\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_21\n\n<!-- end -->\n\n## prefix_fields\n\n<!-- example prefix_fields -->\n\nCODE_BLOCK_22\n\nprefix_fields 设置用于限制前缀索引仅应用于 [dict=crc](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict) 模式下的特定全文字段。默认情况下，所有字段都会以前缀模式进行索引，但由于前缀索引可能影响索引和搜索性能，因此可能希望将其限制在某些字段上。\n\n要将前缀索引限制为特定字段，请使用 prefix_fields 设置，后跟以逗号分隔的字段名称列表。如果未设置 prefix_fields，则所有字段都将在前缀模式下进行索引。\n\n<!-- intro -->\n\n##### CONFIG:\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_23\n\n<!-- end -->\n\n## infix_fields\n\n<!-- example infix_fields -->\n\nCODE_BLOCK_24\n\ninfix_fields 设置允许您指定一个全文字段列表，以限制中缀索引的应用范围。这仅适用于 [dict=crc](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict) 模式，且是可选的，默认情况下所有字段都以中缀模式进行索引。\n\n此设置类似于 [prefix_fields](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)，但它允许您将中缀索引限制在特定字段上。\n\n<!-- intro -->\n\n##### CONFIG:\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_25\n\n<!-- end -->\n\n## max_substring_len\n\n<!-- example max_substring_len -->\n\nCODE_BLOCK_26\n\nmax_substring_len 指令设置要为前缀或中缀搜索索引的最大子字符串长度。此设置是可选的，默认值为 0（表示索引所有可能的子字符串）。它仅适用于 [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)。\n\n默认情况下，[dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict) 中的子字符串索引会将 **所有** 可能的子字符串作为单独的关键字进行索引，这可能导致全文索引过大。因此，max_substring_len 指令允许您跳过过长且可能永远不会被搜索的子字符串。\n\n例如，一个包含 10,000 篇博客文章的测试表根据设置占用不同的磁盘空间：\n\n* 6.4 MB 基线（无子字符串）\n\n* 24.3 MB（3.8 倍）使用 min_prefix_len = 3\n\n* 22.2 MB（3.5 倍）使用 min_prefix_len = 3，max_substring_len = 8\n\n* 19.3 MB（3.0 倍）使用 min_prefix_len = 3，max_substring_len = 6\n\n* 94.3 MB（14.7 倍）使用 min_infix_len = 3\n\n* 84.6 MB（13.2 倍）使用 min_infix_len = 3，max_substring_len = 8\n\n* 70.7 MB（11.0 倍）使用 min_infix_len = 3，max_substring_len = 6\n\n因此，限制最大子字符串长度可以节省 10-15% 的表大小。\n\n在使用 dict=keywords 模式时，子字符串长度不会影响性能。因此，该指令不适用且在这种情况下被故意禁止。不过，如果需要，您仍然可以在应用代码中限制搜索子字符串的长度。\n\n<!-- intro -->\n\n##### CONFIG:\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_27\n\n<!-- end -->\n\n## expand_keywords\n\n<!-- example expand_keywords -->\n\nCODE_BLOCK_28\n\n此设置在可能的情况下扩展关键字为其精确形式和/或带星号的形式。支持的值有：\n\n* 1 - 同时扩展为精确形式和带星号的形式。例如，`running` 将变为 `(running | *running* | =running)`\n\n* `exact` - 仅用其精确形式扩展关键字。例如，`running` 将变为 `(running | =running)`\n\n* `star` - 通过在关键字周围添加 `*` 来扩展关键字。例如，`running` 将变为 `(running | *running*)`\n\n此设置是可选的，默认值为 0（不扩展关键字）。\n\n启用 `expand_keywords` 功能的表的查询会在内部进行如下扩展：如果表启用了前缀或中缀索引，则每个关键字都会被内部替换为关键字本身与相应的前缀或中缀（带星号的关键字）的析取。如果表同时启用了词干提取和 [index_exact_words](../../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words)，还会添加精确形式。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_29\n\n<!-- request JSON -->\n\nCODE_BLOCK_30\n\n<!-- request PHP -->\n\nCODE_BLOCK_31\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_32\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_33\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_34\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_35\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_36\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_37\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_38\n\n<!-- end -->\n\n<!-- example expand_keywords2 -->\n\n扩展后的查询自然需要更长时间完成，但可能提升搜索质量，因为精确形式匹配的文档通常应比词干或中缀匹配的文档排名更高。\n\n**注意，现有的查询语法不允许模拟这种扩展**，因为内部扩展是在关键字级别进行的，并且会扩展短语或仲裁操作符内的关键字（这是查询语法无法实现的）。请查看示例，了解 expand_keywords 如何影响搜索结果权重，以及如何在不添加星号的情况下通过 \"runs\" 找到 \"runsy\"：\n\n<!-- intro -->\n\n##### 启用 expand_keywords\n\n<!-- request expand_keywords_enabled -->\n\nCODE_BLOCK_39\n\n<!-- intro -->\n\n##### 禁用 expand_keywords\n\n<!-- request expand_keywords_disabled -->\n\nCODE_BLOCK_40\n\n<!-- end -->",
      "russian": "##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_18\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_19\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_20\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_21\n\n<!-- end -->\n\n## prefix_fields\n\n<!-- example prefix_fields -->\n\nCODE_BLOCK_22\n\nНастройка prefix_fields используется для ограничения индексирования префиксов конкретными полнотекстовыми полями в режиме [dict=crc](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict). По умолчанию все поля индексируются в режиме префикса, но поскольку индексирование префиксов может влиять как на производительность индексирования, так и на поиск, может потребоваться ограничить его определёнными полями.\n\nЧтобы ограничить индексирование префиксов конкретными полями, используйте настройку prefix_fields с последующим списком имён полей, разделённых запятыми. Если prefix_fields не задан, то все поля будут индексироваться в режиме префикса.\n\n<!-- intro -->\n\n##### CONFIG:\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_23\n\n<!-- end -->\n\n## infix_fields\n\n<!-- example infix_fields -->\n\nCODE_BLOCK_24\n\nНастройка infix_fields позволяет указать список полнотекстовых полей, для которых будет ограничено индексирование инфиксов. Это применяется только к режиму [dict=crc](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict) и является необязательным, по умолчанию индексируются все поля в режиме инфикса.\n\nЭта настройка похожа на [prefix_fields](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict), но позволяет ограничить индексирование инфиксов конкретными полями.\n\n<!-- intro -->\n\n##### CONFIG:\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_25\n\n<!-- end -->\n\n## max_substring_len\n\n<!-- example max_substring_len -->\n\nCODE_BLOCK_26\n\nДиректива max_substring_len задаёт максимальную длину подстроки, которая будет индексироваться для поиска по префиксу или инфиксу. Эта настройка необязательна, и её значение по умолчанию равно 0 (что означает, что индексируются все возможные подстроки). Она применяется только к режиму [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict).\n\nПо умолчанию индексирование подстрок в режиме [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict) индексирует **все** возможные подстроки как отдельные ключевые слова, что может привести к чрезмерно большому полнотекстовому индексу. Поэтому директива max_substring_len позволяет пропускать слишком длинные подстроки, которые, вероятно, никогда не будут искаться.\n\nНапример, тестовая таблица из 10 000 блог-постов занимает разное количество дискового пространства в зависимости от настроек:\n\n* 6.4 МБ базовый уровень (без подстрок)\n\n* 24.3 МБ (3.8x) с min_prefix_len = 3\n\n* 22.2 МБ (3.5x) с min_prefix_len = 3, max_substring_len = 8\n\n* 19.3 МБ (3.0x) с min_prefix_len = 3, max_substring_len = 6\n\n* 94.3 МБ (14.7x) с min_infix_len = 3\n\n* 84.6 МБ (13.2x) с min_infix_len = 3, max_substring_len = 8\n\n* 70.7 МБ (11.0x) с min_infix_len = 3, max_substring_len = 6\n\nТаким образом, ограничение максимальной длины подстроки может сэкономить 10-15% размера таблицы.\n\nПри использовании режима dict=keywords влияние длины подстроки на производительность отсутствует. Поэтому эта директива не применяется и намеренно запрещена в этом случае. Однако при необходимости вы всё равно можете ограничить длину подстроки, которую ищете, в коде приложения.\n\n<!-- intro -->\n\n##### CONFIG:\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_27\n\n<!-- end -->\n\n## expand_keywords\n\n<!-- example expand_keywords -->\n\nCODE_BLOCK_28\n\nЭта настройка расширяет ключевые слова их точными формами и/или со звёздочками, когда это возможно. Поддерживаемые значения:\n\n* 1 - расширять и точной формой, и формой со звёздочками. Например, `running` станет `(running | *running* | =running)`\n\n* `exact` - расширять ключевое слово только точной формой. Например, `running` станет `(running | =running)`\n\n* `star` - расширять ключевое слово, добавляя `*` вокруг него. Например, `running` станет `(running | *running*)`\n\nЭта настройка необязательна, значение по умолчанию — 0 (ключевые слова не расширяются).\n\nЗапросы к таблицам с включённой функцией `expand_keywords` внутренне расширяются следующим образом: если таблица была построена с включённым индексированием префиксов или инфиксов, каждое ключевое слово внутренне заменяется дизъюнкцией самого ключевого слова и соответствующего префикса или инфикса (ключевое слово со звёздочками). Если таблица была построена с включённым стеммингом и [index_exact_words](../../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words), также добавляется точная форма.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_29\n\n<!-- request JSON -->\n\nCODE_BLOCK_30\n\n<!-- request PHP -->\n\nCODE_BLOCK_31\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_32\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_33\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_34\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_35\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_36\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_37\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_38\n\n<!-- end -->\n\n<!-- example expand_keywords2 -->\n\nРасширенные запросы, естественно, выполняются дольше, но могут улучшить качество поиска, так как документы с точными совпадениями форм обычно ранжируются выше, чем документы с совпадениями по стеммам или инфиксам.\n\n**Обратите внимание, что существующий синтаксис запросов не позволяет эмулировать такое расширение**, поскольку внутреннее расширение работает на уровне ключевых слов и расширяет ключевые слова внутри операторов фраз и кворума тоже (что невозможно через синтаксис запросов). Посмотрите на примеры и как expand_keywords влияет на веса результатов поиска и как \"runsy\" находится по запросу \"runs\" без необходимости добавлять звёздочку:\n\n<!-- intro -->\n\n##### expand_keywords включён\n\n<!-- request expand_keywords_enabled -->\n\nCODE_BLOCK_39\n\n<!-- intro -->\n\n##### expand_keywords отключён\n\n<!-- request expand_keywords_disabled -->\n\nCODE_BLOCK_40\n\n<!-- end -->"
    },
    "is_code_or_comment": false
  },
  "8359c0be356ce397585be74e616bd5c8fd6f3c25edcbc6f7b539e0338b894f6e": {
    "original": "# Wildcard searching settings\n\nWildcard searching is a common text search type. In Manticore, it is performed at the dictionary level. By default, both plain and RT tables use a dictionary type called [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict). In this mode, words are stored as they are, so enabling wildcarding does not affect the size of the table. When a wildcard search is performed, the dictionary is searched to find all possible expansions of the wildcarded word. This expansion can be problematic in terms of computation at query time when the expanded word provides many expansions or expansions that have huge hitlists, especially in the case of infixes where the wildcard is added at the start and end of the word. To avoid such problems, the  [expansion_limit](../../Server_settings/Searchd.md#expansion_limit) can be used.\n\n## min_prefix_len\n\n<!-- example min_prefix_len -->\n\nCODE_BLOCK_0\n\nThis setting determines the minimum word prefix length to index and search. By default, it is set to 0, meaning prefixes are not allowed.\n\nPrefixes allow for wildcard searching by `wordstart*` wildcards.\n\nFor example, if the word \"example\" is indexed with min_prefix_len=3, it can be found by searching for \"exa\", \"exam\", \"examp\", \"exampl\", as well as the full word.\n\nNote that with [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=crc min_prefix_len will affect the size of the full-text index since each word expansion will be stored additionally.\n\nManticore can differentiate perfect word matches from prefix matches and rank the former higher if the following conditions are met:\n\n* [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=keywords (on by default)\n\n* [index_exact_words](../../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words)=1 (off by default),\n\n* [expand_keywords](../../Searching/Options.md#expand_keywords)=1 (also off by default)\n\nNote that with either  [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=crc mode or any of the above options disabled, it is not possible to differentiate between prefixes and full words, and perfect word matches cannot be ranked higher.\n\nWhen the [minimum infix length](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) is set to a positive number, the minimum prefix length is always considered 1.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- request JSON -->\n\nCODE_BLOCK_2\n\n<!-- request PHP -->\n\nCODE_BLOCK_3\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_5\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_7\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_9\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n## min_infix_len\n\n<!-- example min_infix_len -->\n\nCODE_BLOCK_11\n\nThe min_infix_len setting determines the minimum length of an infix prefix to index and search. It is optional and its default value is 0, which means that infixes are not allowed. The minimum allowed non-zero value is 2.\n\nWhen enabled, infixes allow for wildcard searching with term patterns like `start*`, `*end`, `*middle*`, , and so on. It also allows you to disable too short wildcards if they are too expensive to search for.\n\nIf the following conditions are met, Manticore can differentiate perfect word matches from infix matches and rank the former higher:\n\n* [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=keywords (on by default)\n\n* [index_exact_words](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=1 (off by default),\n\n* [expand_keywords](../../Searching/Options.md#expand_keywords)=1 (also off by default)\n\nNote that with the [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=crc mode or any of the above options disabled, there is no way to differentiate between infixes and full words, and thus perfect word matches cannot be ranked higher.\n\nInfix wildcard search query time can vary greatly, depending on how many keywords the substring will actually expand to. Short and frequent syllables like `*in*` or `*ti*` might expand to way too many keywords, all of which would need to be matched and processed. Therefore, to generally enable substring searches, you would set min_infix_len to 2. To limit the impact from wildcard searches with too short wildcards, you might set it higher.\n\nInfixes must be at least 2 characters long, and wildcards like `*a*` are not allowed for performance reasons.\n\nWhen min_infix_len is set to a positive number, the [minimum prefix length](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_prefix_len) is considered 1. For [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict) word infixing and prefixing cannot be both enabled at the same time. For [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict) and other fields to have prefixes declared with [prefix_fields](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#prefix_fields), it is forbidden to declare the same field in both lists.\n\nIf dict=keywords, besides the wildcard `*` two other wildcard characters can be used:\n\n* `?` can match any (one) character:  `t?st` will match `test`, but not `teast`\n\n* `%` can match zero or one character:  `tes%` will match `tes` or `test`, but not `testing`\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_12\n\n<!-- request JSON -->\n\nCODE_BLOCK_13\n\n<!-- request PHP -->\n\nCODE_BLOCK_14\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_16\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_17\n\n<!-- intro -->",
    "translations": {
      "chinese": "# 通配符搜索设置\n\n通配符搜索是一种常见的文本搜索类型。在 Manticore 中，它是在字典级别执行的。默认情况下，普通表和 RT 表都使用一种称为 [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict) 的字典类型。在此模式下，单词按原样存储，因此启用通配符不会影响表的大小。当执行通配符搜索时，会搜索字典以查找通配符单词的所有可能扩展。当扩展的单词提供许多扩展或扩展具有庞大命中列表时，尤其是在通配符添加在单词的开头和结尾的中缀情况下，这种扩展在查询时的计算可能会有问题。为避免此类问题，可以使用 [expansion_limit](../../Server_settings/Searchd.md#expansion_limit)。\n\n## min_prefix_len\n\n<!-- example min_prefix_len -->\n\nCODE_BLOCK_0\n\n此设置确定要索引和搜索的最小单词前缀长度。默认值为 0，表示不允许前缀。\n\n前缀允许通过 `wordstart*` 通配符进行通配符搜索。\n\n例如，如果单词 \"example\" 使用 min_prefix_len=3 进行索引，则可以通过搜索 \"exa\"、\"exam\"、\"examp\"、\"exampl\" 以及完整单词找到它。\n\n请注意，使用 [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=crc 时，min_prefix_len 会影响全文索引的大小，因为每个单词扩展都会额外存储。\n\n如果满足以下条件，Manticore 可以区分完全匹配的单词和前缀匹配，并将前者排名更高：\n\n* [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=keywords（默认开启）\n\n* [index_exact_words](../../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words)=1（默认关闭）\n\n* [expand_keywords](../../Searching/Options.md#expand_keywords)=1（也默认关闭）\n\n请注意，在 [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=crc 模式或上述任何选项禁用时，无法区分前缀和完整单词，且无法将完全匹配的单词排名更高。\n\n当 [minimum infix length](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) 设置为正数时，最小前缀长度始终视为 1。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- request JSON -->\n\nCODE_BLOCK_2\n\n<!-- request PHP -->\n\nCODE_BLOCK_3\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_5\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_7\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_9\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n## min_infix_len\n\n<!-- example min_infix_len -->\n\nCODE_BLOCK_11\n\nmin_infix_len 设置确定要索引和搜索的中缀前缀的最小长度。此设置是可选的，默认值为 0，表示不允许中缀。允许的最小非零值为 2。\n\n启用后，中缀允许使用类似 `start*`、`*end`、`*middle*` 等模式进行通配符搜索。它还允许您禁用过短的通配符，以防它们搜索成本过高。\n\n如果满足以下条件，Manticore 可以区分完全匹配的单词和中缀匹配，并将前者排名更高：\n\n* [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=keywords（默认开启）\n\n* [index_exact_words](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=1（默认关闭）\n\n* [expand_keywords](../../Searching/Options.md#expand_keywords)=1（也默认关闭）\n\n请注意，在 [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=crc 模式或上述任何选项禁用时，无法区分中缀和完整单词，因此无法将完全匹配的单词排名更高。\n\n中缀通配符搜索的查询时间可能变化很大，取决于子字符串实际扩展到多少关键字。像 `*in*` 或 `*ti*` 这样短且频繁的音节可能会扩展到过多关键字，所有这些都需要匹配和处理。因此，为了通常启用子字符串搜索，您可以将 min_infix_len 设置为 2。为了限制过短通配符搜索的影响，您可以将其设置得更高。\n\n中缀必须至少有 2 个字符长，出于性能原因，不允许使用像 `*a*` 这样的通配符。\n\n当 min_infix_len 设置为正数时，[最小前缀长度](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_prefix_len) 被视为 1。对于 [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)，单词中缀和前缀不能同时启用。对于 [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict) 和其他字段，如果使用了 [prefix_fields](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#prefix_fields) 声明了前缀，则禁止在两个列表中声明相同字段。\n\n如果 dict=keywords，除了通配符 `*` 外，还可以使用另外两个通配符字符：\n\n* `?` 可以匹配任意（一个）字符：`t?st` 将匹配 `test`，但不匹配 `teast`\n\n* `%` 可以匹配零个或一个字符：`tes%` 将匹配 `tes` 或 `test`，但不匹配 `testing`\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_12\n\n<!-- request JSON -->\n\nCODE_BLOCK_13\n\n<!-- request PHP -->\n\nCODE_BLOCK_14\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_16\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_17\n\n<!-- intro -->",
      "russian": "# Настройки поиска с подстановочными знаками\n\nПоиск с подстановочными знаками — это распространённый тип текстового поиска. В Manticore он выполняется на уровне словаря. По умолчанию как обычные, так и RT-таблицы используют тип словаря, называемый [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict). В этом режиме слова хранятся в исходном виде, поэтому включение подстановочных знаков не влияет на размер таблицы. При выполнении поиска с подстановочными знаками словарь просматривается для нахождения всех возможных расширений слова с подстановочными знаками. Такое расширение может быть проблематичным с точки зрения вычислений во время запроса, если расширенное слово даёт много вариантов или варианты с огромными списками попаданий, особенно в случае инфиксов, когда подстановочный знак добавляется в начало и конец слова. Чтобы избежать таких проблем, можно использовать [expansion_limit](../../Server_settings/Searchd.md#expansion_limit).\n\n## min_prefix_len\n\n<!-- example min_prefix_len -->\n\nCODE_BLOCK_0\n\nЭтот параметр определяет минимальную длину префикса слова для индексации и поиска. По умолчанию он установлен в 0, что означает, что префиксы не разрешены.\n\nПрефиксы позволяют выполнять поиск с подстановочными знаками вида `wordstart*`.\n\nНапример, если слово \"example\" индексируется с min_prefix_len=3, его можно найти, выполнив поиск по \"exa\", \"exam\", \"examp\", \"exampl\", а также по полному слову.\n\nОбратите внимание, что при использовании [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=crc min_prefix_len повлияет на размер полнотекстового индекса, так как каждое расширение слова будет храниться дополнительно.\n\nManticore может различать точные совпадения слов и совпадения по префиксу и ранжировать первые выше, если выполнены следующие условия:\n\n* [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=keywords (включено по умолчанию)\n\n* [index_exact_words](../../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words)=1 (выключено по умолчанию),\n\n* [expand_keywords](../../Searching/Options.md#expand_keywords)=1 (также выключено по умолчанию)\n\nОбратите внимание, что при использовании режима [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=crc или при отключении любого из вышеуказанных параметров невозможно различать префиксы и полные слова, и точные совпадения слов не могут быть ранжированы выше.\n\nКогда [минимальная длина инфикса](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) установлена в положительное число, минимальная длина префикса всегда считается равной 1.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- request JSON -->\n\nCODE_BLOCK_2\n\n<!-- request PHP -->\n\nCODE_BLOCK_3\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_5\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_7\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_9\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n## min_infix_len\n\n<!-- example min_infix_len -->\n\nCODE_BLOCK_11\n\nПараметр min_infix_len определяет минимальную длину префикса инфикса для индексации и поиска. Он является необязательным, и его значение по умолчанию равно 0, что означает, что инфиксы не разрешены. Минимально допустимое ненулевое значение — 2.\n\nПри включении инфиксы позволяют выполнять поиск с подстановочными знаками с шаблонами терминов, такими как `start*`, `*end`, `*middle*` и так далее. Это также позволяет отключить слишком короткие подстановочные знаки, если их поиск слишком затратен.\n\nЕсли выполнены следующие условия, Manticore может различать точные совпадения слов и совпадения по инфиксу и ранжировать первые выше:\n\n* [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=keywords (включено по умолчанию)\n\n* [index_exact_words](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=1 (выключено по умолчанию),\n\n* [expand_keywords](../../Searching/Options.md#expand_keywords)=1 (также выключено по умолчанию)\n\nОбратите внимание, что при использовании режима [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=crc или при отключении любого из вышеуказанных параметров невозможно различать инфиксы и полные слова, и, следовательно, точные совпадения слов не могут быть ранжированы выше.\n\nВремя выполнения запроса поиска с подстановочными знаками в инфиксах может сильно варьироваться в зависимости от того, на сколько ключевых слов будет расширяться подстрока. Короткие и частые слоги, такие как `*in*` или `*ti*`, могут расширяться до слишком большого количества ключевых слов, все из которых нужно будет сопоставить и обработать. Поэтому для общего включения поиска подстрок обычно устанавливают min_infix_len в 2. Чтобы ограничить влияние поиска с подстановочными знаками с слишком короткими подстановочными знаками, можно установить его выше.\n\nИнфиксы должны быть длиной не менее 2 символов, и подстановочные знаки вида `*a*` не разрешены по причинам производительности.\n\nКогда min_infix_len установлен в положительное число, [минимальная длина префикса](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_prefix_len) считается равной 1. Для [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict) нельзя одновременно включать инфиксы и префиксы. Для [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict) и других полей, чтобы иметь префиксы, объявленные с помощью [prefix_fields](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#prefix_fields), запрещено объявлять одно и то же поле в обоих списках.\n\nЕсли dict=keywords, кроме подстановочного знака `*`, можно использовать ещё два символа подстановки:\n\n* `?` может соответствовать любому (одному) символу: `t?st` совпадёт с `test`, но не с `teast`\n\n* `%` может соответствовать нулю или одному символу: `tes%` совпадёт с `tes` или `test`, но не с `testing`\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_12\n\n<!-- request JSON -->\n\nCODE_BLOCK_13\n\n<!-- request PHP -->\n\nCODE_BLOCK_14\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_16\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request javascript -->\n\nCODE_BLOCK_17\n\n<!-- intro -->"
    },
    "is_code_or_comment": false
  }
}
