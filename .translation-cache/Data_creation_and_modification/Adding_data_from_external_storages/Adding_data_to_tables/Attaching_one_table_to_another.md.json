{
  "5b48428656969df9597697fc7c1e78aad4e4e1853a696d1255939bdc9a181db3": {
    "original": "# Attaching one table to another\n\n<!-- example Example_1 -->\n\nA plain table can be converted into a real-time table or added to an existing real-time table.\n\nThe first case is useful when you need to regenerate a real-time table completely, which may be needed, for example, if tokenization settings need an update. In this situation, preparing a plain table and converting it into a real-time table may be easier than preparing a batch job to perform INSERTs for adding all the data into a real-time table.\n\nIn the second case, you normally want to add a large bulk of new data to a real-time table, and again, creating a plain table with that data is easier than populating the existing real-time table.\n\nYou can also attach an existing real-time table to another one.\n\n##### Attaching table - general syntax\n\nThe `ATTACH` statement allows you to convert a plain table to be attached to an existing real-time table. It also enables you to attach the content of one real-time table to another real-time table.\n\nCODE_BLOCK_0\n\nAfter a successful `ATTACH` the data originally stored in the source plain table becomes a part of the target RT table, and the source plain table becomes unavailable (until the next rebuild). If the source table is an RT table, its content is moved into the destination RT table, and the source RT table remains empty. `ATTACH` does not result in any table data changes. Essentially, it just renames the files (making the source table a new disk chunk of the target RT table) and updates the metadata. So it is generally a quick operation that might (frequently) complete as fast as under a second.\n\nNote that when a table is attached to an empty RT table, the fields, attributes, and text processing settings (tokenizer, wordforms, etc.) from the *source* table are copied over and take effect. The respective parts of the RT table definition from the configuration file will be ignored.\n\nWhen the `TRUNCATE` option is used, the RT table gets truncated prior to attaching the source plain table. This allows the operation to be atomic or ensures that the attached source plain table will be the only data in the target RT table.\n\n`ATTACH TABLE` comes with a number of restrictions. Most notably, the target RT table is currently required to be either empty or have the same settings as the source table. In case the source table gets attached to a non-empty RT table, the RT table data collected so far gets stored as a regular disk chunk, and the table being attached becomes the newest disk chunk, with documents having the same IDs getting killed. The complete list of restrictions is as follows:\n\n* The target RT table needs to be either empty or have the same settings as the source table.\n\n* The source table needs to have [phrase_boundary_step](../../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#phrase_boundary_step) set to 0 and [stopword_step](../../../Creating_a_table/NLP_and_tokenization/Ignoring_stop-words.md#stopword_step) set to 1.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request Example -->\n\nBefore the ATTACH, the RT table is empty and has 3 fields:\n\nCODE_BLOCK_1\n\nThe plain table is not empty:\n\nCODE_BLOCK_2\n\nAttaching the plain table to the RT table:\n\nCODE_BLOCK_3\n\nThe RT table now has 5 fields:\n\nCODE_BLOCK_4\n\nAnd it's not empty:\n\nCODE_BLOCK_5\n\nAfter the ATTACH, the plain table is removed and no longer available for searching:\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 将一个表附加到另一个表\n\n<!-- example Example_1 -->\n\n一个普通表可以转换为实时表，或者附加到现有的实时表中。\n\n第一种情况在你需要完全重新生成实时表时非常有用，例如，当分词设置需要更新时。在这种情况下，准备一个普通表并将其转换为实时表可能比准备批处理作业执行 INSERT 操作将所有数据添加到实时表中更简单。\n\n在第二种情况下，通常你想向实时表添加大量新数据，同样，创建一个包含这些数据的普通表比填充现有的实时表更容易。\n\n你也可以将一个现有的实时表附加到另一个实时表。\n\n##### 附加表 - 通用语法\n\n`ATTACH` 语句允许你将普通表转换为附加到现有实时表的表。它还允许你将一个实时表的内容附加到另一个实时表。\n\nCODE_BLOCK_0\n\n成功执行 `ATTACH` 后，原本存储在源普通表中的数据成为目标实时表的一部分，源普通表变得不可用（直到下一次重建）。如果源表是实时表，其内容会被移动到目标实时表中，源实时表保持为空。`ATTACH` 不会导致任何表数据的更改。实质上，它只是重命名文件（使源表成为目标实时表的新磁盘块）并更新元数据。因此，这通常是一个快速操作，通常可以在不到一秒内完成。\n\n请注意，当一个表附加到一个空的实时表时，来自*源*表的字段、属性和文本处理设置（分词器、词形变化等）会被复制并生效。配置文件中实时表定义的相应部分将被忽略。\n\n当使用 `TRUNCATE` 选项时，实时表在附加源普通表之前会被截断。这允许操作是原子的，或者确保附加的源普通表将是目标实时表中唯一的数据。\n\n`ATTACH TABLE` 有许多限制。最显著的是，目标实时表目前必须为空，或者与源表具有相同的设置。如果源表附加到非空的实时表，迄今为止收集的实时表数据将作为常规磁盘块存储，附加的表成为最新的磁盘块，具有相同 ID 的文档将被删除。完整的限制列表如下：\n\n* 目标实时表需要为空，或者与源表具有相同的设置。\n\n* 源表需要将 [phrase_boundary_step](../../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#phrase_boundary_step) 设置为 0，将 [stopword_step](../../../Creating_a_table/NLP_and_tokenization/Ignoring_stop-words.md#stopword_step) 设置为 1。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request Example -->\n\n在 ATTACH 之前，实时表为空且有 3 个字段：\n\nCODE_BLOCK_1\n\n普通表不为空：\n\nCODE_BLOCK_2\n\n将普通表附加到实时表：\n\nCODE_BLOCK_3\n\n实时表现在有 5 个字段：\n\nCODE_BLOCK_4\n\n且不为空：\n\nCODE_BLOCK_5\n\nATTACH 之后，普通表被移除，不再可用于搜索：\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "# Присоединение одной таблицы к другой\n\n<!-- example Example_1 -->\n\nОбычную таблицу можно преобразовать в таблицу реального времени или добавить к существующей таблице реального времени.\n\nПервый случай полезен, когда необходимо полностью пересоздать таблицу реального времени, что может потребоваться, например, если нужно обновить настройки токенизации. В такой ситуации подготовка обычной таблицы и её преобразование в таблицу реального времени может быть проще, чем подготовка пакетной задачи для выполнения INSERT-запросов для добавления всех данных в таблицу реального времени.\n\nВо втором случае обычно нужно добавить большой объем новых данных в таблицу реального времени, и снова создание обычной таблицы с этими данными проще, чем заполнение существующей таблицы реального времени.\n\nТакже можно присоединить существующую таблицу реального времени к другой.\n\n##### Присоединение таблицы - общий синтаксис\n\nОператор `ATTACH` позволяет преобразовать обычную таблицу для присоединения к существующей таблице реального времени. Он также позволяет присоединить содержимое одной таблицы реального времени к другой таблице реального времени.\n\nCODE_BLOCK_0\n\nПосле успешного выполнения `ATTACH` данные, изначально хранившиеся в исходной обычной таблице, становятся частью целевой таблицы реального времени, а исходная обычная таблица становится недоступной (до следующей перестройки). Если исходная таблица является таблицей реального времени, её содержимое перемещается в целевую таблицу реального времени, а исходная таблица реального времени остаётся пустой. `ATTACH` не приводит к изменению данных таблицы. По сути, он просто переименовывает файлы (делая исходную таблицу новым дисковым чанком целевой таблицы реального времени) и обновляет метаданные. Поэтому это обычно быстрая операция, которая часто завершается менее чем за секунду.\n\nОбратите внимание, что когда таблица присоединяется к пустой таблице реального времени, поля, атрибуты и настройки обработки текста (токенизатор, словоформы и т.д.) из *исходной* таблицы копируются и вступают в силу. Соответствующие части определения таблицы реального времени из конфигурационного файла будут игнорироваться.\n\nПри использовании опции `TRUNCATE` таблица реального времени очищается перед присоединением исходной обычной таблицы. Это позволяет сделать операцию атомарной или гарантирует, что присоединённая исходная обычная таблица будет единственными данными в целевой таблице реального времени.\n\n`ATTACH TABLE` имеет ряд ограничений. В частности, целевая таблица реального времени в настоящее время должна быть либо пустой, либо иметь те же настройки, что и исходная таблица. В случае присоединения исходной таблицы к непустой таблице реального времени, данные таблицы реального времени, собранные до этого, сохраняются как обычный дисковый чанк, а присоединяемая таблица становится новейшим дисковым чанком, при этом документы с одинаковыми ID удаляются. Полный список ограничений следующий:\n\n* Целевая таблица реального времени должна быть либо пустой, либо иметь те же настройки, что и исходная таблица.\n\n* Исходная таблица должна иметь [phrase_boundary_step](../../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#phrase_boundary_step) равный 0 и [stopword_step](../../../Creating_a_table/NLP_and_tokenization/Ignoring_stop-words.md#stopword_step) равный 1.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request Example -->\n\nДо выполнения ATTACH таблица реального времени пуста и содержит 3 поля:\n\nCODE_BLOCK_1\n\nОбычная таблица не пуста:\n\nCODE_BLOCK_2\n\nПрисоединение обычной таблицы к таблице реального времени:\n\nCODE_BLOCK_3\n\nТеперь таблица реального времени содержит 5 полей:\n\nCODE_BLOCK_4\n\nИ она не пуста:\n\nCODE_BLOCK_5\n\nПосле выполнения ATTACH обычная таблица удаляется и больше недоступна для поиска:\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
