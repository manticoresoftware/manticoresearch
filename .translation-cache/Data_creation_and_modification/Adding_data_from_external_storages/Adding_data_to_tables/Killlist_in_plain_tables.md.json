{
  "158f2d8ed1aaedbdaab52c98b3af6b75246ec7f7a691f85c5448c91e3acfce53": {
    "original": "# Killlist in plain tables\n\nWhen using plain tables, there's a challenge arising from the need to have the data in the table as fresh as possible.\n\nIn this case, one or more secondary (also known as delta) tables are used to capture the modified data between the time the main table was created and the current time. The modified data can include new, updated, or deleted documents. The search becomes a search over the **main table and the delta table**. This works seamlessly when you just add **new** documents to the delta table, but when it comes to updated or deleted documents, there remains the following issue.\n\nIf a document is present in both the main and delta tables, it can cause issues during searching, as the engine will see two versions of a document and won't know how to pick the right one. So, the delta needs to somehow inform the search that there are deleted documents in the main table that should be disregarded. **This is where kill lists come in**.\n\n## Table kill-list\n\nA table can maintain a list of document IDs that can be used to suppress records in other tables. This feature is available for plain tables using database sources or plain tables using XML sources. In the case of database sources, the source needs to provide an additional query defined by `sql_query_killlist`. It will store in the table a list of documents that can be used by the server to remove documents from other plain tables.\n\nThis query is expected to return a number of 1-column rows, each containing just the document ID.\n\nIn many cases, the query is a union between a query that retrieves a list of updated documents and a list of deleted documents, e.g.:\n\nCODE_BLOCK_0\n\n## Removing documents in a plain table\n\nA plain table can contain a directive called [killlist_target](../../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#killlist_target) that will tell the server it can provide a list of document IDs that should be removed from certain existing tables. The table can use either its document IDs as the source for this list or provide a separate [list](../../../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#Table-kill-list).\n\n### killlist_target\n\n<!-- example killlist_target 1 -->\n\nSets the table(s) that the kill-list will be applied to. Optional, default value is empty.\n\nWhen you use [plain tables](../../../Creating_a_table/Local_tables/Plain_table.md) you often need to maintain not just a single table, but a set of them to be able to add/update/delete new documents sooner (read about [delta table updates](../../../Data_creation_and_modification/Adding_data_from_external_storages/Main_delta.md)). n order to suppress matches in the previous (**main**) table that were updated or deleted in the next (**delta**) table, you need to:\n\n1.  Create a kill-list in the **delta** table using [sql_query_killlist](../../../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#Table-kill-list)\n\n2.  Specify **main** table as `killlist_target` in **delta** table settings:\n\n<!-- intro -->\n\n##### CONFIG:\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\nWhen `killlist_target`  is specified, the kill-list is applied to all the tables listed in it on `searchd` startup. If any of the tables from `killlist_target` are rotated, the kill-list is reapplied to these tables. When the kill-list is applied, tables that were affected save these changes to disk.\n\n`killlist_target` has 3 modes of operation:\n\n1.  `killlist_target = main:kl`. Document IDs from the kill-list of the **delta** table are suppressed in the **main** table (see `sql_query_killlist`).\n\n2.  `killlist_target = main:id`. All document IDs from the **delta** table are suppressed in the **main** table. The kill-list is ignored.\n\n3.  `killlist_target = main`. Both document IDs from the **delta** table and its kill-list are suppressed in the **main** table.\n\nMultiple targets can be specified, separated by commas like:\n\nCODE_BLOCK_2\n\n<!-- example killlist_target 2 -->\n\nYou can change the `killlist_target`  settings for a table without rebuilding it by using `ALTER`.\n\nHowever, since the 'old' main table has already written the changes to disk, the documents that were deleted in it will **remain** deleted even if it is no longer in the `killlist_target` of the **delta** table.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- request HTTP -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# Killlist 在普通表中的应用\n\n使用普通表时，面临的一个挑战是需要保持表中的数据尽可能新鲜。\n\n在这种情况下，会使用一个或多个辅助表（也称为增量表）来捕获主表创建时间与当前时间之间的修改数据。修改的数据可以包括新增、更新或删除的文档。搜索时会同时在**主表和增量表**中进行。这在仅向增量表添加**新**文档时工作得很顺畅，但当涉及更新或删除文档时，仍存在以下问题。\n\n如果一个文档同时存在于主表和增量表中，搜索时可能会出现问题，因为引擎会看到文档的两个版本，不知道该选择哪个。因此，增量表需要以某种方式通知搜索，主表中有些已删除的文档应被忽略。**这就是 kill list 的作用所在**。\n\n## 表的 kill-list\n\n一个表可以维护一个文档 ID 列表，用于抑制其他表中的记录。此功能适用于使用数据库源的普通表或使用 XML 源的普通表。对于数据库源，源需要提供一个由 `sql_query_killlist` 定义的额外查询。该查询会在表中存储一个文档列表，服务器可以使用该列表从其他普通表中移除文档。\n\n该查询预期返回多行单列数据，每行仅包含一个文档 ID。\n\n在许多情况下，该查询是检索更新文档列表和删除文档列表的查询的联合，例如：\n\nCODE_BLOCK_0\n\n## 从普通表中移除文档\n\n普通表可以包含一个名为 [killlist_target](../../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#killlist_target) 的指令，告诉服务器它可以提供一个文档 ID 列表，用于从某些现有表中移除文档。该表可以使用其文档 ID 作为该列表的来源，或提供一个单独的 [列表](../../../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#Table-kill-list)。\n\n### killlist_target\n\n<!-- example killlist_target 1 -->\n\n设置 kill-list 将应用到的表。可选，默认值为空。\n\n当你使用 [普通表](../../../Creating_a_table/Local_tables/Plain_table.md) 时，通常需要维护的不仅仅是单个表，而是一组表，以便更快地添加/更新/删除新文档（详见[增量表更新](../../../Data_creation_and_modification/Adding_data_from_external_storages/Main_delta.md)）。为了抑制在后续（**增量**）表中更新或删除的前一个（**主**）表中的匹配项，你需要：\n\n1.  使用 [sql_query_killlist](../../../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#Table-kill-list) 在**增量**表中创建 kill-list\n\n2.  在**增量**表设置中将 **主** 表指定为 `killlist_target`：\n\n<!-- intro -->\n\n##### 配置：\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n当指定了 `killlist_target` 时，kill-list 会在 `searchd` 启动时应用到其中列出的所有表。如果 `killlist_target` 中的任何表被轮换，kill-list 会重新应用到这些表。应用 kill-list 后，受影响的表会将这些更改保存到磁盘。\n\n`killlist_target` 有三种操作模式：\n\n1.  `killlist_target = main:kl`。**增量**表的 kill-list 中的文档 ID 会在 **主** 表中被抑制（参见 `sql_query_killlist`）。\n\n2.  `killlist_target = main:id`。**增量**表中的所有文档 ID 会在 **主** 表中被抑制。kill-list 会被忽略。\n\n3.  `killlist_target = main`。**增量**表中的文档 ID 及其 kill-list 中的文档 ID 都会在 **主** 表中被抑制。\n\n可以指定多个目标，用逗号分隔，如：\n\nCODE_BLOCK_2\n\n<!-- example killlist_target 2 -->\n\n你可以使用 `ALTER` 修改表的 `killlist_target` 设置，而无需重建表。\n\n但是，由于“旧”的主表已经将更改写入磁盘，即使它不再是**增量**表的 `killlist_target`，在其中被删除的文档仍将**保持**删除状态。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- request HTTP -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "# Killlist в простых таблицах\n\nПри использовании простых таблиц возникает проблема необходимости иметь данные в таблице как можно более свежими.\n\nВ этом случае используется одна или несколько вторичных (также известных как дельта) таблиц для захвата изменённых данных между моментом создания основной таблицы и текущим временем. Изменённые данные могут включать новые, обновлённые или удалённые документы. Поиск становится поиском по **основной таблице и дельта-таблице**. Это работает без проблем, когда вы просто добавляете **новые** документы в дельта-таблицу, но когда речь идёт об обновлённых или удалённых документах, остаётся следующая проблема.\n\nЕсли документ присутствует как в основной, так и в дельта-таблице, это может вызвать проблемы при поиске, так как движок увидит две версии документа и не будет знать, какую выбрать. Поэтому дельта должна как-то сообщать поиску, что в основной таблице есть удалённые документы, которые следует игнорировать. **Вот тут и вступают в игру kill-листы**.\n\n## Kill-лист таблицы\n\nТаблица может поддерживать список ID документов, который можно использовать для подавления записей в других таблицах. Эта функция доступна для простых таблиц, использующих источники данных из базы данных или простых таблиц, использующих XML-источники. В случае источников из базы данных источник должен предоставить дополнительный запрос, определённый как `sql_query_killlist`. Он будет хранить в таблице список документов, который сервер может использовать для удаления документов из других простых таблиц.\n\nОжидается, что этот запрос вернёт несколько строк с одним столбцом, каждая из которых содержит только ID документа.\n\nВо многих случаях запрос представляет собой объединение запроса, который извлекает список обновлённых документов, и списка удалённых документов, например:\n\nCODE_BLOCK_0\n\n## Удаление документов в простой таблице\n\nПростая таблица может содержать директиву под названием [killlist_target](../../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#killlist_target), которая сообщает серверу, что он может предоставить список ID документов, которые должны быть удалены из определённых существующих таблиц. Таблица может использовать либо свои ID документов в качестве источника для этого списка, либо предоставить отдельный [список](../../../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#Table-kill-list).\n\n### killlist_target\n\n<!-- example killlist_target 1 -->\n\nЗадаёт таблицу(ы), к которым будет применён kill-лист. Необязательно, значение по умолчанию — пустое.\n\nКогда вы используете [простые таблицы](../../../Creating_a_table/Local_tables/Plain_table.md), часто нужно поддерживать не одну таблицу, а набор таблиц, чтобы иметь возможность быстрее добавлять/обновлять/удалять новые документы (читайте про [обновления дельта-таблиц](../../../Data_creation_and_modification/Adding_data_from_external_storages/Main_delta.md)). Чтобы подавить совпадения в предыдущей (**основной**) таблице, которые были обновлены или удалены в следующей (**дельта**) таблице, необходимо:\n\n1.  Создать kill-лист в **дельта** таблице с помощью [sql_query_killlist](../../../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#Table-kill-list)\n\n2.  Указать **основную** таблицу как `killlist_target` в настройках **дельта** таблицы:\n\n<!-- intro -->\n\n##### CONFIG:\n\n<!-- request CONFIG -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\nКогда `killlist_target` указан, kill-лист применяется ко всем таблицам, перечисленным в нём, при запуске `searchd`. Если какая-либо из таблиц из `killlist_target` подвергается ротации, kill-лист повторно применяется к этим таблицам. При применении kill-листа таблицы, на которые он повлиял, сохраняют эти изменения на диск.\n\n`killlist_target` имеет 3 режима работы:\n\n1.  `killlist_target = main:kl`. ID документов из kill-листа **дельта** таблицы подавляются в **основной** таблице (см. `sql_query_killlist`).\n\n2.  `killlist_target = main:id`. Все ID документов из **дельта** таблицы подавляются в **основной** таблице. Kill-лист игнорируется.\n\n3.  `killlist_target = main`. Подавляются как ID документов из **дельта** таблицы, так и её kill-лист в **основной** таблице.\n\nМожно указать несколько целей, разделённых запятыми, например:\n\nCODE_BLOCK_2\n\n<!-- example killlist_target 2 -->\n\nВы можете изменить настройки `killlist_target` для таблицы без её перестроения с помощью `ALTER`.\n\nОднако, поскольку «старая» основная таблица уже записала изменения на диск, документы, которые были удалены в ней, **останутся** удалёнными, даже если она больше не входит в `killlist_target` **дельта** таблицы.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- request HTTP -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
