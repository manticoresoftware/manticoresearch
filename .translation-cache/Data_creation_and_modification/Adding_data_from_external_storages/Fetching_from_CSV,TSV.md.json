{
  "9425186b0672e89a31c3326fda3d113ddb9ab208181a6d9ed63e71342f0935fa": {
    "original": "# Fetching from TSV,CSV\n\nTSV/CSV is the simplest way to pass data to the Manticore indexer. This method was created due to the limitations of xmlpipe2. In xmlpipe2, the indexer must map each attribute and field tag in the XML file to a corresponding schema element. This mapping requires time, and it increases with the number of fields and attributes in the schema. TSV/CSV has no such issue, as each field and attribute corresponds to a particular column in the TSV/CSV file. In some cases, TSV/CSV could work slightly faster than xmlpipe2.\n\n## File format\n\nThe first column in TSV/CSV file must be a document ID. The rest columns must mirror the declaration of fields and attributes in the schema definition. Note that you don't need to declare the document ID in the schema, since it's always considered to be present, should be in the 1st column and needs to be a unique-signed positive non-zero 64-bit integer.\n\nThe difference between tsvpipe and csvpipe is delimiter and quoting rules. tsvpipe has a tab character as hardcoded delimiter and has no quoting rules. csvpipe has the  `csvpipe_delimiter`option for delimiter with a default value of , and also has quoting rules, such as:\n\n* Any field may be quoted\n\n* Fields containing a line-break, double-quote or commas should be quoted\n\n* A double quote character in a field must be represented by two double quote characters\n\n## Declaration of TSV stream\n\n`tsvpipe_command` directive is mandatory and contains the shell command invoked to produce the TSV stream that gets indexed. The command can read a TSV file, but it can also be a program that generates on-the-fly the tab delimited content.\n\n##  TSV indexed columns\n\nThe following directives can be used to declare the types of the indexed columns:\n\n* `tsvpipe_field` -  declares a `text` field.\n\n* `tsvpipe_field_string` - declares a text field/string attribute. The column will be both indexed as a text field but also stored as a string attribute.\n\n* `tsvpipe_attr_uint` - declares an integer attribute.\n\n* `tsvpipe_attr_timestamp` - declares a timestamp attribute.\n\n* `tsvpipe_attr_bool` -  declares a boolean attribute.\n\n* `tsvpipe_attr_float` - declares a float attribute.\n\n* `tsvpipe_attr_bigint` - declares a big integer attribute.\n\n* `tsvpipe_attr_multi` - declares a multi-value attribute with integers.\n\n* `tsvpipe_attr_multi_64` - declares a multi-value attribute with 64-bit integers.\n\n* `tsvpipe_attr_string` - declares a string attribute.\n\n* `tsvpipe_attr_json` - declares a JSON attribute.\n\nExample of a source using a TSV file:\n\nCODE_BLOCK_0\n\nCODE_BLOCK_1\n\n## Declaration of CSV stream\n\n`csvpipe_command` directive is mandatory and contains the shell command invoked to produce the CSV stream which gets indexed. The command can just read a CSV file but it can also be a program that generates on-the-fly the comma delimited content.\n\n##  CSV indexed columns\n\nThe following directives can be used to declare the types of the indexed columns:\n\n* `csvpipe_field` -  declares a `text` field.\n\n* `csvpipe_field_string` - declares a text field/string attribute. The column will be both indexed as a text field but also stored as a string attribute.\n\n* `csvpipe_attr_uint` - declares an integer attribute.\n\n* `csvpipe_attr_timestamp` - declares a timestamp attribute.\n\n* `csvpipe_attr_bool` -  declares a boolean attribute.\n\n* `csvpipe_attr_float` - declares a float attribute.\n\n* `csvpipe_attr_bigint` - declares a big integer attribute.\n\n* `csvpipe_attr_multi` - declares a multi-value attribute with integers.\n\n* `csvpipe_attr_multi_64` - declares a multi-value attribute with 64-bit integers.\n\n* `csvpipe_attr_string` - declares a string attribute.\n\n* `csvpipe_attr_json` - declares a JSON attribute.\n\nExample of a source using a CSV file:\n\nCODE_BLOCK_2\n\nCODE_BLOCK_3\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 从 TSV,CSV 获取数据\n\nTSV/CSV 是传递数据给 Manticore 索引器的最简单方式。该方法是由于 xmlpipe2 的限制而创建的。在 xmlpipe2 中，索引器必须将 XML 文件中的每个属性和字段标签映射到相应的模式元素。此映射需要时间，并且随着模式中字段和属性数量的增加而增加。TSV/CSV 没有此类问题，因为每个字段和属性对应于 TSV/CSV 文件中的特定列。在某些情况下，TSV/CSV 的工作速度可能略快于 xmlpipe2。\n\n## 文件格式\n\nTSV/CSV 文件的第一列必须是文档 ID。其余列必须与模式定义中字段和属性的声明相对应。请注意，您不需要在模式中声明文档 ID，因为它始终被视为存在，应该位于第一列，并且需要是唯一的带符号正非零 64 位整数。\n\ntsvpipe 和 csvpipe 之间的区别在于分隔符和引用规则。tsvpipe 的分隔符是硬编码的制表符，并且没有引用规则。csvpipe 有 `csvpipe_delimiter` 选项用于分隔符，默认值为逗号，并且还有引用规则，例如：\n\n* 任何字段都可以被引用\n\n* 包含换行符、双引号或逗号的字段应被引用\n\n* 字段中的双引号字符必须用两个双引号字符表示\n\n## TSV 流声明\n\n`tsvpipe_command` 指令是必需的，包含调用的 shell 命令以生成被索引的 TSV 流。该命令可以读取 TSV 文件，也可以是一个动态生成制表符分隔内容的程序。\n\n## TSV 索引列\n\n以下指令可用于声明索引列的类型：\n\n* `tsvpipe_field` - 声明一个 `text` 字段。\n\n* `tsvpipe_field_string` - 声明一个文本字段/字符串属性。该列既作为文本字段索引，也作为字符串属性存储。\n\n* `tsvpipe_attr_uint` - 声明一个整数属性。\n\n* `tsvpipe_attr_timestamp` - 声明一个时间戳属性。\n\n* `tsvpipe_attr_bool` - 声明一个布尔属性。\n\n* `tsvpipe_attr_float` - 声明一个浮点属性。\n\n* `tsvpipe_attr_bigint` - 声明一个大整数属性。\n\n* `tsvpipe_attr_multi` - 声明一个多值整数属性。\n\n* `tsvpipe_attr_multi_64` - 声明一个多值 64 位整数属性。\n\n* `tsvpipe_attr_string` - 声明一个字符串属性。\n\n* `tsvpipe_attr_json` - 声明一个 JSON 属性。\n\n使用 TSV 文件的源示例：\n\nCODE_BLOCK_0\n\nCODE_BLOCK_1\n\n## CSV 流声明\n\n`csvpipe_command` 指令是必需的，包含调用的 shell 命令以生成被索引的 CSV 流。该命令可以读取 CSV 文件，也可以是一个动态生成逗号分隔内容的程序。\n\n## CSV 索引列\n\n以下指令可用于声明索引列的类型：\n\n* `csvpipe_field` - 声明一个 `text` 字段。\n\n* `csvpipe_field_string` - 声明一个文本字段/字符串属性。该列既作为文本字段索引，也作为字符串属性存储。\n\n* `csvpipe_attr_uint` - 声明一个整数属性。\n\n* `csvpipe_attr_timestamp` - 声明一个时间戳属性。\n\n* `csvpipe_attr_bool` - 声明一个布尔属性。\n\n* `csvpipe_attr_float` - 声明一个浮点属性。\n\n* `csvpipe_attr_bigint` - 声明一个大整数属性。\n\n* `csvpipe_attr_multi` - 声明一个多值整数属性。\n\n* `csvpipe_attr_multi_64` - 声明一个多值 64 位整数属性。\n\n* `csvpipe_attr_string` - 声明一个字符串属性。\n\n* `csvpipe_attr_json` - 声明一个 JSON 属性。\n\n使用 CSV 文件的源示例：\n\nCODE_BLOCK_2\n\nCODE_BLOCK_3\n\n<!-- proofread -->",
      "russian": "# Получение данных из TSV,CSV\n\nTSV/CSV — самый простой способ передать данные индексатору Manticore. Этот метод был создан из-за ограничений xmlpipe2. В xmlpipe2 индексатор должен сопоставить каждый тег атрибута и поля в XML-файле с соответствующим элементом схемы. Это сопоставление требует времени, и оно увеличивается с ростом количества полей и атрибутов в схеме. В TSV/CSV такой проблемы нет, так как каждое поле и атрибут соответствуют определённому столбцу в файле TSV/CSV. В некоторых случаях TSV/CSV может работать немного быстрее, чем xmlpipe2.\n\n## Формат файла\n\nПервый столбец в файле TSV/CSV должен быть идентификатором документа. Остальные столбцы должны соответствовать объявлению полей и атрибутов в определении схемы. Обратите внимание, что вам не нужно объявлять идентификатор документа в схеме, так как он всегда считается присутствующим, должен находиться в первом столбце и быть уникальным знаковым положительным ненулевым 64-битным целым числом.\n\nРазница между tsvpipe и csvpipe заключается в разделителе и правилах кавычек. tsvpipe использует символ табуляции в качестве жёстко заданного разделителя и не имеет правил кавычек. csvpipe имеет опцию `csvpipe_delimiter` для разделителя со значением по умолчанию , а также правила кавычек, такие как:\n\n* Любое поле может быть заключено в кавычки\n\n* Поля, содержащие перенос строки, двойную кавычку или запятые, должны быть заключены в кавычки\n\n* Символ двойной кавычки в поле должен быть представлен двумя двойными кавычками\n\n## Объявление потока TSV\n\nДиректива `tsvpipe_command` обязательна и содержит команду оболочки, вызываемую для создания TSV-потока, который индексируется. Команда может читать TSV-файл, но также может быть программой, которая генерирует содержимое с разделителями табуляции на лету.\n\n## Индексируемые столбцы TSV\n\nСледующие директивы могут использоваться для объявления типов индексируемых столбцов:\n\n* `tsvpipe_field` - объявляет поле типа `text`.\n\n* `tsvpipe_field_string` - объявляет текстовое поле/строковый атрибут. Столбец будет индексироваться как текстовое поле, а также храниться как строковый атрибут.\n\n* `tsvpipe_attr_uint` - объявляет целочисленный атрибут.\n\n* `tsvpipe_attr_timestamp` - объявляет атрибут временной метки.\n\n* `tsvpipe_attr_bool` - объявляет булев атрибут.\n\n* `tsvpipe_attr_float` - объявляет атрибут с плавающей точкой.\n\n* `tsvpipe_attr_bigint` - объявляет атрибут большого целого числа.\n\n* `tsvpipe_attr_multi` - объявляет мульти-значный атрибут с целыми числами.\n\n* `tsvpipe_attr_multi_64` - объявляет мульти-значный атрибут с 64-битными целыми числами.\n\n* `tsvpipe_attr_string` - объявляет строковый атрибут.\n\n* `tsvpipe_attr_json` - объявляет JSON-атрибут.\n\nПример источника, использующего TSV-файл:\n\nCODE_BLOCK_0\n\nCODE_BLOCK_1\n\n## Объявление потока CSV\n\nДиректива `csvpipe_command` обязательна и содержит команду оболочки, вызываемую для создания CSV-потока, который индексируется. Команда может просто читать CSV-файл, но также может быть программой, которая генерирует содержимое с разделителями-запятыми на лету.\n\n## Индексируемые столбцы CSV\n\nСледующие директивы могут использоваться для объявления типов индексируемых столбцов:\n\n* `csvpipe_field` - объявляет поле типа `text`.\n\n* `csvpipe_field_string` - объявляет текстовое поле/строковый атрибут. Столбец будет индексироваться как текстовое поле, а также храниться как строковый атрибут.\n\n* `csvpipe_attr_uint` - объявляет целочисленный атрибут.\n\n* `csvpipe_attr_timestamp` - объявляет атрибут временной метки.\n\n* `csvpipe_attr_bool` - объявляет булев атрибут.\n\n* `csvpipe_attr_float` - объявляет атрибут с плавающей точкой.\n\n* `csvpipe_attr_bigint` - объявляет атрибут большого целого числа.\n\n* `csvpipe_attr_multi` - объявляет мульти-значный атрибут с целыми числами.\n\n* `csvpipe_attr_multi_64` - объявляет мульти-значный атрибут с 64-битными целыми числами.\n\n* `csvpipe_attr_string` - объявляет строковый атрибут.\n\n* `csvpipe_attr_json` - объявляет JSON-атрибут.\n\nПример источника, использующего CSV-файл:\n\nCODE_BLOCK_2\n\nCODE_BLOCK_3\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
