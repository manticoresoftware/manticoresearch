{
  "9d3ecbb4da9581ec5a3bddb198b645a294771695acf6c23fe1ff3db09ab23db6": {
    "original": "# Execution of fetch queries\n\nWith all the SQL drivers, building a plain table generally works as follows.\n\n* A connection to the database is established.\n\n* The `sql_query_pre_all` queries are executed to perform any necessary initial setup, such as setting per-connection encoding with MySQL. These queries run before the entire indexing process, and also after a reconnect for indexing MVA attributes and joined fields.\n\n* The `sql_query_pre` pre-query is executed to perform any necessary initial setup, such as setting up temporary tables or maintaining counter tables. These queries run once for the entire indexing process.\n\n* Pre-queries as `sql_query_pre` is executed to perform any necessary initial setup, such as setting up temporary\n\n  tables, or maintaining counter table. These queries run once per whole indexing.\n\n* Main query as `sql_query` is executed and the rows it returns are processed.\n\n* Post-query as `sql_query_post` is executed to perform some necessary cleanup.\n\n* The connection to the database is closed.\n\n* Indexer does the sorting phase (to be pedantic, table-type specific post-processing).\n\n* A connection to the database is established again.\n\n* Post-processing query as `sql_query_post_index` is executed to perform some necessary final cleanup.\n\n* The connection to the database is closed again.\n\nExample of a source fetching data from MYSQL:\n\nCODE_BLOCK_0\n\n## sql_query\n\nThis is the query used to retrieve documents from a SQL server. There can be only one sql_query declared, and it's mandatory to have one. See also [Processing fetched data](../../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Processing_fetched_data.md#Processing-fetched-data)\n\n## sql_query_pre\n\nPre-fetch query or pre-query. This is a multi-value, optional setting, with the default being an empty list of queries. The pre-queries are executed before the sql_query in the order they appear in the configuration file. The results of the pre-queries are ignored.\n\nPre-queries are useful in many ways. They can be used to set up encoding, mark records that are going to be indexed, update internal counters, set various per-connection SQL server options and variables, and so on.\n\nPerhaps the most frequent use of pre-query is to specify the encoding that the server will use for the rows it returns. Note that Manticore accepts only UTF-8 text. Two MySQL specific examples of setting the encoding are:\n\nCODE_BLOCK_1\n\nAlso, specific to MySQL sources, it is useful to disable query cache (for indexer connection only) in pre-query, because indexing queries are not going to be re-run frequently anyway, and there's no sense in caching their results.\n\nThat could be achieved with:\n\nCODE_BLOCK_2\n\n## sql_query_post\n\nPost-fetch query. This is an optional setting, with the default value being empty.\n\nThis query is executed immediately after sql_query completes successfully. When the post-fetch query produces errors, they are reported as warnings, but indexing is not terminated. Its result set is ignored. Note that indexing is not yet completed at the point when this query gets executed, and further indexing may still fail. Therefore, any permanent updates should not be done from here. For instance, updates on a helper table that permanently change the last successfully indexed ID should not be run from the `sql_query_post` query; they should be run from the `sql_query_post_index` query instead.\n\n## sql_query_post_index\n\nPost-processing query. This is an optional setting, with the default value being empty.\n\nThis query is executed when indexing is fully and successfully completed. If this query produces errors, they are reported as warnings, but indexing is not terminated. Its result set is ignored. The `$maxid` macro can be used in its text; it will be expanded to the maximum document ID that was actually fetched from the database during indexing. If no documents were indexed, `$maxid` will be expanded to 0.\n\nExample:\n\nCODE_BLOCK_3\n\nThe difference between `sql_query_post` and `sql_query_post_index` is that `sql_query_post` is run immediately when Manticore receives all the documents, but further indexing may still fail for some other reason. On the contrary, by the time the `sql_query_post_index` query gets executed, it is guaranteed that the table was created successfully. Database connection is dropped and re-established because sorting phase can be very lengthy and would just time out otherwise.\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 执行 fetch 查询\n\n对于所有的 SQL 驱动，构建一个普通表通常按以下步骤进行。\n\n* 建立与数据库的连接。\n\n* 执行 `sql_query_pre_all` 查询以进行任何必要的初始设置，例如使用 MySQL 设置每个连接的编码。这些查询在整个索引过程之前运行，也在重新连接后用于索引 MVA 属性和连接字段。\n\n* 执行 `sql_query_pre` 预查询以进行任何必要的初始设置，例如设置临时表或维护计数器表。这些查询在整个索引过程中只运行一次。\n\n* 执行 `sql_query_pre` 预查询以进行任何必要的初始设置，例如设置临时\n\n  表，或维护计数器表。这些查询在整个索引过程中只运行一次。\n\n* 执行主查询 `sql_query` 并处理其返回的行。\n\n* 执行后查询 `sql_query_post` 以进行一些必要的清理。\n\n* 关闭与数据库的连接。\n\n* 索引器执行排序阶段（严格来说，是表类型特定的后处理）。\n\n* 再次建立与数据库的连接。\n\n* 执行后处理查询 `sql_query_post_index` 以进行一些必要的最终清理。\n\n* 再次关闭与数据库的连接。\n\n从 MYSQL 获取数据的示例：\n\nCODE_BLOCK_0\n\n## sql_query\n\n这是用于从 SQL 服务器检索文档的查询。只能声明一个 sql_query，且必须有一个。另请参见 [处理获取的数据](../../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Processing_fetched_data.md#Processing-fetched-data)\n\n## sql_query_pre\n\n预获取查询或预查询。这是一个多值的可选设置，默认是一个空的查询列表。预查询按照它们在配置文件中出现的顺序在 sql_query 之前执行。预查询的结果会被忽略。\n\n预查询在很多方面都很有用。它们可以用于设置编码，标记将要被索引的记录，更新内部计数器，设置各种每连接的 SQL 服务器选项和变量，等等。\n\n预查询最常见的用途可能是指定服务器将用于返回行的编码。请注意，Manticore 只接受 UTF-8 文本。两个 MySQL 特定的设置编码的示例如下：\n\nCODE_BLOCK_1\n\n此外，针对 MySQL 源，在预查询中禁用查询缓存（仅针对索引器连接）是有用的，因为索引查询无论如何不会频繁重新运行，缓存它们的结果没有意义。\n\n这可以通过以下方式实现：\n\nCODE_BLOCK_2\n\n## sql_query_post\n\n后获取查询。这是一个可选设置，默认值为空。\n\n该查询在 sql_query 成功完成后立即执行。当后获取查询产生错误时，会作为警告报告，但不会终止索引。其结果集会被忽略。请注意，在执行此查询时索引尚未完成，后续索引仍可能失败。因此，不应从这里进行任何永久更新。例如，不应从 `sql_query_post` 查询中运行永久更改最后成功索引 ID 的辅助表更新；这些应从 `sql_query_post_index` 查询中运行。\n\n## sql_query_post_index\n\n后处理查询。这是一个可选设置，默认值为空。\n\n该查询在索引完全且成功完成时执行。如果此查询产生错误，会作为警告报告，但不会终止索引。其结果集会被忽略。其文本中可以使用 `$maxid` 宏；它将被展开为索引期间实际从数据库获取的最大文档 ID。如果没有索引任何文档，`$maxid` 将被展开为 0。\n\n示例：\n\nCODE_BLOCK_3\n\n`sql_query_post` 和 `sql_query_post_index` 的区别在于，`sql_query_post` 在 Manticore 接收完所有文档后立即运行，但后续索引可能因其他原因失败。相反，当执行 `sql_query_post_index` 查询时，已保证表成功创建。数据库连接被断开并重新建立，因为排序阶段可能非常耗时，否则会超时。\n\n<!-- proofread -->",
      "russian": "# Выполнение запросов выборки\n\nСо всеми SQL-драйверами построение простой таблицы обычно происходит следующим образом.\n\n* Устанавливается соединение с базой данных.\n\n* Выполняются запросы `sql_query_pre_all` для выполнения необходимой начальной настройки, например, установки кодировки на соединение в MySQL. Эти запросы выполняются перед всем процессом индексирования, а также после переподключения для индексирования атрибутов MVA и объединённых полей.\n\n* Выполняется предварительный запрос `sql_query_pre` для выполнения необходимой начальной настройки, например, создания временных таблиц или поддержки таблиц счётчиков. Эти запросы выполняются один раз за весь процесс индексирования.\n\n* Предварительные запросы, такие как `sql_query_pre`, выполняются для выполнения необходимой начальной настройки, например, создания временных\n\n  таблиц или поддержки таблиц счётчиков. Эти запросы выполняются один раз за весь процесс индексирования.\n\n* Выполняется основной запрос `sql_query`, и обрабатываются возвращённые им строки.\n\n* Выполняется пост-запрос `sql_query_post` для выполнения необходимой очистки.\n\n* Соединение с базой данных закрывается.\n\n* Индексатор выполняет фазу сортировки (если быть точным, специфическую для типа таблицы постобработку).\n\n* Соединение с базой данных устанавливается снова.\n\n* Выполняется запрос постобработки `sql_query_post_index` для выполнения необходимой финальной очистки.\n\n* Соединение с базой данных закрывается снова.\n\nПример источника, извлекающего данные из MYSQL:\n\nCODE_BLOCK_0\n\n## sql_query\n\nЭто запрос, используемый для извлечения документов с SQL-сервера. Может быть объявлен только один sql_query, и он обязателен. См. также [Обработка извлечённых данных](../../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Processing_fetched_data.md#Processing-fetched-data)\n\n## sql_query_pre\n\nПредварительный запрос выборки или предзапрос. Это многозначная, необязательная настройка, по умолчанию — пустой список запросов. Предварительные запросы выполняются перед sql_query в порядке их появления в конфигурационном файле. Результаты предварительных запросов игнорируются.\n\nПредварительные запросы полезны во многих случаях. Их можно использовать для установки кодировки, пометки записей, которые будут индексироваться, обновления внутренних счётчиков, установки различных опций и переменных SQL-сервера на соединение и так далее.\n\nВозможно, наиболее частое использование предзапроса — указание кодировки, которую сервер будет использовать для возвращаемых строк. Обратите внимание, что Manticore принимает только текст в UTF-8. Два специфичных для MySQL примера установки кодировки:\n\nCODE_BLOCK_1\n\nТакже, специфично для источников MySQL, полезно отключить кэш запросов (только для соединения индексатора) в предзапросе, потому что индексирующие запросы всё равно не будут часто повторяться, и нет смысла кэшировать их результаты.\n\nЭто можно сделать так:\n\nCODE_BLOCK_2\n\n## sql_query_post\n\nПост-запрос выборки. Это необязательная настройка, по умолчанию пустая.\n\nЭтот запрос выполняется сразу после успешного завершения sql_query. Если пост-запрос выборки вызывает ошибки, они регистрируются как предупреждения, но индексирование не прерывается. Его результирующий набор игнорируется. Обратите внимание, что индексирование ещё не завершено в момент выполнения этого запроса, и дальнейшее индексирование может завершиться неудачей. Поэтому любые постоянные обновления не должны выполняться здесь. Например, обновления вспомогательной таблицы, которые навсегда изменяют последний успешно проиндексированный ID, не должны выполняться из запроса `sql_query_post`; их следует выполнять из запроса `sql_query_post_index`.\n\n## sql_query_post_index\n\nЗапрос постобработки. Это необязательная настройка, по умолчанию пустая.\n\nЭтот запрос выполняется, когда индексирование полностью и успешно завершено. Если этот запрос вызывает ошибки, они регистрируются как предупреждения, но индексирование не прерывается. Его результирующий набор игнорируется. В его тексте можно использовать макрос `$maxid`; он будет заменён на максимальный ID документа, фактически извлечённого из базы данных во время индексирования. Если документы не были проиндексированы, `$maxid` будет заменён на 0.\n\nПример:\n\nCODE_BLOCK_3\n\nРазница между `sql_query_post` и `sql_query_post_index` в том, что `sql_query_post` выполняется сразу, когда Manticore получает все документы, но дальнейшее индексирование всё ещё может завершиться неудачей по другой причине. Напротив, к моменту выполнения запроса `sql_query_post_index` гарантируется, что таблица была успешно создана. Соединение с базой данных разрывается и устанавливается заново, потому что фаза сортировки может быть очень длительной и в противном случае просто прервётся по таймауту.\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
