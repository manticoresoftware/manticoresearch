{
  "14730b1457cfa2c47207d6c3d260aa32b0723b49fef7e63ef7ed869c4ebcc001": {
    "original": "**Joined fields** let you avoid JOIN and/or GROUP_CONCAT statements in the main document fetch query (sql_query). This can be useful when the SQL-side JOIN is slow, or needs to be offloaded on the Manticore side, or simply to emulate MySQL-specific `GROUP_CONCAT` functionality in case your database server does not support it.\n\nThe query must return exactly 2 columns: document ID, and text to append to a joined field. Document IDs can be duplicate, but they must be in ascending order. All the text rows fetched for a given ID will be concatenated together, and the concatenation result will be indexed as the entire contents of a joined field. Rows will be concatenated in the order returned from the query, and separating whitespace will be inserted between them. For instance, if the joined field query returns the following rows:\n\nCODE_BLOCK_6\n\nthen the indexing results would be equivalent to adding a new text field with a value of 'red right hand' to document 1 and 'mysql sphinx' to document 2, including the keyword positions inside the field in the order they come from the query. If the rows need to be in a specific order, that needs to be explicitly defined in the query.\n\nJoined fields are only indexed differently. There are no other differences between joined fields and regular text fields.\n\nBefore executing the joined fields query, any set of `sql_query_pre_all` will be run, if any exist. This allows you to set the desired encoding, etc., within the joined fields' context.\n\nWhen a single query is not efficient enough or does not work because of the database driver limitations, ranged queries can be used. It works similarly to the ranged queries in the main indexing loop. The range will be queried for and fetched upfront once, then multiple queries with different `$start` and `$end` substitutions will be run to fetch the actual data.\n\nWhen using `ranged-main-query` query, omit the `ranged-query`, and it will automatically use the same query from `sql_query_range` (a useful option in complex inheritance setups to save having to manually duplicate the same query many times).\n\n<!-- example payload -->\n\n**Payloads** let you create a special field in which, instead of keyword positions, so-called user payloads are stored. Payloads are custom integer values attached to every keyword. They can then be used at search time to affect the ranking.\n\nThe payload query must return exactly 3 columns:\n\n- document ID\n\n- keyword\n\n- and integer payload value.\n\nDocument IDs can be duplicate, but they must be in ascending order. Payloads **must** be unsigned integers within the 24-bit range, i.e., from 0 to 16777215.\n\nThe only ranker that accounts for payloads is `proximity_bm25` (the default [ranker](../../../Searching/Sorting_and_ranking.md#Available-built-in-rankers)). On tables with payload fields, it will automatically switch to a variant that matches keywords in those fields, computes a sum of matched payloads multiplied by field weights, and adds that sum to the final rank.\n\nPlease note that the payload field is ignored for full-text queries containing complex operators. It only works for simple bag-of-words queries.\n\n<!-- intro -->\n\nConfiguration example:\n\n<!-- request Configuration file -->\n\nCODE_BLOCK_7\n\n<!-- request Just SELECT -->\n\nCODE_BLOCK_8\n\n<!-- request Full-text search -->\n\nNote that when you search for `nike | adidas`, the results containing \"nike\" receive a higher weight due to the \"nike\" tag and its weight originating from the payload query.\n\nCODE_BLOCK_9\n\n<!-- request Complex full-text search -->\n\nNote that the special payload field is ignored for full-text queries containing complex operators. It only works for simple bag-of-words queries.\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n### sql_column_buffers\n\nCODE_BLOCK_11\n\nPer-column buffer sizes. Optional, default is empty (deduce the sizes automatically). Applies to `odbc`, `mssql` source types only.\n\nODBC and MS SQL drivers sometimes cannot return the maximum actual column size to be expected. For instance,`NVARCHAR(MAX)` columns always report their length as 2147483647 bytes to `indexer` even though the actually used length is likely considerably less. However, the receiving buffers still need to be allocated upfront, and their sizes have to be determined. When the driver does not report the column length at all, Manticore allocates default 1 KB buffers for each non-char column, and 1 MB buffers for each char column. Driver-reported column length also gets clamped by an upper limit of 8 MB, so in case the driver reports (almost) a 2 GB column length, it will be clamped and an 8 MB buffer will be allocated instead for that column. These hard-coded limits can be overridden using the `sql_column_buffers` directive, either in order to save memory on actually shorter columns or to overcome the 8 MB limit on actually longer columns. The directive values must be a comma-separated list of selected column names and sizes:\n\nExample:\n\nCODE_BLOCK_12\n\n<!-- proofread -->",
    "translations": {
      "chinese": "**Joined fields** 让您避免在主文档获取查询（sql_query）中使用 JOIN 和/或 GROUP_CONCAT 语句。当 SQL 端的 JOIN 速度较慢，或者需要将其卸载到 Manticore 端，或者仅仅是为了模拟 MySQL 特有的 `GROUP_CONCAT` 功能（以防您的数据库服务器不支持该功能）时，这会非常有用。\n\n查询必须返回恰好 2 列：文档 ID 和要附加到 joined 字段的文本。文档 ID 可以重复，但必须按升序排列。对于给定 ID 获取的所有文本行将被连接在一起，连接结果将被索引为 joined 字段的全部内容。行将按照查询返回的顺序连接，并在它们之间插入分隔空白。例如，如果 joined 字段查询返回以下行：\n\nCODE_BLOCK_6\n\n那么索引结果将等同于向文档 1 添加一个新文本字段，值为 'red right hand'，向文档 2 添加一个新文本字段，值为 'mysql sphinx'，包括字段内关键字的位置，顺序与查询返回的顺序一致。如果行需要特定顺序，则必须在查询中显式定义。\n\nJoined fields 仅在索引方式上有所不同。joined fields 和普通文本字段之间没有其他区别。\n\n在执行 joined fields 查询之前，任何存在的 `sql_query_pre_all` 都会被执行。这允许您在 joined fields 的上下文中设置所需的编码等。\n\n当单个查询效率不够或由于数据库驱动限制而无法工作时，可以使用范围查询。它的工作方式类似于主索引循环中的范围查询。范围将被预先查询并一次性获取，然后使用不同的 `$start` 和 `$end` 替换运行多个查询以获取实际数据。\n\n使用 `ranged-main-query` 查询时，省略 `ranged-query`，它将自动使用 `sql_query_range` 中的相同查询（在复杂继承设置中非常有用，可以避免手动多次复制相同查询）。\n\n<!-- example payload -->\n\n**Payloads** 让您创建一个特殊字段，其中存储的不是关键字位置，而是所谓的用户负载。负载是附加到每个关键字的自定义整数值。它们可以在搜索时用于影响排名。\n\n负载查询必须返回恰好 3 列：\n\n- 文档 ID\n\n- 关键字\n\n- 以及整数负载值。\n\n文档 ID 可以重复，但必须按升序排列。负载 **必须** 是 24 位范围内的无符号整数，即从 0 到 16777215。\n\n唯一考虑负载的排序器是 `proximity_bm25`（默认的[排序器](../../../Searching/Sorting_and_ranking.md#Available-built-in-rankers)）。在带有负载字段的表上，它会自动切换到一个变体，该变体匹配这些字段中的关键字，计算匹配负载乘以字段权重的总和，并将该总和加到最终排名中。\n\n请注意，负载字段会被忽略用于包含复杂操作符的全文查询。它仅适用于简单的词袋查询。\n\n<!-- intro -->\n\n配置示例：\n\n<!-- request Configuration file -->\n\nCODE_BLOCK_7\n\n<!-- request Just SELECT -->\n\nCODE_BLOCK_8\n\n<!-- request Full-text search -->\n\n请注意，当您搜索 `nike | adidas` 时，包含 \"nike\" 的结果由于来自负载查询的 \"nike\" 标签及其权重而获得更高权重。\n\nCODE_BLOCK_9\n\n<!-- request Complex full-text search -->\n\n请注意，特殊负载字段会被忽略用于包含复杂操作符的全文查询。它仅适用于简单的词袋查询。\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n### sql_column_buffers\n\nCODE_BLOCK_11\n\n每列缓冲区大小。可选，默认为空（自动推断大小）。仅适用于 `odbc`、`mssql` 源类型。\n\nODBC 和 MS SQL 驱动有时无法返回预期的最大实际列大小。例如，`NVARCHAR(MAX)` 列总是向 `indexer` 报告其长度为 2147483647 字节，尽管实际使用的长度可能远小于此。然而，接收缓冲区仍需预先分配，并且必须确定其大小。当驱动根本不报告列长度时，Manticore 会为每个非字符列分配默认 1 KB 缓冲区，为每个字符列分配 1 MB 缓冲区。驱动报告的列长度也会被限制在 8 MB 的上限，因此如果驱动报告（几乎）2 GB 的列长度，则会被限制，并为该列分配 8 MB 缓冲区。这些硬编码限制可以通过 `sql_column_buffers` 指令覆盖，既可以节省实际较短列的内存，也可以突破实际较长列的 8 MB 限制。指令值必须是选定列名和大小的逗号分隔列表：\n\n示例：\n\nCODE_BLOCK_12\n\n<!-- proofread -->",
      "russian": "**Объединённые поля** позволяют избежать использования операторов JOIN и/или GROUP_CONCAT в основном запросе выборки документов (sql_query). Это может быть полезно, когда JOIN на стороне SQL медленный, или его нужно перенести на сторону Manticore, или просто для эмуляции специфичной для MySQL функции `GROUP_CONCAT`, если ваш сервер базы данных её не поддерживает.\n\nЗапрос должен возвращать ровно 2 столбца: ID документа и текст, который нужно добавить к объединённому полю. ID документов могут повторяться, но они должны быть в порядке возрастания. Все текстовые строки, полученные для данного ID, будут объединены вместе, и результат конкатенации будет индексироваться как полное содержимое объединённого поля. Строки будут объединяться в порядке, возвращаемом запросом, между ними будет вставлен разделяющий пробел. Например, если запрос объединённого поля возвращает следующие строки:\n\nCODE_BLOCK_6\n\nто результаты индексирования будут эквивалентны добавлению нового текстового поля со значением 'red right hand' к документу 1 и 'mysql sphinx' к документу 2, включая позиции ключевых слов внутри поля в порядке их поступления из запроса. Если строки должны быть в определённом порядке, это нужно явно указать в запросе.\n\nОбъединённые поля индексируются только иначе. Других отличий между объединёнными полями и обычными текстовыми полями нет.\n\nПеред выполнением запроса объединённых полей будут выполнены все наборы `sql_query_pre_all`, если они существуют. Это позволяет задать нужную кодировку и т. п. в контексте объединённых полей.\n\nЕсли один запрос недостаточно эффективен или не работает из-за ограничений драйвера базы данных, можно использовать запросы с диапазонами. Это работает аналогично запросам с диапазонами в основном цикле индексирования. Диапазон запрашивается и извлекается заранее один раз, затем выполняется несколько запросов с разными подстановками `$start` и `$end` для получения фактических данных.\n\nПри использовании запроса `ranged-main-query` опускается `ranged-query`, и автоматически используется тот же запрос из `sql_query_range` (полезная опция в сложных схемах наследования, чтобы не дублировать один и тот же запрос много раз вручную).\n\n<!-- example payload -->\n\n**Payloads** позволяют создать специальное поле, в котором вместо позиций ключевых слов хранятся так называемые пользовательские полезные данные (payloads). Payloads — это пользовательские целочисленные значения, прикреплённые к каждому ключевому слову. Они могут использоваться во время поиска для влияния на ранжирование.\n\nЗапрос payload должен возвращать ровно 3 столбца:\n\n- ID документа\n\n- ключевое слово\n\n- и целочисленное значение payload.\n\nID документов могут повторяться, но должны быть в порядке возрастания. Payloads **должны** быть беззнаковыми целыми числами в 24-битном диапазоне, то есть от 0 до 16777215.\n\nЕдинственный ранжировщик, учитывающий payloads — это `proximity_bm25` (ранжировщик по умолчанию [ranker](../../../Searching/Sorting_and_ranking.md#Available-built-in-rankers)). В таблицах с полями payload он автоматически переключается на вариант, который сопоставляет ключевые слова в этих полях, вычисляет сумму совпавших payloads, умноженных на веса полей, и добавляет эту сумму к итоговому рангу.\n\nОбратите внимание, что поле payload игнорируется для полнотекстовых запросов, содержащих сложные операторы. Оно работает только для простых запросов типа \"мешок слов\".\n\n<!-- intro -->\n\nПример конфигурации:\n\n<!-- request Configuration file -->\n\nCODE_BLOCK_7\n\n<!-- request Just SELECT -->\n\nCODE_BLOCK_8\n\n<!-- request Full-text search -->\n\nОбратите внимание, что при поиске `nike | adidas` результаты, содержащие \"nike\", получают больший вес благодаря тегу \"nike\" и его весу, исходящему из запроса payload.\n\nCODE_BLOCK_9\n\n<!-- request Complex full-text search -->\n\nОбратите внимание, что специальное поле payload игнорируется для полнотекстовых запросов, содержащих сложные операторы. Оно работает только для простых запросов типа \"мешок слов\".\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n### sql_column_buffers\n\nCODE_BLOCK_11\n\nРазмеры буферов для каждого столбца. Опционально, по умолчанию пусто (размеры определяются автоматически). Применяется только к типам источников `odbc`, `mssql`.\n\nДрайверы ODBC и MS SQL иногда не могут вернуть максимальный фактический размер столбца. Например, столбцы `NVARCHAR(MAX)` всегда сообщают длину 2147483647 байт для `indexer`, хотя фактическая длина, скорее всего, значительно меньше. Однако буферы для приёма данных всё равно нужно выделять заранее, и их размеры должны быть определены. Если драйвер вообще не сообщает длину столбца, Manticore выделяет по умолчанию буферы размером 1 КБ для каждого несимвольного столбца и 1 МБ для каждого символьного столбца. Сообщаемая драйвером длина столбца также ограничивается верхним пределом в 8 МБ, поэтому если драйвер сообщает (почти) 2 ГБ длины столбца, она будет ограничена, и для этого столбца будет выделен буфер размером 8 МБ. Эти жёстко заданные ограничения можно переопределить с помощью директивы `sql_column_buffers`, чтобы либо сэкономить память на фактически более коротких столбцах, либо преодолеть ограничение в 8 МБ для фактически более длинных столбцов. Значения директивы должны быть списком через запятую с именами выбранных столбцов и размерами:\n\nПример:\n\nCODE_BLOCK_12\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "c226b739438b67511d5ddd968dde3a3ddd56dc6171f6e6c9b5e8666213d3ded8": {
    "original": "# Processing fetched data\n\nBy default, the first column from the result set of `sql_query` is indexed as the document id.\n\nDocument ID *MUST* be the very first field, and it **MUST BE** UNIQUE SIGNED (NON-ZERO) INTEGER NUMBER from -9223372036854775808 to 9223372036854775807.\n\nYou can specify up to 256 full-text fields and an arbitrary amount of attributes. All the columns that are neither document ID (the first one) nor attributes will be indexed as full-text fields.\n\n## Declaration of attributes:\n\n### sql_attr_bigint\n\nDeclares a 64-bit *signed* integer.\n\n### sql_attr_bool\n\nDeclares a boolean attribute. It's equivalent to an integer attribute with bit count of 1.\n\n### sql_attr_float\n\nDeclares a floating point attribute.\n\nThe values will be stored in single precision, 32-bit IEEE 754 format. Represented range is approximately from 1e-38 to 1e+38. The amount of decimal digits that can be stored precisely is approximately 7.\n\nOne important usage of float attributes is storing latitude and longitude values (in radians), for further usage in query-time geosphere distance calculations.\n\n### sql_attr_json\n\nDeclares a JSON attribute.\n\nWhen indexing JSON attributes, Manticore expects a text field with JSON formatted data. JSON attributes support arbitrary JSON data with no limitation in nested levels or types.\n\n### sql_attr_multi\n\nDeclares a multi-value attribute.\n\nPlain attributes only allow attaching 1 value per each document. However, there are cases (such as tags or categories) when it is desired to attach multiple values of the same attribute and be able to apply filtering or grouping to value lists.\n\nThe MVA can take the values from a column (like the rest of the data types) - in this case, the column in the result set must provide a string with multiple integer values separated by commas - or by running a separate query to get the values.\n\nWhen executing a query, the engine runs the query, groups the results by IDs, and assigns the values to their corresponding documents in the table. Values with an ID not found in the table are discarded. Before executing the query, any defined `sql_query_pre_all` will be run.\n\nThe declaration format for sql_attr_multi is as follows:\n\nCODE_BLOCK_0\n\nwhere\n\n* ATTR-TYPE is `uint`, `bigint` or `timestamp`.\n\n* SOURCE-TYPE is `field`, `query`, `ranged-query`, or `ranged-main-query`.\n\n* QUERY is an optional SQL query used to fetch all (docid, attrvalue) pairs.\n\n* RANGED-QUERY is an optional SQL query used to fetch min and max ID values, similar to `sql_query_range`.\n\n* The backslashes are included for clarity only; everything can be declared in a single line as well.\n\nIt's used with ranged-query SOURCE-TYPE. If using `ranged-main-query` SOURCE-TYPE, then omit the RANGED-QUERY, and it will automatically use the same query from `sql_query_range`(useful option in complex inheritance setups to save having to manually duplicate the same query many times).\n\nCODE_BLOCK_1\n\n### sql_attr_string\n\nDeclares a string attribute. The maximum size of each value is fixed at 4GB.\n\n### sql_attr_timestamp\n\nDeclares a UNIX timestamp.\n\nTimestamps can store dates and times in the range of January 01, 1970, to January 19, 2038, with a precision of one second. The expected column value should be a timestamp in UNIX format, which is a 32-bit unsigned integer number of seconds elapsed since midnight on January 01, 1970, GMT. Timestamps are internally stored and handled as integers everywhere. In addition to working with timestamps as integers, you can also use them with different date-based functions, such as time segments sorting mode or day/week/month/year extraction for GROUP BY.\n\nNote that DATE or DATETIME column types in MySQL cannot be directly used as timestamp attributes in Manticore; you need to explicitly convert such columns using UNIX_TIMESTAMP function (if the data is in range).\n\nNote timestamps can not represent dates before January 01, 1970, and UNIX_TIMESTAMP() in MySQL will not return anything expected. If you only need to work with dates, not times, consider `TO_DAYS()` function in MySQL instead.\n\n### sql_attr_uint\n\nDeclares an unsigned integer attribute.\n\nYou can specify the bit count for integer attributes by appending ':BITCOUNT' to attribute name (see example below). Attributes with less than default 32-bit size, or bitfields, perform slower.\n\nCODE_BLOCK_2\n\n### sql_field_string\n\nDeclares a combo string attribute/text field. The values will be indexed as a full-text field, but also stored in a string attribute with the same name. Note, it should only be used when you are sure you want the field to be searchable both in a full-text manner and as an attribute (with the ability to sort and group by it). If you just want to be able to fetch the original value of the field, you don't need to do anything for it unless you implicitly removed the field from the stored fields list via [stored_fields](../../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#stored_fields).\n\nCODE_BLOCK_3\n\n### sql_file_field\n\nDeclares a file based field.\n\nThis directive makes indexer interpret field contents as a file name, and load and process the referred file. Files larger than max_file_field_buffer in size are skipped. Any errors during the file loading (IO errors, missed limits, etc.) will be reported as indexing warnings and will not early terminate the indexing. No content will be indexed for such files.\n\nCODE_BLOCK_4\n\n### sql_joined_field\n\nJoined/payload field fetch query. Multi-value, optional, the default is an empty list of queries.\n\n`sql_joined_field` lets you use two different features: joined fields and payloads (payload fields). Its syntax is as follows:\n\nCODE_BLOCK_5\n\nwhere\n\n* FIELD-NAME is a joined/payload field name\n\n* QUERY is an SQL query that must fetch values for further processing\n\n* RANGE-QUERY is an optional SQL query that fetches a range of values to process",
    "translations": {
      "chinese": "# 处理获取的数据\n\n默认情况下，`sql_query` 结果集的第一列被索引为文档 ID。\n\n文档 ID *必须* 是第一个字段，并且 **必须是** 唯一的有符号（非零）整数，范围从 -9223372036854775808 到 9223372036854775807。\n\n您可以指定最多 256 个全文字段和任意数量的属性。所有既不是文档 ID（第一列）也不是属性的列将被索引为全文字段。\n\n## 属性声明：\n\n### sql_attr_bigint\n\n声明一个 64 位*有符号*整数。\n\n### sql_attr_bool\n\n声明一个布尔属性。它等同于位数为 1 的整数属性。\n\n### sql_attr_float\n\n声明一个浮点属性。\n\n值将以单精度、32 位 IEEE 754 格式存储。表示范围大约从 1e-38 到 1e+38。可以精确存储的小数位数大约为 7 位。\n\n浮点属性的一个重要用途是存储纬度和经度值（以弧度为单位），以便在查询时进行地球距离计算。\n\n### sql_attr_json\n\n声明一个 JSON 属性。\n\n在索引 JSON 属性时，Manticore 期望文本字段包含 JSON 格式的数据。JSON 属性支持任意 JSON 数据，没有嵌套层级或类型的限制。\n\n### sql_attr_multi\n\n声明一个多值属性。\n\n普通属性每个文档只允许附加一个值。然而，有些情况（如标签或类别）希望附加同一属性的多个值，并能够对值列表进行过滤或分组。\n\nMVA 可以从列中获取值（像其他数据类型一样）——在这种情况下，结果集中的列必须提供一个由逗号分隔的多个整数值的字符串——或者通过运行单独的查询来获取值。\n\n执行查询时，引擎运行查询，按 ID 分组结果，并将值分配给表中对应的文档。未在表中找到的 ID 的值将被丢弃。执行查询前，将运行任何定义的 `sql_query_pre_all`。\n\nsql_attr_multi 的声明格式如下：\n\nCODE_BLOCK_0\n\n其中\n\n* ATTR-TYPE 是 `uint`、`bigint` 或 `timestamp`。\n\n* SOURCE-TYPE 是 `field`、`query`、`ranged-query` 或 `ranged-main-query`。\n\n* QUERY 是一个可选的 SQL 查询，用于获取所有 (docid, attrvalue) 对。\n\n* RANGED-QUERY 是一个可选的 SQL 查询，用于获取最小和最大 ID 值，类似于 `sql_query_range`。\n\n* 反斜杠仅为清晰起见；所有内容也可以声明在一行中。\n\n它用于 ranged-query SOURCE-TYPE。如果使用 `ranged-main-query` SOURCE-TYPE，则省略 RANGED-QUERY，它将自动使用 `sql_query_range` 中的相同查询（在复杂继承设置中非常有用，避免手动多次复制相同查询）。\n\nCODE_BLOCK_1\n\n### sql_attr_string\n\n声明一个字符串属性。每个值的最大大小固定为 4GB。\n\n### sql_attr_timestamp\n\n声明一个 UNIX 时间戳。\n\n时间戳可以存储从 1970 年 1 月 1 日到 2038 年 1 月 19 日的日期和时间，精度为一秒。期望的列值应为 UNIX 格式的时间戳，即自 1970 年 1 月 1 日午夜 GMT 起经过的秒数的 32 位无符号整数。时间戳在内部作为整数存储和处理。除了作为整数使用时间戳外，还可以使用不同的基于日期的函数，如时间段排序模式或用于 GROUP BY 的日/周/月/年提取。\n\n注意，MySQL 中的 DATE 或 DATETIME 列类型不能直接用作 Manticore 中的时间戳属性；需要显式使用 UNIX_TIMESTAMP 函数转换此类列（如果数据在范围内）。\n\n注意时间戳不能表示 1970 年 1 月 1 日之前的日期，MySQL 中的 UNIX_TIMESTAMP() 不会返回预期结果。如果只需要处理日期而非时间，建议使用 MySQL 中的 `TO_DAYS()` 函数。\n\n### sql_attr_uint\n\n声明一个无符号整数属性。\n\n您可以通过在属性名后附加 ':BITCOUNT' 来指定整数属性的位数（见下面示例）。位数小于默认 32 位或位字段的属性性能较慢。\n\nCODE_BLOCK_2\n\n### sql_field_string\n\n声明一个组合字符串属性/文本字段。值将被索引为全文字段，同时也存储在同名的字符串属性中。注意，只有当您确定希望该字段既能全文搜索又能作为属性（支持排序和分组）时，才应使用此项。如果您只想获取字段的原始值，除非您通过 [stored_fields](../../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#stored_fields) 显式移除了字段，否则无需做任何操作。\n\nCODE_BLOCK_3\n\n### sql_file_field\n\n声明一个基于文件的字段。\n\n此指令使索引器将字段内容解释为文件名，并加载处理所指文件。大于 max_file_field_buffer 的文件将被跳过。文件加载期间的任何错误（IO 错误、超出限制等）将作为索引警告报告，不会提前终止索引。此类文件不会被索引任何内容。\n\nCODE_BLOCK_4\n\n### sql_joined_field\n\n连接/负载字段获取查询。多值，可选，默认是空查询列表。\n\n`sql_joined_field` 允许您使用两种不同功能：连接字段和负载字段（payload fields）。其语法如下：\n\nCODE_BLOCK_5\n\n其中\n\n* FIELD-NAME 是连接/负载字段名\n\n* QUERY 是必须获取值以供进一步处理的 SQL 查询\n\n* RANGE-QUERY 是可选的 SQL 查询，用于获取要处理的值范围",
      "russian": "# Обработка полученных данных\n\nПо умолчанию первый столбец из набора результатов `sql_query` индексируется как идентификатор документа.\n\nИдентификатор документа *ДОЛЖЕН* быть самым первым полем, и он **ДОЛЖЕН БЫТЬ** УНИКАЛЬНЫМ ЗНАКОВЫМ (НЕ НУЛЕВЫМ) ЦЕЛЫМ ЧИСЛОМ от -9223372036854775808 до 9223372036854775807.\n\nВы можете указать до 256 полнотекстовых полей и произвольное количество атрибутов. Все столбцы, которые не являются ни идентификатором документа (первым), ни атрибутами, будут индексироваться как полнотекстовые поля.\n\n## Объявление атрибутов:\n\n### sql_attr_bigint\n\nОбъявляет 64-битное *знаковое* целое число.\n\n### sql_attr_bool\n\nОбъявляет булев атрибут. Это эквивалентно целочисленному атрибуту с битовой длиной 1.\n\n### sql_attr_float\n\nОбъявляет атрибут с плавающей точкой.\n\nЗначения будут храниться в формате одинарной точности, 32-битном IEEE 754. Представляемый диапазон примерно от 1e-38 до 1e+38. Количество десятичных знаков, которые могут быть сохранены точно, примерно равно 7.\n\nОдно из важных применений атрибутов с плавающей точкой — хранение значений широты и долготы (в радианах) для дальнейшего использования в вычислениях геосферного расстояния во время запроса.\n\n### sql_attr_json\n\nОбъявляет JSON-атрибут.\n\nПри индексировании JSON-атрибутов Manticore ожидает текстовое поле с данными в формате JSON. JSON-атрибуты поддерживают произвольные JSON-данные без ограничений по уровню вложенности или типам.\n\n### sql_attr_multi\n\nОбъявляет атрибут с множественными значениями.\n\nОбычные атрибуты позволяют прикреплять только 1 значение к каждому документу. Однако бывают случаи (например, теги или категории), когда требуется прикрепить несколько значений одного и того же атрибута и иметь возможность применять фильтрацию или группировку по спискам значений.\n\nMVA может принимать значения из столбца (как и остальные типы данных) — в этом случае столбец в наборе результатов должен содержать строку с несколькими целочисленными значениями, разделёнными запятыми — или путем выполнения отдельного запроса для получения значений.\n\nПри выполнении запроса движок выполняет запрос, группирует результаты по ID и присваивает значения соответствующим документам в таблице. Значения с ID, не найденным в таблице, отбрасываются. Перед выполнением запроса будет выполнен любой определённый `sql_query_pre_all`.\n\nФормат объявления sql_attr_multi следующий:\n\nCODE_BLOCK_0\n\nгде\n\n* ATTR-TYPE — это `uint`, `bigint` или `timestamp`.\n\n* SOURCE-TYPE — это `field`, `query`, `ranged-query` или `ranged-main-query`.\n\n* QUERY — необязательный SQL-запрос, используемый для получения всех пар (docid, attrvalue).\n\n* RANGED-QUERY — необязательный SQL-запрос, используемый для получения минимальных и максимальных значений ID, аналогично `sql_query_range`.\n\n* Обратные слэши включены только для наглядности; всё можно объявить и в одной строке.\n\nИспользуется с SOURCE-TYPE типа ranged-query. Если используется SOURCE-TYPE `ranged-main-query`, то RANGED-QUERY опускается, и автоматически будет использован тот же запрос из `sql_query_range` (полезная опция в сложных настройках наследования, чтобы не дублировать один и тот же запрос много раз вручную).\n\nCODE_BLOCK_1\n\n### sql_attr_string\n\nОбъявляет строковый атрибут. Максимальный размер каждого значения фиксирован и составляет 4 ГБ.\n\n### sql_attr_timestamp\n\nОбъявляет UNIX timestamp.\n\nТаймстампы могут хранить даты и время в диапазоне с 1 января 1970 года по 19 января 2038 года с точностью до одной секунды. Ожидаемое значение столбца — это timestamp в формате UNIX, который представляет собой 32-битное беззнаковое целое число секунд, прошедших с полуночи 1 января 1970 года по Гринвичу. Таймстампы внутренне хранятся и обрабатываются как целые числа повсеместно. Помимо работы с таймстампами как с целыми числами, вы также можете использовать их с различными функциями, основанными на дате, такими как режим сортировки по временным сегментам или извлечение дня/недели/месяца/года для GROUP BY.\n\nОбратите внимание, что типы столбцов DATE или DATETIME в MySQL не могут напрямую использоваться как атрибуты timestamp в Manticore; необходимо явно преобразовывать такие столбцы с помощью функции UNIX_TIMESTAMP (если данные находятся в диапазоне).\n\nОбратите внимание, что таймстампы не могут представлять даты до 1 января 1970 года, и UNIX_TIMESTAMP() в MySQL не вернёт ожидаемых значений. Если вам нужно работать только с датами, а не с временем, рассмотрите функцию `TO_DAYS()` в MySQL.\n\n### sql_attr_uint\n\nОбъявляет беззнаковый целочисленный атрибут.\n\nВы можете указать количество бит для целочисленных атрибутов, добавив ':BITCOUNT' к имени атрибута (см. пример ниже). Атрибуты с размером меньше стандартных 32 бит или битовые поля работают медленнее.\n\nCODE_BLOCK_2\n\n### sql_field_string\n\nОбъявляет комбинированный строковый атрибут/текстовое поле. Значения будут индексироваться как полнотекстовое поле, но также храниться в строковом атрибуте с тем же именем. Обратите внимание, что это следует использовать только если вы уверены, что хотите, чтобы поле было доступно для поиска как полнотекстово, так и как атрибут (с возможностью сортировки и группировки по нему). Если вы просто хотите иметь возможность получить исходное значение поля, вам ничего делать не нужно, если только вы явно не удалили поле из списка хранимых полей через [stored_fields](../../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#stored_fields).\n\nCODE_BLOCK_3\n\n### sql_file_field\n\nОбъявляет поле на основе файла.\n\nЭта директива заставляет индексатор интерпретировать содержимое поля как имя файла и загружать и обрабатывать указанный файл. Файлы, размер которых превышает max_file_field_buffer, пропускаются. Любые ошибки при загрузке файла (ошибки ввода-вывода, превышение лимитов и т. п.) будут зарегистрированы как предупреждения индексирования и не приведут к преждевременному завершению индексирования. Для таких файлов содержимое индексироваться не будет.\n\nCODE_BLOCK_4\n\n### sql_joined_field\n\nЗапрос для получения объединённого/пейлоадного поля. Множественное значение, необязательное, по умолчанию пустой список запросов.\n\n`sql_joined_field` позволяет использовать две разные функции: объединённые поля и пейлоады (payload-поля). Его синтаксис следующий:\n\nCODE_BLOCK_5\n\nгде\n\n* FIELD-NAME — имя объединённого/пейлоадного поля\n\n* QUERY — SQL-запрос, который должен получать значения для дальнейшей обработки\n\n* RANGE-QUERY — необязательный SQL-запрос, который получает диапазон значений для обработки"
    },
    "is_code_or_comment": false
  }
}
