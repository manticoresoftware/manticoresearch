{
  "0860ec6b634201ef29f213f48d095a3d22babd4fe9a837e35e7c4902f25b48c3": {
    "original": "# Ranged queries\n\nMain query, which needs to fetch all the documents, can impose a read lock on the whole table and stall the concurrent queries (e.g. INSERTs to MyISAM table), waste a lot of memory for result set, etc. To avoid this, Manticore supports so-called *ranged queries*. With ranged queries, Manticore first fetches min and max document IDs from the table, and then substitutes different ID intervals into main query text and runs the modified query to fetch another chunk of documents. Here's an example.\n\nRanged query usage example:\n\nCODE_BLOCK_0\n\nIf the table contains document IDs from 1 to, say, 2345, then sql_query would be run three times:\n\n1.  with `$start` replaced with 1 and `$end` replaced with 1000;\n\n2.  with `$start` replaced with 1001 and `$end` replaced with 2000;\n\n3.  with `$start` replaced with 2001 and `$end` replaced with 2345.\n\nObviously, that's not much of a difference for 2000-row table, but when it comes to indexing 10-million-row table, ranged queries might be of some help.\n\n### sql_query_range\n\nDefines the range query. The query specified in this option must fetch min and max document IDs that will be used as range boundaries. It must return exactly two integer fields, min ID first and max ID second; the field names are ignored. When enabled, `sql_query` will be required to contain $start and $end macros. Note that the intervals specified by $start..$end will not overlap, so you should not remove document IDs that are exactly equal to $start or $end from your query.\n\n### sql_range_step\n\nThis directive defines the range query step. The default value is 1024.\n\n### sql_ranged_throttle\n\nThis directive can be used to throttle the ranged query. By default, there is no throttling. Values for sql_ranged_throttle should be specified in milliseconds.\n\nThrottling can be useful when the indexer imposes too much load on the database server. It causes the indexer to sleep for a given amount of time once per each ranged query step. This sleep is unconditional and is performed before the fetch query.\n\nCODE_BLOCK_1\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 范围查询\n\n主查询需要获取所有文档，可能会对整个表施加读锁并阻塞并发查询（例如对 MyISAM 表的 INSERT），浪费大量内存用于结果集等。为避免这种情况，Manticore 支持所谓的*范围查询*。使用范围查询时，Manticore 首先从表中获取最小和最大文档 ID，然后将不同的 ID 区间替换到主查询文本中，运行修改后的查询以获取另一批文档。以下是一个示例。\n\n范围查询使用示例：\n\nCODE_BLOCK_0\n\n如果表中包含从 1 到 2345 的文档 ID，则 sql_query 会运行三次：\n\n1.  将 `$start` 替换为 1，`$end` 替换为 1000；\n\n2.  将 `$start` 替换为 1001，`$end` 替换为 2000；\n\n3.  将 `$start` 替换为 2001，`$end` 替换为 2345。\n\n显然，对于 2000 行的表来说，这差别不大，但当涉及到索引 1000 万行的表时，范围查询可能会有所帮助。\n\n### sql_query_range\n\n定义范围查询。此选项中指定的查询必须获取将用作范围边界的最小和最大文档 ID。它必须返回恰好两个整数字段，先是最小 ID，后是最大 ID；字段名会被忽略。启用后，`sql_query` 需要包含 $start 和 $end 宏。注意，$start..$end 指定的区间不会重叠，因此不应从查询中移除恰好等于 $start 或 $end 的文档 ID。\n\n### sql_range_step\n\n此指令定义范围查询的步长。默认值为 1024。\n\n### sql_ranged_throttle\n\n此指令可用于限制范围查询的速度。默认情况下，没有限速。sql_ranged_throttle 的值应以毫秒为单位指定。\n\n当索引器对数据库服务器施加过大负载时，限速非常有用。它会导致索引器在每个范围查询步长执行前无条件休眠指定时间。\n\nCODE_BLOCK_1\n\n<!-- proofread -->",
      "russian": "# Диапазонные запросы\n\nОсновной запрос, который должен получить все документы, может наложить блокировку на чтение всей таблицы и задержать параллельные запросы (например, INSERT в таблицу MyISAM), расходовать много памяти на набор результатов и т.д. Чтобы избежать этого, Manticore поддерживает так называемые *диапазонные запросы*. С диапазонными запросами Manticore сначала получает минимальные и максимальные ID документов из таблицы, а затем подставляет разные интервалы ID в текст основного запроса и выполняет изменённый запрос для получения следующей части документов. Вот пример.\n\nПример использования диапазонного запроса:\n\nCODE_BLOCK_0\n\nЕсли таблица содержит ID документов от 1 до, скажем, 2345, то sql_query будет выполнен три раза:\n\n1.  с заменой `$start` на 1 и `$end` на 1000;\n\n2.  с заменой `$start` на 1001 и `$end` на 2000;\n\n3.  с заменой `$start` на 2001 и `$end` на 2345.\n\nОчевидно, что для таблицы из 2000 строк это не сильно отличается, но при индексировании таблицы из 10 миллионов строк диапазонные запросы могут оказаться полезными.\n\n### sql_query_range\n\nОпределяет диапазонный запрос. Запрос, указанный в этой опции, должен получить минимальные и максимальные ID документов, которые будут использоваться в качестве границ диапазона. Он должен возвращать ровно два целочисленных поля: сначала минимальный ID, затем максимальный; имена полей игнорируются. При включении этой опции `sql_query` должен содержать макросы $start и $end. Обратите внимание, что интервалы, заданные $start..$end, не будут пересекаться, поэтому не следует исключать из запроса документы с ID, точно равными $start или $end.\n\n### sql_range_step\n\nЭта директива задаёт шаг диапазонного запроса. Значение по умолчанию — 1024.\n\n### sql_ranged_throttle\n\nЭта директива может использоваться для ограничения скорости выполнения диапазонного запроса. По умолчанию ограничение отсутствует. Значения для sql_ranged_throttle указываются в миллисекундах.\n\nОграничение скорости может быть полезно, когда индексатор создаёт слишком большую нагрузку на сервер базы данных. Оно заставляет индексатор приостанавливаться на заданное время один раз за каждый шаг диапазонного запроса. Эта пауза выполняется безусловно и происходит перед выполнением запроса выборки.\n\nCODE_BLOCK_1\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
