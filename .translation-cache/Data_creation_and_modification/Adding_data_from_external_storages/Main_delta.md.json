{
  "1f044da5d32da87254edb34af7abcdbcf03b1bef1f1e47cee64ca2834903ba74": {
    "original": "# Main+delta schema\n\n<!-- example maindelta -->\n\nIn many situations, the total dataset is too large to be frequently rebuilt from scratch, while the number of new records remains relatively small. For example, a forum may have 1,000,000 archived posts but only receive 1,000 new posts per day.\n\nIn such cases, implementing \"live\" (nearly real-time) table updates can be achieved using a \"main+delta\" scheme.\n\nThe concept involves setting up two sources and two tables, with one \"main\" table for data that rarely changes (if ever), and one \"delta\" table for new documents. In the example, the 1,000,000 archived posts would be stored in the main table, while the 1,000 new daily posts would be placed in the delta table. The delta table can then be rebuilt frequently, making the documents available for searching within seconds or minutes. Determining which documents belong to which table and rebuilding the main table can be fully automated. One approach is to create a counter table that tracks the ID used to split the documents and update it whenever the main table is rebuilt.\n\nUsing a timestamp column as the split variable is more effective than using the ID since timestamps can track not only new documents but also modified ones.\n\nFor datasets that may contain modified or deleted documents, the delta table should provide a list of affected documents, ensuring they are suppressed and excluded from search queries. This is accomplished using a feature called Kill Lists. The document IDs to be killed can be specified in an auxiliary query defined by [sql_query_killlist](../../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#Table-kill-list). The delta table must indicate the target tables for which the kill lists will be applied using the [killlist_target](../../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#killlist_target) directive. The impact of kill lists is permanent on the target table, meaning that even if a search is performed without the delta table, the suppressed documents will not appear in the search results.\n\nNotice how we're overriding `sql_query_pre` in the delta source. We must explicitly include this override. If we don't, the `REPLACE` query would be executed during the delta source's build as well, effectively rendering it useless.\n\n<!-- request Example -->\n\nCODE_BLOCK_0\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 主+增量方案\n\n<!-- example maindelta -->\n\n在许多情况下，整个数据集过大，无法频繁地从头重建，而新增记录的数量相对较少。例如，一个论坛可能有1,000,000条存档帖子，但每天只收到1,000条新帖子。\n\n在这种情况下，可以使用“主+增量”方案实现“实时”（近实时）表更新。\n\n该概念涉及设置两个源和两张表，一张“主”表用于存储很少变化（如果有的话）的数据，另一张“增量”表用于存储新文档。在示例中，1,000,000条存档帖子存储在主表中，而每天新增的1,000条帖子存储在增量表中。增量表可以频繁重建，使文档在几秒或几分钟内可供搜索。确定哪些文档属于哪张表以及重建主表可以完全自动化。一种方法是创建一个计数器表，跟踪用于划分文档的ID，并在主表重建时更新它。\n\n使用时间戳列作为划分变量比使用ID更有效，因为时间戳不仅可以跟踪新文档，还可以跟踪被修改的文档。\n\n对于可能包含被修改或删除文档的数据集，增量表应提供受影响文档的列表，确保它们被屏蔽并从搜索查询中排除。这是通过称为“杀死列表”的功能实现的。要杀死的文档ID可以在辅助查询中指定，该查询由[sql_query_killlist](../../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#Table-kill-list)定义。增量表必须使用[killlist_target](../../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#killlist_target)指令指明杀死列表将应用于的目标表。杀死列表对目标表的影响是永久性的，这意味着即使在没有增量表的情况下执行搜索，被屏蔽的文档也不会出现在搜索结果中。\n\n注意我们在增量源中重写了`sql_query_pre`。我们必须显式包含此重写。如果不这样做，`REPLACE`查询也会在增量源构建期间执行，从而使其无效。\n\n<!-- request Example -->\n\nCODE_BLOCK_0\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "# Схема Main+delta\n\n<!-- example maindelta -->\n\nВо многих случаях общий набор данных слишком велик, чтобы его часто перестраивать с нуля, в то время как количество новых записей остается относительно небольшим. Например, на форуме может быть 1 000 000 архивных сообщений, но ежедневно поступает всего 1 000 новых сообщений.\n\nВ таких случаях реализация \"живых\" (почти в реальном времени) обновлений таблиц может быть достигнута с помощью схемы \"main+delta\".\n\nКонцепция заключается в создании двух источников и двух таблиц: одной \"главной\" таблицы для данных, которые редко меняются (если вообще меняются), и одной \"дельта\" таблицы для новых документов. В примере 1 000 000 архивных сообщений будут храниться в главной таблице, а 1 000 новых сообщений в день — в дельта-таблице. Дельта-таблицу можно часто перестраивать, делая документы доступными для поиска в течение нескольких секунд или минут. Определение, какие документы относятся к какой таблице, и перестройка главной таблицы могут быть полностью автоматизированы. Один из подходов — создать таблицу-счетчик, которая отслеживает ID, используемый для разделения документов, и обновлять её при каждой перестройке главной таблицы.\n\nИспользование столбца с временной меткой в качестве переменной разделения более эффективно, чем использование ID, поскольку временные метки позволяют отслеживать не только новые документы, но и изменённые.\n\nДля наборов данных, которые могут содержать изменённые или удалённые документы, дельта-таблица должна предоставлять список затронутых документов, гарантируя их подавление и исключение из поисковых запросов. Это достигается с помощью функции, называемой Kill Lists. ID документов, которые нужно \"убить\", можно указать в вспомогательном запросе, определённом с помощью [sql_query_killlist](../../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#Table-kill-list). Дельта-таблица должна указывать целевые таблицы, для которых будут применяться kill lists, используя директиву [killlist_target](../../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#killlist_target). Влияние kill lists является постоянным для целевой таблицы, что означает, что даже если поиск выполняется без дельта-таблицы, подавленные документы не появятся в результатах поиска.\n\nОбратите внимание, что мы переопределяем `sql_query_pre` в дельта-источнике. Мы должны явно включить это переопределение. Если мы этого не сделаем, запрос `REPLACE` будет выполнен и при построении дельта-источника, что сделает его бесполезным.\n\n<!-- request Example -->\n\nCODE_BLOCK_0\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
