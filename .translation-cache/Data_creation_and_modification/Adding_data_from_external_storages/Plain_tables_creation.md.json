{
  "774bcb53476251dea8709b3e0b5f3f6b5d9ff1ae13abff2d1b12cea858772513": {
    "original": "Plain table building RAM usage limit. Optional, default is 128 MB. Enforced memory usage limit that the `indexer` will not go above. Can be specified in bytes, or kilobytes (using K postfix), or megabytes (using M postfix); see the example. This limit will be automatically raised if set to an extremely low value causing I/O buffers to be less than 8 KB; the exact lower bound for that depends on the built data size. If the buffers are less than 256 KB, a warning will be produced.\n\nThe maximum possible limit is 2047M. Too low values can hurt plain table building speed, but 256M to 1024M should be enough for most, if not all datasets. Setting this value too high can cause SQL server timeouts. During the document collection phase, there will be periods when the memory buffer is partially sorted and no communication with the database is performed; and the database server can timeout. You can resolve that either by raising timeouts on the SQL server side or by lowering `mem_limit`.\n\n#### on_file_field_error\n\nCODE_BLOCK_15\n\nHow to handle IO errors in file fields. Optional, default is `ignore_field`.\n\nWhen there is a problem indexing a file referenced by a file field ([sql_file_field](../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Processing_fetched_data.md#sql_file_field)), `indexer` can either process the document, assuming empty content in this particular field, or skip the document, or fail indexing entirely. `on_file_field_error` directive controls that behavior. The values it takes are:\n\n* `ignore_field`, process the current document without field;\n\n* `skip_document`, skip the current document but continue indexing;\n\n* `fail_index`, fail indexing with an error message.\n\nThe problems that can arise are: open error, size error (file too big), and data read error. Warning messages on any problem will be given at all times, regardless of the phase and the `on_file_field_error` setting.\n\nNote that with `on_file_field_error = skip_document` documents will only be ignored if problems are detected during an early check phase, and **not** during the actual file parsing phase. `indexer` will open every referenced file and check its size before doing any work, and then open it again when doing actual parsing work. So in case a file goes away between these two open attempts, the document will still be indexed.\n\n#### write_buffer\n\nCODE_BLOCK_16\n\nWrite buffer size, bytes. Optional, default is 1MB. Write buffers are used to write both temporary and final table files when indexing. Larger buffers reduce the number of required disk writes. Memory for the buffers is allocated in addition to [mem_limit](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#mem_limit). Note that several (currently up to 4) buffers for different files will be allocated, proportionally increasing the RAM usage.\n\n#### ignore_non_plain\n\nCODE_BLOCK_17\n\n`ignore_non_plain` allows you to completely ignore warnings about skipping non-plain tables. The default is 0 (not ignoring).\n\n<!-- proofread -->\n\n### Schedule indexer via systemd\n\nThere are two approaches to scheduling indexer runs. The first way is the classical method of using crontab. The second way is using a systemd timer with a user-defined schedule. To create the timer unit files, you should place them in the appropriate directory where systemd looks for such unit files. On most Linux distributions, this directory is typically `/etc/systemd/system`. Here's how to do it:\n\n1. Create a timer unit file for your custom schedule:\n\n   ```shell\n\n   cat << EOF > /etc/systemd/system/manticore-indexer@.timer\n\n   [Unit]\n\n   Description=Run Manticore Search's indexer on schedule\n\n   [Timer]\n\n   OnCalendar=minutely\n\n   RandomizedDelaySec=5m\n\n   Unit=manticore-indexer@%i.service\n\n   [Install]\n\n   WantedBy=timers.target\n\n   EOF\n\n   ```\n\n   More on the `OnCalendar` syntax and examples can be found [here](https://www.freedesktop.org/software/systemd/man/latest/systemd.time.html#Calendar%20Events).\n\n2. Edit the timer unit for your specific needs.\n\n3. Enable the timer:\n\n   ```shell\n\n   systemctl enable manticore-indexer@idx1.timer\n\n   ```\n\n4. Start the timer:\n\n   ```shell\n\n   systemctl start manticore-indexer@idx1.timer\n\n   ```\n\n5. Repeat steps 2-4 for any additional timers.",
    "translations": {
      "chinese": "纯表构建内存使用限制。可选，默认值为128 MB。强制执行的内存使用限制，`indexer` 不会超过该限制。可以以字节、千字节（使用K后缀）或兆字节（使用M后缀）指定；参见示例。如果设置为极低值导致I/O缓冲区小于8 KB，该限制将自动提高；具体下限取决于构建数据的大小。如果缓冲区小于256 KB，将发出警告。\n\n最大可能的限制是2047M。过低的值会影响纯表构建速度，但256M到1024M对于大多数（如果不是全部）数据集来说应该足够。设置此值过高可能导致SQL服务器超时。在文档收集阶段，会有内存缓冲区部分排序且不与数据库通信的时间段；数据库服务器可能会超时。您可以通过提高SQL服务器端的超时设置或降低`mem_limit`来解决此问题。\n\n#### on_file_field_error\n\nCODE_BLOCK_15\n\n如何处理文件字段中的IO错误。可选，默认值为`ignore_field`。\n\n当索引由文件字段引用的文件（[sql_file_field](../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Processing_fetched_data.md#sql_file_field)）时出现问题，`indexer` 可以处理文档，假设该字段内容为空，或者跳过文档，或者完全失败索引。`on_file_field_error` 指令控制该行为。它可以取的值有：\n\n* `ignore_field`，处理当前文档但不包含该字段；\n\n* `skip_document`，跳过当前文档但继续索引；\n\n* `fail_index`，索引失败并显示错误信息。\n\n可能出现的问题包括：打开错误、大小错误（文件过大）和数据读取错误。无论阶段和`on_file_field_error`设置如何，任何问题都会发出警告信息。\n\n注意，使用`on_file_field_error = skip_document`时，只有在早期检查阶段检测到问题时文档才会被忽略，**而不是**在实际文件解析阶段。`indexer` 会在进行任何工作之前打开每个引用的文件并检查其大小，然后在实际解析时再次打开它。因此，如果文件在这两次打开之间消失，文档仍将被索引。\n\n#### write_buffer\n\nCODE_BLOCK_16\n\n写缓冲区大小，单位字节。可选，默认值为1MB。写缓冲区用于在索引时写入临时和最终的表文件。较大的缓冲区减少所需的磁盘写入次数。缓冲区的内存分配是额外的，独立于[mem_limit](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#mem_limit)。注意，将为不同文件分配多个（目前最多4个）缓冲区，比例增加RAM使用量。\n\n#### ignore_non_plain\n\nCODE_BLOCK_17\n\n`ignore_non_plain` 允许您完全忽略关于跳过非纯表的警告。默认值为0（不忽略）。\n\n<!-- proofread -->\n\n### 通过 systemd 调度 indexer\n\n有两种调度 indexer 运行的方法。第一种是使用 crontab 的经典方法。第二种是使用带有用户定义计划的 systemd 计时器。要创建计时器单元文件，应将它们放置在 systemd 查找此类单元文件的适当目录中。在大多数 Linux 发行版中，该目录通常是 `/etc/systemd/system`。操作步骤如下：\n\n1. 为您的自定义计划创建计时器单元文件：\n\n   ```shell\n\n   cat << EOF > /etc/systemd/system/manticore-indexer@.timer\n\n   [Unit]\n\n   Description=Run Manticore Search's indexer on schedule\n\n   [Timer]\n\n   OnCalendar=minutely\n\n   RandomizedDelaySec=5m\n\n   Unit=manticore-indexer@%i.service\n\n   [Install]\n\n   WantedBy=timers.target\n\n   EOF\n\n   ```\n\n   关于 `OnCalendar` 语法和示例的更多信息，请参见[这里](https://www.freedesktop.org/software/systemd/man/latest/systemd.time.html#Calendar%20Events)。\n\n2. 根据您的具体需求编辑计时器单元。\n\n3. 启用计时器：\n\n   ```shell\n\n   systemctl enable manticore-indexer@idx1.timer\n\n   ```\n\n4. 启动计时器：\n\n   ```shell\n\n   systemctl start manticore-indexer@idx1.timer\n\n   ```\n\n5. 对任何额外的计时器重复步骤2-4。",
      "russian": "Plain table building RAM usage limit. Optional, default is 128 MB. Enforced memory usage limit that the `indexer` will not go above. Can be specified in bytes, or kilobytes (using K postfix), or megabytes (using M postfix); see the example. This limit will be automatically raised if set to an extremely low value causing I/O buffers to be less than 8 KB; the exact lower bound for that depends on the built data size. If the buffers are less than 256 KB, a warning will be produced.\n\nМаксимально возможный лимит — 2047M. Слишком низкие значения могут замедлить построение plain table, но 256M до 1024M должно быть достаточно для большинства, если не всех наборов данных. Установка слишком высокого значения может привести к тайм-аутам SQL сервера. Во время фазы сбора документов будут периоды, когда буфер памяти частично отсортирован и связь с базой данных не выполняется; и сервер базы данных может прервать соединение по тайм-ауту. Вы можете решить эту проблему либо увеличив тайм-ауты на стороне SQL сервера, либо уменьшив `mem_limit`.\n\n#### on_file_field_error\n\nCODE_BLOCK_15\n\nКак обрабатывать ошибки ввода-вывода в файловых полях. Необязательно, по умолчанию `ignore_field`.\n\nКогда возникает проблема с индексированием файла, на который ссылается файловое поле ([sql_file_field](../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Processing_fetched_data.md#sql_file_field)), `indexer` может либо обработать документ, предполагая пустое содержимое в этом конкретном поле, либо пропустить документ, либо полностью завершить индексирование с ошибкой. Директива `on_file_field_error` контролирует это поведение. Возможные значения:\n\n* `ignore_field`, обработать текущий документ без поля;\n\n* `skip_document`, пропустить текущий документ, но продолжить индексирование;\n\n* `fail_index`, завершить индексирование с сообщением об ошибке.\n\nПроблемы, которые могут возникнуть: ошибка открытия, ошибка размера (файл слишком большой) и ошибка чтения данных. Предупреждающие сообщения о любой проблеме будут выдаваться всегда, независимо от фазы и настройки `on_file_field_error`.\n\nОбратите внимание, что при `on_file_field_error = skip_document` документы будут игнорироваться только если проблемы обнаружены на ранней фазе проверки, и **не** во время фактического разбора файла. `indexer` откроет каждый указанный файл и проверит его размер перед началом работы, а затем откроет его снова при фактическом разборе. Поэтому, если файл исчезнет между этими двумя попытками открытия, документ всё равно будет проиндексирован.\n\n#### write_buffer\n\nCODE_BLOCK_16\n\nРазмер буфера записи, в байтах. Необязательно, по умолчанию 1MB. Буферы записи используются для записи как временных, так и окончательных файлов таблиц при индексировании. Большие буферы уменьшают количество необходимых операций записи на диск. Память для буферов выделяется дополнительно к [mem_limit](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#mem_limit). Обратите внимание, что будет выделено несколько (в настоящее время до 4) буферов для разных файлов, что пропорционально увеличивает использование ОЗУ.\n\n#### ignore_non_plain\n\nCODE_BLOCK_17\n\n`ignore_non_plain` позволяет полностью игнорировать предупреждения о пропуске не-plain таблиц. По умолчанию 0 (не игнорировать).\n\n<!-- proofread -->\n\n### Schedule indexer via systemd\n\nСуществует два подхода к планированию запусков indexer. Первый способ — классический метод с использованием crontab. Второй способ — использование таймера systemd с пользовательским расписанием. Чтобы создать файлы юнитов таймера, их нужно поместить в соответствующий каталог, где systemd ищет такие файлы юнитов. В большинстве дистрибутивов Linux этот каталог обычно `/etc/systemd/system`. Вот как это сделать:\n\n1. Создайте файл юнита таймера для вашего пользовательского расписания:\n\n   ```shell\n\n   cat << EOF > /etc/systemd/system/manticore-indexer@.timer\n\n   [Unit]\n\n   Description=Run Manticore Search's indexer on schedule\n\n   [Timer]\n\n   OnCalendar=minutely\n\n   RandomizedDelaySec=5m\n\n   Unit=manticore-indexer@%i.service\n\n   [Install]\n\n   WantedBy=timers.target\n\n   EOF\n\n   ```\n\n   Подробнее о синтаксисе и примерах `OnCalendar` можно найти [здесь](https://www.freedesktop.org/software/systemd/man/latest/systemd.time.html#Calendar%20Events).\n\n2. Отредактируйте юнит таймера под свои нужды.\n\n3. Включите таймер:\n\n   ```shell\n\n   systemctl enable manticore-indexer@idx1.timer\n\n   ```\n\n4. Запустите таймер:\n\n   ```shell\n\n   systemctl start manticore-indexer@idx1.timer\n\n   ```\n\n5. Повторите шаги 2-4 для любых дополнительных таймеров."
    },
    "is_code_or_comment": false
  },
  "014d576e6289db962531b0b31032c3589e5cf2c2e38e6f4fabe2f58623af7166": {
    "original": "# Plain tables creation\n\nPlain tables are tables that are created one-time by fetching data at creation from one or several sources. A plain table is immutable as documents cannot be added or deleted during its lifespan. It is only possible to update values of numeric attributes (including MVA). Refreshing the data is only possible by recreating the whole table.\n\nPlain tables are available only in the [Plain mode](../../Creating_a_table/Local_tables.md#Defining-table-schema-in-config-%28Plain mode%29) and their definition is made up of a table declaration and one or several source declarations. The data gathering and table creation are not made by the `searchd` server but by the auxiliary tool `indexer`.\n\n**Indexer** is a command-line tool that can be called directly from the command line or from shell scripts.\n\nIt can accept a number of arguments when called, but there are also several settings of its own in the Manticore configuration file.\n\nIn the typical scenario, indexer does the following:\n\n* Fetches the data from the source\n\n* Builds the plain table\n\n* Writes the table files\n\n* (Optional) Informs the search server about the new table which triggers table rotation\n\n## Indexer tool\n\nThe `indexer` tool is used to create plain tables in Manticore Search. It has a general syntax of:\n\nCODE_BLOCK_0\n\nWhen creating tables with `indexer`, the generated table files must be made with permissions that allow `searchd` to read, write, and delete them. In case of the official Linux packages, `searchd` runs under the `manticore` user. Therefore, `indexer` must also run under the `manticore` user:\n\nCODE_BLOCK_1\n\nIf you are running `searchd` differently, you might need to omit `sudo -u manticore`. Just make sure that the user under which your `searchd` instance is running has read/write permissions to the tables generated using `indexer`.\n\nTo create a plain table, you need to list the table(s) you want to process. For example, if your `manticore.conf` file contains details on two tables, `mybigindex` and `mysmallindex`, you could run:\n\nCODE_BLOCK_2\n\nYou can also use wildcard tokens to match table names:\n\n* `?` matches any single character\n\n* `*` matches any count of any characters\n\n* `%` matches none or any single character\n\nCODE_BLOCK_3\n\nThe exit codes for indexer are as follows:\n\n* 0: everything went OK\n\n* 1: there was a problem while indexing (and if `--rotate` was specified, it was skipped) or an operation emitted a warning\n\n* 2: indexing went OK, but the `--rotate` attempt failed\n\n### Indexer systemd service\n\nYou can also start `indexer` using the following systemctl unit file:\n\nCODE_BLOCK_4\n\nOr, in case you want to build a specific table:\n\nCODE_BLOCK_5\n\nUse the `systemctl set-environment INDEXER_CONFIG` command to run the Indexer with a custom configuration, which replaces the default settings.\n\nThe `systemctl set-environment INDEXER_ARGS` command lets you add custom startup options for the Indexer. For a complete list of command-line options, see [here](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#Indexer-command-line-arguments).\n\nFor instance, to start the Indexer in quiet mode, run:\n\nCODE_BLOCK_6\n\nTo revert the changes, run:\n\nCODE_BLOCK_7\n\n### Indexer command line arguments\n\n* `--config <file>` (`-c <file>` for short) tells `indexer` to use the given file as its configuration. Normally, it will look for `manticore.conf` in the installation directory (e.g. `/etc/manticoresearch/manticore.conf`), followed by the current directory you are in when calling `indexer` from the shell. This is most useful in shared environments where the binary files are installed in a global folder, e.g. `/usr/bin/`, but you want to provide users with the ability to make their own custom Manticore set-ups, or if you want to run multiple instances on a single server. In cases like those you could allow them to create their own `manticore.conf` files and pass them to `indexer` with this option. For example:\n\n  ```shell\n\n  sudo -u manticore indexer --config /home/myuser/manticore.conf mytable\n\n  ```\n\n* `--all` tells `indexer` to update every table listed in `manticore.conf` instead of listing individual tables. This would be useful in small configurations or cron-kind or maintenance jobs where the entire table set will get rebuilt each day or week or whatever period is best. Please note that since `--all` tries to update all found tables in the configuration, it will issue a warning if it encounters RealTime tables and the exit code of the command will be `1` not `0` even if the plain tables finished without issue. Example usage:\n\n  ```shell\n\n  sudo -u manticore indexer --config /home/myuser/manticore.conf --all\n\n  ```\n\n* `--rotate` is used for rotating tables. Unless you have the situation where you can take the search function offline without troubling users you will almost certainly need to keep search running whilst indexing new documents. `--rotate` creates a second table, parallel to the first (in the same place, simply including `.new` in the filenames). Once complete, `indexer` notifies `searchd` via sending the `SIGHUP` signal, and the `searchd` will attempt to rename the tables (renaming the existing ones to include `.old` and renaming the `.new` to replace them), and then will start serving from the newer files. Depending on the setting of [seamless_rotate](../../Server_settings/Searchd.md#seamless_rotate) there may be a slight delay in being able to search the newer tables. In case multiple tables are rotated at once which are chained by [killlist_target](../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#killlist_target) relations rotation will start with the tables that are not targets and finish with the ones at the end of target chain. Example usage:\n\n  ```shell\n\n  sudo -u manticore indexer --rotate --all\n\n  ```\n\n* `--quiet` tells `indexer` ot to output anything, unless there is an error. This is mostly used for cron-type or other scripted jobs where the output is irrelevant or unnecessary, except in the event of some kind of error. Example usage:\n\n  ```shell",
    "translations": {
      "chinese": "# 纯表创建\n\n纯表是通过在创建时从一个或多个源获取数据一次性创建的表。纯表是不可变的，因为在其生命周期内无法添加或删除文档。只能更新数值属性（包括 MVA）的值。刷新数据只能通过重新创建整个表来实现。\n\n纯表仅在[纯模式](../../Creating_a_table/Local_tables.md#Defining-table-schema-in-config-%28Plain mode%29)中可用，其定义由表声明和一个或多个源声明组成。数据收集和表创建不是由 `searchd` 服务器完成，而是由辅助工具 `indexer` 完成。\n\n**Indexer** 是一个命令行工具，可以直接从命令行或 shell 脚本调用。\n\n调用时它可以接受多个参数，但在 Manticore 配置文件中也有一些自身的设置。\n\n在典型场景中，indexer 执行以下操作：\n\n* 从源获取数据\n\n* 构建纯表\n\n* 写入表文件\n\n* （可选）通知搜索服务器新表，触发表轮换\n\n## Indexer 工具\n\n`indexer` 工具用于在 Manticore Search 中创建纯表。其通用语法为：\n\nCODE_BLOCK_0\n\n使用 `indexer` 创建表时，生成的表文件必须具有允许 `searchd` 读取、写入和删除的权限。在官方 Linux 包中，`searchd` 以 `manticore` 用户身份运行。因此，`indexer` 也必须以 `manticore` 用户身份运行：\n\nCODE_BLOCK_1\n\n如果你以不同方式运行 `searchd`，可能需要省略 `sudo -u manticore`。只需确保运行 `searchd` 实例的用户对使用 `indexer` 生成的表具有读写权限。\n\n要创建纯表，需要列出要处理的表。例如，如果你的 `manticore.conf` 文件包含两个表的详细信息，`mybigindex` 和 `mysmallindex`，你可以运行：\n\nCODE_BLOCK_2\n\n你也可以使用通配符匹配表名：\n\n* `?` 匹配任意单个字符\n\n* `*` 匹配任意数量的任意字符\n\n* `%` 匹配无或任意单个字符\n\nCODE_BLOCK_3\n\nindexer 的退出代码如下：\n\n* 0：一切正常\n\n* 1：索引时出现问题（如果指定了 `--rotate`，则跳过）或操作发出警告\n\n* 2：索引正常，但 `--rotate` 尝试失败\n\n### Indexer systemd 服务\n\n你也可以使用以下 systemctl 单元文件启动 `indexer`：\n\nCODE_BLOCK_4\n\n或者，如果你想构建特定表：\n\nCODE_BLOCK_5\n\n使用 `systemctl set-environment INDEXER_CONFIG` 命令以自定义配置运行 Indexer，替代默认设置。\n\n`systemctl set-environment INDEXER_ARGS` 命令允许你为 Indexer 添加自定义启动选项。完整的命令行选项列表，请参见[这里](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#Indexer-command-line-arguments)。\n\n例如，要以静默模式启动 Indexer，运行：\n\nCODE_BLOCK_6\n\n要恢复更改，运行：\n\nCODE_BLOCK_7\n\n### Indexer 命令行参数\n\n* `--config <file>`（简写为 `-c <file>`）告诉 `indexer` 使用指定文件作为配置。通常，它会在安装目录（例如 `/etc/manticoresearch/manticore.conf`）中查找 `manticore.conf`，然后是调用 `indexer` 时所在的当前目录。这在共享环境中非常有用，例如二进制文件安装在全局文件夹（如 `/usr/bin/`），但你希望用户能够创建自己的自定义 Manticore 设置，或者你想在单台服务器上运行多个实例。在这种情况下，你可以允许他们创建自己的 `manticore.conf` 文件，并通过此选项传递给 `indexer`。例如：\n\n  ```shell\n\n  sudo -u manticore indexer --config /home/myuser/manticore.conf mytable\n\n  ```\n\n* `--all` 告诉 `indexer` 更新 `manticore.conf` 中列出的所有表，而不是列出单个表。这在小型配置或定时任务或维护作业中很有用，其中整个表集每天、每周或其他最佳周期重建。请注意，由于 `--all` 尝试更新配置中找到的所有表，如果遇到实时表会发出警告，即使纯表完成没有问题，命令的退出代码也会是 `1` 而非 `0`。示例用法：\n\n  ```shell\n\n  sudo -u manticore indexer --config /home/myuser/manticore.conf --all\n\n  ```\n\n* `--rotate` 用于轮换表。除非你能让搜索功能离线而不影响用户，否则几乎肯定需要在索引新文档时保持搜索运行。`--rotate` 创建第二个表，与第一个表并行（在同一位置，只是在文件名中包含 `.new`）。完成后，`indexer` 通过发送 `SIGHUP` 信号通知 `searchd`，`searchd` 会尝试重命名表（将现有表重命名为包含 `.old`，并将 `.new` 重命名替换它们），然后开始从新文件提供服务。根据 [seamless_rotate](../../Server_settings/Searchd.md#seamless_rotate) 的设置，搜索新表可能会有轻微延迟。如果一次轮换多个通过 [killlist_target](../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#killlist_target) 关联的表，轮换将从非目标表开始，最后完成目标链末端的表。示例用法：\n\n  ```shell\n\n  sudo -u manticore indexer --rotate --all\n\n  ```\n\n* `--quiet` 告诉 `indexer` 除非发生错误，否则不输出任何内容。这主要用于定时任务或其他脚本作业，其中输出无关紧要或不必要，除非发生错误。示例用法：\n\n  ```shell",
      "russian": "# Создание простых таблиц\n\nПростые таблицы — это таблицы, которые создаются однократно путём получения данных при создании из одного или нескольких источников. Простая таблица является неизменяемой, так как документы не могут быть добавлены или удалены в течение её жизненного цикла. Возможно только обновление значений числовых атрибутов (включая MVA). Обновление данных возможно только путём пересоздания всей таблицы.\n\nПростые таблицы доступны только в [Plain режиме](../../Creating_a_table/Local_tables.md#Defining-table-schema-in-config-%28Plain mode%29), и их определение состоит из объявления таблицы и одного или нескольких объявлений источников. Сбор данных и создание таблицы выполняются не сервером `searchd`, а вспомогательным инструментом `indexer`.\n\n**Indexer** — это инструмент командной строки, который можно вызывать напрямую из командной строки или из shell-скриптов.\n\nОн может принимать ряд аргументов при вызове, но также имеет несколько собственных настроек в конфигурационном файле Manticore.\n\nВ типичном сценарии indexer выполняет следующие действия:\n\n* Получает данные из источника\n\n* Строит простую таблицу\n\n* Записывает файлы таблицы\n\n* (Опционально) Информирует поисковый сервер о новой таблице, что запускает ротацию таблиц\n\n## Инструмент Indexer\n\nИнструмент `indexer` используется для создания простых таблиц в Manticore Search. Его общий синтаксис:\n\nCODE_BLOCK_0\n\nПри создании таблиц с помощью `indexer` сгенерированные файлы таблиц должны иметь права, позволяющие `searchd` читать, записывать и удалять их. В случае официальных пакетов для Linux `searchd` работает под пользователем `manticore`. Поэтому `indexer` также должен запускаться под пользователем `manticore`:\n\nCODE_BLOCK_1\n\nЕсли вы запускаете `searchd` иначе, возможно, потребуется опустить `sudo -u manticore`. Просто убедитесь, что пользователь, под которым работает ваш экземпляр `searchd`, имеет права на чтение/запись для таблиц, созданных с помощью `indexer`.\n\nЧтобы создать простую таблицу, нужно перечислить таблицу(ы), которые вы хотите обработать. Например, если в вашем файле `manticore.conf` содержатся сведения о двух таблицах, `mybigindex` и `mysmallindex`, вы можете выполнить:\n\nCODE_BLOCK_2\n\nВы также можете использовать подстановочные знаки для сопоставления имён таблиц:\n\n* `?` соответствует любому одному символу\n\n* `*` соответствует любому количеству любых символов\n\n* `%` соответствует отсутствию или любому одному символу\n\nCODE_BLOCK_3\n\nКоды выхода indexer следующие:\n\n* 0: всё прошло успешно\n\n* 1: возникла проблема при индексации (и если был указан `--rotate`, он был пропущен) или операция выдала предупреждение\n\n* 2: индексация прошла успешно, но попытка `--rotate` не удалась\n\n### Служба systemd для Indexer\n\nВы также можете запустить `indexer` с помощью следующего файла юнита systemctl:\n\nCODE_BLOCK_4\n\nИли, если хотите построить конкретную таблицу:\n\nCODE_BLOCK_5\n\nИспользуйте команду `systemctl set-environment INDEXER_CONFIG` для запуска Indexer с пользовательской конфигурацией, которая заменяет настройки по умолчанию.\n\nКоманда `systemctl set-environment INDEXER_ARGS` позволяет добавить пользовательские параметры запуска для Indexer. Полный список параметров командной строки смотрите [здесь](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#Indexer-command-line-arguments).\n\nНапример, чтобы запустить Indexer в тихом режиме, выполните:\n\nCODE_BLOCK_6\n\nЧтобы отменить изменения, выполните:\n\nCODE_BLOCK_7\n\n### Аргументы командной строки Indexer\n\n* `--config <file>` (`-c <file>` для краткости) указывает `indexer` использовать указанный файл в качестве конфигурации. Обычно он ищет `manticore.conf` в каталоге установки (например, `/etc/manticoresearch/manticore.conf`), затем в текущем каталоге, в котором вы вызываете `indexer` из shell. Это особенно полезно в общих средах, где бинарные файлы установлены в глобальную папку, например `/usr/bin/`, но вы хотите предоставить пользователям возможность создавать свои собственные настройки Manticore или запускать несколько экземпляров на одном сервере. В таких случаях вы можете позволить им создавать свои собственные файлы `manticore.conf` и передавать их `indexer` с помощью этой опции. Например:\n\n  ```shell\n\n  sudo -u manticore indexer --config /home/myuser/manticore.conf mytable\n\n  ```\n\n* `--all` указывает `indexer` обновить все таблицы, перечисленные в `manticore.conf`, вместо указания отдельных таблиц. Это полезно в небольших конфигурациях или для заданий cron или обслуживания, когда весь набор таблиц пересоздаётся каждый день, неделю или в другой подходящий период. Обратите внимание, что поскольку `--all` пытается обновить все найденные таблицы в конфигурации, он выдаст предупреждение, если встретит RealTime таблицы, и код выхода команды будет `1`, а не `0`, даже если простые таблицы завершились без проблем. Пример использования:\n\n  ```shell\n\n  sudo -u manticore indexer --config /home/myuser/manticore.conf --all\n\n  ```\n\n* `--rotate` используется для ротации таблиц. Если у вас нет ситуации, когда можно отключить функцию поиска без неудобств для пользователей, вам почти наверняка нужно будет держать поиск запущенным во время индексации новых документов. `--rotate` создаёт вторую таблицу, параллельную первой (в том же месте, просто с включением `.new` в имена файлов). После завершения `indexer` уведомляет `searchd` отправкой сигнала `SIGHUP`, и `searchd` пытается переименовать таблицы (переименовывая существующие с добавлением `.old` и переименовывая `.new` в их место), а затем начинает обслуживать из новых файлов. В зависимости от настройки [seamless_rotate](../../Server_settings/Searchd.md#seamless_rotate) может быть небольшая задержка перед возможностью поиска в новых таблицах. Если одновременно ротируются несколько таблиц, связанных отношениями [killlist_target](../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#killlist_target), ротация начнётся с таблиц, которые не являются целями, и закончится таблицами в конце цепочки целей. Пример использования:\n\n  ```shell\n\n  sudo -u manticore indexer --rotate --all\n\n  ```\n\n* `--quiet` указывает `indexer` не выводить ничего, кроме ошибок. Это в основном используется для заданий типа cron или других скриптов, где вывод не важен или не нужен, кроме случаев ошибок. Пример использования:\n\n  ```shell"
    },
    "is_code_or_comment": false
  },
  "7bc90ab4965c5818736ae8252b74099649d86f0d1ee4150186b57cda8a0f726b": {
    "original": "* `--dump-rows <FILE>` dumps rows fetched by SQL source(s) into the specified file, in a MySQL compatible syntax. The resulting dumps are the exact representation of data as received by `indexer` and can help repeat indexing-time issues. The command performs fetching from the source and creates both table files and the dump file.\n\n* `--print-rt <rt_index> <table>` outputs fetched data from the source as INSERTs for a real-time table. The first lines of the dump will contain the real-time fields and attributes (as a reflection of the plain table fields and attributes). The command performs fetching from the source and creates both table files and the dump output. The command can be used as `sudo -u manticore indexer -c manticore.conf --print-rt indexrt indexplain > dump.sql`. Only SQL-based sources are supported. MVAs are not supported.\n\n* `--sighup-each`  is useful when you are rebuilding many big tables and want each one rotated into `searchd` as soon as possible. With `--sighup-each`, `indexer` will send the SIGHUP signal to searchd after successfully completing work on each table. (The default behavior is to send a single SIGHUP after all the tables are built).\n\n* `--nohup` is useful when you want to check your table with indextool before actually rotating it. indexer won't send the SIGHUP if this option is on. Table files are renamed to .tmp. Use indextool to rename table files to .new and rotate it. Example usage:\n\n  ```shell\n\n  sudo -u manticore indexer --rotate --nohup mytable\n\n  sudo -u manticore indextool --rotate --check mytable\n\n  ```\n\n* `--print-queries` prints out SQL queries that `indexer` sends to the database, along with SQL connection and disconnection events. That is useful to diagnose and fix problems with SQL sources.\n\n* `--help` (`-h` for short) lists all the parameters that can be called in `indexer`.\n\n* `-v` shows `indexer` version.\n\n### Indexer configuration settings\n\nYou can also configure indexer behavior in the Manticore configuration file in the `indexer` section:\n\nCODE_BLOCK_8\n\n#### lemmatizer_cache\n\nCODE_BLOCK_9\n\nLemmatizer cache size. Optional, default is 256K.\n\nOur [lemmatizer](../../Server_settings/Common.md#lemmatizer_base) implementation uses a compressed dictionary format that enables a space/speed tradeoff. It can either perform lemmatization off the compressed data, using more CPU but less RAM, or it can decompress and precache the dictionary either partially or fully, thus using less CPU but more RAM. The lemmatizer_cache directive lets you control how much RAM exactly can be spent for that uncompressed dictionary cache.\n\nCurrently, the only available dictionaries are [ru.pak, en.pak, and de.pak](https://manticoresearch.com/install/). These are the Russian, English, and German dictionaries. The compressed dictionary is approximately 2 to 10 MB in size. Note that the dictionary stays in memory at all times too. The default cache size is 256 KB. The accepted cache sizes are 0 to 2047 MB. It's safe to raise the cache size too high; the lemmatizer will only use the needed memory. For example, the entire Russian dictionary decompresses to approximately 110 MB; thus setting`lemmatizer_cache` higher than that will not affect the memory use. Even when 1024 MB is allowed for the cache, if only 110 MB is needed, it will only use those 110 MB.\n\n#### max_file_field_buffer\n\nCODE_BLOCK_10\n\nMaximum file field adaptive buffer size in bytes. Optional, default is 8MB, minimum is 1MB.\n\nThe file field buffer is used to load files referred to from [sql_file_field](../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Processing_fetched_data.md#sql_file_field) columns. This buffer is adaptive, starting at 1 MB at first allocation, and growing in 2x steps until either the file contents can be loaded or the maximum buffer size, specified by the `max_file_field_buffer` directive, is reached.\n\nThus, if no file fields are specified, no buffer is allocated at all. If all files loaded during indexing are under (for example) 2 MB in size, but the `max_file_field_buffer` value is 128 MB, the peak buffer usage would still be only 2 MB. However, files over 128 MB would be entirely skipped.\n\n#### max_iops\n\nCODE_BLOCK_11\n\nMaximum I/O operations per second, for I/O throttling. Optional, default is 0 (unlimited).\n\nI/O throttling related option. It limits the maximum count of I/O operations (reads or writes) per any given second. A value of 0 means that no limit is imposed.\n\n`indexer` can cause bursts of intensive disk I/O during building a table, and it might be desirable to limit its disk activity (and reserve something for other programs running on the same machine, such as `searchd`). I/O throttling helps to do that. It works by enforcing a minimum guaranteed delay between subsequent disk I/O operations performed by `indexer`. Throttling I/O can help reduce search performance degradation caused by building. This setting is not effective for other kinds of data ingestion, e.g. inserting data into a real-time table.\n\n#### max_iosize\n\nCODE_BLOCK_12\n\nMaximum allowed I/O operation size, in bytes, for I/O throttling. Optional, default is 0 (unlimited).\n\nI/O throttling related option. It limits the maximum file I/O operation (read or write) size for all operations performed by `indexer`. A value of 0 means that no limit is imposed. Reads or writes that are bigger than the limit will be split into several smaller operations, and counted as several operations by the [max_iops](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#max_iops) setting. At the time of this writing, all I/O calls should be under 256 KB (default internal buffer size) anyway, so max_iosize values higher than 256 KB should not have any effect.\n\n#### max_xmlpipe2_field\n\nCODE_BLOCK_13\n\nMaximum allowed field size for XMLpipe2 source type, in bytes. Optional, default is 2 MB.\n\n#### mem_limit\n\nCODE_BLOCK_14",
    "translations": {
      "chinese": "* `--dump-rows <FILE>` 将由 SQL 源获取的行以 MySQL 兼容的语法转储到指定文件中。生成的转储是 `indexer` 接收到的数据的精确表示，有助于重复索引时出现的问题。该命令执行从源的获取，并创建表文件和转储文件。\n\n* `--print-rt <rt_index> <table>` 以 INSERT 语句的形式输出从源获取的实时表数据。转储的前几行将包含实时字段和属性（作为普通表字段和属性的反映）。该命令执行从源的获取，并创建表文件和转储输出。该命令可用作 `sudo -u manticore indexer -c manticore.conf --print-rt indexrt indexplain > dump.sql`。仅支持基于 SQL 的源。不支持 MVA。\n\n* `--sighup-each` 在重建许多大型表时非常有用，您希望每个表尽快旋转到 `searchd`。使用 `--sighup-each`，`indexer` 会在成功完成每个表的工作后向 searchd 发送 SIGHUP 信号。（默认行为是在所有表构建完成后发送单个 SIGHUP）。\n\n* `--nohup` 在您想在实际旋转表之前使用 indextool 检查表时非常有用。如果启用此选项，indexer 不会发送 SIGHUP。表文件将重命名为 .tmp。使用 indextool 将表文件重命名为 .new 并旋转它。示例用法：\n\n  ```shell\n\n  sudo -u manticore indexer --rotate --nohup mytable\n\n  sudo -u manticore indextool --rotate --check mytable\n\n  ```\n\n* `--print-queries` 打印 `indexer` 发送到数据库的 SQL 查询，以及 SQL 连接和断开事件。这对于诊断和修复 SQL 源的问题很有用。\n\n* `--help`（简写为 `-h`）列出 `indexer` 中可调用的所有参数。\n\n* `-v` 显示 `indexer` 版本。\n\n### Indexer 配置设置\n\n您还可以在 Manticore 配置文件的 `indexer` 部分配置 indexer 行为：\n\nCODE_BLOCK_8\n\n#### lemmatizer_cache\n\nCODE_BLOCK_9\n\n词形还原缓存大小。可选，默认值为 256K。\n\n我们的[词形还原器](../../Server_settings/Common.md#lemmatizer_base)实现使用压缩字典格式，支持空间与速度的权衡。它可以直接在压缩数据上执行词形还原，使用更多 CPU 但更少 RAM，或者可以部分或完全解压并预缓存字典，从而使用更少 CPU 但更多 RAM。lemmatizer_cache 指令让您控制用于未压缩字典缓存的 RAM 大小。\n\n目前，唯一可用的字典是[ru.pak、en.pak 和 de.pak](https://manticoresearch.com/install/)，分别是俄语、英语和德语字典。压缩字典大小约为 2 到 10 MB。请注意，字典始终驻留在内存中。默认缓存大小为 256 KB。接受的缓存大小范围是 0 到 2047 MB。将缓存大小设置得过高是安全的；词形还原器只会使用所需的内存。例如，整个俄语字典解压后约为 110 MB；因此将 `lemmatizer_cache` 设置高于此值不会影响内存使用。即使允许缓存为 1024 MB，如果只需 110 MB，它也只会使用这 110 MB。\n\n#### max_file_field_buffer\n\nCODE_BLOCK_10\n\n文件字段自适应缓冲区的最大大小（字节）。可选，默认值为 8MB，最小值为 1MB。\n\n文件字段缓冲区用于加载来自 [sql_file_field](../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Processing_fetched_data.md#sql_file_field) 列引用的文件。该缓冲区是自适应的，首次分配时为 1 MB，并以 2 倍的步长增长，直到文件内容可以加载或达到 `max_file_field_buffer` 指令指定的最大缓冲区大小。\n\n因此，如果未指定文件字段，则不会分配缓冲区。如果索引期间加载的所有文件大小均小于（例如）2 MB，但 `max_file_field_buffer` 值为 128 MB，则峰值缓冲区使用量仍仅为 2 MB。然而，超过 128 MB 的文件将被完全跳过。\n\n#### max_iops\n\nCODE_BLOCK_11\n\n最大每秒 I/O 操作数，用于 I/O 限速。可选，默认值为 0（无限制）。\n\n与 I/O 限速相关的选项。它限制任意给定秒内的最大 I/O 操作数（读或写）。值为 0 表示不施加限制。\n\n`indexer` 在构建表时可能会引起磁盘 I/O 的突发高峰，可能希望限制其磁盘活动（并为同一机器上运行的其他程序，如 `searchd`，保留资源）。I/O 限速有助于实现这一点。它通过强制 `indexer` 执行的连续磁盘 I/O 操作之间的最小保证延迟来工作。限制 I/O 可以帮助减少构建期间导致的搜索性能下降。此设置对其他类型的数据摄取无效，例如向实时表插入数据。\n\n#### max_iosize\n\nCODE_BLOCK_12\n\n最大允许的 I/O 操作大小（字节），用于 I/O 限速。可选，默认值为 0（无限制）。\n\n与 I/O 限速相关的选项。它限制 `indexer` 执行的所有文件 I/O 操作（读或写）的最大大小。值为 0 表示不施加限制。大于限制的读写操作将被拆分为多个较小的操作，并由 [max_iops](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#max_iops) 设置计为多个操作。撰写本文时，所有 I/O 调用应均小于 256 KB（默认内部缓冲区大小），因此 max_iosize 设置高于 256 KB 不应有任何影响。\n\n#### max_xmlpipe2_field\n\nCODE_BLOCK_13\n\nXMLpipe2 源类型允许的最大字段大小（字节）。可选，默认值为 2 MB。\n\n#### mem_limit\n\nCODE_BLOCK_14",
      "russian": "* `--dump-rows <FILE>` сохраняет строки, полученные из SQL-источника(ов), в указанный файл в синтаксисе, совместимом с MySQL. Полученные дампы являются точным представлением данных, как они получены `indexer`, и могут помочь воспроизвести проблемы, возникающие во время индексации. Команда выполняет получение данных из источника и создает как файлы таблиц, так и файл дампа.\n\n* `--print-rt <rt_index> <table>` выводит полученные данные из источника в виде INSERT-запросов для таблицы реального времени. Первые строки дампа будут содержать поля и атрибуты реального времени (как отражение полей и атрибутов обычной таблицы). Команда выполняет получение данных из источника и создает как файлы таблиц, так и вывод дампа. Команду можно использовать как `sudo -u manticore indexer -c manticore.conf --print-rt indexrt indexplain > dump.sql`. Поддерживаются только источники на основе SQL. MVAs не поддерживаются.\n\n* `--sighup-each` полезен, когда вы перестраиваете много больших таблиц и хотите, чтобы каждая из них была как можно скорее загружена в `searchd`. С `--sighup-each` `indexer` отправит сигнал SIGHUP в searchd после успешного завершения работы с каждой таблицей. (По умолчанию отправляется один SIGHUP после построения всех таблиц).\n\n* `--nohup` полезен, когда вы хотите проверить таблицу с помощью indextool перед фактической загрузкой. indexer не отправит SIGHUP, если эта опция включена. Файлы таблиц переименовываются в .tmp. Используйте indextool для переименования файлов таблиц в .new и загрузки их. Пример использования:\n\n  ```shell\n\n  sudo -u manticore indexer --rotate --nohup mytable\n\n  sudo -u manticore indextool --rotate --check mytable\n\n  ```\n\n* `--print-queries` выводит SQL-запросы, которые `indexer` отправляет в базу данных, вместе с событиями подключения и отключения SQL. Это полезно для диагностики и устранения проблем с SQL-источниками.\n\n* `--help` (`-h` для краткости) выводит список всех параметров, которые можно вызвать в `indexer`.\n\n* `-v` показывает версию `indexer`.\n\n### Настройки конфигурации Indexer\n\nВы также можете настроить поведение indexer в конфигурационном файле Manticore в разделе `indexer`:\n\nCODE_BLOCK_8\n\n#### lemmatizer_cache\n\nCODE_BLOCK_9\n\nРазмер кэша лемматизатора. Необязательно, по умолчанию 256K.\n\nНаша реализация [лемматизатора](../../Server_settings/Common.md#lemmatizer_base) использует сжатый формат словаря, который позволяет балансировать между объемом памяти и скоростью. Он может либо выполнять лемматизацию на сжатых данных, используя больше CPU, но меньше RAM, либо распаковывать и предварительно кэшировать словарь частично или полностью, используя меньше CPU, но больше RAM. Директива lemmatizer_cache позволяет контролировать, сколько именно RAM может быть выделено для этого кэша распакованного словаря.\n\nВ настоящее время доступны только словари [ru.pak, en.pak и de.pak](https://manticoresearch.com/install/). Это русские, английские и немецкие словари. Размер сжатого словаря примерно от 2 до 10 МБ. Обратите внимание, что словарь всегда находится в памяти. Размер кэша по умолчанию — 256 КБ. Допустимые размеры кэша — от 0 до 2047 МБ. Безопасно увеличивать размер кэша слишком высоко; лемматизатор будет использовать только необходимую память. Например, весь русский словарь распаковывается примерно до 110 МБ; поэтому установка `lemmatizer_cache` выше этого значения не повлияет на использование памяти. Даже если разрешено 1024 МБ для кэша, если нужно только 110 МБ, будет использовано только 110 МБ.\n\n#### max_file_field_buffer\n\nCODE_BLOCK_10\n\nМаксимальный размер адаптивного буфера для файлового поля в байтах. Необязательно, по умолчанию 8 МБ, минимум 1 МБ.\n\nБуфер файлового поля используется для загрузки файлов, на которые ссылаются столбцы [sql_file_field](../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Processing_fetched_data.md#sql_file_field). Этот буфер адаптивен, начиная с 1 МБ при первом выделении и увеличиваясь в 2 раза, пока либо содержимое файла не будет загружено, либо не будет достигнут максимальный размер буфера, указанный директивой `max_file_field_buffer`.\n\nТаким образом, если файловые поля не указаны, буфер не выделяется вообще. Если все файлы, загружаемые во время индексации, меньше (например) 2 МБ, а значение `max_file_field_buffer` равно 128 МБ, пиковое использование буфера все равно будет только 2 МБ. Однако файлы размером более 128 МБ будут полностью пропущены.\n\n#### max_iops\n\nCODE_BLOCK_11\n\nМаксимальное количество операций ввода-вывода в секунду для ограничения I/O. Необязательно, по умолчанию 0 (без ограничений).\n\nОпция, связанная с ограничением I/O. Она ограничивает максимальное количество операций ввода-вывода (чтение или запись) за любую секунду. Значение 0 означает отсутствие ограничений.\n\n`indexer` может вызывать всплески интенсивных операций дискового ввода-вывода во время построения таблицы, и может быть желательно ограничить его активность на диске (и оставить ресурсы для других программ, работающих на той же машине, например `searchd`). Ограничение I/O помогает в этом. Оно работает, обеспечивая минимальную гарантированную задержку между последовательными операциями дискового ввода-вывода, выполняемыми `indexer`. Ограничение I/O может помочь уменьшить ухудшение производительности поиска, вызванное построением. Эта настройка неэффективна для других видов загрузки данных, например вставки данных в таблицу реального времени.\n\n#### max_iosize\n\nCODE_BLOCK_12\n\nМаксимально допустимый размер операции ввода-вывода в байтах для ограничения I/O. Необязательно, по умолчанию 0 (без ограничений).\n\nОпция, связанная с ограничением I/O. Она ограничивает максимальный размер файловой операции ввода-вывода (чтение или запись) для всех операций, выполняемых `indexer`. Значение 0 означает отсутствие ограничений. Чтения или записи, превышающие этот лимит, будут разбиты на несколько меньших операций и учитываться как несколько операций в настройке [max_iops](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#max_iops). На момент написания все вызовы I/O должны быть меньше 256 КБ (размер внутреннего буфера по умолчанию), поэтому значения max_iosize выше 256 КБ не должны влиять.\n\n#### max_xmlpipe2_field\n\nCODE_BLOCK_13\n\nМаксимально допустимый размер поля для источника типа XMLpipe2 в байтах. Необязательно, по умолчанию 2 МБ.\n\n#### mem_limit\n\nCODE_BLOCK_14"
    },
    "is_code_or_comment": false
  },
  "e38fe6d5d2ceecb180c4b1a337a388f60afb3b04a9d6e59c12ee738762184870": {
    "original": "  sudo -u manticore indexer --rotate --all --quiet\n\n  ```\n\n* `--noprogress` does not display progress details as they occur. Instead, the final status details (such as documents indexed, speed of indexing and so on are only reported at completion of indexing. In instances where the script is not being run on a console (or 'tty'), this will be on by default. Example usage:\n\n  ```shell\n\n  sudo -u manticore indexer --rotate --all --noprogress\n\n  ```\n\n* `--buildstops <outputfile.text> <N>` reviews the table source, as if it were indexing the data, and produces a list of the terms that are being indexed. In other words, it produces a list of all the searchable terms that are becoming part of the table. Note, it does not update the table in question, it simply processes the data as if it were indexing, including running queries defined with [sql_query_pre](../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Execution_of_fetch_queries.md#sql_query_pre) or [sql_query_post](../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Execution_of_fetch_queries.md#sql_query_post). `outputfile.txt` will contain the list of words, one per line, sorted by frequency with most frequent first, and `N` specifies the maximum number of words that will be listed. If it's sufficiently large to encompass every word in the table, only that many words will be returned. Such a dictionary list could be used for client application features around \"Did you mean…\" functionality, usually in conjunction with `--buildfreqs`, below. Example:\n\n  ```shell\n\n  sudo -u manticore indexer mytable --buildstops word_freq.txt 1000\n\n  ```\n\n  This would produce a document in the current directory, `word_freq.txt`, with the 1,000 most common words in 'mytable', ordered by most common first. Note that the file will pertain to the last table indexed when specified with multiple tables or `--all` (i.e. the last one listed in the configuration file)\n\n* `--buildfreqs` works with `--buildstops` (and is ignored if `--buildstops` is not specified). As `--buildstops` provides the list of words used within the table, `--buildfreqs` adds the quantity present in the table, which would be useful in establishing whether certain words should be considered stopwords if they are too prevalent. It will also help with developing \"Did you mean…\" features where you need to know how much more common a given word compared to another, similar one. For example:\n\n  ```shell\n\n  sudo -u manticore indexer mytable --buildstops word_freq.txt 1000 --buildfreqs\n\n  ```\n\n  This would produce the `word_freq.txt` as above, however after each word would be the number of times it occurred in the table in question.\n\n* `--merge <dst-table> <src-table>` is used for physically merging tables together, for example if you have a [main+delta scheme](../../Creating_a_table/Local_tables/Plain_table.md#Main+delta-scenario), where the main table rarely changes, but the delta table is rebuilt frequently, and `--merge` would be used to combine the two. The operation moves from right to left - the contents of `src-table` get examined and physically combined with the contents of `dst-table` and the result is left in `dst-table`. In pseudo-code, it might be expressed as: `dst-table += src-table` An example:\n\n  ```shell\n\n  sudo -u manticore indexer --merge main delta --rotate\n\n  ```\n\n  In the above example, where the main is the master, rarely modified table, and the delta is more frequently modified one, you might use the above to call `indexer` to combine the contents of the delta into the main table and rotate the tables.\n\n* `--merge-dst-range <attr> <min> <max>` runs the filter range given upon merging. Specifically, as the merge is applied to the destination table (as part of `--merge`, and is ignored if `--merge` is not specified), `indexer` will also filter the documents ending up in the destination table, and only documents will pass through the filter given will end up in the final table. This could be used for example, in a table where there is a 'deleted' attribute, where 0 means 'not deleted'. Such a table could be merged with:\n\n  ```shell\n\n  sudo -u manticore indexer --merge main delta --merge-dst-range deleted 0 0\n\n  ```\n\n  Any documents marked as deleted (value 1) will be removed from the newly-merged destination table. It can be added several times to the command line, to add successive filters to the merge, all of which must be met in order for a document to become part of the final table.\n\n* --`merge-killlists` (and its shorter alias `--merge-klists`) changes the way kill lists are processed when merging tables. By default, both kill lists get discarded after a merge. That supports the most typical main+delta merge scenario. With this option enabled, however, kill lists from both tables get concatenated and stored into the destination table. Note that a source (delta) table kill list will be used to suppress rows from a destination (main) table at all times.\n\n* `--keep-attrs` allows to reuse existing attributes on reindexing. Whenever the table is rebuilt, each new document id is checked for presence in the \"old\" table, and if it already exists, its attributes are transferred to the \"new\" table; if not found, attributes from the new table are used. If the user has updated attributes in the table, but not in the actual source used for the table, all updates will be lost when reindexing; using `--keep-attrs` enables saving the updated attribute values from the previous table. It is possible to specify a path for table files to be used instead of the reference path from the config:\n\n  ```shell\n\n  sudo -u manticore indexer mytable --keep-attrs=/path/to/index/files\n\n  ```\n\n* `--keep-attrs-names=<attributes list>` allows you to specify attributes to reuse from an existing table on reindexing. By default, all attributes from the existing table are reused in the new table:\n\n  ```shell\n\n  sudo -u manticore indexer mytable --keep-attrs=/path/to/table/files --keep-attrs-names=update,state\n\n  ```",
    "translations": {
      "chinese": "  sudo -u manticore indexer --rotate --all --quiet\n\n  ```\n\n* `--noprogress` 不会显示进度详情。相反，只有在索引完成时才报告最终状态详情（例如索引的文档数、索引速度等）。在脚本未在控制台（或 'tty'）上运行的情况下，默认启用此选项。示例用法：\n\n  ```shell\n\n  sudo -u manticore indexer --rotate --all --noprogress\n\n  ```\n\n* `--buildstops <outputfile.text> <N>` 会审查表的源数据，就像正在索引数据一样，并生成正在被索引的词汇列表。换句话说，它生成所有成为表一部分的可搜索词汇列表。注意，它不会更新相关表，只是像索引一样处理数据，包括运行用 [sql_query_pre](../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Execution_of_fetch_queries.md#sql_query_pre) 或 [sql_query_post](../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Execution_of_fetch_queries.md#sql_query_post) 定义的查询。`outputfile.txt` 将包含词汇列表，每行一个，按频率排序，最频繁的词在前，`N` 指定列出的最大词数。如果足够大以涵盖表中的所有词，则只返回那么多词。这样的词典列表可用于客户端应用的“你是想说……”功能，通常与下面的 `--buildfreqs` 一起使用。示例：\n\n  ```shell\n\n  sudo -u manticore indexer mytable --buildstops word_freq.txt 1000\n\n  ```\n\n  这将在当前目录生成一个文档 `word_freq.txt`，包含 'mytable' 中最常见的 1000 个词，按最常见排序。注意，如果指定多个表或 `--all`，该文件将对应最后一个被索引的表（即配置文件中最后列出的表）。\n\n* `--buildfreqs` 与 `--buildstops` 配合使用（如果未指定 `--buildstops`，则忽略此选项）。由于 `--buildstops` 提供了表中使用的词列表，`--buildfreqs` 会添加这些词在表中出现的数量，这对于确定某些词是否应被视为停用词（如果它们过于常见）很有用。它还帮助开发“你是想说……”功能，了解某词相较于另一个相似词的出现频率。例如：\n\n  ```shell\n\n  sudo -u manticore indexer mytable --buildstops word_freq.txt 1000 --buildfreqs\n\n  ```\n\n  这将生成上述的 `word_freq.txt`，但每个词后面会跟着它在相关表中出现的次数。\n\n* `--merge <dst-table> <src-table>` 用于物理合并表，例如如果你有一个 [主+增量方案](../../Creating_a_table/Local_tables/Plain_table.md#Main+delta-scenario)，主表很少更改，但增量表经常重建，`--merge` 用于合并两者。操作从右向左进行——检查 `src-table` 的内容并与 `dst-table` 的内容物理合并，结果保留在 `dst-table` 中。伪代码表达为：`dst-table += src-table` 示例：\n\n  ```shell\n\n  sudo -u manticore indexer --merge main delta --rotate\n\n  ```\n\n  在上述示例中，主表是主控且很少修改的表，增量表更频繁修改，你可以用上述命令调用 `indexer` 将增量表内容合并到主表并旋转表。\n\n* `--merge-dst-range <attr> <min> <max>` 在合并时应用给定的过滤范围。具体来说，由于合并应用于目标表（作为 `--merge` 的一部分，如果未指定 `--merge` 则忽略），`indexer` 也会过滤进入目标表的文档，只有通过给定过滤器的文档才会出现在最终表中。例如，在一个有 'deleted' 属性的表中，0 表示“未删除”，可以用如下命令合并：\n\n  ```shell\n\n  sudo -u manticore indexer --merge main delta --merge-dst-range deleted 0 0\n\n  ```\n\n  标记为已删除（值为 1）的文档将从新合并的目标表中移除。此选项可以多次添加到命令行，添加多个连续过滤器，所有过滤条件都必须满足，文档才会成为最终表的一部分。\n\n* --`merge-killlists`（及其简写别名 `--merge-klists`）改变合并表时杀死列表的处理方式。默认情况下，合并后两个杀死列表都会被丢弃。这支持最典型的主+增量合并场景。但启用此选项后，两个表的杀死列表会被连接并存储到目标表中。注意，源（增量）表的杀死列表始终用于抑制目标（主）表中的行。\n\n* `--keep-attrs` 允许在重新索引时重用现有属性。每当表重建时，会检查每个新文档 ID 是否存在于“旧”表中，如果存在，其属性会被转移到“新”表；如果未找到，则使用新表的属性。如果用户更新了表中的属性，但未更新实际用于表的源数据，重新索引时所有更新都会丢失；使用 `--keep-attrs` 可以保存之前表中更新的属性值。可以指定表文件路径以替代配置中的参考路径：\n\n  ```shell\n\n  sudo -u manticore indexer mytable --keep-attrs=/path/to/index/files\n\n  ```\n\n* `--keep-attrs-names=<attributes list>` 允许指定在重新索引时从现有表重用的属性。默认情况下，所有属性都会从现有表重用到新表：\n\n  ```shell\n\n  sudo -u manticore indexer mytable --keep-attrs=/path/to/table/files --keep-attrs-names=update,state\n\n  ```",
      "russian": "  sudo -u manticore indexer --rotate --all --quiet\n\n  ```\n\n* `--noprogress` не отображает детали прогресса по мере их появления. Вместо этого итоговые данные о статусе (например, количество проиндексированных документов, скорость индексации и так далее) выводятся только по завершении индексации. В случаях, когда скрипт не запускается в консоли (или 'tty'), этот параметр включен по умолчанию. Пример использования:\n\n  ```shell\n\n  sudo -u manticore indexer --rotate --all --noprogress\n\n  ```\n\n* `--buildstops <outputfile.text> <N>` просматривает исходную таблицу, как если бы она индексировалась, и создает список терминов, которые индексируются. Другими словами, он создает список всех поисковых терминов, которые становятся частью таблицы. Обратите внимание, что таблица при этом не обновляется, данные просто обрабатываются, как при индексации, включая выполнение запросов, определенных с помощью [sql_query_pre](../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Execution_of_fetch_queries.md#sql_query_pre) или [sql_query_post](../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Execution_of_fetch_queries.md#sql_query_post). В `outputfile.txt` будет содержаться список слов, по одному на строку, отсортированных по частоте с наиболее частыми первыми, а `N` задает максимальное количество слов в списке. Если `N` достаточно велик, чтобы охватить все слова в таблице, будет возвращено только столько слов. Такой словарь может использоваться для функций клиентских приложений, связанных с функционалом \"Вы имели в виду…\", обычно в сочетании с `--buildfreqs`, описанным ниже. Пример:\n\n  ```shell\n\n  sudo -u manticore indexer mytable --buildstops word_freq.txt 1000\n\n  ```\n\n  Это создаст файл в текущем каталоге `word_freq.txt` с 1000 наиболее часто встречающимися словами в 'mytable', упорядоченными по убыванию частоты. Обратите внимание, что файл будет относиться к последней проиндексированной таблице, если указано несколько таблиц или `--all` (то есть к последней в конфигурационном файле).\n\n* `--buildfreqs` работает вместе с `--buildstops` (игнорируется, если `--buildstops` не указан). Поскольку `--buildstops` предоставляет список слов, используемых в таблице, `--buildfreqs` добавляет количество их вхождений в таблицу, что полезно для определения, следует ли считать некоторые слова стоп-словами, если они слишком распространены. Это также помогает при разработке функций \"Вы имели в виду…\", где нужно знать, насколько одно слово встречается чаще другого, похожего. Например:\n\n  ```shell\n\n  sudo -u manticore indexer mytable --buildstops word_freq.txt 1000 --buildfreqs\n\n  ```\n\n  Это создаст `word_freq.txt`, как описано выше, но после каждого слова будет указано количество его вхождений в таблицу.\n\n* `--merge <dst-table> <src-table>` используется для физического слияния таблиц, например, если у вас есть [схема main+delta](../../Creating_a_table/Local_tables/Plain_table.md#Main+delta-scenario), где основная таблица редко меняется, а дельта-таблица часто перестраивается, и `--merge` используется для объединения двух таблиц. Операция идет справа налево — содержимое `src-table` анализируется и физически объединяется с содержимым `dst-table`, а результат остается в `dst-table`. В псевдокоде это можно выразить как: `dst-table += src-table` Пример:\n\n  ```shell\n\n  sudo -u manticore indexer --merge main delta --rotate\n\n  ```\n\n  В приведенном примере, где main — это основная, редко изменяемая таблица, а delta — более часто изменяемая, вы можете использовать эту команду для вызова `indexer`, чтобы объединить содержимое delta с main и выполнить ротацию таблиц.\n\n* `--merge-dst-range <attr> <min> <max>` применяет фильтр диапазона при слиянии. Конкретно, поскольку слияние применяется к целевой таблице (в рамках `--merge` и игнорируется, если `--merge` не указан), `indexer` также фильтрует документы, попадающие в целевую таблицу, и только документы, проходящие через заданный фильтр, окажутся в итоговой таблице. Это может использоваться, например, в таблице с атрибутом 'deleted', где 0 означает 'не удален'. Такая таблица может быть объединена с помощью:\n\n  ```shell\n\n  sudo -u manticore indexer --merge main delta --merge-dst-range deleted 0 0\n\n  ```\n\n  Все документы, помеченные как удаленные (значение 1), будут удалены из вновь объединенной целевой таблицы. Этот параметр можно указывать несколько раз в командной строке, чтобы добавить последовательные фильтры к слиянию, все из которых должны быть выполнены, чтобы документ стал частью итоговой таблицы.\n\n* --`merge-killlists` (и его короткий псевдоним `--merge-klists`) изменяет способ обработки списков удаления (kill lists) при слиянии таблиц. По умолчанию оба списка удаления отбрасываются после слияния. Это поддерживает наиболее типичный сценарий слияния main+delta. При включении этой опции списки удаления обеих таблиц объединяются и сохраняются в целевой таблице. Обратите внимание, что список удаления исходной (delta) таблицы всегда используется для подавления строк из целевой (main) таблицы.\n\n* `--keep-attrs` позволяет повторно использовать существующие атрибуты при переиндексации. При перестроении таблицы для каждого нового id документа проверяется наличие в \"старой\" таблице, и если он уже существует, его атрибуты переносятся в \"новую\" таблицу; если не найден, используются атрибуты из новой таблицы. Если пользователь обновил атрибуты в таблице, но не в исходных данных, используемых для таблицы, все обновления будут потеряны при переиндексации; использование `--keep-attrs` позволяет сохранить обновленные значения атрибутов из предыдущей таблицы. Можно указать путь к файлам таблицы, который будет использоваться вместо пути из конфигурации:\n\n  ```shell\n\n  sudo -u manticore indexer mytable --keep-attrs=/path/to/index/files\n\n  ```\n\n* `--keep-attrs-names=<attributes list>` позволяет указать атрибуты для повторного использования из существующей таблицы при переиндексации. По умолчанию все атрибуты из существующей таблицы повторно используются в новой таблице:\n\n  ```shell\n\n  sudo -u manticore indexer mytable --keep-attrs=/path/to/table/files --keep-attrs-names=update,state\n\n  ```"
    },
    "is_code_or_comment": false
  }
}
