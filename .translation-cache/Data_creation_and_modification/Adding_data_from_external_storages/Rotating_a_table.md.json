{
  "06de84f39dbf9d88b30c9ee6f12708baf1f2d3dd9a092f4441af4bec765eec8b": {
    "original": "With seamless rotate enabled, rotation works as follows:\n\n1. New table RAM storage is allocated.\n\n2. New table attribute and dictionary data is asynchronously preloaded to RAM.\n\n3. On success, old table is deallocated and both tables' files are renamed.\n\n4. On failure, new table is deallocated.\n\n5. At any given moment, queries are served either from old or new table copy.\n\nSeamless rotate comes at the cost of higher **peak** memory usage during the rotation (because both old and new copies of `.spa/.spb/.spi/.spm` data need to be in RAM while preloading the new copy). However, average usage stays the same.\n\nExample:\n\nCODE_BLOCK_4\n\n<!-- proofread -->",
    "translations": {
      "chinese": "启用无缝旋转后，旋转的工作流程如下：\n\n1. 分配新的表RAM存储。\n\n2. 异步预加载新的表属性和字典数据到RAM。\n\n3. 成功后，释放旧表并重命名两个表的文件。\n\n4. 失败时，释放新表。\n\n5. 在任何时刻，查询要么从旧表副本，要么从新表副本提供服务。\n\n无缝旋转的代价是在旋转期间内存的**峰值**使用量更高（因为在预加载新副本时，旧副本和新副本的`.spa/.spb/.spi/.spm`数据都需要在RAM中）。但是，平均使用量保持不变。\n\n示例：\n\nCODE_BLOCK_4\n\n<!-- proofread -->",
      "russian": "С включённым бесшовным поворотом, вращение работает следующим образом:\n\n1. Выделяется новое RAM-хранилище для таблицы.\n\n2. Асинхронно загружаются в RAM новые данные атрибутов и словаря таблицы.\n\n3. В случае успеха, старая таблица освобождается, и файлы обеих таблиц переименовываются.\n\n4. В случае неудачи, новая таблица освобождается.\n\n5. В любой момент запросы обслуживаются либо из старой, либо из новой копии таблицы.\n\nБесшовный поворот требует большего **пикового** использования памяти во время вращения (потому что обе копии данных `.spa/.spb/.spi/.spm` — старая и новая — должны находиться в RAM во время предварительной загрузки новой копии). Однако среднее использование остаётся прежним.\n\nПример:\n\nCODE_BLOCK_4\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "93514b19099b4ab8ad665efb91c6cbbdd0f91e1853eaab4428e3b7ca20ab6afa": {
    "original": "# Rotating a table\n\nTable rotation is a procedure in which the searchd server looks for new versions of defined tables in the configuration. Rotation is supported only in Plain mode of operation.\n\nThere can be two cases:\n\n* for plain tables that are already loaded\n\n* tables added in configuration, but not loaded yet\n\nIn the first case, the indexer cannot put the new version of the table online as the running copy is locked and loaded by `searchd`. In this case `indexer` needs to be called with the [--rotate](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#Indexer-command-line-arguments) parameter. If rotate is used, `indexer` creates new table files with `.new.` in their names and sends a *HUP* signal to `searchd` informing it about the new version. The `searchd` will perform a lookup and will put the new version of the table in place and discard the old one. In some cases, it might be desired to create the new version of the table but not perform rotate as soon as possible. For example, it might be desired to first check the health of the new table versions. In this case,  `indexer` can accept the`--nohup` parameter which will forbid sending the HUP signal to the server.\n\nNew tables can be loaded by rotation; however, the regular handling of the HUP signal is to check for new tables only if the configuration has changed since server startup. If the table was already defined in the configuration, the table should be first created by running `indexer` without rotation and perform the [RELOAD TABLES](../../Data_creation_and_modification/Adding_data_from_external_storages/Rotating_a_table.md#RELOAD-TABLES) statement instead.\n\nThere are also two specialized statements that can be used to perform rotations on tables:\n\n## RELOAD TABLE\n\nCODE_BLOCK_0\n\nThe `RELOAD TABLE` command enables table rotation via SQL.\n\nThis command functions in three modes. In the first mode, without specifying a path, the Manticore server checks for new table files in the directory indicated by the [path](../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#path). New table files must be named as `tbl.new.sp?`.\n\nIf you specify a path, the server searches for table files in that directory, relocates them to the table [path](../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#path), renames them from `tbl.sp?` to `tbl.new.sp?`, and rotates them.\n\nThe third mode, activated by `OPTION switchover=1`, switches the index to the new path. Here, the daemon tries to load the table directly from the new path without moving the files. If loading is successful, this new index supersedes the old one.\n\nAlso, the daemon writes a unique link file (`tbl.link`) in the directory specified by [path](../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#path), maintaining persistent redirection.\n\nIf you revert a redirected index to the path specified in the configuration, the daemon will detect this and delete the link file.\n\nOnce redirected, the daemon retrieves the table from the newly linked path. When rotating, it looks for new table versions at the newly redirected path. Bear in mind, the daemon checks the configuration for common errors, like duplicate paths across different tables. However, it won't identify if multiple tables point to the same path via redirection. Under normal operations, tables are locked with the `.spl` file, but disabling the lock may cause problems. If there's an error (e.g., the path is inaccessible for any reason), you should manually correct (or simply delete) the link file.\n\n`indextool` follows the link file, but other tools (`indexer`, `index_converter`, etc.) do not recognize the link file and consistently use the path defined in the configuration file, ignoring any redirection. Thus, you can inspect the index with `indextool`, and it will read from the new location. However, more complex operations like merging will not acknowledge any link file.\n\nCODE_BLOCK_1\n\n## RELOAD TABLES\n\nCODE_BLOCK_2\n\nThis command functions similarly to the HUP system signal, triggering a rotation of tables. Nevertheless, it doesn't exactly mirror the typical HUP signal (which can come from a `kill -HUP` command or `indexer --rotate`). This command actively searches for any tables needing rotation and is capable of re-reading the configuration. Suppose you launch Manticore in plain mode with a config file that points to a nonexistent plain table. If you then attempt to `indexer --rotate` the table, the new table won't be recognized by the server until you execute `RELOAD TABLES` or restart the server.\n\nDepending on the value of the [seamless_rotate](../../Server_settings/Searchd.md#seamless_rotate) setting, new queries might be shortly stalled, and clients will receive temporary errors.\n\nCODE_BLOCK_3\n\n## Seamless rotate\n\nThe rotate assumes old table version is discarded and new table version is loaded and replaces the existing one. During this swapping, the server needs to also serve incoming queries made on the table that is going to be updated. To avoid stalls of the queries, the server implements a seamless rotate of the table by default, as described below.\n\nTables may contain data that needs to be precached in RAM. At the moment, `.spa`, `.spb`, `.spi` and `.spm` files are fully precached (they contain attribute data, blob attribute data, keyword table, and killed row map, respectively). Without seamless rotate, rotating a table tries to use as little RAM as possible and works as follows:\n\n1. New queries are temporarily rejected (with \"retry\" error code).\n\n2. `searchd` waits for all currently running queries to finish.\n\n3. Old table is deallocated and its files are renamed.\n\n4. New table files are renamed and required RAM is allocated.\n\n5. New table attribute and dictionary data is preloaded to RAM.\n\n6. `searchd` resumes serving queries from the new table.\n\nHowever, if there's a lot of attribute or dictionary data, then the preloading step could take noticeable time - up to several minutes in case of preloading 1-5+ GB files.",
    "translations": {
      "chinese": "# 旋转表\n\n表旋转是一个过程，其中 searchd 服务器查找配置中定义的表的新版本。旋转仅支持在纯模式下操作。\n\n有两种情况：\n\n* 对于已经加载的纯表\n\n* 配置中添加了表，但尚未加载\n\n在第一种情况下，索引器无法将表的新版本上线，因为正在运行的副本被 `searchd` 锁定并加载。在这种情况下，需要使用带有 [--rotate](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#Indexer-command-line-arguments) 参数的 `indexer` 命令。如果使用 rotate，`indexer` 会创建带有 `.new.` 名称的新表文件，并向 `searchd` 发送 *HUP* 信号，通知它有新版本。`searchd` 会执行查找，将新版本的表替换旧版本并丢弃旧版本。在某些情况下，可能希望创建表的新版本，但不立即执行旋转。例如，可能希望先检查新表版本的健康状况。在这种情况下，`indexer` 可以接受 `--nohup` 参数，禁止向服务器发送 HUP 信号。\n\n新表可以通过旋转加载；然而，HUP 信号的常规处理是在服务器启动后配置发生变化时才检查新表。如果表已经在配置中定义，应该先运行不带旋转的 `indexer` 创建表，然后执行 [RELOAD TABLES](../../Data_creation_and_modification/Adding_data_from_external_storages/Rotating_a_table.md#RELOAD-TABLES) 语句。\n\n还有两个专用语句可用于对表执行旋转：\n\n## RELOAD TABLE\n\nCODE_BLOCK_0\n\n`RELOAD TABLE` 命令通过 SQL 实现表旋转。\n\n该命令有三种模式。第一种模式，不指定路径时，Manticore 服务器检查由 [path](../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#path) 指定目录中的新表文件。新表文件必须命名为 `tbl.new.sp?`。\n\n如果指定路径，服务器将在该目录中搜索表文件，将它们移动到表的 [path](../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#path) 目录，将文件名从 `tbl.sp?` 重命名为 `tbl.new.sp?`，然后执行旋转。\n\n第三种模式，通过 `OPTION switchover=1` 激活，将索引切换到新路径。此时，守护进程尝试直接从新路径加载表而不移动文件。如果加载成功，新索引将取代旧索引。\n\n此外，守护进程会在由 [path](../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#path) 指定的目录中写入唯一的链接文件（`tbl.link`），以保持持久重定向。\n\n如果将重定向的索引恢复到配置中指定的路径，守护进程会检测到并删除链接文件。\n\n一旦重定向，守护进程将从新链接的路径检索表。旋转时，它会在新重定向的路径查找新表版本。请注意，守护进程会检查配置中的常见错误，如不同表之间路径重复。但它不会识别多个表通过重定向指向同一路径。在正常操作中，表通过 `.spl` 文件锁定，但禁用锁定可能导致问题。如果出现错误（例如路径因任何原因不可访问），应手动修正（或简单删除）链接文件。\n\n`indextool` 会遵循链接文件，但其他工具（`indexer`、`index_converter` 等）不识别链接文件，始终使用配置文件中定义的路径，忽略任何重定向。因此，可以使用 `indextool` 检查索引，它会从新位置读取。但更复杂的操作如合并不会识别任何链接文件。\n\nCODE_BLOCK_1\n\n## RELOAD TABLES\n\nCODE_BLOCK_2\n\n该命令的功能类似于 HUP 系统信号，触发表的旋转。然而，它并不完全等同于典型的 HUP 信号（可能来自 `kill -HUP` 命令或 `indexer --rotate`）。该命令主动搜索需要旋转的表，并能够重新读取配置。假设你以纯模式启动 Manticore，配置文件指向一个不存在的纯表。如果随后尝试 `indexer --rotate` 该表，服务器不会识别新表，直到执行 `RELOAD TABLES` 或重启服务器。\n\n根据 [seamless_rotate](../../Server_settings/Searchd.md#seamless_rotate) 设置的值，新查询可能会短暂阻塞，客户端会收到临时错误。\n\nCODE_BLOCK_3\n\n## 无缝旋转\n\n旋转假设旧表版本被丢弃，新表版本被加载并替换现有版本。在此交换过程中，服务器还需要处理针对将被更新的表发起的查询。为避免查询阻塞，服务器默认实现了表的无缝旋转，具体如下。\n\n表可能包含需要预先缓存到内存的数据。目前，`.spa`、`.spb`、`.spi` 和 `.spm` 文件会被完全预缓存（它们分别包含属性数据、blob 属性数据、关键字表和已删除行映射）。如果没有无缝旋转，旋转表时尽量少用内存，工作流程如下：\n\n1. 新查询暂时被拒绝（返回“重试”错误码）。\n\n2. `searchd` 等待所有当前运行的查询完成。\n\n3. 旧表被释放，其文件被重命名。\n\n4. 新表文件被重命名并分配所需内存。\n\n5. 新表的属性和字典数据预加载到内存。\n\n6. `searchd` 恢复从新表提供查询服务。\n\n然而，如果属性或字典数据量很大，预加载步骤可能需要显著时间——预加载 1-5+ GB 文件时可能需要几分钟。",
      "russian": "# Вращение таблицы\n\nВращение таблицы — это процедура, при которой сервер searchd ищет новые версии определённых таблиц в конфигурации. Вращение поддерживается только в режиме Plain.\n\nМогут быть два случая:\n\n* для plain-таблиц, которые уже загружены\n\n* таблицы, добавленные в конфигурацию, но ещё не загруженные\n\nВ первом случае индексатор не может поставить новую версию таблицы онлайн, так как запущенная копия заблокирована и загружена `searchd`. В этом случае `indexer` нужно вызвать с параметром [--rotate](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#Indexer-command-line-arguments). Если используется rotate, `indexer` создаёт новые файлы таблицы с `.new.` в их именах и посылает сигнал *HUP* серверу `searchd`, информируя его о новой версии. `searchd` выполнит проверку и заменит старую версию таблицы на новую. В некоторых случаях может потребоваться создать новую версию таблицы, но не выполнять вращение сразу. Например, может потребоваться сначала проверить работоспособность новых версий таблиц. В этом случае `indexer` может принять параметр `--nohup`, который запретит отправку сигнала HUP серверу.\n\nНовые таблицы могут быть загружены через вращение; однако обычная обработка сигнала HUP заключается в проверке новых таблиц только если конфигурация изменилась с момента запуска сервера. Если таблица уже была определена в конфигурации, таблицу следует сначала создать, запустив `indexer` без вращения, и выполнить оператор [RELOAD TABLES](../../Data_creation_and_modification/Adding_data_from_external_storages/Rotating_a_table.md#RELOAD-TABLES).\n\nТакже существуют два специализированных оператора, которые можно использовать для выполнения вращения таблиц:\n\n## RELOAD TABLE\n\nCODE_BLOCK_0\n\nКоманда `RELOAD TABLE` позволяет выполнять вращение таблицы через SQL.\n\nЭта команда работает в трёх режимах. В первом режиме, без указания пути, сервер Manticore проверяет наличие новых файлов таблицы в каталоге, указанном в параметре [path](../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#path). Новые файлы таблицы должны иметь имена вида `tbl.new.sp?`.\n\nЕсли указать путь, сервер ищет файлы таблицы в этом каталоге, перемещает их в каталог таблицы, указанный в [path](../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#path), переименовывает их с `tbl.sp?` в `tbl.new.sp?` и выполняет вращение.\n\nТретий режим, активируемый опцией `OPTION switchover=1`, переключает индекс на новый путь. Здесь демон пытается загрузить таблицу непосредственно из нового пути без перемещения файлов. Если загрузка успешна, этот новый индекс заменяет старый.\n\nТакже демон записывает уникальный файл-ссылку (`tbl.link`) в каталог, указанный в [path](../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#path), обеспечивая постоянное перенаправление.\n\nЕсли вы возвращаете перенаправленный индекс к пути, указанному в конфигурации, демон обнаружит это и удалит файл-ссылку.\n\nПосле перенаправления демон получает таблицу из нового связанного пути. При вращении он ищет новые версии таблиц по новому перенаправленному пути. Учтите, что демон проверяет конфигурацию на общие ошибки, такие как дублирование путей для разных таблиц. Однако он не выявит, если несколько таблиц указывают на один и тот же путь через перенаправление. В нормальных условиях таблицы блокируются файлом `.spl`, но отключение блокировки может вызвать проблемы. Если возникает ошибка (например, путь недоступен по какой-либо причине), вам следует вручную исправить (или просто удалить) файл-ссылку.\n\n`indextool` следует за файлом-ссылкой, но другие инструменты (`indexer`, `index_converter` и т. п.) не распознают файл-ссылку и всегда используют путь, определённый в конфигурационном файле, игнорируя перенаправление. Таким образом, вы можете проверить индекс с помощью `indextool`, и он будет читать из нового расположения. Однако более сложные операции, такие как слияние, не будут учитывать файл-ссылку.\n\nCODE_BLOCK_1\n\n## RELOAD TABLES\n\nCODE_BLOCK_2\n\nЭта команда работает аналогично системному сигналу HUP, вызывая вращение таблиц. Тем не менее, она не полностью повторяет типичный сигнал HUP (который может быть вызван командой `kill -HUP` или `indexer --rotate`). Эта команда активно ищет таблицы, требующие вращения, и способна перечитывать конфигурацию. Предположим, вы запускаете Manticore в режиме plain с конфигурационным файлом, указывающим на несуществующую plain-таблицу. Если затем попытаться выполнить `indexer --rotate` для этой таблицы, сервер не распознает новую таблицу, пока вы не выполните `RELOAD TABLES` или не перезапустите сервер.\n\nВ зависимости от значения параметра [seamless_rotate](../../Server_settings/Searchd.md#seamless_rotate) новые запросы могут быть временно приостановлены, и клиенты получат временные ошибки.\n\nCODE_BLOCK_3\n\n## Плавное вращение\n\nВращение предполагает, что старая версия таблицы отбрасывается, а новая версия загружается и заменяет существующую. Во время этой замены сервер должен также обслуживать входящие запросы к таблице, которая обновляется. Чтобы избежать задержек запросов, сервер по умолчанию реализует плавное вращение таблицы, как описано ниже.\n\nТаблицы могут содержать данные, которые нужно предварительно загрузить в ОЗУ. В настоящее время файлы `.spa`, `.spb`, `.spi` и `.spm` полностью предварительно загружаются (они содержат данные атрибутов, данные блоб-атрибутов, таблицу ключевых слов и карту удалённых строк соответственно). Без плавного вращения вращение таблицы старается использовать как можно меньше ОЗУ и работает следующим образом:\n\n1. Новые запросы временно отклоняются (с кодом ошибки \"retry\").\n\n2. `searchd` ждёт завершения всех текущих запросов.\n\n3. Старая таблица освобождается, и её файлы переименовываются.\n\n4. Файлы новой таблицы переименовываются, и выделяется необходимая ОЗУ.\n\n5. Данные атрибутов и словаря новой таблицы предварительно загружаются в ОЗУ.\n\n6. `searchd` возобновляет обслуживание запросов из новой таблицы.\n\nОднако если данных атрибутов или словаря много, этап предварительной загрузки может занять заметное время — до нескольких минут при загрузке файлов размером 1-5+ ГБ."
    },
    "is_code_or_comment": false
  }
}
