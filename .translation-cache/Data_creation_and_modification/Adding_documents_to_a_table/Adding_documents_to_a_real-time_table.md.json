{
  "4043e3ba4deda4215d758c6b2e0bb32a18969e5e08176000630a66f64a48fce3": {
    "original": "The `/bulk` endpoint supports 'insert', 'replace', 'delete', and 'update' queries. Keep in mind that you can direct operations to multiple tables, but transactions are only possible for a single table. If you specify more, Manticore will gather operations directed to one table into a single transaction. When the table changes, it will commit the collected operations and initiate a new transaction on the new table. An empty line separating batches also leads to committing the previous batch and starting a new transaction.\n\nIn the response for a `/bulk` request, you can find the following fields:\n\n* \"errors\": shows whether any errors occurred (true/false)\n\n* \"error\": describes the error that took place\n\n* \"current_line\": the line number where execution stopped (or failed); empty lines, including the first empty line, are also counted\n\n* \"skipped_lines\": the count of non-committed lines, beginning from the `current_line` and moving backward\n\nCODE_BLOCK_37\n\n<!-- response JSON -->\n\nCODE_BLOCK_38\n\n<!-- request Elasticsearch -->\n\n> NOTE: `_bulk` requires [Manticore Buddy](Installation/Manticore_Buddy.md) if the table doesn't exist yet. If it doesn't work, make sure Buddy is installed.\n\nCODE_BLOCK_39\n\n<!-- response Elasticsearch -->\n\nCODE_BLOCK_40\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nUse method addDocuments():\n\nCODE_BLOCK_41\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_42\n\n<!-- intro -->\n\n##### Python=asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_43\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request Javascript -->\n\nCODE_BLOCK_44\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_45\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_46\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_47\n\n<!-- end -->\n\n<!-- example MVA_insert -->\n\n## Inserting multi-value attributes (MVA) values\n\nMulti-value attributes (MVA) are inserted as arrays of numbers.\n\n<!-- intro -->\n\n### Examples\n\n##### SQL\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- intro -->\n\n##### JSON\n\n<!-- request JSON -->\n\nCODE_BLOCK_49\n\n<!-- intro -->\n\n##### Elasticsearch:\n\n<!-- request Elasticsearch -->\n\nCODE_BLOCK_50\n\nOr, alternatively\n\nCODE_BLOCK_51\n\n<!-- intro -->\n\n##### PHP\n\n<!-- request PHP -->\n\nCODE_BLOCK_52\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_53\n\n<!-- intro -->\n\n##### Python=asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_54\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request Javascript -->\n\nCODE_BLOCK_55\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_56\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_57\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_58\n\n<!-- end -->\n\n<!-- example JSON_insert -->\n\n## Inserting JSON\n\nJSON value can be inserted as an [escaped](../../Searching/Full_text_matching/Escaping.md) string (via SQL or JSON) or as a JSON object (via the JSON interface).\n\n<!-- intro -->\n\n### Examples\n\n##### SQL\n\n<!-- request SQL -->\n\nCODE_BLOCK_59\n\n<!-- intro -->\n\n##### JSON\n\n<!-- request JSON -->\n\nJSON value can be inserted as a JSON object\n\nCODE_BLOCK_60\n\nJSON value can be also inserted as a string containing escaped JSON:\n\nCODE_BLOCK_61\n\n<!-- intro -->\n\n##### Elasticsearch:\n\n<!-- request Elasticsearch -->\n\nCODE_BLOCK_62\n\nOr, alternatively\n\nCODE_BLOCK_63\n\n<!-- intro -->\n\n##### PHP\n\nConsider JSON just as string:\n\n<!-- request PHP -->\n\nCODE_BLOCK_64\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_65\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_66\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request Javascript -->\n\nCODE_BLOCK_67\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_68\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_69\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_70\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "`/bulk` 端点支持 'insert'、'replace'、'delete' 和 'update' 查询。请记住，您可以将操作指向多个表，但事务仅适用于单个表。如果您指定了多个表，Manticore 会将指向同一表的操作收集到一个事务中。当表发生变化时，它会提交已收集的操作，并在新表上启动一个新事务。分批之间的空行也会导致提交前一批并开始一个新事务。\n\n在 `/bulk` 请求的响应中，您可以找到以下字段：\n\n* \"errors\"：显示是否发生了任何错误（true/false）\n\n* \"error\"：描述发生的错误\n\n* \"current_line\"：执行停止（或失败）的位置行号；空行，包括第一个空行，也会被计数\n\n* \"skipped_lines\"：从 `current_line` 向后开始未提交的行数\n\nCODE_BLOCK_37\n\n<!-- response JSON -->\n\nCODE_BLOCK_38\n\n<!-- request Elasticsearch -->\n\n> 注意：如果表尚不存在，`_bulk` 需要 [Manticore Buddy](Installation/Manticore_Buddy.md)。如果不起作用，请确保已安装 Buddy。\n\nCODE_BLOCK_39\n\n<!-- response Elasticsearch -->\n\nCODE_BLOCK_40\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\n使用方法 addDocuments():\n\nCODE_BLOCK_41\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_42\n\n<!-- intro -->\n\n##### Python=asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_43\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request Javascript -->\n\nCODE_BLOCK_44\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_45\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_46\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_47\n\n<!-- end -->\n\n<!-- example MVA_insert -->\n\n## 插入多值属性（MVA）值\n\n多值属性（MVA）作为数字数组插入。\n\n<!-- intro -->\n\n### 示例\n\n##### SQL\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- intro -->\n\n##### JSON\n\n<!-- request JSON -->\n\nCODE_BLOCK_49\n\n<!-- intro -->\n\n##### Elasticsearch:\n\n<!-- request Elasticsearch -->\n\nCODE_BLOCK_50\n\n或者，作为替代\n\nCODE_BLOCK_51\n\n<!-- intro -->\n\n##### PHP\n\n<!-- request PHP -->\n\nCODE_BLOCK_52\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_53\n\n<!-- intro -->\n\n##### Python=asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_54\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request Javascript -->\n\nCODE_BLOCK_55\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_56\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_57\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_58\n\n<!-- end -->\n\n<!-- example JSON_insert -->\n\n## 插入 JSON\n\nJSON 值可以作为[转义](../../Searching/Full_text_matching/Escaping.md)字符串插入（通过 SQL 或 JSON），也可以作为 JSON 对象插入（通过 JSON 接口）。\n\n<!-- intro -->\n\n### 示例\n\n##### SQL\n\n<!-- request SQL -->\n\nCODE_BLOCK_59\n\n<!-- intro -->\n\n##### JSON\n\n<!-- request JSON -->\n\nJSON 值可以作为 JSON 对象插入\n\nCODE_BLOCK_60\n\nJSON 值也可以作为包含转义 JSON 的字符串插入：\n\nCODE_BLOCK_61\n\n<!-- intro -->\n\n##### Elasticsearch:\n\n<!-- request Elasticsearch -->\n\nCODE_BLOCK_62\n\n或者，作为替代\n\nCODE_BLOCK_63\n\n<!-- intro -->\n\n##### PHP\n\n将 JSON 视为字符串：\n\n<!-- request PHP -->\n\nCODE_BLOCK_64\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_65\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_66\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request Javascript -->\n\nCODE_BLOCK_67\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_68\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_69\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_70\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "Эндпоинт `/bulk` поддерживает запросы 'insert', 'replace', 'delete' и 'update'. Имейте в виду, что вы можете направлять операции в несколько таблиц, но транзакции возможны только для одной таблицы. Если вы укажете несколько, Manticore соберет операции, направленные в одну таблицу, в одну транзакцию. Когда таблица меняется, он зафиксирует собранные операции и инициирует новую транзакцию для новой таблицы. Пустая строка, разделяющая пакеты, также приводит к фиксации предыдущего пакета и началу новой транзакции.\n\nВ ответе на запрос `/bulk` вы можете найти следующие поля:\n\n* \"errors\": показывает, произошли ли ошибки (true/false)\n\n* \"error\": описывает произошедшую ошибку\n\n* \"current_line\": номер строки, на которой выполнение остановилось (или завершилось с ошибкой); пустые строки, включая первую пустую строку, также учитываются\n\n* \"skipped_lines\": количество незафиксированных строк, начиная с `current_line` и двигаясь назад\n\nCODE_BLOCK_37\n\n<!-- response JSON -->\n\nCODE_BLOCK_38\n\n<!-- request Elasticsearch -->\n\n> ПРИМЕЧАНИЕ: `_bulk` требует [Manticore Buddy](Installation/Manticore_Buddy.md), если таблица еще не существует. Если не работает, убедитесь, что Buddy установлен.\n\nCODE_BLOCK_39\n\n<!-- response Elasticsearch -->\n\nCODE_BLOCK_40\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nИспользуйте метод addDocuments():\n\nCODE_BLOCK_41\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_42\n\n<!-- intro -->\n\n##### Python=asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_43\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request Javascript -->\n\nCODE_BLOCK_44\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_45\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_46\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_47\n\n<!-- end -->\n\n<!-- example MVA_insert -->\n\n## Вставка значений мультизначных атрибутов (MVA)\n\nМультизначные атрибуты (MVA) вставляются как массивы чисел.\n\n<!-- intro -->\n\n### Примеры\n\n##### SQL\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- intro -->\n\n##### JSON\n\n<!-- request JSON -->\n\nCODE_BLOCK_49\n\n<!-- intro -->\n\n##### Elasticsearch:\n\n<!-- request Elasticsearch -->\n\nCODE_BLOCK_50\n\nИли, альтернативно\n\nCODE_BLOCK_51\n\n<!-- intro -->\n\n##### PHP\n\n<!-- request PHP -->\n\nCODE_BLOCK_52\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_53\n\n<!-- intro -->\n\n##### Python=asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_54\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request Javascript -->\n\nCODE_BLOCK_55\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_56\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_57\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_58\n\n<!-- end -->\n\n<!-- example JSON_insert -->\n\n## Вставка JSON\n\nЗначение JSON может быть вставлено как [экранированная](../../Searching/Full_text_matching/Escaping.md) строка (через SQL или JSON) или как JSON-объект (через JSON-интерфейс).\n\n<!-- intro -->\n\n### Примеры\n\n##### SQL\n\n<!-- request SQL -->\n\nCODE_BLOCK_59\n\n<!-- intro -->\n\n##### JSON\n\n<!-- request JSON -->\n\nЗначение JSON может быть вставлено как JSON-объект\n\nCODE_BLOCK_60\n\nЗначение JSON также может быть вставлено как строка, содержащая экранированный JSON:\n\nCODE_BLOCK_61\n\n<!-- intro -->\n\n##### Elasticsearch:\n\n<!-- request Elasticsearch -->\n\nCODE_BLOCK_62\n\nИли, альтернативно\n\nCODE_BLOCK_63\n\n<!-- intro -->\n\n##### PHP\n\nРассматривайте JSON просто как строку:\n\n<!-- request PHP -->\n\nCODE_BLOCK_64\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_65\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_66\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request Javascript -->\n\nCODE_BLOCK_67\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_68\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_69\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_70\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "0046039f0f1ac45afc39350e0181ddd9a1fdcdf448d183473860a9881731c906": {
    "original": "# Adding documents to a real-time table\n\n> If you're looking for information on adding documents to a plain table, please refer to the section on [adding data from external storages](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md).\n\n<!-- example insert -->\n\nAdding documents in real-time is supported only for [Real-Time](../../Creating_a_table/Local_tables/Real-time_table.md) and [percolate](../../Creating_a_table/Local_tables/Percolate_table.md) tables. The corresponding SQL command, HTTP endpoint, or client functions insert new rows (documents) into a table with the provided field values. It's not necessary for a table to exist before adding documents to it. If the table doesn't exist, Manticore will attempt to create it automatically. For more information, see [Auto schema](../../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md#Auto-schema).\n\nYou can insert a single or [multiple documents](../../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md#Bulk-adding-documents) with values for all fields of the table or just a portion of them. In this case, the other fields will be filled with their default values (0 for scalar types, an empty string for text types).\n\nExpressions are not currently supported in `INSERT`, so values must be explicitly specified.\n\nThe ID field/value can be omitted, as RT and PQ tables support [auto-id](../../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md#Auto-ID) functionality. You can also use `0` as the id value to force automatic ID generation. Rows with duplicate IDs will not be overwritten by `INSERT`. Instead, you can use [REPLACE](../../Data_creation_and_modification/Updating_documents/REPLACE.md) for that purpose.\n\nWhen using the HTTP JSON protocol, you have two different request formats to choose from: a common Manticore format and an Elasticsearch-like format. Both formats are demonstrated in the examples below.\n\nAdditionally, when using the Manticore JSON request format, keep in mind that the `doc` node is required, and all the values should be provided within it.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nGeneral syntax:\n\nCODE_BLOCK_0\n\nCODE_BLOCK_1\n\n<!-- response SQL -->\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_3\n\n<!-- response JSON -->\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n##### Elasticsearch:\n\n<!-- request Elasticsearch -->\n\n> NOTE: `_create` requires [Manticore Buddy](Installation/Manticore_Buddy.md). If it doesn't work, make sure Buddy is installed.\n\nCODE_BLOCK_5\n\n<!-- response Elasticsearch -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_7\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_9\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request Javascript -->\n\nCODE_BLOCK_10\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_11\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_12\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_13\n\n<!-- end -->\n\n## Auto schema\n\n> NOTE: Auto schema requires [Manticore Buddy](Installation/Manticore_Buddy.md). If it doesn't work, make sure Buddy is installed.\n\nManticore features an automatic table creation mechanism, which activates when a specified table in the insert query doesn't yet exist. This mechanism is enabled by default. To disable it, set `auto_schema = 0` in the [Searchd](../../Server_settings/Searchd.md#auto_schema) section of your Manticore config file.\n\n<!-- example auto-schema -->\n\nBy default, all text values in the `VALUES` clause are considered to be of the `text` type, except for values representing valid email addresses, which are treated as the `string` type.\n\nIf you attempt to INSERT multiple rows with different, incompatible value types for the same field, auto table creation will be canceled, and an error message will be returned. However, if the different value types are compatible, the resulting field type will be the one that accommodates all the values. Some automatic data type conversions that may occur include:\n\n* mva -> mva64\n\n* uint -> bigint -> float (this may cause some precision loss)\n\n* string -> text\n\nThe auto schema mechanism does not support creating tables with vector fields (fields of type `float_vector`) used for [KNN](../../Searching/KNN.md#Configuring-a-table-for-KNN-search) (K-Nearest Neighbors) similarity search. To use vector fields in your table, you must explicitly create the table with a schema that defines these fields. If you need to store vector data in a regular table without KNN search capability, you can store it as a JSON array using the standard JSON syntax, for example: `INSERT INTO table_name (vector_field) VALUES ('[1.0, 2.0, 3.0]')`.\n\nAlso, the following formats of dates will be recognized and converted to timestamps while all other date formats will be treated as strings:\n\n- `%Y-%m-%dT%H:%M:%E*S%Z`\n\n- `%Y-%m-%d'T'%H:%M:%S%Z`\n\n- `%Y-%m-%dT%H:%M:%E*S`\n\n- `%Y-%m-%dT%H:%M:%s`\n\n- `%Y-%m-%dT%H:%M`\n\n- `%Y-%m-%dT%H`\n\nKeep in mind that the `/bulk` HTTP endpoint does not support automatic table creation (auto schema). Only the `/_bulk` (Elasticsearch-like) HTTP endpoint and the SQL interface support this feature.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_14\n\n<!-- response SQL -->\n\nCODE_BLOCK_15\n\n<!-- request JSON -->\n\nCODE_BLOCK_16\n\n<!-- response JSON -->\n\nCODE_BLOCK_17\n\n<!-- end -->\n\n## Auto ID\n\n<!-- example autoid -->\n\nManticore provides an auto ID generation functionality for the column ID of documents inserted or replaced into a real-time or [Percolate table](../../Creating_a_table/Local_tables/Percolate_table.md). The generator produces a unique ID for a document with some guarantees, but it should not be considered an auto-incremented ID.\n\nThe generated ID value is guaranteed to be unique under the following conditions:",
    "translations": {
      "chinese": "# 向实时表添加文档\n\n> 如果您正在查找有关向普通表添加文档的信息，请参阅[从外部存储添加数据](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md)部分。\n\n<!-- example insert -->\n\n实时添加文档仅支持[实时表](../../Creating_a_table/Local_tables/Real-time_table.md)和[Percolate表](../../Creating_a_table/Local_tables/Percolate_table.md)。相应的 SQL 命令、HTTP 端点或客户端函数会将新行（文档）插入到表中，并提供字段值。添加文档之前不必先创建表。如果表不存在，Manticore 会尝试自动创建它。更多信息请参见[自动模式](../../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md#Auto-schema)。\n\n您可以插入单个或[多个文档](../../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md#Bulk-adding-documents)，为表的所有字段或部分字段提供值。在这种情况下，其他字段将填充其默认值（标量类型为 0，文本类型为空字符串）。\n\n`INSERT` 目前不支持表达式，因此必须显式指定值。\n\nID 字段/值可以省略，因为 RT 和 PQ 表支持[自动 ID](../../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md#Auto-ID)功能。您也可以使用 `0` 作为 id 值以强制自动生成 ID。具有重复 ID 的行不会被 `INSERT` 覆盖。相反，您可以使用[REPLACE](../../Data_creation_and_modification/Updating_documents/REPLACE.md)来实现该目的。\n\n使用 HTTP JSON 协议时，您可以选择两种不同的请求格式：通用 Manticore 格式和类似 Elasticsearch 的格式。下面的示例中演示了这两种格式。\n\n此外，使用 Manticore JSON 请求格式时，请注意必须包含 `doc` 节点，所有值都应包含在其中。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\n通用语法：\n\nCODE_BLOCK_0\n\nCODE_BLOCK_1\n\n<!-- response SQL -->\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_3\n\n<!-- response JSON -->\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n##### Elasticsearch:\n\n<!-- request Elasticsearch -->\n\n> 注意：`_create` 需要[Manticore Buddy](Installation/Manticore_Buddy.md)。如果无法使用，请确保已安装 Buddy。\n\nCODE_BLOCK_5\n\n<!-- response Elasticsearch -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_7\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_9\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request Javascript -->\n\nCODE_BLOCK_10\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_11\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_12\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_13\n\n<!-- end -->\n\n## 自动模式\n\n> 注意：自动模式需要[Manticore Buddy](Installation/Manticore_Buddy.md)。如果无法使用，请确保已安装 Buddy。\n\nManticore 具有自动创建表的机制，当插入查询中指定的表尚不存在时会激活。该机制默认启用。要禁用它，请在 Manticore 配置文件的[Searchd](../../Server_settings/Searchd.md#auto_schema)部分设置 `auto_schema = 0`。\n\n<!-- example auto-schema -->\n\n默认情况下，`VALUES` 子句中的所有文本值都被视为 `text` 类型，除非值表示有效的电子邮件地址，则视为 `string` 类型。\n\n如果尝试插入多行且同一字段的值类型不同且不兼容，自动创建表将被取消，并返回错误消息。但如果不同的值类型兼容，结果字段类型将是能容纳所有值的类型。可能发生的一些自动数据类型转换包括：\n\n* mva -> mva64\n\n* uint -> bigint -> float（这可能导致一定的精度损失）\n\n* string -> text\n\n自动模式机制不支持创建带有用于[KNN](../../Searching/KNN.md#Configuring-a-table-for-KNN-search)（K 最近邻）相似度搜索的向量字段（`float_vector` 类型）的表。要在表中使用向量字段，必须显式创建定义这些字段的表模式。如果需要在普通表中存储向量数据但不具备 KNN 搜索功能，可以使用标准 JSON 语法将其存储为 JSON 数组，例如：`INSERT INTO table_name (vector_field) VALUES ('[1.0, 2.0, 3.0]')`。\n\n此外，以下日期格式将被识别并转换为时间戳，所有其他日期格式将被视为字符串：\n\n- `%Y-%m-%dT%H:%M:%E*S%Z`\n\n- `%Y-%m-%d'T'%H:%M:%S%Z`\n\n- `%Y-%m-%dT%H:%M:%E*S`\n\n- `%Y-%m-%dT%H:%M:%s`\n\n- `%Y-%m-%dT%H:%M`\n\n- `%Y-%m-%dT%H`\n\n请注意，`/bulk` HTTP 端点不支持自动创建表（自动模式）。只有 `/_bulk`（类似 Elasticsearch）HTTP 端点和 SQL 接口支持此功能。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_14\n\n<!-- response SQL -->\n\nCODE_BLOCK_15\n\n<!-- request JSON -->\n\nCODE_BLOCK_16\n\n<!-- response JSON -->\n\nCODE_BLOCK_17\n\n<!-- end -->\n\n## 自动 ID\n\n<!-- example autoid -->\n\nManticore 为插入或替换到实时表或[Percolate 表](../../Creating_a_table/Local_tables/Percolate_table.md)的文档的 ID 列提供自动 ID 生成功能。该生成器为文档生成唯一 ID 并提供一定保证，但不应视为自增 ID。\n\n生成的 ID 值在以下条件下保证唯一：",
      "russian": "# Добавление документов в таблицу реального времени\n\n> Если вы ищете информацию о добавлении документов в обычную таблицу, пожалуйста, обратитесь к разделу о [добавлении данных из внешних хранилищ](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md).\n\n<!-- example insert -->\n\nДобавление документов в реальном времени поддерживается только для таблиц [Real-Time](../../Creating_a_table/Local_tables/Real-time_table.md) и [percolate](../../Creating_a_table/Local_tables/Percolate_table.md). Соответствующая SQL-команда, HTTP-эндпоинт или клиентские функции вставляют новые строки (документы) в таблицу с указанными значениями полей. Таблица не обязательно должна существовать до добавления в неё документов. Если таблица не существует, Manticore попытается создать её автоматически. Для получения дополнительной информации смотрите [Автоматическая схема](../../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md#Auto-schema).\n\nВы можете вставить один или [несколько документов](../../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md#Bulk-adding-documents) с значениями для всех полей таблицы или только для части из них. В этом случае остальные поля будут заполнены значениями по умолчанию (0 для скалярных типов, пустая строка для текстовых типов).\n\nВ `INSERT` выражения в настоящее время не поддерживаются, поэтому значения должны быть указаны явно.\n\nПоле/значение ID может быть опущено, так как таблицы RT и PQ поддерживают функциональность [auto-id](../../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md#Auto-ID). Вы также можете использовать `0` в качестве значения id, чтобы принудительно сгенерировать автоматический ID. Строки с дублирующимися ID не будут перезаписаны с помощью `INSERT`. Для этого можно использовать [REPLACE](../../Data_creation_and_modification/Updating_documents/REPLACE.md).\n\nПри использовании HTTP JSON протокола у вас есть два различных формата запроса на выбор: общий формат Manticore и формат, похожий на Elasticsearch. Оба формата продемонстрированы в примерах ниже.\n\nКроме того, при использовании формата запроса Manticore JSON имейте в виду, что узел `doc` обязателен, и все значения должны быть указаны внутри него.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nОбщий синтаксис:\n\nCODE_BLOCK_0\n\nCODE_BLOCK_1\n\n<!-- response SQL -->\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_3\n\n<!-- response JSON -->\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n##### Elasticsearch:\n\n<!-- request Elasticsearch -->\n\n> ПРИМЕЧАНИЕ: `_create` требует [Manticore Buddy](Installation/Manticore_Buddy.md). Если не работает, убедитесь, что Buddy установлен.\n\nCODE_BLOCK_5\n\n<!-- response Elasticsearch -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_7\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_9\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request Javascript -->\n\nCODE_BLOCK_10\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_11\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_12\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_13\n\n<!-- end -->\n\n## Автоматическая схема\n\n> ПРИМЕЧАНИЕ: Автоматическая схема требует [Manticore Buddy](Installation/Manticore_Buddy.md). Если не работает, убедитесь, что Buddy установлен.\n\nManticore имеет механизм автоматического создания таблиц, который активируется, когда указанная в запросе вставки таблица ещё не существует. Этот механизм включён по умолчанию. Чтобы отключить его, установите `auto_schema = 0` в разделе [Searchd](../../Server_settings/Searchd.md#auto_schema) вашего конфигурационного файла Manticore.\n\n<!-- example auto-schema -->\n\nПо умолчанию все текстовые значения в разделе `VALUES` считаются типа `text`, за исключением значений, представляющих допустимые адреса электронной почты, которые обрабатываются как тип `string`.\n\nЕсли вы попытаетесь вставить несколько строк с разными, несовместимыми типами значений для одного и того же поля, автоматическое создание таблицы будет отменено, и будет возвращено сообщение об ошибке. Однако, если разные типы значений совместимы, результирующий тип поля будет тем, который может вместить все значения. Некоторые автоматические преобразования типов данных, которые могут произойти, включают:\n\n* mva -> mva64\n\n* uint -> bigint -> float (это может привести к некоторой потере точности)\n\n* string -> text\n\nМеханизм автоматической схемы не поддерживает создание таблиц с векторными полями (полями типа `float_vector`), используемыми для поиска по сходству [KNN](../../Searching/KNN.md#Configuring-a-table-for-KNN-search) (K-ближайших соседей). Чтобы использовать векторные поля в вашей таблице, вы должны явно создать таблицу с определением этих полей в схеме. Если вам нужно хранить векторные данные в обычной таблице без возможности поиска KNN, вы можете хранить их как JSON-массив, используя стандартный JSON-синтаксис, например: `INSERT INTO table_name (vector_field) VALUES ('[1.0, 2.0, 3.0]')`.\n\nТакже будут распознаны и преобразованы в метки времени следующие форматы дат, в то время как все остальные форматы дат будут рассматриваться как строки:\n\n- `%Y-%m-%dT%H:%M:%E*S%Z`\n\n- `%Y-%m-%d'T'%H:%M:%S%Z`\n\n- `%Y-%m-%dT%H:%M:%E*S`\n\n- `%Y-%m-%dT%H:%M:%s`\n\n- `%Y-%m-%dT%H:%M`\n\n- `%Y-%m-%dT%H`\n\nИмейте в виду, что HTTP-эндпоинт `/bulk` не поддерживает автоматическое создание таблиц (автоматическую схему). Только HTTP-эндпоинт `/_bulk` (похожий на Elasticsearch) и SQL-интерфейс поддерживают эту функцию.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_14\n\n<!-- response SQL -->\n\nCODE_BLOCK_15\n\n<!-- request JSON -->\n\nCODE_BLOCK_16\n\n<!-- response JSON -->\n\nCODE_BLOCK_17\n\n<!-- end -->\n\n## Автоматический ID\n\n<!-- example autoid -->\n\nManticore предоставляет функциональность автоматической генерации ID для столбца ID документов, вставляемых или заменяемых в таблице реального времени или [Percolate таблице](../../Creating_a_table/Local_tables/Percolate_table.md). Генератор создаёт уникальный ID для документа с некоторыми гарантиями, но его не следует рассматривать как автоинкрементный ID.\n\nГарантируется уникальность сгенерированного значения ID при следующих условиях:"
    },
    "is_code_or_comment": false
  },
  "d1cce9ac1df57d9f29eeffcf822a40ebd220f6a7000d7ad94cc3614f401d2122": {
    "original": "* The [server_id](../../Server_settings/Searchd.md#server_id) value of the current server is in the range of 0 to 127 and is unique among nodes in the cluster, or it uses the default value generated from the MAC address as a seed\n\n* The system time does not change for the Manticore node between server restarts\n\n* The auto ID is generated fewer than 16 million times per second between search server restarts\n\nThe auto ID generator creates a 64-bit integer for a document ID and uses the following schema:\n\n* Bits 0 to 23 form a counter that gets incremented on every call to the auto ID generator\n\n* Bits 24 to 55 represent the Unix timestamp of the server start\n\n* Bits 56 to 63 correspond to the server_id\n\nThis schema ensures that the generated ID is unique among all nodes in the cluster and that data inserted into different cluster nodes does not create collisions between the nodes.\n\nAs a result, the first ID from the generator used for auto ID is NOT 1 but a larger number. Additionally, the document stream inserted into a table might have non-sequential ID values if inserts into other tables occur between calls, as the ID generator is singular in the server and shared between all its tables.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_18\n\n<!-- response SQL -->\n\nCODE_BLOCK_19\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_20\n\n<!-- response JSON -->\n\nCODE_BLOCK_21\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_23\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_24\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request Javascript -->\n\nCODE_BLOCK_25\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_26\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_27\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_28\n\n<!-- end -->\n\n<!-- example call -->\n\n### UUID_SHORT multi-ID generation\n\nCODE_BLOCK_29\n\nThe `CALL UUID_SHORT(N)` statement allows for generating N unique 64-bit IDs in a single call without inserting any documents. It is particularly useful when you need to pre-generate IDs in Manticore for use in other systems or storage solutions. For example, you can generate auto-IDs in Manticore and then use them in another database, application, or workflow, ensuring consistent and unique identifiers across different environments.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request Example -->\n\nCODE_BLOCK_30\n\n<!-- response SQL -->\n\nCODE_BLOCK_31\n\n<!-- end -->\n\n<!-- example bulk_insert -->\n\n## Bulk adding documents\n\nYou can insert not just a single document into a real-time table, but as many as you'd like. It's perfectly fine to insert batches of tens of thousands of documents into a real-time table. However, it's important to keep the following points in mind:\n\n* The larger the batch, the higher the latency of each insert operation\n\n* The larger the batch, the higher the indexation speed you can expect\n\n* You might want to increase the [max_packet_size](../../Server_settings/Searchd.md#max_packet_size) value to allow for larger batches\n\n* Normally, each batch insert operation is considered a single [transaction](../../Data_creation_and_modification/Transactions.md) with atomicity guarantee, so you will either have all the new documents in the table at once or, in case of failure, none of them will be added. See more details about an empty line or switching to another table in the \"JSON\" example.\n\nNote that the `/bulk` HTTP endpoint does not support automatic creation of tables (auto schema). Only the `/_bulk` (Elasticsearch-like) HTTP endpoint and the SQL interface support this feature. The `/_bulk` (Elasticsearch-like) HTTP endpoint allows the table name to include the cluster name in the format `cluster_name:table_name`.\n\n`/_bulk` endpoint accepts document IDs in the same format as Elasticsearch, and you can also include the `id` within the document itself:\n\nCODE_BLOCK_32\n\nor\n\nCODE_BLOCK_33\n\n#### Chunked transfer in /bulk\n\nThe `/bulk` (Manticore mode) endpoint supports [Chunked transfer encoding](https://en.wikipedia.org/wiki/Chunked_transfer_encoding). You can use it to transmit large batches. It:\n\n* reduces peak RAM usage, lowering the risk of OOM\n\n* decreases response time\n\n* allows you to bypass [max_packet_size](../../Server_settings/Searchd.md#max_packet_size) and transfer batches much larger than the maximum allowed value of `max_packet_size` (128MB), for example, 1GB at a time.\n\n<!-- intro -->\n\n### Bulk insert examples\n\n##### SQL:\n\n<!-- request SQL -->\n\nFor bulk insert, simply provide more documents in brackets after `VALUES()`. The syntax is:\n\nCODE_BLOCK_34\n\nThe optional column name list allows you to explicitly specify values for some of the columns present in the table. All other columns will be filled with their default values (0 for scalar types, empty string for string types).\n\nFor example:\n\nCODE_BLOCK_35\n\n<!-- response SQL -->\n\nCODE_BLOCK_36\n\nExpressions are currently not supported in `INSERT`, and values should be explicitly specified.\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nThe syntax is generally the same as for [inserting a single document](../../Quick_start_guide.md#Add-documents). Just provide more lines, one for each document, and use the `/bulk` endpoint instead of `/insert`. Enclose each document in the \"insert\" node. Note that it also requires:\n\n* `Content-Type: application/x-ndjson`\n\n* The data should be formatted as newline-delimited JSON (NDJSON). Essentially, this means that each line should contain exactly one JSON statement and end with a newline `\\n` and possibly `\\r`.",
    "translations": {
      "chinese": "* 当前服务器的 [server_id](../../Server_settings/Searchd.md#server_id) 值在 0 到 127 范围内，并且在集群节点中唯一，或者使用从 MAC 地址生成的默认值作为种子\n\n* Manticore 节点在服务器重启之间系统时间不变\n\n* 在搜索服务器重启之间，自动 ID 生成次数少于每秒 1600 万次\n\n自动 ID 生成器为文档 ID 创建一个 64 位整数，并使用以下方案：\n\n* 位 0 到 23 形成一个计数器，每次调用自动 ID 生成器时递增\n\n* 位 24 到 55 表示服务器启动的 Unix 时间戳\n\n* 位 56 到 63 对应 server_id\n\n该方案确保生成的 ID 在集群所有节点中唯一，并且插入到不同集群节点的数据不会在节点之间产生冲突。\n\n因此，自动 ID 生成器生成的第一个 ID 不是 1，而是一个更大的数字。此外，如果在调用之间对其他表进行插入，插入到表中的文档流可能具有非连续的 ID 值，因为 ID 生成器在服务器中是唯一的，并且在其所有表之间共享。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_18\n\n<!-- response SQL -->\n\nCODE_BLOCK_19\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_20\n\n<!-- response JSON -->\n\nCODE_BLOCK_21\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_23\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_24\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request Javascript -->\n\nCODE_BLOCK_25\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_26\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_27\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_28\n\n<!-- end -->\n\n<!-- example call -->\n\n### UUID_SHORT 多 ID 生成\n\nCODE_BLOCK_29\n\n`CALL UUID_SHORT(N)` 语句允许在一次调用中生成 N 个唯一的 64 位 ID，而无需插入任何文档。当您需要在 Manticore 中预生成 ID 以供其他系统或存储解决方案使用时，这非常有用。例如，您可以在 Manticore 中生成自动 ID，然后在另一个数据库、应用程序或工作流中使用它们，确保不同环境中的标识符一致且唯一。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request Example -->\n\nCODE_BLOCK_30\n\n<!-- response SQL -->\n\nCODE_BLOCK_31\n\n<!-- end -->\n\n<!-- example bulk_insert -->\n\n## 批量添加文档\n\n您不仅可以向实时表插入单个文档，还可以插入任意数量的文档。向实时表插入数万个文档的批次是完全可以接受的。但需要注意以下几点：\n\n* 批次越大，每次插入操作的延迟越高\n\n* 批次越大，索引速度越快\n\n* 您可能需要增加 [max_packet_size](../../Server_settings/Searchd.md#max_packet_size) 的值以允许更大的批次\n\n* 通常，每个批量插入操作被视为一个具有原子性保证的单个 [事务](../../Data_creation_and_modification/Transactions.md)，因此您要么一次性拥有表中的所有新文档，要么在失败时一个都不会添加。有关空行或切换到另一张表的更多细节，请参见“JSON”示例。\n\n请注意，`/bulk` HTTP 端点不支持自动创建表（自动模式）。只有 `/_bulk`（类似 Elasticsearch）HTTP 端点和 SQL 接口支持此功能。`/_bulk`（类似 Elasticsearch）HTTP 端点允许表名包含集群名称，格式为 `cluster_name:table_name`。\n\n`/_bulk` 端点接受与 Elasticsearch 相同格式的文档 ID，您也可以在文档本身中包含 `id`：\n\nCODE_BLOCK_32\n\n或\n\nCODE_BLOCK_33\n\n#### /bulk 中的分块传输\n\n`/bulk`（Manticore 模式）端点支持[分块传输编码](https://en.wikipedia.org/wiki/Chunked_transfer_encoding)。您可以使用它来传输大型批次。它：\n\n* 减少峰值内存使用，降低 OOM 风险\n\n* 缩短响应时间\n\n* 允许您绕过 [max_packet_size](../../Server_settings/Searchd.md#max_packet_size) 限制，传输远大于最大允许值（128MB）的批次，例如一次传输 1GB。\n\n<!-- intro -->\n\n### 批量插入示例\n\n##### SQL:\n\n<!-- request SQL -->\n\n对于批量插入，只需在 `VALUES()` 后提供更多文档。语法为：\n\nCODE_BLOCK_34\n\n可选的列名列表允许您显式指定表中某些列的值。所有其他列将填充默认值（标量类型为 0，字符串类型为空字符串）。\n\n例如：\n\nCODE_BLOCK_35\n\n<!-- response SQL -->\n\nCODE_BLOCK_36\n\n`INSERT` 目前不支持表达式，值应显式指定。\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\n语法通常与[插入单个文档](../../Quick_start_guide.md#Add-documents)相同。只需提供更多行，每行一个文档，并使用 `/bulk` 端点替代 `/insert`。将每个文档包裹在 \"insert\" 节点中。请注意，还需要：\n\n* `Content-Type: application/x-ndjson`\n\n* 数据应格式化为换行分隔的 JSON（NDJSON）。本质上，这意味着每行应包含一个完整的 JSON 语句，并以换行符 `\\n` 和可能的 `\\r` 结尾。",
      "russian": "* Значение [server_id](../../Server_settings/Searchd.md#server_id) текущего сервера находится в диапазоне от 0 до 127 и уникально среди узлов в кластере, либо используется значение по умолчанию, сгенерированное из MAC-адреса в качестве начального значения\n\n* Системное время не меняется для узла Manticore между перезапусками сервера\n\n* Авто ID генерируется менее 16 миллионов раз в секунду между перезапусками поискового сервера\n\nГенератор авто ID создает 64-битное целое число для идентификатора документа и использует следующую схему:\n\n* Биты с 0 по 23 формируют счетчик, который увеличивается при каждом вызове генератора авто ID\n\n* Биты с 24 по 55 представляют Unix-временную метку запуска сервера\n\n* Биты с 56 по 63 соответствуют server_id\n\nЭта схема гарантирует, что сгенерированный ID уникален среди всех узлов в кластере и что данные, вставленные в разные узлы кластера, не создают коллизий между узлами.\n\nВ результате первый ID из генератора, используемый для авто ID, НЕ равен 1, а является большим числом. Кроме того, поток документов, вставляемых в таблицу, может иметь не последовательные значения ID, если между вызовами происходят вставки в другие таблицы, так как генератор ID един для сервера и используется всеми его таблицами.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_18\n\n<!-- response SQL -->\n\nCODE_BLOCK_19\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_20\n\n<!-- response JSON -->\n\nCODE_BLOCK_21\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_23\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_24\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request Javascript -->\n\nCODE_BLOCK_25\n\n<!-- intro -->\n\n##### java:\n\n<!-- request Java -->\n\nCODE_BLOCK_26\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_27\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_28\n\n<!-- end -->\n\n<!-- example call -->\n\n### UUID_SHORT множественная генерация ID\n\nCODE_BLOCK_29\n\nОператор `CALL UUID_SHORT(N)` позволяет сгенерировать N уникальных 64-битных ID за один вызов без вставки каких-либо документов. Это особенно полезно, когда необходимо предварительно сгенерировать ID в Manticore для использования в других системах или решениях для хранения. Например, вы можете сгенерировать авто-ID в Manticore, а затем использовать их в другой базе данных, приложении или рабочем процессе, обеспечивая согласованные и уникальные идентификаторы в разных средах.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request Example -->\n\nCODE_BLOCK_30\n\n<!-- response SQL -->\n\nCODE_BLOCK_31\n\n<!-- end -->\n\n<!-- example bulk_insert -->\n\n## Массовое добавление документов\n\nВы можете вставлять не только один документ в таблицу реального времени, но и сколько угодно. Абсолютно нормально вставлять партии из десятков тысяч документов в таблицу реального времени. Однако важно учитывать следующие моменты:\n\n* Чем больше партия, тем выше задержка каждой операции вставки\n\n* Чем больше партия, тем выше ожидаемая скорость индексации\n\n* Возможно, вам захочется увеличить значение [max_packet_size](../../Server_settings/Searchd.md#max_packet_size), чтобы разрешить большие партии\n\n* Обычно каждая операция пакетной вставки считается одной [транзакцией](../../Data_creation_and_modification/Transactions.md) с гарантией атомарности, поэтому либо все новые документы окажутся в таблице одновременно, либо в случае сбоя ни один из них не будет добавлен. Подробнее об этом см. в примере \"JSON\" про пустую строку или переключение на другую таблицу.\n\nОбратите внимание, что HTTP-эндпоинт `/bulk` не поддерживает автоматическое создание таблиц (auto schema). Только HTTP-эндпоинт `/_bulk` (подобный Elasticsearch) и SQL-интерфейс поддерживают эту функцию. HTTP-эндпоинт `/_bulk` (подобный Elasticsearch) позволяет включать имя кластера в имя таблицы в формате `cluster_name:table_name`.\n\nЭндпоинт `/_bulk` принимает идентификаторы документов в том же формате, что и Elasticsearch, и вы также можете включать `id` внутри самого документа:\n\nCODE_BLOCK_32\n\nили\n\nCODE_BLOCK_33\n\n#### Передача чанками в /bulk\n\nЭндпоинт `/bulk` (режим Manticore) поддерживает [Chunked transfer encoding](https://en.wikipedia.org/wiki/Chunked_transfer_encoding). Вы можете использовать это для передачи больших партий. Это:\n\n* снижает пиковое использование оперативной памяти, уменьшая риск OOM\n\n* уменьшает время отклика\n\n* позволяет обойти ограничение [max_packet_size](../../Server_settings/Searchd.md#max_packet_size) и передавать партии значительно больше максимального разрешенного значения `max_packet_size` (128 МБ), например, по 1 ГБ за раз.\n\n<!-- intro -->\n\n### Примеры массовой вставки\n\n##### SQL:\n\n<!-- request SQL -->\n\nДля массовой вставки просто укажите больше документов в скобках после `VALUES()`. Синтаксис:\n\nCODE_BLOCK_34\n\nОпциональный список имен столбцов позволяет явно указать значения для некоторых столбцов, присутствующих в таблице. Все остальные столбцы будут заполнены значениями по умолчанию (0 для скалярных типов, пустая строка для строковых типов).\n\nНапример:\n\nCODE_BLOCK_35\n\n<!-- response SQL -->\n\nCODE_BLOCK_36\n\nВ настоящее время выражения в `INSERT` не поддерживаются, и значения должны быть указаны явно.\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nСинтаксис в целом такой же, как для [вставки одного документа](../../Quick_start_guide.md#Add-documents). Просто укажите больше строк, по одной на каждый документ, и используйте эндпоинт `/bulk` вместо `/insert`. Каждый документ должен быть заключен в узел \"insert\". Обратите внимание, что также требуется:\n\n* `Content-Type: application/x-ndjson`\n\n* Данные должны быть отформатированы как JSON с разделением по строкам (NDJSON). По сути, это означает, что каждая строка должна содержать ровно одно JSON-выражение и заканчиваться символом новой строки `\\n` и, возможно, `\\r`."
    },
    "is_code_or_comment": false
  }
}
