{
  "158e6d96e36b67339ff0d593fdcf17a183e6ac570192778d533b329e205c3cc7": {
    "original": "# Transactions\n\nManticore supports basic transactions for deleting and inserting data into real-time and percolate tables, except when attempting to write to a distributed table which includes a real-time or percolate table. Each change to a table is first saved in an internal changeset and then actually committed to the table. By default, each command is wrapped in an individual automatic transaction, making it transparent: you simply 'insert' something and can see the inserted result after it completes, without worrying about transactions. However, this behavior can be explicitly managed by starting and committing transactions manually.\n\nTransactions are supported for the following commands:\n\n* [INSERT](../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md)\n\n* [REPLACE](../Data_creation_and_modification/Updating_documents/REPLACE.md)\n\n* [DELETE](../Data_creation_and_modification/Deleting_documents.md)\n\nTransactions are not supported for:\n\n* UPDATE (which is [different](../Data_creation_and_modification/Updating_documents/REPLACE_vs_UPDATE.md) from REPLACE, as it performs an in-place attribute update)\n\n* ALTER - for [updating table schema](../Updating_table_schema_and_settings.md)\n\n* TRUNCATE - for [emptying a real-time table](../Emptying_a_table.md)\n\n* ATTACH - for [attaching a plain table to a real-time table](../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Attaching_one_table_to_another.md)\n\n* CREATE - [for creating a table](../Creating_a_table/Local_tables.md)\n\n* DROP - [for deleting a table](../Deleting_a_table.md)\n\nPlease note that transactions in Manticore do not aim to provide isolation. The purpose of transactions in Manticore is to allow you to accumulate multiple writes and execute them all at once upon commit, or to roll them all back if necessary. Transactions are integrated with [binary log](../Logging/Binary_logging.md) for durability and consistency.\n\n## Automatic and manual mode\n\nCODE_BLOCK_0\n\n`SET AUTOCOMMIT` controls the autocommit mode in the active session. `AUTOCOMMIT` is set to 1 by default. With the default setting, you don't have to worry about transactions, as every statement that makes any changes to any table is implicitly wrapped in a separate transaction. Setting it to 0 allows you to manage transactions manually, meaning they will not be visible until you explicitly commit them.\n\nTransactions are limited to a single real-time or percolate table and are also limited in size. They are atomic, consistent, overly isolated, and durable. Overly isolated means that the changes are not only invisible to concurrent transactions but even to the current session itself.\n\n## BEGIN, COMMIT, and ROLLBACK\n\nCODE_BLOCK_1\n\nThe `BEGIN` statement (or its `START TRANSACTION` alias) forcibly commits any pending transaction, if present, and starts a new one.\n\nThe `COMMIT` statement commits the current transaction, making all its changes permanent.\n\nThe `ROLLBACK` statement rolls back the current transaction, canceling all its changes.\n\n## Transactions in /bulk\n\nWhen using one of the `/bulk` JSON endpoints ( [bulk insert](../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md?client=JSON#Bulk-adding-documents), [bulk replace](../Data_creation_and_modification/Updating_documents/REPLACE.md?client=JSON#Bulk-replace), [bulk delete](../Data_creation_and_modification/Deleting_documents.md?client=JSON#Bulk-deletion) ), you can force a batch of documents to be committed by adding an empty line after them.\n\n## Examples\n\n### Automatic commits (default)\n\nCODE_BLOCK_2\n\nThe inserted value is immediately visible in the following 'select' statement.\n\n### Manual commits (autocommit=0)\n\nCODE_BLOCK_3\n\nIn this case, changes are NOT automatically committed. As a result, the insertions are not visible, even in the same session, since they have not been committed. Also, despite the absence of a `BEGIN` statement, a transaction is implicitly started.\n\nTo make the changes visible, you need to commit the transaction:\n\nCODE_BLOCK_4\n\nAfter the commit statement, the insertions are visible in the table.\n\n### Manual transaction\n\nBy using `BEGIN` and `COMMIT`, you can define the bounds of a transaction explicitly, so there's no need to worry about autocommit in this case.\n\nCODE_BLOCK_5\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 事务\n\nManticore 支持对实时表和感知表进行基本的删除和插入数据的事务操作，但不支持对包含实时表或感知表的分布式表进行写操作。对表的每次更改首先保存在内部的变更集中，然后实际提交到表中。默认情况下，每个命令都被包装在一个独立的自动事务中，使其对用户透明：您只需执行“插入”操作，完成后即可看到插入的结果，无需担心事务。然而，这种行为可以通过手动启动和提交事务来显式管理。\n\n以下命令支持事务：\n\n* [INSERT](../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md)\n\n* [REPLACE](../Data_creation_and_modification/Updating_documents/REPLACE.md)\n\n* [DELETE](../Data_creation_and_modification/Deleting_documents.md)\n\n以下命令不支持事务：\n\n* UPDATE（与 REPLACE 不同，详见[这里](../Data_creation_and_modification/Updating_documents/REPLACE_vs_UPDATE.md)，因为它执行的是就地属性更新）\n\n* ALTER - 用于[更新表结构](../Updating_table_schema_and_settings.md)\n\n* TRUNCATE - 用于[清空实时表](../Emptying_a_table.md)\n\n* ATTACH - 用于[将普通表附加到实时表](../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Attaching_one_table_to_another.md)\n\n* CREATE - [创建表](../Creating_a_table/Local_tables.md)\n\n* DROP - [删除表](../Deleting_a_table.md)\n\n请注意，Manticore 中的事务并不旨在提供隔离性。Manticore 中事务的目的是允许您累积多个写操作，并在提交时一次性执行，或者在必要时全部回滚。事务与[二进制日志](../Logging/Binary_logging.md)集成，以保证持久性和一致性。\n\n## 自动和手动模式\n\nCODE_BLOCK_0\n\n`SET AUTOCOMMIT` 控制当前会话的自动提交模式。默认情况下，`AUTOCOMMIT` 设置为 1。默认设置下，您无需担心事务，因为对任何表进行更改的每条语句都会隐式地包装在一个独立的事务中。将其设置为 0 则允许您手动管理事务，即事务在您显式提交之前不会生效。\n\n事务仅限于单个实时表或感知表，并且大小有限。它们是原子性的、一致的、过度隔离的且持久的。过度隔离意味着更改不仅对并发事务不可见，甚至对当前会话本身也不可见。\n\n## BEGIN、COMMIT 和 ROLLBACK\n\nCODE_BLOCK_1\n\n`BEGIN` 语句（或其别名 `START TRANSACTION`）会强制提交任何未完成的事务（如果存在），然后开始一个新的事务。\n\n`COMMIT` 语句提交当前事务，使其所有更改永久生效。\n\n`ROLLBACK` 语句回滚当前事务，取消所有更改。\n\n## /bulk 中的事务\n\n使用 `/bulk` JSON 端点（[批量插入](../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md?client=JSON#Bulk-adding-documents)、[批量替换](../Data_creation_and_modification/Updating_documents/REPLACE.md?client=JSON#Bulk-replace)、[批量删除](../Data_creation_and_modification/Deleting_documents.md?client=JSON#Bulk-deletion)）时，可以通过在文档批次后添加一个空行来强制提交该批次的文档。\n\n## 示例\n\n### 自动提交（默认）\n\nCODE_BLOCK_2\n\n插入的值在随后的 'select' 语句中立即可见。\n\n### 手动提交（autocommit=0）\n\nCODE_BLOCK_3\n\n在这种情况下，更改不会自动提交。因此，即使在同一会话中，插入的内容也不可见，因为它们尚未提交。尽管没有 `BEGIN` 语句，事务仍然隐式启动。\n\n要使更改可见，您需要提交事务：\n\nCODE_BLOCK_4\n\n提交语句执行后，插入的内容在表中可见。\n\n### 手动事务\n\n通过使用 `BEGIN` 和 `COMMIT`，您可以显式定义事务的边界，因此无需担心自动提交。\n\nCODE_BLOCK_5\n\n<!-- proofread -->",
      "russian": "# Транзакции\n\nManticore поддерживает базовые транзакции для удаления и вставки данных в таблицы реального времени и перколяции, за исключением попыток записи в распределённую таблицу, которая включает таблицу реального времени или перколяции. Каждое изменение таблицы сначала сохраняется во внутреннем наборе изменений, а затем фактически фиксируется в таблице. По умолчанию каждая команда оборачивается в отдельную автоматическую транзакцию, что делает процесс прозрачным: вы просто 'вставляете' что-то и видите вставленный результат после завершения, не беспокоясь о транзакциях. Однако это поведение можно явно управлять, начиная и фиксируя транзакции вручную.\n\nТранзакции поддерживаются для следующих команд:\n\n* [INSERT](../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md)\n\n* [REPLACE](../Data_creation_and_modification/Updating_documents/REPLACE.md)\n\n* [DELETE](../Data_creation_and_modification/Deleting_documents.md)\n\nТранзакции не поддерживаются для:\n\n* UPDATE (который [отличается](../Data_creation_and_modification/Updating_documents/REPLACE_vs_UPDATE.md) от REPLACE, так как выполняет обновление атрибутов на месте)\n\n* ALTER - для [обновления схемы таблицы](../Updating_table_schema_and_settings.md)\n\n* TRUNCATE - для [очистки таблицы реального времени](../Emptying_a_table.md)\n\n* ATTACH - для [присоединения простой таблицы к таблице реального времени](../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Attaching_one_table_to_another.md)\n\n* CREATE - [для создания таблицы](../Creating_a_table/Local_tables.md)\n\n* DROP - [для удаления таблицы](../Deleting_a_table.md)\n\nОбратите внимание, что транзакции в Manticore не предназначены для обеспечения изоляции. Цель транзакций в Manticore — позволить вам накопить несколько записей и выполнить их все одновременно при фиксации, или отменить их все при необходимости. Транзакции интегрированы с [бинарным журналом](../Logging/Binary_logging.md) для обеспечения надёжности и согласованности.\n\n## Автоматический и ручной режим\n\nCODE_BLOCK_0\n\n`SET AUTOCOMMIT` управляет режимом автокоммита в активной сессии. По умолчанию `AUTOCOMMIT` установлен в 1. При настройке по умолчанию вам не нужно беспокоиться о транзакциях, так как каждое выражение, вносящее изменения в любую таблицу, неявно оборачивается в отдельную транзакцию. Установка значения 0 позволяет управлять транзакциями вручную, то есть они не будут видны, пока вы явно не зафиксируете их.\n\nТранзакции ограничены одной таблицей реального времени или перколяции и также ограничены по размеру. Они атомарны, согласованы, чрезмерно изолированы и надёжны. Чрезмерная изоляция означает, что изменения не видны не только для параллельных транзакций, но даже для самой текущей сессии.\n\n## BEGIN, COMMIT и ROLLBACK\n\nCODE_BLOCK_1\n\nОператор `BEGIN` (или его псевдоним `START TRANSACTION`) принудительно фиксирует любую ожидающую транзакцию, если она есть, и начинает новую.\n\nОператор `COMMIT` фиксирует текущую транзакцию, делая все её изменения постоянными.\n\nОператор `ROLLBACK` откатывает текущую транзакцию, отменяя все её изменения.\n\n## Транзакции в /bulk\n\nПри использовании одного из JSON эндпоинтов `/bulk` ( [bulk insert](../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md?client=JSON#Bulk-adding-documents), [bulk replace](../Data_creation_and_modification/Updating_documents/REPLACE.md?client=JSON#Bulk-replace), [bulk delete](../Data_creation_and_modification/Deleting_documents.md?client=JSON#Bulk-deletion) ), вы можете принудительно зафиксировать пакет документов, добавив пустую строку после них.\n\n## Примеры\n\n### Автоматические коммиты (по умолчанию)\n\nCODE_BLOCK_2\n\nВставленное значение сразу же видно в следующем операторе 'select'.\n\n### Ручные коммиты (autocommit=0)\n\nCODE_BLOCK_3\n\nВ этом случае изменения НЕ фиксируются автоматически. В результате вставки не видны, даже в той же сессии, так как они не были зафиксированы. Также, несмотря на отсутствие оператора `BEGIN`, транзакция запускается неявно.\n\nЧтобы сделать изменения видимыми, необходимо зафиксировать транзакцию:\n\nCODE_BLOCK_4\n\nПосле оператора commit вставки становятся видимыми в таблице.\n\n### Ручная транзакция\n\nИспользуя `BEGIN` и `COMMIT`, вы можете явно определить границы транзакции, поэтому в этом случае не нужно беспокоиться об автокоммите.\n\nCODE_BLOCK_5\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
