{
  "088793a6a21f6262938820a16fd1184b3df6614cca81b27e79a1f56318e42bde": {
    "original": "* maxquerytime - maximum allowed query time (in milliseconds), as in [max_query_time search option](../Searching/Options.md#max_query_time):\n\nCODE_BLOCK_22\n\n* groupby - group-by function and attribute. Read [this](../Searching/Grouping.md#Just-Grouping) about grouping search results:\n\nCODE_BLOCK_23\n\n* groupsort - group-by sorting clause:\n\nCODE_BLOCK_24\n\n* distinct - an attribute to compute [COUNT(DISTINCT)](../Searching/Grouping.md#COUNT%28DISTINCT-field%29) for when doing group-by:\n\nCODE_BLOCK_25\n\n* indexweights - comma-separated list of table names and weights to use when searching through several tables:\n\nCODE_BLOCK_26\n\n* fieldweights - comma-separated list of per-field weights that can be used by the ranker:\n\nCODE_BLOCK_27\n\n* comment - a string to mark this query in query log, as in [comment search option](../Searching/Options.md#comment):\n\nCODE_BLOCK_28\n\n* select - a string with expressions to compute:\n\nCODE_BLOCK_29\n\n* host, port - remote `searchd` host name and TCP port, respectively:\n\nCODE_BLOCK_30\n\n* ranker - a ranking function to use with \"extended\" matching mode, as in [ranker](../Searching/Options.md#ranker). Known values are \"proximity_bm25\", \"bm25\", \"none\", \"wordcount\", \"proximity\", \"matchany\", \"fieldmask\", \"sph04\", \"expr:EXPRESSION\" syntax to support expression-based ranker (where EXPRESSION should be replaced with your specific ranking formula), and \"export:EXPRESSION\":\n\nCODE_BLOCK_31\n\nThe \"export\" ranker functions similarly to ranker=expr, but it retains the per-document factor values, while ranker=expr discards them after computing the final `WEIGHT()` value. Keep in mind that ranker=export is intended for occasional use, such as training a machine learning (ML) function or manually defining your own ranking function, and should not be used in actual production. When utilizing this ranker, you'll likely want to examine the output of the `RANKFACTORS()` function, which generates a string containing all the field-level factors for each document.\n\n<!-- example SQL Example_2 -->\n\n<!-- request -->\n\nCODE_BLOCK_32\n\n<!-- response -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n* geoanchor - geodistance anchor. Learn more about Geo-search [in this section](../Searching/Geo_search.md). Takes 4 parameters, which are the latitude and longitude attribute names, and anchor point coordinates, respectively:\n\nCODE_BLOCK_34\n\nOne **very important** note is that it is **much** more efficient to let Manticore handle sorting, filtering, and slicing the result set, rather than increasing the max matches count and using `WHERE`, `ORDER BY`, and `LIMIT` clauses on the MySQL side. This is due to two reasons. First, Manticore employs a variety of optimizations and performs these tasks better than MySQL. Second, less data would need to be packed by searchd, transferred, and unpacked by SphinxSE.\n\n### Important note about stored fields when using SphinxSE\n\nSince version 5.0.0, Manticore stores all fields by default. When Manticore is used together with MySQL or MariaDB via SphinxSE, storing all fields usually does not make sense because the originals are already stored in MySQL/MariaDB. In such setups it is recommended to explicitly disable stored fields for the involved Manticore table by setting:\n\nCODE_BLOCK_35\n\nSee the setting reference: [stored_fields](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#stored_fields).\n\nIf you keep the default (all fields stored) and then select a lot of documents at once through SphinxSE, an internal limit in the engine may be exceeded and you may receive an error like:\n\n\"bad searchd response length\"\n\nSetting `stored_fields =` avoids sending large stored payloads back to MySQL/MariaDB and prevents this error in typical SphinxSE integrations.\n\n### SHOW ENGINE SPHINX STATUS\n\n<!-- example Example_3 -->\n\nYou can obtain additional information related to the query results using the `SHOW ENGINE SPHINX STATUS` statement:\n\n<!-- request -->\n\nCODE_BLOCK_36\n\n<!-- response -->\n\nCODE_BLOCK_37\n\n<!-- end -->\n\n<!-- example Example_4 -->\n\nYou can also access this information through status variables. Keep in mind that using this method does not require super-user privileges.\n\n<!-- request -->\n\nCODE_BLOCK_38\n\n<!-- response -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example SQL Example_5 -->\n\nSphinxSE search tables can be joined with tables using other engines. Here's an example using the \"documents\" table from example.sql:\n\n<!-- request -->\n\nCODE_BLOCK_40\n\n<!-- response -->\n\nCODE_BLOCK_41\n\n<!-- end -->\n\n## Building snippets via MySQL\n\nSphinxSE also features a UDF function that allows you to create snippets using MySQL. This functionality is similar to [HIGHLIGHT()](../Searching/Highlighting.md#Highlighting), but can be accessed through MySQL+SphinxSE.\n\nThe binary providing the UDF is called `sphinx.so` and should be automatically built and installed in the appropriate location along with SphinxSE. If it doesn't install automatically for some reason, locate `sphinx.so` in the build directory and copy it to your MySQL instance's plugins directory. Once done, register the UDF with the following statement:\n\nCODE_BLOCK_42\n\nThe function name *must* be sphinx_snippets; you cannot use an arbitrary name. The function arguments are as follows:\n\n**Prototype:** function sphinx_snippets ( document, table, words [, options] );\n\nThe document and words arguments can be either strings or table columns. Options must be specified like this: `'value' AS option_name`. For a list of supported options, refer to the [Highlighting section](../Searching/Highlighting.md). The only UDF-specific additional option is called `sphinx` and allows you to specify the searchd location (host and port).\n\nUsage examples:\n\nCODE_BLOCK_43\n\n<!-- proofread -->",
    "translations": {
      "chinese": "* maxquerytime - 最大允许的查询时间（以毫秒为单位），如同 [max_query_time 搜索选项](../Searching/Options.md#max_query_time)：\n\nCODE_BLOCK_22\n\n* groupby - 分组函数和属性。请阅读 [此处](../Searching/Grouping.md#Just-Grouping) 了解分组搜索结果：\n\nCODE_BLOCK_23\n\n* groupsort - 分组排序子句：\n\nCODE_BLOCK_24\n\n* distinct - 在进行分组时计算 [COUNT(DISTINCT)](../Searching/Grouping.md#COUNT%28DISTINCT-field%29) 的属性：\n\nCODE_BLOCK_25\n\n* indexweights - 用逗号分隔的表名和权重列表，用于在多个表中搜索时使用：\n\nCODE_BLOCK_26\n\n* fieldweights - 用逗号分隔的每字段权重列表，可被排序器使用：\n\nCODE_BLOCK_27\n\n* comment - 用于在查询日志中标记此查询的字符串，如同 [comment 搜索选项](../Searching/Options.md#comment)：\n\nCODE_BLOCK_28\n\n* select - 用于计算的表达式字符串：\n\nCODE_BLOCK_29\n\n* host, port - 远程 `searchd` 主机名和 TCP 端口，分别为：\n\nCODE_BLOCK_30\n\n* ranker - 用于“扩展”匹配模式的排名函数，如同 [ranker](../Searching/Options.md#ranker)。已知值包括 \"proximity_bm25\"、\"bm25\"、\"none\"、\"wordcount\"、\"proximity\"、\"matchany\"、\"fieldmask\"、\"sph04\"、\"expr:EXPRESSION\" 语法以支持基于表达式的排名器（其中 EXPRESSION 应替换为您的具体排名公式），以及 \"export:EXPRESSION\"：\n\nCODE_BLOCK_31\n\n“export”排名器的功能类似于 ranker=expr，但它保留每个文档的因子值，而 ranker=expr 在计算最终的 `WEIGHT()` 值后会丢弃它们。请注意，ranker=export 旨在偶尔使用，例如训练机器学习（ML）函数或手动定义您自己的排名函数，不应在实际生产中使用。使用此排名器时，您可能希望检查 `RANKFACTORS()` 函数的输出，该函数生成包含每个文档所有字段级因子的字符串。\n\n<!-- example SQL Example_2 -->\n\n<!-- request -->\n\nCODE_BLOCK_32\n\n<!-- response -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n* geoanchor - 地理距离锚点。更多关于地理搜索的信息请参见 [本节](../Searching/Geo_search.md)。接受4个参数，分别是纬度和经度属性名，以及锚点坐标：\n\nCODE_BLOCK_34\n\n一个**非常重要**的注意事项是，让 Manticore 处理排序、过滤和结果集切片要**高效得多**，而不是增加最大匹配数并在 MySQL 端使用 `WHERE`、`ORDER BY` 和 `LIMIT` 子句。这有两个原因。首先，Manticore 采用多种优化，执行这些任务比 MySQL 更好。其次，searchd 需要打包、传输和 SphinxSE 需要解包的数据量更少。\n\n### 使用 SphinxSE 时关于存储字段的重要说明\n\n从版本 5.0.0 起，Manticore 默认存储所有字段。当 Manticore 与 MySQL 或 MariaDB 通过 SphinxSE 一起使用时，通常不需要存储所有字段，因为原始数据已经存储在 MySQL/MariaDB 中。在这种设置中，建议通过设置显式禁用相关 Manticore 表的存储字段：\n\nCODE_BLOCK_35\n\n请参阅设置参考：[stored_fields](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#stored_fields)。\n\n如果保持默认（存储所有字段），然后通过 SphinxSE 一次选择大量文档，可能会超过引擎的内部限制，并收到类似以下错误：\n\n\"bad searchd response length\"\n\n设置 `stored_fields =` 可以避免将大量存储的负载发送回 MySQL/MariaDB，并防止在典型的 SphinxSE 集成中出现此错误。\n\n### SHOW ENGINE SPHINX STATUS\n\n<!-- example Example_3 -->\n\n您可以使用 `SHOW ENGINE SPHINX STATUS` 语句获取与查询结果相关的更多信息：\n\n<!-- request -->\n\nCODE_BLOCK_36\n\n<!-- response -->\n\nCODE_BLOCK_37\n\n<!-- end -->\n\n<!-- example Example_4 -->\n\n您也可以通过状态变量访问此信息。请注意，使用此方法不需要超级用户权限。\n\n<!-- request -->\n\nCODE_BLOCK_38\n\n<!-- response -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example SQL Example_5 -->\n\nSphinxSE 搜索表可以与使用其他引擎的表进行连接。以下是使用 example.sql 中的 \"documents\" 表的示例：\n\n<!-- request -->\n\nCODE_BLOCK_40\n\n<!-- response -->\n\nCODE_BLOCK_41\n\n<!-- end -->\n\n## 通过 MySQL 构建摘要\n\nSphinxSE 还提供了一个 UDF 函数，允许您使用 MySQL 创建摘要。此功能类似于 [HIGHLIGHT()](../Searching/Highlighting.md#Highlighting)，但可以通过 MySQL+SphinxSE 访问。\n\n提供 UDF 的二进制文件名为 `sphinx.so`，应自动构建并安装在与 SphinxSE 一起的适当位置。如果由于某种原因未自动安装，请在构建目录中找到 `sphinx.so` 并复制到您的 MySQL 实例的插件目录。完成后，使用以下语句注册 UDF：\n\nCODE_BLOCK_42\n\n函数名*必须*是 sphinx_snippets；不能使用任意名称。函数参数如下：\n\n**原型：** function sphinx_snippets ( document, table, words [, options] );\n\ndocument 和 words 参数可以是字符串或表列。选项必须像这样指定：`'value' AS option_name`。有关支持的选项列表，请参阅 [高亮部分](../Searching/Highlighting.md)。唯一的 UDF 特定附加选项称为 `sphinx`，允许您指定 searchd 的位置（主机和端口）。\n\n使用示例：\n\nCODE_BLOCK_43\n\n<!-- proofread -->",
      "russian": "* maxquerytime - максимальное допустимое время выполнения запроса (в миллисекундах), как в [опции поиска max_query_time](../Searching/Options.md#max_query_time):\n\nCODE_BLOCK_22\n\n* groupby - функция группировки и атрибут. Подробнее о группировке результатов поиска читайте [здесь](../Searching/Grouping.md#Just-Grouping):\n\nCODE_BLOCK_23\n\n* groupsort - условие сортировки групп:\n\nCODE_BLOCK_24\n\n* distinct - атрибут для вычисления [COUNT(DISTINCT)](../Searching/Grouping.md#COUNT%28DISTINCT-field%29) при выполнении группировки:\n\nCODE_BLOCK_25\n\n* indexweights - список через запятую имён таблиц и весов, используемых при поиске по нескольким таблицам:\n\nCODE_BLOCK_26\n\n* fieldweights - список через запятую весов для каждого поля, которые могут использоваться ранжировщиком:\n\nCODE_BLOCK_27\n\n* comment - строка для пометки этого запроса в журнале запросов, как в [опции поиска comment](../Searching/Options.md#comment):\n\nCODE_BLOCK_28\n\n* select - строка с выражениями для вычисления:\n\nCODE_BLOCK_29\n\n* host, port - имя удалённого хоста `searchd` и TCP-порт соответственно:\n\nCODE_BLOCK_30\n\n* ranker - функция ранжирования для использования с режимом \"extended\" сопоставления, как в [ranker](../Searching/Options.md#ranker). Известные значения: \"proximity_bm25\", \"bm25\", \"none\", \"wordcount\", \"proximity\", \"matchany\", \"fieldmask\", \"sph04\", синтаксис \"expr:EXPRESSION\" для поддержки ранжировщика на основе выражений (где EXPRESSION следует заменить вашей конкретной формулой ранжирования), и \"export:EXPRESSION\":\n\nCODE_BLOCK_31\n\nРанжировщик \"export\" работает аналогично ranker=expr, но сохраняет значения факторов для каждого документа, в то время как ranker=expr отбрасывает их после вычисления итогового значения `WEIGHT()`. Имейте в виду, что ranker=export предназначен для редкого использования, например, для обучения функции машинного обучения (ML) или ручного определения собственной функции ранжирования, и не должен использоваться в реальной эксплуатации. При использовании этого ранжировщика, скорее всего, вам захочется изучить вывод функции `RANKFACTORS()`, которая генерирует строку, содержащую все факторы на уровне полей для каждого документа.\n\n<!-- example SQL Example_2 -->\n\n<!-- request -->\n\nCODE_BLOCK_32\n\n<!-- response -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n* geoanchor - якорь геодистанции. Подробнее о геопоиске [в этом разделе](../Searching/Geo_search.md). Принимает 4 параметра: имена атрибутов широты и долготы, а также координаты якорной точки соответственно:\n\nCODE_BLOCK_34\n\nОчень **важное** замечание: **гораздо** эффективнее позволить Manticore выполнять сортировку, фильтрацию и нарезку набора результатов, чем увеличивать максимальное количество совпадений и использовать `WHERE`, `ORDER BY` и `LIMIT` на стороне MySQL. Это связано с двумя причинами. Во-первых, Manticore применяет различные оптимизации и выполняет эти задачи лучше, чем MySQL. Во-вторых, меньше данных нужно упаковывать searchd, передавать и распаковывать SphinxSE.\n\n### Важное замечание о сохранённых полях при использовании SphinxSE\n\nНачиная с версии 5.0.0, Manticore по умолчанию сохраняет все поля. При использовании Manticore вместе с MySQL или MariaDB через SphinxSE обычно нет смысла сохранять все поля, так как оригиналы уже хранятся в MySQL/MariaDB. В таких конфигурациях рекомендуется явно отключить сохранение полей для соответствующей таблицы Manticore, установив:\n\nCODE_BLOCK_35\n\nСм. справочник по настройке: [stored_fields](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#stored_fields).\n\nЕсли оставить значение по умолчанию (все поля сохранены) и затем выбрать много документов одновременно через SphinxSE, может быть превышен внутренний лимит движка, и вы получите ошибку вида:\n\n\"bad searchd response length\"\n\nУстановка `stored_fields =` предотвращает отправку больших сохранённых данных обратно в MySQL/MariaDB и предотвращает эту ошибку в типичных интеграциях SphinxSE.\n\n### SHOW ENGINE SPHINX STATUS\n\n<!-- example Example_3 -->\n\nВы можете получить дополнительную информацию, связанную с результатами запроса, используя оператор `SHOW ENGINE SPHINX STATUS`:\n\n<!-- request -->\n\nCODE_BLOCK_36\n\n<!-- response -->\n\nCODE_BLOCK_37\n\n<!-- end -->\n\n<!-- example Example_4 -->\n\nТакже эту информацию можно получить через переменные состояния. Учтите, что для этого способа не требуются права суперпользователя.\n\n<!-- request -->\n\nCODE_BLOCK_38\n\n<!-- response -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example SQL Example_5 -->\n\nТаблицы поиска SphinxSE можно объединять с таблицами, использующими другие движки. Вот пример с таблицей \"documents\" из example.sql:\n\n<!-- request -->\n\nCODE_BLOCK_40\n\n<!-- response -->\n\nCODE_BLOCK_41\n\n<!-- end -->\n\n## Создание сниппетов через MySQL\n\nSphinxSE также содержит функцию UDF, которая позволяет создавать сниппеты с помощью MySQL. Эта функциональность похожа на [HIGHLIGHT()](../Searching/Highlighting.md#Highlighting), но доступна через MySQL+SphinxSE.\n\nБинарный файл, предоставляющий UDF, называется `sphinx.so` и должен автоматически собираться и устанавливаться в нужное место вместе с SphinxSE. Если по какой-то причине он не устанавливается автоматически, найдите `sphinx.so` в каталоге сборки и скопируйте его в каталог плагинов вашей MySQL. После этого зарегистрируйте UDF следующей командой:\n\nCODE_BLOCK_42\n\nИмя функции *должно* быть sphinx_snippets; нельзя использовать произвольное имя. Аргументы функции следующие:\n\n**Прототип:** function sphinx_snippets ( document, table, words [, options] );\n\nАргументы document и words могут быть строками или столбцами таблицы. Опции должны задаваться так: `'value' AS option_name`. Для списка поддерживаемых опций смотрите раздел [Highlighting](../Searching/Highlighting.md). Единственная дополнительная опция, специфичная для UDF, называется `sphinx` и позволяет указать расположение searchd (хост и порт).\n\nПримеры использования:\n\nCODE_BLOCK_43\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "1889a8bbf6bd43cf1b183384109006e19f14d2b405f5ab4aa6115eed55090530": {
    "original": "# SphinxSE\n\nSphinxSE is a MySQL storage engine that can be compiled into MySQL/MariaDB servers using their pluggable architecture.\n\nDespite its name, SphinxSE does *not* actually store any data itself. Instead, it serves as a built-in client that enables the MySQL server to communicate with `searchd`, execute search queries, and retrieve search results. All indexing and searching take place outside MySQL.\n\nSome common SphinxSE applications include:\n\n* Simplifying the porting of MySQL Full-Text Search (FTS) applications to Manticore;\n\n* Enabling Manticore use with programming languages for which native APIs are not yet available;\n\n* Offering optimizations when additional Manticore result set processing is needed on the MySQL side (e.g., JOINs with original document tables or additional MySQL-side filtering).\n\n## Installing SphinxSE\n\nYou will need to obtain a copy of MySQL sources, prepare those, and then recompile MySQL binary. MySQL sources (mysql-5.x.yy.tar.gz) could be obtained from <http://dev.mysql.com> website.\n\n### Compiling MySQL 5.0.x with SphinxSE\n\n1.  copy `sphinx.5.0.yy.diff` patch file into MySQL sources directory and run\n\nCODE_BLOCK_0\n\nIf there's no .diff file exactly for the specific version you need to:   build, try applying .diff with closest version numbers.  It is important that the patch should apply with no rejects.\n\n2.  in MySQL sources directory, run\n\nCODE_BLOCK_1\n\n3.  in MySQL sources directory, create `sql/sphinx` directory in and copy all files in `mysqlse` directory from Manticore sources there. Example:\n\nCODE_BLOCK_2\n\n4.  configure MySQL and enable the new engine:\n\nCODE_BLOCK_3\n\n5.  build and install MySQL:\n\nCODE_BLOCK_4\n\n### Compiling MySQL 5.1.x with SphinxSE\n\n1. In the MySQL sources directory, create a `storage/sphinx` directory and copy all files from the `mysqlse` directory in the Manticore sources to this new location. For example:\n\nCODE_BLOCK_5\n\n2.  In the MySQL source directory, run:\n\nCODE_BLOCK_6\n\n3. Configure MySQL and enable the Manticore engine:\n\nCODE_BLOCK_7\n\n4. Build and install MySQL:\n\nCODE_BLOCK_8\n\n### Checking SphinxSE installation\n\n<!-- example Example_1 -->\n\nTo verify that SphinxSE has been successfully compiled into MySQL, start the newly built server, run the MySQL client, and issue the `SHOW ENGINES` query. You should see a list of all available engines. Manticore should be present, and the \"Support\" column should display \"YES\":\n\n<!-- request -->\n\nCODE_BLOCK_9\n\n<!-- response -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n## Using SphinxSE\n\nTo search using SphinxSE, you'll need to create a special ENGINE=SPHINX \"search table\" and then use a `SELECT` statement with the full-text query placed in the `WHERE` clause for the query column.\n\nHere's an example create statement and search query:\n\nCODE_BLOCK_11\n\nIn a search table, the first three columns *must* have the following types: `INTEGER UNSIGNED` or `BIGINT` for the 1st column (document ID), `INTEGER` or `BIGINT` for the 2nd column (match weight), and `VARCHAR` or `TEXT` for the 3rd column (your query). This mapping is fixed; you cannot omit any of these three required columns, move them around, or change their types. Additionally, the query column must be indexed, while all others should remain unindexed. Column names are ignored, so you can use any arbitrary names.\n\nAdditional columns must be either `INTEGER`, `TIMESTAMP`, `BIGINT`, `VARCHAR`, or `FLOAT`. They will be bound to attributes provided in the Manticore result set by name, so their names must match the attribute names specified in `sphinx.conf`. If there's no matching attribute name in the Manticore search results, the column will have `NULL` values.\n\nSpecial \"virtual\" attribute names can also be bound to SphinxSE columns. Use `_sph_` instead of `@` for that purpose. For example, to obtain the values of `@groupby`, `@count`, or `@distinct` virtual attributes, use `_sph_groupby`, `_sph_count`, or `_sph_distinct` column names, respectively.\n\nThe `CONNECTION` string parameter is used to specify the Manticore host, port, and table. If no connection string is specified in `CREATE TABLE`, the table name `*` (i.e., search all tables) and `localhost:9312` are assumed. The connection string syntax is as follows:\n\nCODE_BLOCK_12\n\nYou can change the default connection string later:\n\nCODE_BLOCK_13\n\nYou can also override these parameters on a per-query basis.\n\nAs shown in the example, both the query text and search options should be placed in the `WHERE` clause on the search query column (i.e., the 3rd column). Options are separated by semicolons and their names from values by an equality sign. Any number of options can be specified. The available options are:\n\n* query - query text;\n\n* mode - matching mode. Must be one of \"all\", \"any\", \"phrase\", \"boolean\", or \"extended\". Default is \"all\";\n\n* sort - match sorting mode. Must be one of \"relevance\", \"attr_desc\", \"attr_asc\", \"time_segments\", or \"extended\". In all modes besides \"relevance\", the attribute name (or sorting clause for \"extended\") is also required after a colon:\n\nCODE_BLOCK_14\n\n* offset - offset into the result set; default is 0;\n\n* limit - number of matches to retrieve from the result set; default is 20;\n\n* index - names of the tables to search:\n\nCODE_BLOCK_15\n\n* minid, maxid - min and max document ID to match;\n\n* weights - comma-separated list of weights to be assigned to Manticore full-text fields:\n\nCODE_BLOCK_16\n\n* filter, !filter - comma-separated attribute name and a set of values to match:\n\nCODE_BLOCK_17\n\n* range, !range - comma-separated (integer or bigint) Manticore attribute name, and min and max values to match:\n\nCODE_BLOCK_18\n\n* floatrange, !floatrange - comma-separated (floating point) Manticore attribute name, and min and max values to match:\n\nCODE_BLOCK_19\n\n* maxmatches - maxmatches - per-query max matches value, as in [max_matches search option](../Searching/Options.md#max_matches):\n\nCODE_BLOCK_20\n\n* cutoff - maximum allowed matches, as in [cutoff search option](../Searching/Options.md#cutoff):\n\nCODE_BLOCK_21",
    "translations": {
      "chinese": "# SphinxSE\n\nSphinxSE 是一个 MySQL 存储引擎，可以通过 MySQL/MariaDB 服务器的可插拔架构进行编译。\n\n尽管名字叫 SphinxSE，但它实际上并不存储任何数据。相反，它作为一个内置客户端，使 MySQL 服务器能够与 `searchd` 通信，执行搜索查询并检索搜索结果。所有的索引和搜索都在 MySQL 之外进行。\n\n一些常见的 SphinxSE 应用包括：\n\n* 简化将 MySQL 全文搜索（FTS）应用移植到 Manticore 的过程；\n\n* 使 Manticore 能够与尚无原生 API 的编程语言一起使用；\n\n* 当需要在 MySQL 端进行额外的 Manticore 结果集处理时提供优化（例如，与原始文档表的 JOIN 或额外的 MySQL 端过滤）。\n\n## 安装 SphinxSE\n\n您需要获取 MySQL 源代码，准备好后重新编译 MySQL 二进制文件。MySQL 源代码（mysql-5.x.yy.tar.gz）可以从 <http://dev.mysql.com> 网站获取。\n\n### 编译带有 SphinxSE 的 MySQL 5.0.x\n\n1. 将 `sphinx.5.0.yy.diff` 补丁文件复制到 MySQL 源代码目录并运行\n\nCODE_BLOCK_0\n\n如果没有针对您需要构建的具体版本的 .diff 文件，请尝试应用版本号最接近的 .diff。补丁必须能够无拒绝地应用。\n\n2. 在 MySQL 源代码目录中，运行\n\nCODE_BLOCK_1\n\n3. 在 MySQL 源代码目录中，创建 `sql/sphinx` 目录，并将 Manticore 源代码中的 `mysqlse` 目录下的所有文件复制到该目录。例如：\n\nCODE_BLOCK_2\n\n4. 配置 MySQL 并启用新引擎：\n\nCODE_BLOCK_3\n\n5. 构建并安装 MySQL：\n\nCODE_BLOCK_4\n\n### 编译带有 SphinxSE 的 MySQL 5.1.x\n\n1. 在 MySQL 源代码目录中，创建 `storage/sphinx` 目录，并将 Manticore 源代码中的 `mysqlse` 目录下的所有文件复制到该新位置。例如：\n\nCODE_BLOCK_5\n\n2. 在 MySQL 源代码目录中，运行：\n\nCODE_BLOCK_6\n\n3. 配置 MySQL 并启用 Manticore 引擎：\n\nCODE_BLOCK_7\n\n4. 构建并安装 MySQL：\n\nCODE_BLOCK_8\n\n### 检查 SphinxSE 安装\n\n<!-- example Example_1 -->\n\n要验证 SphinxSE 是否已成功编译到 MySQL 中，启动新构建的服务器，运行 MySQL 客户端，并执行 `SHOW ENGINES` 查询。您应该看到所有可用引擎的列表。Manticore 应该存在，且“Support”列应显示“YES”：\n\n<!-- request -->\n\nCODE_BLOCK_9\n\n<!-- response -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n## 使用 SphinxSE\n\n要使用 SphinxSE 进行搜索，您需要创建一个特殊的 ENGINE=SPHINX “搜索表”，然后使用带有全文查询的 `SELECT` 语句，将查询放在查询列的 `WHERE` 子句中。\n\n以下是示例创建语句和搜索查询：\n\nCODE_BLOCK_11\n\n在搜索表中，前三列 *必须* 具有以下类型：第 1 列（文档 ID）为 `INTEGER UNSIGNED` 或 `BIGINT`，第 2 列（匹配权重）为 `INTEGER` 或 `BIGINT`，第 3 列（您的查询）为 `VARCHAR` 或 `TEXT`。此映射是固定的；您不能省略这三列中的任何一列，不能更改它们的位置或类型。此外，查询列必须被索引，而其他列应保持未索引。列名被忽略，因此您可以使用任意名称。\n\n附加列必须是 `INTEGER`、`TIMESTAMP`、`BIGINT`、`VARCHAR` 或 `FLOAT`。它们将按名称绑定到 Manticore 结果集中提供的属性，因此它们的名称必须与 `sphinx.conf` 中指定的属性名称匹配。如果 Manticore 搜索结果中没有匹配的属性名称，该列将包含 `NULL` 值。\n\n特殊的“虚拟”属性名称也可以绑定到 SphinxSE 列。为此，请使用 `_sph_` 替代 `@`。例如，要获取 `@groupby`、`@count` 或 `@distinct` 虚拟属性的值，分别使用 `_sph_groupby`、`_sph_count` 或 `_sph_distinct` 列名。\n\n`CONNECTION` 字符串参数用于指定 Manticore 主机、端口和表。如果在 `CREATE TABLE` 中未指定连接字符串，则假定表名为 `*`（即搜索所有表）且为 `localhost:9312`。连接字符串语法如下：\n\nCODE_BLOCK_12\n\n您可以稍后更改默认连接字符串：\n\nCODE_BLOCK_13\n\n您也可以在每个查询中覆盖这些参数。\n\n如示例所示，查询文本和搜索选项都应放在搜索查询列（即第 3 列）的 `WHERE` 子句中。选项用分号分隔，名称和值用等号分隔。可以指定任意数量的选项。可用选项包括：\n\n* query - 查询文本；\n\n* mode - 匹配模式。必须是 \"all\"、\"any\"、\"phrase\"、\"boolean\" 或 \"extended\" 之一。默认是 \"all\"；\n\n* sort - 匹配排序模式。必须是 \"relevance\"、\"attr_desc\"、\"attr_asc\"、\"time_segments\" 或 \"extended\" 之一。除 \"relevance\" 外，其他模式后面还需要冒号后的属性名（或 \"extended\" 的排序子句）：\n\nCODE_BLOCK_14\n\n* offset - 结果集偏移量；默认是 0；\n\n* limit - 从结果集中检索的匹配数；默认是 20；\n\n* index - 要搜索的表名：\n\nCODE_BLOCK_15\n\n* minid, maxid - 匹配的最小和最大文档 ID；\n\n* weights - 赋予 Manticore 全文字段的权重的逗号分隔列表：\n\nCODE_BLOCK_16\n\n* filter, !filter - 逗号分隔的属性名和要匹配的值集合：\n\nCODE_BLOCK_17\n\n* range, !range - 逗号分隔的（整数或 bigint）Manticore 属性名，以及要匹配的最小和最大值：\n\nCODE_BLOCK_18\n\n* floatrange, !floatrange - 逗号分隔的（浮点数）Manticore 属性名，以及要匹配的最小和最大值：\n\nCODE_BLOCK_19\n\n* maxmatches - 每查询最大匹配数值，如 [max_matches 搜索选项](../Searching/Options.md#max_matches)：\n\nCODE_BLOCK_20\n\n* cutoff - 最大允许匹配数，如 [cutoff 搜索选项](../Searching/Options.md#cutoff)：\n\nCODE_BLOCK_21",
      "russian": "# SphinxSE\n\nSphinxSE — это движок хранения MySQL, который можно скомпилировать в серверы MySQL/MariaDB, используя их модульную архитектуру.\n\nНесмотря на своё название, SphinxSE *не* хранит данные самостоятельно. Вместо этого он служит встроенным клиентом, который позволяет серверу MySQL взаимодействовать с `searchd`, выполнять поисковые запросы и получать результаты поиска. Вся индексация и поиск происходят вне MySQL.\n\nНекоторые распространённые применения SphinxSE включают:\n\n* Упрощение переноса приложений MySQL Full-Text Search (FTS) на Manticore;\n\n* Обеспечение использования Manticore с языками программирования, для которых нативные API ещё не доступны;\n\n* Предоставление оптимизаций, когда требуется дополнительная обработка результатов Manticore на стороне MySQL (например, JOIN с оригинальными таблицами документов или дополнительная фильтрация на стороне MySQL).\n\n## Установка SphinxSE\n\nВам потребуется получить исходники MySQL, подготовить их и затем перекомпилировать бинарный файл MySQL. Исходники MySQL (mysql-5.x.yy.tar.gz) можно получить с сайта <http://dev.mysql.com>.\n\n### Компиляция MySQL 5.0.x с SphinxSE\n\n1.  скопируйте патч-файл `sphinx.5.0.yy.diff` в директорию с исходниками MySQL и выполните\n\nCODE_BLOCK_0\n\nЕсли нет .diff файла именно для нужной версии:   сборки, попробуйте применить .diff с ближайшими номерами версий. Важно, чтобы патч применился без конфликтов.\n\n2.  в директории с исходниками MySQL выполните\n\nCODE_BLOCK_1\n\n3.  в директории с исходниками MySQL создайте каталог `sql/sphinx` и скопируйте туда все файлы из каталога `mysqlse` исходников Manticore. Пример:\n\nCODE_BLOCK_2\n\n4.  настройте MySQL и включите новый движок:\n\nCODE_BLOCK_3\n\n5.  соберите и установите MySQL:\n\nCODE_BLOCK_4\n\n### Компиляция MySQL 5.1.x с SphinxSE\n\n1. В директории с исходниками MySQL создайте каталог `storage/sphinx` и скопируйте все файлы из каталога `mysqlse` исходников Manticore в это новое место. Например:\n\nCODE_BLOCK_5\n\n2.  В директории с исходниками MySQL выполните:\n\nCODE_BLOCK_6\n\n3. Настройте MySQL и включите движок Manticore:\n\nCODE_BLOCK_7\n\n4. Соберите и установите MySQL:\n\nCODE_BLOCK_8\n\n### Проверка установки SphinxSE\n\n<!-- example Example_1 -->\n\nЧтобы убедиться, что SphinxSE успешно скомпилирован в MySQL, запустите вновь собранный сервер, выполните клиент MySQL и выполните запрос `SHOW ENGINES`. Вы должны увидеть список всех доступных движков. Manticore должен присутствовать, а в столбце \"Support\" должно быть \"YES\":\n\n<!-- request -->\n\nCODE_BLOCK_9\n\n<!-- response -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n## Использование SphinxSE\n\nДля поиска с помощью SphinxSE необходимо создать специальную \"поисковую таблицу\" с ENGINE=SPHINX, а затем использовать оператор `SELECT` с полнотекстовым запросом, помещённым в условие `WHERE` для колонки запроса.\n\nВот пример оператора создания и поискового запроса:\n\nCODE_BLOCK_11\n\nВ поисковой таблице первые три колонки *должны* иметь следующие типы: `INTEGER UNSIGNED` или `BIGINT` для первой колонки (ID документа), `INTEGER` или `BIGINT` для второй колонки (вес совпадения) и `VARCHAR` или `TEXT` для третьей колонки (ваш запрос). Это сопоставление фиксировано; нельзя пропускать какие-либо из этих трёх обязательных колонок, менять их порядок или типы. Кроме того, колонка запроса должна быть индексирована, а все остальные — не индексированы. Имена колонок игнорируются, поэтому можно использовать любые произвольные имена.\n\nДополнительные колонки должны быть одного из типов: `INTEGER`, `TIMESTAMP`, `BIGINT`, `VARCHAR` или `FLOAT`. Они будут связаны с атрибутами, предоставленными в наборе результатов Manticore по имени, поэтому их имена должны совпадать с именами атрибутов, указанными в `sphinx.conf`. Если в результатах поиска Manticore нет соответствующего имени атрибута, в колонке будут значения `NULL`.\n\nСпециальные \"виртуальные\" имена атрибутов также могут быть связаны с колонками SphinxSE. Для этого используйте `_sph_` вместо `@`. Например, чтобы получить значения виртуальных атрибутов `@groupby`, `@count` или `@distinct`, используйте имена колонок `_sph_groupby`, `_sph_count` или `_sph_distinct` соответственно.\n\nПараметр строки `CONNECTION` используется для указания хоста, порта и таблицы Manticore. Если в `CREATE TABLE` не указана строка подключения, предполагается имя таблицы `*` (т.е. поиск по всем таблицам) и `localhost:9312`. Синтаксис строки подключения следующий:\n\nCODE_BLOCK_12\n\nВы можете изменить строку подключения по умолчанию позже:\n\nCODE_BLOCK_13\n\nТакже эти параметры можно переопределить для каждого запроса.\n\nКак показано в примере, и текст запроса, и параметры поиска должны быть помещены в условие `WHERE` для колонки поискового запроса (т.е. третьей колонки). Опции разделяются точкой с запятой, а имена опций отделяются от значений знаком равенства. Можно указать любое количество опций. Доступные опции:\n\n* query - текст запроса;\n\n* mode - режим сопоставления. Должен быть одним из \"all\", \"any\", \"phrase\", \"boolean\" или \"extended\". По умолчанию \"all\";\n\n* sort - режим сортировки совпадений. Должен быть одним из \"relevance\", \"attr_desc\", \"attr_asc\", \"time_segments\" или \"extended\". Во всех режимах, кроме \"relevance\", после двоеточия требуется имя атрибута (или сортировочное выражение для \"extended\"):\n\nCODE_BLOCK_14\n\n* offset - смещение в наборе результатов; по умолчанию 0;\n\n* limit - количество совпадений для извлечения из набора результатов; по умолчанию 20;\n\n* index - имена таблиц для поиска:\n\nCODE_BLOCK_15\n\n* minid, maxid - минимальный и максимальный ID документа для совпадения;\n\n* weights - список весов, разделённых запятыми, которые будут назначены полнотекстовым полям Manticore:\n\nCODE_BLOCK_16\n\n* filter, !filter - имя атрибута и набор значений для фильтрации, разделённые запятыми:\n\nCODE_BLOCK_17\n\n* range, !range - имя атрибута Manticore (integer или bigint) и минимальное и максимальное значения для фильтрации, разделённые запятыми:\n\nCODE_BLOCK_18\n\n* floatrange, !floatrange - имя атрибута Manticore (с плавающей точкой) и минимальное и максимальное значения для фильтрации, разделённые запятыми:\n\nCODE_BLOCK_19\n\n* maxmatches - максимальное количество совпадений для запроса, как в [опции поиска max_matches](../Searching/Options.md#max_matches):\n\nCODE_BLOCK_20\n\n* cutoff - максимальное допустимое количество совпадений, как в [опции поиска cutoff](../Searching/Options.md#cutoff):\n\nCODE_BLOCK_21"
    },
    "is_code_or_comment": false
  },
  "c568e38630c9d80bb6de23c7838cd8a12afcefc748ec650b629791137b2e3e83": {
    "original": "* maxquerytime - maximum allowed query time (in milliseconds), as in [max_query_time search option](../Searching/Options.md#max_query_time):\n\nCODE_BLOCK_24\n\n* groupby - group-by function and attribute. Read [this](../Searching/Grouping.md#Just-Grouping) about grouping search results:\n\nCODE_BLOCK_25\n\n* groupsort - group-by sorting clause:\n\nCODE_BLOCK_26\n\n* distinct - an attribute to compute [COUNT(DISTINCT)](../Searching/Grouping.md#COUNT%28DISTINCT-field%29) for when doing group-by:\n\nCODE_BLOCK_27\n\n* indexweights - comma-separated list of table names and weights to use when searching through several tables:\n\nCODE_BLOCK_28\n\n* fieldweights - comma-separated list of per-field weights that can be used by the ranker:\n\nCODE_BLOCK_29\n\n* comment - a string to mark this query in query log, as in [comment search option](../Searching/Options.md#comment):\n\nCODE_BLOCK_30\n\n* select - a string with expressions to compute:\n\nCODE_BLOCK_31\n\n* host, port - remote `searchd` host name and TCP port, respectively:\n\nCODE_BLOCK_32\n\n* ranker - a ranking function to use with \"extended\" matching mode, as in [ranker](../Searching/Options.md#ranker). Known values are \"proximity_bm25\", \"bm25\", \"none\", \"wordcount\", \"proximity\", \"matchany\", \"fieldmask\", \"sph04\", \"expr:EXPRESSION\" syntax to support expression-based ranker (where EXPRESSION should be replaced with your specific ranking formula), and \"export:EXPRESSION\":\n\nCODE_BLOCK_33\n\nThe \"export\" ranker functions similarly to ranker=expr, but it retains the per-document factor values, while ranker=expr discards them after computing the final `WEIGHT()` value. Keep in mind that ranker=export is intended for occasional use, such as training a machine learning (ML) function or manually defining your own ranking function, and should not be used in actual production. When utilizing this ranker, you'll likely want to examine the output of the `RANKFACTORS()` function, which generates a string containing all the field-level factors for each document.\n\n<!-- example SQL Example_2 -->\n\n<!-- request -->\n\nCODE_BLOCK_34\n\n<!-- response -->\n\nCODE_BLOCK_35\n\n<!-- end -->\n\n* geoanchor - geodistance anchor. Learn more about Geo-search [in this section](../Searching/Geo_search.md). Takes 4 parameters, which are the latitude and longitude attribute names, and anchor point coordinates, respectively:\n\nCODE_BLOCK_36\n\nOne **very important** note is that it is **much** more efficient to let Manticore handle sorting, filtering, and slicing the result set, rather than increasing the max matches count and using `WHERE`, `ORDER BY`, and `LIMIT` clauses on the MySQL side. This is due to two reasons. First, Manticore employs a variety of optimizations and performs these tasks better than MySQL. Second, less data would need to be packed by searchd, transferred, and unpacked by SphinxSE.\n\n### Important note about stored fields when using SphinxSE\n\nSince version 5.0.0, Manticore stores all fields by default. When Manticore is used together with MySQL or MariaDB via SphinxSE, storing all fields usually does not make sense because the originals are already stored in MySQL/MariaDB. In such setups it is recommended to explicitly disable stored fields for the involved Manticore table by setting:\n\nCODE_BLOCK_37\n\nSee the setting reference: [stored_fields](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#stored_fields).\n\nIf you keep the default (all fields stored) and then select a lot of documents at once through SphinxSE, an internal limit in the engine may be exceeded and you may receive an error like:\n\n\"bad searchd response length\"\n\nSetting `stored_fields =` avoids sending large stored payloads back to MySQL/MariaDB and prevents this error in typical SphinxSE integrations.\n\n### SHOW ENGINE SPHINX STATUS\n\n<!-- example Example_3 -->\n\nYou can obtain additional information related to the query results using the `SHOW ENGINE SPHINX STATUS` statement:\n\n<!-- request -->\n\nCODE_BLOCK_38\n\n<!-- response -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example Example_4 -->\n\nYou can also access this information through status variables. Keep in mind that using this method does not require super-user privileges.\n\n<!-- request -->\n\nCODE_BLOCK_40\n\n<!-- response -->\n\nCODE_BLOCK_41\n\n<!-- end -->\n\n<!-- example SQL Example_5 -->\n\nSphinxSE search tables can be joined with tables using other engines. Here's an example using the \"documents\" table from example.sql:\n\n<!-- request -->\n\nCODE_BLOCK_42\n\n<!-- response -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n## Building snippets via MySQL\n\nSphinxSE also features a UDF function that allows you to create snippets using MySQL. This functionality is similar to [HIGHLIGHT()](../Searching/Highlighting.md#Highlighting), but can be accessed through MySQL+SphinxSE.\n\nThe binary providing the UDF is called `sphinx.so` and should be automatically built and installed in the appropriate location along with SphinxSE. If it doesn't install automatically for some reason, locate `sphinx.so` in the build directory and copy it to your MySQL instance's plugins directory. Once done, register the UDF with the following statement:\n\nCODE_BLOCK_44\n\nThe function name *must* be sphinx_snippets; you cannot use an arbitrary name. The function arguments are as follows:\n\n**Prototype:** function sphinx_snippets ( document, table, words [, options] );\n\nThe document and words arguments can be either strings or table columns. Options must be specified like this: `'value' AS option_name`. For a list of supported options, refer to the [Highlighting section](../Searching/Highlighting.md). The only UDF-specific additional option is called `sphinx` and allows you to specify the searchd location (host and port).\n\nUsage examples:\n\nCODE_BLOCK_45\n\n<!-- proofread -->",
    "translations": {
      "chinese": "* maxquerytime - 最大允许的查询时间（以毫秒为单位），如同 [max_query_time 搜索选项](../Searching/Options.md#max_query_time) 中所示：\n\nCODE_BLOCK_24\n\n* groupby - 分组函数和属性。请阅读 [这篇文章](../Searching/Grouping.md#Just-Grouping) 了解分组搜索结果：\n\nCODE_BLOCK_25\n\n* groupsort - 分组排序子句：\n\nCODE_BLOCK_26\n\n* distinct - 做分组时要计算的 [COUNT(DISTINCT)](../Searching/Grouping.md#COUNT%28DISTINCT-field%29) 的属性：\n\nCODE_BLOCK_27\n\n* indexweights - 用逗号分隔的表名和权重列表，用于搜索多个表时：\n\nCODE_BLOCK_28\n\n* fieldweights - 每个字段权重的逗号分隔列表，可被排序器使用：\n\nCODE_BLOCK_29\n\n* comment - 一个字符串，用于在查询日志中标记此查询，如同 [comment 搜索选项](../Searching/Options.md#comment)：\n\nCODE_BLOCK_30\n\n* select - 用于计算的表达式字符串：\n\nCODE_BLOCK_31\n\n* host, port - 远程 `searchd` 的主机名和 TCP 端口，分别为：\n\nCODE_BLOCK_32\n\n* ranker - 用于“扩展”匹配模式的排名函数，如同 [ranker](../Searching/Options.md#ranker)。已知的值包括 \"proximity_bm25\"、\"bm25\"、\"none\"、\"wordcount\"、\"proximity\"、\"matchany\"、\"fieldmask\"、\"sph04\"、\"expr:EXPRESSION\" 语法支持基于表达式的排序器（其中 EXPRESSION 应被替换为您具体的排名公式），以及 \"export:EXPRESSION\"：\n\nCODE_BLOCK_33\n\n\"export\" 排名器的功能类似于 ranker=expr，但它保留每个文档的因子值，而 ranker=expr 在计算最终的 `WEIGHT()` 值后会丢弃它们。请注意，ranker=export 主要用于偶尔使用，比如训练机器学习（ML）函数或手动定义您自己的排名函数，不应在实际生产中使用。当使用此排名器时，您可能需要查看 `RANKFACTORS()` 函数的输出，它生成一个包含每个文档字段级因子的字符串。\n\n<!-- example SQL Example_2 -->\n\n<!-- request -->\n\nCODE_BLOCK_34\n\n<!-- response -->\n\nCODE_BLOCK_35\n\n<!-- end -->\n\n* geoanchor - 地理距离锚点。更多关于地理搜索信息，请参见[本节](../Searching/Geo_search.md)。接受4个参数，分别是纬度和经度属性名，以及锚点坐标：\n\nCODE_BLOCK_36\n\n一个**非常重要**的注意事项是，让 Manticore 处理排序、过滤和结果集切片要**高效得多**，而不是增加最大匹配数量并在 MySQL 端使用 `WHERE`、`ORDER BY` 和 `LIMIT` 子句。这有两个原因。首先，Manticore 使用多种优化技术，执行这些任务比 MySQL 更加高效。其次，需要由 searchd 打包、传输和由 SphinxSE 解包的数据量会更少。\n\n### 使用 SphinxSE 时关于存储字段的重要提示\n\n从版本 5.0.0 起，Manticore 默认存储所有字段。当 Manticore 通过 SphinxSE 与 MySQL 或 MariaDB 一起使用时，通常存储所有字段是没有意义的，因为原始数据已存储在 MySQL/MariaDB 中。在这种设置下，建议显式禁用相关 Manticore 表的存储字段，方法是设置：\n\nCODE_BLOCK_37\n\n请参阅设置参考：[stored_fields](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#stored_fields)。\n\n如果保留默认值（存储所有字段），然后通过 SphinxSE 一次选择大量文档，可能会超过引擎中的内部限制，并收到类似如下错误：\n\n\"bad searchd response length\"\n\n设置 `stored_fields =` 可以避免将大量存储的负载发送回 MySQL/MariaDB，并防止此错误在典型的 SphinxSE 集成中发生。\n\n### SHOW ENGINE SPHINX STATUS\n\n<!-- example Example_3 -->\n\n您可以使用 `SHOW ENGINE SPHINX STATUS` 语句获取与查询结果相关的更多信息：\n\n<!-- request -->\n\nCODE_BLOCK_38\n\n<!-- response -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example Example_4 -->\n\n您也可以通过状态变量访问此信息。请注意，使用此方法不需要超级用户权限。\n\n<!-- request -->\n\nCODE_BLOCK_40\n\n<!-- response -->\n\nCODE_BLOCK_41\n\n<!-- end -->\n\n<!-- example SQL Example_5 -->\n\nSphinxSE 搜索表可以与其他引擎的表进行联接。以下示例使用 example.sql 中的 \"documents\" 表：\n\n<!-- request -->\n\nCODE_BLOCK_42\n\n<!-- response -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n## 通过 MySQL 构建摘录\n\nSphinxSE 还提供了一个 UDF 函数，允许您通过 MySQL 创建摘录。这一功能类似于 [HIGHLIGHT()](../Searching/Highlighting.md#Highlighting)，但可以通过 MySQL+SphinxSE 访问。\n\n提供该 UDF 的二进制文件称为 `sphinx.so`，应当随着 SphinxSE 自动构建并安装到适当的位置。如果由于某些原因未自动安装，请在构建目录中找到 `sphinx.so` 并复制到您的 MySQL 实例的插件目录。完成后，通过以下语句注册该 UDF：\n\nCODE_BLOCK_44\n\n函数名*必须*是 sphinx_snippets；不能使用任意名称。函数参数如下：\n\n**原型：** function sphinx_snippets ( document, table, words [, options] );\n\ndocument 和 words 参数可以是字符串或表列。选项必须像这样指定：`'value' AS option_name`。支持的选项列表，请参见 [高亮部分](../Searching/Highlighting.md)。唯一的 UDF 特有附加选项称为 `sphinx`，允许您指定 searchd 的位置（主机和端口）。\n\n使用示例：\n\nCODE_BLOCK_45\n\n<!-- proofread -->",
      "russian": "* maxquerytime - максимальное допустимое время выполнения запроса (в миллисекундах), как в [опции поиска max_query_time](../Searching/Options.md#max_query_time):\n\nCODE_BLOCK_24\n\n* groupby - функция группировки и атрибут. Подробнее об [группировке результатов поиска](../Searching/Grouping.md#Just-Grouping):\n\nCODE_BLOCK_25\n\n* groupsort - параметр сортировки при группировке:\n\nCODE_BLOCK_26\n\n* distinct - атрибут для вычисления [COUNT(DISTINCT)](../Searching/Grouping.md#COUNT%28DISTINCT-field%29) при выполнении группировки:\n\nCODE_BLOCK_27\n\n* indexweights - список через запятую с именами таблиц и весами, используемыми при поиске по нескольким таблицам:\n\nCODE_BLOCK_28\n\n* fieldweights - список через запятую с весами для отдельных полей, которые могут использоваться ранжировщиком:\n\nCODE_BLOCK_29\n\n* comment - строка для пометки этого запроса в журнале запросов, как в [опции поиска comment](../Searching/Options.md#comment):\n\nCODE_BLOCK_30\n\n* select - строка с выражениями для вычисления:\n\nCODE_BLOCK_31\n\n* host, port - имя хоста удалённого `searchd` и TCP-порт соответственно:\n\nCODE_BLOCK_32\n\n* ranker - функция ранжирования, используемая в режиме \"extended\" сопоставления, как в [ranker](../Searching/Options.md#ranker). Известные значения: \"proximity_bm25\", \"bm25\", \"none\", \"wordcount\", \"proximity\", \"matchany\", \"fieldmask\", \"sph04\", синтаксис \"expr:EXPRESSION\" для поддержки ранжировщика на основе выражения (где EXPRESSION следует заменить на вашу конкретную формулу ранжирования), а также \"export:EXPRESSION\":\n\nCODE_BLOCK_33\n\nРанжировщик \"export\" работает аналогично ranker=expr, но сохраняет значения факторов для каждого документа, в то время как ranker=expr отбрасывает их после вычисления окончательного значения `WEIGHT()`. Имейте в виду, что ranker=export предназначен для редкого использования, например, для обучения функции машинного обучения (ML) или ручного определения собственной функции ранжирования, и не должен использоваться в реальной производственной среде. При использовании этого ранжировщика, вероятно, вы захотите изучить вывод функции `RANKFACTORS()`, которая генерирует строку, содержащую все факторы на уровне поля для каждого документа.\n\n<!-- example SQL Example_2 -->\n\n<!-- request -->\n\nCODE_BLOCK_34\n\n<!-- response -->\n\nCODE_BLOCK_35\n\n<!-- end -->\n\n* geoanchor - геодистанционная привязка. Подробнее о гео-поиске [в этом разделе](../Searching/Geo_search.md). Принимает 4 параметра, которые являются именами атрибутов широты и долготы, а также координатами якорной точки соответственно:\n\nCODE_BLOCK_36\n\nОдно **очень важное** замечание: **намного** эффективнее позволить Manticore выполнять сортировку, фильтрацию и нарезку результирующего набора, чем увеличивать количество максимальных совпадений и использовать выражения `WHERE`, `ORDER BY` и `LIMIT` на стороне MySQL. Это связано с двумя причинами. Во-первых, Manticore использует разнообразные оптимизации и выполняет эти задачи лучше, чем MySQL. Во-вторых, меньше данных нужно будет упаковывать searchd, передавать и распаковывать SphinxSE.\n\n### Важное замечание о сохранённых полях при использовании SphinxSE\n\nНачиная с версии 5.0.0, Manticore по умолчанию сохраняет все поля. Когда Manticore используется вместе с MySQL или MariaDB через SphinxSE, обычно нет смысла сохранять все поля, поскольку оригиналы уже сохранены в MySQL/MariaDB. В таких случаях рекомендуется явно отключить сохранение полей для соответствующей таблицы Manticore с помощью параметра:\n\nCODE_BLOCK_37\n\nСм. справку по настройке: [stored_fields](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#stored_fields).\n\nЕсли оставить значение по умолчанию (все поля сохраняются) и при этом выполнить выборку большого количества документов через SphinxSE, может быть превышен внутренний лимит в движке, и вы получите ошибку вида:\n\n\"bad searchd response length\"\n\nУстановка `stored_fields =` позволяет избежать отправки больших сохранённых данных обратно в MySQL/MariaDB и предотвращает эту ошибку при типичной интеграции с SphinxSE.\n\n### SHOW ENGINE SPHINX STATUS\n\n<!-- example Example_3 -->\n\nВы можете получить дополнительную информацию, связанную с результатами запроса, используя оператор `SHOW ENGINE SPHINX STATUS`:\n\n<!-- request -->\n\nCODE_BLOCK_38\n\n<!-- response -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example Example_4 -->\n\nТакже эту информацию можно получить через переменные статуса. Учтите, что этот способ не требует прав суперпользователя.\n\n<!-- request -->\n\nCODE_BLOCK_40\n\n<!-- response -->\n\nCODE_BLOCK_41\n\n<!-- end -->\n\n<!-- example SQL Example_5 -->\n\nТаблицы поиска SphinxSE могут объединяться с таблицами, использующими другие движки. Вот пример с таблицей \"documents\" из example.sql:\n\n<!-- request -->\n\nCODE_BLOCK_42\n\n<!-- response -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n## Создание сниппетов через MySQL\n\nSphinxSE также содержит функцию UDF, которая позволяет создавать сниппеты с помощью MySQL. Эта функциональность похожа на [HIGHLIGHT()](../Searching/Highlighting.md#Highlighting), но доступна через MySQL+SphinxSE.\n\nБинарный файл с реализацией UDF называется `sphinx.so` и должен автоматически собираться и устанавливаться в нужное место вместе с SphinxSE. Если он не установился автоматически по какой-то причине, найдите `sphinx.so` в каталоге сборки и скопируйте его в директорию плагинов вашей инсталляции MySQL. После этого зарегистрируйте UDF следующей командой:\n\nCODE_BLOCK_44\n\nИмя функции *обязательно* должно быть sphinx_snippets; нельзя использовать произвольное имя. Аргументы функции таковы:\n\n**Прототип:** function sphinx_snippets ( document, table, words [, options] );\n\nАргументы document и words могут быть как строками, так и столбцами таблицы. Опции должны указываться в формате: `'value' AS option_name`. Список поддерживаемых опций см. в разделе [Подсветка](../Searching/Highlighting.md). Единственной дополнительной опцией, специфичной для UDF, является `sphinx`, которая позволяет указать расположение searchd (хост и порт).\n\nПримеры использования:\n\nCODE_BLOCK_45\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "b94cc33558e1d665ca20241f44a7ebacd739ec32379e1099993b000c9147ba8a": {
    "original": "# SphinxSE\n\nSphinxSE is a MySQL storage engine that can be compiled into MySQL/MariaDB servers using their pluggable architecture.\n\nDespite its name, SphinxSE does *not* actually store any data itself. Instead, it serves as a built-in client that enables the MySQL server to communicate with `searchd`, execute search queries, and retrieve search results. All indexing and searching take place outside MySQL.\n\nSome common SphinxSE applications include:\n\n* Simplifying the porting of MySQL Full-Text Search (FTS) applications to Manticore;\n\n* Enabling Manticore use with programming languages for which native APIs are not yet available;\n\n* Offering optimizations when additional Manticore result set processing is needed on the MySQL side (e.g., JOINs with original document tables or additional MySQL-side filtering).\n\n## Installing SphinxSE\n\nYou will need to obtain a copy of MySQL sources, prepare those, and then recompile MySQL binary. MySQL sources (mysql-5.x.yy.tar.gz) could be obtained from <http://dev.mysql.com> website.\n\n### Compiling MySQL 5.0.x with SphinxSE\n\n1.  copy `sphinx.5.0.yy.diff` patch file into MySQL sources directory and run\n\nCODE_BLOCK_0\n\nIf there's no .diff file exactly for the specific version you need to:   build, try applying .diff with closest version numbers.  It is important that the patch should apply with no rejects.\n\n2.  in MySQL sources directory, run\n\nCODE_BLOCK_1\n\n3.  in MySQL sources directory, create `sql/sphinx` directory in and copy all files in `mysqlse` directory from Manticore sources there. Example:\n\nCODE_BLOCK_2\n\n4.  configure MySQL and enable the new engine:\n\nCODE_BLOCK_3\n\n5.  build and install MySQL:\n\nCODE_BLOCK_4\n\n### Compiling MySQL 5.1.x with SphinxSE\n\n1. In the MySQL sources directory, create a `storage/sphinx` directory and copy all files from the `mysqlse` directory in the Manticore sources to this new location. For example:\n\nCODE_BLOCK_5\n\n2.  In the MySQL source directory, run:\n\nCODE_BLOCK_6\n\n3. Configure MySQL and enable the Manticore engine:\n\nCODE_BLOCK_7\n\n4. Build and install MySQL:\n\nCODE_BLOCK_8\n\n### Checking SphinxSE installation\n\n<!-- example Example_1 -->\n\nTo verify that SphinxSE has been successfully compiled into MySQL, start the newly built server, run the MySQL client, and issue the `SHOW ENGINES` query. You should see a list of all available engines. Manticore should be present, and the \"Support\" column should display \"YES\":\n\n<!-- request -->\n\nCODE_BLOCK_9\n\n<!-- response -->\n\nCODE_BLOCK_10\n\n<!-- request JSON -->\n\nCODE_BLOCK_11\n\n<!-- response JSON -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n## Using SphinxSE\n\nTo search using SphinxSE, you'll need to create a special ENGINE=SPHINX \"search table\" and then use a `SELECT` statement with the full-text query placed in the `WHERE` clause for the query column.\n\nHere's an example create statement and search query:\n\nCODE_BLOCK_13\n\nIn a search table, the first three columns *must* have the following types: `INTEGER UNSIGNED` or `BIGINT` for the 1st column (document ID), `INTEGER` or `BIGINT` for the 2nd column (match weight), and `VARCHAR` or `TEXT` for the 3rd column (your query). This mapping is fixed; you cannot omit any of these three required columns, move them around, or change their types. Additionally, the query column must be indexed, while all others should remain unindexed. Column names are ignored, so you can use any arbitrary names.\n\nAdditional columns must be either `INTEGER`, `TIMESTAMP`, `BIGINT`, `VARCHAR`, or `FLOAT`. They will be bound to attributes provided in the Manticore result set by name, so their names must match the attribute names specified in `sphinx.conf`. If there's no matching attribute name in the Manticore search results, the column will have `NULL` values.\n\nSpecial \"virtual\" attribute names can also be bound to SphinxSE columns. Use `_sph_` instead of `@` for that purpose. For example, to obtain the values of `@groupby`, `@count`, or `@distinct` virtual attributes, use `_sph_groupby`, `_sph_count`, or `_sph_distinct` column names, respectively.\n\nThe `CONNECTION` string parameter is used to specify the Manticore host, port, and table. If no connection string is specified in `CREATE TABLE`, the table name `*` (i.e., search all tables) and `localhost:9312` are assumed. The connection string syntax is as follows:\n\nCODE_BLOCK_14\n\nYou can change the default connection string later:\n\nCODE_BLOCK_15\n\nYou can also override these parameters on a per-query basis.\n\nAs shown in the example, both the query text and search options should be placed in the `WHERE` clause on the search query column (i.e., the 3rd column). Options are separated by semicolons and their names from values by an equality sign. Any number of options can be specified. The available options are:\n\n* query - query text;\n\n* mode - matching mode. Must be one of \"all\", \"any\", \"phrase\", \"boolean\", or \"extended\". Default is \"all\";\n\n* sort - match sorting mode. Must be one of \"relevance\", \"attr_desc\", \"attr_asc\", \"time_segments\", or \"extended\". In all modes besides \"relevance\", the attribute name (or sorting clause for \"extended\") is also required after a colon:\n\nCODE_BLOCK_16\n\n* offset - offset into the result set; default is 0;\n\n* limit - number of matches to retrieve from the result set; default is 20;\n\n* index - names of the tables to search:\n\nCODE_BLOCK_17\n\n* minid, maxid - min and max document ID to match;\n\n* weights - comma-separated list of weights to be assigned to Manticore full-text fields:\n\nCODE_BLOCK_18\n\n* filter, !filter - comma-separated attribute name and a set of values to match:\n\nCODE_BLOCK_19\n\n* range, !range - comma-separated (integer or bigint) Manticore attribute name, and min and max values to match:\n\nCODE_BLOCK_20\n\n* floatrange, !floatrange - comma-separated (floating point) Manticore attribute name, and min and max values to match:\n\nCODE_BLOCK_21\n\n* maxmatches - maxmatches - per-query max matches value, as in [max_matches search option](../Searching/Options.md#max_matches):\n\nCODE_BLOCK_22\n\n* cutoff - maximum allowed matches, as in [cutoff search option](../Searching/Options.md#cutoff):\n\nCODE_BLOCK_23",
    "translations": {
      "chinese": "# SphinxSE\n\nSphinxSE 是一个 MySQL 存储引擎，可以使用 MySQL/MariaDB 服务器的可插拔架构编译到 MySQL/MariaDB 服务器中。\n\n尽管名字叫 SphinxSE，实际上它并*不*存储任何数据。相反，它作为内置客户端，使 MySQL 服务器能够与 `searchd` 通信，执行搜索查询并检索搜索结果。所有索引和搜索都发生在 MySQL 之外。\n\n一些常见的 SphinxSE 应用包括：\n\n* 简化 MySQL 全文搜索（FTS）应用程序向 Manticore 的移植；\n\n* 使尚无本地 API 支持的编程语言能够使用 Manticore；\n\n* 当需要在 MySQL 端对 Manticore 结果集进行额外处理时（例如，与原始文档表的 JOIN 或额外的 MySQL 端过滤）提供优化。\n\n## 安装 SphinxSE\n\n您需要获取 MySQL 源代码，进行准备，然后重新编译 MySQL 二进制文件。MySQL 源代码（mysql-5.x.yy.tar.gz）可从 <http://dev.mysql.com> 网站获取。\n\n### 编译带有 SphinxSE 的 MySQL 5.0.x\n\n1. 将 `sphinx.5.0.yy.diff` 补丁文件复制到 MySQL 源代码目录并运行\n\nCODE_BLOCK_0\n\n如果没有针对您需要的具体版本的 .diff 文件，尝试应用版本号最接近的 .diff 文件。补丁必须无冲突地应用成功。\n\n2. 在 MySQL 源代码目录，运行\n\nCODE_BLOCK_1\n\n3. 在 MySQL 源代码目录，创建 `sql/sphinx` 目录，并将 Manticore 源代码中的 `mysqlse` 目录内的所有文件复制到此处。例如：\n\nCODE_BLOCK_2\n\n4. 配置 MySQL 并启用新引擎：\n\nCODE_BLOCK_3\n\n5. 编译并安装 MySQL：\n\nCODE_BLOCK_4\n\n### 编译带有 SphinxSE 的 MySQL 5.1.x\n\n1. 在 MySQL 源代码目录，创建 `storage/sphinx` 目录，并将 Manticore 源代码中 `mysqlse` 目录的所有文件复制到该位置。例如：\n\nCODE_BLOCK_5\n\n2. 在 MySQL 源代码目录运行：\n\nCODE_BLOCK_6\n\n3. 配置 MySQL 并启用 Manticore 引擎：\n\nCODE_BLOCK_7\n\n4. 编译并安装 MySQL：\n\nCODE_BLOCK_8\n\n### 检查 SphinxSE 安装\n\n<!-- example Example_1 -->\n\n要验证 SphinxSE 是否已成功编译进 MySQL，启动新编译的服务器，运行 MySQL 客户端，执行 `SHOW ENGINES` 查询。您应能看到所有可用引擎的列表。Manticore 应该在其中，并且“Support”列应显示“YES”：\n\n<!-- request -->\n\nCODE_BLOCK_9\n\n<!-- response -->\n\nCODE_BLOCK_10\n\n<!-- request JSON -->\n\nCODE_BLOCK_11\n\n<!-- response JSON -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n## 使用 SphinxSE\n\n要使用 SphinxSE 搜索，您需要创建一个特殊的 ENGINE=SPHINX “搜索表”，然后对查询列在 `WHERE` 子句中使用全文查询的 `SELECT` 语句。\n\n下面是示例的创建语句和搜索查询：\n\nCODE_BLOCK_13\n\n在搜索表中，前三列*必须*是以下类型：第1列（文档 ID）为 `INTEGER UNSIGNED` 或 `BIGINT`，第2列（匹配权重）为 `INTEGER` 或 `BIGINT`，第3列（您的查询）为 `VARCHAR` 或 `TEXT`。此映射是固定的；您不能省略这三列中的任何一个，不能变换它们的位置，也不能更改它们的类型。此外，查询列必须被索引，而其他列应保持未索引。列名被忽略，因此您可以使用任意名称。\n\n其他列必须是 `INTEGER`、`TIMESTAMP`、`BIGINT`、`VARCHAR` 或 `FLOAT` 类型。它们将根据名称绑定到 Manticore 结果集中的属性，因此名称必须与 `sphinx.conf` 中指定的属性名称匹配。如果 Manticore 搜索结果中没有匹配的属性名称，则该列将显示 `NULL` 值。\n\n特殊的“虚拟”属性名称也可以绑定到 SphinxSE 列。为此请使用 `_sph_` 替代 `@`。例如，要获取 `@groupby`、`@count` 或 `@distinct` 虚拟属性的值，可使用 `_sph_groupby`、`_sph_count` 或 `_sph_distinct` 列名。\n\n`CONNECTION` 字符串参数用于指定 Manticore 主机、端口和表。如果在 `CREATE TABLE` 中未指定连接字符串，则假定表名为 `*`（即搜索所有表）且为 `localhost:9312`。连接字符串语法如下：\n\nCODE_BLOCK_14\n\n您可以稍后更改默认连接字符串：\n\nCODE_BLOCK_15\n\n您也可以在每次查询时覆盖这些参数。\n\n如示例所示，查询文本和搜索选项应放置在搜索查询列（即第3列）的 `WHERE` 子句中。选项以分号分隔，选项名与值之间用等号分开。可以指定任意数量的选项。可用选项包括：\n\n* query - 查询文本；\n\n* mode - 匹配模式。必须是 \"all\"、\"any\"、\"phrase\"、\"boolean\" 或 \"extended\" 之一。默认是 \"all\"；\n\n* sort - 匹配排序模式。必须是 \"relevance\"、\"attr_desc\"、\"attr_asc\"、\"time_segments\" 或 \"extended\" 之一。除 \"relevance\" 外，其他模式后需要加冒号和属性名（或 \"extended\" 的排序子句）：\n\nCODE_BLOCK_16\n\n* offset - 结果集偏移；默认是 0；\n\n* limit - 从结果集中检索的匹配数；默认是 20；\n\n* index - 要搜索的表名：\n\nCODE_BLOCK_17\n\n* minid, maxid - 匹配的最小和最大文档 ID；\n\n* weights - 以逗号分隔的权重列表，赋予 Manticore 全文字段：\n\nCODE_BLOCK_18\n\n* filter, !filter - 逗号分隔的属性名和要匹配的值集：\n\nCODE_BLOCK_19\n\n* range, !range - 逗号分隔的 (integer 或 bigint) Manticore 属性名，以及要匹配的最小值和最大值：\n\nCODE_BLOCK_20\n\n* floatrange, !floatrange - 逗号分隔的 (浮点数) Manticore 属性名，以及要匹配的最小值和最大值：\n\nCODE_BLOCK_21\n\n* maxmatches - 每查询最大匹配数，参见 [max_matches 搜索选项](../Searching/Options.md#max_matches)：\n\nCODE_BLOCK_22\n\n* cutoff - 最大允许匹配数，参见 [cutoff 搜索选项](../Searching/Options.md#cutoff)：\n\nCODE_BLOCK_23",
      "russian": "# SphinxSE\n\nSphinxSE — это движок хранения MySQL, который можно скомпилировать в серверы MySQL/MariaDB, используя их модульную архитектуру.\n\nНесмотря на своё название, SphinxSE *не* хранит никаких данных самостоятельно. Вместо этого он служит встроенным клиентом, который позволяет серверу MySQL взаимодействовать с `searchd`, выполнять поисковые запросы и получать результаты поиска. Вся индексация и поиск происходят вне MySQL.\n\nНекоторые распространённые применения SphinxSE включают:\n\n* Упрощение портирования приложений MySQL Full-Text Search (FTS) на Manticore;\n\n* Обеспечение использования Manticore с языками программирования, для которых ещё нет родных API;\n\n* Предоставление оптимизаций, когда требуется дополнительная обработка результатов Manticore на стороне MySQL (например, JOIN с таблицами оригинальных документов или дополнительная фильтрация на стороне MySQL).\n\n## Установка SphinxSE\n\nВам потребуется получить исходники MySQL, подготовить их и затем перекомпилировать бинарный файл MySQL. Исходники MySQL (mysql-5.x.yy.tar.gz) можно получить с сайта <http://dev.mysql.com>.\n\n### Компиляция MySQL 5.0.x с SphinxSE\n\n1.  скопируйте патч `sphinx.5.0.yy.diff` в каталог исходников MySQL и выполните\n\nCODE_BLOCK_0\n\nЕсли нет .diff файла именно для нужной версии сборки, попробуйте применить .diff с ближайшими номерами версий. Важно, чтобы патч применился без конфликтов.\n\n2.  в каталоге исходников MySQL выполните\n\nCODE_BLOCK_1\n\n3.  в каталоге исходников MySQL создайте каталог `sql/sphinx` и скопируйте туда все файлы из каталога `mysqlse` исходников Manticore. Например:\n\nCODE_BLOCK_2\n\n4.  сконфигурируйте MySQL и включите новый движок:\n\nCODE_BLOCK_3\n\n5.  соберите и установите MySQL:\n\nCODE_BLOCK_4\n\n### Компиляция MySQL 5.1.x с SphinxSE\n\n1. В каталоге исходников MySQL создайте каталог `storage/sphinx` и скопируйте все файлы из каталога `mysqlse` исходников Manticore в это новое место. Например:\n\nCODE_BLOCK_5\n\n2.  В каталоге исходников MySQL выполните:\n\nCODE_BLOCK_6\n\n3. Сконфигурируйте MySQL и включите движок Manticore:\n\nCODE_BLOCK_7\n\n4. Соберите и установите MySQL:\n\nCODE_BLOCK_8\n\n### Проверка установки SphinxSE\n\n<!-- example Example_1 -->\n\nЧтобы проверить, что SphinxSE успешно скомпилирован в MySQL, запустите вновь собранный сервер, выполните клиент MySQL и запрос `SHOW ENGINES`. Вы увидите список всех доступных движков. Должен присутствовать Manticore, а в колонке \"Support\" должно стоять \"YES\":\n\n<!-- request -->\n\nCODE_BLOCK_9\n\n<!-- response -->\n\nCODE_BLOCK_10\n\n<!-- request JSON -->\n\nCODE_BLOCK_11\n\n<!-- response JSON -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n## Использование SphinxSE\n\nЧтобы выполнить поиск с помощью SphinxSE, необходимо создать специальную таблицу с `ENGINE=SPHINX` — «поисковую таблицу», а затем использовать оператор `SELECT` с полнотекстовым запросом, помещённым в условие `WHERE` для колонки запроса.\n\nВот пример оператора создания и поискового запроса:\n\nCODE_BLOCK_13\n\nВ поисковой таблице первые три колонки *должны* иметь следующие типы: `INTEGER UNSIGNED` или `BIGINT` для первой колонки (ID документа), `INTEGER` или `BIGINT` для второй (вес совпадения), и `VARCHAR` или `TEXT` для третьей колонки (ваш запрос). Это фиксированное соответствие; вы не можете опускать ни одну из этих трёх обязательных колонок, менять их порядок или типы. Кроме того, колонка с запросом должна иметь индекс, а все остальные — не индексироваться. Имена колонок игнорируются, поэтому можно использовать любые имена.\n\nДополнительные колонки должны иметь типы `INTEGER`, `TIMESTAMP`, `BIGINT`, `VARCHAR` или `FLOAT`. Они будут связаны по имени с атрибутами, предоставленными в результирующем наборе Manticore, поэтому их имена должны совпадать с именами атрибутов, указанными в `sphinx.conf`. Если в результатах поиска Manticore нет соответствующего имени атрибута, колонка будет иметь значения `NULL`.\n\nТакже можно к колонкам SphinxSE привязывать специальные «виртуальные» имена атрибутов. Для этого используйте `_sph_` вместо `@`. Например, чтобы получить значения виртуальных атрибутов `@groupby`, `@count` или `@distinct`, используйте имена колонок `_sph_groupby`, `_sph_count` или `_sph_distinct` соответственно.\n\nПараметр строки `CONNECTION` используется для указания хоста Manticore, порта и таблицы. Если при `CREATE TABLE` строка соединения не указана, предполагается имя таблицы `*` (т.е. поиск по всем таблицам) и `localhost:9312`. Синтаксис строки соединения следующий:\n\nCODE_BLOCK_14\n\nПозже вы можете изменить строку соединения:\n\nCODE_BLOCK_15\n\nТакже можно переопределить эти параметры для каждого запроса.\n\nКак показано в примере, и текст запроса, и опции поиска должны быть помещены в условие `WHERE` для колонки поиска (т.е. для третьей колонки). Опции отделяются точкой с запятой, а имя опции и её значение разделяются знаком равенства. Можно указать любое количество опций. Доступные опции:\n\n* query — текст запроса;\n\n* mode — режим сопоставления. Должен быть один из \"all\", \"any\", \"phrase\", \"boolean\" или \"extended\". По умолчанию \"all\";\n\n* sort — режим сортировки совпадений. Должен быть один из \"relevance\", \"attr_desc\", \"attr_asc\", \"time_segments\" или \"extended\". Во всех режимах, кроме \"relevance\", после двоеточия требуется имя атрибута (или сортировочное выражение для \"extended\"):\n\nCODE_BLOCK_16\n\n* offset — смещение в результирующем наборе; по умолчанию 0;\n\n* limit — количество совпадений для получения из результирующего набора; по умолчанию 20;\n\n* index — имена таблиц для поиска:\n\nCODE_BLOCK_17\n\n* minid, maxid — минимальный и максимальный ID документов для сопоставления;\n\n* weights — список весов через запятую для присвоения полнотекстовым полям Manticore:\n\nCODE_BLOCK_18\n\n* filter, !filter — имя атрибута и набор значений для сопоставления, разделённые запятой:\n\nCODE_BLOCK_19\n\n* range, !range — имя атрибута Manticore (integer или bigint), минимальное и максимальное значения для сопоставления, через запятую:\n\nCODE_BLOCK_20\n\n* floatrange, !floatrange — имя атрибута Manticore с плавающей точкой, минимальное и максимальное значения для сопоставления, через запятую:\n\nCODE_BLOCK_21\n\n* maxmatches — максимальное число совпадений на запрос, как в опции поиска [max_matches](../Searching/Options.md#max_matches):\n\nCODE_BLOCK_22\n\n* cutoff — максимально допустимое число совпадений, как в опции поиска [cutoff](../Searching/Options.md#cutoff):\n\nCODE_BLOCK_23"
    },
    "is_code_or_comment": false
  }
}
