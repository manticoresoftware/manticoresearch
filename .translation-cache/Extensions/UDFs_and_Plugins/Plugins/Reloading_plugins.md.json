{
  "1d2a511f9043511725bebe0931551c4c9549d05b51a1cc0676d2890dd27bf35e": {
    "original": "# RELOADING PLUGINS\n\nCODE_BLOCK_0\n\nReloads all plugins (UDFs, rankers, etc.) from a given library. In a sense, the reload process is transactional, ensuring that:\n\n1. all plugins are successfully updated to their new versions;\n\n2. the update is atomic, meaning all plugins are replaced simultaneously. This atomicity ensures that queries using multiple functions from a reloaded library will never mix old and new versions.\n\nDuring the `RELOAD`, the set of plugins is guaranteed to be consistent; they will either be all old or all new.\n\nThe reload process is also seamless, as some version of a reloaded plugin will always be available for concurrent queries, without any temporary disruptions. This is an improvement over using a pair of `DROP` and `CREATE` statements for reloading. With those, there is a brief window between the `DROP` and the subsequent `CREATE` during which queries technically refer to an unknown plugin and will therefore fail.\n\nIf there's any failure, `RELOAD PLUGINS` does nothing, retains the old plugins, and reports an error.\n\nOn Windows, overwriting or deleting a DLL library currently in use can be problematic. However, you can still rename it, place a new version under the old name, and then `RELOAD` will work. After a successful reload, you'll also be able to delete the renamed old library.\n\nCODE_BLOCK_1\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 重新加载插件\n\nCODE_BLOCK_0\n\n从给定的库重新加载所有插件（UDF、排序器等）。从某种意义上说，重新加载过程是事务性的，确保：\n\n1. 所有插件都成功更新到它们的新版本；\n\n2. 更新是原子的，意味着所有插件同时被替换。此原子性确保使用重新加载库中多个函数的查询永远不会混用旧版本和新版本。\n\n在 `RELOAD` 期间，插件集合保证是一致的；它们要么全部是旧的，要么全部是新的。\n\n重新加载过程也是无缝的，因为某个版本的重新加载插件将始终可用于并发查询，没有任何临时中断。这比使用一对 `DROP` 和 `CREATE` 语句重新加载要好得多。使用后者，在 `DROP` 和随后的 `CREATE` 之间存在一个短暂的窗口期，在此期间查询技术上引用的是未知插件，因此会失败。\n\n如果发生任何失败，`RELOAD PLUGINS` 不执行任何操作，保留旧插件，并报告错误。\n\n在 Windows 上，覆盖或删除当前正在使用的 DLL 库可能会有问题。但是，您仍然可以重命名它，将新版本放在旧名称下，然后 `RELOAD` 将起作用。成功重新加载后，您还可以删除重命名的旧库。\n\nCODE_BLOCK_1\n\n<!-- proofread -->",
      "russian": "# ПЕРЕЗАГРУЗКА ПЛАГИНОВ\n\nCODE_BLOCK_0\n\nПерезагружает все плагины (UDF, ранкеры и т.д.) из указанной библиотеки. В некотором смысле процесс перезагрузки является транзакционным, обеспечивая:\n\n1. все плагины успешно обновлены до новых версий;\n\n2. обновление атомарно, то есть все плагины заменяются одновременно. Эта атомарность гарантирует, что запросы, использующие несколько функций из перезагруженной библиотеки, никогда не будут смешивать старые и новые версии.\n\nВо время `RELOAD` набор плагинов гарантированно будет консистентным; они будут либо все старыми, либо все новыми.\n\nПроцесс перезагрузки также бесшовный, так как какая-то версия перезагруженного плагина всегда будет доступна для одновременных запросов без временных сбоев. Это улучшение по сравнению с использованием пары операторов `DROP` и `CREATE` для перезагрузки. При таком подходе существует короткий промежуток между `DROP` и последующим `CREATE`, в течение которого запросы технически ссылаются на неизвестный плагин и, следовательно, завершаются с ошибкой.\n\nЕсли происходит какая-либо ошибка, `RELOAD PLUGINS` ничего не делает, сохраняет старые плагины и сообщает об ошибке.\n\nВ Windows перезапись или удаление DLL-библиотеки, которая в данный момент используется, может быть проблематичной. Однако вы всё ещё можете переименовать её, поместить новую версию под старым именем, и тогда `RELOAD` сработает. После успешной перезагрузки вы также сможете удалить переименованную старую библиотеку.\n\nCODE_BLOCK_1\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
