{
  "98eb31919ad50c740eac0202b287e5b7ae9067bb11bd13073c6e996939fcf666": {
    "original": "# UDF\n\nUDFs are stored in external dynamic libraries (.so files on UNIX and .dll on Windows systems). Library files must be placed in a trusted folder specified by the [plugin_dir](../../Server_settings/Common.md#plugin_dir) directive for security reasons: it's easier to secure a single folder than to allow anyone to install arbitrary code into `searchd`. You can dynamically load and unload UDFs into searchd using [CREATE FUNCTION](../../Extensions/UDFs_and_Plugins/UDF/Creating_a_function.md) and [DROP FUNCTION](../../Extensions/UDFs_and_Plugins/UDF/Deleting_a_function.md) SQL statements, respectively. Additionally, you can seamlessly reload UDFs (and other plugins) with the [RELOAD PLUGINS](../../Extensions/UDFs_and_Plugins/Plugins/Reloading_plugins.md) statement. Manticore keeps track of currently loaded functions; every time you create or drop a UDF, `searchd` updates its state in the [sphinxql_state](../../Server_settings/Searchd.md#sphinxql_state) file as a plain SQL script.\n\nUDFs are local. To use them on a cluster, you must place the same library on all nodes and run CREATE statements on each node as well. This process may change in future versions.\n\nOnce you successfully load a UDF, you can use it in your SELECT or other statements just like any built-in function:\n\nCODE_BLOCK_0\n\nMultiple UDFs (and other plugins) can reside in a single library. The library will only be loaded once and is automatically unloaded once all the UDFs and plugins within it are dropped.\n\nIn theory, you can write a UDF in any language, as long as its compiler can import standard C headers and emit standard dynamic libraries with properly exported functions. However, writing in C++ or plain C is the path of least resistance. We provide an example UDF library written in plain C that implements several functions (demonstrating various techniques) alongside our source code, found at [src/udfexample.c](https://github.com/manticoresoftware/manticore/blob/master/src/udfexample.c). This example includes the [src/sphinxudf.h](https://github.com/manticoresoftware/manticore/blob/master/src/sphinxudf.h) header file, which contains definitions of several UDF-related structures and types. For most UDFs and plugins, simply using `#include \"sphinxudf.h\"` as shown in the example should be sufficient. However, if you're writing a ranking function and need to access ranking signals (factors) data from within the UDF, you'll also need to compile and link with `src/sphinxudf.c` (available in our source code), as the *implementations* of functions that let you access signal data from within the UDF reside in that file.\n\nBoth the `sphinxudf.h` header and `sphinxudf.c` are standalone, so you can copy those files individually; they don't depend on any other parts of Manticore's source code.\n\nWithin your UDF, you **must** implement and export only a couple of functions. First, for UDF interface version control, you **must** define a function `int LIBRARYNAME_ver()`, where LIBRARYNAME is the name of your library file, and you must return `SPH_UDF_VERSION` (a value defined in `sphinxudf.h`) from it. Here's an example.\n\nCODE_BLOCK_1\n\nThis precaution protects you from accidentally loading a library with a mismatching UDF interface version into a newer or older `searchd`. Secondly, you **must** implement the actual function as well.\n\nCODE_BLOCK_2\n\nUDF function names in SQL are case-insensitive. However, the respective C function names are not; they need to be all *lower-case*, or the UDF will not load. More importantly, it is crucial that:\n\n1. the calling convention is C (aka __cdecl),\n\n2. the arguments list matches the plugin system expectations exactly, and\n\n3. the return type matches the one you specify in `CREATE FUNCTION`.\n\nUnfortunately, there is no (easy) way for us to check for these mistakes when loading the function, and they could crash the server and/or result in unexpected results. Last but not least, all the C functions you implement need to be thread-safe.\n\nThe first argument, a pointer to `SPH_UDF_INIT` structure, is essentially a pointer to our function state. It is optional. In the example just above, the function is stateless, as it simply returns 123 every time it gets called. So, we do not have to define an initialization function, and we can simply ignore that argument.\n\nThis argument serves one more purpose. Since a single query can be executed on multiple threads (see [pseudo-sharding](../../Server_settings/Searchd.md#pseudo_sharding)), the daemon tries to determine whether a UDF is stateful or stateless by checking this argument. If the argument is initialized, parallel execution will be disabled. So, if your UDF is stateful but you don't use this argument, it will be called from multiple threads, and your code needs to be aware of that.\n\nThe second argument, a pointer to `SPH_UDF_ARGS`, is the most important one. All the actual call arguments are passed to your UDF via this structure; it contains the call argument count, names, types, etc. So, whether your function gets called like `SELECT id, testfunc(1)` or like `SELECT id, testfunc('abc', 1000*id+gid, WEIGHT())` or any other way, it will receive the very same `SPH_UDF_ARGS` structure in all of these cases. However, the data passed in the `args` structure will be different. In the first example, `args->arg_count` will be set to 1, in the second example it will be set to 3, and the `args->arg_types` array will contain different type data, and so on.\n\nFinally, the third argument is an error flag. A UDF can raise it to indicate that some kind of internal error occurred, the UDF cannot continue, and the query should terminate early. You should **not** use this for argument type checks or for any other error reporting that is likely to happen during normal use. This flag is designed to report sudden critical runtime errors, such as running out of memory.\n\nIf we wanted to, say, allocate temporary storage for our function to use, or check upfront whether the arguments are of the supported types, then we would need to add two more functions, for UDF initialization and deinitialization, respectively.",
    "translations": {
      "chinese": "# UDF\n\nUDF 存储在外部动态库中（UNIX 系统为 .so 文件，Windows 系统为 .dll 文件）。出于安全考虑，库文件必须放置在由 [plugin_dir](../../Server_settings/Common.md#plugin_dir) 指令指定的受信任文件夹中：保护单个文件夹比允许任何人向 `searchd` 安装任意代码更容易。您可以使用 [CREATE FUNCTION](../../Extensions/UDFs_and_Plugins/UDF/Creating_a_function.md) 和 [DROP FUNCTION](../../Extensions/UDFs_and_Plugins/UDF/Deleting_a_function.md) SQL 语句动态加载和卸载 UDF 到 searchd 中。此外，您还可以使用 [RELOAD PLUGINS](../../Extensions/UDFs_and_Plugins/Plugins/Reloading_plugins.md) 语句无缝重新加载 UDF（及其他插件）。Manticore 会跟踪当前加载的函数；每次创建或删除 UDF 时，`searchd` 会将其状态更新到 [sphinxql_state](../../Server_settings/Searchd.md#sphinxql_state) 文件中，作为普通的 SQL 脚本。\n\nUDF 是本地的。要在集群中使用它们，必须将相同的库放置在所有节点上，并在每个节点上运行 CREATE 语句。此过程在未来版本中可能会有所变化。\n\n成功加载 UDF 后，您可以像使用任何内置函数一样在 SELECT 或其他语句中使用它：\n\nCODE_BLOCK_0\n\n多个 UDF（及其他插件）可以存在于单个库中。该库只会被加载一次，并且在其中所有 UDF 和插件被删除后会自动卸载。\n\n理论上，您可以用任何语言编写 UDF，只要其编译器能导入标准 C 头文件并生成带有正确导出函数的标准动态库。然而，使用 C++ 或纯 C 是最简单的路径。我们提供了一个用纯 C 编写的示例 UDF 库，实现了多个函数（演示了各种技术），与我们的源代码一起，位于 [src/udfexample.c](https://github.com/manticoresoftware/manticore/blob/master/src/udfexample.c)。该示例包含了 [src/sphinxudf.h](https://github.com/manticoresoftware/manticore/blob/master/src/sphinxudf.h) 头文件，其中包含了多个与 UDF 相关的结构和类型定义。对于大多数 UDF 和插件，只需像示例中那样使用 `#include \"sphinxudf.h\"` 即可。然而，如果您正在编写排名函数并需要从 UDF 内部访问排名信号（因子）数据，还需要编译并链接 `src/sphinxudf.c`（可在我们的源代码中找到），因为允许您从 UDF 内部访问信号数据的函数实现位于该文件中。\n\n`sphinxudf.h` 头文件和 `sphinxudf.c` 是独立的，因此您可以单独复制这些文件；它们不依赖于 Manticore 源代码的其他部分。\n\n在您的 UDF 中，您**必须**实现并导出仅几个函数。首先，为了 UDF 接口版本控制，您**必须**定义一个函数 `int LIBRARYNAME_ver()`，其中 LIBRARYNAME 是您的库文件名，且必须从该函数返回 `SPH_UDF_VERSION`（在 `sphinxudf.h` 中定义的值）。示例如下。\n\nCODE_BLOCK_1\n\n此预防措施可防止您意外将接口版本不匹配的库加载到较新或较旧的 `searchd` 中。其次，您**必须**实现实际的函数。\n\nCODE_BLOCK_2\n\nSQL 中的 UDF 函数名不区分大小写。但相应的 C 函数名区分大小写；它们必须全部为*小写*，否则 UDF 无法加载。更重要的是，必须确保：\n\n1. 调用约定为 C（即 __cdecl），\n\n2. 参数列表完全符合插件系统的预期，\n\n3. 返回类型与您在 `CREATE FUNCTION` 中指定的类型匹配。\n\n不幸的是，我们无法（轻易地）在加载函数时检查这些错误，这些错误可能导致服务器崩溃和/或产生意外结果。最后，您实现的所有 C 函数都必须是线程安全的。\n\n第一个参数，是指向 `SPH_UDF_INIT` 结构的指针，本质上是指向函数状态的指针。它是可选的。在上面的示例中，该函数是无状态的，因为它每次调用都简单返回 123。因此，我们不必定义初始化函数，可以忽略该参数。\n\n该参数还有一个作用。由于单个查询可以在多个线程上执行（参见 [pseudo-sharding](../../Server_settings/Searchd.md#pseudo_sharding)），守护进程会通过检查该参数来判断 UDF 是有状态还是无状态。如果该参数被初始化，则禁用并行执行。因此，如果您的 UDF 是有状态的但不使用该参数，它将被多个线程调用，您的代码需要对此有所准备。\n\n第二个参数，是指向 `SPH_UDF_ARGS` 的指针，是最重要的参数。所有实际调用参数都通过该结构传递给您的 UDF；它包含调用参数的数量、名称、类型等。因此，无论您的函数是像 `SELECT id, testfunc(1)` 这样调用，还是像 `SELECT id, testfunc('abc', 1000*id+gid, WEIGHT())` 或其他方式调用，它都会收到相同的 `SPH_UDF_ARGS` 结构。但传入 `args` 结构的数据会不同。在第一个示例中，`args->arg_count` 会被设置为 1，在第二个示例中会被设置为 3，`args->arg_types` 数组会包含不同的类型数据，依此类推。\n\n最后，第三个参数是错误标志。UDF 可以设置该标志以指示发生了某种内部错误，UDF 无法继续，查询应提前终止。您**不应**将其用于参数类型检查或其他可能在正常使用中发生的错误报告。该标志设计用于报告突发的严重运行时错误，例如内存耗尽。\n\n如果我们想为函数分配临时存储，或预先检查参数是否为支持的类型，则需要分别添加两个函数，用于 UDF 的初始化和反初始化。",
      "russian": "# UDF\n\nUDF хранятся во внешних динамических библиотеках (.so файлы в UNIX и .dll в Windows системах). Файлы библиотек должны быть размещены в доверенной папке, указанной директивой [plugin_dir](../../Server_settings/Common.md#plugin_dir) по соображениям безопасности: проще защитить одну папку, чем разрешать кому угодно устанавливать произвольный код в `searchd`. Вы можете динамически загружать и выгружать UDF в searchd с помощью SQL операторов [CREATE FUNCTION](../../Extensions/UDFs_and_Plugins/UDF/Creating_a_function.md) и [DROP FUNCTION](../../Extensions/UDFs_and_Plugins/UDF/Deleting_a_function.md) соответственно. Кроме того, вы можете бесшовно перезагружать UDF (и другие плагины) с помощью оператора [RELOAD PLUGINS](../../Extensions/UDFs_and_Plugins/Plugins/Reloading_plugins.md). Manticore отслеживает текущие загруженные функции; каждый раз при создании или удалении UDF `searchd` обновляет своё состояние в файле [sphinxql_state](../../Server_settings/Searchd.md#sphinxql_state) в виде простого SQL скрипта.\n\nUDF являются локальными. Чтобы использовать их в кластере, вы должны разместить одну и ту же библиотеку на всех узлах и выполнить CREATE операторы на каждом узле. Этот процесс может измениться в будущих версиях.\n\nПосле успешной загрузки UDF вы можете использовать её в ваших SELECT или других операторах так же, как любую встроенную функцию:\n\nCODE_BLOCK_0\n\nНесколько UDF (и других плагинов) могут находиться в одной библиотеке. Библиотека будет загружена только один раз и автоматически выгружена, когда все UDF и плагины в ней будут удалены.\n\nТеоретически, вы можете написать UDF на любом языке, если его компилятор может импортировать стандартные заголовки C и создавать стандартные динамические библиотеки с правильно экспортированными функциями. Однако написание на C++ или обычном C — это путь наименьшего сопротивления. Мы предоставляем пример библиотеки UDF, написанной на обычном C, которая реализует несколько функций (демонстрируя различные техники) вместе с нашим исходным кодом, который можно найти в [src/udfexample.c](https://github.com/manticoresoftware/manticore/blob/master/src/udfexample.c). Этот пример включает заголовочный файл [src/sphinxudf.h](https://github.com/manticoresoftware/manticore/blob/master/src/sphinxudf.h), который содержит определения нескольких структур и типов, связанных с UDF. Для большинства UDF и плагинов достаточно просто использовать `#include \"sphinxudf.h\"`, как показано в примере. Однако, если вы пишете функцию ранжирования и вам нужно получить доступ к данным сигналов ранжирования (факторов) изнутри UDF, вам также нужно скомпилировать и связать с `src/sphinxudf.c` (доступным в нашем исходном коде), так как *реализации* функций, позволяющих получить доступ к данным сигналов изнутри UDF, находятся в этом файле.\n\nИ `sphinxudf.h`, и `sphinxudf.c` являются автономными, поэтому вы можете копировать эти файлы по отдельности; они не зависят от других частей исходного кода Manticore.\n\nВнутри вашей UDF вы **должны** реализовать и экспортировать всего пару функций. Во-первых, для контроля версии интерфейса UDF вы **должны** определить функцию `int LIBRARYNAME_ver()`, где LIBRARYNAME — это имя вашего файла библиотеки, и вы должны возвращать из неё `SPH_UDF_VERSION` (значение, определённое в `sphinxudf.h`). Вот пример.\n\nCODE_BLOCK_1\n\nЭта мера предосторожности защищает вас от случайной загрузки библиотеки с несовпадающей версией интерфейса UDF в более новую или старую версию `searchd`. Во-вторых, вы **должны** реализовать и саму функцию.\n\nCODE_BLOCK_2\n\nИмена функций UDF в SQL нечувствительны к регистру. Однако соответствующие имена функций на C — чувствительны; они должны быть полностью *в нижнем регистре*, иначе UDF не загрузится. Более того, крайне важно, чтобы:\n\n1. соглашение о вызове было C (также известное как __cdecl),\n\n2. список аргументов точно соответствовал ожиданиям системы плагинов, и\n\n3. возвращаемый тип совпадал с тем, который вы указали в `CREATE FUNCTION`.\n\nК сожалению, у нас нет (простого) способа проверить эти ошибки при загрузке функции, и они могут привести к сбою сервера и/или неожиданным результатам. И наконец, все реализованные вами C функции должны быть потокобезопасными.\n\nПервый аргумент, указатель на структуру `SPH_UDF_INIT`, по сути является указателем на состояние нашей функции. Он необязателен. В примере выше функция не имеет состояния, так как просто возвращает 123 при каждом вызове. Поэтому нам не нужно определять функцию инициализации, и мы можем просто игнорировать этот аргумент.\n\nЭтот аргумент служит ещё одной цели. Поскольку один запрос может выполняться на нескольких потоках (см. [pseudo-sharding](../../Server_settings/Searchd.md#pseudo_sharding)), демон пытается определить, является ли UDF с состоянием или без, проверяя этот аргумент. Если аргумент инициализирован, параллельное выполнение будет отключено. Таким образом, если ваша UDF имеет состояние, но вы не используете этот аргумент, она будет вызываться из нескольких потоков, и ваш код должен это учитывать.\n\nВторой аргумент, указатель на `SPH_UDF_ARGS`, является самым важным. Все фактические аргументы вызова передаются вашей UDF через эту структуру; она содержит количество аргументов вызова, имена, типы и т.д. Так что, независимо от того, вызывается ли ваша функция как `SELECT id, testfunc(1)` или как `SELECT id, testfunc('abc', 1000*id+gid, WEIGHT())` или любым другим способом, она получит ту же структуру `SPH_UDF_ARGS` во всех этих случаях. Однако данные, передаваемые в структуре `args`, будут разными. В первом примере `args->arg_count` будет равен 1, во втором — 3, и массив `args->arg_types` будет содержать разные типы данных и так далее.\n\nНаконец, третий аргумент — это флаг ошибки. UDF может установить его, чтобы указать, что произошла внутренняя ошибка, UDF не может продолжать работу, и запрос должен быть завершён досрочно. Вы **не должны** использовать этот флаг для проверки типов аргументов или для любой другой обработки ошибок, которые могут возникать в нормальном использовании. Этот флаг предназначен для сообщения о внезапных критических ошибках во время выполнения, таких как нехватка памяти.\n\nЕсли бы мы хотели, например, выделить временное хранилище для использования нашей функцией или заранее проверить, что аргументы имеют поддерживаемые типы, нам нужно было бы добавить ещё две функции — для инициализации и деинициализации UDF соответственно."
    },
    "is_code_or_comment": false
  },
  "7f28497a02c49311c6f6ee80dbf9e94f1c42d9b55d38aa5a999694e07c222b51": {
    "original": "CODE_BLOCK_3\n\nNote how `testfunc_init()` also receives the call arguments structure. By the time it is called, it does not receive any actual values, so the `args->arg_values` will be NULL. But the argument names and types are known and will be passed. You can check them in the initialization function and return an error if they are of an unsupported type.\n\n## SPH_UDF_ARGS types\n\nUDFs can receive arguments of pretty much any valid internal Manticore type. Refer to the `sphinx_udf_argtype` enumeration in `sphinxudf.h` for a full list. Most of the types map straightforwardly to the respective C types.\n\nThe most notable type is the `SPH_UDF_TYPE_FACTORS` argument type. You get that type by calling your UDF with a [PACKEDFACTOR()](../../Functions/Searching_and_ranking_functions#PACKEDFACTORS()) argument. Its data is a binary blob in a certain internal format, and to extract individual ranking signals from that blob, you need to use either of the two `sphinx_factors_XXX()` or `sphinx_get_YYY_factor()` families of functions.\n\n### sphinx_factors_XXX() functions\n\nThis family consists of 3 functions.\n\n* `sphinx_factors_init()` initializes the unpacked `SPH_UDF_FACTORS` structure\n\n* `sphinx_factors_unpack()` unpacks a binary blob into `SPH_UDF_FACTORS` structure\n\n* `sphinx_factors_deinit()` cleans up and deallocates the `SPH_UDF_FACTORS`.\n\nFirst, you need to call `init()` and `unpack()`, then you can use the `SPH_UDF_FACTORS` fields, and finally, you need to clean up with `deinit()`.\n\nThis approach is simple but may result in a bunch of memory allocations for each processed document, which could be slow.\n\n### sphinx_get_YYY_factor() functions\n\nThe other interface, consisting of a bunch of `sphinx_get_YYY_factor()` functions, is a bit more verbose to use but accesses the blob data directly and guarantees no allocations. For top-notch ranking UDF performance, you'll want to use this approach.\n\n## Return types of UDF\n\nAs for the return types, UDFs can currently return a single INTEGER, BIGINT, FLOAT, or STRING value. The C function return type should be `sphinx_int64_t`, `sphinx_int64_t`, `double`, or `char*` respectively. In the last case, you **must** use the `args->fn_malloc` function to allocate space for returned string values. Internally in your UDF, you can use whatever you want, so the `testfunc_init()` example above is correct code even though it uses malloc() directly: you manage that pointer yourself, it gets freed up using a matching free() call, and all is well. However, the returned strings values are managed by Manticore, and we have our own allocator, so for the return values specifically, you need to use it too.\n\nDepending on how your UDFs are used in the query, the main function call (`testfunc()` in our example) might be called in a rather different volume and order. Specifically,\n\n* UDFs referenced in WHERE, ORDER BY, or GROUP BY clauses must and will be evaluated for every matched document. They will be called in the natural matching order.\n\n* without subselects, UDFs that can be evaluated at the very last stage over the final result set will be evaluated that way, but before applying the `LIMIT` clause. They will be called in the result set order.\n\n* with subselects, such UDFs will also be evaluated after applying the inner `LIMIT` clause.\n\nThe calling sequence of the other functions is fixed, though. Namely,\n\n* `testfunc_init()` is called once when initializing the query. It can return a non-zero code to indicate a failure; in that case, the query will be terminated, and the error message from the `error_message` buffer will be returned.\n\n* `testfunc()` is called for every eligible row (see above), whenever Manticore needs to compute the UDF value. It can also indicate an (internal) failure error by writing a non-zero byte value to `error_flag`. In that case, it is guaranteed that it will not be called for subsequent rows, and a default return value of 0 will be substituted. Manticore might or might not choose to terminate such queries early; neither behavior is currently guaranteed.\n\n* `testfunc_deinit()` is called once when the query processing (in a given table shard) ends.\n\n<!-- proofread -->",
    "translations": {
      "chinese": "CODE_BLOCK_3\n\n注意 `testfunc_init()` 也接收调用参数结构。在它被调用时，不会接收到任何实际值，因此 `args->arg_values` 将为 NULL。但参数名称和类型是已知的，并且会被传递。你可以在初始化函数中检查它们，如果它们是未支持的类型，则返回错误。\n\n## SPH_UDF_ARGS 类型\n\nUDF 可以接收几乎任何有效的内部 Manticore 类型的参数。完整列表请参阅 `sphinxudf.h` 中的 `sphinx_udf_argtype` 枚举。大多数类型都直接映射到相应的 C 类型。\n\n最显著的类型是 `SPH_UDF_TYPE_FACTORS` 参数类型。你可以通过调用带有 [PACKEDFACTOR()](../../Functions/Searching_and_ranking_functions#PACKEDFACTORS()) 参数的 UDF 来获得该类型。它的数据是某种内部格式的二进制块，要从该块中提取单个排名信号，需要使用 `sphinx_factors_XXX()` 或 `sphinx_get_YYY_factor()` 函数族中的任意一个。\n\n### sphinx_factors_XXX() 函数\n\n该函数族包含 3 个函数。\n\n* `sphinx_factors_init()` 初始化解包后的 `SPH_UDF_FACTORS` 结构\n\n* `sphinx_factors_unpack()` 将二进制块解包到 `SPH_UDF_FACTORS` 结构中\n\n* `sphinx_factors_deinit()` 清理并释放 `SPH_UDF_FACTORS`。\n\n首先，你需要调用 `init()` 和 `unpack()`，然后可以使用 `SPH_UDF_FACTORS` 字段，最后需要用 `deinit()` 进行清理。\n\n这种方法简单，但可能导致每个处理的文档产生大量内存分配，可能会较慢。\n\n### sphinx_get_YYY_factor() 函数\n\n另一种接口由一堆 `sphinx_get_YYY_factor()` 函数组成，使用起来稍显冗长，但直接访问二进制块数据，保证不进行分配。为了获得顶级的排名 UDF 性能，你会想使用这种方法。\n\n## UDF 的返回类型\n\n至于返回类型，UDF 目前可以返回单个 INTEGER、BIGINT、FLOAT 或 STRING 值。C 函数返回类型应分别为 `sphinx_int64_t`、`sphinx_int64_t`、`double` 或 `char*`。在最后一种情况下，你**必须**使用 `args->fn_malloc` 函数为返回的字符串值分配空间。在 UDF 内部，你可以使用任何你想要的方式，因此上面 `testfunc_init()` 示例中直接使用 malloc() 是正确的代码：你自己管理该指针，它通过匹配的 free() 调用被释放，一切正常。然而，返回的字符串值由 Manticore 管理，我们有自己的分配器，因此对于返回值，特别需要使用它。\n\n根据你的 UDF 在查询中的使用方式，主函数调用（示例中的 `testfunc()`）可能会以相当不同的数量和顺序被调用。具体来说，\n\n* 在 WHERE、ORDER BY 或 GROUP BY 子句中引用的 UDF 必须且将会对每个匹配的文档进行评估。它们将按照自然匹配顺序被调用。\n\n* 如果没有子查询，可以在最终结果集的最后阶段评估的 UDF 将以这种方式评估，但在应用 `LIMIT` 子句之前。它们将按照结果集顺序被调用。\n\n* 有子查询时，这些 UDF 也将在应用内部 `LIMIT` 子句后进行评估。\n\n其他函数的调用顺序是固定的。即，\n\n* `testfunc_init()` 在初始化查询时调用一次。它可以返回非零代码以指示失败；在这种情况下，查询将被终止，并返回 `error_message` 缓冲区中的错误信息。\n\n* `testfunc()` 在每个符合条件的行（见上文）上调用，每当 Manticore 需要计算 UDF 值时。它也可以通过向 `error_flag` 写入非零字节值来指示（内部）失败错误。在这种情况下，保证不会对后续行调用它，并且会替换为默认返回值 0。Manticore 可能会也可能不会选择提前终止此类查询；目前两种行为都不保证。\n\n* `testfunc_deinit()` 在查询处理（在给定表分片中）结束时调用一次。\n\n<!-- proofread -->",
      "russian": "CODE_BLOCK_3\n\nОбратите внимание, что `testfunc_init()` также получает структуру аргументов вызова. К моменту его вызова он не получает никаких фактических значений, поэтому `args->arg_values` будет NULL. Но имена и типы аргументов известны и будут переданы. Вы можете проверить их в функции инициализации и вернуть ошибку, если они имеют неподдерживаемый тип.\n\n## Типы SPH_UDF_ARGS\n\nUDF могут принимать аргументы практически любого допустимого внутреннего типа Manticore. Полный список смотрите в перечислении `sphinx_udf_argtype` в `sphinxudf.h`. Большинство типов напрямую соответствуют соответствующим типам C.\n\nСамый примечательный тип — это тип аргумента `SPH_UDF_TYPE_FACTORS`. Вы получаете этот тип, вызывая ваш UDF с аргументом [PACKEDFACTOR()](../../Functions/Searching_and_ranking_functions#PACKEDFACTORS()). Его данные — это бинарный блок в определённом внутреннем формате, и чтобы извлечь отдельные сигналы ранжирования из этого блока, нужно использовать либо одну из двух семейств функций `sphinx_factors_XXX()` или `sphinx_get_YYY_factor()`.\n\n### Функции sphinx_factors_XXX()\n\nЭто семейство состоит из 3 функций.\n\n* `sphinx_factors_init()` инициализирует распакованную структуру `SPH_UDF_FACTORS`\n\n* `sphinx_factors_unpack()` распаковывает бинарный блок в структуру `SPH_UDF_FACTORS`\n\n* `sphinx_factors_deinit()` очищает и освобождает `SPH_UDF_FACTORS`.\n\nСначала нужно вызвать `init()` и `unpack()`, затем можно использовать поля `SPH_UDF_FACTORS`, и в конце нужно очистить с помощью `deinit()`.\n\nЭтот подход простой, но может привести к множеству выделений памяти для каждого обрабатываемого документа, что может быть медленно.\n\n### Функции sphinx_get_YYY_factor()\n\nДругой интерфейс, состоящий из множества функций `sphinx_get_YYY_factor()`, немного более многословен в использовании, но обращается к данным блока напрямую и гарантирует отсутствие выделений памяти. Для максимальной производительности ранжирования UDF рекомендуется использовать этот подход.\n\n## Возвращаемые типы UDF\n\nЧто касается возвращаемых типов, UDF в настоящее время могут возвращать одно значение INTEGER, BIGINT, FLOAT или STRING. Тип возвращаемого значения C-функции должен быть соответственно `sphinx_int64_t`, `sphinx_int64_t`, `double` или `char*`. В последнем случае вы **должны** использовать функцию `args->fn_malloc` для выделения памяти под возвращаемые строковые значения. Внутри вашего UDF вы можете использовать что угодно, поэтому пример `testfunc_init()` выше является корректным кодом, даже если он использует malloc() напрямую: вы сами управляете этим указателем, он освобождается с помощью соответствующего вызова free(), и всё в порядке. Однако возвращаемые строковые значения управляются Manticore, и у нас есть собственный аллокатор, поэтому для возвращаемых значений нужно использовать именно его.\n\nВ зависимости от того, как ваши UDF используются в запросе, основной вызов функции (`testfunc()` в нашем примере) может вызываться в довольно разном объёме и порядке. В частности,\n\n* UDF, используемые в WHERE, ORDER BY или GROUP BY, должны и будут вычисляться для каждого совпадающего документа. Они будут вызываться в естественном порядке совпадений.\n\n* без подзапросов UDF, которые могут быть вычислены на самом последнем этапе по итоговому набору результатов, будут вычислены именно так, но до применения условия `LIMIT`. Они будут вызываться в порядке набора результатов.\n\n* с подзапросами такие UDF также будут вычислены после применения внутреннего условия `LIMIT`.\n\nПоследовательность вызовов остальных функций фиксирована. А именно,\n\n* `testfunc_init()` вызывается один раз при инициализации запроса. Она может вернуть ненулевой код для указания ошибки; в этом случае запрос будет прерван, и будет возвращено сообщение об ошибке из буфера `error_message`.\n\n* `testfunc()` вызывается для каждой подходящей строки (см. выше), когда Manticore нужно вычислить значение UDF. Она также может указать (внутреннюю) ошибку, записав ненулевое значение байта в `error_flag`. В этом случае гарантируется, что она не будет вызвана для последующих строк, и вместо этого будет подставлено значение по умолчанию 0. Manticore может как завершить такие запросы досрочно, так и не сделать этого; в настоящее время ни одно из поведений не гарантируется.\n\n* `testfunc_deinit()` вызывается один раз при завершении обработки запроса (в данном шарде таблицы).\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
