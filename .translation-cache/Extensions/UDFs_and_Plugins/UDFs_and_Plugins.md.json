{
  "9a719c2ba7fb5903cfecc52ae52392f654e3b927861be32d63072c035c9764a1": {
    "original": "# UDFs and Plugins\n\nManticore can be extended with user-defined functions, or UDFs for short, like this:\n\nCODE_BLOCK_0\n\nYou can dynamically load and unload UDFs into `searchd` without having to restart the server, and use them in expressions when searching, ranking, etc. A quick summary of the UDF features is as follows:\n\n* UDFs can take integer (both 32-bit and 64-bit), float, string, MVA, or `PACKEDFACTORS()` arguments.\n\n* UDFs can return integer, float, or string values.\n\n* UDFs can check the argument number, types, and names during the query setup phase, and raise errors.\n\nWe do not yet support aggregation functions. In other words, your UDFs will be called for just a single document at a time and are expected to return some value for that document. Writing a function that can compute an aggregate value like AVG() over the entire group of documents that share the same GROUP BY key is not yet possible. However, you can use UDFs within the built-in aggregate functions: that is, even though MYCUSTOMAVG() is not supported yet, AVG(MYCUSTOMFUNC()) should work just fine!\n\nUDFs offer a wide range of applications, such as:\n\n* incorporating custom mathematical or string functions;\n\n* accessing databases or files from within Manticore;\n\n* creating complex ranking functions.\n\n## Plugins\n\nPlugins offer additional opportunities to expand search functionality. They can currently be used to compute custom rankings and tokenize documents and queries.\n\nHere's the complete list of plugin types:\n\n* UDF plugins (essentially UDFs, but since they're plugged in, they're also referred to as 'UDF plugins')\n\n* ranker plugins\n\n* indexing-time token filter plugins\n\n* query-time token filter plugins\n\nThis section covers the general process of writing and managing plugins; specifics related to creating different types of plugins are discussed in their respective subsections.\n\nSo, how do you write and use a plugin? Here's a quick four-step guide:\n\n* create a dynamic library (either .so or .dll), most likely using C or C++;\n\n* load the plugin into searchd with [CREATE PLUGIN](../../Extensions/UDFs_and_Plugins/Plugins/Creating_a_plugin.md);\n\n* use the plugin with plugin-specific calls (usually through specific OPTIONS).\n\n* unload or reload a plugin with [DROP PLUGIN](../../Extensions/UDFs_and_Plugins/Plugins/Deleting_a_plugin.md) and [RELOAD PLUGINS](../../Extensions/UDFs_and_Plugins/Plugins/Reloading_plugins.md), respectively.\n\nNote that while UDFs are first-class plugins, they are installed using a separate [CREATE FUNCTION](../../Extensions/UDFs_and_Plugins/UDF/Creating_a_function.md) statement. This allows for a neat specification of the return type, without sacrificing backward compatibility or changing the syntax.\n\nDynamic plugins are supported in threads and thread_pool workers. Multiple plugins (and/or UDFs) can be contained in a single library file. You may choose to either group all project-specific plugins in one large library or create a separate library for each UDF and plugin; it's up to you.\n\nAs with UDFs, you should include the `src/sphinxudf.h` header file. At the very least, you'll need the `SPH_UDF_VERSION` constant to implement an appropriate version function. Depending on the specific plugin type, you may or may not need to link your plugin with `src/sphinxudf.c`. However, all functions implemented in `sphinxudf.c` are related to unpacking the `PACKEDFACTORS()` blob, and no plugin types have access to that data. So currently, linking with just the header should suffice. (In fact, if you copy over the UDF version number, you won't even need the header file for some plugin types.)\n\nFormally, plugins are simply sets of C functions that adhere to a specific naming pattern. You're typically required to define one key function for the primary task, but you can also define additional functions. For instance, to implement a ranker called \"myrank\", you must define a `myrank_finalize()` function that returns the rank value. However, you can also define `myrank_init()`, `myrank_update()`, and `myrank_deinit()` functions. Specific sets of well-known suffixes and call arguments differ based on the plugin type, but _init() and _deinit() are generic, and every plugin has them. Hint: for a quick reference on known suffixes and their argument types, refer to `sphinxplugin.h`, where the call prototypes are defined at the beginning of the file.\n\nEven though the public interface is defined in pure C, our plugins essentially follow an *object-oriented model*. Indeed, every `_init()` function receives a `void ** userdata` out-parameter, and the pointer value stored at `(*userdata)` is then passed as the first argument to all other plugin functions. So you can think of a plugin as a *class* that gets instantiated every time an object of that class is needed to handle a request: the `userdata` pointer serves as the `this` pointer; the functions act as methods, and the `_init()` and `_deinit()` functions work as constructor and destructor, respectively.\n\nThis minor OOP-in-C complication arises because plugins run in a multi-threaded environment, and some need to maintain state. You can't store that state in a global variable in your plugin, so we pass around a userdata parameter, which naturally leads to the OOP model. If your plugin is simple and stateless, the interface allows you to omit `_init()`, `_deinit()`, and any other functions.\n\nTo summarize, here's the simplest complete ranker plugin in just three lines of C code:\n\nCODE_BLOCK_1\n\nHere's how to use the simple ranker plugin:\n\nCODE_BLOCK_2\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# UDFs and Plugins\n\nManticore 可以通过用户自定义函数（简称 UDFs）进行扩展，方法如下：\n\nCODE_BLOCK_0\n\n您可以动态加载和卸载 UDFs 到 `searchd`，无需重启服务器，并在搜索、排序等表达式中使用它们。UDF 功能的简要总结如下：\n\n* UDF 可以接受整数（32 位和 64 位）、浮点数、字符串、MVA 或 `PACKEDFACTORS()` 参数。\n\n* UDF 可以返回整数、浮点数或字符串值。\n\n* UDF 可以在查询设置阶段检查参数数量、类型和名称，并抛出错误。\n\n我们尚不支持聚合函数。换句话说，您的 UDF 将一次仅针对单个文档调用，并期望返回该文档的某个值。编写能够计算整个共享相同 GROUP BY 键的文档组的聚合值（如 AVG()）的函数目前还不可行。不过，您可以在内置聚合函数中使用 UDF：即使 MYCUSTOMAVG() 目前不支持，AVG(MYCUSTOMFUNC()) 应该可以正常工作！\n\nUDF 提供了广泛的应用场景，例如：\n\n* 集成自定义数学或字符串函数；\n\n* 从 Manticore 内部访问数据库或文件；\n\n* 创建复杂的排序函数。\n\n## Plugins\n\n插件提供了扩展搜索功能的额外机会。目前它们可用于计算自定义排序和对文档及查询进行分词。\n\n以下是插件类型的完整列表：\n\n* UDF 插件（本质上是 UDF，但由于它们是插件，也称为“UDF 插件”）\n\n* 排序器插件\n\n* 索引时的分词过滤器插件\n\n* 查询时的分词过滤器插件\n\n本节涵盖编写和管理插件的一般流程；有关创建不同类型插件的具体内容，请参见各自的小节。\n\n那么，如何编写和使用插件？以下是快速的四步指南：\n\n* 创建动态库（.so 或 .dll），通常使用 C 或 C++；\n\n* 使用 [CREATE PLUGIN](../../Extensions/UDFs_and_Plugins/Plugins/Creating_a_plugin.md) 将插件加载到 searchd；\n\n* 通过插件特定调用（通常通过特定 OPTIONS）使用插件；\n\n* 分别使用 [DROP PLUGIN](../../Extensions/UDFs_and_Plugins/Plugins/Deleting_a_plugin.md) 和 [RELOAD PLUGINS](../../Extensions/UDFs_and_Plugins/Plugins/Reloading_plugins.md) 卸载或重新加载插件。\n\n请注意，虽然 UDF 是一等插件，但它们是通过单独的 [CREATE FUNCTION](../../Extensions/UDFs_and_Plugins/UDF/Creating_a_function.md) 语句安装的。这允许对返回类型进行整洁的指定，同时不牺牲向后兼容性或更改语法。\n\n动态插件支持线程和线程池工作者。多个插件（和/或 UDF）可以包含在单个库文件中。您可以选择将所有项目特定插件放入一个大型库，或为每个 UDF 和插件创建单独的库；这取决于您。\n\n与 UDF 一样，您应包含 `src/sphinxudf.h` 头文件。至少，您需要 `SPH_UDF_VERSION` 常量来实现适当的版本函数。根据具体插件类型，您可能需要或不需要将插件与 `src/sphinxudf.c` 链接。然而，`sphinxudf.c` 中实现的所有函数都与解包 `PACKEDFACTORS()` blob 相关，而没有插件类型可以访问该数据。因此，目前仅链接头文件就足够了。（实际上，如果您复制 UDF 版本号，对于某些插件类型甚至不需要头文件。）\n\n形式上，插件只是遵循特定命名模式的一组 C 函数。通常需要定义一个关键函数来完成主要任务，但也可以定义额外函数。例如，要实现名为 \"myrank\" 的排序器，必须定义返回排序值的 `myrank_finalize()` 函数。但您也可以定义 `myrank_init()`、`myrank_update()` 和 `myrank_deinit()` 函数。具体的已知后缀和调用参数集根据插件类型不同而异，但 _init() 和 _deinit() 是通用的，每个插件都有它们。提示：有关已知后缀及其参数类型的快速参考，请参阅 `sphinxplugin.h`，调用原型定义在文件开头。\n\n尽管公共接口是用纯 C 定义的，我们的插件本质上遵循*面向对象模型*。确实，每个 `_init()` 函数接收一个 `void ** userdata` 输出参数，存储在 `(*userdata)` 的指针值随后作为第一个参数传递给所有其他插件函数。因此，您可以将插件视为一个*类*，每当需要处理请求时实例化该类的一个对象：`userdata` 指针充当 `this` 指针；函数作为方法；`_init()` 和 `_deinit()` 分别作为构造函数和析构函数。\n\n这种在 C 中的轻量级面向对象复杂性产生的原因是插件运行在多线程环境中，有些需要维护状态。您不能将状态存储在插件的全局变量中，因此我们传递 userdata 参数，这自然导致了面向对象模型。如果您的插件简单且无状态，接口允许您省略 `_init()`、`_deinit()` 和其他函数。\n\n总结一下，下面是仅用三行 C 代码实现的最简单完整排序器插件：\n\nCODE_BLOCK_1\n\n以下是如何使用该简单排序器插件：\n\nCODE_BLOCK_2\n\n<!-- proofread -->",
      "russian": "# UDFs and Plugins\n\nManticore можно расширять пользовательскими функциями, или UDF (User-Defined Functions), вот так:\n\nCODE_BLOCK_0\n\nВы можете динамически загружать и выгружать UDF в `searchd` без необходимости перезапуска сервера и использовать их в выражениях при поиске, ранжировании и т.д. Краткое резюме возможностей UDF:\n\n* UDF могут принимать аргументы типа integer (как 32-битные, так и 64-битные), float, string, MVA или `PACKEDFACTORS()`.\n\n* UDF могут возвращать значения типа integer, float или string.\n\n* UDF могут проверять количество, типы и имена аргументов на этапе настройки запроса и выдавать ошибки.\n\nАгрегационные функции пока не поддерживаются. Другими словами, ваши UDF вызываются для одного документа за раз и должны возвращать некоторое значение для этого документа. Написать функцию, которая может вычислять агрегатное значение, например AVG() по всей группе документов с одинаковым ключом GROUP BY, пока невозможно. Однако вы можете использовать UDF внутри встроенных агрегатных функций: то есть, хотя MYCUSTOMAVG() пока не поддерживается, AVG(MYCUSTOMFUNC()) будет работать отлично!\n\nUDF имеют широкий спектр применения, например:\n\n* внедрение пользовательских математических или строковых функций;\n\n* доступ к базам данных или файлам изнутри Manticore;\n\n* создание сложных функций ранжирования.\n\n## Плагины\n\nПлагины предоставляют дополнительные возможности для расширения функционала поиска. В настоящее время их можно использовать для вычисления пользовательских ранжировок и токенизации документов и запросов.\n\nВот полный список типов плагинов:\n\n* UDF плагины (фактически UDF, но поскольку они подключаются как плагины, их также называют «UDF плагинами»)\n\n* плагины ранжирования\n\n* плагины фильтрации токенов во время индексации\n\n* плагины фильтрации токенов во время выполнения запроса\n\nВ этом разделе описан общий процесс написания и управления плагинами; особенности создания разных типов плагинов рассматриваются в соответствующих подразделах.\n\nИтак, как написать и использовать плагин? Вот краткое руководство из четырёх шагов:\n\n* создать динамическую библиотеку (либо .so, либо .dll), скорее всего на C или C++;\n\n* загрузить плагин в searchd с помощью [CREATE PLUGIN](../../Extensions/UDFs_and_Plugins/Plugins/Creating_a_plugin.md);\n\n* использовать плагин с помощью вызовов, специфичных для плагина (обычно через OPTIONS);\n\n* выгрузить или перезагрузить плагин с помощью [DROP PLUGIN](../../Extensions/UDFs_and_Plugins/Plugins/Deleting_a_plugin.md) и [RELOAD PLUGINS](../../Extensions/UDFs_and_Plugins/Plugins/Reloading_plugins.md) соответственно.\n\nОбратите внимание, что хотя UDF являются полноценными плагинами, они устанавливаются с помощью отдельного оператора [CREATE FUNCTION](../../Extensions/UDFs_and_Plugins/UDF/Creating_a_function.md). Это позволяет аккуратно указать тип возвращаемого значения, не жертвуя обратной совместимостью и не меняя синтаксис.\n\nДинамические плагины поддерживаются в потоках и в thread_pool воркерах. Несколько плагинов (и/или UDF) могут содержаться в одном файле библиотеки. Вы можете либо сгруппировать все плагины проекта в одну большую библиотеку, либо создать отдельную библиотеку для каждого UDF и плагина — выбор за вами.\n\nКак и для UDF, следует включить заголовочный файл `src/sphinxudf.h`. Минимум, что вам понадобится — это константа `SPH_UDF_VERSION` для реализации соответствующей функции версии. В зависимости от типа плагина, может потребоваться или не потребоваться линковка с `src/sphinxudf.c`. Однако все функции, реализованные в `sphinxudf.c`, связаны с распаковкой blob `PACKEDFACTORS()`, и ни один тип плагинов не имеет доступа к этим данным. Поэтому на данный момент достаточно линковки только с заголовочным файлом. (Фактически, если вы скопируете номер версии UDF, то для некоторых типов плагинов даже заголовочный файл не понадобится.)\n\nФормально, плагины — это просто наборы функций на C, которые следуют определённому шаблону именования. Обычно требуется определить одну ключевую функцию для основной задачи, но можно определить и дополнительные функции. Например, чтобы реализовать ранжировщик с именем \"myrank\", нужно определить функцию `myrank_finalize()`, которая возвращает значение ранга. Но можно также определить функции `myrank_init()`, `myrank_update()` и `myrank_deinit()`. Конкретные наборы известных суффиксов и аргументов вызова зависят от типа плагина, но _init() и _deinit() универсальны и есть у каждого плагина. Подсказка: для быстрого ознакомления с известными суффиксами и типами аргументов смотрите `sphinxplugin.h`, где прототипы вызовов определены в начале файла.\n\nХотя публичный интерфейс определён на чистом C, наши плагины фактически следуют *объектно-ориентированной модели*. Действительно, каждая функция `_init()` получает параметр `void ** userdata` для вывода, и указатель, сохранённый в `(*userdata)`, затем передаётся как первый аргумент всем остальным функциям плагина. Так что можно считать плагин *классом*, который создаётся каждый раз, когда нужен объект этого класса для обработки запроса: указатель `userdata` служит указателем `this`; функции выступают как методы, а функции `_init()` и `_deinit()` работают как конструктор и деструктор соответственно.\n\nЭто небольшое усложнение ООП в C возникает потому, что плагины работают в многопоточном окружении, и некоторым нужно хранить состояние. Нельзя хранить это состояние в глобальной переменной плагина, поэтому мы передаём параметр userdata, что естественно ведёт к модели ООП. Если ваш плагин простой и без состояния, интерфейс позволяет опустить `_init()`, `_deinit()` и любые другие функции.\n\nВ итоге, вот самый простой полный плагин ранжировщика всего из трёх строк кода на C:\n\nCODE_BLOCK_1\n\nВот как использовать простой плагин ранжировщика:\n\nCODE_BLOCK_2\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "1a51af8b409479dcb60ffd734cddfe17fbd1b44928f97a0a1ccb12de1d996040": {
    "original": "# UDFs and Plugins\n\nManticore can be extended with user-defined functions, or UDFs for short, like this:\n\nCODE_BLOCK_0\n\nYou can dynamically load and unload UDFs into `searchd` without having to restart the server, and use them in expressions when searching, ranking, etc. A quick summary of the UDF features is as follows:\n\n* UDFs can take integer (both 32-bit and 64-bit), float, string, MVA, or `PACKEDFACTORS()` arguments.\n\n* UDFs can return integer, float, string, or MVA values (MULTI, MULTI64, FLOAT_VECTOR).\n\n* UDFs can check the argument number, types, and names during the query setup phase, and raise errors.\n\nWe do not yet support aggregation functions. In other words, your UDFs will be called for just a single document at a time and are expected to return some value for that document. Writing a function that can compute an aggregate value like AVG() over the entire group of documents that share the same GROUP BY key is not yet possible. However, you can use UDFs within the built-in aggregate functions: that is, even though MYCUSTOMAVG() is not supported yet, AVG(MYCUSTOMFUNC()) should work just fine!\n\n## MVA Return Types\n\nUDFs can also return Multi-Value Attributes (MVA) in addition to scalar values. The supported MVA return types are:\n\n* **MULTI**: Arrays of 32-bit unsigned integers\n\n* **MULTI64**: Arrays of 64-bit signed integers  \n\n* **FLOAT_VECTOR**: Arrays of floating-point numbers\n\nMVA UDFs are created using the same `CREATE FUNCTION` syntax with the appropriate return type, and can be used in SELECT statements just like scalar UDFs.\n\nUDFs offer a wide range of applications, such as:\n\n* incorporating custom mathematical or string functions;\n\n* accessing databases or files from within Manticore;\n\n* creating complex ranking functions.\n\n## Plugins\n\nPlugins offer additional opportunities to expand search functionality. They can currently be used to compute custom rankings and tokenize documents and queries.\n\nHere's the complete list of plugin types:\n\n* UDF plugins (essentially UDFs, but since they're plugged in, they're also referred to as 'UDF plugins')\n\n* ranker plugins\n\n* indexing-time token filter plugins\n\n* query-time token filter plugins\n\nThis section covers the general process of writing and managing plugins; specifics related to creating different types of plugins are discussed in their respective subsections.\n\nSo, how do you write and use a plugin? Here's a quick four-step guide:\n\n* create a dynamic library (either .so or .dll), most likely using C or C++;\n\n* load the plugin into searchd with [CREATE PLUGIN](../../Extensions/UDFs_and_Plugins/Plugins/Creating_a_plugin.md);\n\n* use the plugin with plugin-specific calls (usually through specific OPTIONS).\n\n* unload or reload a plugin with [DROP PLUGIN](../../Extensions/UDFs_and_Plugins/Plugins/Deleting_a_plugin.md) and [RELOAD PLUGINS](../../Extensions/UDFs_and_Plugins/Plugins/Reloading_plugins.md), respectively.\n\nNote that while UDFs are first-class plugins, they are installed using a separate [CREATE FUNCTION](../../Extensions/UDFs_and_Plugins/UDF/Creating_a_function.md) statement. This allows for a neat specification of the return type, without sacrificing backward compatibility or changing the syntax.\n\nDynamic plugins are supported in threads and thread_pool workers. Multiple plugins (and/or UDFs) can be contained in a single library file. You may choose to either group all project-specific plugins in one large library or create a separate library for each UDF and plugin; it's up to you.\n\nAs with UDFs, you should include the `src/sphinxudf.h` header file. At the very least, you'll need the `SPH_UDF_VERSION` constant to implement an appropriate version function. Depending on the specific plugin type, you may or may not need to link your plugin with `src/sphinxudf.c`. However, all functions implemented in `sphinxudf.c` are related to unpacking the `PACKEDFACTORS()` blob, and no plugin types have access to that data. So currently, linking with just the header should suffice. (In fact, if you copy over the UDF version number, you won't even need the header file for some plugin types.)\n\nFormally, plugins are simply sets of C functions that adhere to a specific naming pattern. You're typically required to define one key function for the primary task, but you can also define additional functions. For instance, to implement a ranker called \"myrank\", you must define a `myrank_finalize()` function that returns the rank value. However, you can also define `myrank_init()`, `myrank_update()`, and `myrank_deinit()` functions. Specific sets of well-known suffixes and call arguments differ based on the plugin type, but _init() and _deinit() are generic, and every plugin has them. Hint: for a quick reference on known suffixes and their argument types, refer to `sphinxplugin.h`, where the call prototypes are defined at the beginning of the file.\n\nEven though the public interface is defined in pure C, our plugins essentially follow an *object-oriented model*. Indeed, every `_init()` function receives a `void ** userdata` out-parameter, and the pointer value stored at `(*userdata)` is then passed as the first argument to all other plugin functions. So you can think of a plugin as a *class* that gets instantiated every time an object of that class is needed to handle a request: the `userdata` pointer serves as the `this` pointer; the functions act as methods, and the `_init()` and `_deinit()` functions work as constructor and destructor, respectively.\n\nThis minor OOP-in-C complication arises because plugins run in a multi-threaded environment, and some need to maintain state. You can't store that state in a global variable in your plugin, so we pass around a userdata parameter, which naturally leads to the OOP model. If your plugin is simple and stateless, the interface allows you to omit `_init()`, `_deinit()`, and any other functions.\n\nTo summarize, here's the simplest complete ranker plugin in just three lines of C code:\n\nCODE_BLOCK_1\n\nHere's how to use the simple ranker plugin:\n\nCODE_BLOCK_2\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# UDFs and Plugins\n\nManticore 可以通过用户自定义函数（简称 UDFs）进行扩展，方法如下：\n\nCODE_BLOCK_0\n\n您可以动态加载和卸载 UDFs 到 `searchd`，无需重启服务器，并在搜索、排序等表达式中使用它们。UDF 功能的简要总结如下：\n\n* UDF 可以接受整数（32 位和 64 位）、浮点数、字符串、MVA 或 `PACKEDFACTORS()` 参数。\n\n* UDF 可以返回整数、浮点数、字符串或 MVA 值（MULTI、MULTI64、FLOAT_VECTOR）。\n\n* UDF 可以在查询设置阶段检查参数数量、类型和名称，并抛出错误。\n\n我们尚不支持聚合函数。换句话说，您的 UDF 将一次仅针对单个文档调用，并期望返回该文档的某个值。编写能够计算整个共享相同 GROUP BY 键的文档组的聚合值（如 AVG()）的函数目前还不可行。不过，您可以在内置聚合函数中使用 UDF：即使 MYCUSTOMAVG() 目前不支持，AVG(MYCUSTOMFUNC()) 应该可以正常工作！\n\n## MVA 返回类型\n\nUDF 除了标量值外，还可以返回多值属性（MVA）。支持的 MVA 返回类型有：\n\n* **MULTI**：32 位无符号整数数组\n\n* **MULTI64**：64 位有符号整数数组\n\n* **FLOAT_VECTOR**：浮点数数组\n\nMVA UDF 使用相同的 `CREATE FUNCTION` 语法创建，指定相应的返回类型，并且可以像标量 UDF 一样在 SELECT 语句中使用。\n\nUDF 提供了广泛的应用场景，例如：\n\n* 集成自定义数学或字符串函数；\n\n* 从 Manticore 内部访问数据库或文件；\n\n* 创建复杂的排序函数。\n\n## 插件\n\n插件提供了扩展搜索功能的额外机会。目前它们可用于计算自定义排序和对文档及查询进行分词。\n\n以下是插件类型的完整列表：\n\n* UDF 插件（本质上是 UDF，但由于它们是插件，也称为“UDF 插件”）\n\n* 排序器插件\n\n* 索引时的分词过滤器插件\n\n* 查询时的分词过滤器插件\n\n本节涵盖编写和管理插件的一般流程；有关创建不同类型插件的具体内容，请参见各自子章节。\n\n那么，如何编写和使用插件？以下是快速的四步指南：\n\n* 创建动态库（.so 或 .dll），通常使用 C 或 C++；\n\n* 使用 [CREATE PLUGIN](../../Extensions/UDFs_and_Plugins/Plugins/Creating_a_plugin.md) 将插件加载到 searchd；\n\n* 通过插件特定调用（通常通过特定 OPTIONS）使用插件；\n\n* 分别使用 [DROP PLUGIN](../../Extensions/UDFs_and_Plugins/Plugins/Deleting_a_plugin.md) 和 [RELOAD PLUGINS](../../Extensions/UDFs_and_Plugins/Plugins/Reloading_plugins.md) 卸载或重新加载插件。\n\n请注意，虽然 UDF 是一等插件，但它们是通过单独的 [CREATE FUNCTION](../../Extensions/UDFs_and_Plugins/UDF/Creating_a_function.md) 语句安装的。这允许对返回类型进行整洁的指定，同时不牺牲向后兼容性或更改语法。\n\n动态插件支持线程和线程池工作线程。多个插件（和/或 UDF）可以包含在单个库文件中。您可以选择将所有项目特定插件放入一个大型库，或为每个 UDF 和插件创建单独的库；这取决于您。\n\n与 UDF 一样，您应包含 `src/sphinxudf.h` 头文件。至少，您需要 `SPH_UDF_VERSION` 常量来实现适当的版本函数。根据具体插件类型，您可能需要或不需要将插件与 `src/sphinxudf.c` 链接。然而，`sphinxudf.c` 中实现的所有函数都与解包 `PACKEDFACTORS()` blob 相关，而没有插件类型可以访问该数据。因此，目前仅链接头文件就足够了。（实际上，如果您复制 UDF 版本号，对于某些插件类型甚至不需要头文件。）\n\n形式上，插件只是遵循特定命名模式的一组 C 函数。通常需要定义一个关键函数来完成主要任务，但也可以定义额外函数。例如，要实现名为 \"myrank\" 的排序器，必须定义返回排序值的 `myrank_finalize()` 函数。但您也可以定义 `myrank_init()`、`myrank_update()` 和 `myrank_deinit()` 函数。具体的已知后缀和调用参数集因插件类型而异，但 _init() 和 _deinit() 是通用的，每个插件都有它们。提示：有关已知后缀及其参数类型的快速参考，请参阅 `sphinxplugin.h`，调用原型定义在文件开头。\n\n尽管公共接口是用纯 C 定义的，我们的插件本质上遵循*面向对象模型*。确实，每个 `_init()` 函数接收一个 `void ** userdata` 输出参数，存储在 `(*userdata)` 的指针值随后作为第一个参数传递给所有其他插件函数。因此，您可以将插件视为一个*类*，每当需要处理请求时实例化该类的对象：`userdata` 指针充当 `this` 指针；函数作为方法；`_init()` 和 `_deinit()` 分别作为构造函数和析构函数。\n\n这种在 C 中的轻微面向对象复杂性产生的原因是插件运行在多线程环境中，有些插件需要维护状态。您不能将状态存储在插件的全局变量中，因此我们传递 userdata 参数，这自然导致了面向对象模型。如果您的插件简单且无状态，接口允许您省略 `_init()`、`_deinit()` 和其他函数。\n\n总结一下，以下是仅用三行 C 代码实现的最简单完整排序器插件：\n\nCODE_BLOCK_1\n\n以下是如何使用该简单排序器插件：\n\nCODE_BLOCK_2\n\n<!-- proofread -->",
      "russian": "# UDFs and Plugins\n\nManticore can be extended with user-defined functions, or UDFs for short, like this:\n\nCODE_BLOCK_0\n\nYou can dynamically load and unload UDFs into `searchd` without having to restart the server, and use them in expressions when searching, ranking, etc. A quick summary of the UDF features is as follows:\n\n* UDFs can take integer (both 32-bit and 64-bit), float, string, MVA, or `PACKEDFACTORS()` arguments.\n\n* UDFs can return integer, float, string, or MVA values (MULTI, MULTI64, FLOAT_VECTOR).\n\n* UDFs can check the argument number, types, and names during the query setup phase, and raise errors.\n\nWe do not yet support aggregation functions. In other words, your UDFs will be called for just a single document at a time and are expected to return some value for that document. Writing a function that can compute an aggregate value like AVG() over the entire group of documents that share the same GROUP BY key is not yet possible. However, you can use UDFs within the built-in aggregate functions: that is, even though MYCUSTOMAVG() is not supported yet, AVG(MYCUSTOMFUNC()) should work just fine!\n\n## MVA Return Types\n\nUDFs can also return Multi-Value Attributes (MVA) in addition to scalar values. The supported MVA return types are:\n\n* **MULTI**: Arrays of 32-bit unsigned integers\n\n* **MULTI64**: Arrays of 64-bit signed integers  \n\n* **FLOAT_VECTOR**: Arrays of floating-point numbers\n\nMVA UDFs are created using the same `CREATE FUNCTION` syntax with the appropriate return type, and can be used in SELECT statements just like scalar UDFs.\n\nUDFs offer a wide range of applications, such as:\n\n* incorporating custom mathematical or string functions;\n\n* accessing databases or files from within Manticore;\n\n* creating complex ranking functions.\n\n## Plugins\n\nPlugins offer additional opportunities to expand search functionality. They can currently be used to compute custom rankings and tokenize documents and queries.\n\nHere's the complete list of plugin types:\n\n* UDF plugins (essentially UDFs, but since they're plugged in, they're also referred to as 'UDF plugins')\n\n* ranker plugins\n\n* indexing-time token filter plugins\n\n* query-time token filter plugins\n\nThis section covers the general process of writing and managing plugins; specifics related to creating different types of plugins are discussed in their respective subsections.\n\nSo, how do you write and use a plugin? Here's a quick four-step guide:\n\n* create a dynamic library (either .so or .dll), most likely using C or C++;\n\n* load the plugin into searchd with [CREATE PLUGIN](../../Extensions/UDFs_and_Plugins/Plugins/Creating_a_plugin.md);\n\n* use the plugin with plugin-specific calls (usually through specific OPTIONS).\n\n* unload or reload a plugin with [DROP PLUGIN](../../Extensions/UDFs_and_Plugins/Plugins/Deleting_a_plugin.md) and [RELOAD PLUGINS](../../Extensions/UDFs_and_Plugins/Plugins/Reloading_plugins.md), respectively.\n\nNote that while UDFs are first-class plugins, they are installed using a separate [CREATE FUNCTION](../../Extensions/UDFs_and_Plugins/UDF/Creating_a_function.md) statement. This allows for a neat specification of the return type, without sacrificing backward compatibility or changing the syntax.\n\nDynamic plugins are supported in threads and thread_pool workers. Multiple plugins (and/or UDFs) can be contained in a single library file. You may choose to either group all project-specific plugins in one large library or create a separate library for each UDF and plugin; it's up to you.\n\nAs with UDFs, you should include the `src/sphinxudf.h` header file. At the very least, you'll need the `SPH_UDF_VERSION` constant to implement an appropriate version function. Depending on the specific plugin type, you may or may not need to link your plugin with `src/sphinxudf.c`. However, all functions implemented in `sphinxudf.c` are related to unpacking the `PACKEDFACTORS()` blob, and no plugin types have access to that data. So currently, linking with just the header should suffice. (In fact, if you copy over the UDF version number, you won't even need the header file for some plugin types.)\n\nFormally, plugins are simply sets of C functions that adhere to a specific naming pattern. You're typically required to define one key function for the primary task, but you can also define additional functions. For instance, to implement a ranker called \"myrank\", you must define a `myrank_finalize()` function that returns the rank value. However, you can also define `myrank_init()`, `myrank_update()`, and `myrank_deinit()` functions. Specific sets of well-known suffixes and call arguments differ based on the plugin type, but _init() and _deinit() are generic, and every plugin has them. Hint: for a quick reference on known suffixes and their argument types, refer to `sphinxplugin.h`, where the call prototypes are defined at the beginning of the file.\n\nEven though the public interface is defined in pure C, our plugins essentially follow an *object-oriented model*. Indeed, every `_init()` function receives a `void ** userdata` out-parameter, and the pointer value stored at `(*userdata)` is then passed as the first argument to all other plugin functions. So you can think of a plugin as a *class* that gets instantiated every time an object of that class is needed to handle a request: the `userdata` pointer serves as the `this` pointer; the functions act as methods, and the `_init()` and `_deinit()` functions work as constructor and destructor, respectively.\n\nThis minor OOP-in-C complication arises because plugins run in a multi-threaded environment, and some need to maintain state. You can't store that state in a global variable in your plugin, so we pass around a userdata parameter, which naturally leads to the OOP model. If your plugin is simple and stateless, the interface allows you to omit `_init()`, `_deinit()`, and any other functions.\n\nTo summarize, here's the simplest complete ranker plugin in just three lines of C code:\n\nCODE_BLOCK_1\n\nHere's how to use the simple ranker plugin:\n\nCODE_BLOCK_2\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
