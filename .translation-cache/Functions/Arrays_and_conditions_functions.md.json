{
  "903e2baef7728d250e265a29199f9754ae8fee1e69c1e9ab95f8eba5b27bf182": {
    "original": "`HISTOGRAM(expr, {hist_interval=size, hist_offset=value})` takes a bucket size and returns the bucket number for the value. The key function is:\n\nCODE_BLOCK_25\n\nThe histogram argument `interval` must be positive. The histogram argument `offset` must be positive and less than `interval`. It is used in aggregation, `FACET`, and grouping.\n\n<!-- intro -->\n\nExample:\n\n<!-- request HISTOGRAM() -->\n\nCODE_BLOCK_26\n\n<!-- end -->\n\n### IN()\n\n`IN(expr,val1,val2,...)` takes 2 or more arguments and returns 1 if the 1st argument (expr) is equal to any of the other arguments (val1..valN), or 0 otherwise. Currently, all the checked values (but not the expression itself) are required to be constant. The constants are pre-sorted, and binary search is used, so `IN()` even against a large arbitrary list of constants will be very quick. The first argument can also be an MVA attribute. In that case, `IN()` will return 1 if any of the MVA values are equal to any of the other arguments. `IN()` also supports `IN(expr,@uservar)` syntax to check whether the value belongs to the list in the given global user variable. The first argument can be a JSON attribute.\n\n### INDEXOF()\n\n`INDEXOF(cond FOR var IN json.array)` function iterates through all elements in the array and returns the index of the first element for which 'cond' is true, and -1 if 'cond' is false for every element in the array.\n\n### INTERVAL()\n\n`INTERVAL(expr,point1,point2,point3,...)` takes 2 or more arguments and returns the index of the argument that is less than the first argument: it returns 0 if `expr<point1`, 1 if `point1<=expr<point2`, and so on. It is required that `point1<point2<...<pointN` for this function to work correctly.\n\n### LENGTH()\n\n`LENGTH(attr_mva)` function returns the number of elements in an MVA set. It works with both 32-bit and 64-bit MVA attributes. `LENGTH(attr_json)` returns the length of a field in JSON. The return value depends on the type of field. For example, `LENGTH(json_attr.some_int)` always returns 1, and `LENGTH(json_attr.some_array)` returns the number of elements in the array. `LENGTH(string_expr)` function returns the length of the string resulting from an expression.\n\n[TO_STRING()](../Functions/Type_casting_functions.md#TO_STRING%28%29) must enclose the expression, regardless of whether the expression returns a non-string or it's simply a string attribute.\n\n### RANGE()\n\n<!-- example range -->\n\n`RANGE(expr, {range_from=value,range_to=value})` takes a set of ranges and returns the bucket number for the value.\n\nThis expression includes the `range_from` value and excludes the `range_to` value for each range. A range can be open - having only the `range_from` or only the `range_to` value. It is used in aggregation, `FACET`, and grouping.\n\n<!-- intro -->\n\nExample:\n\n<!-- request RANGE() -->\n\nCODE_BLOCK_27\n\n<!-- end -->\n\n### REMAP()\n\n<!-- example remap -->\n\n`REMAP(condition, expression, (cond1, cond2, ...), (expr1, expr2, ...))` function allows you to make some exceptions to expression values depending on condition values. The condition expression should always result in an integer, while the expression can result in an integer or float.\n\n<!-- intro -->\n\nExample:\n\n<!-- request REMAP() -->\n\nCODE_BLOCK_28\n\n<!-- request Another example -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\nThis will put documents with sizes 5 and 6 first, followed by sizes 7 and 8. In case there's an original value not listed in the array (e.g. size 10), it will default to 15, and in this case, will be placed at the end.\n\n<!-- proofread -->",
    "translations": {
      "chinese": "`HISTOGRAM(expr, {hist_interval=size, hist_offset=value})` 接受一个桶大小并返回该值所属的桶编号。关键函数是：\n\nCODE_BLOCK_25\n\n直方图参数 `interval` 必须为正。直方图参数 `offset` 必须为正且小于 `interval`。它用于聚合、`FACET` 和分组。\n\n<!-- intro -->\n\n示例：\n\n<!-- request HISTOGRAM() -->\n\nCODE_BLOCK_26\n\n<!-- end -->\n\n### IN()\n\n`IN(expr,val1,val2,...)` 接受 2 个或更多参数，如果第一个参数（expr）等于其他任一参数（val1..valN），则返回 1，否则返回 0。目前，所有被检查的值（但不包括表达式本身）必须是常量。常量会被预先排序，并使用二分查找，因此即使是针对大量任意常量列表的 `IN()` 也会非常快。第一个参数也可以是 MVA 属性。在这种情况下，如果任何 MVA 值等于其他任一参数，`IN()` 将返回 1。`IN()` 还支持 `IN(expr,@uservar)` 语法，用于检查值是否属于给定全局用户变量中的列表。第一个参数可以是 JSON 属性。\n\n### INDEXOF()\n\n`INDEXOF(cond FOR var IN json.array)` 函数遍历数组中的所有元素，返回第一个满足 'cond' 条件的元素的索引，如果数组中所有元素都不满足 'cond'，则返回 -1。\n\n### INTERVAL()\n\n`INTERVAL(expr,point1,point2,point3,...)` 接受 2 个或更多参数，返回第一个小于第一个参数的参数的索引：如果 `expr<point1` 返回 0，`point1<=expr<point2` 返回 1，依此类推。要求 `point1<point2<...<pointN`，该函数才能正确工作。\n\n### LENGTH()\n\n`LENGTH(attr_mva)` 函数返回 MVA 集合中的元素数量。它适用于 32 位和 64 位 MVA 属性。`LENGTH(attr_json)` 返回 JSON 字段的长度。返回值取决于字段类型。例如，`LENGTH(json_attr.some_int)` 总是返回 1，而 `LENGTH(json_attr.some_array)` 返回数组中的元素数量。`LENGTH(string_expr)` 函数返回表达式结果字符串的长度。\n\n[TO_STRING()](../Functions/Type_casting_functions.md#TO_STRING%28%29) 必须包裹表达式，无论表达式返回的是非字符串还是简单的字符串属性。\n\n### RANGE()\n\n<!-- example range -->\n\n`RANGE(expr, {range_from=value,range_to=value})` 接受一组范围并返回该值所属的桶编号。\n\n该表达式包含每个范围的 `range_from` 值，但不包含 `range_to` 值。范围可以是开放的——只有 `range_from` 或只有 `range_to`。它用于聚合、`FACET` 和分组。\n\n<!-- intro -->\n\n示例：\n\n<!-- request RANGE() -->\n\nCODE_BLOCK_27\n\n<!-- end -->\n\n### REMAP()\n\n<!-- example remap -->\n\n`REMAP(condition, expression, (cond1, cond2, ...), (expr1, expr2, ...))` 函数允许根据条件值对表达式值做一些例外处理。条件表达式应始终返回整数，而表达式可以返回整数或浮点数。\n\n<!-- intro -->\n\n示例：\n\n<!-- request REMAP() -->\n\nCODE_BLOCK_28\n\n<!-- request Another example -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n这将使大小为 5 和 6 的文档排在前面，接着是大小为 7 和 8 的文档。如果存在未列在数组中的原始值（例如大小为 10），则默认值为 15，在这种情况下，将排在最后。\n\n<!-- proofread -->",
      "russian": "`HISTOGRAM(expr, {hist_interval=size, hist_offset=value})` принимает размер корзины и возвращает номер корзины для значения. Ключевая функция:\n\nCODE_BLOCK_25\n\nАргумент гистограммы `interval` должен быть положительным. Аргумент гистограммы `offset` должен быть положительным и меньше `interval`. Он используется в агрегации, `FACET` и группировке.\n\n<!-- intro -->\n\nПример:\n\n<!-- request HISTOGRAM() -->\n\nCODE_BLOCK_26\n\n<!-- end -->\n\n### IN()\n\n`IN(expr,val1,val2,...)` принимает 2 или более аргументов и возвращает 1, если первый аргумент (expr) равен любому из других аргументов (val1..valN), или 0 в противном случае. В настоящее время все проверяемые значения (но не само выражение) должны быть константами. Константы предварительно сортируются, и используется бинарный поиск, поэтому `IN()` даже при большом произвольном списке констант будет очень быстрым. Первый аргумент также может быть атрибутом MVA. В этом случае `IN()` вернет 1, если любое из значений MVA равно любому из других аргументов. `IN()` также поддерживает синтаксис `IN(expr,@uservar)` для проверки, принадлежит ли значение списку в данном глобальном пользовательском переменном. Первый аргумент может быть JSON-атрибутом.\n\n### INDEXOF()\n\nФункция `INDEXOF(cond FOR var IN json.array)` перебирает все элементы массива и возвращает индекс первого элемента, для которого 'cond' истинно, и -1, если 'cond' ложно для каждого элемента массива.\n\n### INTERVAL()\n\n`INTERVAL(expr,point1,point2,point3,...)` принимает 2 или более аргументов и возвращает индекс аргумента, который меньше первого аргумента: возвращает 0, если `expr<point1`, 1, если `point1<=expr<point2` и так далее. Для корректной работы функции требуется, чтобы `point1<point2<...<pointN`.\n\n### LENGTH()\n\nФункция `LENGTH(attr_mva)` возвращает количество элементов в наборе MVA. Она работает как с 32-битными, так и с 64-битными атрибутами MVA. `LENGTH(attr_json)` возвращает длину поля в JSON. Возвращаемое значение зависит от типа поля. Например, `LENGTH(json_attr.some_int)` всегда возвращает 1, а `LENGTH(json_attr.some_array)` возвращает количество элементов в массиве. Функция `LENGTH(string_expr)` возвращает длину строки, полученной из выражения.\n\n[TO_STRING()](../Functions/Type_casting_functions.md#TO_STRING%28%29) должна обрамлять выражение, независимо от того, возвращает ли выражение нестроковое значение или это просто строковый атрибут.\n\n### RANGE()\n\n<!-- example range -->\n\n`RANGE(expr, {range_from=value,range_to=value})` принимает набор диапазонов и возвращает номер корзины для значения.\n\nЭто выражение включает значение `range_from` и исключает значение `range_to` для каждого диапазона. Диапазон может быть открытым — иметь только значение `range_from` или только `range_to`. Используется в агрегации, `FACET` и группировке.\n\n<!-- intro -->\n\nПример:\n\n<!-- request RANGE() -->\n\nCODE_BLOCK_27\n\n<!-- end -->\n\n### REMAP()\n\n<!-- example remap -->\n\nФункция `REMAP(condition, expression, (cond1, cond2, ...), (expr1, expr2, ...))` позволяет делать некоторые исключения для значений выражения в зависимости от значений условия. Выражение условия всегда должно возвращать целое число, в то время как выражение может возвращать целое число или число с плавающей точкой.\n\n<!-- intro -->\n\nПример:\n\n<!-- request REMAP() -->\n\nCODE_BLOCK_28\n\n<!-- request Another example -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\nЭто поместит документы с размерами 5 и 6 первыми, за ними последуют размеры 7 и 8. В случае, если есть исходное значение, не указанное в массиве (например, размер 10), оно по умолчанию будет равно 15 и в этом случае будет размещено в конце.\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "4dbdd845526a7fd75bff2f67c3744af5483d83081964298e4770a6e2d60e2f5b": {
    "original": "# Arrays and conditions functions\n\n### ALL()\n\n<!-- example all_json -->\n\n`ALL(cond FOR var IN json.array)` applies to JSON arrays and returns 1 if the condition is true for all elements in the array and 0 otherwise. `cond` is a general expression that can also use `var` as the current value of an array element within itself.\n\n<!-- request ALL() with json -->\n\nCODE_BLOCK_0\n\n<!-- response ALL() with json -->\n\nCODE_BLOCK_1\n\n<!-- request ALL() with json ex. 2 -->\n\nCODE_BLOCK_2\n\n<!-- response ALL() with json ex. 2 -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- example all_mva -->\n\n`ALL(mva)` is a special constructor for multi-value attributes. When used with comparison operators (including comparison with `IN()`), it returns 1 if all values from the MVA attribute are found among the compared values.\n\n<!-- request ALL() with MVA -->\n\nCODE_BLOCK_4\n\n<!-- response ALL() with MVA -->\n\nCODE_BLOCK_5\n\n<!-- request ALL() with MVA and IN() -->\n\nCODE_BLOCK_6\n\n<!-- response ALL() with MVA and IN() -->\n\nCODE_BLOCK_7\n\n<!-- end -->\n\n<!-- example all_not_in -->\n\nTo compare an MVA attribute with an array, avoid using `<mva> NOT ALL()`; use `ALL(<mva>) NOT IN()` instead.\n\n<!-- request ALL() with MVA and NOT IN() -->\n\nCODE_BLOCK_8\n\n<!-- response ALL() with MVA and NOT IN() -->\n\nCODE_BLOCK_9\n\n<!-- end -->\n\n<!-- example all_string -->\n\n`ALL(string list)` is a special operation for filtering string tags.\n\nIf all of the words enumerated as arguments of `ALL()` are present in the attribute, the filter matches. The optional `NOT` inverts the logic.\n\nThis filter internally uses doc-by-doc matching, so in the case of a full scan query, it might be slower than expected. It is intended for attributes that are not indexed, like calculated expressions or tags in PQ tables. If you need such filtering, consider the solution of putting the string attribute as a full-text field, and then use the full-text operator `match()`, which will invoke a full-text search.\n\n<!-- request ALL() with strings -->\n\nCODE_BLOCK_10\n\n<!-- response ALL() with strings -->\n\nCODE_BLOCK_11\n\n<!-- request ALL() with strings and NOT -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n### ANY()\n\n<!-- example any_json -->\n\n`ANY(cond FOR var IN json.array)` applies to JSON arrays and returns 1 if the condition is true for any element in the array and 0 otherwise. `cond` is a general expression that can also use `var` as the current value of an array element within itself.\n\n<!-- request ANY() with json -->\n\nCODE_BLOCK_13\n\n<!-- response ANY() with json -->\n\nCODE_BLOCK_14\n\n<!-- request ANY() with json ex. 2 -->\n\nCODE_BLOCK_15\n\n<!-- response ANY() with json ex. 2 -->\n\nCODE_BLOCK_16\n\n<!-- end -->\n\n<!-- example any_mva -->\n\n`ANY(mva)` is a special constructor for multi-value attributes. When used with comparison operators (including comparison with `IN()`), it returns 1 if any of the MVA values is found among the compared values.\n\nWhen comparing an array using `IN()`, `ANY()` is assumed by default if not otherwise specified, but a warning will be issued regarding the missing constructor.\n\n<!-- request ANY() with MVA -->\n\nCODE_BLOCK_17\n\n<!-- request ANY() with MVA and IN() -->\n\nCODE_BLOCK_18\n\n<!-- response ANY() with MVA and IN() -->\n\nCODE_BLOCK_19\n\n<!-- end -->\n\n<!-- example any_not_in -->\n\nTo compare an MVA attribute with an array, avoid using `<mva> NOT ANY()`; use `<mva> NOT IN()` instead or `ANY(<mva>) NOT IN()`.\n\n<!-- request ANY() with MVA and NOT IN() -->\n\nCODE_BLOCK_20\n\n<!-- end -->\n\n<!-- example any_string -->\n\n`ANY(string list)` is a special operation for filtering string tags.\n\nIf any of the words enumerated as arguments of `ANY()` is present in the attribute, the filter matches. The optional `NOT` inverts the logic.\n\nThis filter internally uses doc-by-doc matching, so in the case of a full scan query, it might be slower than expected. It is intended for attributes that are not indexed, like calculated expressions or tags in PQ tables. If you need such filtering, consider the solution of putting the string attribute as a full-text field, and then use the full-text operator `match()`, which will invoke a full-text search.\n\n<!-- request ANY() with strings -->\n\nCODE_BLOCK_21\n\n<!-- response ANY() with strings -->\n\nCODE_BLOCK_22\n\n<!-- request ANY() with strings and NOT -->\n\nCODE_BLOCK_23\n\n<!-- end -->\n\n### CONTAINS()\n\n`CONTAINS(polygon, x, y)` checks whether the (x,y) point is within the given polygon, and returns 1 if true, or 0 if false. The polygon has to be specified using either the  [POLY2D()](../Functions/Geo_spatial_functions.md#POLY2D%28%29) function. The former function is intended for \"small\" polygons, meaning less than 500 km (300 miles) a side, and it doesn't take into account the Earth's curvature for speed. For larger distances, you should use `GEOPOLY2D`, which tessellates the given polygon in smaller parts, accounting for the Earth's curvature.\n\n### IF()\n\n<!-- example if -->\n\nThe behavior of `IF()` is slightly different from its MySQL counterpart. It takes 3 arguments, checks whether the 1st argument is equal to 0.0, returns the 2nd argument if it is not zero, or the 3rd one when it is. Note that unlike comparison operators, `IF()` does **not** use a threshold! Therefore, it's safe to use comparison results as its 1st argument, but arithmetic operators might produce unexpected results. For instance, the following two calls will produce *different* results even though they are logically equivalent:\n\n<!-- request IF() -->\n\nCODE_BLOCK_24\n\n<!-- end -->\n\nIn the first case, the comparison operator <> will return 0.0 (false) due to a threshold, and `IF()` will always return `**` as a result. In the second case, the same `sqrt(3)*sqrt(3)-3` expression will be compared with zero *without* a threshold by the `IF()` function itself. However, its value will be slightly different from zero due to limited floating-point calculation precision. Because of this, the comparison with 0.0 done by `IF()` will not pass, and the second variant will return 'a' as a result.\n\n### HISTOGRAM()\n\n<!-- example histogram -->",
    "translations": {
      "chinese": "# 数组和条件函数\n\n### ALL()\n\n<!-- example all_json -->\n\n`ALL(cond FOR var IN json.array)` 适用于 JSON 数组，如果数组中所有元素都满足条件，则返回 1，否则返回 0。`cond` 是一个通用表达式，也可以在其中使用 `var` 作为当前数组元素的值。\n\n<!-- request ALL() with json -->\n\nCODE_BLOCK_0\n\n<!-- response ALL() with json -->\n\nCODE_BLOCK_1\n\n<!-- request ALL() with json ex. 2 -->\n\nCODE_BLOCK_2\n\n<!-- response ALL() with json ex. 2 -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- example all_mva -->\n\n`ALL(mva)` 是多值属性的特殊构造函数。当与比较运算符（包括与 `IN()` 的比较）一起使用时，如果 MVA 属性中的所有值都在被比较的值中，则返回 1。\n\n<!-- request ALL() with MVA -->\n\nCODE_BLOCK_4\n\n<!-- response ALL() with MVA -->\n\nCODE_BLOCK_5\n\n<!-- request ALL() with MVA and IN() -->\n\nCODE_BLOCK_6\n\n<!-- response ALL() with MVA and IN() -->\n\nCODE_BLOCK_7\n\n<!-- end -->\n\n<!-- example all_not_in -->\n\n要将 MVA 属性与数组进行比较，避免使用 `<mva> NOT ALL()`；应使用 `ALL(<mva>) NOT IN()`。\n\n<!-- request ALL() with MVA and NOT IN() -->\n\nCODE_BLOCK_8\n\n<!-- response ALL() with MVA and NOT IN() -->\n\nCODE_BLOCK_9\n\n<!-- end -->\n\n<!-- example all_string -->\n\n`ALL(string list)` 是用于过滤字符串标签的特殊操作。\n\n如果 `ALL()` 的所有参数中列举的单词都存在于属性中，则过滤器匹配。可选的 `NOT` 会反转逻辑。\n\n此过滤器内部使用逐文档匹配，因此在全扫描查询的情况下，可能比预期更慢。它适用于未建立索引的属性，如计算表达式或 PQ 表中的标签。如果需要此类过滤，建议将字符串属性作为全文字段，然后使用全文操作符 `match()`，这将调用全文搜索。\n\n<!-- request ALL() with strings -->\n\nCODE_BLOCK_10\n\n<!-- response ALL() with strings -->\n\nCODE_BLOCK_11\n\n<!-- request ALL() with strings and NOT -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n### ANY()\n\n<!-- example any_json -->\n\n`ANY(cond FOR var IN json.array)` 适用于 JSON 数组，如果数组中任一元素满足条件，则返回 1，否则返回 0。`cond` 是一个通用表达式，也可以在其中使用 `var` 作为当前数组元素的值。\n\n<!-- request ANY() with json -->\n\nCODE_BLOCK_13\n\n<!-- response ANY() with json -->\n\nCODE_BLOCK_14\n\n<!-- request ANY() with json ex. 2 -->\n\nCODE_BLOCK_15\n\n<!-- response ANY() with json ex. 2 -->\n\nCODE_BLOCK_16\n\n<!-- end -->\n\n<!-- example any_mva -->\n\n`ANY(mva)` 是多值属性的特殊构造函数。当与比较运算符（包括与 `IN()` 的比较）一起使用时，如果 MVA 属性中的任一值在被比较的值中，则返回 1。\n\n当使用 `IN()` 比较数组时，如果未另行指定，默认假设为 `ANY()`，但会发出缺少构造函数的警告。\n\n<!-- request ANY() with MVA -->\n\nCODE_BLOCK_17\n\n<!-- request ANY() with MVA and IN() -->\n\nCODE_BLOCK_18\n\n<!-- response ANY() with MVA and IN() -->\n\nCODE_BLOCK_19\n\n<!-- end -->\n\n<!-- example any_not_in -->\n\n要将 MVA 属性与数组进行比较，避免使用 `<mva> NOT ANY()`；应使用 `<mva> NOT IN()` 或 `ANY(<mva>) NOT IN()`。\n\n<!-- request ANY() with MVA and NOT IN() -->\n\nCODE_BLOCK_20\n\n<!-- end -->\n\n<!-- example any_string -->\n\n`ANY(string list)` 是用于过滤字符串标签的特殊操作。\n\n如果 `ANY()` 的参数中列举的任一单词存在于属性中，则过滤器匹配。可选的 `NOT` 会反转逻辑。\n\n此过滤器内部使用逐文档匹配，因此在全扫描查询的情况下，可能比预期更慢。它适用于未建立索引的属性，如计算表达式或 PQ 表中的标签。如果需要此类过滤，建议将字符串属性作为全文字段，然后使用全文操作符 `match()`，这将调用全文搜索。\n\n<!-- request ANY() with strings -->\n\nCODE_BLOCK_21\n\n<!-- response ANY() with strings -->\n\nCODE_BLOCK_22\n\n<!-- request ANY() with strings and NOT -->\n\nCODE_BLOCK_23\n\n<!-- end -->\n\n### CONTAINS()\n\n`CONTAINS(polygon, x, y)` 检查点 (x,y) 是否在给定多边形内，若是则返回 1，否则返回 0。多边形必须使用 [POLY2D()](../Functions/Geo_spatial_functions.md#POLY2D%28%29) 函数指定。前者函数适用于“较小”的多边形，指边长小于 500 公里（300 英里），且为了速度不考虑地球曲率。对于较大距离，应使用 `GEOPOLY2D`，它将给定多边形分割成更小部分，考虑地球曲率。\n\n### IF()\n\n<!-- example if -->\n\n`IF()` 的行为与其 MySQL 对应函数略有不同。它接受 3 个参数，检查第 1 个参数是否等于 0.0，如果不为零则返回第 2 个参数，否则返回第 3 个参数。注意，与比较运算符不同，`IF()` **不** 使用阈值！因此，使用比较结果作为第 1 个参数是安全的，但算术运算符可能产生意外结果。例如，以下两个调用即使逻辑上等价，结果也会*不同*：\n\n<!-- request IF() -->\n\nCODE_BLOCK_24\n\n<!-- end -->\n\n在第一种情况下，比较运算符 <> 会因阈值返回 0.0（假），`IF()` 将始终返回 `**` 作为结果。在第二种情况下，相同的 `sqrt(3)*sqrt(3)-3` 表达式将由 `IF()` 函数自身*不带阈值*地与零比较。然而，由于浮点计算精度有限，其值会略微不同于零。因此，`IF()` 对 0.0 的比较不会通过，第二种变体将返回 'a' 作为结果。\n\n### HISTOGRAM()\n\n<!-- example histogram -->",
      "russian": "# Массивы и функции условий\n\n### ALL()\n\n<!-- example all_json -->\n\n`ALL(cond FOR var IN json.array)` применяется к JSON-массивам и возвращает 1, если условие истинно для всех элементов массива, и 0 в противном случае. `cond` — это общее выражение, которое также может использовать `var` как текущее значение элемента массива внутри себя.\n\n<!-- request ALL() with json -->\n\nCODE_BLOCK_0\n\n<!-- response ALL() with json -->\n\nCODE_BLOCK_1\n\n<!-- request ALL() with json ex. 2 -->\n\nCODE_BLOCK_2\n\n<!-- response ALL() with json ex. 2 -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- example all_mva -->\n\n`ALL(mva)` — это специальный конструктор для мультизначных атрибутов. При использовании с операторами сравнения (включая сравнение с `IN()`), он возвращает 1, если все значения из MVA-атрибута найдены среди сравниваемых значений.\n\n<!-- request ALL() with MVA -->\n\nCODE_BLOCK_4\n\n<!-- response ALL() with MVA -->\n\nCODE_BLOCK_5\n\n<!-- request ALL() with MVA and IN() -->\n\nCODE_BLOCK_6\n\n<!-- response ALL() with MVA and IN() -->\n\nCODE_BLOCK_7\n\n<!-- end -->\n\n<!-- example all_not_in -->\n\nДля сравнения MVA-атрибута с массивом избегайте использования `<mva> NOT ALL()`; вместо этого используйте `ALL(<mva>) NOT IN()`.\n\n<!-- request ALL() with MVA and NOT IN() -->\n\nCODE_BLOCK_8\n\n<!-- response ALL() with MVA and NOT IN() -->\n\nCODE_BLOCK_9\n\n<!-- end -->\n\n<!-- example all_string -->\n\n`ALL(string list)` — это специальная операция для фильтрации строковых тегов.\n\nЕсли все слова, перечисленные в аргументах `ALL()`, присутствуют в атрибуте, фильтр срабатывает. Опциональный `NOT` инвертирует логику.\n\nЭтот фильтр внутренне использует пословное сопоставление, поэтому в случае полного сканирования запрос может работать медленнее, чем ожидалось. Он предназначен для атрибутов, которые не индексируются, например, вычисляемых выражений или тегов в PQ-таблицах. Если вам нужна такая фильтрация, рассмотрите вариант размещения строкового атрибута как полнотекстового поля, а затем используйте полнотекстовый оператор `match()`, который вызовет полнотекстовый поиск.\n\n<!-- request ALL() with strings -->\n\nCODE_BLOCK_10\n\n<!-- response ALL() with strings -->\n\nCODE_BLOCK_11\n\n<!-- request ALL() with strings and NOT -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n### ANY()\n\n<!-- example any_json -->\n\n`ANY(cond FOR var IN json.array)` применяется к JSON-массивам и возвращает 1, если условие истинно для любого элемента массива, и 0 в противном случае. `cond` — это общее выражение, которое также может использовать `var` как текущее значение элемента массива внутри себя.\n\n<!-- request ANY() with json -->\n\nCODE_BLOCK_13\n\n<!-- response ANY() with json -->\n\nCODE_BLOCK_14\n\n<!-- request ANY() with json ex. 2 -->\n\nCODE_BLOCK_15\n\n<!-- response ANY() with json ex. 2 -->\n\nCODE_BLOCK_16\n\n<!-- end -->\n\n<!-- example any_mva -->\n\n`ANY(mva)` — это специальный конструктор для мультизначных атрибутов. При использовании с операторами сравнения (включая сравнение с `IN()`), он возвращает 1, если любое из значений MVA найдено среди сравниваемых значений.\n\nПри сравнении массива с помощью `IN()` по умолчанию предполагается `ANY()`, если не указано иное, но будет выдано предупреждение о пропущенном конструкторе.\n\n<!-- request ANY() with MVA -->\n\nCODE_BLOCK_17\n\n<!-- request ANY() with MVA and IN() -->\n\nCODE_BLOCK_18\n\n<!-- response ANY() with MVA and IN() -->\n\nCODE_BLOCK_19\n\n<!-- end -->\n\n<!-- example any_not_in -->\n\nДля сравнения MVA-атрибута с массивом избегайте использования `<mva> NOT ANY()`; вместо этого используйте `<mva> NOT IN()` или `ANY(<mva>) NOT IN()`.\n\n<!-- request ANY() with MVA and NOT IN() -->\n\nCODE_BLOCK_20\n\n<!-- end -->\n\n<!-- example any_string -->\n\n`ANY(string list)` — это специальная операция для фильтрации строковых тегов.\n\nЕсли любое из слов, перечисленных в аргументах `ANY()`, присутствует в атрибуте, фильтр срабатывает. Опциональный `NOT` инвертирует логику.\n\nЭтот фильтр внутренне использует пословное сопоставление, поэтому в случае полного сканирования запрос может работать медленнее, чем ожидалось. Он предназначен для атрибутов, которые не индексируются, например, вычисляемых выражений или тегов в PQ-таблицах. Если вам нужна такая фильтрация, рассмотрите вариант размещения строкового атрибута как полнотекстового поля, а затем используйте полнотекстовый оператор `match()`, который вызовет полнотекстовый поиск.\n\n<!-- request ANY() with strings -->\n\nCODE_BLOCK_21\n\n<!-- response ANY() with strings -->\n\nCODE_BLOCK_22\n\n<!-- request ANY() with strings and NOT -->\n\nCODE_BLOCK_23\n\n<!-- end -->\n\n### CONTAINS()\n\n`CONTAINS(polygon, x, y)` проверяет, находится ли точка (x,y) внутри заданного полигона, и возвращает 1, если да, или 0, если нет. Полигон должен быть задан с помощью функции [POLY2D()](../Functions/Geo_spatial_functions.md#POLY2D%28%29). Эта функция предназначена для \"маленьких\" полигонов, то есть со стороной менее 500 км (300 миль), и не учитывает кривизну Земли для ускорения. Для больших расстояний следует использовать `GEOPOLY2D`, который разбивает заданный полигон на меньшие части с учётом кривизны Земли.\n\n### IF()\n\n<!-- example if -->\n\nПоведение `IF()` немного отличается от аналога в MySQL. Он принимает 3 аргумента, проверяет, равен ли первый аргумент 0.0, возвращает второй аргумент, если он не равен нулю, или третий, если равен. Обратите внимание, что в отличие от операторов сравнения, `IF()` **не** использует порог! Поэтому безопасно использовать результаты сравнений в качестве первого аргумента, но арифметические операторы могут давать неожиданные результаты. Например, следующие два вызова дадут *разные* результаты, хотя логически эквивалентны:\n\n<!-- request IF() -->\n\nCODE_BLOCK_24\n\n<!-- end -->\n\nВ первом случае оператор сравнения <> вернёт 0.0 (ложь) из-за порога, и `IF()` всегда вернёт `**` как результат. Во втором случае выражение `sqrt(3)*sqrt(3)-3` будет сравниваться с нулём *без* порога самой функцией `IF()`. Однако его значение будет немного отличаться от нуля из-за ограниченной точности вычислений с плавающей точкой. Из-за этого сравнение с 0.0, выполненное `IF()`, не пройдёт, и второй вариант вернёт 'a' как результат.\n\n### HISTOGRAM()\n\n<!-- example histogram -->"
    },
    "is_code_or_comment": false
  }
}
