{
  "d3ffeb9c07763560001112bda882185597c3ce23df71eb46053053261d2ed4cd": {
    "original": "Table functions are a mechanism for post-query result set processing. Table functions take an arbitrary result set as input and return a new, processed set as output. The first argument should be the input result set, but a table function can optionally take and handle more arguments. Table functions can completely change the result set, including the schema. Currently, only built-in table functions are supported. Table functions work for both outer `SELECT` and [nested SELECT](../Searching/Sub-selects.md).\n\n<!-- proofread -->",
    "translations": {
      "chinese": "表函数是一种用于查询后结果集处理的机制。表函数以任意结果集作为输入，并返回一个新的、处理过的结果集作为输出。第一个参数应为输入结果集，但表函数可以选择性地接受和处理更多参数。表函数可以完全改变结果集，包括其模式。目前，仅支持内置表函数。表函数适用于外部 `SELECT` 和[嵌套 SELECT](../Searching/Sub-selects.md)。",
      "russian": "Табличные функции — это механизм обработки набора результатов после выполнения запроса. Табличные функции принимают произвольный набор результатов на вход и возвращают новый, обработанный набор на выход. Первый аргумент должен быть входным набором результатов, но табличная функция может дополнительно принимать и обрабатывать другие аргументы. Табличные функции могут полностью изменить набор результатов, включая схему. В настоящее время поддерживаются только встроенные табличные функции. Табличные функции работают как для внешнего `SELECT`, так и для [вложенного SELECT](../Searching/Sub-selects.md).\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "c1e20bfd9365d2435d55308b96e1b33ae44ecc7a69f017050b67e854e2008653": {
    "original": "# Searching and ranking functions\n\n### BM25A()\n\n`BM25A(k1,b)` returns the exact `BM25A()` value. Requires the `expr` ranker and enabled `index_field_lengths`. Parameters `k1` and `b` must be floats.\n\n### BM25F()\n\n`BM25F(k1, b, {field=weight, ...})` returns the exact `BM25F()` value and requires `index_field_lengths` to be enabled. The `expr` ranker is also necessary. Parameters `k1` and `b` must be floats.\n\n### EXIST()\n\nSubstitutes non-existent columns with default values. It returns either the value of an attribute specified by 'attr-name', or the 'default-value' if that attribute does not exist. STRING or MVA attributes are not supported. This function is useful when searching through multiple tables with different schemas.\n\nCODE_BLOCK_0\n\n### MIN_TOP_SORTVAL()\n\nReturns the sort key value of the worst-ranked element in the current top-N matches if the sort key is a float, and 0 otherwise.\n\n### MIN_TOP_WEIGHT()\n\nReturns the weight of the worst-ranked element in the current top-N matches.\n\n### PACKEDFACTORS()\n\n`PACKEDFACTORS()` can be used in queries to display all calculated weighting factors during matching or to provide a binary attribute for creating a custom ranking UDF. This function only works if the expression ranker is specified and the query is not a full scan; otherwise, it returns an error. `PACKEDFACTORS()` can take an optional argument that disables ATC ranking factor calculation: `PACKEDFACTORS({no_atc=1})`. Calculating ATC significantly slows down query processing, so this option can be useful if you need to see the ranking factors but don't require ATC. `PACKEDFACTORS()` can also output in JSON format: `PACKEDFACTORS({json=1})`. The respective outputs in either key-value pair or JSON format are shown below. (Note that the examples below are wrapped for readability; actual returned values would be single-line.)\n\nCODE_BLOCK_1\n\nCODE_BLOCK_2\n\nThis function can be used to implement custom ranking functions in UDFs, as in:\n\nCODE_BLOCK_3\n\nWhere `CUSTOM_RANK()` is a function implemented in a UDF. It should declare a `SPH_UDF_FACTORS` structure (defined in sphinxudf.h), initialize this structure, unpack the factors into it before usage, and deinitialize it afterwards, as follows:\n\nCODE_BLOCK_4\n\n`PACKEDFACTORS()` data is available at all query stages, not just during the initial matching and ranking pass. This enables another particularly interesting application of `PACKEDFACTORS()`: re-ranking.\n\nIn the example above, we used an expression-based ranker with a dummy expression and sorted the result set by the value computed by our UDF. In other words, we used the UDF to rank all our results. Now, let's assume for the sake of an example that our UDF is extremely expensive to compute, with a throughput of only 10,000 calls per second. If our query matches 1,000,000 documents, we would want to use a much simpler expression to do most of our ranking in order to maintain reasonable performance. Then, we would apply the expensive UDF to only a few top results, say, the top 100 results. In other words, we would build the top 100 results using a simpler ranking function and then re-rank those with a more complex one. This can be done with subselects:\n\nCODE_BLOCK_5\n\nIn this example, the expression-based ranker is called for every matched document to compute `WEIGHT()`, so it gets called 1,000,000 times. However, the UDF computation can be postponed until the outer sort, and it will only be performed for the top 100 matches by `WEIGHT()`, according to the inner limit. This means the UDF will only be called 100 times. Finally, the top 10 matches by UDF value are selected and returned to the application.\n\nFor reference, in a distributed setup, the `PACKEDFACTORS()` data is sent from the agents to the master node in binary format. This makes it technically feasible to implement additional re-ranking passes on the master node if needed.\n\nWhen used in SQL but not called from any UDFs, the result of `PACKEDFACTORS()` is formatted as plain text, which can be used to manually assess the ranking factors. Note that this feature is not currently supported by the Manticore API.\n\n### REMOVE_REPEATS()\n\n`REMOVE_REPEATS ( result_set, column, offset, limit )` - removes repeated adjusted rows with the same 'column' value.\n\nCODE_BLOCK_6\n\nNote that `REMOVE_REPEATS` does not affect `total_found` in the [search query meta info](../Node_info_and_management/SHOW_META.md#SHOW-META).\n\n### WEIGHT()\n\nThe `WEIGHT()` function returns the calculated matching score. If no ordering is specified, the result is sorted in descending order by the score provided by `WEIGHT()`. In this example, we order first by weight and then by an integer attribute.\n\nThe search above performs a simple matching, where all words need to be present. However, we can do more (and this is just a simple example):\n\nCODE_BLOCK_7\n\nHere, we search for four words, but a match can occur even if only three of the four words are found. The search will rank documents containing all words higher.\n\n### ZONESPANLIST()\n\nThe `ZONESPANLIST()` function returns pairs of matched zone spans. Each pair contains the matched zone span identifier, a colon, and the order number of the matched zone span. For example, if a document reads `<emphasis role=\"bold\"><i>text</i> the <i>text</i></emphasis>`, and you query for `'ZONESPAN:(i,b) text'`, then `ZONESPANLIST()` will return the string `\"1:1 1:2 2:1\"`, meaning that the first zone span matched \"text\" in spans 1 and 2, and the second zone span in span 1 only.\n\n### QUERY()\n\n`QUERY()` returns the current search query. `QUERY()` is a postlimit expression and is intended to be used with [SNIPPET()](../Functions/String_functions.md#SNIPPET%28%29).",
    "translations": {
      "chinese": "# 搜索和排序函数\n\n### BM25A()\n\n`BM25A(k1,b)` 返回精确的 `BM25A()` 值。需要 `expr` 排序器并启用 `index_field_lengths`。参数 `k1` 和 `b` 必须是浮点数。\n\n### BM25F()\n\n`BM25F(k1, b, {field=weight, ...})` 返回精确的 `BM25F()` 值，且需要启用 `index_field_lengths`。同样需要 `expr` 排序器。参数 `k1` 和 `b` 必须是浮点数。\n\n### EXIST()\n\n用默认值替代不存在的列。它返回由 'attr-name' 指定的属性值，或者如果该属性不存在，则返回 'default-value'。不支持 STRING 或 MVA 属性。此函数在搜索多个具有不同模式的表时非常有用。\n\nCODE_BLOCK_0\n\n### MIN_TOP_SORTVAL()\n\n如果排序键是浮点数，则返回当前 top-N 匹配中排名最差元素的排序键值，否则返回 0。\n\n### MIN_TOP_WEIGHT()\n\n返回当前 top-N 匹配中排名最差元素的权重。\n\n### PACKEDFACTORS()\n\n`PACKEDFACTORS()` 可用于查询中显示匹配期间计算的所有加权因子，或提供二进制属性以创建自定义排序 UDF。此函数仅在指定表达式排序器且查询不是全扫描时有效，否则返回错误。`PACKEDFACTORS()` 可以接受一个可选参数，禁用 ATC 排序因子计算：`PACKEDFACTORS({no_atc=1})`。计算 ATC 会显著降低查询处理速度，因此如果您需要查看排序因子但不需要 ATC，此选项非常有用。`PACKEDFACTORS()` 还可以输出 JSON 格式：`PACKEDFACTORS({json=1})`。以下分别展示了键值对和 JSON 格式的输出。（注意下面的示例为便于阅读进行了换行；实际返回值为单行。）\n\nCODE_BLOCK_1\n\nCODE_BLOCK_2\n\n此函数可用于在 UDF 中实现自定义排序函数，如下所示：\n\nCODE_BLOCK_3\n\n其中 `CUSTOM_RANK()` 是在 UDF 中实现的函数。它应声明一个 `SPH_UDF_FACTORS` 结构（定义于 sphinxudf.h），初始化该结构，在使用前解包因子到其中，使用后再反初始化，如下所示：\n\nCODE_BLOCK_4\n\n`PACKEDFACTORS()` 数据在所有查询阶段均可用，而不仅限于初始匹配和排序阶段。这使得 `PACKEDFACTORS()` 另一个特别有趣的应用成为可能：重新排序。\n\n在上面的示例中，我们使用了基于表达式的排序器和一个虚拟表达式，并按我们 UDF 计算的值对结果集进行排序。换句话说，我们用 UDF 对所有结果进行排序。现在，假设我们的 UDF 计算非常昂贵，吞吐量仅为每秒 10,000 次调用。如果查询匹配了 1,000,000 个文档，我们希望使用更简单的表达式进行大部分排序，以保持合理的性能。然后，我们只对少数顶级结果（比如前 100 个）应用昂贵的 UDF。换句话说，我们用更简单的排序函数构建前 100 个结果，然后用更复杂的函数重新排序它们。这可以通过子查询实现：\n\nCODE_BLOCK_5\n\n在此示例中，基于表达式的排序器为每个匹配文档调用以计算 `WEIGHT()`，因此调用了 1,000,000 次。然而，UDF 计算可以推迟到外层排序，只对内层限制的前 100 个 `WEIGHT()` 匹配执行。这意味着 UDF 只调用 100 次。最后，按 UDF 值选出前 10 个匹配并返回给应用程序。\n\n作为参考，在分布式设置中，`PACKEDFACTORS()` 数据以二进制格式从代理发送到主节点。这使得在主节点上实现额外的重新排序过程在技术上成为可能（如果需要）。\n\n在 SQL 中使用但未从任何 UDF 调用时，`PACKEDFACTORS()` 的结果格式为纯文本，可用于手动评估排序因子。注意此功能当前不被 Manticore API 支持。\n\n### REMOVE_REPEATS()\n\n`REMOVE_REPEATS ( result_set, column, offset, limit )` - 移除具有相同 'column' 值的重复调整行。\n\nCODE_BLOCK_6\n\n注意，`REMOVE_REPEATS` 不影响 [搜索查询元信息](../Node_info_and_management/SHOW_META.md#SHOW-META)中的 `total_found`。\n\n### WEIGHT()\n\n`WEIGHT()` 函数返回计算出的匹配分数。如果未指定排序，则结果按 `WEIGHT()` 提供的分数降序排序。在此示例中，我们先按权重排序，再按整数属性排序。\n\n上述搜索执行简单匹配，所有词都必须出现。但我们可以做更多（这只是一个简单示例）：\n\nCODE_BLOCK_7\n\n这里，我们搜索四个词，但即使只找到其中三个词也可匹配。包含所有词的文档排名更高。\n\n### ZONESPANLIST()\n\n`ZONESPANLIST()` 函数返回匹配的区域跨度对。每对包含匹配区域跨度标识符、冒号和匹配区域跨度的顺序号。例如，如果文档内容为 `<emphasis role=\"bold\"><i>text</i> the <i>text</i></emphasis>`，且查询为 `'ZONESPAN:(i,b) text'`，则 `ZONESPANLIST()` 返回字符串 `\"1:1 1:2 2:1\"`，表示第一个区域跨度在跨度 1 和 2 中匹配了 \"text\"，第二个区域跨度仅在跨度 1 中匹配。\n\n### QUERY()\n\n`QUERY()` 返回当前搜索查询。`QUERY()` 是一个后限制表达式，旨在与 [SNIPPET()](../Functions/String_functions.md#SNIPPET%28%29) 一起使用。",
      "russian": "# Поисковые и ранжирующие функции\n\n### BM25A()\n\n`BM25A(k1,b)` возвращает точное значение `BM25A()`. Требует ранжировщика `expr` и включённого `index_field_lengths`. Параметры `k1` и `b` должны быть числами с плавающей точкой.\n\n### BM25F()\n\n`BM25F(k1, b, {field=weight, ...})` возвращает точное значение `BM25F()` и требует включённого `index_field_lengths`. Также необходим ранжировщик `expr`. Параметры `k1` и `b` должны быть числами с плавающей точкой.\n\n### EXIST()\n\nЗаменяет несуществующие столбцы значениями по умолчанию. Возвращает либо значение атрибута, указанного в 'attr-name', либо 'default-value', если такой атрибут отсутствует. Атрибуты STRING или MVA не поддерживаются. Эта функция полезна при поиске по нескольким таблицам с разными схемами.\n\nCODE_BLOCK_0\n\n### MIN_TOP_SORTVAL()\n\nВозвращает значение ключа сортировки наихудшего элемента в текущих топ-N совпадениях, если ключ сортировки — число с плавающей точкой, иначе 0.\n\n### MIN_TOP_WEIGHT()\n\nВозвращает вес наихудшего элемента в текущих топ-N совпадениях.\n\n### PACKEDFACTORS()\n\n`PACKEDFACTORS()` можно использовать в запросах для отображения всех вычисленных факторов взвешивания во время сопоставления или для предоставления бинарного атрибута для создания пользовательской функции ранжирования UDF. Эта функция работает только при указании ранжировщика выражений и если запрос не является полным сканированием; в противном случае возвращается ошибка. `PACKEDFACTORS()` может принимать необязательный аргумент, отключающий вычисление фактора ранжирования ATC: `PACKEDFACTORS({no_atc=1})`. Вычисление ATC значительно замедляет обработку запроса, поэтому эта опция полезна, если нужно видеть факторы ранжирования, но ATC не требуется. `PACKEDFACTORS()` также может выводить данные в формате JSON: `PACKEDFACTORS({json=1})`. Соответствующие выводы в формате пар ключ-значение или JSON показаны ниже. (Обратите внимание, что приведённые примеры разбиты для удобства чтения; фактические возвращаемые значения будут в одной строке.)\n\nCODE_BLOCK_1\n\nCODE_BLOCK_2\n\nЭта функция может использоваться для реализации пользовательских функций ранжирования в UDF, например:\n\nCODE_BLOCK_3\n\nГде `CUSTOM_RANK()` — функция, реализованная в UDF. Она должна объявить структуру `SPH_UDF_FACTORS` (определённую в sphinxudf.h), инициализировать эту структуру, распаковать в неё факторы перед использованием и деинициализировать после, следующим образом:\n\nCODE_BLOCK_4\n\nДанные `PACKEDFACTORS()` доступны на всех этапах запроса, а не только во время начального прохода сопоставления и ранжирования. Это открывает ещё одно особенно интересное применение `PACKEDFACTORS()`: повторное ранжирование.\n\nВ приведённом выше примере мы использовали ранжировщик на основе выражений с фиктивным выражением и отсортировали набор результатов по значению, вычисленному нашей UDF. Другими словами, мы использовали UDF для ранжирования всех результатов. Теперь предположим для примера, что наша UDF чрезвычайно затратна в вычислении, с пропускной способностью всего 10 000 вызовов в секунду. Если наш запрос совпадает с 1 000 000 документов, мы хотели бы использовать гораздо более простое выражение для основной части ранжирования, чтобы сохранить разумную производительность. Затем мы применим дорогую UDF только к нескольким лучшим результатам, скажем, к топ-100. Другими словами, мы построим топ-100 результатов с помощью более простой функции ранжирования, а затем повторно отсортируем их с помощью более сложной. Это можно сделать с помощью подзапросов:\n\nCODE_BLOCK_5\n\nВ этом примере ранжировщик на основе выражений вызывается для каждого совпавшего документа для вычисления `WEIGHT()`, поэтому он вызывается 1 000 000 раз. Однако вычисление UDF можно отложить до внешней сортировки, и оно будет выполнено только для топ-100 совпадений по `WEIGHT()`, согласно внутреннему ограничению. Это означает, что UDF будет вызвана всего 100 раз. Наконец, выбираются и возвращаются приложению топ-10 совпадений по значению UDF.\n\nДля справки, в распределённой конфигурации данные `PACKEDFACTORS()` передаются от агентов к мастер-узлу в бинарном формате. Это технически позволяет реализовать дополнительные проходы повторного ранжирования на мастер-узле при необходимости.\n\nПри использовании в SQL, но без вызова из UDF, результат `PACKEDFACTORS()` форматируется как простой текст, который можно использовать для ручной оценки факторов ранжирования. Обратите внимание, что эта функция в настоящее время не поддерживается API Manticore.\n\n### REMOVE_REPEATS()\n\n`REMOVE_REPEATS ( result_set, column, offset, limit )` — удаляет повторяющиеся скорректированные строки с одинаковым значением 'column'.\n\nCODE_BLOCK_6\n\nОбратите внимание, что `REMOVE_REPEATS` не влияет на `total_found` в [метаинформации поискового запроса](../Node_info_and_management/SHOW_META.md#SHOW-META).\n\n### WEIGHT()\n\nФункция `WEIGHT()` возвращает вычисленный балл совпадения. Если порядок не задан, результат сортируется по убыванию балла, возвращаемого `WEIGHT()`. В этом примере мы сначала сортируем по весу, затем по целочисленному атрибуту.\n\nПриведённый выше поиск выполняет простое сопоставление, где все слова должны присутствовать. Однако можно сделать больше (и это всего лишь простой пример):\n\nCODE_BLOCK_7\n\nЗдесь мы ищем четыре слова, но совпадение может произойти, если найдены только три из четырёх слов. Поиск будет ранжировать документы, содержащие все слова, выше.\n\n### ZONESPANLIST()\n\nФункция `ZONESPANLIST()` возвращает пары совпавших зональных интервалов. Каждая пара содержит идентификатор совпавшего зонального интервала, двоеточие и порядковый номер совпавшего зонального интервала. Например, если в документе содержится `<emphasis role=\"bold\"><i>text</i> the <i>text</i></emphasis>`, и вы выполняете запрос `'ZONESPAN:(i,b) text'`, то `ZONESPANLIST()` вернёт строку `\"1:1 1:2 2:1\"`, что означает, что первый зональный интервал совпал со словом \"text\" в интервалах 1 и 2, а второй зональный интервал — только в интервале 1.\n\n### QUERY()\n\n`QUERY()` возвращает текущий поисковый запрос. `QUERY()` является выражением postlimit и предназначена для использования с [SNIPPET()](../Functions/String_functions.md#SNIPPET%28%29)."
    },
    "is_code_or_comment": false
  }
}
