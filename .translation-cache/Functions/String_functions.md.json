{
  "51227758d30af47d1787575b9e5b1a80f3820317269c471f78581eb924eb0a15": {
    "original": "# String functions\n\n### CONCAT()\n\nConcatenates two or more strings into one. Non-string arguments must be explicitly converted to string using the `TO_STRING()` function.\n\nCODE_BLOCK_0\n\n### LEVENSHTEIN()\n\n`LEVENSHTEIN ( pattern, source, {normalize=0, length_delta=0})` returns number (Levenshtein distance) of single-character edits (insertions, deletions or substitutions) between `pattern` and `source` strings required to make in `pattern` to make it `source`.\n\n   * `pattern`, `source` - constant string, string field name, JSON field name, or any expression that produces a string (like e.g., [SUBSTRING_INDEX()](../Functions/String_functions.md#SUBSTRING_INDEX%28%29))\n\n   * `normalize` - option to return the distance as a float number in the range `[0.0 - 1.0]`, where 0.0 is an exact match, and 1.0 is the maximum difference. The default value is 0, meaning not to normalize and provide the result as an integer.\n\n   * `length_delta` - skips Levenshtein distance calculation and returns `max(strlen(pattern), strlen(source))` if the option is set and the lengths of the strings differ by more than the `length_delta` value. The default value is 0, meaning to calculate Levenshtein distance for any input strings. This option can be useful when checking mostly similar strings.\n\nCODE_BLOCK_1\n\n### REGEX()\n\nThe `REGEX(attr,expr)` function returns 1 if a regular expression matches the attribute's string, and 0 otherwise. It works with both string and JSON attributes.\n\nCODE_BLOCK_2\n\nExpressions should adhere to the RE2 syntax. To perform a case-insensitive search, for instance, you can use:\n\nCODE_BLOCK_3\n\n### SNIPPET()\n\nThe `SNIPPET()` function can be used to highlight search results within a given text. The first two arguments are: the text to be highlighted, and a query. [Options](../Searching/Highlighting.md#Highlighting-options) can be passed to the function as the third, fourth, and so on arguments. `SNIPPET()` can obtain the text for highlighting directly from the table. In this case, the first argument should be the field name:\n\nCODE_BLOCK_4\n\nIn this example, the `QUERY()`  expression returns the current full-text query. `SNIPPET()` can also highlight non-indexed text:\n\nCODE_BLOCK_5\n\nAdditionally, it can be used to highlight text fetched from other sources using a User-Defined Function (UDF):\n\nCODE_BLOCK_6\n\nIn this context, `myUdf()` is a User-Defined Function (UDF) that retrieves a document by its ID from an external storage source. The `SNIPPET()` function is considered a \"post limit\" function, which means that the computation of snippets is delayed until the entire final result set is prepared, and even after the `LIMIT` clause has been applied. For instance, if a `LIMIT 20,10` clause is used, `SNIPPET()` will be called no more than 10 times.\n\nIt is important to note that `SNIPPET()` does not support field-based limitations. For this functionality, use [HIGHLIGHT()](../Searching/Highlighting.md#Highlighting-via-SQL) instead.\n\n### SUBSTRING_INDEX()\n\n<!-- example substring_index -->\n\n`SUBSTRING_INDEX(string, delimiter, number)` returns a substring of the original string, based on a specified number of delimiter occurrences:\n\n   *   string - The original string, which can be a constant string or a string from a string/JSON attribute.\n\n   *   delimiter - The delimiter to search for.\n\n   *   number - The number of times to search for the delimiter. This can be either a positive or negative number. If it is a positive number, the function will return everything to the left of the delimiter. If it is a negative number, the function will return everything to the right of the delimiter.\n\n`SUBSTRING_INDEX()` by default returns a string, but it can also be coerced into other types (such as integer or float) if necessary. Numeric values can be converted using specific functions (such as `BIGINT()`, `DOUBLE()`, etc.).\n\n<!-- request SQL -->\n\nCODE_BLOCK_7\n\n<!-- end -->\n\n### UPPER() and LOWER()\n\n`UPPER(string)` convert argument to upper case, `LOWER(string)` convert argument to lower case.\n\nResult also can be promoted to numeric, but only if string argument is convertible to a number. Numeric values could be promoted with arbitrary functions (`BITINT`, `DOUBLE`, etc.).\n\nCODE_BLOCK_8\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 字符串函数\n\n### CONCAT()\n\n将两个或多个字符串连接成一个。非字符串参数必须使用 `TO_STRING()` 函数显式转换为字符串。\n\nCODE_BLOCK_0\n\n### LEVENSHTEIN()\n\n`LEVENSHTEIN ( pattern, source, {normalize=0, length_delta=0})` 返回单字符编辑（插入、删除或替换）次数的数字（Levenshtein 距离），表示将 `pattern` 变为 `source` 所需的编辑次数。\n\n   * `pattern`，`source` - 常量字符串、字符串字段名、JSON 字段名，或任何产生字符串的表达式（例如，[SUBSTRING_INDEX()](../Functions/String_functions.md#SUBSTRING_INDEX%28%29)）\n\n   * `normalize` - 选项，返回一个范围在 `[0.0 - 1.0]` 之间的浮点数距离，其中 0.0 表示完全匹配，1.0 表示最大差异。默认值为 0，表示不归一化，结果为整数。\n\n   * `length_delta` - 如果设置了该选项且字符串长度差异超过 `length_delta`，则跳过 Levenshtein 距离计算，直接返回 `max(strlen(pattern), strlen(source))`。默认值为 0，表示对任何输入字符串都计算 Levenshtein 距离。该选项在检查大致相似字符串时非常有用。\n\nCODE_BLOCK_1\n\n### REGEX()\n\n`REGEX(attr,expr)` 函数如果正则表达式匹配属性字符串，则返回 1，否则返回 0。它适用于字符串和 JSON 属性。\n\nCODE_BLOCK_2\n\n表达式应遵循 RE2 语法。例如，要执行不区分大小写的搜索，可以使用：\n\nCODE_BLOCK_3\n\n### SNIPPET()\n\n`SNIPPET()` 函数可用于突出显示给定文本中的搜索结果。前两个参数是：要高亮的文本和查询。可以将[选项](../Searching/Highlighting.md#Highlighting-options)作为第三个、第四个及后续参数传递给函数。`SNIPPET()` 可以直接从表中获取要高亮的文本。在这种情况下，第一个参数应为字段名：\n\nCODE_BLOCK_4\n\n在此示例中，`QUERY()` 表达式返回当前全文查询。`SNIPPET()` 也可以高亮非索引文本：\n\nCODE_BLOCK_5\n\n此外，它还可以用于高亮通过用户自定义函数（UDF）从其他来源获取的文本：\n\nCODE_BLOCK_6\n\n在此上下文中，`myUdf()` 是一个用户自定义函数（UDF），用于从外部存储源通过 ID 获取文档。`SNIPPET()` 函数被视为“后限制”函数，这意味着片段的计算会延迟到整个最终结果集准备好之后，甚至在应用 `LIMIT` 子句之后。例如，如果使用 `LIMIT 20,10` 子句，`SNIPPET()` 最多会被调用 10 次。\n\n需要注意的是，`SNIPPET()` 不支持基于字段的限制。若需此功能，请使用 [HIGHLIGHT()](../Searching/Highlighting.md#Highlighting-via-SQL)。\n\n### SUBSTRING_INDEX()\n\n<!-- example substring_index -->\n\n`SUBSTRING_INDEX(string, delimiter, number)` 根据指定的分隔符出现次数返回原字符串的子串：\n\n   *   string - 原始字符串，可以是常量字符串或字符串/JSON 属性中的字符串。\n\n   *   delimiter - 要搜索的分隔符。\n\n   *   number - 搜索分隔符的次数。可以是正数或负数。若为正数，函数返回分隔符左侧的所有内容；若为负数，函数返回分隔符右侧的所有内容。\n\n`SUBSTRING_INDEX()` 默认返回字符串，但如果需要，也可以强制转换为其他类型（如整数或浮点数）。数值可以通过特定函数（如 `BIGINT()`、`DOUBLE()` 等）转换。\n\n<!-- request SQL -->\n\nCODE_BLOCK_7\n\n<!-- end -->\n\n### UPPER() 和 LOWER()\n\n`UPPER(string)` 将参数转换为大写，`LOWER(string)` 将参数转换为小写。\n\n结果也可以提升为数值，但仅当字符串参数可转换为数字时。数值可以通过任意函数（`BITINT`、`DOUBLE` 等）提升。\n\nCODE_BLOCK_8\n\n<!-- proofread -->",
      "russian": "# Функции строк\n\n### CONCAT()\n\nОбъединяет две или более строк в одну. Аргументы, не являющиеся строками, должны быть явно преобразованы в строку с помощью функции `TO_STRING()`.\n\nCODE_BLOCK_0\n\n### LEVENSHTEIN()\n\n`LEVENSHTEIN ( pattern, source, {normalize=0, length_delta=0})` возвращает число (расстояние Левенштейна) односимвольных изменений (вставок, удалений или замен) между строками `pattern` и `source`, необходимых для преобразования `pattern` в `source`.\n\n   * `pattern`, `source` - константная строка, имя строкового поля, имя JSON-поля или любое выражение, которое возвращает строку (например, [SUBSTRING_INDEX()](../Functions/String_functions.md#SUBSTRING_INDEX%28%29))\n\n   * `normalize` - опция для возврата расстояния в виде числа с плавающей точкой в диапазоне `[0.0 - 1.0]`, где 0.0 — точное совпадение, а 1.0 — максимальное различие. Значение по умолчанию 0, что означает отсутствие нормализации и возврат результата в виде целого числа.\n\n   * `length_delta` - пропускает вычисление расстояния Левенштейна и возвращает `max(strlen(pattern), strlen(source))`, если опция установлена и длины строк отличаются более чем на значение `length_delta`. Значение по умолчанию 0, что означает вычисление расстояния Левенштейна для любых входных строк. Эта опция может быть полезна при проверке преимущественно похожих строк.\n\nCODE_BLOCK_1\n\n### REGEX()\n\nФункция `REGEX(attr,expr)` возвращает 1, если регулярное выражение совпадает со строкой атрибута, и 0 в противном случае. Работает как со строковыми, так и с JSON-атрибутами.\n\nCODE_BLOCK_2\n\nВыражения должны соответствовать синтаксису RE2. Для выполнения поиска без учета регистра, например, можно использовать:\n\nCODE_BLOCK_3\n\n### SNIPPET()\n\nФункция `SNIPPET()` может использоваться для выделения результатов поиска в заданном тексте. Первые два аргумента: текст для выделения и запрос. [Опции](../Searching/Highlighting.md#Highlighting-options) могут передаваться функции в качестве третьего, четвертого и последующих аргументов. `SNIPPET()` может получать текст для выделения непосредственно из таблицы. В этом случае первым аргументом должно быть имя поля:\n\nCODE_BLOCK_4\n\nВ этом примере выражение `QUERY()` возвращает текущий полнотекстовый запрос. `SNIPPET()` также может выделять неиндексированный текст:\n\nCODE_BLOCK_5\n\nКроме того, она может использоваться для выделения текста, полученного из других источников с помощью функции, определенной пользователем (UDF):\n\nCODE_BLOCK_6\n\nВ данном контексте `myUdf()` — это функция, определенная пользователем (UDF), которая извлекает документ по его ID из внешнего источника хранения. Функция `SNIPPET()` считается функцией \"post limit\", что означает, что вычисление сниппетов откладывается до подготовки всего итогового набора результатов, даже после применения оператора `LIMIT`. Например, если используется оператор `LIMIT 20,10`, `SNIPPET()` будет вызвана не более 10 раз.\n\nВажно отметить, что `SNIPPET()` не поддерживает ограничения по полям. Для этой функциональности используйте [HIGHLIGHT()](../Searching/Highlighting.md#Highlighting-via-SQL).\n\n### SUBSTRING_INDEX()\n\n<!-- example substring_index -->\n\n`SUBSTRING_INDEX(string, delimiter, number)` возвращает подстроку исходной строки, основанную на указанном количестве вхождений разделителя:\n\n   *   string - исходная строка, которая может быть константной строкой или строкой из строкового/JSON-атрибута.\n\n   *   delimiter - разделитель для поиска.\n\n   *   number - количество раз для поиска разделителя. Может быть положительным или отрицательным числом. Если число положительное, функция вернет все слева от разделителя. Если отрицательное — все справа от разделителя.\n\nПо умолчанию `SUBSTRING_INDEX()` возвращает строку, но при необходимости может быть приведена к другим типам (например, целому или числу с плавающей точкой). Числовые значения можно преобразовать с помощью специальных функций (например, `BIGINT()`, `DOUBLE()` и т.д.).\n\n<!-- request SQL -->\n\nCODE_BLOCK_7\n\n<!-- end -->\n\n### UPPER() и LOWER()\n\n`UPPER(string)` преобразует аргумент в верхний регистр, `LOWER(string)` преобразует аргумент в нижний регистр.\n\nРезультат также может быть преобразован в числовой тип, но только если строковый аргумент можно преобразовать в число. Числовые значения могут быть преобразованы с помощью произвольных функций (`BITINT`, `DOUBLE` и т.д.).\n\nCODE_BLOCK_8\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
