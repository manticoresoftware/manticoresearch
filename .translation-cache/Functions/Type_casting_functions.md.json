{
  "d333cc8327f74628512784a0935877ec9506ebc82d42d42293a95a297fc0cb46": {
    "original": "# Type Casting Functions\n\nType casting comprises three principal actions: conversion, reinterpretation, and promotion.\n\n* **Conversion**. This refers to the process of changing the data type of a value to another data type. This involves additional computations and is exclusively performed by the `TO_STRING()` function.\n\n* **Reinterpretation**. This involves treating the binary data representing a value as if it were of a different data type, without actually changing the underlying data. This is handled by `SINT()`, doesn't involve extra computations; instead, it merely reinterprets existing data.\n\n* **Promotion**. This refers to the process of converting a value to a \"larger\" or more precise data type. It doesn't require extra computation either; it merely requests the argument to deliver a value of a different type. Only JSON fields and a few other functions can promote their values to integers. If an argument cannot yield a value of a different type, the promotion will fail. For instance, the `TIMEDIFF()` function usually returns a string, but can also return a number. So, `BIGINT(TIMEDIFF(1,2))` will execute successfully, compelling `TIMEDIFF()` to supply an integer value. Conversely, `DATE_FORMAT()` solely returns strings and can't yield a number, meaning that `BIGINT(DATE_FORMAT(...))` will fail.\n\n### BIGINT()\n\nThis function promotes an integer argument to a 64-bit type, leaving floating-point arguments untouched. It's designed to ensure the evaluation of specific expressions (such as `a*b`) in 64-bit mode, even if all arguments are 32-bit.\n\n### DOUBLE()\n\nThe `DOUBLE()` function promotes its argument to a floating-point type. This is designed to help enforce the evaluation of numeric JSON fields.\n\n### INTEGER()\n\nThe `INTEGER()` function promotes its argument to a 64-bit signed type. This is designed to enforce the evaluation of numeric JSON fields.\n\n### TO_STRING()\n\nThis function forcefully converts its argument to a string type.\n\n### UINT()\n\nThe `UINT()` function promotes its argument to a 32-bit unsigned integer type.\n\n### UINT64()\n\nThe `UINT64()` function promotes its argument to a 64-bit unsigned integer type.\n\n### SINT()\n\nThe `SINT()` function forcefully reinterprets its 32-bit unsigned integer argument as signed and extends it to a 64-bit type (since the 32-bit type is unsigned). For instance, 1-2 ordinarily evaluates to 4294967295, but `SINT(1-2)` evaluates to -1.\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 类型转换函数\n\n类型转换包括三个主要操作：转换、重新解释和提升。\n\n* **转换**。指将一个值的数据类型更改为另一种数据类型的过程。这涉及额外的计算，仅由 `TO_STRING()` 函数执行。\n\n* **重新解释**。指将表示一个值的二进制数据视为另一种数据类型，而不实际更改底层数据。由 `SINT()` 处理，不涉及额外计算；它只是重新解释现有数据。\n\n* **提升**。指将一个值转换为“更大”或更精确的数据类型的过程。它也不需要额外计算；它只是请求参数提供不同类型的值。只有 JSON 字段和少数其他函数可以将其值提升为整数。如果参数无法产生不同类型的值，提升将失败。例如，`TIMEDIFF()` 函数通常返回字符串，但也可以返回数字。因此，`BIGINT(TIMEDIFF(1,2))` 会成功执行，强制 `TIMEDIFF()` 提供整数值。相反，`DATE_FORMAT()` 仅返回字符串，不能产生数字，这意味着 `BIGINT(DATE_FORMAT(...))` 会失败。\n\n### BIGINT()\n\n此函数将整数参数提升为 64 位类型，浮点参数保持不变。它旨在确保特定表达式（如 `a*b`）以 64 位模式计算，即使所有参数都是 32 位。\n\n### DOUBLE()\n\n`DOUBLE()` 函数将其参数提升为浮点类型。此设计用于强制计算数值 JSON 字段。\n\n### INTEGER()\n\n`INTEGER()` 函数将其参数提升为 64 位有符号类型。此设计用于强制计算数值 JSON 字段。\n\n### TO_STRING()\n\n此函数强制将其参数转换为字符串类型。\n\n### UINT()\n\n`UINT()` 函数将其参数提升为 32 位无符号整数类型。\n\n### UINT64()\n\n`UINT64()` 函数将其参数提升为 64 位无符号整数类型。\n\n### SINT()\n\n`SINT()` 函数强制将其 32 位无符号整数参数重新解释为有符号，并扩展为 64 位类型（因为 32 位类型是无符号的）。例如，1-2 通常计算为 4294967295，但 `SINT(1-2)` 计算为 -1。\n\n<!-- proofread -->",
      "russian": "# Функции приведения типов\n\nПриведение типов включает три основных действия: преобразование, переинтерпретацию и продвижение.\n\n* **Преобразование**. Это процесс изменения типа данных значения на другой тип данных. Это требует дополнительных вычислений и выполняется исключительно функцией `TO_STRING()`.\n\n* **Переинтерпретация**. Это означает обработку двоичных данных, представляющих значение, как если бы они были другого типа данных, без фактического изменения исходных данных. Это выполняется функцией `SINT()`, не требует дополнительных вычислений; вместо этого просто переинтерпретирует существующие данные.\n\n* **Продвижение**. Это процесс преобразования значения в \"больший\" или более точный тип данных. Это также не требует дополнительных вычислений; просто запрашивает у аргумента выдачу значения другого типа. Только JSON-поля и несколько других функций могут продвигать свои значения к целым числам. Если аргумент не может выдать значение другого типа, продвижение завершится неудачей. Например, функция `TIMEDIFF()` обычно возвращает строку, но может также возвращать число. Поэтому `BIGINT(TIMEDIFF(1,2))` выполнится успешно, заставляя `TIMEDIFF()` выдавать целочисленное значение. Напротив, `DATE_FORMAT()` возвращает только строки и не может выдать число, значит `BIGINT(DATE_FORMAT(...))` завершится неудачей.\n\n### BIGINT()\n\nЭта функция продвигает целочисленный аргумент к 64-битному типу, оставляя аргументы с плавающей точкой без изменений. Она предназначена для обеспечения вычисления определённых выражений (например, `a*b`) в 64-битном режиме, даже если все аргументы 32-битные.\n\n### DOUBLE()\n\nФункция `DOUBLE()` продвигает свой аргумент к типу с плавающей точкой. Это предназначено для принудительного вычисления числовых JSON-полей.\n\n### INTEGER()\n\nФункция `INTEGER()` продвигает свой аргумент к 64-битному знаковому типу. Это предназначено для принудительного вычисления числовых JSON-полей.\n\n### TO_STRING()\n\nЭта функция принудительно преобразует свой аргумент к строковому типу.\n\n### UINT()\n\nФункция `UINT()` продвигает свой аргумент к 32-битному беззнаковому целочисленному типу.\n\n### UINT64()\n\nФункция `UINT64()` продвигает свой аргумент к 64-битному беззнаковому целочисленному типу.\n\n### SINT()\n\nФункция `SINT()` принудительно переинтерпретирует свой 32-битный беззнаковый целочисленный аргумент как знаковый и расширяет его до 64-битного типа (поскольку 32-битный тип беззнаковый). Например, выражение 1-2 обычно вычисляется как 4294967295, но `SINT(1-2)` вычисляется как -1.\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
