{
  "cf29f00630d4577af7238043cd21c480fdd66cf5453f095add8ff167b60db1ff": {
    "original": "- Single-config needs the build type provided during configuration, via the `CMAKE_BUILD_TYPE` parameter. If it is not defined, the build will fall back to the `RelWithDebInfo` type which is suitable if you just want to build Manticore from sources and not participate in development. For explicit builds, you should provide a build type, like `-DCMAKE_BUILD_TYPE=Debug`.\n\n- Multi-config selects the build type during the build. It should be provided with the `--config` option, otherwise it will build a kind of `noconfig`, which is not desirable. So, you should always specify the build type, like `--config Debug`.\n\nIf you want to specify the build type but don't want to care about whether it is a 'single' or 'multi' config generator - just provide the necessary keys in both places. I.e., configure with `-DCMAKE_BUILD_TYPE=Debug`, and then build with `--config Debug`. Just be sure that both values are the same. If the target builder is a single-config, it will consume the configuration param. If it is multi-config, the configuration param will be ignored, but the correct build configuration will be selected by the `--config` key.\n\nIf you want `RelWithDebInfo` (i.e. just build for production) and know you're on a single-config platform (that is all, except Windows) - you can omit the `--config` flag on the cmake invocation. The default `CMAKE_BUILD_TYPE=RelWithDebInfo` will be configured then, and used. All the commands for 'building', 'installation' and 'building package' will become shorter then.\n\n#### Explicitly select build system generators\n\nCmake is the tool that doesn't perform building by itself, but it generates rules for the local build system.\n\nUsually, it determines the available build system well, but sometimes you might need to provide a generator explicitly. You\n\ncan run `cmake -G` and review the list of available generators.\n\n- On Windows, if you have more than one version of Visual Studio installed, you might need to specify which one to use,\n\nas:\n\nCODE_BLOCK_14\n\n  cmake -GNinja ...\n\n  ```\n\n  or\n\nCODE_BLOCK_15\n\nNinja Multi-Config is quite useful as it is really 'multi-config' and available on Linux/macOS/BSD. With this generator, you may shift the choosing of configuration type to build time, and also you may build several configurations in one and the same build folder, changing only the  `--config` param.\n\n### Caveats\n\n1. If you want to finally build a full-featured RPM package, the path to the build directory must be long enough in order to correctly build debug symbols.\n\nLike `/manticore012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789`, for example. That is because RPM tools modify the path over compiled binaries when building debug info, and it can just write over existing room and won't allocate more. The aforementioned long path has 100 chars and that is quite enough for such a case.\n\n## External dependencies\n\nSome libraries should be available if you want to use them.\n\n- For indexing (`indexer` tool): `expat`, `iconv`, `mysql`, `odbc`, `postgresql`. Without them, you can only process `tsv` and `csv` sources.\n\n- For serving queries (`searchd` daemon): `openssl` might be necessary.\n\n- For all (required, mandatory!) we need the Boost library. The minimal version is 1.61.0, however, we build the binaries with a fresher version 1.75.0. Even more recent versions (like 1.76) should also be okay. On Windows, you can download pre-built Boost from their site (boost.org) and install it into the default suggested path (i.e. `C:\\\\boost...`). On MacOs, the one provided in brew is okay. On Linux, you can check the available version in official repositories, and if it doesn't match requirements, you can build from sources. We need the component 'context', you can also build components 'system' and 'program_options', they will be necessary if you also want to build Galera library from the sources. Look into `dist/build_dockers/xxx/boost_175/Dockerfile` for a short self-documented script/instruction on how to do it.\n\nOn the build system, you need the 'dev' or 'devel' versions of these packages installed (i.e. - libmysqlclient-devel, unixodbc-devel, etc. Look to our dockerfiles for the names of concrete packages).\n\nOn run systems, these packages should be present at least in the final (non-dev) variants. (devel variants usually larger, as they include not only target binaries, but also different development stuff like include headers, etc.).\n\n### Building on Windows\n\nApart from necessary prerequisites, you might need prebuilt `expat`, `iconv`, `mysql`, and `postgresql` client libraries. You have to either build them yourself or contact us to get our build bundle (a simple zip archive where the folder with these targets is located).\n\n- ODBC is not necessary as it is a system library.\n\n- OpenSSL might be built from sources or downloaded prebuilt from https://slproweb.com/products/Win32OpenSSL.html (as mentioned in the cmake internal script on FindOpenSSL).\n\n- Boost might be downloaded pre-built from https://www.boost.org/ releases.\n\n### See what is compiled\n\nRun `indexer -h`. It will show which features were configured and built (whether they're explicit or investigated, doesn't matter):\n\nCODE_BLOCK_16\n\n<!-- proofread -->",
    "translations": {
      "chinese": "- 单配置需要在配置期间通过 `CMAKE_BUILD_TYPE` 参数提供构建类型。如果未定义，构建将回退到 `RelWithDebInfo` 类型，这适用于仅从源代码构建 Manticore 而不参与开发的情况。对于显式构建，您应提供构建类型，例如 `-DCMAKE_BUILD_TYPE=Debug`。\n\n- 多配置在构建期间选择构建类型。应通过 `--config` 选项提供，否则将构建一种 `noconfig`，这是不理想的。因此，您应始终指定构建类型，例如 `--config Debug`。\n\n如果您想指定构建类型，但不想关心它是“单配置”还是“多配置”生成器——只需在两个地方都提供必要的键。即，使用 `-DCMAKE_BUILD_TYPE=Debug` 进行配置，然后使用 `--config Debug` 进行构建。只要确保两个值相同即可。如果目标构建器是单配置，它将使用配置参数。如果是多配置，配置参数将被忽略，但正确的构建配置将由 `--config` 键选择。\n\n如果您想要 `RelWithDebInfo`（即仅为生产构建）并且知道您处于单配置平台（除 Windows 外的所有平台）——您可以在 cmake 调用时省略 `--config` 标志。默认的 `CMAKE_BUILD_TYPE=RelWithDebInfo` 将被配置并使用。所有“构建”、“安装”和“构建包”的命令将因此变得更简短。\n\n#### 显式选择构建系统生成器\n\nCmake 是一个本身不执行构建的工具，但它为本地构建系统生成规则。\n\n通常，它能很好地确定可用的构建系统，但有时您可能需要显式提供生成器。您可以运行 `cmake -G` 并查看可用生成器列表。\n\n- 在 Windows 上，如果您安装了多个版本的 Visual Studio，您可能需要指定使用哪一个，如：\n\nCODE_BLOCK_14\n\n  cmake -GNinja ...\n\n  ```\n\n  或者\n\nCODE_BLOCK_15\n\nNinja 多配置非常有用，因为它是真正的“多配置”，并且在 Linux/macOS/BSD 上可用。使用此生成器，您可以将配置类型的选择推迟到构建时，并且可以在同一个构建文件夹中构建多个配置，只需更改 `--config` 参数。\n\n### 注意事项\n\n1. 如果您最终想构建一个功能完整的 RPM 包，构建目录的路径必须足够长，以便正确构建调试符号。\n\n例如 `/manticore012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789`。这是因为 RPM 工具在构建调试信息时会修改编译二进制文件的路径，它可能会覆盖现有空间而不会分配更多空间。上述长路径有 100 个字符，这对于这种情况来说足够了。\n\n## 外部依赖\n\n如果您想使用某些库，它们应该是可用的。\n\n- 用于索引（`indexer` 工具）：`expat`、`iconv`、`mysql`、`odbc`、`postgresql`。没有它们，您只能处理 `tsv` 和 `csv` 源。\n\n- 用于服务查询（`searchd` 守护进程）：可能需要 `openssl`。\n\n- 对于所有（必需的，强制性的！）我们需要 Boost 库。最低版本是 1.61.0，然而，我们使用更新的 1.75.0 版本构建二进制文件。更高版本（如 1.76）也应该可以。在 Windows 上，您可以从其网站（boost.org）下载预编译的 Boost 并安装到默认建议路径（即 `C:\\\\boost...`）。在 MacOS 上，brew 提供的版本是可以的。在 Linux 上，您可以检查官方仓库中的可用版本，如果不符合要求，可以从源代码构建。我们需要组件 'context'，如果您还想从源代码构建 Galera 库，也可以构建组件 'system' 和 'program_options'。请查看 `dist/build_dockers/xxx/boost_175/Dockerfile`，那里有一个简短的自述脚本/说明，介绍如何操作。\n\n在构建系统上，您需要安装这些包的 'dev' 或 'devel' 版本（例如 libmysqlclient-devel、unixodbc-devel 等。具体包名请查看我们的 dockerfiles）。\n\n在运行系统上，这些包至少应以最终（非开发）版本存在。（devel 版本通常更大，因为它们不仅包含目标二进制文件，还包括不同的开发内容，如头文件等）。\n\n### 在 Windows 上构建\n\n除了必要的前置条件外，您可能需要预编译的 `expat`、`iconv`、`mysql` 和 `postgresql` 客户端库。您必须自己构建它们，或者联系我们获取我们的构建包（一个简单的 zip 压缩包，其中包含这些目标的文件夹）。\n\n- ODBC 不是必需的，因为它是系统库。\n\n- OpenSSL 可以从源代码构建，或者从 https://slproweb.com/products/Win32OpenSSL.html 下载预编译版本（如 cmake 内部脚本 FindOpenSSL 中所述）。\n\n- Boost 可以从 https://www.boost.org/ 下载预编译版本。\n\n### 查看已编译内容\n\n运行 `indexer -h`。它将显示哪些功能已配置和构建（无论是显式的还是自动检测的，都无关紧要）：\n\nCODE_BLOCK_16\n\n<!-- proofread -->",
      "russian": "- Single-config требует указания типа сборки во время конфигурации через параметр `CMAKE_BUILD_TYPE`. Если он не определён, сборка по умолчанию будет использовать тип `RelWithDebInfo`, что подходит, если вы просто хотите собрать Manticore из исходников и не участвовать в разработке. Для явных сборок следует указать тип сборки, например `-DCMAKE_BUILD_TYPE=Debug`.\n\n- Multi-config выбирает тип сборки во время сборки. Его следует указывать с помощью опции `--config`, иначе будет собрана некая конфигурация `noconfig`, что нежелательно. Поэтому всегда указывайте тип сборки, например `--config Debug`.\n\nЕсли вы хотите указать тип сборки, но не хотите заботиться о том, является ли генератор 'single' или 'multi' конфигурацией — просто укажите необходимые ключи в обоих местах. Т.е. конфигурируйте с `-DCMAKE_BUILD_TYPE=Debug`, а затем собирайте с `--config Debug`. Главное, чтобы оба значения совпадали. Если целевой билд-системой является single-config, она использует параметр конфигурации. Если multi-config, параметр конфигурации игнорируется, но правильная конфигурация сборки выбирается по ключу `--config`.\n\nЕсли вы хотите `RelWithDebInfo` (т.е. просто сборку для продакшена) и знаете, что находитесь на платформе с single-config (то есть на всех, кроме Windows) — можно опустить флаг `--config` при вызове cmake. Тогда будет настроен и использован параметр по умолчанию `CMAKE_BUILD_TYPE=RelWithDebInfo`. Все команды для 'сборки', 'установки' и 'сборки пакета' станут короче.\n\n#### Явный выбор генераторов системы сборки\n\nCmake — это инструмент, который сам по себе не выполняет сборку, а генерирует правила для локальной системы сборки.\n\nОбычно он хорошо определяет доступную систему сборки, но иногда может потребоваться явно указать генератор. Вы\n\nможете запустить `cmake -G` и просмотреть список доступных генераторов.\n\n- На Windows, если у вас установлено несколько версий Visual Studio, возможно, потребуется указать, какую использовать,\n\nнапример:\n\nCODE_BLOCK_14\n\n  cmake -GNinja ...\n\n  ```\n\n  или\n\nCODE_BLOCK_15\n\nNinja Multi-Config весьма полезен, так как действительно является 'multi-config' и доступен на Linux/macOS/BSD. С этим генератором вы можете отложить выбор типа конфигурации до времени сборки, а также собирать несколько конфигураций в одной и той же папке сборки, меняя только параметр `--config`.\n\n### Особенности\n\n1. Если вы хотите в итоге собрать полнофункциональный RPM-пакет, путь к директории сборки должен быть достаточно длинным для корректной сборки отладочных символов.\n\nНапример, `/manticore012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789`. Это связано с тем, что инструменты RPM модифицируют путь к скомпилированным бинарникам при сборке отладочной информации, и они могут просто перезаписать существующее место, не выделяя дополнительное. Указанный длинный путь содержит 100 символов, чего достаточно для такого случая.\n\n## Внешние зависимости\n\nНекоторые библиотеки должны быть доступны, если вы хотите их использовать.\n\n- Для индексирования (инструмент `indexer`): `expat`, `iconv`, `mysql`, `odbc`, `postgresql`. Без них можно обрабатывать только источники `tsv` и `csv`.\n\n- Для обслуживания запросов (демон `searchd`): может потребоваться `openssl`.\n\n- Для всех (обязательно!) нужна библиотека Boost. Минимальная версия — 1.61.0, однако мы собираем бинарники с более свежей версией 1.75.0. Ещё более новые версии (например, 1.76) тоже должны подойти. На Windows можно скачать предсобранный Boost с их сайта (boost.org) и установить в путь по умолчанию (т.е. `C:\\\\boost...`). На MacOs версия из brew подходит. На Linux можно проверить доступную версию в официальных репозиториях, и если она не соответствует требованиям, собрать из исходников. Нам нужен компонент 'context', можно также собрать компоненты 'system' и 'program_options', они понадобятся, если вы хотите собрать библиотеку Galera из исходников. Посмотрите в `dist/build_dockers/xxx/boost_175/Dockerfile` для краткого самодокументированного скрипта/инструкции, как это сделать.\n\nНа системе сборки должны быть установлены 'dev' или 'devel' версии этих пакетов (например, libmysqlclient-devel, unixodbc-devel и т.д. Названия конкретных пакетов смотрите в наших докерфайлах).\n\nНа системах запуска эти пакеты должны присутствовать хотя бы в финальных (не dev) вариантах. (devel варианты обычно больше, так как включают не только целевые бинарники, но и различные средства разработки, такие как заголовочные файлы и т.п.).\n\n### Сборка на Windows\n\nПомимо необходимых предварительных условий, вам могут понадобиться предсобранные клиентские библиотеки `expat`, `iconv`, `mysql` и `postgresql`. Их нужно либо собрать самостоятельно, либо связаться с нами, чтобы получить наш сборочный пакет (простой zip-архив, где находится папка с этими целями).\n\n- ODBC не обязателен, так как это системная библиотека.\n\n- OpenSSL можно собрать из исходников или скачать предсобранный с https://slproweb.com/products/Win32OpenSSL.html (как указано во внутреннем скрипте cmake FindOpenSSL).\n\n- Boost можно скачать предсобранный с https://www.boost.org/ releases.\n\n### Посмотреть, что собрано\n\nЗапустите `indexer -h`. Он покажет, какие функции были настроены и собраны (явные или обнаруженные — неважно):\n\nCODE_BLOCK_16\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "b5ddbd46858f88b65cdc95dc12efb27c68ee052d1eeab054b3a9bc9fca858635": {
    "original": "To disable it, use `-DFOO=0`. If not explicitly noted, enabling a feature that is not available((such as `WITH_GALERA` on an MS Windows build)) will cause the configuration to fail with an error. Disabling a feature, apart from excluding it from the build, also disables its investigation on the system and disables the downloading/building of any related external libraries.\n\n#### Configuration flags and options\n\n- **USE_SYSLOG** - allows the use of`syslog` in [query logging](../Logging/Query_logging.md).\n\n- **WITH_GALERA** -Enables support for replication on the search daemon. Support will be configured for the build, and the sources for the Galera library will be downloaded, built, and included in the distribution/installation. Usually, it is safe to build with Galera, but not distribute the library itself (so no Galera module, no replication). However, sometimes you may need to explicitly disable it, such as if you want to build a static binary that by design cannot load any libraries, so that even the presence of a call to the 'dlopen' function inside the daemon will cause a link error.\n\n- **WITH_RE2** - Builds with the use of the RE2 regular expression library. This is necessary for functions like [REGEX()](../Functions/String_functions.md#REGEX%28%29), and the [regexp_filter](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#regexp_filter)\n\n  feature.\n\n- **WITH_RE2_FORCE_STATIC** - Downloads the sources of RE2, compiles them, and links them statically, so that the final binaries will not depend on the presence of a shared  `RE2` library in your system.\n\n- **WITH_STEMMER** - Builds with the use of the Snowball stemming library.\n\n- **WITH_STEMMER_FORCE_STATIC** - Downloads the Snowball sources, compiles them, and links them statically, so that the final binaries will not depend on the presence of a shared  `libstemmer` library in your system.\n\n- **WITH_ICU** -  Builds with the ICU (International Components for Unicode) library. It is used for segmenting Chinese text. It is utilized when morphology=`icu_chinese` is used.\n\n- **WITH_JIEBA** -  Builds with the Jieba Chinese text segmentation tool. It is used for segmenting Chinese text. It is utilized when morphology=`jieba_chinese` is used.\n\n- **WITH_ICU_FORCE_STATIC** - Downloads the ICU sources, compiles them, and links them statically, so that the final binaries will not depend on the presence of a shared `icu` library in your system. Also includes the ICU data file into the installation/distribution. The purpose of a statically linked ICU is to have a library of a known version, so that behavior is determined and not dependent on any system libraries. You will most likely prefer to use the system ICU instead, as it may be updated over time without the need to recompile the Manticore daemon. In this case, you need to explicitly disable this option. This will also save you some space occupied by the ICU data file (about 30M), as it will not be included in the distribution.\n\n- **WITH_SSL** - Used for support for HTTPS, and also encrypted MySQL connections to the daemon. The system OpenSSL library will be linked to the daemon. This implies that OpenSSL will be required to start the daemon. This is mandatory for support for HTTPS, but not strictly mandatory for the server (i.e. no SSL means no possibility to connect via HTTPS, but other protocols will work). SSL library versions starting from 1.0.2 to 1.1.1 may be used by Manticore,  however note that **for the sake of security it's highly recommended to use the freshest possible SSL\n\n  library**. For now only v1.1.1 is supported, the rest are outdated (\n\n  see [openssl release strategy](https://www.openssl.org/policies/releasestrat.html)\n\n- **WITH_ZLIB** - used by the indexer to work with compressed columns from MySQL. Used by the daemon to provide support for the compressed MySQL protocol.\n\n- **WITH_ODBC** - used by the indexer to support indexing sources from ODBC providers (they're typically UnixODBC and iODBC). On MS Windows, ODBC is the proper way to work with MS SQL sources, so indexing of `MSSQL` also implies this flag.\n\n- **DL_ODBC** - don't link with the ODBC library. If ODBC is linked, but not available, you can't start indexer tool even if you want to process something not related to ODBC. This option asks the indexer to load the library at runtime only when you want to deal with ODBC source.\n\n- **ODBC_LIB** - name of the ODBC library file. The indexer will try to load that file when you want to process ODBC source. This option is written automatically from available ODBC shared library investigation. You can also override that name at runtime by providing the environment variable `ODBC_LIB` with the proper path to an alternative library before running the indexer.\n\n- **WITH_EXPAT** - used by the indexer to support indexing xmlpipe sources.\n\n- **DL_EXPAT** - don't link with the EXPAT library. If EXPAT is linked, but not available, you can't start `indexer` tool even if you want to process something not related to xmlpipe. This option asks the indexer to load the library at runtime only when you want to deal with xmlpipe source.\n\n- **EXPAT_LIB** - name of the EXPAT library file. The indexer will try to load that file when you want to process xmlpipe source. This option is written automatically from available EXPAT shared library investigation. You can also override that name at runtime by providing the environment variable EXPAT_LIB with the proper path to an alternative library before running the indexer.\n\n- **WITH_ICONV** - for support different encodings when indexing xmlpipe sources with the indexer.\n\n- **DL_ICONV** - don't link with the iconv library. If iconv is linked, but not available, you can't start `indexer` tool even if you want to process something not related to xmlpipe. This option asks the indexer to load the library at runtime only when you want to deal with xmlpipe source.",
    "translations": {
      "chinese": "要禁用它，请使用 `-DFOO=0`。如果没有明确说明，启用不可用的功能（例如 MS Windows 构建上的 `WITH_GALERA`）将导致配置失败并报错。禁用功能，除了将其排除在构建之外，还会禁用对系统的检测，并禁用任何相关外部库的下载/构建。\n\n#### 配置标志和选项\n\n- **USE_SYSLOG** - 允许在[查询日志](../Logging/Query_logging.md)中使用 `syslog`。\n\n- **WITH_GALERA** - 启用搜索守护进程上的复制支持。构建时将配置支持，并下载、构建 Galera 库的源代码，并将其包含在发行版/安装中。通常，构建时启用 Galera 是安全的，但不分发库本身（因此没有 Galera 模块，也没有复制）。但是，有时您可能需要显式禁用它，例如如果您想构建一个设计上不能加载任何库的静态二进制文件，以至于即使守护进程内部存在对 'dlopen' 函数的调用也会导致链接错误。\n\n- **WITH_RE2** - 使用 RE2 正则表达式库进行构建。这对于像 [REGEX()](../Functions/String_functions.md#REGEX%28%29) 和 [regexp_filter](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#regexp_filter) 功能是必要的。\n\n- **WITH_RE2_FORCE_STATIC** - 下载 RE2 源代码，编译并静态链接它们，使最终的二进制文件不依赖系统中共享的 `RE2` 库。\n\n- **WITH_STEMMER** - 使用 Snowball 词干提取库进行构建。\n\n- **WITH_STEMMER_FORCE_STATIC** - 下载 Snowball 源代码，编译并静态链接它们，使最终的二进制文件不依赖系统中共享的 `libstemmer` 库。\n\n- **WITH_ICU** - 使用 ICU（国际Unicode组件）库进行构建。它用于中文文本分词。当使用 morphology=`icu_chinese` 时会使用它。\n\n- **WITH_JIEBA** - 使用 Jieba 中文文本分词工具进行构建。它用于中文文本分词。当使用 morphology=`jieba_chinese` 时会使用它。\n\n- **WITH_ICU_FORCE_STATIC** - 下载 ICU 源代码，编译并静态链接它们，使最终的二进制文件不依赖系统中共享的 `icu` 库。还将 ICU 数据文件包含在安装/发行版中。静态链接 ICU 的目的是拥有已知版本的库，以确保行为确定且不依赖任何系统库。您很可能更愿意使用系统 ICU，因为它可能会随着时间更新，无需重新编译 Manticore 守护进程。在这种情况下，您需要显式禁用此选项。这也会节省 ICU 数据文件（约 30M）占用的空间，因为它不会包含在发行版中。\n\n- **WITH_SSL** - 用于支持 HTTPS 以及与守护进程的加密 MySQL 连接。系统的 OpenSSL 库将链接到守护进程。这意味着启动守护进程时需要 OpenSSL。对于支持 HTTPS 是强制性的，但对服务器本身不是严格强制的（即无 SSL 意味着无法通过 HTTPS 连接，但其他协议仍然可用）。Manticore 可以使用从 1.0.2 到 1.1.1 版本的 SSL 库，但请注意 **为了安全起见，强烈建议使用最新的 SSL 库**。目前仅支持 v1.1.1，其他版本已过时（参见 [openssl 发布策略](https://www.openssl.org/policies/releasestrat.html)）。\n\n- **WITH_ZLIB** - 索引器用于处理来自 MySQL 的压缩列。守护进程用于支持压缩的 MySQL 协议。\n\n- **WITH_ODBC** - 索引器用于支持来自 ODBC 提供程序的索引源（通常是 UnixODBC 和 iODBC）。在 MS Windows 上，ODBC 是处理 MS SQL 源的正确方式，因此索引 `MSSQL` 也意味着启用此标志。\n\n- **DL_ODBC** - 不链接 ODBC 库。如果链接了 ODBC，但不可用，即使您想处理与 ODBC 无关的内容，也无法启动索引器工具。此选项要求索引器仅在需要处理 ODBC 源时运行时加载库。\n\n- **ODBC_LIB** - ODBC 库文件的名称。索引器在处理 ODBC 源时会尝试加载该文件。此选项会根据可用的 ODBC 共享库自动写入。您也可以通过在运行索引器之前设置环境变量 `ODBC_LIB` 并提供替代库的正确路径来覆盖该名称。\n\n- **WITH_EXPAT** - 索引器用于支持索引 xmlpipe 源。\n\n- **DL_EXPAT** - 不链接 EXPAT 库。如果链接了 EXPAT，但不可用，即使您想处理与 xmlpipe 无关的内容，也无法启动 `indexer` 工具。此选项要求索引器仅在需要处理 xmlpipe 源时运行时加载库。\n\n- **EXPAT_LIB** - EXPAT 库文件的名称。索引器在处理 xmlpipe 源时会尝试加载该文件。此选项会根据可用的 EXPAT 共享库自动写入。您也可以通过在运行索引器之前设置环境变量 EXPAT_LIB 并提供替代库的正确路径来覆盖该名称。\n\n- **WITH_ICONV** - 支持索引器在索引 xmlpipe 源时使用不同编码。\n\n- **DL_ICONV** - 不链接 iconv 库。如果链接了 iconv，但不可用，即使您想处理与 xmlpipe 无关的内容，也无法启动 `indexer` 工具。此选项要求索引器仅在需要处理 xmlpipe 源时运行时加载库。",
      "russian": "Чтобы отключить, используйте `-DFOO=0`. Если явно не указано иное, включение функции, которая недоступна((например, `WITH_GALERA` в сборке для MS Windows)) приведет к ошибке конфигурации. Отключение функции, помимо исключения её из сборки, также отключает её проверку в системе и загрузку/сборку любых связанных внешних библиотек.\n\n#### Флаги и опции конфигурации\n\n- **USE_SYSLOG** - позволяет использовать `syslog` в [логировании запросов](../Logging/Query_logging.md).\n\n- **WITH_GALERA** - Включает поддержку репликации в поисковом демоне. Поддержка будет настроена для сборки, а исходники библиотеки Galera будут загружены, собраны и включены в дистрибутив/установку. Обычно безопасно собирать с Galera, но не распространять саму библиотеку (то есть без модуля Galera, без репликации). Однако иногда может потребоваться явно отключить её, например, если вы хотите собрать статический бинарный файл, который по конструкции не может загружать библиотеки, так что даже наличие вызова функции 'dlopen' внутри демона вызовет ошибку линковки.\n\n- **WITH_RE2** - Сборка с использованием библиотеки регулярных выражений RE2. Это необходимо для функций, таких как [REGEX()](../Functions/String_functions.md#REGEX%28%29), и функции [regexp_filter](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#regexp_filter).\n\n- **WITH_RE2_FORCE_STATIC** - Загружает исходники RE2, компилирует их и статически линкует, так что итоговые бинарники не будут зависеть от наличия общей библиотеки `RE2` в вашей системе.\n\n- **WITH_STEMMER** - Сборка с использованием библиотеки стемминга Snowball.\n\n- **WITH_STEMMER_FORCE_STATIC** - Загружает исходники Snowball, компилирует их и статически линкует, так что итоговые бинарники не будут зависеть от наличия общей библиотеки `libstemmer` в вашей системе.\n\n- **WITH_ICU** - Сборка с библиотекой ICU (International Components for Unicode). Используется для сегментации китайского текста. Применяется при использовании morphology=`icu_chinese`.\n\n- **WITH_JIEBA** - Сборка с инструментом сегментации китайского текста Jieba. Используется для сегментации китайского текста. Применяется при использовании morphology=`jieba_chinese`.\n\n- **WITH_ICU_FORCE_STATIC** - Загружает исходники ICU, компилирует их и статически линкует, так что итоговые бинарники не будут зависеть от наличия общей библиотеки `icu` в вашей системе. Также включает файл данных ICU в установку/дистрибутив. Цель статической линковки ICU — иметь библиотеку известной версии, чтобы поведение было определённым и не зависело от системных библиотек. Скорее всего, вы предпочтёте использовать системную ICU, так как она может обновляться без необходимости перекомпиляции демона Manticore. В этом случае нужно явно отключить эту опцию. Это также сэкономит место, занимаемое файлом данных ICU (около 30М), так как он не будет включён в дистрибутив.\n\n- **WITH_SSL** - Используется для поддержки HTTPS, а также зашифрованных MySQL-соединений с демоном. Системная библиотека OpenSSL будет связана с демоном. Это означает, что для запуска демона потребуется OpenSSL. Это обязательно для поддержки HTTPS, но не строго обязательно для сервера (то есть отсутствие SSL означает невозможность подключения по HTTPS, но другие протоколы будут работать). Manticore может использовать версии SSL-библиотеки от 1.0.2 до 1.1.1, однако **в целях безопасности настоятельно рекомендуется использовать максимально свежую версию SSL-библиотеки**. На данный момент поддерживается только версия 1.1.1, остальные устарели (см. [стратегию релизов openssl](https://www.openssl.org/policies/releasestrat.html)).\n\n- **WITH_ZLIB** - используется индексатором для работы с сжатыми колонками из MySQL. Используется демоном для поддержки сжатого протокола MySQL.\n\n- **WITH_ODBC** - используется индексатором для поддержки индексации источников из ODBC-провайдеров (обычно UnixODBC и iODBC). В MS Windows ODBC — правильный способ работы с источниками MS SQL, поэтому индексация `MSSQL` также подразумевает этот флаг.\n\n- **DL_ODBC** - не линкуется с библиотекой ODBC. Если ODBC линкуется, но недоступна, вы не сможете запустить инструмент indexer, даже если хотите обработать что-то, не связанное с ODBC. Эта опция заставляет индексатор загружать библиотеку во время выполнения только при работе с источником ODBC.\n\n- **ODBC_LIB** - имя файла библиотеки ODBC. Индексатор попытается загрузить этот файл при работе с источником ODBC. Эта опция автоматически устанавливается на основе обнаружения доступной общей библиотеки ODBC. Вы также можете переопределить это имя во время выполнения, задав переменную окружения `ODBC_LIB` с правильным путём к альтернативной библиотеке перед запуском индексатора.\n\n- **WITH_EXPAT** - используется индексатором для поддержки индексации источников xmlpipe.\n\n- **DL_EXPAT** - не линкуется с библиотекой EXPAT. Если EXPAT линкуется, но недоступна, вы не сможете запустить инструмент `indexer`, даже если хотите обработать что-то, не связанное с xmlpipe. Эта опция заставляет индексатор загружать библиотеку во время выполнения только при работе с источником xmlpipe.\n\n- **EXPAT_LIB** - имя файла библиотеки EXPAT. Индексатор попытается загрузить этот файл при работе с источником xmlpipe. Эта опция автоматически устанавливается на основе обнаружения доступной общей библиотеки EXPAT. Вы также можете переопределить это имя во время выполнения, задав переменную окружения EXPAT_LIB с правильным путём к альтернативной библиотеке перед запуском индексатора.\n\n- **WITH_ICONV** - для поддержки различных кодировок при индексации источников xmlpipe с помощью индексатора.\n\n- **DL_ICONV** - не линкуется с библиотекой iconv. Если iconv линкуется, но недоступна, вы не сможете запустить инструмент `indexer`, даже если хотите обработать что-то, не связанное с xmlpipe. Эта опция заставляет индексатор загружать библиотеку во время выполнения только при работе с источником xmlpipe."
    },
    "is_code_or_comment": false
  },
  "b2872684e88e0be0eb03e02e3e26907f1bc18219ae52d3bc32f8d71d0dda23dc": {
    "original": "- **ICONV_LIB** - name of the iconv library file. The indexer will try to load that file when you want to process xmlpipe source. This option is written automatically from the available iconv shared library investigation. You can also override that name at runtime by providing the environment variable `ICONV_LIB` with the proper path to an alternative library before running the indexer.\n\n- **WITH_MYSQL** - used by the indexer to support indexing MySQL sources.\n\n- **DL_MYSQL** - don't link with the MySQL library. If MySQL is linked, but not available, you can't start the`indexer` tool even if you want to process something not related to MySQL. This option asks the indexer to load the library at runtime only when you want to deal with a MySQL source.\n\n- **MYSQL_LIB** -- name of the MySQL library file. The indexer will try to load that file when you want to process a MySQL source. This option is written automatically from the available MySQL shared library investigation. You can also override that name at runtime by providing the environment variable `MYSQL_LIB` with the proper path to an alternative library before running the indexer.\n\n- **WITH_POSTGRESQL** - used by the indexer to support indexing PostgreSQL sources.\n\n- **DL_POSTGRESQL** - don't link with the PostgreSQL library. If PostgreSQL is linked, but not available, you can't start the `indexer` ool even if you want to process something not related to PostgreSQL. This option asks the indexer to load the library at runtime only when you want to deal with a PostgreSQL source.\n\n- **POSTGRESQL_LIB** - name of postgresql library file. The indexer will attempt to load the specified postgresql library file when processing a postgresql source. This option is automatically determined from available postgresql shared library investigation. You can also override the name at runtime by providing the environment variable  `POSTGRESQL_LIB` with the proper path to an alternative library before running the indexer.\n\n- **LOCALDATADIR** - default path where the daemon stores binlogs. If this path is not provided or explicitly disabled in the daemon's runtime config (i.e. the file `manticore.conf`, which is not related to this build configuration), binlogs will be placed in this path. It is typically an absolute path, however, it is not required to be and relative paths can also be used. You probably would not need to change the default value defined by the configuration, which, depending on the target system, might be something like `/var/data`, `/var/lib/manticore/data`, or `/usr/local/var/lib/manticore/data`.\n\n- **FULL_SHARE_DIR** - default path where all assets are stored. It can be overridden by the environment variable `FULL_SHARE_DIR` before starting any tool that utilizes files from that folder. This is an important path as many things are expected to be found there by default. These include predefined charset tables, stopwords, manticore modules, and icu data files, all placed in that folder. The configuration script usually determines this path to be something like `/usr/share/manticore`, or `/usr/local/share/manticore`.\n\n- **DISTR_BUILD** - a shortcut for the options for releasing packages. This is a string value with the name of the target platform. It can be used instead of manually configuring all the options. On Debian and Redhat Linuxes, the default value might be determined by light introspection and set to a generic 'Debian' or 'RHEL'. Otherwise, the value is not defined.\n\n- **PACK** - an even more convenient shortcut. It reads the `DISTR` environment variable, assigns it to the **DISTR_BUILD** parameter, and then works as usual. This is very useful when building in prepared build systems, like Docker containers, where the  `DISTR` variable is set at the system level and reflects the target system for which the container is intended.\n\n- **CMAKE_INSTALL_PREFIX** (path) - where Manticore is expected to be installed. Building does not perform any installations, but it prepares the installation rules that are executed when you run the `cmake --install` command or create a package and then install it. The prefix can be changed at any time, even during installation, by invoking\n\n  `cmake --install . --prefix /path/to/installation`. However, at config time, this variable is used to initialize the default values of  `LOCALDATADIR` and `FULL_SHARE_DIR`. For example, setting it to `/my/custom` at configure\n\n  time will hardcode `LOCALDATADIR` as `/my/custom/var/lib/manticore/data`, and `FULL_SHARE_DIR` as\n\n  `/my/custom/usr/share/manticore`.\n\n- **BUILD_TESTING** (bool) whether to support testing. If enabled, after the build, you can run 'ctest' and test the build. Note that testing implies additional dependencies, like at least the presence of PHP cli, Python, and an available MySQL server with a test database. By default, this parameter is on. So, for 'just build', you might want to disable the option by explicitly specifying 'off' value.\n\n- **BUILD_SRPMS** (bool) whether to show instructions for building Source RPMs (SRPMs). Due to CPack limitations with component-based packaging, SRPMs cannot be generated directly alongside binary RPMs. When enabled, the build system will display instructions for proper SRPM generation using the source configuration method. By default, this parameter is off.\n\n- **LIBS_BUNDLE** - path to a folder with different libraries. This is mostly relevant for Windows building, but may also be helpful if you have to build often in order to avoid downloading third-party sources each time. By default, this path is never modified by the configuration script; you should put everything there manually. When, say, we want support for a stemmer - the sources will be downloaded from Snowball homepage, then extracted, configured, built, etc. Instead, you can store the original source tarball (which is `libstemmer_c.tgz`) in this folder. Next time you want to build from scratch, the configuration script will first look up in the bundle, and if it finds the stemmer there, it will not download it again from the Internet.",
    "translations": {
      "chinese": "- **ICONV_LIB** - iconv 库文件的名称。当您想处理 xmlpipe 源时，索引器将尝试加载该文件。此选项是根据可用的 iconv 共享库自动写入的。您也可以在运行时通过提供环境变量 `ICONV_LIB` 并指定替代库的正确路径来覆盖该名称，然后再运行索引器。\n\n- **WITH_MYSQL** - 索引器用来支持索引 MySQL 源。\n\n- **DL_MYSQL** - 不与 MySQL 库链接。如果 MySQL 已链接但不可用，即使您想处理与 MySQL 无关的内容，也无法启动 `indexer` 工具。此选项要求索引器仅在您想处理 MySQL 源时才在运行时加载该库。\n\n- **MYSQL_LIB** -- MySQL 库文件的名称。当您想处理 MySQL 源时，索引器将尝试加载该文件。此选项是根据可用的 MySQL 共享库自动写入的。您也可以在运行时通过提供环境变量 `MYSQL_LIB` 并指定替代库的正确路径来覆盖该名称，然后再运行索引器。\n\n- **WITH_POSTGRESQL** - 索引器用来支持索引 PostgreSQL 源。\n\n- **DL_POSTGRESQL** - 不与 PostgreSQL 库链接。如果 PostgreSQL 已链接但不可用，即使您想处理与 PostgreSQL 无关的内容，也无法启动 `indexer` 工具。此选项要求索引器仅在您想处理 PostgreSQL 源时才在运行时加载该库。\n\n- **POSTGRESQL_LIB** - postgresql 库文件的名称。当处理 postgresql 源时，索引器将尝试加载指定的 postgresql 库文件。此选项是根据可用的 postgresql 共享库自动确定的。您也可以在运行时通过提供环境变量 `POSTGRESQL_LIB` 并指定替代库的正确路径来覆盖该名称，然后再运行索引器。\n\n- **LOCALDATADIR** - 守护进程存储 binlog 的默认路径。如果在守护进程的运行时配置（即文件 `manticore.conf`，与此构建配置无关）中未提供该路径或显式禁用，binlog 将放置在此路径。它通常是绝对路径，但不要求必须是，亦可使用相对路径。您可能不需要更改配置定义的默认值，该默认值根据目标系统可能是 `/var/data`、`/var/lib/manticore/data` 或 `/usr/local/var/lib/manticore/data`。\n\n- **FULL_SHARE_DIR** - 存储所有资源的默认路径。可以在启动任何使用该文件夹中文件的工具之前，通过环境变量 `FULL_SHARE_DIR` 覆盖此路径。这是一个重要路径，因为许多内容默认期望在此找到，包括预定义的字符集表、停用词、manticore 模块和 icu 数据文件，均放置在该文件夹中。配置脚本通常将此路径确定为类似 `/usr/share/manticore` 或 `/usr/local/share/manticore`。\n\n- **DISTR_BUILD** - 用于发布包选项的快捷方式。它是一个字符串值，表示目标平台的名称。可以用它代替手动配置所有选项。在 Debian 和 Redhat Linux 上，默认值可能通过轻量级检测确定并设置为通用的 'Debian' 或 'RHEL'。否则，该值未定义。\n\n- **PACK** - 更方便的快捷方式。它读取 `DISTR` 环境变量，将其赋值给 **DISTR_BUILD** 参数，然后按常规工作。这在准备好的构建系统（如 Docker 容器）中非常有用，其中 `DISTR` 变量在系统级别设置，反映容器所针对的目标系统。\n\n- **CMAKE_INSTALL_PREFIX** (路径) - Manticore 预期安装的位置。构建不会执行任何安装，但会准备安装规则，这些规则在您运行 `cmake --install` 命令或创建包然后安装时执行。该前缀可以随时更改，即使在安装期间，也可以通过调用\n\n  `cmake --install . --prefix /path/to/installation` 来更改。然而，在配置时，此变量用于初始化 `LOCALDATADIR` 和 `FULL_SHARE_DIR` 的默认值。例如，在配置时将其设置为 `/my/custom` 会将 `LOCALDATADIR` 硬编码为 `/my/custom/var/lib/manticore/data`，将 `FULL_SHARE_DIR` 硬编码为\n\n  `/my/custom/usr/share/manticore`。\n\n- **BUILD_TESTING** (布尔值) 是否支持测试。如果启用，构建完成后，您可以运行 'ctest' 来测试构建。请注意，测试意味着额外的依赖项，如至少需要 PHP cli、Python 和可用的带测试数据库的 MySQL 服务器。默认情况下，此参数为开启状态。因此，对于“仅构建”，您可能希望通过显式指定 'off' 来禁用该选项。\n\n- **BUILD_SRPMS** (布尔值) 是否显示构建源 RPM（SRPM）的说明。由于 CPack 在基于组件的打包方面的限制，SRPM 不能直接与二进制 RPM 一起生成。启用时，构建系统将显示使用源配置方法正确生成 SRPM 的说明。默认情况下，此参数为关闭。\n\n- **LIBS_BUNDLE** - 包含不同库的文件夹路径。这主要与 Windows 构建相关，但如果您需要频繁构建以避免每次都下载第三方源，也可能有用。默认情况下，配置脚本不会修改此路径；您应手动将所有内容放入其中。例如，当我们想支持一个词干提取器时，源代码将从 Snowball 主页下载，然后解压、配置、构建等。相反，您可以将原始源代码压缩包（即 `libstemmer_c.tgz`）存放在此文件夹中。下次想从头构建时，配置脚本将首先在该包中查找，如果找到词干提取器，就不会再从互联网下载。",
      "russian": "- **ICONV_LIB** - имя файла библиотеки iconv. Индексатор попытается загрузить этот файл, когда вы захотите обработать источник xmlpipe. Эта опция записывается автоматически на основе доступных исследованных разделяемых библиотек iconv. Вы также можете переопределить это имя во время выполнения, задав переменную окружения `ICONV_LIB` с правильным путем к альтернативной библиотеке перед запуском индексатора.\n\n- **WITH_MYSQL** - используется индексатором для поддержки индексирования источников MySQL.\n\n- **DL_MYSQL** - не связывать с библиотекой MySQL. Если MySQL связана, но недоступна, вы не сможете запустить инструмент `indexer`, даже если хотите обработать что-то, не связанное с MySQL. Эта опция заставляет индексатор загружать библиотеку во время выполнения только тогда, когда вы хотите работать с источником MySQL.\n\n- **MYSQL_LIB** -- имя файла библиотеки MySQL. Индексатор попытается загрузить этот файл, когда вы захотите обработать источник MySQL. Эта опция записывается автоматически на основе доступных исследованных разделяемых библиотек MySQL. Вы также можете переопределить это имя во время выполнения, задав переменную окружения `MYSQL_LIB` с правильным путем к альтернативной библиотеке перед запуском индексатора.\n\n- **WITH_POSTGRESQL** - используется индексатором для поддержки индексирования источников PostgreSQL.\n\n- **DL_POSTGRESQL** - не связывать с библиотекой PostgreSQL. Если PostgreSQL связана, но недоступна, вы не сможете запустить инструмент `indexer`, даже если хотите обработать что-то, не связанное с PostgreSQL. Эта опция заставляет индексатор загружать библиотеку во время выполнения только тогда, когда вы хотите работать с источником PostgreSQL.\n\n- **POSTGRESQL_LIB** - имя файла библиотеки postgresql. Индексатор попытается загрузить указанный файл библиотеки postgresql при обработке источника postgresql. Эта опция автоматически определяется на основе доступных исследованных разделяемых библиотек postgresql. Вы также можете переопределить имя во время выполнения, задав переменную окружения `POSTGRESQL_LIB` с правильным путем к альтернативной библиотеке перед запуском индексатора.\n\n- **LOCALDATADIR** - путь по умолчанию, где демон хранит binlogs. Если этот путь не указан или явно отключен в конфигурации времени выполнения демона (т.е. в файле `manticore.conf`, который не связан с этой конфигурацией сборки), binlogs будут размещены в этом пути. Обычно это абсолютный путь, однако он не обязательно должен быть таковым, можно использовать и относительные пути. Вероятно, вам не нужно менять значение по умолчанию, определённое конфигурацией, которое, в зависимости от целевой системы, может быть таким, как `/var/data`, `/var/lib/manticore/data` или `/usr/local/var/lib/manticore/data`.\n\n- **FULL_SHARE_DIR** - путь по умолчанию, где хранятся все ресурсы. Его можно переопределить переменной окружения `FULL_SHARE_DIR` перед запуском любого инструмента, который использует файлы из этой папки. Это важный путь, так как многие вещи по умолчанию ожидаются именно там. Сюда входят предопределённые таблицы символов, стоп-слова, модули manticore и файлы данных icu, все размещённые в этой папке. Скрипт конфигурации обычно определяет этот путь как что-то вроде `/usr/share/manticore` или `/usr/local/share/manticore`.\n\n- **DISTR_BUILD** - ярлык для опций выпуска пакетов. Это строковое значение с именем целевой платформы. Его можно использовать вместо ручной настройки всех опций. В Debian и Redhat Linux значение по умолчанию может определяться лёгкой интроспекцией и устанавливаться как общее 'Debian' или 'RHEL'. В противном случае значение не определено.\n\n- **PACK** - ещё более удобный ярлык. Он читает переменную окружения `DISTR`, присваивает её параметру **DISTR_BUILD**, а затем работает как обычно. Это очень полезно при сборке в подготовленных системах сборки, таких как контейнеры Docker, где переменная `DISTR` установлена на уровне системы и отражает целевую систему, для которой предназначен контейнер.\n\n- **CMAKE_INSTALL_PREFIX** (путь) - где ожидается установка Manticore. Сборка не выполняет установку, но подготавливает правила установки, которые выполняются при запуске команды `cmake --install` или создании пакета с последующей установкой. Префикс можно изменить в любое время, даже во время установки, вызвав\n\n  `cmake --install . --prefix /path/to/installation`. Однако во время конфигурации эта переменная используется для инициализации значений по умолчанию для `LOCALDATADIR` и `FULL_SHARE_DIR`. Например, установка её в `/my/custom` во время конфигурации\n\n  зафиксирует `LOCALDATADIR` как `/my/custom/var/lib/manticore/data`, а `FULL_SHARE_DIR` как\n\n  `/my/custom/usr/share/manticore`.\n\n- **BUILD_TESTING** (bool) поддержка тестирования. Если включено, после сборки вы можете запустить 'ctest' и протестировать сборку. Обратите внимание, что тестирование подразумевает дополнительные зависимости, такие как наличие PHP cli, Python и доступного сервера MySQL с тестовой базой данных. По умолчанию этот параметр включён. Поэтому для «просто сборки» вы, возможно, захотите отключить опцию, явно указав значение 'off'.\n\n- **BUILD_SRPMS** (bool) показывать инструкции по сборке исходных RPM-пакетов (SRPM). Из-за ограничений CPack с упаковкой на основе компонентов, SRPM не могут быть сгенерированы напрямую вместе с бинарными RPM. При включении система сборки покажет инструкции для правильной генерации SRPM с использованием метода конфигурации исходников. По умолчанию этот параметр выключен.\n\n- **LIBS_BUNDLE** - путь к папке с различными библиотеками. Это в основном актуально для сборки под Windows, но может быть полезно, если вам часто приходится собирать, чтобы избежать загрузки сторонних исходников каждый раз. По умолчанию этот путь не изменяется скриптом конфигурации; вы должны положить всё туда вручную. Например, если нужна поддержка стеммера — исходники будут загружены с домашней страницы Snowball, затем распакованы, сконфигурированы, собраны и т.д. Вместо этого вы можете хранить оригинальный архив исходников (который называется `libstemmer_c.tgz`) в этой папке. В следующий раз при сборке с нуля скрипт конфигурации сначала проверит наличие стеммера в бандле, и если он там есть, не будет загружать его снова из Интернета."
    },
    "is_code_or_comment": false
  },
  "4a131f62034cec1dcc69497cbff1185f1d1610def9d7ec6ae026e8d3945a2071": {
    "original": "# Compiling Manticore from source\n\nCompiling Manticore Search from sources enables custom build configurations, such as disabling certain features or adding new patches for testing. For example, you may want to compile from sources and disable the embedded ICU in order to use a different version installed on your system that can be upgraded independently of Manticore. This is also useful if you are interested in contributing to the Manticore Search project.\n\n## Building using CI Docker\n\nTo prepare [official release and development packages](https://repo.manticoresearch.com/), we use Docker and a special building image. This image includes essential tooling and is designed to be used with external sysroots, so one container can build packages for all operating systems. You can build the image using the [Dockerfile](https://github.com/manticoresoftware/manticoresearch/blob/master/dist/build_dockers/cross/external_toolchain/Dockerfile) and [README](https://github.com/manticoresoftware/manticoresearch/blob/master/dist/build_dockers/README.md) or use an image from [Docker Hub](https://hub.docker.com/r/manticoresearch/external_toolchain/tags). This is the easiest way to create binaries for any supported operating system and architecture. You'll also need to specify the following environment variables when running the container:\n\n* `DISTR`: the target platform: `bionic`, `focal`, `jammy`, `buster`, `bullseye`, `bookworm`, `rhel7`, `rhel8`, `rhel9`, `rhel10`, `macos`, `windows`, `freebsd13`\n\n* `arch`: the architecture: `x86_64`, `x64` (for Windows), `aarch64`, `arm64` (for Macos)\n\n* `SYSROOT_URL`: the URL to the system roots archives. You can use https://repo.manticoresearch.com/repository/sysroots unless you are building the sysroots yourself (instructions can be found [here](https://github.com/manticoresoftware/manticoresearch/tree/master/dist/build_dockers/cross/sysroots)).\n\n* Use the CI workflow files as a reference to find the other environment variables you might need to use:\n\n  - https://github.com/manticoresoftware/manticoresearch/blob/master/.github/workflows/pack_publish.yml\n\n  - https://github.com/manticoresoftware/manticoresearch/blob/master/.github/workflows/build_template.yml\n\nTo find possible values for `DISTR` and `arch`, you can use the directory https://repo.manticoresearch.com/repository/sysroots/roots_with_zstd/ as a reference, as it includes sysroots for all supported combinations.\n\nAfter that, building packages inside the Docker container is as easy as calling:\n\nCODE_BLOCK_0\n\nFor instance, to create a package for Ubuntu Jammy that is similar to the official version Manticore Core Team provides, you should execute the following commands in the directory containing the Manticore Search sources. This directory is the root of a cloned repository from https://github.com/manticoresoftware/manticoresearch:\n\nCODE_BLOCK_1\n\nThe long source directory path is required or it may fail to build the sources in some cases (e.g. Centos).\n\nIn the same way, you can build binaries or packages not just for popular Linux distributions, but also for FreeBSD, Windows, and macOS.\n\n#### Building SRPMs using Docker\n\nYou can also you the same special docker image to build SRPMs:\n\nCODE_BLOCK_2\n\nThis will generate a Source RPM (`.src.rpm` file) containing all the source code.\n\n#### Building binary RPMs from the SRPM\n\nOnce you have generated the SRPM, you can use it to build the complete set of binary RPM packages:\n\nCODE_BLOCK_3\n\n> NOTE: **To build RPMs from the SRPM, you need to make sure all the dependencies listed in the SRPM are fully installed, which can be challenging.** The SRPM can still be useful for:\n\n> - Auditing the build process or inspecting the source and spec files\n\n> - Making custom modifications or patches to the build\n\n> - Understanding how the binaries were produced\n\n> - Meeting open-source license compliance requirements\n\n## Building manually\n\nCompiling Manticore without using the building Docker is **not recommended**, but if you need to do it, here's what you may need to know:\n\n### Required tools\n\n* C++ compiler\n\n  * In Linux - GNU (4.7.2 and above) or Clang can be used\n\n  * In Windows - Microsoft Visual Studio 2019 and above (community edition is enough)\n\n  * On macOS - Clang (from command line tools of XCode, use `xcode-select --install` to install).\n\n* Bison, Flex - on most systems, they are available as packages, on Windows they are available in the cygwin framework.\n\n* Cmake - used on all platforms (version 3.19 or above required)\n\n### Fetching sources\n\n#### From git\n\nManticore source code is [hosted on GitHub](https://github.com/manticoresoftware/manticoresearch).\n\nTo obtain the source code, clone the repository and then check out the desired branch or tag. The branch `master` represents the main development branch. Upon release, a versioned tag is created, such as `3.6.0` and a new branch for the current release is started, in this case `manticore-3.6.0`. The head of the versioned branch after all changes is used as source to build all binary releases. For example, to take sources of version 3.6.0 you can run:\n\nCODE_BLOCK_4\n\n#### From archive\n\nYou can download the desired code from GitHub by using the \"Download ZIP\" button. Both .zip and .tar.gz formats are suitable.\n\nCODE_BLOCK_5\n\n### Configuring\n\nManticore uses CMake. Assuming you are inside the root directory of the cloned repository:\n\nCODE_BLOCK_6\n\nCMake will investigate available features and configure the build according to them. By default, all features are considered enabled if they are available. The script also downloads and builds some external libraries, assuming that you want to use them. Implicitly, you get support for the maximal number of features.\n\nYou can also configure the build explicitly with flags and options.  To enable feature `FOO` add `-DFOO=1` to the CMake call.",
    "translations": {
      "chinese": "# 从源码编译 Manticore\n\n从源码编译 Manticore Search 可以实现自定义构建配置，例如禁用某些功能或添加新的补丁进行测试。例如，您可能希望从源码编译并禁用内嵌的 ICU，以便使用系统上安装的不同版本，该版本可以独立于 Manticore 升级。如果您有兴趣为 Manticore Search 项目做贡献，这也非常有用。\n\n## 使用 CI Docker 构建\n\n为了准备[官方发布和开发包](https://repo.manticoresearch.com/)，我们使用 Docker 和一个特殊的构建镜像。该镜像包含必要的工具，并设计为与外部 sysroots 一起使用，因此一个容器可以为所有操作系统构建包。您可以使用 [Dockerfile](https://github.com/manticoresoftware/manticoresearch/blob/master/dist/build_dockers/cross/external_toolchain/Dockerfile) 和 [README](https://github.com/manticoresoftware/manticoresearch/blob/master/dist/build_dockers/README.md) 构建该镜像，或者使用来自 [Docker Hub](https://hub.docker.com/r/manticoresearch/external_toolchain/tags) 的镜像。这是为任何支持的操作系统和架构创建二进制文件的最简单方法。运行容器时，您还需要指定以下环境变量：\n\n* `DISTR`：目标平台：`bionic`、`focal`、`jammy`、`buster`、`bullseye`、`bookworm`、`rhel7`、`rhel8`、`rhel9`、`rhel10`、`macos`、`windows`、`freebsd13`\n\n* `arch`：架构：`x86_64`、`x64`（Windows 用）、`aarch64`、`arm64`（Macos 用）\n\n* `SYSROOT_URL`：系统根目录归档的 URL。除非您自己构建 sysroots（说明见[这里](https://github.com/manticoresoftware/manticoresearch/tree/master/dist/build_dockers/cross/sysroots)），否则可以使用 https://repo.manticoresearch.com/repository/sysroots。\n\n* 使用 CI 工作流文件作为参考，查找您可能需要使用的其他环境变量：\n\n  - https://github.com/manticoresoftware/manticoresearch/blob/master/.github/workflows/pack_publish.yml\n\n  - https://github.com/manticoresoftware/manticoresearch/blob/master/.github/workflows/build_template.yml\n\n要查找 `DISTR` 和 `arch` 的可能值，可以参考目录 https://repo.manticoresearch.com/repository/sysroots/roots_with_zstd/，其中包含所有支持组合的 sysroots。\n\n之后，在 Docker 容器内构建包就像调用以下命令一样简单：\n\nCODE_BLOCK_0\n\n例如，要为 Ubuntu Jammy 创建一个类似于 Manticore 核心团队提供的官方版本的包，您应在包含 Manticore Search 源代码的目录中执行以下命令。该目录是从 https://github.com/manticoresoftware/manticoresearch 克隆的仓库的根目录：\n\nCODE_BLOCK_1\n\n需要使用较长的源代码目录路径，否则在某些情况下（例如 Centos）可能无法构建源代码。\n\n同样，您不仅可以为流行的 Linux 发行版构建二进制文件或包，还可以为 FreeBSD、Windows 和 macOS 构建。\n\n#### 使用 Docker 构建 SRPM\n\n您也可以使用相同的特殊 Docker 镜像来构建 SRPM：\n\nCODE_BLOCK_2\n\n这将生成一个包含所有源代码的源 RPM（`.src.rpm` 文件）。\n\n#### 从 SRPM 构建二进制 RPM\n\n生成 SRPM 后，您可以使用它来构建完整的二进制 RPM 包集：\n\nCODE_BLOCK_3\n\n> 注意：**要从 SRPM 构建 RPM，您需要确保 SRPM 中列出的所有依赖项都已完全安装，这可能具有挑战性。** SRPM 仍然有用的场景包括：\n\n> - 审计构建过程或检查源代码和 spec 文件\n\n> - 对构建进行自定义修改或补丁\n\n> - 了解二进制文件的生成方式\n\n> - 满足开源许可证合规性要求\n\n## 手动构建\n\n不使用构建 Docker 编译 Manticore **不推荐**，但如果您需要这样做，以下是您可能需要了解的内容：\n\n### 所需工具\n\n* C++ 编译器\n\n  * 在 Linux 上 - 可使用 GNU（4.7.2 及以上）或 Clang\n\n  * 在 Windows 上 - Microsoft Visual Studio 2019 及以上（社区版足够）\n\n  * 在 macOS 上 - Clang（来自 XCode 的命令行工具，使用 `xcode-select --install` 安装）\n\n* Bison、Flex - 在大多数系统上作为包提供，在 Windows 上可通过 cygwin 框架获得。\n\n* Cmake - 所有平台通用（需要版本 3.19 或以上）\n\n### 获取源码\n\n#### 从 git\n\nManticore 源代码托管在 [GitHub](https://github.com/manticoresoftware/manticoresearch)。\n\n要获取源代码，请克隆仓库，然后检出所需的分支或标签。`master` 分支代表主开发分支。发布时，会创建一个版本标签，如 `3.6.0`，并启动当前发布的新分支，在此例中为 `manticore-3.6.0`。版本分支的最新提交用于构建所有二进制发布。例如，要获取版本 3.6.0 的源码，可以运行：\n\nCODE_BLOCK_4\n\n#### 从归档\n\n您可以通过 GitHub 的“Download ZIP”按钮下载所需代码。`.zip` 和 `.tar.gz` 格式均适用。\n\nCODE_BLOCK_5\n\n### 配置\n\nManticore 使用 CMake。假设您处于克隆仓库的根目录：\n\nCODE_BLOCK_6\n\nCMake 会检测可用功能并据此配置构建。默认情况下，如果功能可用，则视为启用。脚本还会下载并构建一些外部库，假设您想使用它们。隐式地，您获得了最大数量功能的支持。\n\n您也可以通过标志和选项显式配置构建。要启用功能 `FOO`，请在 CMake 调用中添加 `-DFOO=1`。",
      "russian": "# Компиляция Manticore из исходников\n\nКомпиляция Manticore Search из исходных кодов позволяет создавать пользовательские конфигурации сборки, такие как отключение определённых функций или добавление новых патчей для тестирования. Например, вы можете захотеть скомпилировать из исходников и отключить встроенный ICU, чтобы использовать другую версию, установленную в вашей системе, которую можно обновлять независимо от Manticore. Это также полезно, если вы хотите внести вклад в проект Manticore Search.\n\n## Сборка с использованием CI Docker\n\nДля подготовки [официальных релизных и девелоперских пакетов](https://repo.manticoresearch.com/) мы используем Docker и специальный образ для сборки. Этот образ включает необходимые инструменты и предназначен для использования с внешними sysroots, так что один контейнер может собирать пакеты для всех операционных систем. Вы можете собрать образ, используя [Dockerfile](https://github.com/manticoresoftware/manticoresearch/blob/master/dist/build_dockers/cross/external_toolchain/Dockerfile) и [README](https://github.com/manticoresoftware/manticoresearch/blob/master/dist/build_dockers/README.md) или использовать образ с [Docker Hub](https://hub.docker.com/r/manticoresearch/external_toolchain/tags). Это самый простой способ создать бинарные файлы для любой поддерживаемой операционной системы и архитектуры. Также вам нужно будет указать следующие переменные окружения при запуске контейнера:\n\n* `DISTR`: целевая платформа: `bionic`, `focal`, `jammy`, `buster`, `bullseye`, `bookworm`, `rhel7`, `rhel8`, `rhel9`, `rhel10`, `macos`, `windows`, `freebsd13`\n\n* `arch`: архитектура: `x86_64`, `x64` (для Windows), `aarch64`, `arm64` (для Macos)\n\n* `SYSROOT_URL`: URL архивов системных корней. Вы можете использовать https://repo.manticoresearch.com/repository/sysroots, если не собираете sysroots самостоятельно (инструкции можно найти [здесь](https://github.com/manticoresoftware/manticoresearch/tree/master/dist/build_dockers/cross/sysroots)).\n\n* Используйте файлы CI workflow в качестве справочника, чтобы найти другие переменные окружения, которые могут понадобиться:\n\n  - https://github.com/manticoresoftware/manticoresearch/blob/master/.github/workflows/pack_publish.yml\n\n  - https://github.com/manticoresoftware/manticoresearch/blob/master/.github/workflows/build_template.yml\n\nЧтобы узнать возможные значения для `DISTR` и `arch`, вы можете использовать каталог https://repo.manticoresearch.com/repository/sysroots/roots_with_zstd/ в качестве справочника, так как он содержит sysroots для всех поддерживаемых комбинаций.\n\nПосле этого сборка пакетов внутри Docker-контейнера так же проста, как вызов:\n\nCODE_BLOCK_0\n\nНапример, чтобы создать пакет для Ubuntu Jammy, аналогичный официальной версии, предоставляемой командой Manticore Core, выполните следующие команды в каталоге с исходниками Manticore Search. Этот каталог является корнем клонированного репозитория с https://github.com/manticoresoftware/manticoresearch:\n\nCODE_BLOCK_1\n\nТребуется длинный путь к каталогу исходников, иначе сборка может не пройти в некоторых случаях (например, Centos).\n\nАналогично, вы можете собирать бинарные файлы или пакеты не только для популярных дистрибутивов Linux, но и для FreeBSD, Windows и macOS.\n\n#### Сборка SRPM с использованием Docker\n\nВы также можете использовать тот же специальный образ Docker для сборки SRPM:\n\nCODE_BLOCK_2\n\nЭто создаст Source RPM (`.src.rpm` файл), содержащий весь исходный код.\n\n#### Сборка бинарных RPM из SRPM\n\nПосле создания SRPM вы можете использовать его для сборки полного набора бинарных RPM пакетов:\n\nCODE_BLOCK_3\n\n> ПРИМЕЧАНИЕ: **Для сборки RPM из SRPM необходимо убедиться, что все зависимости, указанные в SRPM, полностью установлены, что может быть сложно.** SRPM всё равно может быть полезен для:\n\n> - Аудита процесса сборки или изучения исходников и spec-файлов\n\n> - Внесения пользовательских изменений или патчей в сборку\n\n> - Понимания, как были созданы бинарные файлы\n\n> - Соблюдения требований лицензий с открытым исходным кодом\n\n## Ручная сборка\n\nКомпиляция Manticore без использования Docker для сборки **не рекомендуется**, но если вам нужно это сделать, вот что может быть полезно знать:\n\n### Необходимые инструменты\n\n* Компилятор C++\n\n  * В Linux - можно использовать GNU (4.7.2 и выше) или Clang\n\n  * В Windows - Microsoft Visual Studio 2019 и выше (достаточно community edition)\n\n  * На macOS - Clang (из командных инструментов XCode, используйте `xcode-select --install` для установки).\n\n* Bison, Flex - на большинстве систем доступны как пакеты, в Windows доступны в среде cygwin.\n\n* Cmake - используется на всех платформах (требуется версия 3.19 или выше)\n\n### Получение исходников\n\n#### Из git\n\nИсходный код Manticore размещён на [GitHub](https://github.com/manticoresoftware/manticoresearch).\n\nЧтобы получить исходный код, клонируйте репозиторий и затем переключитесь на нужную ветку или тег. Ветка `master` представляет основную ветку разработки. При выпуске создаётся тег с версией, например `3.6.0`, и начинается новая ветка для текущего релиза, в данном случае `manticore-3.6.0`. Голова версии ветки после всех изменений используется как источник для сборки всех бинарных релизов. Например, чтобы взять исходники версии 3.6.0, выполните:\n\nCODE_BLOCK_4\n\n#### Из архива\n\nВы можете скачать нужный код с GitHub, используя кнопку \"Download ZIP\". Подходят форматы .zip и .tar.gz.\n\nCODE_BLOCK_5\n\n### Конфигурация\n\nManticore использует CMake. Предположим, вы находитесь в корневом каталоге клонированного репозитория:\n\nCODE_BLOCK_6\n\nCMake исследует доступные функции и настроит сборку в соответствии с ними. По умолчанию все функции считаются включёнными, если они доступны. Скрипт также скачивает и собирает некоторые внешние библиотеки, предполагая, что вы хотите их использовать. Таким образом, вы получаете поддержку максимального количества функций.\n\nВы также можете явно настроить сборку с помощью флагов и опций. Чтобы включить функцию `FOO`, добавьте `-DFOO=1` к вызову CMake."
    },
    "is_code_or_comment": false
  },
  "234e7a4c0ce3fa5345195b8be23269878f6e01b37da099419c9e6222d78447a9": {
    "original": "- **CACHEB** - path to a folder with stored builds of 3-rd party libraries. Usually features like galera, re2, icu, etc. first downloaded or being got from bundle, then unpacked, built, and installed into a temporary internal folder. When building manticore, that folder is then used as the place where the things required to support the asked feature are live. Finally, they either link with manticore, if it is a library; either go directly to distribution/installation (like galera or icu data). When **CACHEB** is defined either as cmake config param, either as a system environment variable, it is used as the target folder for that builds. This folder might be kept across builds, so that stored libraries there will not be rebuilt anymore, making the whole build process much shorter.\n\nNote, that some options are organized in triples: `WITH_XXX`, `DL_XXX` and `XXX_LIB` - like support of mysql, odbc, etc. `WITH_XXX` determines whether next two have an effect or not. I.e., if you set `WITH_ODBC` to `0` - there is no sence to provide `DL_ODBC` and `ODBC_LIB`, and these two will have no effect if the whole feature is disabled. Also, `XXX_LIB` has no sense without `DL_XXX`, because if you don't want `DL_XXX` option, dynamic loading will not be used, and name provided by `XXX_LIB` is useless. That is used by default introspection.\n\nAlso, using the `iconv` library assumes `expat` and is useless if the last is disabled.\n\nAlso, some libraries may be always available, and so, there is no sense to avoid linkage with them. For example, in Windows that is ODBC. On macOS that is Expat, iconv, and m.b. others. Default introspection determines such libraries and effectively emits only `WITH_XXX` for them, without `DL_XXX` and `XXX_LIB`, that makes the things simpler.\n\nWith some options in game configuring might look like:\n\nCODE_BLOCK_7\n\nApart general configuration values, you may also investigate file `CMakeCache.txt` which is left in build folder right after you run configuration. Any values defined there might be redefined explicitly when running cmake. For example, you may run `cmake -DHAVE_GETADDRINFO_A=FALSE ...`, and that config run will not assume investigated value of that variable, but will use one you've provided.\n\n#### Specific environment variables\n\nEnvironment variables are useful for providing some kind of global settings which are stored aside from build configuration and are always present. For persistence, they may be set globally on the system using different ways - like adding them to the `.bashrc` file, or embedding them into a Dockerfile if you produce a docker-based build system, or writing them in system preferences environment variables on Windows. Also, you may set them short-lived using `export VAR=value` in the shell. Or even shorter, by prepending values to the cmake call, like `CACHEB=/my/cache cmake ...` - this way it will only work on this call and will not be visible on the next.\n\nSome of such variables are known to be used in general by cmake and some other tools. That is things like `CXX` which determines the current C++ compiler, or `CXX_FLAGS` to provide compiler flags, etc.\n\nHowever, we have some variables that are specific to manticore configuration, which are invented solely for our builds.\n\n- **CACHEB** - same as the config **CACHEB** option\n\n- **LIBS_BUNDLE** - same as the config **LIBS_BUNDLE** option\n\n- **DISTR** - used to initialize the `DISTR_BUILD` option when `-DPACK=1` is used.\n\n- **DIAGNOSTIC** - makes the output of cmake configuration much more verbose, explaining everything happening\n\n- **WRITEB** - assumes **LIBS_BUNDLE** and, if set, will download source archive files for different tools to the LIBS_BUNDLE folder. That is, if a fresh version of the stemmer comes out - you can manually remove libstemmer_c.tgz from the bundle and then run a one-shot `WRITEB=1 cmake ...` - it will not find the stemmer's sources in the bundle and will then download them from the vendor's site to the bundle (without WRITEB it will download them into a temporary folder inside the build and will disappear when you wipe the build folder).\n\nAt the end of configuration, you may see what is available and will be used in a list like this one:\n\nCODE_BLOCK_8\n\n### Building\n\nCODE_BLOCK_9\n\n### Installation\n\nTo install run:\n\nCODE_BLOCK_10\n\nto install into custom (non-default) folder, run\n\nCODE_BLOCK_11\n\n### Building packages\n\nFor building a package, use the target `package`. It will build the package according to the selection provided by the `-DDISTR_BUILD` option. By default, it will be a simple .zip or .tgz archive with all binaries and supplementary files.\n\nCODE_BLOCK_12\n\n## Some advanced things about building\n\n### Recompilation (update) on single-config\n\nIf you haven't changed the path for sources and build, simply move to your build folder and run:\n\nCODE_BLOCK_13\n\nIf by any reason it doesn't work, you can delete file `CMakeCache.txt` located in the build folder. After this step you\n\nhave to run cmake again, pointing to the source folder and configuring the options.\n\nIf it also doesn't help, just wipe out your build folder and begin from scratch.\n\n### Build types\n\nBriefly - just use `--config RelWithDebInfo` as written above. It will make no mistake.\n\nWe use two build types. For development, it is `Debug` - it assigns compiler flags for optimization and other things in a way that it is very friendly for development, meaning the debug runs with step-by-step execution. However, the produced binaries are quite large and slow for production.\n\nFor releasing, we use another type - `RelWithDebInfo` - which means 'release build with debug info'. It produces production binaries with embedded debug info. The latter is then split away into separate debuginfo packages which are stored aside with release packages and might be used in case of some issues like crashes - for investigation and bugfixing. Cmake also provides `Release` and `MinSizeRel`, but we don't use them. If the build type is not available, cmake will make a `noconfig` build.\n\n#### Build system generators\n\nThere are two types of generators: single-config and multi-config.",
    "translations": {
      "chinese": "- **CACHEB** - 存储第三方库构建的文件夹路径。通常像 galera、re2、icu 等功能，首先从网络下载或从捆绑包中获取，然后解包、构建并安装到一个临时的内部文件夹中。在构建 manticore 时，该文件夹被用作支持所需功能的资源所在位置。最终，这些库要么与 manticore 链接（如果它是一个库）；要么直接进入分发/安装（如 galera 或 icu 数据）。当 **CACHEB** 被定义为 cmake 配置参数或系统环境变量时，它被用作这些构建的目标文件夹。该文件夹可能会在多次构建间保留，因此存储在其中的库不会被重新构建，从而大大缩短整个构建过程。\n\n注意，有些选项是成三元组组织的：`WITH_XXX`、`DL_XXX` 和 `XXX_LIB` —— 比如对 mysql、odbc 等的支持。`WITH_XXX` 决定后两个选项是否生效。即，如果你将 `WITH_ODBC` 设置为 `0`，那么提供 `DL_ODBC` 和 `ODBC_LIB` 就没有意义，这两个选项在整个功能被禁用时不会生效。此外，`XXX_LIB` 在没有 `DL_XXX` 的情况下也没有意义，因为如果不使用 `DL_XXX` 选项，则不会使用动态加载，`XXX_LIB` 提供的名称也就无用。这是默认的自省机制所使用的。\n\n另外，使用 `iconv` 库假设依赖 `expat`，如果后者被禁用，则前者无效。\n\n还有一些库可能总是可用，因此没有必要避免与它们链接。例如，在 Windows 上是 ODBC；在 macOS 上是 Expat、iconv 以及可能的其他库。默认的自省机制会识别这些库，并仅为它们生成 `WITH_XXX`，而不生成 `DL_XXX` 和 `XXX_LIB`，这使得配置更简单。\n\n使用某些选项时，配置过程可能如下所示：\n\nCODE_BLOCK_7\n\n除了通用配置值外，你还可以查看配置后保留在构建文件夹中的 `CMakeCache.txt` 文件。任何在该文件中定义的值都可以在运行 cmake 时显式重新定义。例如，你可以运行 `cmake -DHAVE_GETADDRINFO_A=FALSE ...`，这次配置将不会使用该变量的已有值，而是使用你提供的值。\n\n#### 特定环境变量\n\n环境变量用于提供某种全局设置，这些设置存储在构建配置之外且始终存在。为了持久化，它们可以通过多种方式在系统中全局设置——比如添加到 `.bashrc` 文件，或者如果你使用基于 Docker 的构建系统，则嵌入到 Dockerfile 中，或者在 Windows 的系统偏好环境变量中设置。你也可以在 shell 中使用 `export VAR=value` 设置短期变量。甚至更短暂的方式是，在调用 cmake 时前置变量赋值，如 `CACHEB=/my/cache cmake ...` ——这样变量只在这次调用中生效，下一次调用不可见。\n\n其中一些变量是 cmake 和其他工具通用的，比如 `CXX` 用于指定当前 C++ 编译器，`CXX_FLAGS` 用于提供编译器标志等。\n\n然而，我们有一些专门针对 manticore 配置的变量，这些变量是专门为我们的构建设计的。\n\n- **CACHEB** - 与配置中的 **CACHEB** 选项相同\n\n- **LIBS_BUNDLE** - 与配置中的 **LIBS_BUNDLE** 选项相同\n\n- **DISTR** - 当使用 `-DPACK=1` 时，用于初始化 `DISTR_BUILD` 选项。\n\n- **DIAGNOSTIC** - 使 cmake 配置输出更详细，解释所有发生的事情\n\n- **WRITEB** - 假设 **LIBS_BUNDLE** 已设置，如果启用，将下载不同工具的源代码归档文件到 LIBS_BUNDLE 文件夹。也就是说，如果出现了新的 stemmer 版本，你可以手动删除 bundle 中的 libstemmer_c.tgz，然后运行一次性命令 `WRITEB=1 cmake ...` ——它会在 bundle 中找不到 stemmer 源码，然后从供应商网站下载到 bundle 中（如果不使用 WRITEB，则会下载到构建中的临时文件夹，构建文件夹清理后会消失）。\n\n配置结束时，你可以看到一个可用功能列表，如下所示：\n\nCODE_BLOCK_8\n\n### 构建\n\nCODE_BLOCK_9\n\n### 安装\n\n运行以下命令进行安装：\n\nCODE_BLOCK_10\n\n如果要安装到自定义（非默认）文件夹，运行\n\nCODE_BLOCK_11\n\n### 构建包\n\n要构建包，使用目标 `package`。它将根据 `-DDISTR_BUILD` 选项的选择构建包。默认情况下，它是一个包含所有二进制文件和辅助文件的简单 .zip 或 .tgz 归档。\n\nCODE_BLOCK_12\n\n## 关于构建的一些高级内容\n\n### 单配置下的重新编译（更新）\n\n如果你没有更改源码和构建路径，只需进入你的构建文件夹并运行：\n\nCODE_BLOCK_13\n\n如果由于某种原因这不起作用，你可以删除构建文件夹中的 `CMakeCache.txt` 文件。完成此步骤后，你必须再次运行 cmake，指向源码文件夹并配置选项。\n\n如果这仍然无效，只需清空你的构建文件夹并从头开始。\n\n### 构建类型\n\n简而言之——只需使用上文所述的 `--config RelWithDebInfo`。这样不会出错。\n\n我们使用两种构建类型。开发时使用 `Debug` —— 它为优化和其他方面分配编译器标志，使调试运行支持逐步执行。然而，生成的二进制文件较大且运行较慢，不适合生产环境。\n\n发布时使用另一种类型——`RelWithDebInfo` —— 意味着“带调试信息的发布构建”。它生成带有嵌入调试信息的生产二进制文件。调试信息随后被拆分到单独的调试信息包中，这些包与发布包一起存储，可用于崩溃等问题的调查和修复。Cmake 还提供 `Release` 和 `MinSizeRel`，但我们不使用它们。如果构建类型不可用，cmake 会生成一个 `noconfig` 构建。\n\n#### 构建系统生成器\n\n生成器分为两种类型：单配置和多配置。",
      "russian": "- **CACHEB** - путь к папке с сохранёнными сборками сторонних библиотек. Обычно такие функции, как galera, re2, icu и т.д., сначала скачиваются или берутся из бандла, затем распаковываются, собираются и устанавливаются во временную внутреннюю папку. При сборке manticore эта папка затем используется как место, где находятся необходимые для поддержки запрашиваемой функции компоненты. В итоге они либо линкуются с manticore, если это библиотека; либо идут напрямую в дистрибутив/установку (например, galera или данные icu). Когда **CACHEB** определён либо как параметр конфигурации cmake, либо как системная переменная окружения, он используется как целевая папка для этих сборок. Эта папка может сохраняться между сборками, чтобы сохранённые там библиотеки больше не пересобирались, что значительно сокращает весь процесс сборки.\n\nОбратите внимание, что некоторые опции организованы тройками: `WITH_XXX`, `DL_XXX` и `XXX_LIB` — например, поддержка mysql, odbc и т.д. `WITH_XXX` определяет, будут ли влиять следующие две. То есть, если вы установите `WITH_ODBC` в `0`, нет смысла задавать `DL_ODBC` и `ODBC_LIB`, и эти две опции не будут иметь эффекта, если вся функция отключена. Также `XXX_LIB` не имеет смысла без `DL_XXX`, потому что если вы не хотите использовать опцию `DL_XXX`, динамическая загрузка не будет использоваться, и имя, заданное в `XXX_LIB`, бесполезно. Это используется по умолчанию для интроспекции.\n\nТакже использование библиотеки `iconv` предполагает наличие `expat` и бесполезно, если последний отключён.\n\nКроме того, некоторые библиотеки могут быть всегда доступны, и поэтому нет смысла избегать их линковки. Например, в Windows это ODBC. На macOS это Expat, iconv и, возможно, другие. По умолчанию интроспекция определяет такие библиотеки и фактически генерирует только `WITH_XXX` для них, без `DL_XXX` и `XXX_LIB`, что упрощает ситуацию.\n\nС некоторыми опциями конфигурация может выглядеть так:\n\nCODE_BLOCK_7\n\nПомимо общих значений конфигурации, вы также можете изучить файл `CMakeCache.txt`, который остаётся в папке сборки сразу после запуска конфигурации. Любые значения, определённые там, могут быть переопределены явно при запуске cmake. Например, вы можете запустить `cmake -DHAVE_GETADDRINFO_A=FALSE ...`, и этот запуск конфигурации не будет учитывать исследуемое значение этой переменной, а будет использовать то, которое вы указали.\n\n#### Специфические переменные окружения\n\nПеременные окружения полезны для предоставления некоторого рода глобальных настроек, которые хранятся отдельно от конфигурации сборки и всегда присутствуют. Для постоянства их можно задать глобально в системе разными способами — например, добавив их в файл `.bashrc`, или встроив в Dockerfile, если вы создаёте систему сборки на основе Docker, или записав их в системные переменные окружения в настройках Windows. Также их можно задать временно с помощью `export VAR=value` в оболочке. Или ещё короче — предваряя вызов cmake значениями, например `CACHEB=/my/cache cmake ...` — так это будет работать только для этого вызова и не будет видно в следующем.\n\nНекоторые из таких переменных известны и используются в целом cmake и другими инструментами. Это такие вещи, как `CXX`, определяющая текущий компилятор C++, или `CXX_FLAGS` для передачи флагов компилятора и т.д.\n\nОднако у нас есть переменные, специфичные для конфигурации manticore, которые придуманы исключительно для наших сборок.\n\n- **CACHEB** - то же, что и опция конфигурации **CACHEB**\n\n- **LIBS_BUNDLE** - то же, что и опция конфигурации **LIBS_BUNDLE**\n\n- **DISTR** - используется для инициализации опции `DISTR_BUILD` при использовании `-DPACK=1`.\n\n- **DIAGNOSTIC** - делает вывод конфигурации cmake гораздо более подробным, объясняя всё происходящее\n\n- **WRITEB** - предполагает **LIBS_BUNDLE** и, если установлена, будет скачивать исходные архивы для разных инструментов в папку LIBS_BUNDLE. То есть, если выходит свежая версия стеммера — вы можете вручную удалить libstemmer_c.tgz из бандла, а затем выполнить однократный запуск `WRITEB=1 cmake ...` — он не найдёт исходники стеммера в бандле и скачает их с сайта поставщика в бандл (без WRITEB он скачает их во временную папку внутри сборки, которая исчезнет при очистке папки сборки).\n\nВ конце конфигурации вы можете увидеть, что доступно и будет использовано, в списке, похожем на этот:\n\nCODE_BLOCK_8\n\n### Сборка\n\nCODE_BLOCK_9\n\n### Установка\n\nДля установки выполните:\n\nCODE_BLOCK_10\n\nчтобы установить в пользовательскую (не по умолчанию) папку, выполните\n\nCODE_BLOCK_11\n\n### Сборка пакетов\n\nДля сборки пакета используйте цель `package`. Она соберёт пакет согласно выбору, заданному опцией `-DDISTR_BUILD`. По умолчанию это будет простой архив .zip или .tgz со всеми бинарными файлами и дополнительными файлами.\n\nCODE_BLOCK_12\n\n## Некоторые продвинутые моменты сборки\n\n### Пересборка (обновление) при single-config\n\nЕсли вы не меняли путь к исходникам и сборке, просто перейдите в папку сборки и выполните:\n\nCODE_BLOCK_13\n\nЕсли по какой-то причине это не сработает, вы можете удалить файл `CMakeCache.txt`, расположенный в папке сборки. После этого шага вам нужно снова запустить cmake, указав папку с исходниками и настроив опции.\n\nЕсли и это не поможет, просто очистите папку сборки и начните заново.\n\n### Типы сборок\n\nКратко — просто используйте `--config RelWithDebInfo`, как указано выше. Это не вызовет ошибок.\n\nМы используем два типа сборок. Для разработки — `Debug` — он задаёт флаги компилятора для оптимизации и других вещей так, чтобы было удобно для разработки, то есть отладка с пошаговым выполнением. Однако получаемые бинарники довольно большие и медленные для продакшена.\n\nДля релиза мы используем другой тип — `RelWithDebInfo` — что означает «релизная сборка с отладочной информацией». Она создаёт продакшн-бинарники с встроенной отладочной информацией. Последняя затем выносится в отдельные пакеты с отладочной информацией, которые хранятся отдельно от релизных пакетов и могут использоваться в случае проблем, например, с крашами — для расследования и исправления ошибок. Cmake также предоставляет `Release` и `MinSizeRel`, но мы их не используем. Если тип сборки недоступен, cmake сделает сборку `noconfig`.\n\n#### Генераторы системы сборки\n\nСуществуют два типа генераторов: single-config и multi-config."
    },
    "is_code_or_comment": false
  }
}
