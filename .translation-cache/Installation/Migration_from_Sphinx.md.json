{
  "bb804e9a7647308846ba5f2e83cbe19524a2f8b2d80ac8a88239cf09a3a97fca": {
    "original": "* `--path` - instead of using a config file, a path containing table(s) can be used\n\n* `--strip-path` - strips path from filenames referenced by table: stopwords, exceptions and wordforms\n\n* `--large-docid` - allows to convert documents with ids larger than 2^63 and display a warning, otherwise it will just exit on the large id with an error. This option was added as in Manticore 3.x doc ids are signed bigint, while previously they were unsigned\n\n* `--output-dir <dir>` - writes the new files in a chosen folder rather than the same location as with the existing table files. When this option set, existing table files will remain untouched at their location.\n\n* `--all` - converts all tables from the config\n\n* `--killlist-target <targets>` sets the target tables for which kill-lists will be applied. This option should be used only in conjunction with the `--index` option\n\n<!-- proofread -->",
    "translations": {
      "chinese": "* `--path` - 不使用配置文件，而是使用包含表的路径\n\n* `--strip-path` - 从表引用的文件名中去除路径：停用词、例外和词形变化\n\n* `--large-docid` - 允许转换文档ID大于2^63的文档并显示警告，否则遇到大ID时会直接报错退出。添加此选项是因为在Manticore 3.x中，文档ID是有符号的bigint，而之前是无符号的\n\n* `--output-dir <dir>` - 将新文件写入指定文件夹，而不是与现有表文件相同的位置。设置此选项时，现有表文件将保持原位置不变。\n\n* `--all` - 转换配置中的所有表\n\n* `--killlist-target <targets>` 设置将应用kill-list的目标表。此选项应仅与`--index`选项一起使用\n\n<!-- proofread -->",
      "russian": "* `--path` - вместо использования конфигурационного файла можно указать путь, содержащий таблицу(ы)\n\n* `--strip-path` - удаляет путь из имён файлов, на которые ссылается таблица: стоп-слова, исключения и словоформы\n\n* `--large-docid` - позволяет конвертировать документы с идентификаторами больше 2^63 и выводить предупреждение, иначе при большом идентификаторе программа просто завершится с ошибкой. Эта опция была добавлена, так как в Manticore 3.x идентификаторы документов имеют тип signed bigint, тогда как ранее они были unsigned\n\n* `--output-dir <dir>` - записывает новые файлы в выбранную папку, а не в то же место, где находятся существующие файлы таблиц. При установке этой опции существующие файлы таблиц останутся нетронутыми на своих местах.\n\n* `--all` - конвертирует все таблицы из конфигурации\n\n* `--killlist-target <targets>` задаёт целевые таблицы, к которым будут применяться kill-листы. Эта опция должна использоваться только вместе с опцией `--index`\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "986ed4cd63da89dbbd5dd21b33c351bcc919adaa22309bfd381c3eec71101714": {
    "original": "In Manticore 3, kill-lists are applied to a table when it's loaded during searchd startup or gets rotated. The new directive `killlist_target` in table configuration specifies target tables and defines which doc ids from the source table should be used for suppression. These can be ids from the defined kill-list, actual doc ids of the table or both.\n\nDocuments from the kill-lists are deleted from the target tables, they are not returned in results even if the search doesn't include the table that provided the kill-lists. Because of that, the order of tables for searching does not matter anymore. Now, `delta, main` and `main, delta` will provide the same results.\n\nIn previous versions, tables were rotated following the order from the configuration file. In Manticore 3 table rotation order is much smarter and works in accordance with killlist targets. Before starting to rotate tables, the server looks for chains of tables by `killlist_target` definitions. It will then first rotate tables not referenced anywhere as kill-lists targets. Next, it will rotate tables targeted by already rotated tables and so on. For example, if we do  `indexer --all` and we have 3 tables: main, delta_big (which targets at the main) and delta_small (with target at delta_big), first, delta_small is rotated, then delta_big and finally the main. This is to ensure that when a dependent table is rotated it gets the most actual kill-list from other tables.\n\n## Configuration keys removed in Manticore 3.x\n\n* `docinfo` - everything is now extern\n\n* `inplace_docinfo_gap` - not needed anymore\n\n* `mva_updates_pool` - MVAs don’t have anymore a dedicated pool for updates, as now they can be updated directly in the blob (see below).\n\n## Updating var-length attributes in Manticore 3.x\n\nString, JSON and MVA attributes can be updated in Manticore 3.x using `UPDATE` statement.\n\nIn 2.x string attributes required `REPLACE`, for JSON it was only possible to update scalar properties (as they were fixed-width) and MVAs could be updated using the MVA pool. Now updates are performed directly on the blob component. One setting that may require tuning is [attr_update_reserve](../Data_creation_and_modification/Updating_documents/UPDATE.md#attr_update_reserve) which allows changing the allocated extra space at the end of the blob used to avoid frequent resizes in case the new values are bigger than the existing values in the blob.\n\n## Document IDs in Manticore 3.x\n\nDoc ids used to be UNSIGNED 64-bit integers. Now they are POSITIVE SIGNED 64-bit integers.\n\n## RT mode in Manticore 3.x\n\nRead here about the [RT mode](../Read_this_first.md#Real-time-mode-vs-plain-mode)\n\n## Special suffixes since Manticore 3.x\n\nManticore 3.x recognizes and parses special suffixes which makes easier to use numeric values with special meaning. Common form for them is integer number + literal, like 10k or 100d, but not 40.3s (since 40.3 is not integer), or not 2d 4h (since there are two, not one value). Literals are case-insensitive, so 10W is the same as 10w. There are 2 types of such suffixes currently supported:\n\n* Size suffixes - can be used in parameters that define size of something (memory buffer, disk file, limit of RAM, etc. ) in bytes. \"Naked\" numbers in that places mean literally size in bytes (octets). Size values take suffix `k` for kilobytes (1k=1024), `m` for megabytes (1m=1024k), `g` for gigabytes (1g=1024m) and `t` for terabytes (1t=1024g).\n\n* Time suffixes - can be used in parameters defining some time interval values like delays, timeouts, etc. \"Naked\" values for those parameters usually have documented scale, and you must know if their numbers, say, 100, means '100 seconds' or '100 milliseconds'. However instead of guessing you just can write suffixed value and it will be fully determined by it's suffix. Time values take suffix `us` for useconds (microseconds), `ms` for milliseconds, `s` for seconds, `m` for minutes, `h` for hours, `d` for days and `w` for weeks.\n\n## index_converter\n\n`index_converter` is a tool for converting tables created with Sphinx/Manticore Search 2.x to the Manticore Search 3.x table format. The tool can be used in several different ways:\n\n#### Convert one table at a time\n\nCODE_BLOCK_0\n\n#### Convert all tables\n\nCODE_BLOCK_1\n\n#### Convert tables found in a folder\n\nCODE_BLOCK_2\n\nThe new version of the table is written by default in the same folder. The previous version's files are saved with the `.old` extension in their name. An exception is the `.spp` (hitlists) file, which is the only table component that didn't have any changes in the new format.\n\nYou can save the new table version to a different folder using the `-–output-dir` option\n\nCODE_BLOCK_3\n\n#### Convert kill lists\n\nA special case is for tables containing kill-lists. As the behaviour of how kill-lists works has changed (see [killlist_target](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#killlist_target)), the delta table should know which are the target tables for applying the kill-lists. There are 3 ways to have a converted table ready for setting targeted tables for applying kill-lists:\n\n* Use `-–killlist-target` when converting a table\n\n  ```ini\n\n  $ index_converter --config /home/myuser/manticore.conf --index deltaindex --killlist-target mainindex:kl\n\n  ```\n\n* Add killlist_target in the configuration before doing the conversion\n\n* use [ALTER ... KILLIST_TARGET](../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#killlist_target) command after conversion\n\n#### Complete list of index_converter options\n\nHere's the complete list of `index_converter` options:\n\n* `--config <file>` (`-c <file>` for short) tells index_converter to use the given file as its configuration. Normally, it will look for manticore.conf in the installation directory (e.g. `/usr/local/manticore/etc/manticore.conf` if installed into `/usr/local/sphinx`), followed by the current directory you are in when calling index_converter from the shell.\n\n* `--index` specifies which table should be converted",
    "translations": {
      "chinese": "在 Manticore 3 中，kill-list 会在 searchd 启动时加载表或表被轮换时应用。表配置中的新指令 `killlist_target` 指定目标表，并定义应从源表中用于抑制的文档 ID。这些可以是定义的 kill-list 中的 ID、表的实际文档 ID 或两者。\n\n来自 kill-list 的文档会从目标表中删除，即使搜索不包含提供 kill-list 的表，也不会在结果中返回。因此，搜索表的顺序不再重要。现在，`delta, main` 和 `main, delta` 将提供相同的结果。\n\n在以前的版本中，表的轮换遵循配置文件中的顺序。在 Manticore 3 中，表的轮换顺序更智能，并且与 killlist 目标一致。在开始轮换表之前，服务器会根据 `killlist_target` 定义查找表链。然后，它会先轮换未被任何地方作为 kill-list 目标引用的表。接着，轮换已被已轮换表作为目标的表，依此类推。例如，如果我们执行 `indexer --all` 并且有 3 个表：main、delta_big（目标为 main）和 delta_small（目标为 delta_big），则首先轮换 delta_small，然后是 delta_big，最后是 main。这样可以确保当依赖表被轮换时，它能获得来自其他表的最新 kill-list。\n\n## Manticore 3.x 中移除的配置键\n\n* `docinfo` - 现在全部为 extern\n\n* `inplace_docinfo_gap` - 不再需要\n\n* `mva_updates_pool` - MVA 不再有专用的更新池，因为现在它们可以直接在 blob 中更新（见下文）。\n\n## Manticore 3.x 中更新变长属性\n\n字符串、JSON 和 MVA 属性可以在 Manticore 3.x 中使用 `UPDATE` 语句更新。\n\n在 2.x 中，字符串属性需要 `REPLACE`，JSON 只能更新标量属性（因为它们是定长的），MVA 可以使用 MVA 池更新。现在更新直接在 blob 组件上执行。可能需要调整的一个设置是 [attr_update_reserve](../Data_creation_and_modification/Updating_documents/UPDATE.md#attr_update_reserve)，它允许更改在 blob 末尾分配的额外空间，用于避免当新值比现有值大时频繁调整大小。\n\n## Manticore 3.x 中的文档 ID\n\n文档 ID 以前是无符号 64 位整数。现在是正有符号 64 位整数。\n\n## Manticore 3.x 中的 RT 模式\n\n请阅读关于 [RT 模式](../Read_this_first.md#Real-time-mode-vs-plain-mode) 的内容。\n\n## Manticore 3.x 以来的特殊后缀\n\nManticore 3.x 识别并解析特殊后缀，使得使用带有特殊含义的数值更方便。它们的常见形式是整数 + 字面量，如 10k 或 100d，但不包括 40.3s（因为 40.3 不是整数），也不包括 2d 4h（因为有两个值，而非一个）。字面量不区分大小写，因此 10W 与 10w 相同。目前支持两种类型的后缀：\n\n* 大小后缀 - 可用于定义某些大小（内存缓冲区、磁盘文件、RAM 限制等）参数的字节数。在这些位置的“裸”数字字面意思是字节数（八位字节）。大小值使用后缀 `k` 表示千字节（1k=1024），`m` 表示兆字节（1m=1024k），`g` 表示千兆字节（1g=1024m），`t` 表示太字节（1t=1024g）。\n\n* 时间后缀 - 可用于定义某些时间间隔值，如延迟、超时等。这些参数的“裸”值通常有文档说明的单位，你必须知道数字 100 是表示“100 秒”还是“100 毫秒”。不过，你可以直接写带后缀的值，单位由后缀完全确定。时间值使用后缀 `us` 表示微秒，`ms` 表示毫秒，`s` 表示秒，`m` 表示分钟，`h` 表示小时，`d` 表示天，`w` 表示周。\n\n## index_converter\n\n`index_converter` 是一个用于将 Sphinx/Manticore Search 2.x 创建的表转换为 Manticore Search 3.x 表格式的工具。该工具可以通过多种方式使用：\n\n#### 一次转换一个表\n\nCODE_BLOCK_0\n\n#### 转换所有表\n\nCODE_BLOCK_1\n\n#### 转换文件夹中找到的表\n\nCODE_BLOCK_2\n\n新版本的表默认写入同一文件夹。旧版本的文件会以 `.old` 扩展名保存。例外的是 `.spp`（hitlists）文件，这是唯一在新格式中没有任何更改的表组件。\n\n你可以使用 `-–output-dir` 选项将新表版本保存到不同的文件夹\n\nCODE_BLOCK_3\n\n#### 转换 kill list\n\n包含 kill-list 的表是特殊情况。由于 kill-list 的工作方式发生了变化（参见 [killlist_target](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#killlist_target)），delta 表应知道应用 kill-list 的目标表。转换表后准备设置应用 kill-list 的目标表有三种方法：\n\n* 转换表时使用 `-–killlist-target`\n\n  ```ini\n\n  $ index_converter --config /home/myuser/manticore.conf --index deltaindex --killlist-target mainindex:kl\n\n  ```\n\n* 在转换前在配置中添加 killlist_target\n\n* 转换后使用 [ALTER ... KILLIST_TARGET](../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#killlist_target) 命令\n\n#### index_converter 选项完整列表\n\n以下是 `index_converter` 选项的完整列表：\n\n* `--config <file>`（简写为 `-c <file>`）告诉 index_converter 使用指定的配置文件。通常，它会在安装目录（例如，如果安装在 `/usr/local/sphinx`，则为 `/usr/local/manticore/etc/manticore.conf`）中查找 manticore.conf，然后是你从 shell 调用 index_converter 时所在的当前目录。\n\n* `--index` 指定要转换的表",
      "russian": "В Manticore 3 kill-листы применяются к таблице при её загрузке во время запуска searchd или при её ротации. Новая директива `killlist_target` в конфигурации таблицы указывает целевые таблицы и определяет, какие doc id из исходной таблицы должны использоваться для подавления. Это могут быть id из определённого kill-листа, фактические doc id таблицы или оба варианта.\n\nДокументы из kill-листов удаляются из целевых таблиц, они не возвращаются в результатах даже если поиск не включает таблицу, которая предоставила kill-листы. Из-за этого порядок таблиц для поиска больше не имеет значения. Теперь `delta, main` и `main, delta` дадут одинаковые результаты.\n\nВ предыдущих версиях таблицы ротировались в порядке, указанном в конфигурационном файле. В Manticore 3 порядок ротации таблиц стал гораздо умнее и работает в соответствии с целями killlist. Перед началом ротации таблиц сервер ищет цепочки таблиц по определениям `killlist_target`. Затем он сначала ротирует таблицы, которые нигде не упоминаются как цели kill-листов. Далее он ротирует таблицы, на которые ссылаются уже ротированные таблицы, и так далее. Например, если мы делаем `indexer --all` и у нас есть 3 таблицы: main, delta_big (который нацелен на main) и delta_small (с целью на delta_big), сначала ротируется delta_small, затем delta_big и наконец main. Это делается для того, чтобы при ротации зависимой таблицы она получала самый актуальный kill-лист из других таблиц.\n\n## Ключи конфигурации, удалённые в Manticore 3.x\n\n* `docinfo` - теперь всё extern\n\n* `inplace_docinfo_gap` - больше не нужен\n\n* `mva_updates_pool` - MVAs больше не имеют выделенного пула для обновлений, так как теперь их можно обновлять напрямую в блобе (см. ниже).\n\n## Обновление атрибутов переменной длины в Manticore 3.x\n\nСтроковые, JSON и MVA атрибуты можно обновлять в Manticore 3.x с помощью оператора `UPDATE`.\n\nВ версии 2.x строковые атрибуты требовали `REPLACE`, для JSON можно было обновлять только скалярные свойства (так как они были фиксированной ширины), а MVAs можно было обновлять с помощью пула MVA. Теперь обновления выполняются напрямую в компоненте блоба. Одной из настроек, которую может потребоваться подстроить, является [attr_update_reserve](../Data_creation_and_modification/Updating_documents/UPDATE.md#attr_update_reserve), которая позволяет изменять выделенное дополнительное пространство в конце блоба, используемое для избежания частых переразмериваний, если новые значения больше существующих в блобе.\n\n## Doc ID в Manticore 3.x\n\nDoc id раньше были беззнаковыми 64-битными целыми числами. Теперь они являются положительными знаковыми 64-битными целыми числами.\n\n## RT режим в Manticore 3.x\n\nЧитайте здесь про [RT режим](../Read_this_first.md#Real-time-mode-vs-plain-mode)\n\n## Специальные суффиксы с Manticore 3.x\n\nManticore 3.x распознаёт и парсит специальные суффиксы, что облегчает использование числовых значений со специальным значением. Общая форма — целое число + литерал, например 10k или 100d, но не 40.3s (так как 40.3 не целое), или не 2d 4h (так как это два значения, а не одно). Литералы не чувствительны к регистру, поэтому 10W — то же, что 10w. В настоящее время поддерживаются 2 типа таких суффиксов:\n\n* Суффиксы размера — могут использоваться в параметрах, определяющих размер чего-либо (буфер памяти, файл на диске, лимит ОЗУ и т.п.) в байтах. «Голые» числа в таких местах означают буквально размер в байтах (октетах). Суффиксы размера: `k` для килобайт (1k=1024), `m` для мегабайт (1m=1024k), `g` для гигабайт (1g=1024m) и `t` для терабайт (1t=1024g).\n\n* Суффиксы времени — могут использоваться в параметрах, задающих временные интервалы, такие как задержки, таймауты и т.п. «Голые» значения для таких параметров обычно имеют документированную шкалу, и вы должны знать, означает ли число, скажем, 100 — «100 секунд» или «100 миллисекунд». Однако вместо догадок можно просто написать значение с суффиксом, и оно будет однозначно определено своим суффиксом. Суффиксы времени: `us` для микросекунд, `ms` для миллисекунд, `s` для секунд, `m` для минут, `h` для часов, `d` для дней и `w` для недель.\n\n## index_converter\n\n`index_converter` — это инструмент для конвертации таблиц, созданных в Sphinx/Manticore Search 2.x, в формат таблиц Manticore Search 3.x. Инструмент можно использовать несколькими способами:\n\n#### Конвертация одной таблицы за раз\n\nCODE_BLOCK_0\n\n#### Конвертация всех таблиц\n\nCODE_BLOCK_1\n\n#### Конвертация таблиц, найденных в папке\n\nCODE_BLOCK_2\n\nНовая версия таблицы по умолчанию записывается в ту же папку. Файлы предыдущей версии сохраняются с расширением `.old` в имени. Исключение — файл `.spp` (hitlists), который является единственным компонентом таблицы, не изменившимся в новом формате.\n\nВы можете сохранить новую версию таблицы в другую папку, используя опцию `-–output-dir`\n\nCODE_BLOCK_3\n\n#### Конвертация kill-листов\n\nОсобый случай — таблицы, содержащие kill-листы. Поскольку поведение kill-листов изменилось (см. [killlist_target](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#killlist_target)), дельта-таблица должна знать, какие таблицы являются целевыми для применения kill-листов. Есть 3 способа получить конвертированную таблицу, готовую для установки целевых таблиц для применения kill-листов:\n\n* Использовать `-–killlist-target` при конвертации таблицы\n\n  ```ini\n\n  $ index_converter --config /home/myuser/manticore.conf --index deltaindex --killlist-target mainindex:kl\n\n  ```\n\n* Добавить killlist_target в конфигурацию перед конвертацией\n\n* Использовать команду [ALTER ... KILLIST_TARGET](../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#killlist_target) после конвертации\n\n#### Полный список опций index_converter\n\nВот полный список опций `index_converter`:\n\n* `--config <file>` (`-c <file>` для краткости) указывает index_converter использовать данный файл в качестве конфигурации. Обычно он ищет manticore.conf в каталоге установки (например, `/usr/local/manticore/etc/manticore.conf`, если установлен в `/usr/local/sphinx`), затем в текущем каталоге, в котором вы вызываете index_converter из оболочки.\n\n* `--index` указывает, какую таблицу следует конвертировать"
    },
    "is_code_or_comment": false
  },
  "9bbef4f49ba58bfe4c4d8157daa0bc547ee541c56d30e95d519dc64a4236dea5": {
    "original": "# Migration from Sphinx Search\n\n## Sphinx 2.x -> Manticore 2.x\n\nManticore Search 2.x maintains compatibility with Sphinxsearch 2.x and can load existing tables created by Sphinxsearch. In most cases, upgrading is just a matter of replacing the binaries.\n\nInstead of sphinx.conf (in Linux normally located at `/etc/sphinxsearch/sphinx.conf`) Manticore by default uses `/etc/manticoresearch/manticore.conf`. It also runs under a different user and use different folders.\n\nSystemd service name has changed from `sphinx/sphinxsearch` to `manticore` and the service runs under user `manticore` (Sphinx was using `sphinx` or `sphinxsearch`). It also uses a different folder for the PID file.\n\nThe folders used by default are `/var/lib/manticore`, `/var/log/manticore`, `/var/run/manticore`. You can still use the existing Sphinx config, but you need to manually change permissions for `/var/lib/sphinxsearch` and `/var/log/sphinxsearch` folders. Or, just rename globally 'sphinx' to 'manticore' in system files. If you use other folders (for data, wordforms files etc.) the ownership must be also switched to user `manticore`. The `pid_file` location should be changed to match the manticore.service to `/run/manticore/searchd.pid`.\n\nIf you want to use the Manticore folder instead, the table files need to be moved to the new data folder (`/var/lib/manticore`) and the permissions must be changed to user `manticore`.\n\n## Sphinx 2.x / Manticore 2.x -> Manticore 3.x\n\nUpgrading from Sphinx / Manticore 2.x to 3.x is not straightforward, as the table storage engine has undergone a significant upgrade and the new searchd cannot load older tables and upgrade them to the new format on-the-fly.\n\nManticore Search 3 got a redesigned table storage. Tables created with Manticore/Sphinx 2.x cannot be loaded by Manticore Search 3 without a [conversion](../Installation/Migration_from_Sphinx.md#index_converter). Because of the 4GB limitation, a real-time table in 2.x could still have several disk chunks after an optimize operation. After upgrading to 3.x, these tables can now be optimized to 1-disk chunk with the usual [OPTIMIZE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE) command. Index files also changed. The only component that didn't get any structural changes is the `.spp` file (hitlists). `.sps` (strings/json) and `.spm` (MVA) are now held by `.spb` (var-length attributes). The new format has an `.spm` file present, but it's used for row map (previously it was dedicated for MVA attributes). The new extensions added are `.spt` (docid lookup), `.sphi` ( secondary index histograms), `.spds` (document storage). In case you are using scripts that manipulate table files, they should be adapted for the new file extensions.\n\nThe upgrade procedure may differ depending on your setup (number of servers in the cluster, whether you have high availability or not, etc.), but in general, it involves creating new 3.x table versions and replacing your existing ones, as well as replacing older 2.x binaries with the new ones.\n\nThere are two special requirements to take care:\n\n* Real-time tables need to be flushed using [FLUSH RAMCHUNK](../Securing_and_compacting_a_table/Flushing_RAM_chunk_to_a_new_disk_chunk.md#FLUSH-RAMCHUNK)\n\n* Plain tables with kill-lists require adding a new directive in table configuration (see [killlist_target](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#killlist_target))\n\nManticore Search 3 includes a new tool - [index_converter](../Installation/Migration_from_Sphinx.md#index_converter) - that can convert Sphinx 2.x / Manticore 2.x tables to 3.x format. `index_converter` comes in a separate package which should be installed first. Using the convert tool create 3.x versions of your tables. `index_converter` can write the new files in the existing data folder and backup the old files or it can write the new files to a chosen folder.\n\n## Basic upgrade instruction\n\nIf you have a single server:\n\n* Install the manticore-converter package\n\n* Use index_converter to create new versions of the tables in a different folder than the existing data folder (using the `--output-dir` option)\n\n* Stop the existing Manticore/Sphinx, upgrade to 3.0, move the new tables to the data folder, and start Manticore\n\nTo minimize downtime, you can copy 2.x tables, config (you'll need to edit paths here for tables, logs, and different ports), and binaries to a separate location and start this on a separate port. Point your application to it. After upgrading to 3.0 and the new server is started, you can point the application back to the normal ports. If everything is good, stop the 2.x copy and delete the files to free up space.\n\nIf you have a spare box (like a testing or staging server), you can do the table upgrade there first and even install Manticore 3 to perform several tests. If everything is okay, copy the new table files to the production server. If you have multiple servers that can be pulled out of production, do it one by one and perform the upgrade on each. For distributed setups, 2.x searchd can work as a master with 3.x nodes, so you can do the upgrading on the data nodes first, and then on the master node.\n\nThere have been no changes made to the way clients should connect to the engine, or any changes to the querying mode or behavior of queries.\n\n## kill-lists in Sphinx / Manticore 2.x vs Manticore 3.x\n\n[Kill-lists](../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md) have been redesigned in Manticore Search 3. In previous versions, kill-lists were applied to the result set provided by each previously searched table at query time.\n\nThus, in 2.x, the table order at query time mattered. For example, if a delta table had a kill-list, in order to apply it against the main table, the order had to be main, delta (either in a distributed table or in the FROM clause).",
    "translations": {
      "chinese": "# 从 Sphinx Search 迁移\n\n## Sphinx 2.x -> Manticore 2.x\n\nManticore Search 2.x 保持与 Sphinxsearch 2.x 的兼容性，可以加载由 Sphinxsearch 创建的现有表。在大多数情况下，升级只是替换二进制文件的问题。\n\nManticore 默认使用 `/etc/manticoresearch/manticore.conf`，而不是 sphinx.conf（在 Linux 中通常位于 `/etc/sphinxsearch/sphinx.conf`）。它还以不同的用户身份运行，并使用不同的文件夹。\n\nSystemd 服务名称已从 `sphinx/sphinxsearch` 更改为 `manticore`，服务以用户 `manticore` 运行（Sphinx 使用的是 `sphinx` 或 `sphinxsearch`）。它还使用不同的文件夹存放 PID 文件。\n\n默认使用的文件夹是 `/var/lib/manticore`、`/var/log/manticore`、`/var/run/manticore`。你仍然可以使用现有的 Sphinx 配置，但需要手动更改 `/var/lib/sphinxsearch` 和 `/var/log/sphinxsearch` 文件夹的权限。或者，直接在系统文件中全局将 'sphinx' 重命名为 'manticore'。如果你使用其他文件夹（用于数据、词形文件等），所有权也必须切换为用户 `manticore`。`pid_file` 位置应更改为与 manticore.service 匹配，即 `/run/manticore/searchd.pid`。\n\n如果你想使用 Manticore 文件夹，则需要将表文件移动到新的数据文件夹（`/var/lib/manticore`），并将权限更改为用户 `manticore`。\n\n## Sphinx 2.x / Manticore 2.x -> Manticore 3.x\n\n从 Sphinx / Manticore 2.x 升级到 3.x 并不简单，因为表存储引擎经历了重大升级，新的 searchd 无法加载旧表并即时升级到新格式。\n\nManticore Search 3 重新设计了表存储。使用 Manticore/Sphinx 2.x 创建的表无法被 Manticore Search 3 加载，除非进行[转换](../Installation/Migration_from_Sphinx.md#index_converter)。由于 4GB 限制，2.x 中的实时表在优化操作后仍可能有多个磁盘块。升级到 3.x 后，这些表可以通过常规的 [OPTIMIZE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE) 命令优化为单磁盘块。索引文件也发生了变化。唯一未发生结构变化的组件是 `.spp` 文件（命中列表）。`.sps`（字符串/json）和 `.spm`（MVA）现在由 `.spb`（变长属性）持有。新格式中存在 `.spm` 文件，但它用于行映射（之前专用于 MVA 属性）。新增的扩展名有 `.spt`（docid 查找）、`.sphi`（二级索引直方图）、`.spds`（文档存储）。如果你使用脚本操作表文件，应适配新的文件扩展名。\n\n升级过程可能因你的设置（集群中服务器数量、是否有高可用等）而异，但通常涉及创建新的 3.x 表版本并替换现有表，以及用新二进制文件替换旧的 2.x 文件。\n\n有两个特殊要求需要注意：\n\n* 实时表需要使用 [FLUSH RAMCHUNK](../Securing_and_compacting_a_table/Flushing_RAM_chunk_to_a_new_disk_chunk.md#FLUSH-RAMCHUNK) 刷新\n\n* 带有 kill-list 的普通表需要在表配置中添加新指令（参见 [killlist_target](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#killlist_target)）\n\nManticore Search 3 包含一个新工具 - [index_converter](../Installation/Migration_from_Sphinx.md#index_converter) - 可以将 Sphinx 2.x / Manticore 2.x 表转换为 3.x 格式。`index_converter` 是一个单独的软件包，需要先安装。使用转换工具创建表的 3.x 版本。`index_converter` 可以将新文件写入现有数据文件夹并备份旧文件，或者写入指定文件夹。\n\n## 基本升级说明\n\n如果你只有一台服务器：\n\n* 安装 manticore-converter 软件包\n\n* 使用 index_converter 在不同于现有数据文件夹的文件夹中创建表的新版本（使用 `--output-dir` 选项）\n\n* 停止现有的 Manticore/Sphinx，升级到 3.0，将新表移动到数据文件夹，然后启动 Manticore\n\n为了最小化停机时间，你可以复制 2.x 表、配置（需要编辑表、日志路径和不同端口）、二进制文件到另一个位置，并在不同端口启动。将应用程序指向它。升级到 3.0 并启动新服务器后，可以将应用程序指回正常端口。如果一切正常，停止 2.x 副本并删除文件以释放空间。\n\n如果你有备用机器（如测试或预发布服务器），可以先在那里进行表升级，甚至安装 Manticore 3 进行多次测试。如果一切正常，将新表文件复制到生产服务器。如果你有多台服务器可以从生产环境中抽出，逐台进行升级。对于分布式设置，2.x searchd 可以作为主节点与 3.x 节点共存，因此可以先升级数据节点，再升级主节点。\n\n客户端连接引擎的方式、查询模式或查询行为没有任何变化。\n\n## Sphinx / Manticore 2.x 与 Manticore 3.x 中的 kill-list\n\n[Kill-list](../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md) 在 Manticore Search 3 中进行了重新设计。在之前的版本中，kill-list 在查询时应用于每个先前搜索表提供的结果集。\n\n因此，在 2.x 中，查询时表的顺序很重要。例如，如果增量表有 kill-list，为了对主表应用它，顺序必须是主表、增量表（无论是在分布式表中还是在 FROM 子句中）。",
      "russian": "# Миграция с Sphinx Search\n\n## Sphinx 2.x -> Manticore 2.x\n\nManticore Search 2.x сохраняет совместимость с Sphinxsearch 2.x и может загружать существующие таблицы, созданные Sphinxsearch. В большинстве случаев обновление сводится к замене бинарных файлов.\n\nВместо sphinx.conf (в Linux обычно находится в `/etc/sphinxsearch/sphinx.conf`) Manticore по умолчанию использует `/etc/manticoresearch/manticore.conf`. Он также работает под другим пользователем и использует другие папки.\n\nИмя службы systemd изменилось с `sphinx/sphinxsearch` на `manticore`, и служба работает под пользователем `manticore` (Sphinx использовал `sphinx` или `sphinxsearch`). Также используется другая папка для файла PID.\n\nПапки, используемые по умолчанию: `/var/lib/manticore`, `/var/log/manticore`, `/var/run/manticore`. Вы всё ещё можете использовать существующую конфигурацию Sphinx, но вам нужно вручную изменить права доступа к папкам `/var/lib/sphinxsearch` и `/var/log/sphinxsearch`. Или просто глобально переименовать 'sphinx' в 'manticore' в системных файлах. Если вы используете другие папки (для данных, файлов wordforms и т.д.), владение ими также должно быть переключено на пользователя `manticore`. Местоположение `pid_file` следует изменить, чтобы оно соответствовало manticore.service на `/run/manticore/searchd.pid`.\n\nЕсли вы хотите использовать папку Manticore, файлы таблиц нужно переместить в новую папку данных (`/var/lib/manticore`), и права доступа должны быть изменены на пользователя `manticore`.\n\n## Sphinx 2.x / Manticore 2.x -> Manticore 3.x\n\nОбновление с Sphinx / Manticore 2.x до 3.x не является простым, так как движок хранения таблиц претерпел значительное обновление, и новый searchd не может загружать старые таблицы и обновлять их в новый формат на лету.\n\nManticore Search 3 получил переработанное хранение таблиц. Таблицы, созданные с Manticore/Sphinx 2.x, не могут быть загружены Manticore Search 3 без [конвертации](../Installation/Migration_from_Sphinx.md#index_converter). Из-за ограничения в 4 ГБ, таблица реального времени в 2.x могла иметь несколько дисковых чанков после операции оптимизации. После обновления до 3.x эти таблицы теперь можно оптимизировать до одного дискового чанка с помощью обычной команды [OPTIMIZE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE). Файлы индексов также изменились. Единственный компонент, который не претерпел структурных изменений — это файл `.spp` (hitlists). `.sps` (строки/json) и `.spm` (MVA) теперь содержатся в `.spb` (атрибуты переменной длины). Новый формат содержит файл `.spm`, но он используется для карты строк (ранее он был предназначен для MVA атрибутов). Добавлены новые расширения: `.spt` (поиск docid), `.sphi` (гистограммы вторичных индексов), `.spds` (хранение документов). Если вы используете скрипты, которые манипулируют файлами таблиц, их следует адаптировать под новые расширения файлов.\n\nПроцедура обновления может отличаться в зависимости от вашей конфигурации (число серверов в кластере, наличие высокой доступности и т.д.), но в общем случае она включает создание новых версий таблиц 3.x и замену существующих, а также замену старых бинарных файлов 2.x на новые.\n\nЕсть два специальных требования, которые нужно учесть:\n\n* Таблицы реального времени нужно сбросить с помощью [FLUSH RAMCHUNK](../Securing_and_compacting_a_table/Flushing_RAM_chunk_to_a_new_disk_chunk.md#FLUSH-RAMCHUNK)\n\n* Обычные таблицы с kill-листами требуют добавления новой директивы в конфигурацию таблицы (см. [killlist_target](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#killlist_target))\n\nManticore Search 3 включает новый инструмент — [index_converter](../Installation/Migration_from_Sphinx.md#index_converter) — который может конвертировать таблицы Sphinx 2.x / Manticore 2.x в формат 3.x. `index_converter` поставляется в отдельном пакете, который нужно установить первым. С помощью этого инструмента создайте версии таблиц 3.x. `index_converter` может записывать новые файлы в существующую папку данных и создавать резервные копии старых файлов, либо записывать новые файлы в выбранную папку.\n\n## Основная инструкция по обновлению\n\nЕсли у вас один сервер:\n\n* Установите пакет manticore-converter\n\n* Используйте index_converter для создания новых версий таблиц в другой папке, отличной от существующей папки данных (с помощью опции `--output-dir`)\n\n* Остановите существующий Manticore/Sphinx, обновитесь до 3.0, переместите новые таблицы в папку данных и запустите Manticore\n\nЧтобы минимизировать время простоя, вы можете скопировать таблицы 2.x, конфигурацию (вам нужно будет отредактировать пути для таблиц, логов и разных портов) и бинарные файлы в отдельное место и запустить это на отдельном порту. Направьте ваше приложение на него. После обновления до 3.0 и запуска нового сервера вы можете вернуть приложение к обычным портам. Если всё работает хорошо, остановите копию 2.x и удалите файлы, чтобы освободить место.\n\nЕсли у вас есть запасной сервер (например, тестовый или staging сервер), вы можете сначала выполнить обновление таблиц там и даже установить Manticore 3 для проведения нескольких тестов. Если всё в порядке, скопируйте новые файлы таблиц на продуктивный сервер. Если у вас несколько серверов, которые можно вывести из эксплуатации, делайте это по одному и выполняйте обновление на каждом. Для распределённых конфигураций searchd 2.x может работать как мастер с узлами 3.x, так что вы можете сначала обновить узлы данных, а затем мастер-узел.\n\nИзменений в способе подключения клиентов к движку, режиме запросов или поведении запросов не было.\n\n## kill-листы в Sphinx / Manticore 2.x и Manticore 3.x\n\n[Kill-листы](../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md) были переработаны в Manticore Search 3. В предыдущих версиях kill-листы применялись к результирующему набору, предоставленному каждой ранее обработанной таблицей во время выполнения запроса.\n\nТаким образом, в 2.x порядок таблиц во время запроса имел значение. Например, если у дельта-таблицы был kill-лист, чтобы применить его к основной таблице, порядок должен был быть основной, дельта (либо в распределённой таблице, либо в операторе FROM)."
    },
    "is_code_or_comment": false
  }
}
