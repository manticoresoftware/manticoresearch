{
  "3971024a1cbf3bfc57c04ba9cf0bf3a8660abdcdf5a3213fd2764e417cc0a3b1": {
    "original": "* `2` - Data is written after each transaction, and a sync is initiated every second. This approach offers a balance, writing data regularly and quickly. However, if the computer fails, some of the data that was being secured might not finish saving. Also, syncing may take longer than one second depending on the disk.\n\n* `3` - Similar to `2`, but it also ensures the binlog file is synced before it is closed due to exceeding `binlog_max_log_size`.\n\nThe default mode is `2`, which writes data after each transaction and starts syncing it every second, balancing speed and safety.\n\n<!-- request Example -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n### Cluster binlog support\n\n<!-- Example binlog_cluster -->\n\nIn a cluster setup using Galera, node recovery behavior is crucial. Normally, Galera handles node desynchronization via IST (incremental state transfer) if the node was shut down cleanly and its last sequence number (seqno) was properly saved. However, in case of a crash where seqno isn't preserved, Galera will trigger an SST (state snapshot transfer), which is resource-intensive and can significantly slow down the cluster due to high I/O activity.\n\nTo address this, cluster binlog support has been introduced. This feature extends the existing binary logging functionality to help reduce the need for SST by allowing a recovering node to replay missing transactions from local binlogs and rejoin the cluster with a valid seqno.\n\nCluster binlog is enabled by default for any cluster operations. However, it can be disabled by setting the environment variable:\n\n<!-- request binlog_cluster -->\n\nCODE_BLOCK_9\n\n<!-- end -->\n\nThis feature reduces downtime and avoids full data transfers by combining the local durability of binary log with Galera distributed sync capabilities.\n\n### Recovery\n\nDuring recovery after an unclean shutdown, binlogs are replayed, and all logged transactions since the last good on-disk state are restored. Transactions are checksummed, so in case of binlog file corruption, garbage data will **not** be replayed; such a broken transaction will be detected and will stop the replay.\n\n### Flushing RT RAM chunks\n\n<!-- Example rt_flush_period -->\n\nIntensive updates to a small RT table that fully fits into a RAM chunk can result in an ever-growing binlog that can never be unlinked until a clean shutdown. Binlogs essentially serve as append-only deltas against the last known good saved state on disk, and they cannot be unlinked unless the RAM chunk is saved. An ever-growing binlog is not ideal for disk usage and crash recovery time. To address this issue, you can configure `searchd` to perform periodic RAM chunk flushes using the `rt_flush_period` directive. With periodic flushes enabled, `searchd` will maintain a separate thread that checks whether RT table RAM chunks need to be written back to disk. Once this occurs, the respective binlogs can be (and are) safely unlinked.\n\nThe default RT flush period is set to 10 hours.\n\n<!-- request Example -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\nIt's important to note that `rt_flush_period` only controls the frequency at which checks occur. There are no guarantees that a specific RAM chunk will be saved. For example, it doesn't make sense to regularly re-save a large RAM chunk that only receives a few rows worth of updates. Manticore automatically determines whether to perform the flush using a few heuristics.\n\n<!-- proofread -->",
    "translations": {
      "chinese": "* `2` - 每个事务后写入数据，并且每秒启动一次同步。此方法提供了一个平衡，定期且快速地写入数据。然而，如果计算机发生故障，某些正在保存的数据可能无法完成保存。此外，根据磁盘情况，同步可能需要超过一秒的时间。\n\n* `3` - 类似于 `2`，但还确保在因超过 `binlog_max_log_size` 而关闭 binlog 文件之前进行同步。\n\n默认模式是 `2`，它在每个事务后写入数据，并每秒开始同步，平衡了速度和安全性。\n\n<!-- request Example -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n### 集群 binlog 支持\n\n<!-- Example binlog_cluster -->\n\n在使用 Galera 的集群设置中，节点恢复行为至关重要。通常，如果节点已正常关闭且其最后的序列号（seqno）已正确保存，Galera 会通过 IST（增量状态传输）处理节点不同步的情况。然而，在发生崩溃且 seqno 未被保存的情况下，Galera 将触发 SST（状态快照传输），这是一种资源密集型操作，可能由于高 I/O 活动显著减慢集群速度。\n\n为了解决这个问题，引入了集群 binlog 支持。此功能扩展了现有的二进制日志功能，帮助减少 SST 的需求，使恢复节点能够从本地 binlog 重放缺失的事务，并以有效的 seqno 重新加入集群。\n\n集群 binlog 默认对任何集群操作启用。但可以通过设置环境变量来禁用：\n\n<!-- request binlog_cluster -->\n\nCODE_BLOCK_9\n\n<!-- end -->\n\n此功能通过结合二进制日志的本地持久性和 Galera 分布式同步能力，减少了停机时间并避免了完整数据传输。\n\n### 恢复\n\n在非正常关闭后的恢复过程中，会重放 binlog，并恢复自上次良好磁盘状态以来记录的所有事务。事务带有校验和，因此如果 binlog 文件损坏，垃圾数据将**不会**被重放；此类损坏的事务将被检测到并停止重放。\n\n### 刷新 RT RAM 块\n\n<!-- Example rt_flush_period -->\n\n对完全适合于 RAM 块的小型 RT 表进行密集更新，可能导致 binlog 不断增长，直到干净关闭之前无法被删除。binlog 本质上是相对于磁盘上最后已知良好保存状态的追加式增量，除非 RAM 块被保存，否则无法删除。不断增长的 binlog 对磁盘使用和崩溃恢复时间都不理想。为了解决此问题，可以使用 `rt_flush_period` 指令配置 `searchd` 执行周期性 RAM 块刷新。启用周期性刷新后，`searchd` 将维护一个单独线程，检查 RT 表的 RAM 块是否需要写回磁盘。一旦发生，相关的 binlog 可以（且会被）安全删除。\n\n默认的 RT 刷新周期设置为 10 小时。\n\n<!-- request Example -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n需要注意的是，`rt_flush_period` 仅控制检查的频率。不能保证特定的 RAM 块一定会被保存。例如，定期重新保存仅接收少量行更新的大 RAM 块是没有意义的。Manticore 会使用一些启发式方法自动决定是否执行刷新。\n\n<!-- proofread -->",
      "russian": "* `2` - Данные записываются после каждой транзакции, и синхронизация запускается каждую секунду. Такой подход обеспечивает баланс, записывая данные регулярно и быстро. Однако, если компьютер выйдет из строя, часть данных, которые сохранялись, может не успеть сохраниться полностью. Также синхронизация может занять больше одной секунды в зависимости от диска.\n\n* `3` - Аналогично `2`, но также гарантирует синхронизацию файла binlog перед его закрытием из-за превышения `binlog_max_log_size`.\n\nРежим по умолчанию — `2`, который записывает данные после каждой транзакции и запускает их синхронизацию каждую секунду, обеспечивая баланс между скоростью и безопасностью.\n\n<!-- request Example -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n### Поддержка кластерного binlog\n\n<!-- Example binlog_cluster -->\n\nВ кластере с использованием Galera поведение восстановления узла имеет решающее значение. Обычно Galera обрабатывает рассинхронизацию узла через IST (incremental state transfer — инкрементальная передача состояния), если узел был корректно выключен и его последний номер последовательности (seqno) был правильно сохранён. Однако в случае сбоя, когда seqno не сохраняется, Galera инициирует SST (state snapshot transfer — передача снимка состояния), что требует больших ресурсов и может значительно замедлить работу кластера из-за высокой активности ввода-вывода.\n\nДля решения этой проблемы была введена поддержка кластерного binlog. Эта функция расширяет существующую функциональность бинарного логирования, помогая уменьшить необходимость SST, позволяя восстанавливающемуся узлу воспроизвести отсутствующие транзакции из локальных binlog и повторно присоединиться к кластеру с валидным seqno.\n\nКластерный binlog включён по умолчанию для любых операций в кластере. Однако его можно отключить, установив переменную окружения:\n\n<!-- request binlog_cluster -->\n\nCODE_BLOCK_9\n\n<!-- end -->\n\nЭта функция сокращает время простоя и избегает полной передачи данных, сочетая локальную надёжность бинарного лога с возможностями распределённой синхронизации Galera.\n\n### Восстановление\n\nПри восстановлении после некорректного завершения работы binlog воспроизводится, и все записанные транзакции с момента последнего корректного состояния на диске восстанавливаются. Транзакции имеют контрольную сумму, поэтому в случае повреждения файла binlog мусорные данные **не** будут воспроизведены; такая повреждённая транзакция будет обнаружена и воспроизведение остановится.\n\n### Сброс RT RAM чанков\n\n<!-- Example rt_flush_period -->\n\nИнтенсивные обновления небольшой RT-таблицы, которая полностью помещается в RAM-чанк, могут привести к постоянно растущему binlog, который нельзя удалить до чистого завершения работы. Binlog фактически служит как дельта только для добавления по отношению к последнему известному корректному сохранённому состоянию на диске, и его нельзя удалить, пока RAM-чанк не будет сохранён. Постоянно растущий binlog не является оптимальным с точки зрения использования диска и времени восстановления после сбоя. Для решения этой проблемы можно настроить `searchd` на периодический сброс RAM-чанков с помощью директивы `rt_flush_period`. При включённых периодических сбросах `searchd` будет поддерживать отдельный поток, который проверяет, нужно ли записывать RT-чанки обратно на диск. После этого соответствующие binlog могут быть (и будут) безопасно удалены.\n\nПериод сброса RT по умолчанию установлен в 10 часов.\n\n<!-- request Example -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\nВажно отметить, что `rt_flush_period` контролирует только частоту проверок. Нет гарантии, что конкретный RAM-чанк будет сохранён. Например, не имеет смысла регулярно пересохранять большой RAM-чанк, в который поступают обновления всего нескольких строк. Manticore автоматически определяет необходимость сброса, используя несколько эвристик.\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "e0482d7b3097b0697f27b4c35513e163b0b2488a2023e15c1283573bfce92e66": {
    "original": "# Binary logging\n\nBinary logging serves as a recovery mechanism for [real-time](../Creating_a_table/Local_tables/Real-time_table.md) table data. When binary logs are enabled, `searchd` records each transaction to the binlog file and utilizes it for recovery following an unclean shutdown. During a clean shutdown, RAM chunks are saved to disk, and all binlog files are subsequently deleted.\n\n## Enabling and disabling binary logging\n\nBy default, binary logging is enabled to safeguard data integrity. On Linux systems, the default location for `binlog.*` files in [Plain mode](../Creating_a_table/Local_tables.md#Defining-table-schema-in-config-%28Plain-mode%29) is `/var/lib/manticore/data/`. In [RT mode](../Creating_a_table/Local_tables.md#Online-schema-management-%28RT-mode%29), binary logs are stored in the `<data_dir>/binlog/` folder, unless specified otherwise.\n\n### Global binary logging configuration\n\n<!-- example binlog_path -->\n\nTo disable binary logging globally, set `binlog_path` to an empty value in the `searchd` configuration.\n\nDisabling binary logging requires a restart of the daemon and puts data at risk if the system shuts down unexpectedly.\n\n<!-- request Example -->\n\nCODE_BLOCK_0\n\n<!-- end -->\n\n<!-- example binlog_path2 -->\n\nYou can use the following directive to set a custom path:\n\n<!-- request Example -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n### Per-table binary logging configuration\n\n<!-- Example binlog0 -->\n\nFor more granular control, binary logging can be disabled at the table level for real-time tables by setting the `binlog` table parameter to `0`. This option is not available for percolate tables.\n\n<!-- request Example -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n<!-- Example binlog_alter -->\n\nFor existing RT tables, binary logging can also be disabled by modifying the `binlog` parameter.\n\n<!-- request Example -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- Example binlog_alter2 -->\n\nIf binary logging was previously disabled, it can be re-enabled by setting the `binlog` parameter back to `1`:\n\n<!-- request Example -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n#### Important considerations:\n\n* **Dependency on global settings**: per-table binary logging settings only take effect if binary logging is globally enabled in the searchd configuration (`binlog_path` must not be empty).\n\n* **Binary logging status and transaction ID insights**: Modifying the binary logging status of a table forces an immediate [flush of the table](../Securing_and_compacting_a_table/Flushing_RAM_chunk_to_disk.md#FLUSH-TABLE). If you turn off binary logging for a table, its transaction ID (TID) changes to `-1`. This indicates that binary logging is not active, and no changes are being tracked. Conversely, if you start binary logging for a table, its transaction ID becomes a non-negative number (zero or higher). This indicates that the table's changes are now being recorded. You can check the transaction ID by using the command: `SHOW TABLE <name> STATUS`. The transaction ID reflects whether changes to the table are being recorded (non-negative number) or not (`-1`).\n\n## Operations\n\nWhen binary logging is turned on, every change made to an RT table is saved to a log file. If the system shuts down unexpectedly, these logs are used automatically when the system starts again to bring back all the changes that were logged.\n\n### Log size\n\n<!-- Example binlog_max_log_size -->\n\nDuring normal operations, when the amount of data logged reaches a certain limit (set by `binlog_max_log_size`), a new log file starts. Old log files are kept until all changes in them are completely processed and saved to disk as a disk chunk. If this limit is set to `0`, the log files are kept until the system is properly shut down. By default, there's no limit to how large these files can grow.\n\n<!-- request Example -->\n\nCODE_BLOCK_5\n\n<!-- end -->\n\n### Log files\n\n<!-- example binlog_filename_digits -->\n\nEach binlog file is named with a zero-padded number, like `binlog.0000`, `binlog.0001`, etc., typically showing four digits. You can change how many digits the number has with the setting `binlog_filename_digits`. If you have more binlog files than the number of digits can accommodate, the number of digits will be automatically increased to fit all files.\n\n**Important**: To change the number of digits, you must first save all table data and properly shut down the system. Then, delete the old log files and restart the system.\n\n<!-- request Example -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n### Binary logging strategies\n\n<!-- Example binlog_common -->\n\nYou can choose between two ways to manage binary log files, which can be set with the `binlog_common` directive:\n\n* Separate file for each table (default, `0`): Each table saves its changes in its own log file. This setup is good if you have many tables that get updated at different times. It allows tables to be updated without waiting for others. Also, if there is a problem with one table's log file, it does not affect the others.\n\n* Single file for all tables (`1`): All tables use the same binary log file. This method makes it easier to handle files because there are fewer of them. However, this could keep files longer than needed if one table still needs to save its updates. This setting might also slow things down if many tables need to update at the same time because all changes have to wait to be written to one file.\n\n<!-- request binlog_common -->\n\nCODE_BLOCK_7\n\n<!-- end -->\n\n### Binary flushing strategies\n\n<!-- Example binlog_flush -->\n\nThere are four different binlog flushing strategies, controlled by the `binlog_flush` directive:\n\n* `0` - Data is written to disk (flushed) every second, and Manticore initiates making it secure on the disk ([syncing](https://linux.die.net/man/8/sync)) right after flushing. This method is the fastest, but if the server or computer crashes suddenly, some recently written data that hasn't been secured may be lost.\n\n* `1` - Data is written to the binlog and synced immediately after each transaction. This method is the safest as it ensures that each change is immediately preserved, but it slows down writing.",
    "translations": {
      "chinese": "# 二进制日志\n\n二进制日志作为[实时](../Creating_a_table/Local_tables/Real-time_table.md)表数据的恢复机制。当启用二进制日志时，`searchd` 会将每个事务记录到 binlog 文件中，并在非正常关闭后利用它进行恢复。在正常关闭期间，RAM 块会保存到磁盘，随后所有 binlog 文件都会被删除。\n\n## 启用和禁用二进制日志\n\n默认情况下，二进制日志是启用的，以保障数据完整性。在 Linux 系统上，[纯模式](../Creating_a_table/Local_tables.md#Defining-table-schema-in-config-%28Plain-mode%29)下 `binlog.*` 文件的默认位置是 `/var/lib/manticore/data/`。在[RT 模式](../Creating_a_table/Local_tables.md#Online-schema-management-%28RT-mode%29)下，二进制日志存储在 `<data_dir>/binlog/` 文件夹中，除非另有指定。\n\n### 全局二进制日志配置\n\n<!-- example binlog_path -->\n\n要全局禁用二进制日志，请在 `searchd` 配置中将 `binlog_path` 设置为空值。\n\n禁用二进制日志需要重启守护进程，并且如果系统意外关闭，数据将面临风险。\n\n<!-- request Example -->\n\nCODE_BLOCK_0\n\n<!-- end -->\n\n<!-- example binlog_path2 -->\n\n您可以使用以下指令设置自定义路径：\n\n<!-- request Example -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n### 每表二进制日志配置\n\n<!-- Example binlog0 -->\n\n为了更细粒度的控制，可以通过将实时表的 `binlog` 表参数设置为 `0` 来禁用该表的二进制日志。此选项不适用于 percolate 表。\n\n<!-- request Example -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n<!-- Example binlog_alter -->\n\n对于已有的 RT 表，也可以通过修改 `binlog` 参数来禁用二进制日志。\n\n<!-- request Example -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- Example binlog_alter2 -->\n\n如果之前禁用了二进制日志，可以通过将 `binlog` 参数重新设置为 `1` 来重新启用：\n\n<!-- request Example -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n#### 重要注意事项：\n\n* **依赖全局设置**：每表的二进制日志设置仅在全局启用了二进制日志（`binlog_path` 不为空）时生效。\n\n* **二进制日志状态和事务 ID 说明**：修改表的二进制日志状态会强制立即[刷新表](../Securing_and_compacting_a_table/Flushing_RAM_chunk_to_disk.md#FLUSH-TABLE)。如果关闭表的二进制日志，其事务 ID（TID）会变为 `-1`，表示二进制日志未激活，且不跟踪任何更改。相反，如果启用表的二进制日志，其事务 ID 会变为非负数（零或更大），表示该表的更改正在被记录。您可以使用命令 `SHOW TABLE <name> STATUS` 来检查事务 ID。事务 ID 反映了表的更改是否被记录（非负数）或未被记录（`-1`）。\n\n## 操作\n\n当启用二进制日志时，对 RT 表的每次更改都会保存到日志文件中。如果系统意外关闭，这些日志会在系统重新启动时自动使用，以恢复所有已记录的更改。\n\n### 日志大小\n\n<!-- Example binlog_max_log_size -->\n\n在正常操作期间，当记录的数据量达到一定限制（由 `binlog_max_log_size` 设置）时，会启动一个新的日志文件。旧的日志文件会保留，直到其中的所有更改都被完全处理并保存为磁盘块。如果该限制设置为 `0`，则日志文件会一直保留，直到系统正常关闭。默认情况下，这些文件的大小没有限制。\n\n<!-- request Example -->\n\nCODE_BLOCK_5\n\n<!-- end -->\n\n### 日志文件\n\n<!-- example binlog_filename_digits -->\n\n每个 binlog 文件的命名格式为带零填充的数字，如 `binlog.0000`、`binlog.0001` 等，通常显示四位数字。您可以通过设置 `binlog_filename_digits` 来更改数字的位数。如果 binlog 文件数量超过数字位数能容纳的范围，数字位数会自动增加以适应所有文件。\n\n**重要**：要更改数字位数，必须先保存所有表数据并正常关闭系统。然后删除旧的日志文件并重启系统。\n\n<!-- request Example -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n### 二进制日志策略\n\n<!-- Example binlog_common -->\n\n您可以选择两种管理二进制日志文件的方式，通过 `binlog_common` 指令设置：\n\n* 每表单独文件（默认，`0`）：每个表将其更改保存到自己的日志文件中。如果您有许多表在不同时间更新，这种设置很合适。它允许表独立更新，无需等待其他表。此外，如果某个表的日志文件出现问题，不会影响其他表。\n\n* 所有表共用单个文件（`1`）：所有表使用同一个二进制日志文件。这种方法使文件管理更简单，因为文件数量较少。然而，如果某个表仍需保存更新，文件可能会被保留时间较长。如果许多表同时需要更新，这种设置可能会降低性能，因为所有更改都必须等待写入同一个文件。\n\n<!-- request binlog_common -->\n\nCODE_BLOCK_7\n\n<!-- end -->\n\n### 二进制刷新策略\n\n<!-- Example binlog_flush -->\n\n有四种不同的 binlog 刷新策略，由 `binlog_flush` 指令控制：\n\n* `0` - 数据每秒写入磁盘（刷新），并且 Manticore 在刷新后立即启动将其安全写入磁盘的操作（[同步](https://linux.die.net/man/8/sync)）。此方法速度最快，但如果服务器或计算机突然崩溃，某些最近写入但尚未安全写入的数据可能会丢失。\n\n* `1` - 数据在每个事务后立即写入 binlog 并同步。此方法最安全，确保每次更改立即被保存，但写入速度较慢。",
      "russian": "# Бинарное логирование\n\nБинарное логирование служит механизмом восстановления данных таблиц [реального времени](../Creating_a_table/Local_tables/Real-time_table.md). Когда бинарные логи включены, `searchd` записывает каждую транзакцию в binlog-файл и использует его для восстановления после некорректного завершения работы. При корректном завершении работы, RAM-чонки сохраняются на диск, и все binlog-файлы затем удаляются.\n\n## Включение и отключение бинарного логирования\n\nПо умолчанию бинарное логирование включено для защиты целостности данных. В системах Linux, стандартное расположение файлов `binlog.*` в [Plain режиме](../Creating_a_table/Local_tables.md#Defining-table-schema-in-config-%28Plain-mode%29) — `/var/lib/manticore/data/`. В [RT режиме](../Creating_a_table/Local_tables.md#Online-schema-management-%28RT-mode%29) бинарные логи хранятся в папке `<data_dir>/binlog/`, если не указано иное.\n\n### Глобальная конфигурация бинарного логирования\n\n<!-- example binlog_path -->\n\nЧтобы отключить бинарное логирование глобально, установите `binlog_path` в пустое значение в конфигурации `searchd`.\n\nОтключение бинарного логирования требует перезапуска демона и подвергает данные риску при неожиданном завершении работы системы.\n\n<!-- request Example -->\n\nCODE_BLOCK_0\n\n<!-- end -->\n\n<!-- example binlog_path2 -->\n\nВы можете использовать следующую директиву для установки пользовательского пути:\n\n<!-- request Example -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n### Конфигурация бинарного логирования для каждой таблицы\n\n<!-- Example binlog0 -->\n\nДля более точного контроля бинарное логирование можно отключить на уровне таблицы для таблиц реального времени, установив параметр таблицы `binlog` в `0`. Эта опция недоступна для percolate таблиц.\n\n<!-- request Example -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n<!-- Example binlog_alter -->\n\nДля существующих RT таблиц бинарное логирование также можно отключить, изменив параметр `binlog`.\n\n<!-- request Example -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- Example binlog_alter2 -->\n\nЕсли бинарное логирование было ранее отключено, его можно включить снова, установив параметр `binlog` обратно в `1`:\n\n<!-- request Example -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n#### Важные замечания:\n\n* **Зависимость от глобальных настроек**: настройки бинарного логирования на уровне таблицы вступают в силу только если бинарное логирование глобально включено в конфигурации searchd (`binlog_path` не должен быть пустым).\n\n* **Статус бинарного логирования и информация о ID транзакции**: изменение статуса бинарного логирования таблицы вызывает немедленный [сброс таблицы](../Securing_and_compacting_a_table/Flushing_RAM_chunk_to_disk.md#FLUSH-TABLE). Если вы отключаете бинарное логирование для таблицы, её ID транзакции (TID) меняется на `-1`. Это означает, что бинарное логирование не активно и изменения не отслеживаются. Напротив, если вы включаете бинарное логирование для таблицы, её ID транзакции становится неотрицательным числом (ноль или больше). Это означает, что изменения таблицы теперь записываются. Вы можете проверить ID транзакции с помощью команды: `SHOW TABLE <name> STATUS`. ID транзакции отражает, записываются ли изменения таблицы (неотрицательное число) или нет (`-1`).\n\n## Операции\n\nКогда бинарное логирование включено, каждое изменение в RT таблице сохраняется в лог-файл. Если система неожиданно выключается, эти логи автоматически используются при следующем запуске системы для восстановления всех зафиксированных изменений.\n\n### Размер лога\n\n<!-- Example binlog_max_log_size -->\n\nВо время нормальной работы, когда объем записанных данных достигает определенного предела (установленного параметром `binlog_max_log_size`), начинается новый лог-файл. Старые лог-файлы сохраняются до тех пор, пока все изменения в них полностью не обработаны и не сохранены на диск в виде дисковой чанки. Если этот предел установлен в `0`, лог-файлы сохраняются до корректного завершения работы системы. По умолчанию нет ограничения на размер этих файлов.\n\n<!-- request Example -->\n\nCODE_BLOCK_5\n\n<!-- end -->\n\n### Лог-файлы\n\n<!-- example binlog_filename_digits -->\n\nКаждый binlog-файл именуется с нулями в начале номера, например `binlog.0000`, `binlog.0001` и т.д., обычно с четырьмя цифрами. Вы можете изменить количество цифр в номере с помощью настройки `binlog_filename_digits`. Если количество binlog-файлов превысит вместимость текущего количества цифр, количество цифр будет автоматически увеличено для размещения всех файлов.\n\n**Важно**: чтобы изменить количество цифр, сначала необходимо сохранить все данные таблиц и корректно завершить работу системы. Затем удалить старые лог-файлы и перезапустить систему.\n\n<!-- request Example -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n### Стратегии бинарного логирования\n\n<!-- Example binlog_common -->\n\nВы можете выбрать один из двух способов управления бинарными лог-файлами, которые задаются директивой `binlog_common`:\n\n* Отдельный файл для каждой таблицы (по умолчанию, `0`): каждая таблица сохраняет свои изменения в собственном лог-файле. Эта настройка хороша, если у вас много таблиц, которые обновляются в разное время. Она позволяет обновлять таблицы без ожидания других. Также, если возникает проблема с лог-файлом одной таблицы, это не влияет на другие.\n\n* Один файл для всех таблиц (`1`): все таблицы используют один и тот же бинарный лог-файл. Этот метод упрощает управление файлами, так как их меньше. Однако это может привести к тому, что файлы будут храниться дольше, чем нужно, если одна таблица все еще должна сохранить свои обновления. Эта настройка также может замедлить работу, если много таблиц обновляются одновременно, так как все изменения должны ждать записи в один файл.\n\n<!-- request binlog_common -->\n\nCODE_BLOCK_7\n\n<!-- end -->\n\n### Стратегии сброса бинарного лога\n\n<!-- Example binlog_flush -->\n\nСуществует четыре различных стратегии сброса binlog, контролируемые директивой `binlog_flush`:\n\n* `0` - данные записываются на диск (сбрасываются) каждую секунду, и Manticore инициирует их защиту на диске ([syncing](https://linux.die.net/man/8/sync)) сразу после сброса. Этот метод самый быстрый, но если сервер или компьютер внезапно упадет, некоторые недавно записанные данные, которые еще не были защищены, могут быть потеряны.\n\n* `1` - данные записываются в binlog и синхронизируются сразу после каждой транзакции. Этот метод самый безопасный, так как гарантирует немедленное сохранение каждого изменения, но замедляет запись."
    },
    "is_code_or_comment": false
  }
}
