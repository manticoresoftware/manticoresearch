{
  "d10f8e851e5b97ec03755d3629ba8348f8f77caeb3d17973eca0e2399ccd7ad7": {
    "original": "If auto-optimize was previously enabled, you should manually re-enable it after the check is complete by running:\n\nCODE_BLOCK_3\n\n## spelldump\n\nThe `spelldump` command is designed to retrieve the contents from a dictionary file that employs the `ispell` or `MySpell` format. This can be handy when you need to compile word lists for wordforms, as it generates all possible forms for you.\n\nHere's the general syntax:\n\nCODE_BLOCK_4\n\nThe primary parameters are the main file and the affix file of the dictionary. Typically, these are named as `[language-prefix].dict` and `[language-prefix].aff`, respectively. You can find these files in most standard Linux distributions or from numerous online sources.\n\nThe `[result]` parameter is where the extracted dictionary data will be stored, and `[locale-name]` is the parameter used to specify the locale details of your choice.\n\nThere's an optional `-c [file]` option as well. This option allows you to specify a file for case conversion details.\n\nHere are some usage examples:\n\nCODE_BLOCK_5\n\nThe resulting file will list all the words from the dictionary, arranged alphabetically and formatted like a wordforms file. You can then modify this file as per your specific requirements. Here's a sample of what the output file might look like:\n\nCODE_BLOCK_6\n\n## wordbreaker\n\nThe `wordbreaker` tool is designed to deconstruct compound words, a common feature in URLs, into their individual components. For instance, it can dissect \"lordoftherings\" into four separate words or break down `http://manofsteel.warnerbros.com` into \"man of steel warner bros\". This ability enhances search functionality by eliminating the need for prefixes or infixes. To illustrate, a search for \"sphinx\" wouldn't yield \"sphinxsearch\" in the results. However, if you apply `wordbreaker` to disassemble the compound word and index the detached elements, a search will be successful without the file size expansion associated with prefix or infix usage in full-text indexing.\n\nHere are some examples of how to use `wordbreaker`:\n\nCODE_BLOCK_7\n\nThe `-dict` dictionary file is used to separate the input stream into individual words. If no dictionary file is specified, Wordbreaker will look for a file named `wordbreaker-dict.txt` in the current working directory. (Ensure that the dictionary file matches the language of the compound word you're working with.) The `split` command breaks words from the standard input and sends the results to the standard output. The `test` and `bench` commands are also available to assess the splitting quality and measure the performance of the splitting function, respectively.\n\nWordbreaker uses a dictionary to identify individual substrings within a given string. To distinguish between multiple potential splits, it considers the relative frequency of each word in the dictionary. A higher frequency indicates a higher likelihood for a word split. To generate a file of this nature, you can use the `indexer` tool:\n\nCODE_BLOCK_8\n\nwhich will produce a text file named `dict.txt` that contains the 100,000 most frequently occurring words from `myindex`, along with their respective counts. Since this output file is a simple text document, you have the flexibility to manually edit it whenever needed. Feel free to add or remove words as required.\n\n<!-- proofread -->",
    "translations": {
      "chinese": "如果之前启用了自动优化，检查完成后应手动重新启用它，方法是运行：\n\nCODE_BLOCK_3\n\n## spelldump\n\n`spelldump` 命令用于从采用 `ispell` 或 `MySpell` 格式的字典文件中提取内容。当您需要为词形编译单词列表时，这非常有用，因为它会为您生成所有可能的词形。\n\n其一般语法如下：\n\nCODE_BLOCK_4\n\n主要参数是字典的主文件和词缀文件。通常，这些文件分别命名为 `[language-prefix].dict` 和 `[language-prefix].aff`。您可以在大多数标准 Linux 发行版或许多在线资源中找到这些文件。\n\n`[result]` 参数是提取的字典数据将被存储的位置，`[locale-name]` 是用于指定您选择的区域设置的参数。\n\n还有一个可选的 `-c [file]` 选项。此选项允许您指定一个用于大小写转换细节的文件。\n\n以下是一些使用示例：\n\nCODE_BLOCK_5\n\n生成的文件将列出字典中的所有单词，按字母顺序排列，并格式化为类似词形文件的形式。然后，您可以根据具体需求修改此文件。以下是输出文件可能的示例：\n\nCODE_BLOCK_6\n\n## wordbreaker\n\n`wordbreaker` 工具用于拆解复合词，这在 URL 中很常见，将其分解为单独的组成部分。例如，它可以将 \"lordoftherings\" 拆分为四个单词，或将 `http://manofsteel.warnerbros.com` 拆分为 \"man of steel warner bros\"。这种能力增强了搜索功能，无需使用前缀或中缀。例如，搜索 \"sphinx\" 不会在结果中出现 \"sphinxsearch\"。但是，如果您应用 `wordbreaker` 拆解复合词并索引拆分后的元素，搜索将成功，且不会像全文索引中使用前缀或中缀那样导致文件大小膨胀。\n\n以下是一些使用 `wordbreaker` 的示例：\n\nCODE_BLOCK_7\n\n`-dict` 字典文件用于将输入流分割成单个单词。如果未指定字典文件，Wordbreaker 会在当前工作目录中查找名为 `wordbreaker-dict.txt` 的文件。（确保字典文件与您处理的复合词的语言匹配。）`split` 命令从标准输入拆分单词并将结果发送到标准输出。`test` 和 `bench` 命令分别用于评估拆分质量和测量拆分函数的性能。\n\nWordbreaker 使用字典来识别给定字符串中的单个子串。为了区分多种可能的拆分，它会考虑字典中每个单词的相对频率。频率越高，单词拆分的可能性越大。要生成此类文件，您可以使用 `indexer` 工具：\n\nCODE_BLOCK_8\n\n它将生成一个名为 `dict.txt` 的文本文件，包含 `myindex` 中出现频率最高的 100,000 个单词及其各自的计数。由于此输出文件是简单的文本文件，您可以随时手动编辑它。根据需要随意添加或删除单词。\n\n<!-- proofread -->",
      "russian": "Если автооптимизация была включена ранее, вам следует вручную включить её снова после завершения проверки, выполнив:\n\nCODE_BLOCK_3\n\n## spelldump\n\nКоманда `spelldump` предназначена для извлечения содержимого из файла словаря, использующего формат `ispell` или `MySpell`. Это может быть полезно, когда нужно составить списки слов для форм слов, так как она генерирует все возможные формы за вас.\n\nОбщий синтаксис выглядит так:\n\nCODE_BLOCK_4\n\nОсновными параметрами являются основной файл и файл аффиксов словаря. Обычно они называются `[language-prefix].dict` и `[language-prefix].aff` соответственно. Эти файлы можно найти в большинстве стандартных дистрибутивов Linux или в многочисленных онлайн-источниках.\n\nПараметр `[result]` — это место, куда будет сохранён извлечённый словарь, а `[locale-name]` — параметр для указания нужных локалей.\n\nТакже есть необязательный параметр `-c [file]`. Эта опция позволяет указать файл с деталями преобразования регистра.\n\nВот несколько примеров использования:\n\nCODE_BLOCK_5\n\nВ результате получится файл, в котором будут перечислены все слова из словаря, расположенные в алфавитном порядке и отформатированные как файл форм слов. Вы можете затем изменить этот файл в соответствии с вашими конкретными требованиями. Вот пример того, как может выглядеть выходной файл:\n\nCODE_BLOCK_6\n\n## wordbreaker\n\nИнструмент `wordbreaker` предназначен для разбиения составных слов, часто встречающихся в URL, на отдельные компоненты. Например, он может разделить \"lordoftherings\" на четыре отдельных слова или разбить `http://manofsteel.warnerbros.com` на \"man of steel warner bros\". Эта возможность улучшает функциональность поиска, устраняя необходимость в префиксах или инфиксах. Например, поиск по слову \"sphinx\" не выдаст \"sphinxsearch\" в результатах. Однако, если применить `wordbreaker` для разбиения составного слова и индексировать отдельные элементы, поиск будет успешным без увеличения размера файла, связанного с использованием префиксов или инфиксов в полнотекстовом индексировании.\n\nВот несколько примеров использования `wordbreaker`:\n\nCODE_BLOCK_7\n\nФайл словаря `-dict` используется для разделения входного потока на отдельные слова. Если файл словаря не указан, Wordbreaker будет искать файл с именем `wordbreaker-dict.txt` в текущей рабочей директории. (Убедитесь, что файл словаря соответствует языку составного слова, с которым вы работаете.) Команда `split` разбивает слова из стандартного ввода и отправляет результаты в стандартный вывод. Команды `test` и `bench` также доступны для оценки качества разбиения и измерения производительности функции разбиения соответственно.\n\nWordbreaker использует словарь для определения отдельных подстрок в заданной строке. Чтобы различать несколько возможных вариантов разбиения, он учитывает относительную частоту каждого слова в словаре. Более высокая частота указывает на большую вероятность разбиения на это слово. Для создания такого файла можно использовать инструмент `indexer`:\n\nCODE_BLOCK_8\n\nкоторый создаст текстовый файл с именем `dict.txt`, содержащий 100 000 наиболее часто встречающихся слов из `myindex` вместе с их соответствующими количествами. Поскольку этот выходной файл является простым текстовым документом, у вас есть возможность вручную редактировать его в любое время. Не стесняйтесь добавлять или удалять слова по мере необходимости.\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "09349f7914896a3bb64ad4dd0c83a6460b6d9b36684e3584eebbc187151c7ad4": {
    "original": "# Miscellaneous tools\n\n## indextool\n\n`indextool` is a helpful utility that extracts various information about a physical table, excluding `template` or `distributed` tables. Here's the general syntax for utilizing `indextool`:\n\nCODE_BLOCK_0\n\n### Options\n\nThese options are applicable to all commands:\n\n* `--config <file>` (`-c <file>` for short) lets you override the default configuration file names.\n\n* `--quiet` (`-q` for short) suppresses the output of banners and such by `indextool`.\n\n* `--help` (`-h` for short) displays all parameters available in your specific build of `indextool`.\n\n* `-v` displays the version information of your specific `indextool` build.\n\n### Commands\n\nHere are the available commands:\n\n* `--checkconfig` loads and verifies the config file, checking its validity and for any syntax errors.\n\n* `--buildidf DICTFILE1 [DICTFILE2 ...] --out IDFILE` constructs an IDF file from one or more dictionary dumps (refer to `--dumpdict`). The additional parameter `--skip-uniq` will omit unique words (df=1).\n\n* `--build-infixes TABLENAME` generates infixes for a pre-existing dict=keywords table (updates .sph, .spi in place). Use this option for legacy table files already employing dict=keywords, but now requiring infix search support; updating the table files with indextool may be simpler or quicker than recreating them from scratch with indexer.\n\n* `--dumpheader FILENAME.sph` promptly dumps the given table header file without disturbing any other table files or even the config file. The report offers a detailed view of all the table settings, especially the complete attribute and field list.\n\n* `--dumpconfig FILENAME.sph` extracts the table definition from the specified table header file in an (almost) manticore.conf file-compliant format.\n\n* `--dumpheader TABLENAME` dumps table header by table name while searching for the header path in the config file.\n\n* `--dumpdict TABLENAME` dumps the dictionary. An extra `-stats` switch will add the total document count to the dictionary dump. This is necessary for dictionary files used in IDF file creation.\n\n* `--dumpdocids TABLENAME` dumps document IDs by table name.\n\n* `--dumphitlist TABLENAME KEYWORD` dumps all instances (occurrences) of a specified keyword in a given table, with the keyword defined as text.\n\n* `--dumphitlist TABLENAME --wordid ID` dumps all instances (occurrences) of a specific keyword in a given table, with the keyword represented as an internal numeric ID.\n\n* `--dumpkilllist TABLENAME` dumps the kill list contents of the specified table, including targets and flags. It can also be used as `--dumpkilllist FILENAME.spk`.\n\n* `--docextract TBL DOCID` executes a standard table check pass of the entire dictionary/docs/hits, and gathers all the words and hits associated with the requested document. Subsequently, all the words are arranged according to their fields and positions, and the result is printed, grouped by field.\n\n* `--fold TABLENAME OPTFILE` This option helps understand how the tokenizer processes input. You can supply the indextool with text from a file, if specified, or from stdin otherwise. The output will replace separators with spaces (based on your `charset_table` settings) and convert letters in words to lowercase.\n\n* `--htmlstrip TABLENAME` applies the HTML stripper settings for a specified table to filter stdin, and sends the filtering results to stdout. Be aware that the settings will be fetched from manticore.conf, and not from the table header.\n\n* `--mergeidf NODE1.idf [NODE2.idf ...] --out GLOBAL.idf` combines multiple .idf files into a single one. The extra parameter `--skip-uniq` will ignore unique words (df=1).\n\n* `--morph TABLENAME` applies morphology to the given stdin and directs the result to stdout.\n\n* `--check TABLENAME` evaluates the table data files for consistency errors that could be caused by bugs in `indexer` or hardware faults. `--check` is also functional on RT tables, RAM, and disk chunks. Additional options:\n\n    - `--check-id-dups` checks for duplicate document IDs in the plain table and all disk chunks of an RT table\n\n    - `--check-disk-chunk CHUNK_NAME` checks only a specific disk chunk of an RT table. The argument is the numeric extension of the RT table's disk chunk to be checked.\n\n* `--strip-path` removes the path names from all file names referred to from the table (stopwords, wordforms, exceptions, etc). This is helpful when verifying tables built on a different machine with possibly varying path layouts.\n\n* `--rotate` is only compatible with `--check` and determines whether to check the table waiting for rotation, i.e., with a .new extension. This is useful when you wish to validate your table before actually putting it into use.\n\n* `--apply-killlists` loads and applies kill-lists for all tables listed in the config file. Changes are saved in .SPM files. Kill-list files (.SPK) are removed. This can be handy if you want to shift the application of tables from server startup to indexing stage.\n\n### Important Consideration for RT Table Checking\n\n`indextool` cannot fully check an RT table that is currently served by the daemon. When attempting to check an active RT table, you may encounter the following warning:\n\nCODE_BLOCK_1\n\nTo avoid these warning and ensure a proper check of an RT table, consider the following approaches:\n\n- stop the daemon before running `indextool --check`.\n\n- ensure that the RT table is not actively served by the daemon.\n\n- check a separate copy of the RT table instead of the live one.\n\nIf stopping the daemon is not an option, you can prevent unintended modifications to the RT table by executing the following MySQL statement before running `indextool --check`:\n\nCODE_BLOCK_2\n\nThis command prevents the daemon from performing auto-optimization, ensuring that RT table files remain unchanged. After executing this statement, wait until the optimization thread has completely stopped before proceeding with `indextool --check`. This ensures that no disk chunks are unintentionally modified or removed during the check process.",
    "translations": {
      "chinese": "# 杂项工具\n\n## indextool\n\n`indextool` 是一个有用的工具，用于提取有关物理表的各种信息，但不包括 `template` 或 `distributed` 表。以下是使用 `indextool` 的一般语法：\n\nCODE_BLOCK_0\n\n### 选项\n\n这些选项适用于所有命令：\n\n* `--config <file>`（简写为 `-c <file>`）允许您覆盖默认的配置文件名。\n\n* `--quiet`（简写为 `-q`）抑制 `indextool` 输出的横幅等信息。\n\n* `--help`（简写为 `-h`）显示您特定版本的 `indextool` 中可用的所有参数。\n\n* `-v` 显示您特定版本的 `indextool` 的版本信息。\n\n### 命令\n\n以下是可用的命令：\n\n* `--checkconfig` 加载并验证配置文件，检查其有效性及语法错误。\n\n* `--buildidf DICTFILE1 [DICTFILE2 ...] --out IDFILE` 从一个或多个字典转储文件（参见 `--dumpdict`）构建 IDF 文件。额外参数 `--skip-uniq` 会省略唯一词（df=1）。\n\n* `--build-infixes TABLENAME` 为已有的 dict=keywords 表生成中缀（infixes）（就地更新 .sph、.spi 文件）。此选项适用于已经使用 dict=keywords 的旧表文件，但现在需要支持中缀搜索；使用 indextool 更新表文件可能比用 indexer 重新创建更简单或更快。\n\n* `--dumpheader FILENAME.sph` 立即转储指定的表头文件，而不影响其他表文件或配置文件。报告详细显示所有表设置，特别是完整的属性和字段列表。\n\n* `--dumpconfig FILENAME.sph` 以（几乎）符合 manticore.conf 文件格式的方式提取指定表头文件中的表定义。\n\n* `--dumpheader TABLENAME` 通过表名转储表头，同时在配置文件中搜索表头路径。\n\n* `--dumpdict TABLENAME` 转储字典。额外的 `-stats` 开关会在字典转储中添加总文档数。这对于用于 IDF 文件创建的字典文件是必要的。\n\n* `--dumpdocids TABLENAME` 按表名转储文档 ID。\n\n* `--dumphitlist TABLENAME KEYWORD` 转储指定表中指定关键词的所有实例（出现位置），关键词以文本形式定义。\n\n* `--dumphitlist TABLENAME --wordid ID` 转储指定表中指定关键词的所有实例（出现位置），关键词以内部数字 ID 表示。\n\n* `--dumpkilllist TABLENAME` 转储指定表的 kill list 内容，包括目标和标志。也可用作 `--dumpkilllist FILENAME.spk`。\n\n* `--docextract TBL DOCID` 执行整个字典/文档/命中标准表检查，并收集请求文档相关的所有词和命中。随后，所有词按字段和位置排列，结果按字段分组打印。\n\n* `--fold TABLENAME OPTFILE` 此选项帮助理解分词器如何处理输入。您可以向 indextool 提供来自文件的文本（如果指定了文件），否则从标准输入读取。输出将根据您的 `charset_table` 设置将分隔符替换为空格，并将词中的字母转换为小写。\n\n* `--htmlstrip TABLENAME` 对指定表应用 HTML 去除器设置以过滤标准输入，并将过滤结果发送到标准输出。请注意，设置将从 manticore.conf 中获取，而非表头。\n\n* `--mergeidf NODE1.idf [NODE2.idf ...] --out GLOBAL.idf` 将多个 .idf 文件合并为一个。额外参数 `--skip-uniq` 会忽略唯一词（df=1）。\n\n* `--morph TABLENAME` 对给定的标准输入应用形态学处理，并将结果输出到标准输出。\n\n* `--check TABLENAME` 检查表数据文件的一致性错误，这些错误可能由 `indexer` 的缺陷或硬件故障引起。`--check` 也适用于 RT 表、RAM 和磁盘块。附加选项：\n\n    - `--check-id-dups` 检查普通表和 RT 表所有磁盘块中的重复文档 ID\n\n    - `--check-disk-chunk CHUNK_NAME` 仅检查 RT 表的特定磁盘块。参数是要检查的 RT 表磁盘块的数字扩展名。\n\n* `--strip-path` 从表引用的所有文件名中移除路径名（如停用词、词形变化、例外等）。这在验证在不同机器上构建且路径布局可能不同的表时很有用。\n\n* `--rotate` 仅与 `--check` 兼容，决定是否检查等待旋转的表，即带有 .new 扩展名的表。这在您希望在实际使用表之前验证表时很有用。\n\n* `--apply-killlists` 加载并应用配置文件中列出的所有表的 kill-list。更改保存到 .SPM 文件。kill-list 文件 (.SPK) 被删除。如果您想将表的应用从服务器启动阶段转移到索引阶段，这很方便。\n\n### RT 表检查的重要注意事项\n\n`indextool` 无法完全检查当前由守护进程服务的 RT 表。当尝试检查活动的 RT 表时，您可能会遇到以下警告：\n\nCODE_BLOCK_1\n\n为避免这些警告并确保正确检查 RT 表，请考虑以下方法：\n\n- 在运行 `indextool --check` 之前停止守护进程。\n\n- 确保 RT 表未被守护进程主动服务。\n\n- 检查 RT 表的单独副本，而非实时表。\n\n如果无法停止守护进程，您可以在运行 `indextool --check` 之前执行以下 MySQL 语句，以防止对 RT 表的意外修改：\n\nCODE_BLOCK_2\n\n此命令阻止守护进程执行自动优化，确保 RT 表文件保持不变。执行此语句后，等待优化线程完全停止，然后再进行 `indextool --check`。这确保在检查过程中不会无意中修改或删除磁盘块。",
      "russian": "# Различные инструменты\n\n## indextool\n\n`indextool` — полезная утилита, которая извлекает различную информацию о физической таблице, исключая `template` или `distributed` таблицы. Вот общий синтаксис использования `indextool`:\n\nCODE_BLOCK_0\n\n### Опции\n\nЭти опции применимы ко всем командам:\n\n* `--config <file>` (`-c <file>` для краткости) позволяет переопределить имена файлов конфигурации по умолчанию.\n\n* `--quiet` (`-q` для краткости) подавляет вывод баннеров и подобного от `indextool`.\n\n* `--help` (`-h` для краткости) отображает все параметры, доступные в вашей конкретной сборке `indextool`.\n\n* `-v` отображает информацию о версии вашей конкретной сборки `indextool`.\n\n### Команды\n\nДоступные команды:\n\n* `--checkconfig` загружает и проверяет файл конфигурации, проверяя его валидность и наличие синтаксических ошибок.\n\n* `--buildidf DICTFILE1 [DICTFILE2 ...] --out IDFILE` строит IDF файл из одного или нескольких дампов словарей (см. `--dumpdict`). Дополнительный параметр `--skip-uniq` пропустит уникальные слова (df=1).\n\n* `--build-infixes TABLENAME` генерирует инфиксы для уже существующей таблицы dict=keywords (обновляет .sph, .spi на месте). Используйте эту опцию для устаревших файлов таблиц, которые уже используют dict=keywords, но теперь требуют поддержки инфиксного поиска; обновление файлов таблиц с помощью indextool может быть проще или быстрее, чем их пересоздание с нуля с помощью indexer.\n\n* `--dumpheader FILENAME.sph` быстро выводит указанный файл заголовка таблицы без изменения других файлов таблицы или даже файла конфигурации. Отчет предоставляет подробный обзор всех настроек таблицы, особенно полный список атрибутов и полей.\n\n* `--dumpconfig FILENAME.sph` извлекает определение таблицы из указанного файла заголовка таблицы в формате, (почти) совместимом с файлом manticore.conf.\n\n* `--dumpheader TABLENAME` выводит заголовок таблицы по имени таблицы, при этом путь к заголовку ищется в файле конфигурации.\n\n* `--dumpdict TABLENAME` выводит словарь. Дополнительный переключатель `-stats` добавит общее количество документов к дампу словаря. Это необходимо для файлов словаря, используемых при создании IDF файла.\n\n* `--dumpdocids TABLENAME` выводит идентификаторы документов по имени таблицы.\n\n* `--dumphitlist TABLENAME KEYWORD` выводит все вхождения указанного ключевого слова в заданной таблице, при этом ключевое слово задано как текст.\n\n* `--dumphitlist TABLENAME --wordid ID` выводит все вхождения конкретного ключевого слова в заданной таблице, при этом ключевое слово представлено внутренним числовым ID.\n\n* `--dumpkilllist TABLENAME` выводит содержимое kill-листа указанной таблицы, включая цели и флаги. Также может использоваться как `--dumpkilllist FILENAME.spk`.\n\n* `--docextract TBL DOCID` выполняет стандартную проверку таблицы всей словарной базы/документов/вхождений и собирает все слова и вхождения, связанные с запрошенным документом. Затем все слова упорядочиваются по полям и позициям, и результат выводится, сгруппированный по полям.\n\n* `--fold TABLENAME OPTFILE` Эта опция помогает понять, как токенизатор обрабатывает ввод. Вы можете передать indextool текст из файла, если он указан, или из stdin в противном случае. Вывод заменит разделители пробелами (на основе настроек `charset_table`) и преобразует буквы в словах в нижний регистр.\n\n* `--htmlstrip TABLENAME` применяет настройки HTML-стриппера для указанной таблицы для фильтрации stdin и отправляет результаты фильтрации в stdout. Учтите, что настройки будут взяты из manticore.conf, а не из заголовка таблицы.\n\n* `--mergeidf NODE1.idf [NODE2.idf ...] --out GLOBAL.idf` объединяет несколько .idf файлов в один. Дополнительный параметр `--skip-uniq` пропустит уникальные слова (df=1).\n\n* `--morph TABLENAME` применяет морфологию к входным данным из stdin и направляет результат в stdout.\n\n* `--check TABLENAME` проверяет файлы данных таблицы на ошибки согласованности, которые могут быть вызваны ошибками в `indexer` или аппаратными сбоями. `--check` также работает с RT таблицами, RAM и дисковыми чанками. Дополнительные опции:\n\n    - `--check-id-dups` проверяет дубликаты идентификаторов документов в простой таблице и во всех дисковых чанках RT таблицы\n\n    - `--check-disk-chunk CHUNK_NAME` проверяет только конкретный дисковый чанк RT таблицы. Аргумент — числовое расширение дискового чанка RT таблицы для проверки.\n\n* `--strip-path` удаляет пути из всех имен файлов, на которые ссылается таблица (стоп-слова, словоформы, исключения и т.д.). Это полезно при проверке таблиц, собранных на другой машине с возможно отличающейся структурой путей.\n\n* `--rotate` совместимо только с `--check` и определяет, проверять ли таблицу, ожидающую ротации, т.е. с расширением .new. Это полезно, если вы хотите проверить таблицу перед её фактическим использованием.\n\n* `--apply-killlists` загружает и применяет kill-листы для всех таблиц, перечисленных в файле конфигурации. Изменения сохраняются в .SPM файлах. Файлы kill-листов (.SPK) удаляются. Это удобно, если вы хотите перенести применение таблиц с запуска сервера на этап индексирования.\n\n### Важное замечание по проверке RT таблиц\n\n`indextool` не может полностью проверить RT таблицу, которая в данный момент обслуживается демоном. При попытке проверить активную RT таблицу вы можете столкнуться с следующим предупреждением:\n\nCODE_BLOCK_1\n\nЧтобы избежать этих предупреждений и обеспечить корректную проверку RT таблицы, рассмотрите следующие подходы:\n\n- остановите демон перед запуском `indextool --check`.\n\n- убедитесь, что RT таблица не обслуживается демоном.\n\n- проверьте отдельную копию RT таблицы вместо живой.\n\nЕсли остановка демона невозможна, вы можете предотвратить нежелательные изменения RT таблицы, выполнив следующий MySQL-запрос перед запуском `indextool --check`:\n\nCODE_BLOCK_2\n\nЭта команда предотвращает автоматическую оптимизацию демоном, гарантируя, что файлы RT таблицы останутся неизменными. После выполнения этого запроса дождитесь полного завершения потока оптимизации перед продолжением с `indextool --check`. Это гарантирует, что во время проверки не будут случайно изменены или удалены дисковые чанки."
    },
    "is_code_or_comment": false
  }
}
