{
  "67c194bbd96050806424150b2e3bd5da949f3def7b00db7811f7fc7938b89900": {
    "original": "# Query profile\n\n<!-- example SHOW PROFILE -->\n\nThe SQL `SHOW PROFILE` statement and the `\"profile\": true` JSON interface option both provide a detailed execution profile of the executed query. In the case of SQL, profiling must be enabled in the current session **before** running the statement to be instrumented. This can be accomplished with the `SET profiling=1` statement. By default, profiling is disabled to prevent potential performance implications, resulting in an empty profile if not enabled.\n\nEach profiling result includes the following fields:\n\n* `Status` column briefly describes the specific state where the time was spent. See below.\n\n* `Duration` column shows the wall clock time, in seconds.\n\n* `Switches` column displays the number of times the query engine changed to the given state. These are merely logical engine state switches and **not** any OS level context switches or function calls (although some sections might actually map to function calls), and they do **not** have any direct effect on performance. In a sense, the number of switches is just the number of times the respective instrumentation point was hit.\n\n* `Percent` column shows the percentage of time spent in this state.\n\nStates in the profile are returned in a prerecorded order that roughly maps (but is **not** identical) to the actual query order.\n\nThe list of states may (and will) change over time as we refine the states. Here's a brief description of the currently profiled states.\n\n* `unknown`: generic catch-all state. Accounts for not-yet-instrumented code or small miscellaneous tasks that don't really belong in any other state but are too small to warrant their own state.\n\n* `net_read`: reading the query from the network (i.e., the application).\n\n* `io`: generic file IO time.\n\n* `dist_connect`: connecting to remote agents in the distributed table case.\n\n* `sql_parse`: parsing the SQL syntax.\n\n* `dict_setup`: dictionary and tokenizer setup.\n\n* `parse`: parsing the full-text query syntax.\n\n* `transforms`: full-text query transformations (wildcard and other expansions, simplification, etc.).\n\n* `init`: initializing the query evaluation.\n\n* `open`: opening the table files.\n\n* `read_docs`: IO time spent reading document lists.\n\n* `read_hits`: IO time spent reading keyword positions.\n\n* `get_docs`: computing the matching documents.\n\n* `get_hits`: computing the matching positions.\n\n* `filter`: filtering the full-text matches.\n\n* `rank`: computing the relevance rank.\n\n* `sort`: sorting the matches.\n\n* `finalize`: finalizing the per-table search result set (last stage expressions, etc.).\n\n* `dist_wait`: waiting for remote results from agents in the distributed table case.\n\n* `aggregate`: aggregating multiple result sets.\n\n* `net_write`: writing the result set to the network.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- response SQL -->\n\nCODE_BLOCK_1\n\n<!-- request JSON -->\n\nCODE_BLOCK_2\n\n<!-- response JSON -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 查询分析\n\n<!-- example SHOW PROFILE -->\n\nSQL 语句 `SHOW PROFILE` 和 JSON 接口选项 `\"profile\": true` 都提供了已执行查询的详细执行分析。在 SQL 的情况下，必须在当前会话中**在**运行要分析的语句之前启用分析。这可以通过执行 `SET profiling=1` 语句来完成。默认情况下，分析是禁用的，以防止潜在的性能影响，如果未启用，则分析结果为空。\n\n每个分析结果包含以下字段：\n\n* `Status` 列简要描述了时间花费的具体状态。见下文。\n\n* `Duration` 列显示了实际时间，单位为秒。\n\n* `Switches` 列显示查询引擎切换到给定状态的次数。这些仅是逻辑引擎状态切换，**不是**任何操作系统级别的上下文切换或函数调用（尽管某些部分可能实际上映射到函数调用），并且它们**不会**对性能产生任何直接影响。从某种意义上说，切换次数只是相应分析点被触发的次数。\n\n* `Percent` 列显示在该状态下花费时间的百分比。\n\n分析中的状态按预录顺序返回，该顺序大致映射（但**不**完全相同）到实际查询顺序。\n\n状态列表可能（且会）随着我们对状态的细化而变化。以下是当前分析状态的简要说明。\n\n* `unknown`：通用的捕获状态。用于尚未分析的代码或不属于任何其他状态但又太小而不值得单独列出的杂项任务。\n\n* `net_read`：从网络（即应用程序）读取查询。\n\n* `io`：通用文件 IO 时间。\n\n* `dist_connect`：在分布式表情况下连接远程代理。\n\n* `sql_parse`：解析 SQL 语法。\n\n* `dict_setup`：字典和分词器设置。\n\n* `parse`：解析全文查询语法。\n\n* `transforms`：全文查询转换（通配符和其他扩展，简化等）。\n\n* `init`：初始化查询评估。\n\n* `open`：打开表文件。\n\n* `read_docs`：读取文档列表的 IO 时间。\n\n* `read_hits`：读取关键字位置的 IO 时间。\n\n* `get_docs`：计算匹配的文档。\n\n* `get_hits`：计算匹配的位置。\n\n* `filter`：过滤全文匹配。\n\n* `rank`：计算相关性排名。\n\n* `sort`：对匹配结果排序。\n\n* `finalize`：完成每个表的搜索结果集（最后阶段表达式等）。\n\n* `dist_wait`：在分布式表情况下等待远程代理的结果。\n\n* `aggregate`：聚合多个结果集。\n\n* `net_write`：将结果集写入网络。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- response SQL -->\n\nCODE_BLOCK_1\n\n<!-- request JSON -->\n\nCODE_BLOCK_2\n\n<!-- response JSON -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "# Профиль запроса\n\n<!-- example SHOW PROFILE -->\n\nSQL-оператор `SHOW PROFILE` и опция JSON-интерфейса `\"profile\": true` предоставляют подробный профиль выполнения выполненного запроса. В случае SQL профилирование должно быть включено в текущей сессии **до** выполнения инструктируемого оператора. Это можно сделать с помощью оператора `SET profiling=1`. По умолчанию профилирование отключено, чтобы избежать возможных последствий для производительности, в результате чего профиль будет пустым, если оно не включено.\n\nКаждый результат профилирования включает следующие поля:\n\n* Столбец `Status` кратко описывает конкретное состояние, в котором было затрачено время. См. ниже.\n\n* Столбец `Duration` показывает время по настенным часам, в секундах.\n\n* Столбец `Switches` отображает количество раз, когда движок запроса переключался в данное состояние. Это лишь логические переключения состояния движка и **не** переключения контекста на уровне ОС или вызовы функций (хотя некоторые разделы могут фактически соответствовать вызовам функций), и они **не** оказывают прямого влияния на производительность. В некотором смысле, количество переключений — это просто количество срабатываний соответствующей точки инструментирования.\n\n* Столбец `Percent` показывает процент времени, проведённого в этом состоянии.\n\nСостояния в профиле возвращаются в заранее записанном порядке, который примерно соответствует (но **не** идентичен) фактическому порядку выполнения запроса.\n\nСписок состояний может (и будет) меняться со временем по мере уточнения состояний. Вот краткое описание текущих профилируемых состояний.\n\n* `unknown`: универсальное состояние для всего прочего. Учитывает ещё не инструментированный код или мелкие разовые задачи, которые не относятся ни к одному другому состоянию, но слишком малы, чтобы выделять для них отдельное состояние.\n\n* `net_read`: чтение запроса из сети (т.е. из приложения).\n\n* `io`: общее время файлового ввода-вывода.\n\n* `dist_connect`: подключение к удалённым агентам в случае распределённой таблицы.\n\n* `sql_parse`: разбор синтаксиса SQL.\n\n* `dict_setup`: настройка словаря и токенизатора.\n\n* `parse`: разбор синтаксиса полнотекстового запроса.\n\n* `transforms`: преобразования полнотекстового запроса (подстановки, расширения, упрощения и т.п.).\n\n* `init`: инициализация выполнения запроса.\n\n* `open`: открытие файлов таблицы.\n\n* `read_docs`: время ввода-вывода, затраченное на чтение списков документов.\n\n* `read_hits`: время ввода-вывода, затраченное на чтение позиций ключевых слов.\n\n* `get_docs`: вычисление совпадающих документов.\n\n* `get_hits`: вычисление совпадающих позиций.\n\n* `filter`: фильтрация полнотекстовых совпадений.\n\n* `rank`: вычисление релевантного ранга.\n\n* `sort`: сортировка совпадений.\n\n* `finalize`: финализация набора результатов поиска по таблице (выражения последнего этапа и т.п.).\n\n* `dist_wait`: ожидание удалённых результатов от агентов в случае распределённой таблицы.\n\n* `aggregate`: агрегирование нескольких наборов результатов.\n\n* `net_write`: запись набора результатов в сеть.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- response SQL -->\n\nCODE_BLOCK_1\n\n<!-- request JSON -->\n\nCODE_BLOCK_2\n\n<!-- response JSON -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
