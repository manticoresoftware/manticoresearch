{
  "bf0c1d4d505db869b7a6f7486743d92ef2fa41bb46d853884a72c53bca271169": {
    "original": "It includes the following additional entries:\n\n* `Setup` - Time spent on the initial setup of the matching process, such as parsing docs and setting options\n\n* `Queries failed` - Number of queries that failed\n\n* `Fast rejected queries` - Number of queries that were not fully evaluated but quickly matched and rejected using filters or other conditions\n\n* `Time per query` - Detailed time for each query\n\n* `Time of matched queries` - Total time spent on queries that matched any documents\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_17\n\n<!-- response SQL -->\n\nCODE_BLOCK_18\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "它包括以下附加条目：\n\n* `Setup` - 匹配过程初始设置所花费的时间，例如解析文档和设置选项\n\n* `Queries failed` - 失败的查询数量\n\n* `Fast rejected queries` - 未完全评估但通过过滤器或其他条件快速匹配并拒绝的查询数量\n\n* `Time per query` - 每个查询的详细时间\n\n* `Time of matched queries` - 匹配到任何文档的查询所花费的总时间\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_17\n\n<!-- response SQL -->\n\nCODE_BLOCK_18\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "Он включает следующие дополнительные записи:\n\n* `Setup` - Время, затраченное на начальную настройку процесса сопоставления, например, разбор документов и установку параметров\n\n* `Queries failed` - Количество запросов, которые завершились с ошибкой\n\n* `Fast rejected queries` - Количество запросов, которые не были полностью оценены, но быстро сопоставлены и отклонены с использованием фильтров или других условий\n\n* `Time per query` - Подробное время для каждого запроса\n\n* `Time of matched queries` - Общее время, затраченное на запросы, которые совпали с любыми документами\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_17\n\n<!-- response SQL -->\n\nCODE_BLOCK_18\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "a03f29d512dc9ed309f0f067140388dd7e65d7d4ec2ae27001a89be05e1ce59d": {
    "original": "# SHOW META\n\nCODE_BLOCK_0\n\n<!-- example show meta -->\n\n`SHOW META` is an SQL statement that displays additional meta-information about the processed query, including the query time, keyword statistics, and information about the secondary indexes used. The syntax is:\n\nThe included items are:\n\n* `total`: The number of matches that were actually retrieved and sent to the client. This value is typically limited by the [LIMIT/size](../Searching/Pagination.md#Pagination-of-search-results) search option.\n\n* `total_found`:\n\n  - The estimated total number of matches for the query in the index. If you need the exact number of matches, use `SELECT COUNT(*)` instead of relying on this value.\n\n  - For queries with `GROUP BY`, `total_found` represents the number of groups instead of individual matches.\n\n  - For [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) queries, `total_found` still represents the number of groups, regardless of the value of `N`.\n\n* `total_relation`: Indicates whether the `total_found` value is exact or an estimate.\n\n  - If Manticore cannot determine the precise `total_found` value, this field will display `total_relation: gte`, meaning the actual number of matches is **Greater Than or Equal** to the reported `total_found`.\n\n  - If the `total_found` value is exact, `total_relation: eq` will be displayed.\n\n* `time`: The duration (in seconds) it took to process the search query.\n\n* `keyword[N]`: The n-th keyword used in the search query. Note that the keyword can be presented as a wildcard, e.g., `abc*`.\n\n* `docs[N]`: The total number of documents (or records) containing the n-th keyword from the search query. If the keyword is presented as a wildcard, this value represents the sum of documents for all expanded sub-keywords, potentially exceeding the actual number of matched documents.\n\n* `hits[N]`: The total number of occurrences (or hits) of the n-th keyword across all documents.\n\n* `index`: Information about the utilized index (e.g., secondary index).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- response SQL -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n<!-- example show meta iostats cpustats -->\n\n`SHOW META` can display I/O and CPU counters, but they will only be available if searchd was started with the `--iostats` and `--cpustats` switches, respectively.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- response SQL -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n<!-- example show meta predicted_time -->\n\nAdditional values, such as `predicted_time`, `dist_predicted_time`, `local_fetched_docs`, `local_fetched_hits`, `local_fetched_skips`, and their respective `dist_fetched_*` counterparts, will only be available if `searchd` was configured with [predicted time costs](../Server_settings/Searchd.md#predicted_time_costs) and the query included `predicted_time` in the `OPTION` clause.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- response SQL -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n<!-- example show meta single statement -->\n\n`SHOW META` must be executed immediately after the query in the **same** session. Since some MySQL connectors/libraries use connection pools, running `SHOW META` in a separate statement can lead to unexpected results, such as retrieving metadata from another query. In these cases (and generally recommended), run a multiple statement containing both the query and `SHOW META`. Some connectors/libraries support multi-queries within the same method for a single statement, while others may require the use of a dedicated method for multi-queries or setting specific options during connection setup.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_7\n\n<!-- response SQL -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!-- example SHOW META LIKE -->\n\nYou can also use the optional LIKE clause, which allows you to select only the variables that match a specific pattern. The pattern syntax follows standard SQL wildcards, where `%` represents any number of any characters, and `_` represents a single character.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- response SQL -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n## SHOW META and facets\n\n<!-- example show meta facets -->\n\nWhen utilizing [faceted search](../Searching/Faceted_search.md), you can examine the `multiplier` field in the `SHOW META` output to determine how many queries were executed in an optimized group.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_11\n\n<!-- response SQL -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n## SHOW META and query optimizer\n\n<!-- example of show meta vs query optimizer -->\n\nWhen the [cost-based query optimizer](../Searching/Cost_based_optimizer.md) chooses to use `DocidIndex`, `ColumnarScan`, or `SecondaryIndex` instead of a plain filter, this is reflected in the `SHOW META` command.\n\nThe `index` variable displays the names and types of secondary indexes used during query execution. The percentage indicates how many disk chunks (in the case of an RT table) or pseudo shards (in the case of a plain table) utilized the secondary index.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_13\n\n<!-- response SQL -->\n\nCODE_BLOCK_14\n\n<!-- end -->\n\n## SHOW META for PQ tables\n\n<!-- example show meta PQ -->\n\n`SHOW META` can be used after executing a [CALL PQ](../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ) statement, in which case it provides different output.\n\n`SHOW META` following a `CALL PQ` statement includes:\n\n* `total` - Total time spent on matching the document(s)\n\n* `queries_matched` - Number of stored queries that match the document(s)\n\n* `document_matches` - Number of documents that matched the queries stored in the table\n\n* `total_queries_stored` - Total number of queries stored in the table\n\n* `term_only_queries` - Number of queries in the table that have terms; the remaining queries use extended query syntax.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_15\n\n<!-- response SQL -->\n\nCODE_BLOCK_16\n\n<!-- end -->\n\n<!-- example call pq verbose meta  -->\n\nUsing `CALL PQ` with a `verbose` option provides more detailed output.",
    "translations": {
      "chinese": "# SHOW META\n\nCODE_BLOCK_0\n\n<!-- example show meta -->\n\n`SHOW META` 是一个 SQL 语句，用于显示有关处理查询的附加元信息，包括查询时间、关键字统计以及使用的二级索引信息。语法如下：\n\n包含的项目有：\n\n* `total`：实际检索并发送给客户端的匹配数。该值通常受 [LIMIT/size](../Searching/Pagination.md#Pagination-of-search-results) 搜索选项的限制。\n\n* `total_found`：\n\n  - 索引中查询的估计匹配总数。如果需要精确的匹配数，请使用 `SELECT COUNT(*)`，而不是依赖此值。\n\n  - 对于带有 `GROUP BY` 的查询，`total_found` 表示组的数量，而非单个匹配数。\n\n  - 对于 [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) 查询，`total_found` 仍表示组的数量，无论 `N` 的值是多少。\n\n* `total_relation`：指示 `total_found` 值是精确的还是估计的。\n\n  - 如果 Manticore 无法确定精确的 `total_found` 值，此字段将显示 `total_relation: gte`，表示实际匹配数**大于或等于**报告的 `total_found`。\n\n  - 如果 `total_found` 值是精确的，则显示 `total_relation: eq`。\n\n* `time`：处理搜索查询所用的时间（秒）。\n\n* `keyword[N]`：搜索查询中使用的第 n 个关键字。注意关键字可以是通配符形式，例如 `abc*`。\n\n* `docs[N]`：包含搜索查询中第 n 个关键字的文档（或记录）总数。如果关键字是通配符形式，此值表示所有展开子关键字的文档总和，可能超过实际匹配文档数。\n\n* `hits[N]`：第 n 个关键字在所有文档中出现的总次数（命中数）。\n\n* `index`：所使用索引的信息（例如二级索引）。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- response SQL -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n<!-- example show meta iostats cpustats -->\n\n`SHOW META` 可以显示 I/O 和 CPU 计数器，但仅当 searchd 启动时带有 `--iostats` 和 `--cpustats` 参数时才可用。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- response SQL -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n<!-- example show meta predicted_time -->\n\n额外的值，如 `predicted_time`、`dist_predicted_time`、`local_fetched_docs`、`local_fetched_hits`、`local_fetched_skips` 及其对应的 `dist_fetched_*`，仅在 `searchd` 配置了[预测时间成本](../Server_settings/Searchd.md#predicted_time_costs)且查询的 `OPTION` 子句中包含 `predicted_time` 时可用。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- response SQL -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n<!-- example show meta single statement -->\n\n`SHOW META` 必须在**同一**会话中紧接查询之后执行。由于某些 MySQL 连接器/库使用连接池，单独执行 `SHOW META` 可能导致意外结果，例如获取到其他查询的元数据。在这些情况下（且通常推荐），应执行包含查询和 `SHOW META` 的多语句。一些连接器/库支持在同一方法中执行多查询，而其他可能需要专用方法或在连接设置时配置特定选项。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_7\n\n<!-- response SQL -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!-- example SHOW META LIKE -->\n\n你也可以使用可选的 LIKE 子句，只选择匹配特定模式的变量。模式语法遵循标准 SQL 通配符，其中 `%` 表示任意数量的任意字符，`_` 表示单个字符。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- response SQL -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n## SHOW META 和 facets\n\n<!-- example show meta facets -->\n\n使用[分面搜索](../Searching/Faceted_search.md)时，可以查看 `SHOW META` 输出中的 `multiplier` 字段，以确定优化分组中执行了多少查询。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_11\n\n<!-- response SQL -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n## SHOW META 和查询优化器\n\n<!-- example of show meta vs query optimizer -->\n\n当[基于成本的查询优化器](../Searching/Cost_based_optimizer.md)选择使用 `DocidIndex`、`ColumnarScan` 或 `SecondaryIndex` 而非简单过滤器时，`SHOW META` 命令会反映这一点。\n\n`index` 变量显示查询执行期间使用的二级索引的名称和类型。百分比表示使用二级索引的磁盘块数量（RT 表情况）或伪分片数量（普通表情况）。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_13\n\n<!-- response SQL -->\n\nCODE_BLOCK_14\n\n<!-- end -->\n\n## SHOW META 用于 PQ 表\n\n<!-- example show meta PQ -->\n\n`SHOW META` 可在执行[CALL PQ](../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ) 语句后使用，此时输出不同。\n\n`CALL PQ` 语句后执行的 `SHOW META` 包含：\n\n* `total` - 匹配文档所花费的总时间\n\n* `queries_matched` - 匹配文档的存储查询数量\n\n* `document_matches` - 匹配表中存储查询的文档数量\n\n* `total_queries_stored` - 表中存储的查询总数\n\n* `term_only_queries` - 表中包含词项的查询数量；其余查询使用扩展查询语法。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_15\n\n<!-- response SQL -->\n\nCODE_BLOCK_16\n\n<!-- end -->\n\n<!-- example call pq verbose meta  -->\n\n使用带有 `verbose` 选项的 `CALL PQ` 可提供更详细的输出。",
      "russian": "# SHOW META\n\nCODE_BLOCK_0\n\n<!-- example show meta -->\n\n`SHOW META` — это SQL-запрос, который отображает дополнительную метаинформацию о выполненном запросе, включая время выполнения запроса, статистику по ключевым словам и информацию о используемых вторичных индексах. Синтаксис:\n\nВключённые элементы:\n\n* `total`: Количество совпадений, которые фактически были извлечены и отправлены клиенту. Это значение обычно ограничивается опцией поиска [LIMIT/size](../Searching/Pagination.md#Pagination-of-search-results).\n\n* `total_found`:\n\n  - Оценочное общее количество совпадений для запроса в индексе. Если вам нужно точное количество совпадений, используйте `SELECT COUNT(*)` вместо опоры на это значение.\n\n  - Для запросов с `GROUP BY` `total_found` представляет количество групп, а не отдельных совпадений.\n\n  - Для запросов [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) `total_found` по-прежнему представляет количество групп, независимо от значения `N`.\n\n* `total_relation`: Указывает, является ли значение `total_found` точным или оценочным.\n\n  - Если Manticore не может определить точное значение `total_found`, в этом поле будет отображено `total_relation: gte`, что означает, что фактическое количество совпадений **больше или равно** указанному `total_found`.\n\n  - Если значение `total_found` точное, будет отображено `total_relation: eq`.\n\n* `time`: Время (в секундах), затраченное на обработку поискового запроса.\n\n* `keyword[N]`: n-й ключевой запрос, использованный в поисковом запросе. Обратите внимание, что ключевое слово может быть представлено с использованием подстановочного знака, например, `abc*`.\n\n* `docs[N]`: Общее количество документов (или записей), содержащих n-й ключевой запрос из поискового запроса. Если ключевое слово представлено с подстановочным знаком, это значение представляет сумму документов для всех расширенных подзапросов, что может превышать фактическое количество совпавших документов.\n\n* `hits[N]`: Общее количество вхождений (или попаданий) n-го ключевого слова во всех документах.\n\n* `index`: Информация об используемом индексе (например, вторичном индексе).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- response SQL -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n<!-- example show meta iostats cpustats -->\n\n`SHOW META` может отображать счётчики ввода-вывода и CPU, но они будут доступны только если searchd был запущен с переключателями `--iostats` и `--cpustats` соответственно.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- response SQL -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n<!-- example show meta predicted_time -->\n\nДополнительные значения, такие как `predicted_time`, `dist_predicted_time`, `local_fetched_docs`, `local_fetched_hits`, `local_fetched_skips` и их соответствующие аналоги `dist_fetched_*`, будут доступны только если `searchd` был настроен с [предсказанными затратами времени](../Server_settings/Searchd.md#predicted_time_costs) и запрос включал `predicted_time` в опции `OPTION`.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- response SQL -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n<!-- example show meta single statement -->\n\n`SHOW META` должен выполняться сразу после запроса в **той же** сессии. Поскольку некоторые MySQL-коннекторы/библиотеки используют пулы соединений, выполнение `SHOW META` в отдельном запросе может привести к неожиданным результатам, например, получению метаданных другого запроса. В таких случаях (и в общем случае рекомендуется) выполняйте множественный запрос, содержащий и сам запрос, и `SHOW META`. Некоторые коннекторы/библиотеки поддерживают мультизапросы в одном методе для одного запроса, в то время как другие могут требовать использования специального метода для мультизапросов или установки определённых опций при настройке соединения.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_7\n\n<!-- response SQL -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!-- example SHOW META LIKE -->\n\nВы также можете использовать необязательное выражение LIKE, которое позволяет выбрать только переменные, соответствующие определённому шаблону. Синтаксис шаблона соответствует стандартным SQL-подстановочным знакам, где `%` обозначает любое количество любых символов, а `_` — один символ.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- response SQL -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n## SHOW META и фасеты\n\n<!-- example show meta facets -->\n\nПри использовании [фасетного поиска](../Searching/Faceted_search.md) вы можете проверить поле `multiplier` в выводе `SHOW META`, чтобы определить, сколько запросов было выполнено в оптимизированной группе.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_11\n\n<!-- response SQL -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n## SHOW META и оптимизатор запросов\n\n<!-- example of show meta vs query optimizer -->\n\nКогда [оптимизатор запросов на основе стоимости](../Searching/Cost_based_optimizer.md) выбирает использование `DocidIndex`, `ColumnarScan` или `SecondaryIndex` вместо простого фильтра, это отражается в команде `SHOW META`.\n\nПеременная `index` отображает имена и типы вторичных индексов, использованных во время выполнения запроса. Процент указывает, сколько дисковых чанков (в случае RT-таблицы) или псевдо-шард (в случае простой таблицы) использовали вторичный индекс.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_13\n\n<!-- response SQL -->\n\nCODE_BLOCK_14\n\n<!-- end -->\n\n## SHOW META для PQ таблиц\n\n<!-- example show meta PQ -->\n\n`SHOW META` можно использовать после выполнения [CALL PQ](../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ), в этом случае он выдаёт другой вывод.\n\n`SHOW META` после выполнения `CALL PQ` включает:\n\n* `total` — Общее время, затраченное на сопоставление документа(ов)\n\n* `queries_matched` — Количество сохранённых запросов, которые совпали с документом(ами)\n\n* `document_matches` — Количество документов, которые совпали с запросами, сохранёнными в таблице\n\n* `total_queries_stored` — Общее количество запросов, сохранённых в таблице\n\n* `term_only_queries` — Количество запросов в таблице, которые содержат термы; остальные запросы используют расширенный синтаксис запросов.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_15\n\n<!-- response SQL -->\n\nCODE_BLOCK_16\n\n<!-- end -->\n\n<!-- example call pq verbose meta  -->\n\nИспользование `CALL PQ` с опцией `verbose` предоставляет более подробный вывод."
    },
    "is_code_or_comment": false
  },
  "ec5562375af2320902b544432a32eb2bd91770bac4cd76cf6d69d0240609f489": {
    "original": "`SHOW META` can be used after executing a [CALL PQ](../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ) statement, in which case it provides different output.\n\n`SHOW META` following a `CALL PQ` statement includes:\n\n* `total` - Total time spent on matching the document(s)\n\n* `queries_matched` - Number of stored queries that match the document(s)\n\n* `document_matches` - Number of documents that matched the queries stored in the table\n\n* `total_queries_stored` - Total number of queries stored in the table\n\n* `term_only_queries` - Number of queries in the table that have terms; the remaining queries use extended query syntax.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_29\n\n<!-- response SQL -->\n\nCODE_BLOCK_30\n\n<!-- end -->\n\n<!-- example call pq verbose meta  -->\n\nUsing `CALL PQ` with a `verbose` option provides more detailed output.\n\nIt includes the following additional entries:\n\n* `Setup` - Time spent on the initial setup of the matching process, such as parsing docs and setting options\n\n* `Queries failed` - Number of queries that failed\n\n* `Fast rejected queries` - Number of queries that were not fully evaluated but quickly matched and rejected using filters or other conditions\n\n* `Time per query` - Detailed time for each query\n\n* `Time of matched queries` - Total time spent on queries that matched any documents\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_31\n\n<!-- response SQL -->\n\nCODE_BLOCK_32\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "`SHOW META` 可在执行 [CALL PQ](../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ) 语句后使用，此时它提供不同的输出。\n\n紧跟 `CALL PQ` 语句之后的 `SHOW META` 包括：\n\n* `total` - 匹配文档所花费的总时间\n\n* `queries_matched` - 匹配文档的存储查询数量\n\n* `document_matches` - 匹配表中存储查询的文档数量\n\n* `total_queries_stored` - 表中存储的查询总数\n\n* `term_only_queries` - 表中包含词条的查询数量；其余查询使用扩展查询语法。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_29\n\n<!-- response SQL -->\n\nCODE_BLOCK_30\n\n<!-- end -->\n\n<!-- example call pq verbose meta  -->\n\n使用带有 `verbose` 选项的 `CALL PQ` 可提供更详细的输出。\n\n它包括以下附加条目：\n\n* `Setup` - 匹配过程初始设置所花时间，如解析文档和设置选项\n\n* `Queries failed` - 失败的查询数量\n\n* `Fast rejected queries` - 使用过滤器或其他条件快速匹配并拒绝的查询数量，这些查询未被完全评估\n\n* `Time per query` - 每个查询的详细时间\n\n* `Time of matched queries` - 匹配任何文档的查询所花费的总时间\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_31\n\n<!-- response SQL -->\n\nCODE_BLOCK_32\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "`SHOW META` может использоваться после выполнения оператора [CALL PQ](../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ), при этом он выводит другую информацию.\n\n`SHOW META` после оператора `CALL PQ` включает:\n\n* `total` - Общее время, затраченное на сопоставление документа(ов)\n\n* `queries_matched` - Количество сохранённых запросов, которые совпали с документом(ами)\n\n* `document_matches` - Количество документов, которые совпали с запросами, сохранёнными в таблице\n\n* `total_queries_stored` - Общее количество запросов, сохранённых в таблице\n\n* `term_only_queries` - Количество запросов в таблице, которые содержат термы; остальные запросы используют расширенный синтаксис запросов.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_29\n\n<!-- response SQL -->\n\nCODE_BLOCK_30\n\n<!-- end -->\n\n<!-- example call pq verbose meta  -->\n\nИспользование `CALL PQ` с опцией `verbose` даёт более подробный вывод.\n\nОн включает следующие дополнительные поля:\n\n* `Setup` - Время, затраченное на начальную настройку процесса сопоставления, например, разбор документов и установку параметров\n\n* `Queries failed` - Количество запросов, которые завершились ошибкой\n\n* `Fast rejected queries` - Количество запросов, которые не были полностью оценены, но быстро сопоставлены и отброшены с использованием фильтров или других условий\n\n* `Time per query` - Подробное время для каждого запроса\n\n* `Time of matched queries` - Общее время, затраченное на запросы, которые совпали с любыми документами\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_31\n\n<!-- response SQL -->\n\nCODE_BLOCK_32\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "d1ee1a830ff2de48f06e3e56f7c3862168de6178454968fcf1cc282186d27c6f": {
    "original": "# SHOW META\n\nCODE_BLOCK_0\n\n<!-- example show meta -->\n\n`SHOW META` is an SQL statement that displays additional meta-information about the processed query, including the query time, keyword statistics, and information about the secondary indexes used. The syntax is:\n\nThe included items are:\n\n* `total`: The number of matches that were actually retrieved and sent to the client. This value is typically limited by the [LIMIT/size](../Searching/Pagination.md#Pagination-of-search-results) search option.\n\n* `total_found`:\n\n  - The estimated total number of matches for the query in the index. If you need the exact number of matches, use `SELECT COUNT(*)` instead of relying on this value.\n\n  - For queries with `GROUP BY`, `total_found` represents the number of groups instead of individual matches.\n\n  - For [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) queries, `total_found` still represents the number of groups, regardless of the value of `N`.\n\n* `total_relation`: Indicates whether the `total_found` value is exact or an estimate.\n\n  - If Manticore cannot determine the precise `total_found` value, this field will display `total_relation: gte`, meaning the actual number of matches is **Greater Than or Equal** to the reported `total_found`.\n\n  - If the `total_found` value is exact, `total_relation: eq` will be displayed.\n\n* `time`: The duration (in seconds) it took to process the search query.\n\n* `keyword[N]`: The n-th keyword used in the search query. Note that the keyword can be presented as a wildcard, e.g., `abc*`.\n\n* `docs[N]`: The total number of documents (or records) containing the n-th keyword from the search query. If the keyword is presented as a wildcard, this value represents the sum of documents for all expanded sub-keywords, potentially exceeding the actual number of matched documents.\n\n* `hits[N]`: The total number of occurrences (or hits) of the n-th keyword across all documents.\n\n* `index`: Information about the utilized index (e.g., secondary index).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- response SQL -->\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_3\n\n<!-- response JSON -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n<!-- example show meta iostats cpustats -->\n\n`SHOW META` can display I/O and CPU counters, but they will only be available if searchd was started with the `--iostats` and `--cpustats` switches, respectively.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- response SQL -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_7\n\n<!-- response JSON -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!-- example show meta predicted_time -->\n\nAdditional values, such as `predicted_time`, `dist_predicted_time`, `local_fetched_docs`, `local_fetched_hits`, `local_fetched_skips`, and their respective `dist_fetched_*` counterparts, will only be available if `searchd` was configured with [predicted time costs](../Server_settings/Searchd.md#predicted_time_costs) and the query included `predicted_time` in the `OPTION` clause.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- response SQL -->\n\nCODE_BLOCK_10\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_11\n\n<!-- response JSON -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n<!-- example show meta single statement -->\n\n`SHOW META` must be executed immediately after the query in the **same** session. Since some MySQL connectors/libraries use connection pools, running `SHOW META` in a separate statement can lead to unexpected results, such as retrieving metadata from another query. In these cases (and generally recommended), run a multiple statement containing both the query and `SHOW META`. Some connectors/libraries support multi-queries within the same method for a single statement, while others may require the use of a dedicated method for multi-queries or setting specific options during connection setup.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_13\n\n<!-- response SQL -->\n\nCODE_BLOCK_14\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_15\n\n<!-- response JSON -->\n\nCODE_BLOCK_16\n\n<!-- end -->\n\n<!-- example SHOW META LIKE -->\n\nYou can also use the optional LIKE clause, which allows you to select only the variables that match a specific pattern. The pattern syntax follows standard SQL wildcards, where `%` represents any number of any characters, and `_` represents a single character.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_17\n\n<!-- response SQL -->\n\nCODE_BLOCK_18\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_19\n\n<!-- response JSON -->\n\nCODE_BLOCK_20\n\n<!-- end -->\n\n## SHOW META and facets\n\n<!-- example show meta facets -->\n\nWhen utilizing [faceted search](../Searching/Faceted_search.md), you can examine the `multiplier` field in the `SHOW META` output to determine how many queries were executed in an optimized group.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_21\n\n<!-- response SQL -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_23\n\n<!-- response JSON -->\n\nCODE_BLOCK_24\n\n<!-- end -->\n\n## SHOW META and query optimizer\n\n<!-- example of show meta vs query optimizer -->\n\nWhen the [cost-based query optimizer](../Searching/Cost_based_optimizer.md) chooses to use `DocidIndex`, `ColumnarScan`, or `SecondaryIndex` instead of a plain filter, this is reflected in the `SHOW META` command.\n\nThe `index` variable displays the names and types of secondary indexes used during query execution. The percentage indicates how many disk chunks (in the case of an RT table) or pseudo shards (in the case of a plain table) utilized the secondary index.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_25\n\n<!-- response SQL -->\n\nCODE_BLOCK_26\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_27\n\n<!-- response JSON -->\n\nCODE_BLOCK_28\n\n<!-- end -->\n\n## SHOW META for PQ tables\n\n<!-- example show meta PQ -->",
    "translations": {
      "chinese": "# SHOW META\n\nCODE_BLOCK_0\n\n<!-- example show meta -->\n\n`SHOW META` 是一个 SQL 语句，用于显示有关处理查询的附加元信息，包括查询时间、关键词统计以及所用二级索引的信息。语法为：\n\n所包含的项目有：\n\n* `total`：实际检索并发送给客户端的匹配数。此值通常受 [LIMIT/size](../Searching/Pagination.md#Pagination-of-search-results) 搜索选项限制。\n\n* `total_found`：\n\n  - 索引中查询的估计总匹配数。如果需要精确匹配数，请使用 `SELECT COUNT(*)`，而不要依赖此值。\n\n  - 对于带有 `GROUP BY` 的查询，`total_found` 表示分组数量，而非单个匹配。\n\n  - 对于 [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) 查询，`total_found` 仍然表示分组数，而不管 `N` 的值。\n\n* `total_relation`：指示 `total_found` 值是精确还是估计。\n\n  - 如果 Manticore 无法确定精确的 `total_found` 值，该字段将显示 `total_relation: gte`，表示实际匹配数 **大于等于** 报告的 `total_found`。\n\n  - 如果 `total_found` 值是精确的，将显示 `total_relation: eq`。\n\n* `time`：处理搜索查询花费的时长（秒）。\n\n* `keyword[N]`：搜索查询中使用的第 n 个关键词。注意关键词可以是通配符形式，例如 `abc*`。\n\n* `docs[N]`：包含搜索查询中第 n 个关键词的文档（或记录）总数。如果关键词是通配符形式，此值表示所有扩展子关键词对应文档的总和，可能大于实际匹配文档数。\n\n* `hits[N]`：所有文档中第 n 个关键词的总出现次数（或命中数）。\n\n* `index`：有关使用的索引（例如二级索引）的信息。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- response SQL -->\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_3\n\n<!-- response JSON -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n<!-- example show meta iostats cpustats -->\n\n`SHOW META` 可以显示 I/O 和 CPU 计数器，但只有当 searchd 启动时分别包含 `--iostats` 和 `--cpustats` 开关时，这些信息才可用。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- response SQL -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_7\n\n<!-- response JSON -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!-- example show meta predicted_time -->\n\n附加值，如 `predicted_time`、`dist_predicted_time`、`local_fetched_docs`、`local_fetched_hits`、`local_fetched_skips` 及其相应的 `dist_fetched_*` 对应项，只有在 `searchd` 配置了[预测时间成本](../Server_settings/Searchd.md#predicted_time_costs)并且查询的 `OPTION` 子句中包含 `predicted_time` 时才会提供。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- response SQL -->\n\nCODE_BLOCK_10\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_11\n\n<!-- response JSON -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n<!-- example show meta single statement -->\n\n`SHOW META` 必须在**同一**会话中紧接着查询立即执行。由于某些 MySQL 连接器/库使用连接池，在单独语句中执行 `SHOW META` 可能造成意外结果，例如检索到其他查询的元数据。在这些情况下（并且通常推荐），请执行包含查询和 `SHOW META` 的多语句操作。有些连接器/库支持单个方法中的多查询，而有些则可能需要使用专门的方法或在连接设置时启用特定选项来支持多查询。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_13\n\n<!-- response SQL -->\n\nCODE_BLOCK_14\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_15\n\n<!-- response JSON -->\n\nCODE_BLOCK_16\n\n<!-- end -->\n\n<!-- example SHOW META LIKE -->\n\n你也可以使用可选的 LIKE 子句，允许你仅选择匹配特定模式的变量。模式语法遵循标准 SQL 通配符，其中 `%` 表示任意数量的任意字符，`_` 表示单个字符。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_17\n\n<!-- response SQL -->\n\nCODE_BLOCK_18\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_19\n\n<!-- response JSON -->\n\nCODE_BLOCK_20\n\n<!-- end -->\n\n## SHOW META 与 facets\n\n<!-- example show meta facets -->\n\n当使用[分面搜索](../Searching/Faceted_search.md)时，你可以通过 `SHOW META` 输出中的 `multiplier` 字段，了解优化分组内执行了多少查询。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_21\n\n<!-- response SQL -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_23\n\n<!-- response JSON -->\n\nCODE_BLOCK_24\n\n<!-- end -->\n\n## SHOW META 与查询优化器\n\n<!-- example of show meta vs query optimizer -->\n\n当[基于成本的查询优化器](../Searching/Cost_based_optimizer.md)选择使用 `DocidIndex`、`ColumnarScan` 或 `SecondaryIndex` 替代普通过滤时，`SHOW META` 命令会有所反映。\n\n`index` 变量显示查询执行期间所用二级索引的名称和类型。百分比表示利用二级索引的磁盘块数量（对于 RT 表）或伪分片数量（对于普通表）。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_25\n\n<!-- response SQL -->\n\nCODE_BLOCK_26\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_27\n\n<!-- response JSON -->\n\nCODE_BLOCK_28\n\n<!-- end -->\n\n## SHOW META 针对 PQ 表\n\n<!-- example show meta PQ -->",
      "russian": "# SHOW META\n\nCODE_BLOCK_0\n\n<!-- example show meta -->\n\n`SHOW META` — это SQL-оператор, который отображает дополнительную мета-информацию о выполненном запросе, включая время выполнения запроса, статистику по ключевым словам и информацию о вторичных индексах, использованных в запросе. Синтаксис:\n\nВключённые элементы:\n\n* `total`: Количество совпадений, которые были фактически извлечены и отправлены клиенту. Обычно это значение ограничивается опцией поиска [LIMIT/size](../Searching/Pagination.md#Pagination-of-search-results).\n\n* `total_found`:\n\n  - Оценочное общее количество совпадений для запроса в индексе. Если требуется точное количество совпадений, используйте `SELECT COUNT(*)`, вместо того чтобы полагаться на это значение.\n\n  - Для запросов с `GROUP BY`, `total_found` представляет количество групп, а не отдельных совпадений.\n\n  - Для запросов типа [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) `total_found` всё равно представляет количество групп, независимо от значения `N`.\n\n* `total_relation`: Показывает, является ли значение `total_found` точным или оценочным.\n\n  - Если Manticore не может определить точное значение `total_found`, в этом поле будет отображено `total_relation: gte`, что означает, что фактическое количество совпадений **больше или равно** указанному `total_found`.\n\n  - Если значение `total_found` точно, будет отображено `total_relation: eq`.\n\n* `time`: Время (в секундах), затраченное на обработку поискового запроса.\n\n* `keyword[N]`: n-й ключевой запрос, использованный в поиске. Обратите внимание, что ключевое слово может быть представлено с использованием подстановочного знака, например, `abc*`.\n\n* `docs[N]`: Общее количество документов (или записей), содержащих n-ое ключевое слово из поискового запроса. Если ключевое слово представлено подстановочным знаком, это значение представляет сумму документов для всех расширенных подключей, что может превышать фактическое количество совпадающих документов.\n\n* `hits[N]`: Общее количество вхождений (или попаданий) n-го ключевого слова во всех документах.\n\n* `index`: Информация об используемом индексе (например, вторичном индексе).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- response SQL -->\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_3\n\n<!-- response JSON -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n<!-- example show meta iostats cpustats -->\n\n`SHOW META` может показывать счётчики ввода/вывода и процессора, но они будут доступны только, если searchd был запущен с переключателями `--iostats` и `--cpustats` соответственно.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- response SQL -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_7\n\n<!-- response JSON -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!-- example show meta predicted_time -->\n\nДополнительные значения, такие как `predicted_time`, `dist_predicted_time`, `local_fetched_docs`, `local_fetched_hits`, `local_fetched_skips` и соответствующие им `dist_fetched_*` значения будут доступны только если `searchd` был сконфигурирован с [предсказанными временными затратами](../Server_settings/Searchd.md#predicted_time_costs) и запрос включал `predicted_time` в разделе `OPTION`.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- response SQL -->\n\nCODE_BLOCK_10\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_11\n\n<!-- response JSON -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n<!-- example show meta single statement -->\n\n`SHOW META` должен выполняться сразу после запроса в **той же** сессии. Поскольку некоторые MySQL-коннекторы/библиотеки используют пулы соединений, выполнение `SHOW META` в отдельном операторе может привести к непредвиденным результатам, таким как получение метаданных другого запроса. В таких случаях (и вообще рекомендуется) выполняйте многооператорный запрос, содержащий и запрос, и `SHOW META`. Некоторые коннекторы/библиотеки поддерживают мультизапросы в пределах одного вызова метода, в то время как другим может потребоваться использовать специализированный метод для мультизапросов или настроить определённые параметры при установке соединения.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_13\n\n<!-- response SQL -->\n\nCODE_BLOCK_14\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_15\n\n<!-- response JSON -->\n\nCODE_BLOCK_16\n\n<!-- end -->\n\n<!-- example SHOW META LIKE -->\n\nВы также можете использовать необязательный оператор LIKE, который позволяет выбирать только переменные, соответствующие определённому шаблону. Синтаксис шаблона выполняется по стандартным SQL-подстановочным знакам, где `%` означает любое количество любых символов, а `_` соответствует одному символу.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_17\n\n<!-- response SQL -->\n\nCODE_BLOCK_18\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_19\n\n<!-- response JSON -->\n\nCODE_BLOCK_20\n\n<!-- end -->\n\n## SHOW META и фасеты\n\n<!-- example show meta facets -->\n\nПри использовании [фасетного поиска](../Searching/Faceted_search.md) в выводе `SHOW META` вы можете посмотреть поле `multiplier`, чтобы узнать, сколько запросов было выполнено в оптимизированной группе.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_21\n\n<!-- response SQL -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_23\n\n<!-- response JSON -->\n\nCODE_BLOCK_24\n\n<!-- end -->\n\n## SHOW META и оптимизатор запросов\n\n<!-- example of show meta vs query optimizer -->\n\nКогда [оптимизатор запросов на основе стоимости](../Searching/Cost_based_optimizer.md) выбирает использовать `DocidIndex`, `ColumnarScan` или `SecondaryIndex` вместо простого фильтра, это отображается в команде `SHOW META`.\n\nПеременная `index` показывает имена и типы вторичных индексов, использованных при выполнении запроса. Процент указывает, сколько дисковых чанков (для RT-таблицы) или псевдо-шард (для простой таблицы) использовали вторичный индекс.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_25\n\n<!-- response SQL -->\n\nCODE_BLOCK_26\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_27\n\n<!-- response JSON -->\n\nCODE_BLOCK_28\n\n<!-- end -->\n\n## SHOW META для PQ таблиц\n\n<!-- example show meta PQ -->"
    },
    "is_code_or_comment": false
  }
}
