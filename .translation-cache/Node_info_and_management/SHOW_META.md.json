{
  "bf0c1d4d505db869b7a6f7486743d92ef2fa41bb46d853884a72c53bca271169": {
    "original": "It includes the following additional entries:\n\n* `Setup` - Time spent on the initial setup of the matching process, such as parsing docs and setting options\n\n* `Queries failed` - Number of queries that failed\n\n* `Fast rejected queries` - Number of queries that were not fully evaluated but quickly matched and rejected using filters or other conditions\n\n* `Time per query` - Detailed time for each query\n\n* `Time of matched queries` - Total time spent on queries that matched any documents\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_17\n\n<!-- response SQL -->\n\nCODE_BLOCK_18\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "它包括以下附加条目：\n\n* `Setup` - 匹配过程初始设置所花费的时间，例如解析文档和设置选项\n\n* `Queries failed` - 失败的查询数量\n\n* `Fast rejected queries` - 未完全评估但通过过滤器或其他条件快速匹配并拒绝的查询数量\n\n* `Time per query` - 每个查询的详细时间\n\n* `Time of matched queries` - 匹配到任何文档的查询所花费的总时间\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_17\n\n<!-- response SQL -->\n\nCODE_BLOCK_18\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "Он включает следующие дополнительные записи:\n\n* `Setup` - Время, затраченное на начальную настройку процесса сопоставления, например, разбор документов и установку параметров\n\n* `Queries failed` - Количество запросов, которые завершились с ошибкой\n\n* `Fast rejected queries` - Количество запросов, которые не были полностью оценены, но быстро сопоставлены и отклонены с использованием фильтров или других условий\n\n* `Time per query` - Подробное время для каждого запроса\n\n* `Time of matched queries` - Общее время, затраченное на запросы, которые совпали с любыми документами\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_17\n\n<!-- response SQL -->\n\nCODE_BLOCK_18\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "a03f29d512dc9ed309f0f067140388dd7e65d7d4ec2ae27001a89be05e1ce59d": {
    "original": "# SHOW META\n\nCODE_BLOCK_0\n\n<!-- example show meta -->\n\n`SHOW META` is an SQL statement that displays additional meta-information about the processed query, including the query time, keyword statistics, and information about the secondary indexes used. The syntax is:\n\nThe included items are:\n\n* `total`: The number of matches that were actually retrieved and sent to the client. This value is typically limited by the [LIMIT/size](../Searching/Pagination.md#Pagination-of-search-results) search option.\n\n* `total_found`:\n\n  - The estimated total number of matches for the query in the index. If you need the exact number of matches, use `SELECT COUNT(*)` instead of relying on this value.\n\n  - For queries with `GROUP BY`, `total_found` represents the number of groups instead of individual matches.\n\n  - For [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) queries, `total_found` still represents the number of groups, regardless of the value of `N`.\n\n* `total_relation`: Indicates whether the `total_found` value is exact or an estimate.\n\n  - If Manticore cannot determine the precise `total_found` value, this field will display `total_relation: gte`, meaning the actual number of matches is **Greater Than or Equal** to the reported `total_found`.\n\n  - If the `total_found` value is exact, `total_relation: eq` will be displayed.\n\n* `time`: The duration (in seconds) it took to process the search query.\n\n* `keyword[N]`: The n-th keyword used in the search query. Note that the keyword can be presented as a wildcard, e.g., `abc*`.\n\n* `docs[N]`: The total number of documents (or records) containing the n-th keyword from the search query. If the keyword is presented as a wildcard, this value represents the sum of documents for all expanded sub-keywords, potentially exceeding the actual number of matched documents.\n\n* `hits[N]`: The total number of occurrences (or hits) of the n-th keyword across all documents.\n\n* `index`: Information about the utilized index (e.g., secondary index).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- response SQL -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n<!-- example show meta iostats cpustats -->\n\n`SHOW META` can display I/O and CPU counters, but they will only be available if searchd was started with the `--iostats` and `--cpustats` switches, respectively.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- response SQL -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n<!-- example show meta predicted_time -->\n\nAdditional values, such as `predicted_time`, `dist_predicted_time`, `local_fetched_docs`, `local_fetched_hits`, `local_fetched_skips`, and their respective `dist_fetched_*` counterparts, will only be available if `searchd` was configured with [predicted time costs](../Server_settings/Searchd.md#predicted_time_costs) and the query included `predicted_time` in the `OPTION` clause.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- response SQL -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n<!-- example show meta single statement -->\n\n`SHOW META` must be executed immediately after the query in the **same** session. Since some MySQL connectors/libraries use connection pools, running `SHOW META` in a separate statement can lead to unexpected results, such as retrieving metadata from another query. In these cases (and generally recommended), run a multiple statement containing both the query and `SHOW META`. Some connectors/libraries support multi-queries within the same method for a single statement, while others may require the use of a dedicated method for multi-queries or setting specific options during connection setup.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_7\n\n<!-- response SQL -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!-- example SHOW META LIKE -->\n\nYou can also use the optional LIKE clause, which allows you to select only the variables that match a specific pattern. The pattern syntax follows standard SQL wildcards, where `%` represents any number of any characters, and `_` represents a single character.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- response SQL -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n## SHOW META and facets\n\n<!-- example show meta facets -->\n\nWhen utilizing [faceted search](../Searching/Faceted_search.md), you can examine the `multiplier` field in the `SHOW META` output to determine how many queries were executed in an optimized group.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_11\n\n<!-- response SQL -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n## SHOW META and query optimizer\n\n<!-- example of show meta vs query optimizer -->\n\nWhen the [cost-based query optimizer](../Searching/Cost_based_optimizer.md) chooses to use `DocidIndex`, `ColumnarScan`, or `SecondaryIndex` instead of a plain filter, this is reflected in the `SHOW META` command.\n\nThe `index` variable displays the names and types of secondary indexes used during query execution. The percentage indicates how many disk chunks (in the case of an RT table) or pseudo shards (in the case of a plain table) utilized the secondary index.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_13\n\n<!-- response SQL -->\n\nCODE_BLOCK_14\n\n<!-- end -->\n\n## SHOW META for PQ tables\n\n<!-- example show meta PQ -->\n\n`SHOW META` can be used after executing a [CALL PQ](../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ) statement, in which case it provides different output.\n\n`SHOW META` following a `CALL PQ` statement includes:\n\n* `total` - Total time spent on matching the document(s)\n\n* `queries_matched` - Number of stored queries that match the document(s)\n\n* `document_matches` - Number of documents that matched the queries stored in the table\n\n* `total_queries_stored` - Total number of queries stored in the table\n\n* `term_only_queries` - Number of queries in the table that have terms; the remaining queries use extended query syntax.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_15\n\n<!-- response SQL -->\n\nCODE_BLOCK_16\n\n<!-- end -->\n\n<!-- example call pq verbose meta  -->\n\nUsing `CALL PQ` with a `verbose` option provides more detailed output.",
    "translations": {
      "chinese": "# SHOW META\n\nCODE_BLOCK_0\n\n<!-- example show meta -->\n\n`SHOW META` 是一个 SQL 语句，用于显示有关处理查询的附加元信息，包括查询时间、关键字统计以及使用的二级索引信息。语法如下：\n\n包含的项目有：\n\n* `total`：实际检索并发送给客户端的匹配数。该值通常受 [LIMIT/size](../Searching/Pagination.md#Pagination-of-search-results) 搜索选项的限制。\n\n* `total_found`：\n\n  - 索引中查询的估计匹配总数。如果需要精确的匹配数，请使用 `SELECT COUNT(*)`，而不是依赖此值。\n\n  - 对于带有 `GROUP BY` 的查询，`total_found` 表示组的数量，而非单个匹配数。\n\n  - 对于 [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) 查询，`total_found` 仍表示组的数量，无论 `N` 的值是多少。\n\n* `total_relation`：指示 `total_found` 值是精确的还是估计的。\n\n  - 如果 Manticore 无法确定精确的 `total_found` 值，此字段将显示 `total_relation: gte`，表示实际匹配数**大于或等于**报告的 `total_found`。\n\n  - 如果 `total_found` 值是精确的，则显示 `total_relation: eq`。\n\n* `time`：处理搜索查询所用的时间（秒）。\n\n* `keyword[N]`：搜索查询中使用的第 n 个关键字。注意关键字可以是通配符形式，例如 `abc*`。\n\n* `docs[N]`：包含搜索查询中第 n 个关键字的文档（或记录）总数。如果关键字是通配符形式，此值表示所有展开子关键字的文档总和，可能超过实际匹配文档数。\n\n* `hits[N]`：第 n 个关键字在所有文档中出现的总次数（命中数）。\n\n* `index`：所使用索引的信息（例如二级索引）。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- response SQL -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n<!-- example show meta iostats cpustats -->\n\n`SHOW META` 可以显示 I/O 和 CPU 计数器，但仅当 searchd 启动时带有 `--iostats` 和 `--cpustats` 参数时才可用。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- response SQL -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n<!-- example show meta predicted_time -->\n\n额外的值，如 `predicted_time`、`dist_predicted_time`、`local_fetched_docs`、`local_fetched_hits`、`local_fetched_skips` 及其对应的 `dist_fetched_*`，仅在 `searchd` 配置了[预测时间成本](../Server_settings/Searchd.md#predicted_time_costs)且查询的 `OPTION` 子句中包含 `predicted_time` 时可用。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- response SQL -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n<!-- example show meta single statement -->\n\n`SHOW META` 必须在**同一**会话中紧接查询之后执行。由于某些 MySQL 连接器/库使用连接池，单独执行 `SHOW META` 可能导致意外结果，例如获取到其他查询的元数据。在这些情况下（且通常推荐），应执行包含查询和 `SHOW META` 的多语句。一些连接器/库支持在同一方法中执行多查询，而其他可能需要专用方法或在连接设置时配置特定选项。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_7\n\n<!-- response SQL -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!-- example SHOW META LIKE -->\n\n你也可以使用可选的 LIKE 子句，只选择匹配特定模式的变量。模式语法遵循标准 SQL 通配符，其中 `%` 表示任意数量的任意字符，`_` 表示单个字符。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- response SQL -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n## SHOW META 和 facets\n\n<!-- example show meta facets -->\n\n使用[分面搜索](../Searching/Faceted_search.md)时，可以查看 `SHOW META` 输出中的 `multiplier` 字段，以确定优化分组中执行了多少查询。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_11\n\n<!-- response SQL -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n## SHOW META 和查询优化器\n\n<!-- example of show meta vs query optimizer -->\n\n当[基于成本的查询优化器](../Searching/Cost_based_optimizer.md)选择使用 `DocidIndex`、`ColumnarScan` 或 `SecondaryIndex` 而非简单过滤器时，`SHOW META` 命令会反映这一点。\n\n`index` 变量显示查询执行期间使用的二级索引的名称和类型。百分比表示使用二级索引的磁盘块数量（RT 表情况）或伪分片数量（普通表情况）。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_13\n\n<!-- response SQL -->\n\nCODE_BLOCK_14\n\n<!-- end -->\n\n## SHOW META 用于 PQ 表\n\n<!-- example show meta PQ -->\n\n`SHOW META` 可在执行[CALL PQ](../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ) 语句后使用，此时输出不同。\n\n`CALL PQ` 语句后执行的 `SHOW META` 包含：\n\n* `total` - 匹配文档所花费的总时间\n\n* `queries_matched` - 匹配文档的存储查询数量\n\n* `document_matches` - 匹配表中存储查询的文档数量\n\n* `total_queries_stored` - 表中存储的查询总数\n\n* `term_only_queries` - 表中包含词项的查询数量；其余查询使用扩展查询语法。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_15\n\n<!-- response SQL -->\n\nCODE_BLOCK_16\n\n<!-- end -->\n\n<!-- example call pq verbose meta  -->\n\n使用带有 `verbose` 选项的 `CALL PQ` 可提供更详细的输出。",
      "russian": "# SHOW META\n\nCODE_BLOCK_0\n\n<!-- example show meta -->\n\n`SHOW META` — это SQL-запрос, который отображает дополнительную метаинформацию о выполненном запросе, включая время выполнения запроса, статистику по ключевым словам и информацию о используемых вторичных индексах. Синтаксис:\n\nВключённые элементы:\n\n* `total`: Количество совпадений, которые фактически были извлечены и отправлены клиенту. Это значение обычно ограничивается опцией поиска [LIMIT/size](../Searching/Pagination.md#Pagination-of-search-results).\n\n* `total_found`:\n\n  - Оценочное общее количество совпадений для запроса в индексе. Если вам нужно точное количество совпадений, используйте `SELECT COUNT(*)` вместо опоры на это значение.\n\n  - Для запросов с `GROUP BY` `total_found` представляет количество групп, а не отдельных совпадений.\n\n  - Для запросов [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) `total_found` по-прежнему представляет количество групп, независимо от значения `N`.\n\n* `total_relation`: Указывает, является ли значение `total_found` точным или оценочным.\n\n  - Если Manticore не может определить точное значение `total_found`, в этом поле будет отображено `total_relation: gte`, что означает, что фактическое количество совпадений **больше или равно** указанному `total_found`.\n\n  - Если значение `total_found` точное, будет отображено `total_relation: eq`.\n\n* `time`: Время (в секундах), затраченное на обработку поискового запроса.\n\n* `keyword[N]`: n-й ключевой запрос, использованный в поисковом запросе. Обратите внимание, что ключевое слово может быть представлено с использованием подстановочного знака, например, `abc*`.\n\n* `docs[N]`: Общее количество документов (или записей), содержащих n-й ключевой запрос из поискового запроса. Если ключевое слово представлено с подстановочным знаком, это значение представляет сумму документов для всех расширенных подзапросов, что может превышать фактическое количество совпавших документов.\n\n* `hits[N]`: Общее количество вхождений (или попаданий) n-го ключевого слова во всех документах.\n\n* `index`: Информация об используемом индексе (например, вторичном индексе).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- response SQL -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n<!-- example show meta iostats cpustats -->\n\n`SHOW META` может отображать счётчики ввода-вывода и CPU, но они будут доступны только если searchd был запущен с переключателями `--iostats` и `--cpustats` соответственно.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- response SQL -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n<!-- example show meta predicted_time -->\n\nДополнительные значения, такие как `predicted_time`, `dist_predicted_time`, `local_fetched_docs`, `local_fetched_hits`, `local_fetched_skips` и их соответствующие аналоги `dist_fetched_*`, будут доступны только если `searchd` был настроен с [предсказанными затратами времени](../Server_settings/Searchd.md#predicted_time_costs) и запрос включал `predicted_time` в опции `OPTION`.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- response SQL -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n<!-- example show meta single statement -->\n\n`SHOW META` должен выполняться сразу после запроса в **той же** сессии. Поскольку некоторые MySQL-коннекторы/библиотеки используют пулы соединений, выполнение `SHOW META` в отдельном запросе может привести к неожиданным результатам, например, получению метаданных другого запроса. В таких случаях (и в общем случае рекомендуется) выполняйте множественный запрос, содержащий и сам запрос, и `SHOW META`. Некоторые коннекторы/библиотеки поддерживают мультизапросы в одном методе для одного запроса, в то время как другие могут требовать использования специального метода для мультизапросов или установки определённых опций при настройке соединения.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_7\n\n<!-- response SQL -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!-- example SHOW META LIKE -->\n\nВы также можете использовать необязательное выражение LIKE, которое позволяет выбрать только переменные, соответствующие определённому шаблону. Синтаксис шаблона соответствует стандартным SQL-подстановочным знакам, где `%` обозначает любое количество любых символов, а `_` — один символ.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- response SQL -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n## SHOW META и фасеты\n\n<!-- example show meta facets -->\n\nПри использовании [фасетного поиска](../Searching/Faceted_search.md) вы можете проверить поле `multiplier` в выводе `SHOW META`, чтобы определить, сколько запросов было выполнено в оптимизированной группе.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_11\n\n<!-- response SQL -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n## SHOW META и оптимизатор запросов\n\n<!-- example of show meta vs query optimizer -->\n\nКогда [оптимизатор запросов на основе стоимости](../Searching/Cost_based_optimizer.md) выбирает использование `DocidIndex`, `ColumnarScan` или `SecondaryIndex` вместо простого фильтра, это отражается в команде `SHOW META`.\n\nПеременная `index` отображает имена и типы вторичных индексов, использованных во время выполнения запроса. Процент указывает, сколько дисковых чанков (в случае RT-таблицы) или псевдо-шард (в случае простой таблицы) использовали вторичный индекс.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_13\n\n<!-- response SQL -->\n\nCODE_BLOCK_14\n\n<!-- end -->\n\n## SHOW META для PQ таблиц\n\n<!-- example show meta PQ -->\n\n`SHOW META` можно использовать после выполнения [CALL PQ](../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ), в этом случае он выдаёт другой вывод.\n\n`SHOW META` после выполнения `CALL PQ` включает:\n\n* `total` — Общее время, затраченное на сопоставление документа(ов)\n\n* `queries_matched` — Количество сохранённых запросов, которые совпали с документом(ами)\n\n* `document_matches` — Количество документов, которые совпали с запросами, сохранёнными в таблице\n\n* `total_queries_stored` — Общее количество запросов, сохранённых в таблице\n\n* `term_only_queries` — Количество запросов в таблице, которые содержат термы; остальные запросы используют расширенный синтаксис запросов.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_15\n\n<!-- response SQL -->\n\nCODE_BLOCK_16\n\n<!-- end -->\n\n<!-- example call pq verbose meta  -->\n\nИспользование `CALL PQ` с опцией `verbose` предоставляет более подробный вывод."
    },
    "is_code_or_comment": false
  },
  "57ccc0eeba6f94ba9e3d4f9429432c7775111f8223b4e9620b82d9615f5cd18c": {
    "original": "CODE_BLOCK_15\n\n<!-- response SQL -->\n\nCODE_BLOCK_16\n\n<!-- end -->\n\n<!-- example call pq verbose meta  -->\n\nUsing `CALL PQ` with a `verbose` option provides more detailed output.\n\nIt includes the following additional entries:\n\n* `Setup` - Time spent on the initial setup of the matching process, such as parsing docs and setting options\n\n* `Queries failed` - Number of queries that failed\n\n* `Fast rejected queries` - Number of queries that were not fully evaluated but quickly matched and rejected using filters or other conditions\n\n* `Time per query` - Detailed time for each query\n\n* `Time of matched queries` - Total time spent on queries that matched any documents\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_17\n\n<!-- response SQL -->\n\nCODE_BLOCK_18\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "CODE_BLOCK_15\n\n<!-- response SQL -->\n\nCODE_BLOCK_16\n\n<!-- end -->\n\n<!-- example call pq verbose meta  -->\n\n使用带有 `verbose` 选项的 `CALL PQ` 可提供更详细的输出。\n\n它包括以下附加条目：\n\n* `Setup` - 匹配过程初始设置所花费的时间，例如解析文档和设置选项\n\n* `Queries failed` - 失败的查询数量\n\n* `Fast rejected queries` - 未完全评估但通过过滤器或其他条件快速匹配并拒绝的查询数量\n\n* `Time per query` - 每个查询的详细时间\n\n* `Time of matched queries` - 与任何文档匹配的查询所花费的总时间\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_17\n\n<!-- response SQL -->\n\nCODE_BLOCK_18\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "CODE_BLOCK_15\n\n<!-- response SQL -->\n\nCODE_BLOCK_16\n\n<!-- end -->\n\n<!-- example call pq verbose meta  -->\n\nИспользование `CALL PQ` с опцией `verbose` предоставляет более подробный вывод.\n\nОн включает следующие дополнительные записи:\n\n* `Setup` - Время, затраченное на начальную настройку процесса сопоставления, такое как разбор документов и установка опций\n\n* `Queries failed` - Количество запросов, которые завершились неудачей\n\n* `Fast rejected queries` - Количество запросов, которые не были полностью оценены, но быстро сопоставлены и отклонены с использованием фильтров или других условий\n\n* `Time per query` - Детальное время для каждого запроса\n\n* `Time of matched queries` - Общее время, затраченное на запросы, которые сопоставились с какими-либо документами\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_17\n\n<!-- response SQL -->\n\nCODE_BLOCK_18\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "c2cfe1cb1caf3a47c2700646fbfa0e603964d21a27b84c6a4f39aea7a3471cba": {
    "original": "# SHOW META\n\nCODE_BLOCK_0\n\n<!-- example show meta -->\n\n`SHOW META` is an SQL statement that displays additional meta-information about the processed query, including the query time, keyword statistics, and information about the secondary indexes used. The syntax is:\n\nThe included items are:\n\n* `total`: The number of matches that were actually retrieved and sent to the client. This value is typically limited by the [LIMIT/size](../Searching/Pagination.md#Pagination-of-search-results) search option.\n\n* `total_found`:\n\n  - The estimated total number of matches for the query in the index. If you need the exact number of matches, use `SELECT COUNT(*)` instead of relying on this value.\n\n  - For queries with `GROUP BY`, `total_found` represents the number of groups instead of individual matches.\n\n  - When using `HAVING` with `GROUP BY`, `total_found` reflects the number of groups **after** the `HAVING` filter is applied. This enables proper pagination with `HAVING` clauses.\n\n  - For [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) queries, `total_found` still represents the number of groups, regardless of the value of `N`.\n\n* `total_relation`: Indicates whether the `total_found` value is exact or an estimate.\n\n  - If Manticore cannot determine the precise `total_found` value, this field will display `total_relation: gte`, meaning the actual number of matches is **Greater Than or Equal** to the reported `total_found`.\n\n  - If the `total_found` value is exact, `total_relation: eq` will be displayed.\n\n* `time`: The duration (in seconds) it took to process the search query.\n\n* `keyword[N]`: The n-th keyword used in the search query. Note that the keyword can be presented as a wildcard, e.g., `abc*`.\n\n* `docs[N]`: The total number of documents (or records) containing the n-th keyword from the search query. If the keyword is presented as a wildcard, this value represents the sum of documents for all expanded sub-keywords, potentially exceeding the actual number of matched documents.\n\n* `hits[N]`: The total number of occurrences (or hits) of the n-th keyword across all documents.\n\n* `index`: Information about the utilized index (e.g., secondary index).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- response SQL -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n<!-- example show meta iostats cpustats -->\n\n`SHOW META` can display I/O and CPU counters, but they will only be available if searchd was started with the `--iostats` and `--cpustats` switches, respectively.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- response SQL -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n<!-- example show meta predicted_time -->\n\nAdditional values, such as `predicted_time`, `dist_predicted_time`, `local_fetched_docs`, `local_fetched_hits`, `local_fetched_skips`, and their respective `dist_fetched_*` counterparts, will only be available if `searchd` was configured with [predicted time costs](../Server_settings/Searchd.md#predicted_time_costs) and the query included `predicted_time` in the `OPTION` clause.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- response SQL -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n<!-- example show meta single statement -->\n\n`SHOW META` must be executed immediately after the query in the **same** session. Since some MySQL connectors/libraries use connection pools, running `SHOW META` in a separate statement can lead to unexpected results, such as retrieving metadata from another query. In these cases (and generally recommended), run a multiple statement containing both the query and `SHOW META`. Some connectors/libraries support multi-queries within the same method for a single statement, while others may require the use of a dedicated method for multi-queries or setting specific options during connection setup.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_7\n\n<!-- response SQL -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!-- example SHOW META LIKE -->\n\nYou can also use the optional LIKE clause, which allows you to select only the variables that match a specific pattern. The pattern syntax follows standard SQL wildcards, where `%` represents any number of any characters, and `_` represents a single character.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- response SQL -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n## SHOW META and facets\n\n<!-- example show meta facets -->\n\nWhen utilizing [faceted search](../Searching/Faceted_search.md), you can examine the `multiplier` field in the `SHOW META` output to determine how many queries were executed in an optimized group.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_11\n\n<!-- response SQL -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n## SHOW META and query optimizer\n\n<!-- example of show meta vs query optimizer -->\n\nWhen the [cost-based query optimizer](../Searching/Cost_based_optimizer.md) chooses to use `DocidIndex`, `ColumnarScan`, or `SecondaryIndex` instead of a plain filter, this is reflected in the `SHOW META` command.\n\nThe `index` variable displays the names and types of secondary indexes used during query execution. The percentage indicates how many disk chunks (in the case of an RT table) or pseudo shards (in the case of a plain table) utilized the secondary index.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_13\n\n<!-- response SQL -->\n\nCODE_BLOCK_14\n\n<!-- end -->\n\n## SHOW META for PQ tables\n\n<!-- example show meta PQ -->\n\n`SHOW META` can be used after executing a [CALL PQ](../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ) statement, in which case it provides different output.\n\n`SHOW META` following a `CALL PQ` statement includes:\n\n* `total` - Total time spent on matching the document(s)\n\n* `queries_matched` - Number of stored queries that match the document(s)\n\n* `document_matches` - Number of documents that matched the queries stored in the table\n\n* `total_queries_stored` - Total number of queries stored in the table\n\n* `term_only_queries` - Number of queries in the table that have terms; the remaining queries use extended query syntax.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->",
    "translations": {
      "chinese": "# SHOW META\n\nCODE_BLOCK_0\n\n<!-- example show meta -->\n\n`SHOW META` 是一个 SQL 语句，用于显示有关处理查询的附加元信息，包括查询时间、关键词统计以及使用的辅助索引信息。语法如下：\n\n包含的项目有：\n\n* `total`：实际检索并发送给客户端的匹配数。该值通常受 [LIMIT/size](../Searching/Pagination.md#Pagination-of-search-results) 搜索选项的限制。\n\n* `total_found`：\n\n  - 索引中查询的匹配项估计总数。如果需要确切的匹配数量，请使用 `SELECT COUNT(*)`，而不要依赖此值。\n\n  - 对于带有 `GROUP BY` 的查询，`total_found` 表示组的数量，而非单个匹配。\n\n  - 当使用带有 `GROUP BY` 的 `HAVING` 时，`total_found` 反映应用 `HAVING` 过滤后的组数。这支持带有 `HAVING` 子句的正确分页。\n\n  - 对于 [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) 查询，不论 `N` 的值，`total_found` 仍然表示组的数量。\n\n* `total_relation`：指示 `total_found` 的值是准确的还是估计的。\n\n  - 如果 Manticore 无法确定精确的 `total_found` 值，该字段将显示 `total_relation: gte`，意味着实际匹配数量 **大于或等于** 报告的 `total_found`。\n\n  - 如果 `total_found` 是精确值，则显示 `total_relation: eq`。\n\n* `time`：处理搜索查询所用的时间（以秒为单位）。\n\n* `keyword[N]`：搜索查询中第 n 个使用的关键词。关键词可以是通配符，例如 `abc*`。\n\n* `docs[N]`：包含搜索查询中第 n 个关键词的文档（或记录）总数。如果关键词是通配符，则该值表示所有展开子关键词文档数的总和，可能超过实际匹配的文档数。\n\n* `hits[N]`：第 n 个关键词在所有文档中出现的总次数（或命中次数）。\n\n* `index`：所用索引的信息（例如辅助索引）。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- response SQL -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n<!-- example show meta iostats cpustats -->\n\n`SHOW META` 可以显示 I/O 和 CPU 计数器，但只有在 searchd 启动时使用了 `--iostats` 和 `--cpustats` 开关时，这些信息才可用。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- response SQL -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n<!-- example show meta predicted_time -->\n\n额外的值如 `predicted_time`、`dist_predicted_time`、`local_fetched_docs`、`local_fetched_hits`、`local_fetched_skips` 以及其对应的 `dist_fetched_*` 等仅在 `searchd` 配置了 [预测时间成本](../Server_settings/Searchd.md#predicted_time_costs)，且查询的 `OPTION` 子句中包含 `predicted_time` 时才可用。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- response SQL -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n<!-- example show meta single statement -->\n\n`SHOW META` 必须紧接查询之后在**同一**会话中执行。由于某些 MySQL 连接器/库使用连接池，单独执行 `SHOW META` 可能导致意外结果，如获取到其它查询的元数据。针对这种情况（且一般推荐），请使用包含查询和 `SHOW META` 的多语句查询。有些连接器/库支持在同一方法内多查询执行，另一些可能需要专用多查询方法或在连接设置时配置特殊选项。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_7\n\n<!-- response SQL -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!-- example SHOW META LIKE -->\n\n也可以使用可选的 LIKE 子句，只选出匹配特定模式的变量。模式语法遵循标准 SQL 通配符，`%` 表示任意数量的任意字符，`_` 表示单个字符。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- response SQL -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n## SHOW META 与 facets\n\n<!-- example show meta facets -->\n\n使用 [分面搜索](../Searching/Faceted_search.md) 时，可在 `SHOW META` 输出中查看 `multiplier` 字段，了解执行了多少个优化分组的查询。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_11\n\n<!-- response SQL -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n## SHOW META 与查询优化器\n\n<!-- example of show meta vs query optimizer -->\n\n当 [基于成本的查询优化器](../Searching/Cost_based_optimizer.md) 选择用 `DocidIndex`、`ColumnarScan` 或 `SecondaryIndex` 代替普通过滤时，`SHOW META` 命令会反映这一点。\n\n`index` 变量显示执行查询时使用的辅助索引名称和类型。百分比表示在 RT 表中使用辅助索引的磁盘块数量或在普通表中使用的伪分片数量。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_13\n\n<!-- response SQL -->\n\nCODE_BLOCK_14\n\n<!-- end -->\n\n## SHOW META 用于 PQ 表\n\n<!-- example show meta PQ -->\n\n`SHOW META` 可在执行 [CALL PQ](../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ) 语句后使用，此时会提供不同的输出。\n\n`CALL PQ` 之后的 `SHOW META` 包含：\n\n* `total` - 匹配文档所花费的总时间\n\n* `queries_matched` - 匹配文档的存储查询数\n\n* `document_matches` - 匹配表中存储查询的文档数\n\n* `total_queries_stored` - 表中存储查询的总数\n\n* `term_only_queries` - 表中含词项的查询数；其余查询使用扩展查询语法。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->",
      "russian": "# SHOW META\n\nCODE_BLOCK_0\n\n<!-- example show meta -->\n\n`SHOW META` — это SQL-запрос, который отображает дополнительную мета-информацию о выполняемом запросе, включая время выполнения запроса, статистику по ключевым словам и информацию о используемых вторичных индексах. Синтаксис:\n\nВключённые элементы:\n\n* `total`: Количество совпадений, которые действительно были извлечены и отправлены клиенту. Это значение обычно ограничивается опцией поиска [LIMIT/size](../Searching/Pagination.md#Pagination-of-search-results).\n\n* `total_found`:\n\n  - Оценочное общее число совпадений для запроса в индексе. Если необходим точный подсчет, используйте `SELECT COUNT(*)` вместо опоры на это значение.\n\n  - Для запросов с `GROUP BY` значение `total_found` представляет количество групп, а не отдельных совпадений.\n\n  - При использовании `HAVING` с `GROUP BY` `total_found` отражает количество групп **после** применения фильтра `HAVING`. Это обеспечивает корректную пагинацию с условиями `HAVING`.\n\n  - Для запросов [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) `total_found` по-прежнему отражает количество групп, независимо от значения `N`.\n\n* `total_relation`: Указывает, является ли значение `total_found` точным или оценочным.\n\n  - Если Manticore не может определить точное значение `total_found`, в этом поле будет отображено `total_relation: gte`, что означает, что фактическое количество совпадений **Больше Или Равно** заявленному в `total_found`.\n\n  - Если значение `total_found` точно, будет отображено `total_relation: eq`.\n\n* `time`: Продолжительность (в секундах) обработки поискового запроса.\n\n* `keyword[N]`: N-й ключевой слово, использованное в поисковом запросе. Обратите внимание, что ключевое слово может быть представлено с использованием подстановочных символов, например, `abc*`.\n\n* `docs[N]`: Общее количество документов (или записей), содержащих N-е ключевое слово из поискового запроса. Если ключевое слово представлено с подстановочным знаком, это значение представляет сумму документов для всех расширенных подслов, возможно превышая фактическое количество совпавших документов.\n\n* `hits[N]`: Общее количество вхождений (или попаданий) N-го ключевого слова во всех документах.\n\n* `index`: Информация об используемом индексе (например, вторичный индекс).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- response SQL -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n<!-- example show meta iostats cpustats -->\n\n`SHOW META` может отображать счётчики ввода/вывода и CPU, но они будут доступны только если searchd был запущен с переключателями `--iostats` и `--cpustats` соответственно.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- response SQL -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n<!-- example show meta predicted_time -->\n\nДополнительные значения, такие как `predicted_time`, `dist_predicted_time`, `local_fetched_docs`, `local_fetched_hits`, `local_fetched_skips` и их соответствующие аналоги `dist_fetched_*` будут доступны только в случае, если `searchd` был настроен с [предсказанными затратами времени](../Server_settings/Searchd.md#predicted_time_costs) и запрос содержал `predicted_time` в разделе `OPTION`.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- response SQL -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n<!-- example show meta single statement -->\n\n`SHOW META` должен выполняться сразу после запроса в **той же самой** сессии. Поскольку некоторые MySQL коннекторы/библиотеки используют connection pools, выполнение `SHOW META` как отдельного запроса может привести к неожиданным результатам, таким как получение метаданных другого запроса. В таких случаях (и как общее рекомендуемое решение) выполняйте составной запрос, объединяющий основной запрос вместе с `SHOW META`. Некоторые коннекторы/библиотеки поддерживают много-запросы в одном вызове, в то время как другие требуют использования специального метода для много-запросов или установки определённых опций при настройке соединения.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_7\n\n<!-- response SQL -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!-- example SHOW META LIKE -->\n\nТакже можно использовать необязательное выражение LIKE, которое позволяет выбрать только переменные, соответствующие определённому шаблону. Синтаксис шаблона следует стандартным SQL подстановочным символам, где `%` обозначает любое количество любых символов, а `_` обозначает одиночный символ.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- response SQL -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n## SHOW META и фасеты\n\n<!-- example show meta facets -->\n\nПри использовании [фасетного поиска](../Searching/Faceted_search.md) можно проверить поле `multiplier` в выводе `SHOW META`, чтобы определить, сколько запросов было выполнено в оптимизированной группе.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_11\n\n<!-- response SQL -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n## SHOW META и оптимизатор запросов\n\n<!-- example of show meta vs query optimizer -->\n\nКогда [оптимизатор запросов на основе стоимости](../Searching/Cost_based_optimizer.md) выбирает использование `DocidIndex`, `ColumnarScan` или `SecondaryIndex` вместо обычного фильтра, это отражается в команде `SHOW META`.\n\nПеременная `index` отображает имена и типы вторичных индексов, использованных при выполнении запроса. Процент указывает, сколько дисковых чанков (для RT-таблиц) или псевдо-шард (для обычных таблиц) использовали вторичный индекс.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_13\n\n<!-- response SQL -->\n\nCODE_BLOCK_14\n\n<!-- end -->\n\n## SHOW META для PQ таблиц\n\n<!-- example show meta PQ -->\n\n`SHOW META` можно использовать после выполнения [CALL PQ](../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ), в этом случае вывод будет отличаться.\n\n`SHOW META` после запроса `CALL PQ` включает:\n\n* `total` — общее время, затраченное на сопоставление документа(ов)\n\n* `queries_matched` — количество сохранённых запросов, совпавших с документом(ами)\n\n* `document_matches` — количество документов, совпавших с запросами, сохранёнными в таблице\n\n* `total_queries_stored` — общее число запросов, сохранённых в таблице\n\n* `term_only_queries` — число запросов в таблице, содержащих только термы; остальные запросы используют расширенный синтаксис запросов.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->"
    },
    "is_code_or_comment": false
  },
  "3bb6a4c2dd7d3a10702a6e63638e444ec205f936c7d4c573e246ffcf32e94324": {
    "original": "INSERT INTO facetdemo(title, brand_name, brand_id, categories, price, j, property) VALUES\n\n('Product Ten Three', 'Brand One', 1, (1,2), 100,  '{\"prop1\":66,\"prop2\":91,\"prop3\":\"One\"}', 'Six_Ten'),\n\n('Product Ten Four', 'Brand One', 1, (2,3), 100,  '{\"prop1\":67,\"prop2\":92,\"prop3\":\"Two\"}', 'Six_Ten'),\n\n('Product Ten Nine', 'Brand Two', 2), (1,2), 120,  '{\"prop1\":67,\"prop2\":93,\"prop3\":\"Nine\"}', 'Six_Nine'),\n\n('Product Ten Ten', 'Brand Two', 2), (1,2), 150,  '{\"prop1\":66,\"prop2\":94,\"prop3\":\"Ten\"}', 'Six_Nine');\n\n--> \n\n<!-- example show meta facets -->\n\nWhen utilizing [faceted search](../Searching/Faceted_search.md), you can examine the `multiplier` field in the `SHOW META` output to determine how many queries were executed in an optimized group.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_21\n\n<!-- response SQL -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_23\n\n<!-- response JSON -->\n\nCODE_BLOCK_24\n\n<!-- end -->\n\n## SHOW META and query optimizer\n\n<!-- example of show meta vs query optimizer -->\n\nWhen the [cost-based query optimizer](../Searching/Cost_based_optimizer.md) chooses to use `DocidIndex`, `ColumnarScan`, or `SecondaryIndex` instead of a plain filter, this is reflected in the `SHOW META` command.\n\nThe `index` variable displays the names and types of secondary indexes used during query execution. The percentage indicates how many disk chunks (in the case of an RT table) or pseudo shards (in the case of a plain table) utilized the secondary index.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_25\n\n<!-- response SQL -->\n\nCODE_BLOCK_26\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_27\n\n<!-- response JSON -->\n\nCODE_BLOCK_28\n\n<!-- end -->\n\n## SHOW META for PQ tables\n\n<!-- example show meta PQ -->\n\n`SHOW META` can be used after executing a [CALL PQ](../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ) statement, in which case it provides different output.\n\n`SHOW META` following a `CALL PQ` statement includes:\n\n* `total` - Total time spent on matching the document(s)\n\n* `queries_matched` - Number of stored queries that match the document(s)\n\n* `document_matches` - Number of documents that matched the queries stored in the table\n\n* `total_queries_stored` - Total number of queries stored in the table\n\n* `term_only_queries` - Number of queries in the table that have terms; the remaining queries use extended query syntax.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_29\n\n<!-- response SQL -->\n\nCODE_BLOCK_30\n\n<!-- end -->\n\n<!-- example call pq verbose meta  -->\n\nUsing `CALL PQ` with a `verbose` option provides more detailed output.\n\nIt includes the following additional entries:\n\n* `Setup` - Time spent on the initial setup of the matching process, such as parsing docs and setting options\n\n* `Queries failed` - Number of queries that failed\n\n* `Fast rejected queries` - Number of queries that were not fully evaluated but quickly matched and rejected using filters or other conditions\n\n* `Time per query` - Detailed time for each query\n\n* `Time of matched queries` - Total time spent on queries that matched any documents\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_31\n\n<!-- response SQL -->\n\nCODE_BLOCK_32\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "INSERT INTO facetdemo(title, brand_name, brand_id, categories, price, j, property) VALUES\n\n('产品十 三', '品牌一', 1, (1,2), 100,  '{\"prop1\":66,\"prop2\":91,\"prop3\":\"One\"}', 'Six_Ten'),\n\n('产品十 四', '品牌一', 1, (2,3), 100,  '{\"prop1\":67,\"prop2\":92,\"prop3\":\"Two\"}', 'Six_Ten'),\n\n('产品十 九', '品牌二', 2), (1,2), 120,  '{\"prop1\":67,\"prop2\":93,\"prop3\":\"Nine\"}', 'Six_Nine'),\n\n('产品十 十', '品牌二', 2), (1,2), 150,  '{\"prop1\":66,\"prop2\":94,\"prop3\":\"Ten\"}', 'Six_Nine');\n\n--> \n\n<!-- example show meta facets -->\n\n使用[分面搜索](../Searching/Faceted_search.md)时，您可以查看 `SHOW META` 输出中的 `multiplier` 字段，以确定优化组中执行了多少查询。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_21\n\n<!-- response SQL -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_23\n\n<!-- response JSON -->\n\nCODE_BLOCK_24\n\n<!-- end -->\n\n## SHOW META 和查询优化器\n\n<!-- example of show meta vs query optimizer -->\n\n当[基于成本的查询优化器](../Searching/Cost_based_optimizer.md)选择使用 `DocidIndex`、`ColumnarScan` 或 `SecondaryIndex` 代替普通过滤器时，这将在 `SHOW META` 命令中体现。\n\n`index` 变量显示的是查询执行过程中使用的二级索引名称和类型。百分比表示使用二级索引的磁盘块数（对于 RT 表）或伪分片数（对于普通表）的比例。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_25\n\n<!-- response SQL -->\n\nCODE_BLOCK_26\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_27\n\n<!-- response JSON -->\n\nCODE_BLOCK_28\n\n<!-- end -->\n\n## PQ 表的 SHOW META\n\n<!-- example show meta PQ -->\n\n执行[调用 PQ](../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ)语句后，可以使用 `SHOW META`，此时它提供不同的输出。\n\n紧跟 `CALL PQ` 语句的 `SHOW META` 包含：\n\n* `total` - 匹配文档所花费的总时间\n\n* `queries_matched` - 匹配文档的存储查询数\n\n* `document_matches` - 匹配表中存储查询的文档数\n\n* `total_queries_stored` - 表中存储的查询总数\n\n* `term_only_queries` - 表中仅含术语的查询数；其余查询使用扩展查询语法。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_29\n\n<!-- response SQL -->\n\nCODE_BLOCK_30\n\n<!-- end -->\n\n<!-- example call pq verbose meta  -->\n\n使用带有 `verbose` 选项的 `CALL PQ` 会提供更详细的输出。\n\n它包含以下附加条目：\n\n* `Setup` - 匹配过程初始设置所花费的时间，如解析文档和设置选项\n\n* `Queries failed` - 失败的查询数\n\n* `Fast rejected queries` - 未完全评估但通过过滤器或其他条件快速匹配并拒绝的查询数\n\n* `Time per query` - 每个查询的详细时间\n\n* `Time of matched queries` - 匹配任何文档的查询所花费的总时间\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_31\n\n<!-- response SQL -->\n\nCODE_BLOCK_32\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "INSERT INTO facetdemo(title, brand_name, brand_id, categories, price, j, property) VALUES\n\n('Product Ten Three', 'Brand One', 1, (1,2), 100,  '{\"prop1\":66,\"prop2\":91,\"prop3\":\"One\"}', 'Six_Ten'),\n\n('Product Ten Four', 'Brand One', 1, (2,3), 100,  '{\"prop1\":67,\"prop2\":92,\"prop3\":\"Two\"}', 'Six_Ten'),\n\n('Product Ten Nine', 'Brand Two', 2), (1,2), 120,  '{\"prop1\":67,\"prop2\":93,\"prop3\":\"Nine\"}', 'Six_Nine'),\n\n('Product Ten Ten', 'Brand Two', 2), (1,2), 150,  '{\"prop1\":66,\"prop2\":94,\"prop3\":\"Ten\"}', 'Six_Nine');\n\n--> \n\n<!-- example show meta facets -->\n\nПри использовании [фасетного поиска](../Searching/Faceted_search.md) вы можете проверить поле `multiplier` в выводе `SHOW META`, чтобы определить, сколько запросов было выполнено в оптимизированной группе.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_21\n\n<!-- response SQL -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_23\n\n<!-- response JSON -->\n\nCODE_BLOCK_24\n\n<!-- end -->\n\n## SHOW META и оптимизатор запросов\n\n<!-- example of show meta vs query optimizer -->\n\nКогда [оптимизатор запросов на основе стоимости](../Searching/Cost_based_optimizer.md) выбирает использование `DocidIndex`, `ColumnarScan` или `SecondaryIndex` вместо обычного фильтра, это отражается в команде `SHOW META`.\n\nПеременная `index` отображает имена и типы используемых во время выполнения запроса вторичных индексов. Процент указывает, сколько дисковых чанков (в случае RT таблицы) или псевдо-шардов (в случае обычной таблицы) использовали вторичный индекс.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_25\n\n<!-- response SQL -->\n\nCODE_BLOCK_26\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_27\n\n<!-- response JSON -->\n\nCODE_BLOCK_28\n\n<!-- end -->\n\n## SHOW META для PQ таблиц\n\n<!-- example show meta PQ -->\n\n`SHOW META` можно использовать после выполнения [CALL PQ](../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ), в этом случае он предоставляет другой вывод.\n\n`SHOW META`, следующий за оператором `CALL PQ`, включает:\n\n* `total` - Общее время, затраченное на сопоставление документа(ов)\n\n* `queries_matched` - Количество сохранённых запросов, которые совпали с документом(ами)\n\n* `document_matches` - Количество документов, которые совпали с запросами, сохранёнными в таблице\n\n* `total_queries_stored` - Общее количество запросов, сохранённых в таблице\n\n* `term_only_queries` - Количество запросов в таблице, которые содержат термы; остальные запросы используют расширенный синтаксис запросов.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_29\n\n<!-- response SQL -->\n\nCODE_BLOCK_30\n\n<!-- end -->\n\n<!-- example call pq verbose meta  -->\n\nИспользование `CALL PQ` с опцией `verbose` предоставляет более подробный вывод.\n\nОн включает следующие дополнительные записи:\n\n* `Setup` - Время, затраченное на первоначальную настройку процесса сопоставления, такую как разбор документов и настройка опций\n\n* `Queries failed` - Количество запросов, которые завершились ошибкой\n\n* `Fast rejected queries` - Количество запросов, которые не были полностью оценены, но были быстро сопоставлены и отклонены с использованием фильтров или других условий\n\n* `Time per query` - Подробное время для каждого запроса\n\n* `Time of matched queries` - Общее время, затраченное на запросы, которые совпали с любыми документами\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_31\n\n<!-- response SQL -->\n\nCODE_BLOCK_32\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "1bfc5865a0d02a6dbb0c81dbd13148fbe223bcac20463a8c540ae7a0603b6a1c": {
    "original": "# SHOW META\n\nCODE_BLOCK_0\n\n<!-- example show meta -->\n\n`SHOW META` is an SQL statement that displays additional meta-information about the processed query, including the query time, keyword statistics, and information about the secondary indexes used. The syntax is:\n\nThe included items are:\n\n* `total`: The number of matches that were actually retrieved and sent to the client. This value is typically limited by the [LIMIT/size](../Searching/Pagination.md#Pagination-of-search-results) search option.\n\n* `total_found`:\n\n  - The estimated total number of matches for the query in the index. If you need the exact number of matches, use `SELECT COUNT(*)` instead of relying on this value.\n\n  - For queries with `GROUP BY`, `total_found` represents the number of groups instead of individual matches.\n\n  - When using `HAVING` with `GROUP BY`, `total_found` reflects the number of groups **after** the `HAVING` filter is applied. This enables proper pagination with `HAVING` clauses.\n\n  - For [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) queries, `total_found` still represents the number of groups, regardless of the value of `N`.\n\n* `total_relation`: Indicates whether the `total_found` value is exact or an estimate.\n\n  - If Manticore cannot determine the precise `total_found` value, this field will display `total_relation: gte`, meaning the actual number of matches is **Greater Than or Equal** to the reported `total_found`.\n\n  - If the `total_found` value is exact, `total_relation: eq` will be displayed.\n\n* `time`: The duration (in seconds) it took to process the search query.\n\n* `keyword[N]`: The n-th keyword used in the search query. Note that the keyword can be presented as a wildcard, e.g., `abc*`.\n\n* `docs[N]`: The total number of documents (or records) containing the n-th keyword from the search query. If the keyword is presented as a wildcard, this value represents the sum of documents for all expanded sub-keywords, potentially exceeding the actual number of matched documents.\n\n* `hits[N]`: The total number of occurrences (or hits) of the n-th keyword across all documents.\n\n* `index`: Information about the utilized index (e.g., secondary index).\n\n<!--\n\ndata for the following examples:\n\nDROP TABLE IF EXISTS hn_small;\n\nCREATE TABLE hn_small(story_author text, comment_ranking int);\n\nINSERT INTO hn_small(story_author, comment_ranking) VALUES\n\n('anewkid', 4),\n\n('sasjri', 1),\n\n('bks', 5);\n\n--> \n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- response SQL -->\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_3\n\n<!-- response JSON -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n<!--\n\ndata for the following example:\n\nDROP TABLE IF EXISTS records;\n\nCREATE TABLE records(content text, channel_id int);\n\nINSERT INTO records(story_author, channel_id) VALUES\n\n('record one', 4),\n\n('record two', 1),\n\n('record three', 3),\n\n('record four', 4),\n\n('record twenty one', 2),\n\n('record twenty two', 2),\n\n-->\n\n<!-- example show meta iostats cpustats -->\n\n`SHOW META` can display I/O and CPU counters, but they will only be available if searchd was started with the `--iostats` and `--cpustats` switches, respectively.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- response SQL -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_7\n\n<!-- response JSON -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!--\n\ndata for the following examples:\n\nDROP TABLE IF EXISTS hn_small;\n\nCREATE TABLE hn_small(story_author text, comment_ranking int);\n\nINSERT INTO hn_small(story_author, comment_ranking) VALUES\n\n('anewkid', 4),\n\n('sasjri', 1),\n\n('bks', 5);\n\n-->\n\n<!-- example show meta predicted_time -->\n\nAdditional values, such as `predicted_time`, `dist_predicted_time`, `local_fetched_docs`, `local_fetched_hits`, `local_fetched_skips`, and their respective `dist_fetched_*` counterparts, will only be available if `searchd` was configured with [predicted time costs](../Server_settings/Searchd.md#predicted_time_costs) and the query included `predicted_time` in the `OPTION` clause.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- response SQL -->\n\nCODE_BLOCK_10\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_11\n\n<!-- response JSON -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n<!--\n\ndata for the following examples:\n\nDROP TABLE IF EXISTS hn_small;\n\nCREATE TABLE hn_small(story_author text, comment_ranking int);\n\nINSERT INTO hn_small(story_author, comment_ranking) VALUES\n\n('anewkid', 4),\n\n('sasjri', 1),\n\n('bks', 5);\n\n-->\n\n<!-- example show meta single statement -->\n\n`SHOW META` must be executed immediately after the query in the **same** session. Since some MySQL connectors/libraries use connection pools, running `SHOW META` in a separate statement can lead to unexpected results, such as retrieving metadata from another query. In these cases (and generally recommended), run a multiple statement containing both the query and `SHOW META`. Some connectors/libraries support multi-queries within the same method for a single statement, while others may require the use of a dedicated method for multi-queries or setting specific options during connection setup.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_13\n\n<!-- response SQL -->\n\nCODE_BLOCK_14\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_15\n\n<!-- response JSON -->\n\nCODE_BLOCK_16\n\n<!-- end -->\n\n<!-- example SHOW META LIKE -->\n\nYou can also use the optional LIKE clause, which allows you to select only the variables that match a specific pattern. The pattern syntax follows standard SQL wildcards, where `%` represents any number of any characters, and `_` represents a single character.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_17\n\n<!-- response SQL -->\n\nCODE_BLOCK_18\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_19\n\n<!-- response JSON -->\n\nCODE_BLOCK_20\n\n<!-- end -->\n\n## SHOW META and facets\n\n<!--\n\ndata for the following example:\n\nDROP TABLE IF EXISTS facetdemo;\n\nCREATE TABLE facetdemo(title text, brand_name string, brand_id int, categories multi, price float, j json, property string);",
    "translations": {
      "chinese": "# SHOW META\n\nCODE_BLOCK_0\n\n<!-- example show meta -->\n\n`SHOW META` 是一个 SQL 语句，用于显示有关已处理查询的附加元信息，包括查询时间、关键字统计以及使用的二级索引信息。语法如下：\n\n包含的项目有：\n\n* `total`：实际检索并发送给客户端的匹配数。此值通常受 [LIMIT/size](../Searching/Pagination.md#Pagination-of-search-results) 搜索选项限制。\n\n* `total_found`：\n\n  - 索引中查询匹配的估计总数。如果需要精确的匹配数，请使用 `SELECT COUNT(*)`，不要依赖此值。\n\n  - 对于含 `GROUP BY` 的查询，`total_found` 表示分组数而非单个匹配数。\n\n  - 当与 `GROUP BY` 一起使用 `HAVING` 时，`total_found` 反映的是应用 `HAVING` 过滤后组的数量。这确保了包含 `HAVING` 子句时的正确分页。\n\n  - 对于 [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) 查询，`total_found` 仍代表组数，无论 `N` 的值是多少。\n\n* `total_relation`：指示 `total_found` 值是精确还是估计。\n\n  - 如果 Manticore 无法确定精确的 `total_found` 值，此字段会显示 `total_relation: gte`，意味着实际匹配数**大于或等于**报告的 `total_found`。\n\n  - 如果 `total_found` 值是精确的，则显示 `total_relation: eq`。\n\n* `time`：处理搜索查询所耗费的时间（秒）。\n\n* `keyword[N]`：搜索查询中第 n 个关键字。关键字可能以通配符形式呈现，如 `abc*`。\n\n* `docs[N]`：包含搜索查询中第 n 个关键字的文档（或记录）总数。如果关键字是通配符形式，此值表示所有扩展子关键字文档数的总和，可能超过实际匹配文档数。\n\n* `hits[N]`：第 n 个关键字在所有文档中的总出现次数（命中数）。\n\n* `index`：有关所用索引的信息（例如二级索引）。\n\n<!--\n\ndata for the following examples:\n\nDROP TABLE IF EXISTS hn_small;\n\nCREATE TABLE hn_small(story_author text, comment_ranking int);\n\nINSERT INTO hn_small(story_author, comment_ranking) VALUES\n\n('anewkid', 4),\n\n('sasjri', 1),\n\n('bks', 5);\n\n--> \n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- response SQL -->\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_3\n\n<!-- response JSON -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n<!--\n\ndata for the following example:\n\nDROP TABLE IF EXISTS records;\n\nCREATE TABLE records(content text, channel_id int);\n\nINSERT INTO records(story_author, channel_id) VALUES\n\n('record one', 4),\n\n('record two', 1),\n\n('record three', 3),\n\n('record four', 4),\n\n('record twenty one', 2),\n\n('record twenty two', 2),\n\n-->\n\n<!-- example show meta iostats cpustats -->\n\n`SHOW META` 可以显示 I/O 和 CPU 计数器，但仅当 searchd 分别使用 `--iostats` 和 `--cpustats` 参数启动时才可用。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- response SQL -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_7\n\n<!-- response JSON -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!--\n\ndata for the following examples:\n\nDROP TABLE IF EXISTS hn_small;\n\nCREATE TABLE hn_small(story_author text, comment_ranking int);\n\nINSERT INTO hn_small(story_author, comment_ranking) VALUES\n\n('anewkid', 4),\n\n('sasjri', 1),\n\n('bks', 5);\n\n-->\n\n<!-- example show meta predicted_time -->\n\n额外的值，如 `predicted_time`、`dist_predicted_time`、`local_fetched_docs`、`local_fetched_hits`、`local_fetched_skips` 及其各自的 `dist_fetched_*` 对应值，只有当 `searchd` 配置了[预测时间成本](../Server_settings/Searchd.md#predicted_time_costs)且查询在 `OPTION` 子句中包含 `predicted_time` 时才可用。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- response SQL -->\n\nCODE_BLOCK_10\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_11\n\n<!-- response JSON -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n<!--\n\ndata for the following examples:\n\nDROP TABLE IF EXISTS hn_small;\n\nCREATE TABLE hn_small(story_author text, comment_ranking int);\n\nINSERT INTO hn_small(story_author, comment_ranking) VALUES\n\n('anewkid', 4),\n\n('sasjri', 1),\n\n('bks', 5);\n\n-->\n\n<!-- example show meta single statement -->\n\n`SHOW META` 必须在**同一**会话中紧接查询后执行。由于某些 MySQL 连接器/库使用连接池，单独执行 `SHOW META` 可能会导致意外结果，比如获取到其他查询的元数据。在这些情况下（且一般建议做法），运行一个包含查询和 `SHOW META` 的多语句。有些连接器/库支持单个方法中多查询语句，而其他可能需要专门的多查询方法或在连接设置时指定特定选项。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_13\n\n<!-- response SQL -->\n\nCODE_BLOCK_14\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_15\n\n<!-- response JSON -->\n\nCODE_BLOCK_16\n\n<!-- end -->\n\n<!-- example SHOW META LIKE -->\n\n您也可以使用可选的 LIKE 子句，选择仅匹配特定模式的变量。模式语法遵循标准 SQL 通配符，其中 `%` 表示任意数量的任意字符，`_` 表示单个字符。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_17\n\n<!-- response SQL -->\n\nCODE_BLOCK_18\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_19\n\n<!-- response JSON -->\n\nCODE_BLOCK_20\n\n<!-- end -->\n\n## SHOW META 和 facets\n\n<!--\n\ndata for the following example:\n\nDROP TABLE IF EXISTS facetdemo;\n\nCREATE TABLE facetdemo(title text, brand_name string, brand_id int, categories multi, price float, j json, property string);",
      "russian": "# SHOW META\n\nCODE_BLOCK_0\n\n<!-- example show meta -->\n\n`SHOW META` — это SQL-запрос, который отображает дополнительную метаинформацию о выполненном запросе, включая время выполнения запроса, статистику по ключевым словам и информацию о вторичных индексах, которые использовались. Синтаксис следующий:\n\nВключённые элементы:\n\n* `total`: Количество совпадений, которые были фактически извлечены и отправлены клиенту. Это значение обычно ограничивается параметром поиска [LIMIT/size](../Searching/Pagination.md#Pagination-of-search-results).\n\n* `total_found`:\n\n  - Оценочное общее количество совпадений по запросу в индексе. Если нужен точный подсчёт совпадений, используйте `SELECT COUNT(*)`, вместо того чтобы полагаться на это значение.\n\n  - Для запросов с `GROUP BY`, `total_found` представляет количество групп, а не отдельных совпадений.\n\n  - При использовании `HAVING` с `GROUP BY`, `total_found` отражает число групп **после** применения фильтра `HAVING`. Это позволяет корректно делать пагинацию с условиями `HAVING`.\n\n  - Для запросов [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) `total_found` по-прежнему представляет количество групп, независимо от значения `N`.\n\n* `total_relation`: Указывает, является ли значение `total_found` точным или оценочным.\n\n  - Если Manticore не может установить точное значение `total_found`, в этом поле будет указано `total_relation: gte`, что означает, что фактическое количество совпадений **больше или равно** отчётному значению `total_found`.\n\n  - Если значение `total_found` точно, будет отображено `total_relation: eq`.\n\n* `time`: Время (в секундах), затраченное на обработку поискового запроса.\n\n* `keyword[N]`: N-ое ключевое слово, использованное в поисковом запросе. Обратите внимание, что ключевое слово может содержать подстановочные символы, например, `abc*`.\n\n* `docs[N]`: Общее количество документов (или записей), в которых содержится N-ое ключевое слово из поискового запроса. Если ключевое слово задано с подстановкой, это значение представляет сумму документов для всех расширенных под-ключевых слов и может превышать фактическое количество подходящих документов.\n\n* `hits[N]`: Общее количество вхождений (или попаданий) N-го ключевого слова во всех документах.\n\n* `index`: Информация об используемом индексе (например, вторичном индексе).\n\n<!--\n\ndata for the following examples:\n\nDROP TABLE IF EXISTS hn_small;\n\nCREATE TABLE hn_small(story_author text, comment_ranking int);\n\nINSERT INTO hn_small(story_author, comment_ranking) VALUES\n\n('anewkid', 4),\n\n('sasjri', 1),\n\n('bks', 5);\n\n--> \n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- response SQL -->\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_3\n\n<!-- response JSON -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n<!--\n\ndata for the following example:\n\nDROP TABLE IF EXISTS records;\n\nCREATE TABLE records(content text, channel_id int);\n\nINSERT INTO records(story_author, channel_id) VALUES\n\n('record one', 4),\n\n('record two', 1),\n\n('record three', 3),\n\n('record four', 4),\n\n('record twenty one', 2),\n\n('record twenty two', 2),\n\n-->\n\n<!-- example show meta iostats cpustats -->\n\n`SHOW META` может отображать счётчики ввода-вывода (I/O) и процессора (CPU), но они будут доступны только если searchd был запущен с переключателями `--iostats` и `--cpustats` соответственно.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- response SQL -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_7\n\n<!-- response JSON -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!--\n\ndata for the following examples:\n\nDROP TABLE IF EXISTS hn_small;\n\nCREATE TABLE hn_small(story_author text, comment_ranking int);\n\nINSERT INTO hn_small(story_author, comment_ranking) VALUES\n\n('anewkid', 4),\n\n('sasjri', 1),\n\n('bks', 5);\n\n-->\n\n<!-- example show meta predicted_time -->\n\nДополнительные значения, такие как `predicted_time`, `dist_predicted_time`, `local_fetched_docs`, `local_fetched_hits`, `local_fetched_skips`, а также их соответствующие `dist_fetched_*` аналоги, будут доступны только если `searchd` был настроен с использованием [предсказанных затрат времени](../Server_settings/Searchd.md#predicted_time_costs) и запрос включал `predicted_time` в опции `OPTION`.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- response SQL -->\n\nCODE_BLOCK_10\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_11\n\n<!-- response JSON -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n<!--\n\ndata for the following examples:\n\nDROP TABLE IF EXISTS hn_small;\n\nCREATE TABLE hn_small(story_author text, comment_ranking int);\n\nINSERT INTO hn_small(story_author, comment_ranking) VALUES\n\n('anewkid', 4),\n\n('sasjri', 1),\n\n('bks', 5);\n\n-->\n\n<!-- example show meta single statement -->\n\n`SHOW META` должен выполняться непосредственно после запроса в **той же** сессии. Поскольку некоторые MySQL коннекторы/библиотеки используют пулы соединений, выполнение `SHOW META` отдельным запросом может привести к неожиданным результатам, например, к получению метаданных от другого запроса. В таких случаях (и вообще рекомендуемым способом) запускайте составной запрос, содержащий как сам запрос, так и `SHOW META`. Некоторые коннекторы/библиотеки поддерживают несколько запросов (multi-queries) в одном вызове метода для одного запроса, другие могут требовать использования специального метода для multi-queries или настройки определённых опций при установке соединения.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_13\n\n<!-- response SQL -->\n\nCODE_BLOCK_14\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_15\n\n<!-- response JSON -->\n\nCODE_BLOCK_16\n\n<!-- end -->\n\n<!-- example SHOW META LIKE -->\n\nВы также можете использовать опциональный оператор LIKE, который позволяет выбрать только те переменные, которые соответствуют определённому шаблону. Синтаксис шаблона соответствует стандартным SQL-подстановкам, где `%` соответствует любому количеству любых символов, а `_` — одному произвольному символу.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_17\n\n<!-- response SQL -->\n\nCODE_BLOCK_18\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_19\n\n<!-- response JSON -->\n\nCODE_BLOCK_20\n\n<!-- end -->\n\n## SHOW META и фасеты\n\n<!--\n\ndata for the following example:\n\nDROP TABLE IF EXISTS facetdemo;\n\nCREATE TABLE facetdemo(title text, brand_name string, brand_id int, categories multi, price float, j json, property string);"
    },
    "is_code_or_comment": false
  }
}
