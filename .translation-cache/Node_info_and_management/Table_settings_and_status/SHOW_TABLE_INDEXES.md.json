{
  "dbcf6dad5f34e54afd7190ef3819e9d242ff431d5be71afe7320495260b626a9": {
    "original": "# SHOW TABLE INDEXES\n\n<!-- example SHOW TABLE INDEXES -->\n\nThe `SHOW TABLE INDEXES` SQL statement displays the secondary indexes available for a specified table, along with their properties. [Secondary indexes](../../Server_settings/Searchd.md#secondary_indexes) improve query performance by creating additional data structures that speed up searches on specific columns.\n\nThe syntax is:\n\nCODE_BLOCK_0\n\nThe displayed properties include the following columns:\n\n* **Name**: The name of the secondary index. Can be used in [query optimizer hints](../../Searching/Options.md#Query-optimizer-hints).\n\n* **Type**: The type of data stored in the secondary index. For plain attributes, it matches the type of the original attribute. For secondary indexes generated from JSON attributes, the type is deduced by scanning all documents and determining the types of all JSON properties.\n\n* **Enabled**: Indicates whether the index is currently enabled and can be used to improve search speed. When an attribute is updated, the secondary index for that attribute is temporarily disabled until the index is rebuilt. You can rebuild disabled indexes using the [ALTER TABLE ... REBUILD SECONDARY](../../Updating_table_schema_and_settings.md#Rebuilding-a-secondary-index) command.\n\n* **Percent**: In an RT table, different disk chunks may contain different secondary indexes especially when JSON attributes are used. This percentage shows how many chunks have an index with the same name, type, and enabled state.\n\n> **Note:** For RT tables, secondary indexes are only created for disk chunks, not for data in RAM segments. When you first insert data into an RT table, it stays in RAM and no secondary indexes will be shown. The indexes become visible only after the data is flushed to disk chunks, which by default happens automatically when the table becomes active (receives both inserts and searches).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- response SQL -->\n\nCODE_BLOCK_2\n\n<!-- end -->",
    "translations": {
      "chinese": "# SHOW TABLE INDEXES\n\n<!-- example SHOW TABLE INDEXES -->\n\n`SHOW TABLE INDEXES` SQL 语句显示指定表的可用二级索引及其属性。[二级索引](../../Server_settings/Searchd.md#secondary_indexes) 通过创建额外的数据结构来加速特定列的搜索，从而提升查询性能。\n\n语法如下：\n\nCODE_BLOCK_0\n\n显示的属性包括以下列：\n\n* **Name**：二级索引的名称。可用于[查询优化器提示](../../Searching/Options.md#Query-optimizer-hints)。\n\n* **Type**：二级索引中存储的数据类型。对于普通属性，类型与原始属性类型相同。对于从 JSON 属性生成的二级索引，类型通过扫描所有文档并确定所有 JSON 属性的类型来推断。\n\n* **Enabled**：指示索引当前是否启用，是否可用于提升搜索速度。当属性被更新时，该属性的二级索引会暂时禁用，直到索引重建。您可以使用[ALTER TABLE ... REBUILD SECONDARY](../../Updating_table_schema_and_settings.md#Rebuilding-a-secondary-index) 命令重建被禁用的索引。\n\n* **Percent**：在 RT 表中，不同的磁盘块可能包含不同的二级索引，尤其是在使用 JSON 属性时。此百分比显示有多少块包含具有相同名称、类型和启用状态的索引。\n\n> **注意：** 对于 RT 表，二级索引仅为磁盘块创建，不为 RAM 段中的数据创建。当您首次向 RT 表插入数据时，数据保存在 RAM 中，二级索引不会显示。索引仅在数据刷新到磁盘块后可见，默认情况下，当表变为活动状态（同时接收插入和搜索）时会自动刷新。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- response SQL -->\n\nCODE_BLOCK_2\n\n<!-- end -->",
      "russian": "# SHOW TABLE INDEXES\n\n<!-- example SHOW TABLE INDEXES -->\n\nОператор SQL `SHOW TABLE INDEXES` отображает доступные вторичные индексы для указанной таблицы вместе с их свойствами. [Вторичные индексы](../../Server_settings/Searchd.md#secondary_indexes) улучшают производительность запросов, создавая дополнительные структуры данных, которые ускоряют поиск по определённым столбцам.\n\nСинтаксис:\n\nCODE_BLOCK_0\n\nОтображаемые свойства включают следующие столбцы:\n\n* **Name**: Имя вторичного индекса. Может использоваться в [подсказках оптимизатора запросов](../../Searching/Options.md#Query-optimizer-hints).\n\n* **Type**: Тип данных, хранящихся во вторичном индексе. Для простых атрибутов он совпадает с типом исходного атрибута. Для вторичных индексов, созданных из JSON-атрибутов, тип определяется путём сканирования всех документов и определения типов всех JSON-свойств.\n\n* **Enabled**: Указывает, включён ли индекс в данный момент и может ли использоваться для ускорения поиска. Когда атрибут обновляется, вторичный индекс для этого атрибута временно отключается до тех пор, пока индекс не будет перестроен. Вы можете перестроить отключённые индексы с помощью команды [ALTER TABLE ... REBUILD SECONDARY](../../Updating_table_schema_and_settings.md#Rebuilding-a-secondary-index).\n\n* **Percent**: В RT-таблице разные дисковые чанки могут содержать разные вторичные индексы, особенно при использовании JSON-атрибутов. Этот процент показывает, сколько чанков имеют индекс с одинаковым именем, типом и состоянием включения.\n\n> **Примечание:** Для RT-таблиц вторичные индексы создаются только для дисковых чанков, а не для данных в RAM-сегментах. Когда вы впервые вставляете данные в RT-таблицу, они остаются в RAM, и вторичные индексы не отображаются. Индексы становятся видимыми только после сброса данных в дисковые чанки, что по умолчанию происходит автоматически, когда таблица становится активной (получает и вставки, и поисковые запросы).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- response SQL -->\n\nCODE_BLOCK_2\n\n<!-- end -->"
    },
    "is_code_or_comment": false
  },
  "135d7d839c5e475ccef610d1d7fc123b09446f929cb44a26b44dfd05682dd370": {
    "original": "# SHOW TABLE INDEXES\n\n<!-- example SHOW TABLE INDEXES -->\n\nThe `SHOW TABLE INDEXES` SQL statement displays the secondary indexes available for a specified table, along with their properties. [Secondary indexes](../../Server_settings/Searchd.md#secondary_indexes) improve query performance by creating additional data structures that speed up searches on specific columns.\n\nThe syntax is:\n\nCODE_BLOCK_0\n\nThe displayed properties include the following columns:\n\n* **Name**: The name of the secondary index. Can be used in [query optimizer hints](../../Searching/Options.md#Query-optimizer-hints).\n\n* **Type**: The type of data stored in the secondary index. For plain attributes, it matches the type of the original attribute. For secondary indexes generated from JSON attributes, the type is deduced by scanning all documents and determining the types of all JSON properties.\n\n* **Enabled**: Indicates whether the index is currently enabled and can be used to improve search speed. When an attribute is updated, the secondary index for that attribute is temporarily disabled until the index is rebuilt. You can rebuild disabled indexes using the [ALTER TABLE ... REBUILD SECONDARY](../../Updating_table_schema_and_settings.md#Rebuilding-a-secondary-index) command.\n\n* **Percent**: In an RT table, different disk chunks may contain different secondary indexes especially when JSON attributes are used. This percentage shows how many chunks have an index with the same name, type, and enabled state.\n\n> **Note:** For RT tables, secondary indexes are only created for disk chunks, not for data in RAM segments. When you first insert data into an RT table, it stays in RAM and no secondary indexes will be shown. The indexes become visible only after the data is flushed to disk chunks, which by default happens automatically when the table becomes active (receives both inserts and searches).\n\n<!--\n\ndata for the following examples:\n\nDROP TABLE IF EXISTS test;\n\nCREATE TABLE test(j json);\n\nINSERT INTO test(j) VALUES\n\n( '{\"addresses\": {\"a1\":{\"id\":\"1\",\"name\":\"a\"},\"a2\":{\"id\":\"2\",\"name\":\"b\"},\"a3\":{\"id\":\"3\",\"name\":\"c\"},\"a4\":{\"id\":\"4\",\"name\":\"d\"},\"a5\":{\"id\":\"5\",\"name\":\"e\"},\"a6\":{\"id\":\"6\",\"name\":\"f\"}},\"factor\":2,\"int_arr\":[1,2,3],\"tags\": [\"1\":{},\"2\":{},\"3\":{}],\"arr\":\"a\",\"str\":\"a\",\"price\":1.0 }' );\n\nFLUSH RAMCHUNK test;\n\n--> \n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- response SQL -->\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_3\n\n<!-- response JSON -->\n\nCODE_BLOCK_4\n\n,\n\n<!-- end -->",
    "translations": {
      "chinese": "# SHOW TABLE INDEXES\n\n<!-- example SHOW TABLE INDEXES -->\n\n`SHOW TABLE INDEXES` SQL语句显示指定表的可用二级索引及其属性。[二级索引](../../Server_settings/Searchd.md#secondary_indexes)通过创建额外的数据结构，加快对特定列的搜索，从而提高查询性能。\n\n语法如下：\n\nCODE_BLOCK_0\n\n显示的属性包括以下列：\n\n* **Name**：二级索引的名称。可以在[查询优化器提示](../../Searching/Options.md#Query-optimizer-hints)中使用。\n\n* **Type**：二级索引中存储的数据类型。对于普通属性，类型与原始属性相同。对于从JSON属性生成的二级索引，类型则通过扫描所有文档并确定所有JSON属性的类型来推断。\n\n* **Enabled**：指示索引当前是否启用，是否可以用于提高搜索速度。当属性被更新时，该属性的二级索引会被暂时禁用，直到索引被重建。您可以使用[ALTER TABLE ... REBUILD SECONDARY](../../Updating_table_schema_and_settings.md#Rebuilding-a-secondary-index)命令重建已禁用的索引。\n\n* **Percent**：在RT表中，不同的磁盘块可能包含不同的二级索引，尤其是在使用JSON属性时。此百分比显示有多少块具有相同名称、类型和启用状态的索引。\n\n> **注意：** 对于RT表，二级索引仅为磁盘块创建，而不会为RAM段中的数据创建。当您首次向RT表插入数据时，数据保存在RAM中，二级索引不会显示。只有当数据刷新到磁盘块后，索引才会可见，默认情况下，当表变为活动状态（同时接收插入和搜索）时会自动发生刷新。\n\n<!--\n\ndata for the following examples:\n\nDROP TABLE IF EXISTS test;\n\nCREATE TABLE test(j json);\n\nINSERT INTO test(j) VALUES\n\n( '{\"addresses\": {\"a1\":{\"id\":\"1\",\"name\":\"a\"},\"a2\":{\"id\":\"2\",\"name\":\"b\"},\"a3\":{\"id\":\"3\",\"name\":\"c\"},\"a4\":{\"id\":\"4\",\"name\":\"d\"},\"a5\":{\"id\":\"5\",\"name\":\"e\"},\"a6\":{\"id\":\"6\",\"name\":\"f\"}},\"factor\":2,\"int_arr\":[1,2,3],\"tags\": [\"1\":{},\"2\":{},\"3\":{}],\"arr\":\"a\",\"str\":\"a\",\"price\":1.0 }' );\n\nFLUSH RAMCHUNK test;\n\n--> \n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- response SQL -->\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_3\n\n<!-- response JSON -->\n\nCODE_BLOCK_4\n\n,\n\n<!-- end -->",
      "russian": "# SHOW TABLE INDEXES\n\n<!-- example SHOW TABLE INDEXES -->\n\nОператор SQL `SHOW TABLE INDEXES` отображает доступные для указанной таблицы вторичные индексы вместе с их свойствами. [Вторичные индексы](../../Server_settings/Searchd.md#secondary_indexes) улучшают производительность запросов, создавая дополнительные структуры данных, ускоряющие поиск по конкретным столбцам.\n\nСинтаксис имеет вид:\n\nCODE_BLOCK_0\n\nОтображаемые свойства включают следующие столбцы:\n\n* **Name**: Имя вторичного индекса. Может использоваться в [подсказках оптимизатора запросов](../../Searching/Options.md#Query-optimizer-hints).\n\n* **Type**: Тип данных, хранящихся во вторичном индексе. Для обычных атрибутов он совпадает с типом исходного атрибута. Для вторичных индексов, созданных из JSON-атрибутов, тип определяется путем сканирования всех документов и определения типов всех JSON-свойств.\n\n* **Enabled**: Показывает, включен ли индекс в данный момент и может ли использоваться для ускорения поиска. При обновлении атрибута вторичный индекс для этого атрибута временно отключается до тех пор, пока индекс не будет перестроен. Вы можете перестроить отключенные индексы с помощью команды [ALTER TABLE ... REBUILD SECONDARY](../../Updating_table_schema_and_settings.md#Rebuilding-a-secondary-index).\n\n* **Percent**: В RT-таблицах разные дисковые чанки могут содержать разные вторичные индексы, особенно при использовании JSON-атрибутов. Этот процент показывает, сколько чанков содержит индекс с одинаковым именем, типом и состоянием включения.\n\n> **Примечание:** Для RT-таблиц вторичные индексы создаются только для дисковых чанков, а не для данных в RAM-сегментах. Когда вы впервые вставляете данные в RT-таблицу, они остаются в оперативной памяти, и вторичные индексы не будут отображаться. Индексы становятся видимыми только после сброса данных в дисковые чанки, что по умолчанию происходит автоматически, когда таблица становится активной (получает как вставки, так и запросы поиска).\n\n<!--\n\ndata for the following examples:\n\nDROP TABLE IF EXISTS test;\n\nCREATE TABLE test(j json);\n\nINSERT INTO test(j) VALUES\n\n( '{\"addresses\": {\"a1\":{\"id\":\"1\",\"name\":\"a\"},\"a2\":{\"id\":\"2\",\"name\":\"b\"},\"a3\":{\"id\":\"3\",\"name\":\"c\"},\"a4\":{\"id\":\"4\",\"name\":\"d\"},\"a5\":{\"id\":\"5\",\"name\":\"e\"},\"a6\":{\"id\":\"6\",\"name\":\"f\"}},\"factor\":2,\"int_arr\":[1,2,3],\"tags\": [\"1\":{},\"2\":{},\"3\":{}],\"arr\":\"a\",\"str\":\"a\",\"price\":1.0 }' );\n\nFLUSH RAMCHUNK test;\n\n--> \n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- response SQL -->\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_3\n\n<!-- response JSON -->\n\nCODE_BLOCK_4\n\n,\n\n<!-- end -->"
    },
    "is_code_or_comment": false
  }
}
