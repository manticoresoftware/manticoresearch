{
  "b9f64f74ca9facdd384d82aab56d6a10250759fcc22ec3c78f87d6191a1ce10b": {
    "original": "There is an [article about it in our blog](https://manticoresearch.com/blog/simple-autocomplete-with-manticore/) and an [interactive course](https://play.manticoresearch.com/simpleautocomplete/). A quick example is:\n\n* Let's assume you have a document: `My cat loves my dog. The cat (Felis catus) is a domestic species of small carnivorous mammal.`\n\n* Then you can use `^`, `\"\"`, and `*` so as the user is typing, you make queries like: `^\"m*\"`, `^\"my *\"`, `^\"my c*\"`, `^\"my ca*\"` and so on\n\n* It will find the document, and if you also do [highlighting](../Searching/Highlighting.md), you will get something like: `<b>My cat</b> loves my dog. The cat ( ...`\n\n##### Autocomplete a word\n\nIn some cases, all you need is to autocomplete a single word or a couple of words. In this case, you can use `CALL KEYWORDS`.\n\n### CALL KEYWORDS\n\n`CALL KEYWORDS` is available through the SQL interface and offers a way to examine how keywords are tokenized or to obtain the tokenized forms of specific keywords. If the table enables [infixes](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len), it allows you to quickly find possible endings for given keywords, making it suitable for autocomplete functionality.\n\nThis is a great alternative to general infixed search, as it provides higher performance since it only needs the table's dictionary, not the documents themselves.\n\n### General syntax\n\n<!-- example keywords -->\n\nCODE_BLOCK_13\n\nThe `CALL KEYWORDS` statement divides text into keywords. It returns the tokenized and normalized forms of the keywords, and if desired, keyword statistics. Additionally, it provides the position of each keyword in the query and all forms of tokenized keywords when the table enables [lemmatizers](../Creating_a_table/NLP_and_tokenization/Morphology.md).\n\n| Parameter | Description |\n\n| - | - |\n\n| text | Text to break down to keywords |\n\n| table | Name of the table from which to take the text processing settings |\n\n| 0/1 as stats | Show statistics of keywords, default is 0 |\n\n| 0/1 as fold_wildcards | Fold wildcards, default is 0 |\n\n| 0/1 as fold_lemmas | Fold morphological lemmas, default is 0 |\n\n| 0/1 as fold_blended | Fold blended words, default is 0 |\n\n| N as expansion_limit | Override [expansion_limit](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expansion_limit) defined in the server configuration, default is 0 (use value from the configuration) |\n\n| docs/hits as sort_mode | Sorts output results by either 'docs' or 'hits'. No sorting is applied by default. |\n\n| jieba_mode | Jieba segmentation mode for the query. See [jieba_mode](../Creating_a_table/NLP_and_tokenization/Morphology.md#jieba_mode) for more details |\n\nThe examples show how it works if assuming the user is trying to get an autocomplete for \"my cat ...\". So on the application side all you need to do is to suggest the user the endings from the column \"normalized\" for each new word. It often makes sense to sort by hits or docs using `'hits' as sort_mode` or `'docs' as sort_mode`.\n\n<!-- intro -->\n\n##### Examples:\n\n<!-- request Examples -->\n\nCODE_BLOCK_14\n\n<!-- end -->\n\n<!-- example bigram -->\n\nThere is a nice trick how you can improve the above algorithm - use [bigram_index](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#bigram_index). When you have it enabled for the table what you get in it is not just a single word, but each pair of words standing one after another indexed as a separate token.\n\nThis allows to predict not just the current word's ending, but the next word too which is especially beneficial for the purpose of autocomplete.\n\n<!-- intro -->\n\n##### Examples:\n\n<!-- request Examples -->\n\nCODE_BLOCK_15\n\n<!-- end -->\n\n`CALL KEYWORDS` supports distributed tables so no matter how big your data set you can benefit from using it.\n\n<!-- proofread -->",
    "translations": {
      "chinese": "我们的博客中有一篇[相关文章](https://manticoresearch.com/blog/simple-autocomplete-with-manticore/)，还有一个[互动课程](https://play.manticoresearch.com/simpleautocomplete/)。一个快速示例如下：\n\n* 假设你有一篇文档：`My cat loves my dog. The cat (Felis catus) is a domestic species of small carnivorous mammal.`\n\n* 然后你可以使用 `^`、`\"\"` 和 `*`，当用户输入时，你可以发起类似这样的查询：`^\"m*\"`、`^\"my *\"`、`^\"my c*\"`、`^\"my ca*\"` 等等\n\n* 它会找到该文档，如果你还使用了[高亮](../Searching/Highlighting.md)，你将得到类似这样的结果：`<b>My cat</b> loves my dog. The cat ( ...`\n\n##### 自动补全一个单词\n\n在某些情况下，你只需要自动补全一个单词或几个单词。这时，你可以使用 `CALL KEYWORDS`。\n\n### CALL KEYWORDS\n\n`CALL KEYWORDS` 通过 SQL 接口提供，可以用来检查关键词是如何被分词的，或者获取特定关键词的分词形式。如果表启用了[infixes](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len)，它允许你快速找到给定关键词的可能结尾，非常适合自动补全功能。\n\n这是通用中缀搜索的一个很好的替代方案，因为它性能更高，只需要表的字典，而不需要文档本身。\n\n### 通用语法\n\n<!-- example keywords -->\n\nCODE_BLOCK_13\n\n`CALL KEYWORDS` 语句将文本拆分为关键词。它返回关键词的分词和规范化形式，如果需要，还会返回关键词统计信息。此外，当表启用了[词形还原器](../Creating_a_table/NLP_and_tokenization/Morphology.md)时，还会提供查询中每个关键词的位置以及所有分词关键词的形式。\n\n| 参数 | 描述 |\n\n| - | - |\n\n| text | 要拆分成关键词的文本 |\n\n| table | 用于获取文本处理设置的表名 |\n\n| 0/1 as stats | 是否显示关键词统计，默认是 0 |\n\n| 0/1 as fold_wildcards | 是否折叠通配符，默认是 0 |\n\n| 0/1 as fold_lemmas | 是否折叠形态词形，默认是 0 |\n\n| 0/1 as fold_blended | 是否折叠混合词，默认是 0 |\n\n| N as expansion_limit | 覆盖服务器配置中定义的[expansion_limit](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expansion_limit)，默认是 0（使用配置中的值） |\n\n| docs/hits as sort_mode | 按 'docs' 或 'hits' 对输出结果排序。默认不排序。 |\n\n| jieba_mode | 查询的结巴分词模式。详情见[jieba_mode](../Creating_a_table/NLP_and_tokenization/Morphology.md#jieba_mode) |\n\n示例展示了如果假设用户想要获取“my cat ...”的自动补全结果时的工作方式。因此，在应用端你只需要为每个新词从“normalized”列建议用户可能的结尾。通常使用 `'hits' as sort_mode` 或 `'docs' as sort_mode` 按点击数或文档数排序是有意义的。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request Examples -->\n\nCODE_BLOCK_14\n\n<!-- end -->\n\n<!-- example bigram -->\n\n这里有一个很好的技巧可以改进上述算法——使用[bigram_index](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#bigram_index)。当你为表启用它时，索引中不仅包含单个词，还包含相邻的每对词作为单独的标记。\n\n这不仅可以预测当前词的结尾，还可以预测下一个词，这对于自动补全功能尤其有益。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request Examples -->\n\nCODE_BLOCK_15\n\n<!-- end -->\n\n`CALL KEYWORDS` 支持分布式表，因此无论你的数据集多大，都可以从中受益。\n\n<!-- proofread -->",
      "russian": "В нашем блоге есть [статья об этом](https://manticoresearch.com/blog/simple-autocomplete-with-manticore/) и [интерактивный курс](https://play.manticoresearch.com/simpleautocomplete/). Быстрый пример:\n\n* Предположим, у вас есть документ: `My cat loves my dog. The cat (Felis catus) is a domestic species of small carnivorous mammal.`\n\n* Затем вы можете использовать `^`, `\"\"` и `*`, чтобы по мере ввода пользователем формировать запросы, например: `^\"m*\"`, `^\"my *\"`, `^\"my c*\"`, `^\"my ca*\"` и так далее\n\n* Он найдет документ, и если вы также используете [подсветку](../Searching/Highlighting.md), вы получите что-то вроде: `<b>My cat</b> loves my dog. The cat ( ...`\n\n##### Автозаполнение слова\n\nВ некоторых случаях вам нужно автозаполнить одно слово или пару слов. В этом случае можно использовать `CALL KEYWORDS`.\n\n### CALL KEYWORDS\n\n`CALL KEYWORDS` доступна через SQL-интерфейс и предоставляет способ проверить, как ключевые слова токенизируются, или получить токенизированные формы конкретных ключевых слов. Если в таблице включены [инфиксы](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len), это позволяет быстро находить возможные окончания для заданных ключевых слов, что подходит для функции автозаполнения.\n\nЭто отличная альтернатива общему поиску с инфиксами, так как обеспечивает более высокую производительность, поскольку требует только словаря таблицы, а не самих документов.\n\n### Общий синтаксис\n\n<!-- example keywords -->\n\nCODE_BLOCK_13\n\nОператор `CALL KEYWORDS` разбивает текст на ключевые слова. Он возвращает токенизированные и нормализованные формы ключевых слов, а при необходимости — статистику по ключевым словам. Кроме того, он предоставляет позицию каждого ключевого слова в запросе и все формы токенизированных ключевых слов, если в таблице включены [лемматизаторы](../Creating_a_table/NLP_and_tokenization/Morphology.md).\n\n| Параметр | Описание |\n\n| - | - |\n\n| text | Текст для разбиения на ключевые слова |\n\n| table | Имя таблицы, из которой берутся настройки обработки текста |\n\n| 0/1 as stats | Показать статистику по ключевым словам, по умолчанию 0 |\n\n| 0/1 as fold_wildcards | Обрабатывать подстановочные знаки, по умолчанию 0 |\n\n| 0/1 as fold_lemmas | Обрабатывать морфологические леммы, по умолчанию 0 |\n\n| 0/1 as fold_blended | Обрабатывать составные слова, по умолчанию 0 |\n\n| N as expansion_limit | Переопределить [expansion_limit](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expansion_limit), заданный в конфигурации сервера, по умолчанию 0 (использовать значение из конфигурации) |\n\n| docs/hits as sort_mode | Сортировать результаты по 'docs' или 'hits'. По умолчанию сортировка не применяется. |\n\n| jieba_mode | Режим сегментации Jieba для запроса. Подробнее см. [jieba_mode](../Creating_a_table/NLP_and_tokenization/Morphology.md#jieba_mode) |\n\nПримеры показывают, как это работает, если предположить, что пользователь пытается получить автозаполнение для \"my cat ...\". На стороне приложения все, что нужно — предлагать пользователю окончания из столбца \"normalized\" для каждого нового слова. Часто имеет смысл сортировать по hits или docs, используя `'hits' as sort_mode` или `'docs' as sort_mode`.\n\n<!-- intro -->\n\n##### Примеры:\n\n<!-- request Examples -->\n\nCODE_BLOCK_14\n\n<!-- end -->\n\n<!-- example bigram -->\n\nЕсть хороший трюк, как улучшить описанный выше алгоритм — использовать [bigram_index](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#bigram_index). Если он включен для таблицы, то в нем индексируется не просто отдельное слово, а каждая пара слов, стоящих друг за другом, как отдельный токен.\n\nЭто позволяет предсказывать не только окончание текущего слова, но и следующее слово, что особенно полезно для автозаполнения.\n\n<!-- intro -->\n\n##### Примеры:\n\n<!-- request Examples -->\n\nCODE_BLOCK_15\n\n<!-- end -->\n\n`CALL KEYWORDS` поддерживает распределённые таблицы, так что независимо от размера вашего набора данных вы можете использовать эту функцию.\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "f9c161661d451409061f03d3a746943d6d1d819644469deca500b475db94af21": {
    "original": "# Autocomplete\n\nAutocomplete, or word completion, predicts and suggests the end of a word or phrase as you type. It's commonly used in:\n\n- Search boxes on websites\n\n- Suggestions in search engines\n\n- Text fields in apps\n\nManticore offers an advanced autocomplete feature that gives suggestions while you type, similar to those in well-known search engines. This helps speed up searches and lets users find what they need faster.\n\nIn addition to basic autocomplete functionality, Manticore includes advanced features to enhance the user experience:\n\n1. **Spell Correction (Fuzziness):** Manticore's autocomplete helps correct spelling mistakes by using algorithms that recognize and fix common errors. This means even if you type something wrong, you can still find what you were looking for.\n\n2. **Keyboard Layout Autodetection:** Manticore can figure out which keyboard layout you are using. This is really useful in places where many languages are used, or if you accidentally type in the wrong language. For example, if you type \"ghbdtn\" by mistake, Manticore knows you meant to say \"привет\" (hello in Russian) and suggests the correct word.\n\nManticore's autocomplete can be tailored to match different needs and settings, making it a flexible tool for many applications.\n\n![Autocomplete](autocomplete.png)\n\n## CALL AUTOCOMPLETE\n\n> NOTE: `CALL AUTOCOMPLETE` and `/autocomplete` require [Manticore Buddy](../Installation/Manticore_Buddy.md). If it doesn't work, make sure Buddy is installed.\n\n<!-- example call_autocomplete -->\n\nTo use autocomplete in Manticore, use the `CALL AUTOCOMPLETE` SQL statement or its JSON equivalent `/autocomplete`. This feature provides word completion suggestions based on your indexed data.\n\nBefore you proceed, ensure that the table you intend to use for autocomplete has [infixes](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) enabled.\n\n**Note:** There's an automatic check for `min_infix_len` in the table settings, which uses a 30-second cache to improve the performance of `CALL AUTOCOMPLETE`. After making changes to your table, there may be a brief delay the first time you use `CALL AUTOCOMPLETE` (though this is usually not noticeable). Only successful results are cached, so if you remove the table or disable `min_infix_len`, `CALL AUTOCOMPLETE` may temporarily return incorrect results until it eventually starts showing an error related to `min_infix_len`.\n\n### General syntax\n\n#### SQL\n\nCODE_BLOCK_0\n\n#### JSON\n\nCODE_BLOCK_1\n\n#### Options\n\n- `layouts`: A comma-separated string of keyboard layout codes for detecting typing errors caused by keyboard layout mismatches (e.g., typing \"ghbdtn\" instead of \"привет\" when using wrong layout). Manticore compares character positions across different layouts to suggest corrections. Requires at least 2 layouts to effectively detect mismatches. Available options: us, ru, ua, se, pt, no, it, gr, uk, fr, es, dk, de, ch, br, bg, be (more details [here](../Searching/Spell_correction.md#Options)). Default: none\n\n- `fuzziness`: `0`, `1`, or `2` (default: `2`). Maximum Levenshtein distance for finding typos. Set to `0` to disable fuzzy matching\n\n- `preserve`: `0` or `1` (default: `0`). When set to `1`, keeps words that don't have fuzzy matches in the search results (e.g., \"hello wrld\" returns both \"hello wrld\" and \"hello world\"). When set to `0`, only returns words with successful fuzzy matches (e.g., \"hello wrld\" returns only \"hello world\"). Particularly useful for preserving short words or proper nouns that may not exist in Manticore Search\n\n- `prepend`: Boolean (0/1 in SQL). If true(1), adds an asterisk before the last word for prefix expansion (e.g., `*word`)\n\n- `append`: Boolean (0/1 in SQL). If true(1), adds an asterisk after the last word for suffix expansion (e.g., `word*`)\n\n- `expansion_len`: Number of characters to expand in the last word. Default: `10`\n\n- `force_bigrams`: Boolean (0/1 in SQL). Forces the use of bigrams (2-character n-grams) instead of trigrams for all word lengths, which can improve matching for words with transposition errors. Default: `0` (use trigrams for words ≥6 characters)\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- request SQL with no fuzzy search -->\n\nCODE_BLOCK_3\n\n<!-- request JSON -->\n\nCODE_BLOCK_4\n\n<!-- response JSON -->\n\nCODE_BLOCK_5\n\n<!-- request SQL with preserve option -->\n\nCODE_BLOCK_6\n\n<!-- request JSON with preserve option -->\n\nCODE_BLOCK_7\n\n<!-- response JSON with preserve option -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!-- example force_bigrams option -->\n\n##### Using force_bigrams for better transposition handling\n\nThe `force_bigrams` option can help with words that have transposition errors, such as \"ipohne\" vs \"iphone\". By using bigrams instead of trigrams, the algorithm can better handle character transpositions.\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- response SQL -->\n\nCODE_BLOCK_10\n\n<!-- request JSON -->\n\nCODE_BLOCK_11\n\n<!-- response JSON -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n#### Links\n\n* [This demo](https://github.manticoresearch.com/manticoresoftware/manticoresearch) demonstrates the autocomplete functionality:\n\n  ![Autocomplete example](autocomplete_github_demo.png){.scale-0.7}\n\n* Blog post about Fuzzy Search and Autocomplete - https://manticoresearch.com/blog/new-fuzzy-search-and-autocomplete/\n\n## Alternative autocomplete methods\n\nWhile `CALL AUTOCOMPLETE` is the recommended method for most use cases, Manticore also supports other controllable and customizable approaches to implement autocomplete functionality:\n\n##### Autocomplete a sentence\n\nTo autocomplete a sentence, you can use [infixed search](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len). You can find the end of a document field by providing its beginning and:\n\n* using the [full-text wildcard operator](../Searching/Full_text_matching/Operators.md) `*` to match any characters\n\n* optionally using `^` to start from the beginning of the field\n\n* optionally using `\"\"` for phrase matching\n\n* and using [result highlighting](../Searching/Highlighting.md)",
    "translations": {
      "chinese": "# 自动完成\n\n自动完成，或称词语补全，是在你输入时预测并建议单词或短语的结尾。它常用于：\n\n- 网站上的搜索框\n\n- 搜索引擎中的建议\n\n- 应用程序中的文本字段\n\nManticore 提供了一个高级的自动完成功能，在你输入时给出建议，类似于知名搜索引擎中的功能。这有助于加快搜索速度，让用户更快找到所需内容。\n\n除了基本的自动完成功能外，Manticore 还包含增强用户体验的高级功能：\n\n1. **拼写纠正（模糊匹配）：** Manticore 的自动完成通过使用识别和修正常见错误的算法，帮助纠正拼写错误。这意味着即使你输入错误，也能找到你想要的内容。\n\n2. **键盘布局自动检测：** Manticore 能够识别你使用的键盘布局。这在多语言环境中非常有用，或者当你不小心使用了错误的语言输入时。例如，如果你错误地输入了“ghbdtn”，Manticore 会知道你想输入的是“привет”（俄语中的“你好”），并建议正确的单词。\n\nManticore 的自动完成可以根据不同需求和设置进行定制，是许多应用的灵活工具。\n\n![Autocomplete](autocomplete.png)\n\n## 调用自动完成\n\n> 注意：`CALL AUTOCOMPLETE` 和 `/autocomplete` 需要 [Manticore Buddy](../Installation/Manticore_Buddy.md)。如果无法使用，请确保已安装 Buddy。\n\n<!-- example call_autocomplete -->\n\n要在 Manticore 中使用自动完成，请使用 `CALL AUTOCOMPLETE` SQL 语句或其 JSON 等价的 `/autocomplete`。此功能基于你的索引数据提供词语补全建议。\n\n在继续之前，请确保你打算用于自动完成的表已启用 [infixes](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len)。\n\n**注意：** 表设置中有一个针对 `min_infix_len` 的自动检查，使用 30 秒缓存以提升 `CALL AUTOCOMPLETE` 的性能。修改表后，首次使用 `CALL AUTOCOMPLETE` 可能会有短暂延迟（通常不明显）。只有成功的结果会被缓存，因此如果你删除表或禁用 `min_infix_len`，`CALL AUTOCOMPLETE` 可能暂时返回错误结果，直到最终显示与 `min_infix_len` 相关的错误。\n\n### 通用语法\n\n#### SQL\n\nCODE_BLOCK_0\n\n#### JSON\n\nCODE_BLOCK_1\n\n#### 选项\n\n- `layouts`：逗号分隔的键盘布局代码字符串，用于检测因键盘布局不匹配导致的输入错误（例如使用错误布局时输入“ghbdtn”而非“привет”）。Manticore 会比较不同布局中字符的位置以建议纠正。至少需要 2 个布局才能有效检测不匹配。可用选项：us, ru, ua, se, pt, no, it, gr, uk, fr, es, dk, de, ch, br, bg, be（更多详情见[这里](../Searching/Spell_correction.md#Options)）。默认：无\n\n- `fuzziness`：`0`、`1` 或 `2`（默认：`2`）。查找拼写错误的最大 Levenshtein 距离。设置为 `0` 禁用模糊匹配\n\n- `preserve`：`0` 或 `1`（默认：`0`）。设置为 `1` 时，保留搜索结果中没有模糊匹配的词（例如，“hello wrld”返回“hello wrld”和“hello world”）。设置为 `0` 时，仅返回有成功模糊匹配的词（例如，“hello wrld”仅返回“hello world”）。对保留短词或可能不存在于 Manticore Search 中的专有名词特别有用\n\n- `prepend`：布尔值（SQL 中为 0/1）。若为 true(1)，在最后一个词前添加星号以进行前缀扩展（例如，`*word`）\n\n- `append`：布尔值（SQL 中为 0/1）。若为 true(1)，在最后一个词后添加星号以进行后缀扩展（例如，`word*`）\n\n- `expansion_len`：最后一个词扩展的字符数。默认：`10`\n\n- `force_bigrams`：布尔值（SQL 中为 0/1）。强制对所有词长使用二元组（2 字符 n-gram）而非三元组，这可以改善对字符调换错误的匹配。默认：`0`（对长度≥6的词使用三元组）\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- request SQL with no fuzzy search -->\n\nCODE_BLOCK_3\n\n<!-- request JSON -->\n\nCODE_BLOCK_4\n\n<!-- response JSON -->\n\nCODE_BLOCK_5\n\n<!-- request SQL with preserve option -->\n\nCODE_BLOCK_6\n\n<!-- request JSON with preserve option -->\n\nCODE_BLOCK_7\n\n<!-- response JSON with preserve option -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!-- example force_bigrams option -->\n\n##### 使用 force_bigrams 改善字符调换处理\n\n`force_bigrams` 选项可以帮助处理字符调换错误的词，例如“ipohne”与“iphone”。通过使用二元组而非三元组，算法能更好地处理字符调换。\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- response SQL -->\n\nCODE_BLOCK_10\n\n<!-- request JSON -->\n\nCODE_BLOCK_11\n\n<!-- response JSON -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n#### 链接\n\n* [此演示](https://github.manticoresearch.com/manticoresoftware/manticoresearch) 展示了自动完成功能：\n\n  ![Autocomplete example](autocomplete_github_demo.png){.scale-0.7}\n\n* 关于模糊搜索和自动完成的博客文章 - https://manticoresearch.com/blog/new-fuzzy-search-and-autocomplete/\n\n## 其他自动完成方法\n\n虽然 `CALL AUTOCOMPLETE` 是大多数用例推荐的方法，Manticore 还支持其他可控且可定制的方式来实现自动完成功能：\n\n##### 自动完成句子\n\n要自动完成句子，可以使用 [中缀搜索](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len)。你可以通过提供文档字段的开头并：\n\n* 使用 [全文通配符操作符](../Searching/Full_text_matching/Operators.md) `*` 匹配任意字符\n\n* 可选地使用 `^` 从字段开头开始\n\n* 可选地使用 `\"\"` 进行短语匹配\n\n* 并使用 [结果高亮](../Searching/Highlighting.md)",
      "russian": "# Автозаполнение\n\nАвтозаполнение, или дополнение слова, предсказывает и предлагает окончание слова или фразы по мере ввода. Обычно используется в:\n\n- Поисковых строках на сайтах\n\n- Подсказках в поисковых системах\n\n- Текстовых полях в приложениях\n\nManticore предлагает продвинутую функцию автозаполнения, которая дает подсказки во время ввода, аналогично известным поисковым системам. Это помогает ускорить поиск и позволяет пользователям быстрее находить нужное.\n\nПомимо базовой функциональности автозаполнения, Manticore включает расширенные возможности для улучшения пользовательского опыта:\n\n1. **Коррекция орфографии (Fuzziness):** Автозаполнение Manticore помогает исправлять орфографические ошибки с помощью алгоритмов, которые распознают и исправляют распространённые ошибки. Это значит, что даже если вы ошиблись при вводе, вы всё равно сможете найти то, что искали.\n\n2. **Автоматическое определение раскладки клавиатуры:** Manticore может определить, какую раскладку клавиатуры вы используете. Это особенно полезно в местах с множеством языков или если вы случайно печатаете не на том языке. Например, если вы ошибочно ввели \"ghbdtn\", Manticore поймёт, что вы хотели написать \"привет\" и предложит правильное слово.\n\nАвтозаполнение Manticore можно настроить под разные нужды и параметры, что делает его гибким инструментом для многих приложений.\n\n![Autocomplete](autocomplete.png)\n\n## ВЫЗОВ AUTOCOMPLETE\n\n> ПРИМЕЧАНИЕ: `CALL AUTOCOMPLETE` и `/autocomplete` требуют [Manticore Buddy](../Installation/Manticore_Buddy.md). Если не работает, убедитесь, что Buddy установлен.\n\n<!-- example call_autocomplete -->\n\nДля использования автозаполнения в Manticore используйте SQL-запрос `CALL AUTOCOMPLETE` или его JSON-эквивалент `/autocomplete`. Эта функция предоставляет предложения по дополнению слов на основе ваших индексированных данных.\n\nПеред использованием убедитесь, что в таблице, которую вы собираетесь использовать для автозаполнения, включены [инфиксы](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len).\n\n**Примечание:** В настройках таблицы есть автоматическая проверка `min_infix_len`, которая использует кэш на 30 секунд для улучшения производительности `CALL AUTOCOMPLETE`. После внесения изменений в таблицу может быть небольшая задержка при первом использовании `CALL AUTOCOMPLETE` (обычно незаметная). Кэшируются только успешные результаты, поэтому если вы удалите таблицу или отключите `min_infix_len`, `CALL AUTOCOMPLETE` может временно возвращать некорректные результаты, пока не начнёт показывать ошибку, связанную с `min_infix_len`.\n\n### Общий синтаксис\n\n#### SQL\n\nCODE_BLOCK_0\n\n#### JSON\n\nCODE_BLOCK_1\n\n#### Опции\n\n- `layouts`: Строка с разделёнными запятыми кодами раскладок клавиатуры для обнаружения ошибок ввода из-за несоответствия раскладок (например, ввод \"ghbdtn\" вместо \"привет\" при неправильной раскладке). Manticore сравнивает позиции символов в разных раскладках для предложения исправлений. Требуется минимум 2 раскладки для эффективного обнаружения несоответствий. Доступные варианты: us, ru, ua, se, pt, no, it, gr, uk, fr, es, dk, de, ch, br, bg, be (подробнее [здесь](../Searching/Spell_correction.md#Options)). По умолчанию: none\n\n- `fuzziness`: `0`, `1` или `2` (по умолчанию: `2`). Максимальное расстояние Левенштейна для поиска опечаток. Установите в `0` для отключения нечеткого поиска\n\n- `preserve`: `0` или `1` (по умолчанию: `0`). При значении `1` сохраняет слова без нечетких совпадений в результатах поиска (например, \"hello wrld\" возвращает и \"hello wrld\", и \"hello world\"). При значении `0` возвращает только слова с успешными нечеткими совпадениями (например, \"hello wrld\" возвращает только \"hello world\"). Особенно полезно для сохранения коротких слов или собственных имён, которые могут отсутствовать в Manticore Search\n\n- `prepend`: Булево (0/1 в SQL). Если true(1), добавляет звёздочку перед последним словом для расширения префикса (например, `*word`)\n\n- `append`: Булево (0/1 в SQL). Если true(1), добавляет звёздочку после последнего слова для расширения суффикса (например, `word*`)\n\n- `expansion_len`: Количество символов для расширения в последнем слове. По умолчанию: `10`\n\n- `force_bigrams`: Булево (0/1 в SQL). Принудительно использует биграммы (2-символьные n-граммы) вместо триграмм для всех длин слов, что может улучшить совпадения для слов с ошибками перестановки символов. По умолчанию: `0` (использовать триграммы для слов длиной ≥6 символов)\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- request SQL with no fuzzy search -->\n\nCODE_BLOCK_3\n\n<!-- request JSON -->\n\nCODE_BLOCK_4\n\n<!-- response JSON -->\n\nCODE_BLOCK_5\n\n<!-- request SQL with preserve option -->\n\nCODE_BLOCK_6\n\n<!-- request JSON with preserve option -->\n\nCODE_BLOCK_7\n\n<!-- response JSON with preserve option -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!-- example force_bigrams option -->\n\n##### Использование force_bigrams для лучшей обработки перестановок\n\nОпция `force_bigrams` помогает с словами, в которых есть ошибки перестановки символов, например \"ipohne\" вместо \"iphone\". Используя биграммы вместо триграмм, алгоритм лучше справляется с перестановками символов.\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- response SQL -->\n\nCODE_BLOCK_10\n\n<!-- request JSON -->\n\nCODE_BLOCK_11\n\n<!-- response JSON -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n#### Ссылки\n\n* [Демонстрация](https://github.manticoresearch.com/manticoresoftware/manticoresearch) показывает работу автозаполнения:\n\n  ![Autocomplete example](autocomplete_github_demo.png){.scale-0.7}\n\n* Блог о нечетком поиске и автозаполнении - https://manticoresearch.com/blog/new-fuzzy-search-and-autocomplete/\n\n## Альтернативные методы автозаполнения\n\nХотя `CALL AUTOCOMPLETE` является рекомендуемым методом для большинства случаев, Manticore также поддерживает другие управляемые и настраиваемые подходы для реализации функции автозаполнения:\n\n##### Автозаполнение предложения\n\nДля автозаполнения предложения можно использовать [инфиксный поиск](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len). Вы можете найти конец поля документа, указав его начало и:\n\n* используя [оператор подстановки полного текста](../Searching/Full_text_matching/Operators.md) `*` для совпадения с любыми символами\n\n* опционально используя `^` для начала с начала поля\n\n* опционально используя `\"\"` для поиска фразы\n\n* и используя [подсветку результатов](../Searching/Highlighting.md)"
    },
    "is_code_or_comment": false
  }
}
