{
  "24f6ef9ff566877206e1a4770327a5d0d87a9b8a9fb74f5511dacbce39568338": {
    "original": "# Cost-based optimizer\n\nWhen Manticore executes a fullscan query, it can either use a plain scan to check every document against the filters or employ additional data and/or algorithms to speed up query execution. Manticore uses a cost-based optimizer (CBO), also known as a \"query optimizer\" to determine which approach to take.\n\nThe CBO can also enhance the performance of full-text queries. See below for more details.\n\nThe CBO may decide to replace one or more query filters with one of the following entities if it determines that doing so will improve performance:\n\n1. A **docid index** utilizes a special docid-only secondary index stored in files with the `.spt` extension. Besides improving filters on document IDs, the docid index is also used to accelerate document ID to row ID lookups and to speed up the application of large killlists during daemon startup.\n\n2. A **columnar scan** relies on columnar storage and can only be used on a columnar attribute. It scans every value and tests it against the filter, but it is heavily optimized and is typically faster than the default approach.\n\n3. **Secondary indexes** are generated for all attributes (except JSON) by default. They use the [PGM index](https://pgm.di.unipi.it/) along with Manticore's built-in inverted index to retrieve the list of row IDs corresponding to a value or range of values. Secondary indexes are stored in files with the `.spidx` and `.spjidx` extensions.\n\nFor information on how to generate secondary indexes over JSON attributes, see [json_secondary_indexes](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#json_secondary_indexes).\n\nThe optimizer estimates the cost of each execution path using various attribute statistics, including:\n\n1. Information on the data distribution within an attribute (histograms, stored in `.sphi` files). Histograms are generated automatically when data is indexed and serve as the primary source of information for the CBO.\n\n2. Information from PGM (secondary indexes), which helps estimate the number of document lists to read. This assists in gauging doclist merge performance and in selecting the appropriate merge algorithm (priority queue merge or bitmap merge).\n\n3. Columnar encoding statistics, employed to estimate columnar data decompression performance.\n\n4. A columnar min-max tree. While the CBO uses histograms to estimate the number of documents left after applying the filter, it also needs to determine how many documents the filter had to process. For columnar attributes, partial evaluation of the min-max tree serves this purpose.\n\n5. Full-text dictionary. The CBO utilizes term stats to estimate the cost of evaluating the full-text tree.\n\nThe optimizer computes the execution cost for every filter used in a query. Since certain filters can be replaced with several different entities (e.g., for a document id, Manticore can use a plain scan, a docid index lookup, a columnar scan (if the document id is columnar), and a secondary index), the optimizer evaluates all available combinations. However, there is a maximum limit of 1024 combinations.\n\nTo estimate query execution costs, the optimizer calculates the estimated costs of the most significant operations performed when executing the query. It uses preset constants to represent the cost of each operation.\n\nThe optimizer compares the costs of each execution path and chooses the path with the lowest cost to execute the query.\n\nWhen working with full-text queries that have filters by attributes, the query optimizer decides between two possible execution paths. One is to execute the full-text query, retrieve the matches, and use filters. The other is to replace filters with one or more entities described above, fetch rowids from them, and inject them into the full-text matching tree. This way, full-text search results will intersect with full-scan results. The query optimizer estimates the cost of full-text tree evaluation and the best possible path for computing filter results. Using this information, the optimizer chooses the execution path.\n\nAnother factor to consider is multithreaded query execution (when `pseudo_sharding` is enabled). The CBO is aware that some queries can be executed in multiple threads and takes this into account. The CBO prioritizes shorter query execution times (i.e., latency) over throughput. For instance, if a query using a columnar scan can be executed in multiple threads (and occupy multiple CPU cores) and is faster than a query executed in a single thread using secondary indexes, multithreaded execution will be preferred.\n\nQueries using secondary indexes and docid indexes always run in a single thread, as benchmarks indicate that there is little to no benefit in making them multithreaded.\n\nAt present, the optimizer only uses CPU costs and does not take memory or disk usage into account.\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 基于成本的优化器\n\n当 Manticore 执行全扫描查询时，它可以使用普通扫描来检查每个文档是否符合过滤条件，或者采用额外的数据和/或算法来加速查询执行。Manticore 使用基于成本的优化器（CBO），也称为“查询优化器”，来决定采用哪种方法。\n\nCBO 还可以提升全文查询的性能。详情见下文。\n\n如果 CBO 认为替换一个或多个查询过滤器能提升性能，它可能会用以下实体之一替换：\n\n1. **docid 索引** 利用存储在 `.spt` 扩展名文件中的特殊仅包含 docid 的二级索引。除了提升文档 ID 上的过滤器性能外，docid 索引还用于加速文档 ID 到行 ID 的查找，以及加快守护进程启动时大规模 killlist 的应用。\n\n2. **列式扫描** 依赖于列式存储，仅能用于列式属性。它扫描每个值并对其进行过滤测试，但经过高度优化，通常比默认方法更快。\n\n3. **二级索引** 默认为所有属性（除 JSON 外）生成。它们使用 [PGM 索引](https://pgm.di.unipi.it/) 以及 Manticore 内置的倒排索引来检索对应于某个值或值范围的行 ID 列表。二级索引存储在扩展名为 `.spidx` 和 `.spjidx` 的文件中。\n\n有关如何为 JSON 属性生成二级索引的信息，请参见 [json_secondary_indexes](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#json_secondary_indexes)。\n\n优化器使用各种属性统计信息来估算每条执行路径的成本，包括：\n\n1. 属性内数据分布信息（直方图，存储在 `.sphi` 文件中）。直方图在数据索引时自动生成，是 CBO 的主要信息来源。\n\n2. 来自 PGM（二级索引）的信息，有助于估算需要读取的文档列表数量。这有助于评估文档列表合并性能并选择合适的合并算法（优先队列合并或位图合并）。\n\n3. 列式编码统计，用于估算列式数据解压性能。\n\n4. 列式最小-最大树。虽然 CBO 使用直方图估算应用过滤器后剩余的文档数量，但它还需要确定过滤器处理了多少文档。对于列式属性，部分评估最小-最大树可实现此目的。\n\n5. 全文字典。CBO 利用词项统计信息来估算全文树的评估成本。\n\n优化器计算查询中每个过滤器的执行成本。由于某些过滤器可以被多种不同实体替代（例如，对于文档 ID，Manticore 可以使用普通扫描、docid 索引查找、列式扫描（如果文档 ID 是列式的）和二级索引），优化器会评估所有可用组合。但组合数最大限制为 1024。\n\n为了估算查询执行成本，优化器计算执行查询时最重要操作的估计成本。它使用预设常数来表示每个操作的成本。\n\n优化器比较每条执行路径的成本，选择成本最低的路径来执行查询。\n\n在处理带有属性过滤器的全文查询时，查询优化器在两种可能的执行路径之间做出决定。一种是执行全文查询，检索匹配项，然后使用过滤器。另一种是用上述一个或多个实体替换过滤器，从中获取行 ID 并注入全文匹配树。这样，全文搜索结果将与全扫描结果相交。查询优化器估算全文树评估的成本和计算过滤器结果的最佳路径。基于此信息，优化器选择执行路径。\n\n另一个需要考虑的因素是多线程查询执行（当启用 `pseudo_sharding` 时）。CBO 知道某些查询可以多线程执行，并将此纳入考虑。CBO 优先考虑较短的查询执行时间（即延迟）而非吞吐量。例如，如果使用列式扫描的查询可以多线程执行（占用多个 CPU 核心），且比单线程使用二级索引执行的查询更快，则优先选择多线程执行。\n\n使用二级索引和 docid 索引的查询始终在单线程中运行，因为基准测试表明使它们多线程几乎没有收益。\n\n目前，优化器仅使用 CPU 成本，不考虑内存或磁盘使用。 \n\n<!-- proofread -->",
      "russian": "# Оптимизатор на основе стоимости\n\nКогда Manticore выполняет запрос полного сканирования, он может либо использовать простой скан для проверки каждого документа по фильтрам, либо применять дополнительные данные и/или алгоритмы для ускорения выполнения запроса. Manticore использует оптимизатор на основе стоимости (CBO), также известный как «оптимизатор запросов», чтобы определить, какой подход выбрать.\n\nCBO также может улучшить производительность полнотекстовых запросов. Подробнее см. ниже.\n\nCBO может решить заменить один или несколько фильтров запроса одним из следующих элементов, если он определит, что это улучшит производительность:\n\n1. **docid индекс** использует специальный вторичный индекс только по docid, хранящийся в файлах с расширением `.spt`. Помимо улучшения фильтров по идентификаторам документов, docid индекс также используется для ускорения поиска соответствия docid к rowid и для ускорения применения больших списков исключений (killlists) при запуске демона.\n\n2. **Колоннарное сканирование** опирается на колоннарное хранение и может использоваться только для колоннарного атрибута. Оно сканирует каждое значение и проверяет его по фильтру, но при этом сильно оптимизировано и обычно быстрее стандартного подхода.\n\n3. **Вторичные индексы** создаются по умолчанию для всех атрибутов (кроме JSON). Они используют [PGM индекс](https://pgm.di.unipi.it/) вместе с встроенным инвертированным индексом Manticore для получения списка rowid, соответствующих значению или диапазону значений. Вторичные индексы хранятся в файлах с расширениями `.spidx` и `.spjidx`.\n\nДля информации о том, как создавать вторичные индексы по JSON-атрибутам, см. [json_secondary_indexes](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#json_secondary_indexes).\n\nОптимизатор оценивает стоимость каждого пути выполнения, используя различные статистики атрибутов, включая:\n\n1. Информацию о распределении данных внутри атрибута (гистограммы, хранящиеся в файлах `.sphi`). Гистограммы генерируются автоматически при индексировании данных и служат основным источником информации для CBO.\n\n2. Информацию из PGM (вторичные индексы), которая помогает оценить количество списков документов для чтения. Это помогает оценить производительность слияния doclist и выбрать подходящий алгоритм слияния (слияние с приоритетной очередью или слияние битмапов).\n\n3. Статистику колоннарного кодирования, используемую для оценки производительности декомпрессии колоннарных данных.\n\n4. Колоннарное дерево min-max. В то время как CBO использует гистограммы для оценки количества документов, оставшихся после применения фильтра, ему также нужно определить, сколько документов фильтр должен был обработать. Для колоннарных атрибутов частичная оценка дерева min-max служит этой цели.\n\n5. Полнотекстовый словарь. CBO использует статистику терминов для оценки стоимости вычисления полнотекстового дерева.\n\nОптимизатор вычисляет стоимость выполнения для каждого фильтра, используемого в запросе. Поскольку некоторые фильтры могут быть заменены несколькими разными элементами (например, для идентификатора документа Manticore может использовать простой скан, поиск по docid индексу, колоннарное сканирование (если docid колоннарный) и вторичный индекс), оптимизатор оценивает все доступные комбинации. Однако существует максимальный предел в 1024 комбинации.\n\nДля оценки стоимости выполнения запроса оптимизатор рассчитывает предполагаемые затраты на наиболее значимые операции, выполняемые при выполнении запроса. Он использует предустановленные константы для представления стоимости каждой операции.\n\nОптимизатор сравнивает стоимости каждого пути выполнения и выбирает путь с наименьшей стоимостью для выполнения запроса.\n\nПри работе с полнотекстовыми запросами, которые имеют фильтры по атрибутам, оптимизатор запроса выбирает между двумя возможными путями выполнения. Один — выполнить полнотекстовый запрос, получить совпадения и применить фильтры. Другой — заменить фильтры одним или несколькими описанными выше элементами, получить rowid из них и внедрить их в полнотекстовое дерево поиска. Таким образом, результаты полнотекстового поиска пересекутся с результатами полного сканирования. Оптимизатор запроса оценивает стоимость вычисления полнотекстового дерева и лучший возможный путь для вычисления результатов фильтра. Используя эту информацию, оптимизатор выбирает путь выполнения.\n\nЕще одним фактором является многопоточное выполнение запроса (когда включен `pseudo_sharding`). CBO учитывает, что некоторые запросы могут выполняться в нескольких потоках, и принимает это во внимание. CBO отдает приоритет более короткому времени выполнения запроса (то есть задержке), а не пропускной способности. Например, если запрос с использованием колоннарного сканирования может выполняться в нескольких потоках (и занимать несколько ядер CPU) и при этом быстрее, чем запрос, выполняемый в одном потоке с использованием вторичных индексов, будет предпочтено многопоточное выполнение.\n\nЗапросы с использованием вторичных индексов и docid индексов всегда выполняются в одном потоке, так как бенчмарки показывают, что многопоточное выполнение для них малоэффективно.\n\nВ настоящее время оптимизатор учитывает только затраты CPU и не принимает во внимание использование памяти или диска.\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
