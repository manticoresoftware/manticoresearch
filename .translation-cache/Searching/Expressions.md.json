{
  "89dabbc2ad1dcaf95b2ce4e14c14894933b0066b76afd45cd5babae7599b7643": {
    "original": "* [REGEX()](../Functions/String_functions.md#REGEX%28%29)\n\n* [REMAP()](../Functions/Arrays_and_conditions_functions.md#REMAP%28%29)\n\n* [SECOND()](../Functions/Date_and_time_functions.md#SECOND%28%29)\n\n* [SIN()](../Functions/Mathematical_functions.md#SIN%28%29)\n\n* [SINT()](../Functions/Type_casting_functions.md#SINT%28%29)\n\n* [SQRT()](../Functions/Mathematical_functions.md#SQRT%28%29)\n\n* [SUBSTRING_INDEX()](../Functions/String_functions.md#SUBSTRING_INDEX%28%29)\n\n* [TO_STRING()](../Functions/Type_casting_functions.md#TO_STRING%28%29)\n\n* [UINT()](../Functions/Type_casting_functions.md#UINT%28%29)\n\n* [YEAR()](../Functions/Date_and_time_functions.md#YEAR%28%29)\n\n* [YEARMONTH()](../Functions/Date_and_time_functions.md#YEARMONTH%28%29)\n\n* [YEARMONTHDAY()](../Functions/Date_and_time_functions.md#YEARMONTHDAY%28%29)\n\n* [WEIGHT()](../Functions/Searching_and_ranking_functions.md#WEIGHT%28%29)\n\n## Expressions in HTTP JSON\n\nIn the HTTP JSON interface, expressions are supported via `script_fields` and `expressions`.\n\n### script_fields\n\n<!-- example script_fields -->\n\nCODE_BLOCK_4\n\nIn this example, two expressions are created: `add_all` and `title_len`. The first expression calculates `( gid * 10 ) | crc32(title)` and stores the result in the `add_all` attribute. The second expression calculates `crc32(title)` and stores the result in the `title_len` attribute.\n\nCurrently, only `inline` expressions are supported. The value of the `inline` property (the expression to compute) has the same syntax as SQL expressions.\n\nThe expression name can be utilized in filtering or sorting.\n\n<!-- intro -->\n\n##### script_fields:\n\n<!-- request script_fields -->\n\nCODE_BLOCK_5\n\n<!-- end -->\n\nBy default, expression values are included in the `_source` array of the result set. If the source is selective (see [Source selection](../Searching/Search_results.md#Source-selection)), the expression name can be added to the `_source` parameter in the request. Note, the names of the expressions must be in lowercase.\n\n### expressions\n\n<!-- example expressions -->\n\n`expressions` is an alternative to `script_fields` with a simpler syntax. The example request adds two expressions and stores the results into `add_all` and `title_len` attributes. Note, the names of the expressions must be in lowercase.\n\n<!-- request expressions -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "* [REGEX()](../Functions/String_functions.md#REGEX%28%29)\n\n* [REMAP()](../Functions/Arrays_and_conditions_functions.md#REMAP%28%29)\n\n* [SECOND()](../Functions/Date_and_time_functions.md#SECOND%28%29)\n\n* [SIN()](../Functions/Mathematical_functions.md#SIN%28%29)\n\n* [SINT()](../Functions/Type_casting_functions.md#SINT%28%29)\n\n* [SQRT()](../Functions/Mathematical_functions.md#SQRT%28%29)\n\n* [SUBSTRING_INDEX()](../Functions/String_functions.md#SUBSTRING_INDEX%28%29)\n\n* [TO_STRING()](../Functions/Type_casting_functions.md#TO_STRING%28%29)\n\n* [UINT()](../Functions/Type_casting_functions.md#UINT%28%29)\n\n* [YEAR()](../Functions/Date_and_time_functions.md#YEAR%28%29)\n\n* [YEARMONTH()](../Functions/Date_and_time_functions.md#YEARMONTH%28%29)\n\n* [YEARMONTHDAY()](../Functions/Date_and_time_functions.md#YEARMONTHDAY%28%29)\n\n* [WEIGHT()](../Functions/Searching_and_ranking_functions.md#WEIGHT%28%29)\n\n## HTTP JSON 中的表达式\n\n在 HTTP JSON 接口中，通过 `script_fields` 和 `expressions` 支持表达式。\n\n### script_fields\n\n<!-- example script_fields -->\n\nCODE_BLOCK_4\n\n在此示例中，创建了两个表达式：`add_all` 和 `title_len`。第一个表达式计算 `( gid * 10 ) | crc32(title)` 并将结果存储在 `add_all` 属性中。第二个表达式计算 `crc32(title)` 并将结果存储在 `title_len` 属性中。\n\n目前仅支持 `inline` 表达式。`inline` 属性的值（要计算的表达式）具有与 SQL 表达式相同的语法。\n\n表达式名称可以用于过滤或排序。\n\n<!-- intro -->\n\n##### script_fields:\n\n<!-- request script_fields -->\n\nCODE_BLOCK_5\n\n<!-- end -->\n\n默认情况下，表达式值包含在结果集的 `_source` 数组中。如果源是选择性的（参见[源选择](../Searching/Search_results.md#Source-selection)），可以将表达式名称添加到请求中的 `_source` 参数中。注意，表达式名称必须是小写。\n\n### expressions\n\n<!-- example expressions -->\n\n`expressions` 是 `script_fields` 的一种替代方案，语法更简单。示例请求添加了两个表达式，并将结果存储到 `add_all` 和 `title_len` 属性中。注意，表达式名称必须是小写。\n\n<!-- request expressions -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "* [REGEX()](../Functions/String_functions.md#REGEX%28%29)\n\n* [REMAP()](../Functions/Arrays_and_conditions_functions.md#REMAP%28%29)\n\n* [SECOND()](../Functions/Date_and_time_functions.md#SECOND%28%29)\n\n* [SIN()](../Functions/Mathematical_functions.md#SIN%28%29)\n\n* [SINT()](../Functions/Type_casting_functions.md#SINT%28%29)\n\n* [SQRT()](../Functions/Mathematical_functions.md#SQRT%28%29)\n\n* [SUBSTRING_INDEX()](../Functions/String_functions.md#SUBSTRING_INDEX%28%29)\n\n* [TO_STRING()](../Functions/Type_casting_functions.md#TO_STRING%28%29)\n\n* [UINT()](../Functions/Type_casting_functions.md#UINT%28%29)\n\n* [YEAR()](../Functions/Date_and_time_functions.md#YEAR%28%29)\n\n* [YEARMONTH()](../Functions/Date_and_time_functions.md#YEARMONTH%28%29)\n\n* [YEARMONTHDAY()](../Functions/Date_and_time_functions.md#YEARMONTHDAY%28%29)\n\n* [WEIGHT()](../Functions/Searching_and_ranking_functions.md#WEIGHT%28%29)\n\n## Выражения в HTTP JSON\n\nВ интерфейсе HTTP JSON поддерживаются выражения через `script_fields` и `expressions`.\n\n### script_fields\n\n<!-- example script_fields -->\n\nCODE_BLOCK_4\n\nВ этом примере создаются два выражения: `add_all` и `title_len`. Первое выражение вычисляет `( gid * 10 ) | crc32(title)` и сохраняет результат в атрибут `add_all`. Второе выражение вычисляет `crc32(title)` и сохраняет результат в атрибут `title_len`.\n\nВ настоящее время поддерживаются только `inline` выражения. Значение свойства `inline` (выражение для вычисления) имеет такой же синтаксис, как и SQL-выражения.\n\nИмя выражения может использоваться при фильтрации или сортировке.\n\n<!-- intro -->\n\n##### script_fields:\n\n<!-- request script_fields -->\n\nCODE_BLOCK_5\n\n<!-- end -->\n\nПо умолчанию значения выражений включаются в массив `_source` набора результатов. Если источник выборочный (см. [Выбор источника](../Searching/Search_results.md#Source-selection)), имя выражения можно добавить в параметр `_source` в запросе. Обратите внимание, что имена выражений должны быть в нижнем регистре.\n\n### expressions\n\n<!-- example expressions -->\n\n`expressions` является альтернативой `script_fields` с более простым синтаксисом. В примере запроса добавляются два выражения, и результаты сохраняются в атрибуты `add_all` и `title_len`. Обратите внимание, что имена выражений должны быть в нижнем регистре.\n\n<!-- request expressions -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "f0be45671194f874d5c03cdd34eb8309c1cb755ed5d11b0f33109d54b70ef7fb": {
    "original": "# Expressions in search\n\nManticore enables the use of arbitrary arithmetic expressions through both SQL and HTTP, incorporating attribute values, internal attributes (document ID and relevance weight), arithmetic operations, several built-in functions, and user-defined functions. Below is the complete reference list for quick access.\n\n## Arithmetic operators\n\nCODE_BLOCK_0\n\nStandard arithmetic operators are available. Arithmetic calculations involving these operators can be executed in three different modes:\n\n1. using single-precision, 32-bit IEEE 754 floating point values (default),\n\n2. using signed 32-bit integers,\n\n3. using 64-bit signed integers.\n\nThe expression parser automatically switches to integer mode if no operations result in a floating point value. Otherwise, it uses the default floating point mode. For example, a+b will be computed using 32-bit integers if both arguments are 32-bit integers; or using 64-bit integers if both arguments are integers but one of them is 64-bit; or in floats otherwise. However, `a/b` or `sqrt(a)` will always be computed in floats, as these operations return a non-integer result. To avoid this, you can use `IDIV(a,b)` or a `DIV b` form. Additionally, `a*b` will not automatically promote to 64-bit when arguments are 32-bit. To enforce 64-bit results, use [BIGINT()](../Functions/Type_casting_functions.md#BIGINT%28%29), but note that if non-integer operations are present, BIGINT() will simply be ignored.\n\n## Comparison operators\n\nCODE_BLOCK_1\n\nThe comparison operators return 1.0 when the condition is true and 0.0 otherwise. For example, `(a=b)+3` evaluates to 4 when attribute `a` is equal to attribute `b`, and to 3 when `a` is not. Unlike MySQL, the equality comparisons (i.e., `=` and `<>` operators) include a small equality threshold (1e-6 by default). If the difference between the compared values is within the threshold, they are considered equal.\n\nThe `BETWEEN` and `IN` operators, in the case of multi-value attributes, return true if at least one value matches the condition (similar to [ANY()](../Functions/Arrays_and_conditions_functions.md#ANY%28%29)). The `IN` operator does not support JSON attributes. The `IS (NOT) NULL` operator is supported only for JSON attributes.\n\n## Boolean operators\n\nCODE_BLOCK_2\n\nBoolean operators (AND, OR, NOT) behave as expected. They are left-associative and have the lowest priority compared to other operators. NOT has higher priority than AND and OR but still less than any other operator. AND and OR share the same priority, so using parentheses is recommended to avoid confusion in complex expressions.\n\n## Bitwise operators\n\nCODE_BLOCK_3\n\nThese operators perform bitwise AND and OR respectively. The operands must be of integer types.\n\n## Functions:\n\n* [ABS()](../Functions/Mathematical_functions.md#ABS%28%29)\n\n* [ALL()](../Functions/Arrays_and_conditions_functions.md#ALL%28%29)\n\n* [ANY()](../Functions/Arrays_and_conditions_functions.md#ANY%28%29)\n\n* [ATAN2()](../Functions/Mathematical_functions.md#ATAN2%28%29)\n\n* [BIGINT()](../Functions/Type_casting_functions.md#BIGINT%28%29)\n\n* [BITDOT()](../Functions/Mathematical_functions.md#BITDOT%28%29)\n\n* [BM25F()](../Functions/Searching_and_ranking_functions.md#BM25F%28%29)\n\n* [CEIL()](../Functions/Mathematical_functions.md#CEIL%28%29)\n\n* [CONCAT()](../Functions/String_functions.md#CONCAT%28%29)\n\n* [CONTAINS()](../Functions/Arrays_and_conditions_functions.md#CONTAINS%28%29)\n\n* [COS()](../Functions/Mathematical_functions.md#COS%28%29)\n\n* [CRC32()](../Functions/Mathematical_functions.md#CRC32%28%29)\n\n* [DATE_HISTOGRAM()](../Functions/Date_and_time_functions.md#DATE_HISTOGRAM%28%29)\n\n* [DATE_RANGE()](../Functions/Date_and_time_functions.md#DATE_RANGE%28%29)\n\n* [DAY()](../Functions/Date_and_time_functions.md#DAY%28%29)\n\n* [DOUBLE()](../Functions/Type_casting_functions.md#DOUBLE%28%29)\n\n* [EXP()](../Functions/Mathematical_functions.md#EXP%28%29)\n\n* [FIBONACCI()](../Functions/Mathematical_functions.md#FIBONACCI%28%29)\n\n* [FLOOR()](../Functions/Mathematical_functions.md#FLOOR%28%29)\n\n* [GEODIST()](../Functions/Geo_spatial_functions.md#GEODIST%28%29)\n\n* [GEOPOLY2D()](../Functions/Geo_spatial_functions.md#GEOPOLY2D%28%29)\n\n* [GREATEST()](../Functions/Mathematical_functions.md#GREATEST%28%29)\n\n* [HOUR()](../Functions/Date_and_time_functions.md#HOUR%28%29)\n\n* [HISTOGRAM()](../Functions/Arrays_and_conditions_functions.md#HISTOGRAM%28%29)\n\n* [IDIV()](../Functions/Mathematical_functions.md#IDIV%28%29)\n\n* [IF()](../Functions/Arrays_and_conditions_functions.md#IF%28%29)\n\n* [IN()](../Functions/Arrays_and_conditions_functions.md#IN%28%29)\n\n* [INDEXOF()](../Functions/Arrays_and_conditions_functions.md#INDEXOF%28%29)\n\n* [INTEGER()](../Functions/Type_casting_functions.md#INTEGER%28%29)\n\n* [INTERVAL()](../Functions/Arrays_and_conditions_functions.md#INTERVAL%28%29)\n\n* [LAST_INSERT_ID()](../Functions/Other_functions.md#LAST_INSERT_ID%28%29)\n\n* [LEAST()](../Functions/Mathematical_functions.md#LEAST%28%29)\n\n* [LENGTH()](../Functions/Arrays_and_conditions_functions.md#LENGTH%28%29)\n\n* [LN()](../Functions/Mathematical_functions.md#LN%28%29)\n\n* [LOG10()](../Functions/Mathematical_functions.md#LOG10%28%29)\n\n* [LOG2()](../Functions/Mathematical_functions.md#LOG2%28%29)\n\n* [MAX()](../Functions/Mathematical_functions.md#MAX%28%29)\n\n* [MIN()](../Functions/Mathematical_functions.md#MIN%28%29)\n\n* [MINUTE()](../Functions/Date_and_time_functions.md#MINUTE%28%29)\n\n* [MIN_TOP_SORTVAL()](../Functions/Searching_and_ranking_functions.md#MIN_TOP_SORTVAL%28%29)\n\n* [MIN_TOP_WEIGHT()](../Functions/Searching_and_ranking_functions.md#MIN_TOP_WEIGHT%28%29)\n\n* [MONTH()](../Functions/Date_and_time_functions.md#MONTH%28%29)\n\n* [NOW()](../Functions/Date_and_time_functions.md#NOW%28%29)\n\n* [PACKEDFACTORS()](../Functions/Searching_and_ranking_functions.md#PACKEDFACTORS%28%29)\n\n* [POLY2D()](../Functions/Geo_spatial_functions.md#POLY2D%28%29)\n\n* [POW()](../Functions/Mathematical_functions.md#POW%28%29)\n\n* [RAND()](../Functions/Mathematical_functions.md#RAND%28%29)\n\n* [RANGE()](../Functions/Arrays_and_conditions_functions.md#RANGE%28%29)",
    "translations": {
      "chinese": "# 搜索中的表达式\n\nManticore 通过 SQL 和 HTTP 支持使用任意算术表达式，包含属性值、内部属性（文档 ID 和相关性权重）、算术运算、多种内置函数和用户定义函数。以下是完整的参考列表，方便快速查阅。\n\n## 算术运算符\n\nCODE_BLOCK_0\n\n支持标准算术运算符。涉及这些运算符的算术计算可以通过三种不同模式执行：\n\n1. 使用单精度 32 位 IEEE 754 浮点数（默认），\n\n2. 使用有符号 32 位整数，\n\n3. 使用有符号 64 位整数。\n\n表达式解析器会自动切换到整数模式，如果没有运算结果为浮点数。否则，使用默认的浮点模式。例如，a+b 如果两个参数都是 32 位整数，则使用 32 位整数计算；如果两个参数都是整数但其中一个是 64 位，则使用 64 位整数计算；否则使用浮点数计算。但是，`a/b` 或 `sqrt(a)` 总是以浮点数计算，因为这些运算返回非整数结果。为避免这种情况，可以使用 `IDIV(a,b)` 或 `DIV b` 形式。此外，`a*b` 在参数为 32 位时不会自动提升为 64 位。要强制使用 64 位结果，请使用 [BIGINT()](../Functions/Type_casting_functions.md#BIGINT%28%29)，但请注意，如果存在非整数运算，BIGINT() 会被忽略。\n\n## 比较运算符\n\nCODE_BLOCK_1\n\n比较运算符在条件为真时返回 1.0，否则返回 0.0。例如，当属性 `a` 等于属性 `b` 时，`(a=b)+3` 计算结果为 4；当 `a` 不等于 `b` 时，结果为 3。与 MySQL 不同，等值比较（即 `=` 和 `<>` 运算符）包含一个小的相等阈值（默认 1e-6）。如果比较值之间的差异在阈值内，则视为相等。\n\n对于多值属性，`BETWEEN` 和 `IN` 运算符如果至少有一个值满足条件，则返回真（类似于 [ANY()](../Functions/Arrays_and_conditions_functions.md#ANY%28%29)）。`IN` 运算符不支持 JSON 属性。`IS (NOT) NULL` 运算符仅支持 JSON 属性。\n\n## 布尔运算符\n\nCODE_BLOCK_2\n\n布尔运算符（AND、OR、NOT）行为符合预期。它们是左结合的，并且优先级最低。NOT 的优先级高于 AND 和 OR，但仍低于其他运算符。AND 和 OR 具有相同优先级，建议在复杂表达式中使用括号以避免混淆。\n\n## 位运算符\n\nCODE_BLOCK_3\n\n这些运算符分别执行按位与和按位或。操作数必须是整数类型。\n\n## 函数：\n\n* [ABS()](../Functions/Mathematical_functions.md#ABS%28%29)\n\n* [ALL()](../Functions/Arrays_and_conditions_functions.md#ALL%28%29)\n\n* [ANY()](../Functions/Arrays_and_conditions_functions.md#ANY%28%29)\n\n* [ATAN2()](../Functions/Mathematical_functions.md#ATAN2%28%29)\n\n* [BIGINT()](../Functions/Type_casting_functions.md#BIGINT%28%29)\n\n* [BITDOT()](../Functions/Mathematical_functions.md#BITDOT%28%29)\n\n* [BM25F()](../Functions/Searching_and_ranking_functions.md#BM25F%28%29)\n\n* [CEIL()](../Functions/Mathematical_functions.md#CEIL%28%29)\n\n* [CONCAT()](../Functions/String_functions.md#CONCAT%28%29)\n\n* [CONTAINS()](../Functions/Arrays_and_conditions_functions.md#CONTAINS%28%29)\n\n* [COS()](../Functions/Mathematical_functions.md#COS%28%29)\n\n* [CRC32()](../Functions/Mathematical_functions.md#CRC32%28%29)\n\n* [DATE_HISTOGRAM()](../Functions/Date_and_time_functions.md#DATE_HISTOGRAM%28%29)\n\n* [DATE_RANGE()](../Functions/Date_and_time_functions.md#DATE_RANGE%28%29)\n\n* [DAY()](../Functions/Date_and_time_functions.md#DAY%28%29)\n\n* [DOUBLE()](../Functions/Type_casting_functions.md#DOUBLE%28%29)\n\n* [EXP()](../Functions/Mathematical_functions.md#EXP%28%29)\n\n* [FIBONACCI()](../Functions/Mathematical_functions.md#FIBONACCI%28%29)\n\n* [FLOOR()](../Functions/Mathematical_functions.md#FLOOR%28%29)\n\n* [GEODIST()](../Functions/Geo_spatial_functions.md#GEODIST%28%29)\n\n* [GEOPOLY2D()](../Functions/Geo_spatial_functions.md#GEOPOLY2D%28%29)\n\n* [GREATEST()](../Functions/Mathematical_functions.md#GREATEST%28%29)\n\n* [HOUR()](../Functions/Date_and_time_functions.md#HOUR%28%29)\n\n* [HISTOGRAM()](../Functions/Arrays_and_conditions_functions.md#HISTOGRAM%28%29)\n\n* [IDIV()](../Functions/Mathematical_functions.md#IDIV%28%29)\n\n* [IF()](../Functions/Arrays_and_conditions_functions.md#IF%28%29)\n\n* [IN()](../Functions/Arrays_and_conditions_functions.md#IN%28%29)\n\n* [INDEXOF()](../Functions/Arrays_and_conditions_functions.md#INDEXOF%28%29)\n\n* [INTEGER()](../Functions/Type_casting_functions.md#INTEGER%28%29)\n\n* [INTERVAL()](../Functions/Arrays_and_conditions_functions.md#INTERVAL%28%29)\n\n* [LAST_INSERT_ID()](../Functions/Other_functions.md#LAST_INSERT_ID%28%29)\n\n* [LEAST()](../Functions/Mathematical_functions.md#LEAST%28%29)\n\n* [LENGTH()](../Functions/Arrays_and_conditions_functions.md#LENGTH%28%29)\n\n* [LN()](../Functions/Mathematical_functions.md#LN%28%29)\n\n* [LOG10()](../Functions/Mathematical_functions.md#LOG10%28%29)\n\n* [LOG2()](../Functions/Mathematical_functions.md#LOG2%28%29)\n\n* [MAX()](../Functions/Mathematical_functions.md#MAX%28%29)\n\n* [MIN()](../Functions/Mathematical_functions.md#MIN%28%29)\n\n* [MINUTE()](../Functions/Date_and_time_functions.md#MINUTE%28%29)\n\n* [MIN_TOP_SORTVAL()](../Functions/Searching_and_ranking_functions.md#MIN_TOP_SORTVAL%28%29)\n\n* [MIN_TOP_WEIGHT()](../Functions/Searching_and_ranking_functions.md#MIN_TOP_WEIGHT%28%29)\n\n* [MONTH()](../Functions/Date_and_time_functions.md#MONTH%28%29)\n\n* [NOW()](../Functions/Date_and_time_functions.md#NOW%28%29)\n\n* [PACKEDFACTORS()](../Functions/Searching_and_ranking_functions.md#PACKEDFACTORS%28%29)\n\n* [POLY2D()](../Functions/Geo_spatial_functions.md#POLY2D%28%29)\n\n* [POW()](../Functions/Mathematical_functions.md#POW%28%29)\n\n* [RAND()](../Functions/Mathematical_functions.md#RAND%28%29)\n\n* [RANGE()](../Functions/Arrays_and_conditions_functions.md#RANGE%28%29)",
      "russian": "# Выражения в поиске\n\nManticore позволяет использовать произвольные арифметические выражения как через SQL, так и через HTTP, включая значения атрибутов, внутренние атрибуты (ID документа и вес релевантности), арифметические операции, несколько встроенных функций и пользовательские функции. Ниже приведён полный справочный список для быстрого доступа.\n\n## Арифметические операторы\n\nCODE_BLOCK_0\n\nДоступны стандартные арифметические операторы. Арифметические вычисления с использованием этих операторов могут выполняться в трёх различных режимах:\n\n1. с использованием чисел с плавающей запятой одинарной точности, 32-битных по стандарту IEEE 754 (по умолчанию),\n\n2. с использованием знаковых 32-битных целых чисел,\n\n3. с использованием знаковых 64-битных целых чисел.\n\nПарсер выражений автоматически переключается в целочисленный режим, если ни одна операция не приводит к значению с плавающей точкой. В противном случае используется режим с плавающей точкой по умолчанию. Например, a+b будет вычислено с использованием 32-битных целых чисел, если оба аргумента 32-битные целые; или с использованием 64-битных целых, если оба аргумента целые, но один из них 64-битный; или в формате с плавающей точкой в остальных случаях. Однако `a/b` или `sqrt(a)` всегда будут вычисляться в формате с плавающей точкой, так как эти операции возвращают нецелочисленный результат. Чтобы избежать этого, можно использовать `IDIV(a,b)` или форму `DIV b`. Кроме того, `a*b` не будет автоматически повышать разрядность до 64-бит при аргументах 32-бит. Чтобы обеспечить 64-битный результат, используйте [BIGINT()](../Functions/Type_casting_functions.md#BIGINT%28%29), но учтите, что если присутствуют операции с нецелочисленными значениями, BIGINT() будет просто проигнорирован.\n\n## Операторы сравнения\n\nCODE_BLOCK_1\n\nОператоры сравнения возвращают 1.0, когда условие истинно, и 0.0 в противном случае. Например, `(a=b)+3` вычисляется как 4, когда атрибут `a` равен атрибуту `b`, и как 3, когда `a` не равен. В отличие от MySQL, сравнения на равенство (т.е. операторы `=` и `<>`) включают небольшой порог равенства (по умолчанию 1e-6). Если разница между сравниваемыми значениями находится в пределах порога, они считаются равными.\n\nОператоры `BETWEEN` и `IN` в случае многозначных атрибутов возвращают true, если хотя бы одно значение соответствует условию (аналогично [ANY()](../Functions/Arrays_and_conditions_functions.md#ANY%28%29)). Оператор `IN` не поддерживает JSON-атрибуты. Оператор `IS (NOT) NULL` поддерживается только для JSON-атрибутов.\n\n## Логические операторы\n\nCODE_BLOCK_2\n\nЛогические операторы (AND, OR, NOT) ведут себя ожидаемо. Они являются левосторонне ассоциативными и имеют самый низкий приоритет по сравнению с другими операторами. NOT имеет более высокий приоритет, чем AND и OR, но всё же ниже, чем любой другой оператор. AND и OR имеют одинаковый приоритет, поэтому рекомендуется использовать скобки, чтобы избежать путаницы в сложных выражениях.\n\n## Побитовые операторы\n\nCODE_BLOCK_3\n\nЭти операторы выполняют побитовое И и ИЛИ соответственно. Операнды должны быть целочисленных типов.\n\n## Функции:\n\n* [ABS()](../Functions/Mathematical_functions.md#ABS%28%29)\n\n* [ALL()](../Functions/Arrays_and_conditions_functions.md#ALL%28%29)\n\n* [ANY()](../Functions/Arrays_and_conditions_functions.md#ANY%28%29)\n\n* [ATAN2()](../Functions/Mathematical_functions.md#ATAN2%28%29)\n\n* [BIGINT()](../Functions/Type_casting_functions.md#BIGINT%28%29)\n\n* [BITDOT()](../Functions/Mathematical_functions.md#BITDOT%28%29)\n\n* [BM25F()](../Functions/Searching_and_ranking_functions.md#BM25F%28%29)\n\n* [CEIL()](../Functions/Mathematical_functions.md#CEIL%28%29)\n\n* [CONCAT()](../Functions/String_functions.md#CONCAT%28%29)\n\n* [CONTAINS()](../Functions/Arrays_and_conditions_functions.md#CONTAINS%28%29)\n\n* [COS()](../Functions/Mathematical_functions.md#COS%28%29)\n\n* [CRC32()](../Functions/Mathematical_functions.md#CRC32%28%29)\n\n* [DATE_HISTOGRAM()](../Functions/Date_and_time_functions.md#DATE_HISTOGRAM%28%29)\n\n* [DATE_RANGE()](../Functions/Date_and_time_functions.md#DATE_RANGE%28%29)\n\n* [DAY()](../Functions/Date_and_time_functions.md#DAY%28%29)\n\n* [DOUBLE()](../Functions/Type_casting_functions.md#DOUBLE%28%29)\n\n* [EXP()](../Functions/Mathematical_functions.md#EXP%28%29)\n\n* [FIBONACCI()](../Functions/Mathematical_functions.md#FIBONACCI%28%29)\n\n* [FLOOR()](../Functions/Mathematical_functions.md#FLOOR%28%29)\n\n* [GEODIST()](../Functions/Geo_spatial_functions.md#GEODIST%28%29)\n\n* [GEOPOLY2D()](../Functions/Geo_spatial_functions.md#GEOPOLY2D%28%29)\n\n* [GREATEST()](../Functions/Mathematical_functions.md#GREATEST%28%29)\n\n* [HOUR()](../Functions/Date_and_time_functions.md#HOUR%28%29)\n\n* [HISTOGRAM()](../Functions/Arrays_and_conditions_functions.md#HISTOGRAM%28%29)\n\n* [IDIV()](../Functions/Mathematical_functions.md#IDIV%28%29)\n\n* [IF()](../Functions/Arrays_and_conditions_functions.md#IF%28%29)\n\n* [IN()](../Functions/Arrays_and_conditions_functions.md#IN%28%29)\n\n* [INDEXOF()](../Functions/Arrays_and_conditions_functions.md#INDEXOF%28%29)\n\n* [INTEGER()](../Functions/Type_casting_functions.md#INTEGER%28%29)\n\n* [INTERVAL()](../Functions/Arrays_and_conditions_functions.md#INTERVAL%28%29)\n\n* [LAST_INSERT_ID()](../Functions/Other_functions.md#LAST_INSERT_ID%28%29)\n\n* [LEAST()](../Functions/Mathematical_functions.md#LEAST%28%29)\n\n* [LENGTH()](../Functions/Arrays_and_conditions_functions.md#LENGTH%28%29)\n\n* [LN()](../Functions/Mathematical_functions.md#LN%28%29)\n\n* [LOG10()](../Functions/Mathematical_functions.md#LOG10%28%29)\n\n* [LOG2()](../Functions/Mathematical_functions.md#LOG2%28%29)\n\n* [MAX()](../Functions/Mathematical_functions.md#MAX%28%29)\n\n* [MIN()](../Functions/Mathematical_functions.md#MIN%28%29)\n\n* [MINUTE()](../Functions/Date_and_time_functions.md#MINUTE%28%29)\n\n* [MIN_TOP_SORTVAL()](../Functions/Searching_and_ranking_functions.md#MIN_TOP_SORTVAL%28%29)\n\n* [MIN_TOP_WEIGHT()](../Functions/Searching_and_ranking_functions.md#MIN_TOP_WEIGHT%28%29)\n\n* [MONTH()](../Functions/Date_and_time_functions.md#MONTH%28%29)\n\n* [NOW()](../Functions/Date_and_time_functions.md#NOW%28%29)\n\n* [PACKEDFACTORS()](../Functions/Searching_and_ranking_functions.md#PACKEDFACTORS%28%29)\n\n* [POLY2D()](../Functions/Geo_spatial_functions.md#POLY2D%28%29)\n\n* [POW()](../Functions/Mathematical_functions.md#POW%28%29)\n\n* [RAND()](../Functions/Mathematical_functions.md#RAND%28%29)\n\n* [RANGE()](../Functions/Arrays_and_conditions_functions.md#RANGE%28%29)"
    },
    "is_code_or_comment": false
  }
}
