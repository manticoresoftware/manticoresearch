{
  "3af83c6d69967f9841f4acc1f1ff7617781958cfd4efc4f40dfa99b60f4d497d": {
    "original": "<!-- request TypeScript -->\n\nCODE_BLOCK_49\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_50\n\n<!-- request Go -->\n\nCODE_BLOCK_51\n\n<!-- response Go -->\n\nCODE_BLOCK_52\n\n<!-- end -->\n\n<!-- example Multi-level -->\n\n### Facet over multi-level grouping\n\nFacets can aggregate over multi-level grouping, with the result set being the same as if the query performed a multi-level grouping:\n\n<!-- request SQL -->\n\nCODE_BLOCK_53\n\n<!-- response SQL -->\n\nCODE_BLOCK_54\n\n<!-- end -->\n\n<!-- example histogram -->\n\n### Facet over histogram values\n\nFacets can aggregate over histogram values by constructing fixed-size buckets over the values.\n\nThe key function is:\n\nCODE_BLOCK_55\n\nThe histogram argument `interval` must be positive, and the histogram argument `offset` must be positive and less than `interval`. By default, the buckets are returned as an array. The histogram argument `keyed` makes the response a dictionary with the bucket keys.\n\n<!-- request SQL -->\n\nCODE_BLOCK_56\n\n<!-- response SQL -->\n\nCODE_BLOCK_57\n\n<!-- request JSON -->\n\nCODE_BLOCK_58\n\n<!-- response JSON -->\n\nCODE_BLOCK_59\n\n<!-- request JSON 2 -->\n\nCODE_BLOCK_60\n\n<!-- response JSON 2 -->\n\nCODE_BLOCK_61\n\n<!-- end -->\n\n<!-- example histogram_date -->\n\n### Facet over histogram date values\n\nFacets can aggregate over histogram date values, which is similar to the normal histogram. The difference is that the interval is specified using a date or time expression. Such expressions require special support because the intervals are not always of fixed length. Values are rounded to the closest bucket using the following key function:\n\nCODE_BLOCK_62\n\nThe histogram parameter `calendar_interval` understands months to have different amounts of days.\n\nUnlike `calendar_interval`, the `fixed_interval` parameter uses a fixed number of units and does not deviate, regardless of where it falls on the calendar. However `fixed_interval` cannot process units such as months because a month is not a fixed quantity. Attempting to specify units like weeks or months for `fixed_interval` will result in an error.\n\nThe accepted intervals are described in the [date_histogram](../Functions/Date_and_time_functions.md#DATE_HISTOGRAM%28%29) expression. By default, the buckets are returned as an array. The histogram argument `keyed` makes the response a dictionary with the bucket keys.\n\n<!-- request SQL -->\n\nCODE_BLOCK_63\n\n<!-- response SQL -->\n\nCODE_BLOCK_64\n\n<!-- request JSON -->\n\nCODE_BLOCK_65\n\n<!-- response JSON -->\n\nCODE_BLOCK_66\n\n<!-- end -->\n\n<!-- example facet range -->\n\n### Facet over set of ranges\n\nFacets can aggregate over a set of ranges. The values are checked against the bucket range, where each bucket includes the `from` value and excludes the `to` value from the range.\n\nSetting the `keyed` property to `true` makes the response a dictionary with the bucket keys rather than an array.\n\n<!-- request SQL -->\n\nCODE_BLOCK_67\n\n<!-- response SQL -->\n\nCODE_BLOCK_68\n\n<!-- request JSON -->\n\nCODE_BLOCK_69\n\n<!-- response JSON -->\n\nCODE_BLOCK_70\n\n<!-- request JSON 2 -->\n\nCODE_BLOCK_71\n\n<!-- response JSON 2 -->\n\nCODE_BLOCK_72\n\n<!-- end -->\n\n<!-- example facet range_date -->\n\n### Facet over set of date ranges\n\nFacets can aggregate over a set of date ranges, which is similar to the normal range. The difference is that the `from` and `to` values can be expressed in [Date math](../Functions/Date_and_time_functions.md#Date-math) expressions. This aggregation includes the `from` value and excludes the `to` value for each range. Setting the `keyed` property to `true` makes the response a dictionary with the bucket keys rather than an array.\n\n<!-- request SQL -->\n\nCODE_BLOCK_73\n\n<!-- response SQL -->\n\nCODE_BLOCK_74\n\n<!-- request JSON -->\n\nCODE_BLOCK_75\n\n<!-- response JSON -->\n\nCODE_BLOCK_76\n\n<!-- end -->\n\n<!-- example Ordering -->\n\n### Ordering in facet result\n\nFacets support the `ORDER BY` clause just like a standard query. Each facet can have its own ordering, and the facet ordering doesn't affect the main result set's ordering, which is determined by the main query's `ORDER BY`. Sorting can be done on attribute name, count (using `COUNT(*)`, `COUNT(DISTINCT attribute_name)`), or the special `FACET()` function, which provides the aggregated data values. By default, a query with `ORDER BY COUNT(*)` will sort in descending order.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_77\n\n<!-- response SQL -->\n\nCODE_BLOCK_78\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_79\n\n<!-- response JSON -->\n\nCODE_BLOCK_80\n\n<!-- end -->\n\n<!-- example Size -->\n\n### Size of facet result\n\nBy default, each facet result set is limited to 20 values. The number of facet values can be controlled with the `LIMIT` clause individually for each facet by providing either a number of values to return in the format `LIMIT count` or with an offset as `LIMIT offset, count`.\n\nThe maximum facet values that can be returned is limited by the query's `max_matches` setting. If you want to implement dynamic `max_matches` (limiting `max_matches` to offset + per page for better performance), it must be taken into account that a too low `max_matches` value can affect the number of facet values. In this case, a minimum `max_matches` value should be used that is sufficient to cover the number of facet values.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_81\n\n<!-- response SQL -->\n\nCODE_BLOCK_82\n\n<!-- request JSON -->\n\nCODE_BLOCK_83\n\n<!-- response JSON -->\n\nCODE_BLOCK_84\n\n<!-- request PHP -->\n\nCODE_BLOCK_85\n\n<!-- response PHP -->\n\nCODE_BLOCK_86\n\n<!-- request Python -->\n\nCODE_BLOCK_87\n\n<!-- response Python -->\n\nCODE_BLOCK_88\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_89\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_90\n\n<!-- request Javascript -->\n\nCODE_BLOCK_91\n\n<!-- response Javascript -->\n\nCODE_BLOCK_92\n\n<!-- request Java -->\n\nCODE_BLOCK_93\n\n<!-- response Java -->\n\nCODE_BLOCK_94\n\n<!-- request C# -->\n\nCODE_BLOCK_95\n\n<!-- response C# -->\n\nCODE_BLOCK_96\n\n<!-- request Rust -->\n\nCODE_BLOCK_97\n\n<!-- response Rust -->\n\nCODE_BLOCK_98\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_99\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_100\n\n<!-- request Go -->",
    "translations": {
      "chinese": "<!-- request TypeScript -->\n\nCODE_BLOCK_49\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_50\n\n<!-- request Go -->\n\nCODE_BLOCK_51\n\n<!-- response Go -->\n\nCODE_BLOCK_52\n\n<!-- end -->\n\n<!-- example Multi-level -->\n\n### Facet over multi-level grouping\n\nFacets can aggregate over multi-level grouping, with the result set being the same as if the query performed a multi-level grouping:\n\n<!-- request SQL -->\n\nCODE_BLOCK_53\n\n<!-- response SQL -->\n\nCODE_BLOCK_54\n\n<!-- end -->\n\n<!-- example histogram -->\n\n### Facet over histogram values\n\nFacets can aggregate over histogram values by constructing fixed-size buckets over the values.\n\nThe key function is:\n\nCODE_BLOCK_55\n\nThe histogram argument `interval` must be positive, and the histogram argument `offset` must be positive and less than `interval`. By default, the buckets are returned as an array. The histogram argument `keyed` makes the response a dictionary with the bucket keys.\n\n<!-- request SQL -->\n\nCODE_BLOCK_56\n\n<!-- response SQL -->\n\nCODE_BLOCK_57\n\n<!-- request JSON -->\n\nCODE_BLOCK_58\n\n<!-- response JSON -->\n\nCODE_BLOCK_59\n\n<!-- request JSON 2 -->\n\nCODE_BLOCK_60\n\n<!-- response JSON 2 -->\n\nCODE_BLOCK_61\n\n<!-- end -->\n\n<!-- example histogram_date -->\n\n### Facet over histogram date values\n\nFacets can aggregate over histogram date values, which is similar to the normal histogram. The difference is that the interval is specified using a date or time expression. Such expressions require special support because the intervals are not always of fixed length. Values are rounded to the closest bucket using the following key function:\n\nCODE_BLOCK_62\n\nThe histogram parameter `calendar_interval` understands months to have different amounts of days.\n\nUnlike `calendar_interval`, the `fixed_interval` parameter uses a fixed number of units and does not deviate, regardless of where it falls on the calendar. However `fixed_interval` cannot process units such as months because a month is not a fixed quantity. Attempting to specify units like weeks or months for `fixed_interval` will result in an error.\n\nThe accepted intervals are described in the [date_histogram](../Functions/Date_and_time_functions.md#DATE_HISTOGRAM%28%29) expression. By default, the buckets are returned as an array. The histogram argument `keyed` makes the response a dictionary with the bucket keys.\n\n<!-- request SQL -->\n\nCODE_BLOCK_63\n\n<!-- response SQL -->\n\nCODE_BLOCK_64\n\n<!-- request JSON -->\n\nCODE_BLOCK_65\n\n<!-- response JSON -->\n\nCODE_BLOCK_66\n\n<!-- end -->\n\n<!-- example facet range -->\n\n### Facet over set of ranges\n\nFacets can aggregate over a set of ranges. The values are checked against the bucket range, where each bucket includes the `from` value and excludes the `to` value from the range.\n\nSetting the `keyed` property to `true` makes the response a dictionary with the bucket keys rather than an array.\n\n<!-- request SQL -->\n\nCODE_BLOCK_67\n\n<!-- response SQL -->\n\nCODE_BLOCK_68\n\n<!-- request JSON -->\n\nCODE_BLOCK_69\n\n<!-- response JSON -->\n\nCODE_BLOCK_70\n\n<!-- request JSON 2 -->\n\nCODE_BLOCK_71\n\n<!-- response JSON 2 -->\n\nCODE_BLOCK_72\n\n<!-- end -->\n\n<!-- example facet range_date -->\n\n### Facet over set of date ranges\n\nFacets can aggregate over a set of date ranges, which is similar to the normal range. The difference is that the `from` and `to` values can be expressed in [Date math](../Functions/Date_and_time_functions.md#Date-math) expressions. This aggregation includes the `from` value and excludes the `to` value for each range. Setting the `keyed` property to `true` makes the response a dictionary with the bucket keys rather than an array.\n\n<!-- request SQL -->\n\nCODE_BLOCK_73\n\n<!-- response SQL -->\n\nCODE_BLOCK_74\n\n<!-- request JSON -->\n\nCODE_BLOCK_75\n\n<!-- response JSON -->\n\nCODE_BLOCK_76\n\n<!-- end -->\n\n<!-- example Ordering -->\n\n### Ordering in facet result\n\nFacets support the `ORDER BY` clause just like a standard query. Each facet can have its own ordering, and the facet ordering doesn't affect the main result set's ordering, which is determined by the main query's `ORDER BY`. Sorting can be done on attribute name, count (using `COUNT(*)`, `COUNT(DISTINCT attribute_name)`), or the special `FACET()` function, which provides the aggregated data values. By default, a query with `ORDER BY COUNT(*)` will sort in descending order.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_77\n\n<!-- response SQL -->\n\nCODE_BLOCK_78\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_79\n\n<!-- response JSON -->\n\nCODE_BLOCK_80\n\n<!-- end -->\n\n<!-- example Size -->\n\n### Size of facet result\n\nBy default, each facet result set is limited to 20 values. The number of facet values can be controlled with the `LIMIT` clause individually for each facet by providing either a number of values to return in the format `LIMIT count` or with an offset as `LIMIT offset, count`.\n\nThe maximum facet values that can be returned is limited by the query's `max_matches` setting. If you want to implement dynamic `max_matches` (limiting `max_matches` to offset + per page for better performance), it must be taken into account that a too low `max_matches` value can affect the number of facet values. In this case, a minimum `max_matches` value should be used that is sufficient to cover the number of facet values.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_81\n\n<!-- response SQL -->\n\nCODE_BLOCK_82\n\n<!-- request JSON -->\n\nCODE_BLOCK_83\n\n<!-- response JSON -->\n\nCODE_BLOCK_84\n\n<!-- request PHP -->\n\nCODE_BLOCK_85\n\n<!-- response PHP -->\n\nCODE_BLOCK_86\n\n<!-- request Python -->\n\nCODE_BLOCK_87\n\n<!-- response Python -->\n\nCODE_BLOCK_88\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_89\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_90\n\n<!-- request Javascript -->\n\nCODE_BLOCK_91\n\n<!-- response Javascript -->\n\nCODE_BLOCK_92\n\n<!-- request Java -->\n\nCODE_BLOCK_93\n\n<!-- response Java -->\n\nCODE_BLOCK_94\n\n<!-- request C# -->\n\nCODE_BLOCK_95\n\n<!-- response C# -->\n\nCODE_BLOCK_96\n\n<!-- request Rust -->\n\nCODE_BLOCK_97\n\n<!-- response Rust -->\n\nCODE_BLOCK_98\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_99\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_100\n\n<!-- request Go -->",
      "russian": "<!-- request TypeScript -->\n\nCODE_BLOCK_49\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_50\n\n<!-- request Go -->\n\nCODE_BLOCK_51\n\n<!-- response Go -->\n\nCODE_BLOCK_52\n\n<!-- end -->\n\n<!-- example Multi-level -->\n\n### Facet over multi-level grouping\n\nFacets can aggregate over multi-level grouping, with the result set being the same as if the query performed a multi-level grouping:\n\n<!-- request SQL -->\n\nCODE_BLOCK_53\n\n<!-- response SQL -->\n\nCODE_BLOCK_54\n\n<!-- end -->\n\n<!-- example histogram -->\n\n### Facet over histogram values\n\nFacets can aggregate over histogram values by constructing fixed-size buckets over the values.\n\nThe key function is:\n\nCODE_BLOCK_55\n\nThe histogram argument `interval` must be positive, and the histogram argument `offset` must be positive and less than `interval`. By default, the buckets are returned as an array. The histogram argument `keyed` makes the response a dictionary with the bucket keys.\n\n<!-- request SQL -->\n\nCODE_BLOCK_56\n\n<!-- response SQL -->\n\nCODE_BLOCK_57\n\n<!-- request JSON -->\n\nCODE_BLOCK_58\n\n<!-- response JSON -->\n\nCODE_BLOCK_59\n\n<!-- request JSON 2 -->\n\nCODE_BLOCK_60\n\n<!-- response JSON 2 -->\n\nCODE_BLOCK_61\n\n<!-- end -->\n\n<!-- example histogram_date -->\n\n### Facet over histogram date values\n\nFacets can aggregate over histogram date values, which is similar to the normal histogram. The difference is that the interval is specified using a date or time expression. Such expressions require special support because the intervals are not always of fixed length. Values are rounded to the closest bucket using the following key function:\n\nCODE_BLOCK_62\n\nThe histogram parameter `calendar_interval` understands months to have different amounts of days.\n\nUnlike `calendar_interval`, the `fixed_interval` parameter uses a fixed number of units and does not deviate, regardless of where it falls on the calendar. However `fixed_interval` cannot process units such as months because a month is not a fixed quantity. Attempting to specify units like weeks or months for `fixed_interval` will result in an error.\n\nThe accepted intervals are described in the [date_histogram](../Functions/Date_and_time_functions.md#DATE_HISTOGRAM%28%29) expression. By default, the buckets are returned as an array. The histogram argument `keyed` makes the response a dictionary with the bucket keys.\n\n<!-- request SQL -->\n\nCODE_BLOCK_63\n\n<!-- response SQL -->\n\nCODE_BLOCK_64\n\n<!-- request JSON -->\n\nCODE_BLOCK_65\n\n<!-- response JSON -->\n\nCODE_BLOCK_66\n\n<!-- end -->\n\n<!-- example facet range -->\n\n### Facet over set of ranges\n\nFacets can aggregate over a set of ranges. The values are checked against the bucket range, where each bucket includes the `from` value and excludes the `to` value from the range.\n\nSetting the `keyed` property to `true` makes the response a dictionary with the bucket keys rather than an array.\n\n<!-- request SQL -->\n\nCODE_BLOCK_67\n\n<!-- response SQL -->\n\nCODE_BLOCK_68\n\n<!-- request JSON -->\n\nCODE_BLOCK_69\n\n<!-- response JSON -->\n\nCODE_BLOCK_70\n\n<!-- request JSON 2 -->\n\nCODE_BLOCK_71\n\n<!-- response JSON 2 -->\n\nCODE_BLOCK_72\n\n<!-- end -->\n\n<!-- example facet range_date -->\n\n### Facet over set of date ranges\n\nFacets can aggregate over a set of date ranges, which is similar to the normal range. The difference is that the `from` and `to` values can be expressed in [Date math](../Functions/Date_and_time_functions.md#Date-math) expressions. This aggregation includes the `from` value and excludes the `to` value for each range. Setting the `keyed` property to `true` makes the response a dictionary with the bucket keys rather than an array.\n\n<!-- request SQL -->\n\nCODE_BLOCK_73\n\n<!-- response SQL -->\n\nCODE_BLOCK_74\n\n<!-- request JSON -->\n\nCODE_BLOCK_75\n\n<!-- response JSON -->\n\nCODE_BLOCK_76\n\n<!-- end -->\n\n<!-- example Ordering -->\n\n### Ordering in facet result\n\nFacets support the `ORDER BY` clause just like a standard query. Each facet can have its own ordering, and the facet ordering doesn't affect the main result set's ordering, which is determined by the main query's `ORDER BY`. Sorting can be done on attribute name, count (using `COUNT(*)`, `COUNT(DISTINCT attribute_name)`), or the special `FACET()` function, which provides the aggregated data values. By default, a query with `ORDER BY COUNT(*)` will sort in descending order.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_77\n\n<!-- response SQL -->\n\nCODE_BLOCK_78\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_79\n\n<!-- response JSON -->\n\nCODE_BLOCK_80\n\n<!-- end -->\n\n<!-- example Size -->\n\n### Size of facet result\n\nBy default, each facet result set is limited to 20 values. The number of facet values can be controlled with the `LIMIT` clause individually for each facet by providing either a number of values to return in the format `LIMIT count` or with an offset as `LIMIT offset, count`.\n\nThe maximum facet values that can be returned is limited by the query's `max_matches` setting. If you want to implement dynamic `max_matches` (limiting `max_matches` to offset + per page for better performance), it must be taken into account that a too low `max_matches` value can affect the number of facet values. In this case, a minimum `max_matches` value should be used that is sufficient to cover the number of facet values.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_81\n\n<!-- response SQL -->\n\nCODE_BLOCK_82\n\n<!-- request JSON -->\n\nCODE_BLOCK_83\n\n<!-- response JSON -->\n\nCODE_BLOCK_84\n\n<!-- request PHP -->\n\nCODE_BLOCK_85\n\n<!-- response PHP -->\n\nCODE_BLOCK_86\n\n<!-- request Python -->\n\nCODE_BLOCK_87\n\n<!-- response Python -->\n\nCODE_BLOCK_88\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_89\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_90\n\n<!-- request Javascript -->\n\nCODE_BLOCK_91\n\n<!-- response Javascript -->\n\nCODE_BLOCK_92\n\n<!-- request Java -->\n\nCODE_BLOCK_93\n\n<!-- response Java -->\n\nCODE_BLOCK_94\n\n<!-- request C# -->\n\nCODE_BLOCK_95\n\n<!-- response C# -->\n\nCODE_BLOCK_96\n\n<!-- request Rust -->\n\nCODE_BLOCK_97\n\n<!-- response Rust -->\n\nCODE_BLOCK_98\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_99\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_100\n\n<!-- request Go -->"
    },
    "is_code_or_comment": true
  },
  "6515db86794f33d2cf2b46df962d67fb7af6004be4f818d880de724fc10154cb": {
    "original": "CODE_BLOCK_101\n\n<!-- response Go -->\n\nCODE_BLOCK_102\n\n<!-- end -->\n\n### Returned result set\n\nWhen using SQL, a search with facets returns multiple result sets. The MySQL client/library/connector used **must** support multiple result sets in order to access the facet result sets.\n\n<!-- example Performance -->\n\n### Performance\n\nInternally, the `FACET` is a shorthand for executing a multi-query where the first query contains the main search query and the rest of the queries in the batch have each a clustering. As in the case of multi-query, the common query optimization can kick in for a faceted search, meaning the search query is executed only once, and the facets operate on the search query result, with each facet adding only a fraction of time to the total query time.\n\nTo check if the faceted search ran in an optimized mode, you can look in the [query log](../Logging/Query_logging.md), where all logged queries will contain an `xN` string, where `N` is the number of queries that ran in the optimized group. Alternatively, you can check the output of the [SHOW META](../Node_info_and_management/SHOW_META.md) statement, which will display a `multiplier` metric:\n\n<!-- request SQL -->\n\nCODE_BLOCK_103\n\n<!-- response SQL -->\n\nCODE_BLOCK_104\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "CODE_BLOCK_101\n\n<!-- response Go -->\n\nCODE_BLOCK_102\n\n<!-- end -->\n\n### 返回的结果集\n\n使用 SQL 时，带有分面的搜索会返回多个结果集。所使用的 MySQL 客户端/库/连接器**必须**支持多个结果集，才能访问分面结果集。\n\n<!-- example Performance -->\n\n### 性能\n\n在内部，`FACET` 是执行多查询的简写，其中第一个查询包含主搜索查询，批次中的其余查询各自包含一个聚类。与多查询的情况一样，通用查询优化可以应用于分面搜索，这意味着搜索查询只执行一次，分面操作基于搜索查询结果，每个分面只为总查询时间增加一小部分时间。\n\n要检查分面搜索是否以优化模式运行，可以查看[查询日志](../Logging/Query_logging.md)，所有记录的查询都会包含一个 `xN` 字符串，其中 `N` 是在优化组中运行的查询数量。或者，您可以检查[SHOW META](../Node_info_and_management/SHOW_META.md) 语句的输出，它会显示一个 `multiplier` 指标：\n\n<!-- request SQL -->\n\nCODE_BLOCK_103\n\n<!-- response SQL -->\n\nCODE_BLOCK_104\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "CODE_BLOCK_101\n\n<!-- response Go -->\n\nCODE_BLOCK_102\n\n<!-- end -->\n\n### Возвращаемый набор результатов\n\nПри использовании SQL поиск с фасетами возвращает несколько наборов результатов. Клиент/библиотека/коннектор MySQL, используемый **должен** поддерживать несколько наборов результатов, чтобы получить доступ к наборам результатов фасетов.\n\n<!-- example Performance -->\n\n### Производительность\n\nВнутренне `FACET` является сокращением для выполнения мультизапроса, где первый запрос содержит основной поисковый запрос, а остальные запросы в пакете имеют каждый свою кластеризацию. Как и в случае мультизапроса, общая оптимизация запросов может сработать для фасетного поиска, что означает, что поисковый запрос выполняется только один раз, а фасеты работают с результатом поискового запроса, при этом каждый фасет добавляет лишь часть времени к общему времени запроса.\n\nЧтобы проверить, был ли фасетный поиск выполнен в оптимизированном режиме, вы можете посмотреть в [журнал запросов](../Logging/Query_logging.md), где все записанные запросы будут содержать строку `xN`, где `N` — количество запросов, выполненных в оптимизированной группе. Кроме того, вы можете проверить вывод оператора [SHOW META](../Node_info_and_management/SHOW_META.md), который отобразит метрику `multiplier`:\n\n<!-- request SQL -->\n\nCODE_BLOCK_103\n\n<!-- response SQL -->\n\nCODE_BLOCK_104\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "e1200a4a2b7d5516c03e7b5eb40ac4dadaf32fefd86aa8c9d6b7e7849b4ab558": {
    "original": "# Faceted search\n\nFaceted search is as crucial to a modern search application as [autocomplete](../Searching/Autocomplete.md), [spell correction](../Searching/Spell_correction.md), and search keywords [highlighting](../Searching/Highlighting.md), especially in e-commerce products.\n\n![Faceted search](faceted.png)\n\nFaceted search comes in handy when dealing with large quantities of data and various interconnected properties, such as size, color, manufacturer, or other factors. When querying vast amounts of data, search results frequently include numerous entries that don't match the user's expectations. Faceted search enables the end user to explicitly define the criteria they want their search results to satisfy.\n\nIn Manticore Search, there's an optimization that maintains the result set of the original query and reuses it for each facet calculation. Since the aggregations are applied to an already calculated subset of documents, they're fast, and the total execution time can often be only slightly longer than the initial query. Facets can be added to any query, and the facet can be any attribute or expression. A facet result includes the facet values and the facet counts. Facets can be accessed using the SQL `SELECT` statement by declaring them at the very end of the query.\n\n## Aggregations\n\n<!-- example Aggregations -->\n\n### SQL\n\nThe facet values can originate from an attribute, a JSON property within a JSON attribute, or an expression. Facet values can also be aliased, but the **alias must be unique** across all result sets (main query result set and other facets result sets). The facet value is derived from the aggregated attribute/expression, but it can also come from another attribute/expression.\n\nCODE_BLOCK_0\n\nMultiple facet declarations must be separated by a whitespace.\n\n### HTTP JSON\n\nFacets can be defined in the `aggs` node:\n\nCODE_BLOCK_1\n\nwhere:\n\n* `group name` is an alias assigned to the aggregation\n\n* `field` value must contain the name of the attribute or expression being faceted\n\n* optional `size` specifies the maximum number of buckets to include in the result. When not specified, it inherits the main query's limit. More details can be found in the [Size of facet result](../Searching/Faceted_search.md#Size-of-facet-result) section.\n\n* optional `sort` specifies an array of attributes and/or additional properties using the same syntax as the [\"sort\" parameter in the main query](../Searching/Sorting_and_ranking.md#Sorting-via-JSON).\n\nThe result set will contain an `aggregations` node with the returned facets, where `key` is the aggregated value and `doc_count` is the aggregation count.\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- response SQL -->\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_5\n\n<!-- response JSON -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_7\n\n<!-- response PHP -->\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_9\n\n<!-- response Python -->\n\nCODE_BLOCK_10\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_11\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_12\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request Javascript -->\n\nCODE_BLOCK_13\n\n<!-- response Javascript -->\n\nCODE_BLOCK_14\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_15\n\n<!-- response Java -->\n\nCODE_BLOCK_16\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_17\n\n<!-- response C# -->\n\nCODE_BLOCK_18\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_19\n\n<!-- response Rust -->\n\nCODE_BLOCK_20\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_21\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_22\n\n<!-- request Go -->\n\nCODE_BLOCK_23\n\n<!-- response Go -->\n\nCODE_BLOCK_24\n\n<!-- end -->\n\n<!-- example Another_attribute -->\n\n### Faceting by aggregation over another attribute\n\nData can be faceted by aggregating another attribute or expression. For example if the documents contain both the brand id and name, we can return in facet the brand names, but aggregate the brand ids. This can be done by using `FACET {expr1} BY {expr2}`\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_25\n\n<!-- response SQL -->\n\nCODE_BLOCK_26\n\n<!-- end -->\n\n<!-- example Distinct -->\n\n### Faceting without duplicates\n\nIf you need to remove duplicates from the buckets returned by FACET, you can use `DISTINCT field_name`, where `field_name` is the field by which you want to perform deduplication. It can also be `id` (which is the default) if you make a FACET query against a distributed table and are not sure whether you have unique ids in the tables (the tables should be local and have the same schema).\n\nIf you have multiple FACET declarations in your query, `field_name` should be the same in all of them.\n\n`DISTINCT` returns an additional column `count(distinct ...)` before the column `count(*)`, allowing you to obtain both results without needing to make another query.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_27\n\n<!-- response SQL -->\n\nCODE_BLOCK_28\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_29\n\n<!-- response JSON -->\n\nCODE_BLOCK_30\n\n<!-- end -->\n\n<!-- example Expressions -->\n\n### Facet over expressions\n\nFacets can aggregate over expressions. A classic example is the segmentation of prices by specific ranges:\n\n<!-- request SQL -->\n\nCODE_BLOCK_31\n\n<!-- response SQL -->\n\nCODE_BLOCK_32\n\n<!-- request JSON -->\n\nCODE_BLOCK_33\n\n<!-- response JSON -->\n\nCODE_BLOCK_34\n\n<!-- request PHP -->\n\nCODE_BLOCK_35\n\n<!-- response PHP -->\n\nCODE_BLOCK_36\n\n<!-- request Python -->\n\nCODE_BLOCK_37\n\n<!-- response Python -->\n\nCODE_BLOCK_38\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_39\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_40\n\n<!-- request Javascript -->\n\nCODE_BLOCK_41\n\n<!-- response Javascript -->\n\nCODE_BLOCK_42\n\n<!-- request Java -->\n\nCODE_BLOCK_43\n\n<!-- response Java -->\n\nCODE_BLOCK_44\n\n<!-- request C# -->\n\nCODE_BLOCK_45\n\n<!-- response C# -->\n\nCODE_BLOCK_46\n\n<!-- request Rust -->\n\nCODE_BLOCK_47\n\n<!-- response Rust -->\n\nCODE_BLOCK_48",
    "translations": {
      "chinese": "# 分面搜索\n\n分面搜索对于现代搜索应用程序来说，与[自动完成](../Searching/Autocomplete.md)、[拼写纠正](../Searching/Spell_correction.md)和搜索关键词[高亮](../Searching/Highlighting.md)一样重要，尤其是在电子商务产品中。\n\n![分面搜索](faceted.png)\n\n当处理大量数据和各种相互关联的属性（如尺寸、颜色、制造商或其他因素）时，分面搜索非常有用。在查询大量数据时，搜索结果通常包含许多不符合用户期望的条目。分面搜索使最终用户能够明确指定他们希望搜索结果满足的条件。\n\n在 Manticore Search 中，有一种优化方法可以维护原始查询的结果集，并在每个分面计算中重用它。由于聚合应用于已经计算好的文档子集，因此速度很快，总执行时间通常仅比初始查询稍长。分面可以添加到任何查询中，分面可以是任何属性或表达式。分面结果包括分面值和分面计数。可以使用 SQL `SELECT` 语句通过在查询末尾声明分面来访问分面。\n\n## 聚合\n\n<!-- example Aggregations -->\n\n### SQL\n\n分面值可以来自属性、JSON 属性中的 JSON 属性，或表达式。分面值也可以被别名化，但**别名必须在所有结果集中唯一**（主查询结果集和其他分面结果集）。分面值来源于聚合的属性/表达式，但也可以来自另一个属性/表达式。\n\nCODE_BLOCK_0\n\n多个分面声明必须用空格分隔。\n\n### HTTP JSON\n\n分面可以在 `aggs` 节点中定义：\n\nCODE_BLOCK_1\n\n其中：\n\n* `group name` 是分配给聚合的别名\n\n* `field` 值必须包含被分面的属性或表达式的名称\n\n* 可选的 `size` 指定结果中包含的最大桶数。如果未指定，则继承主查询的限制。更多细节可见[分面结果大小](../Searching/Faceted_search.md#Size-of-facet-result)部分。\n\n* 可选的 `sort` 指定一个属性和/或附加属性的数组，使用与[主查询中的“sort”参数](../Searching/Sorting_and_ranking.md#Sorting-via-JSON)相同的语法。\n\n结果集将包含一个 `aggregations` 节点，返回的分面中，`key` 是聚合值，`doc_count` 是聚合计数。\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- response SQL -->\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_5\n\n<!-- response JSON -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_7\n\n<!-- response PHP -->\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_9\n\n<!-- response Python -->\n\nCODE_BLOCK_10\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_11\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_12\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request Javascript -->\n\nCODE_BLOCK_13\n\n<!-- response Javascript -->\n\nCODE_BLOCK_14\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_15\n\n<!-- response Java -->\n\nCODE_BLOCK_16\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_17\n\n<!-- response C# -->\n\nCODE_BLOCK_18\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_19\n\n<!-- response Rust -->\n\nCODE_BLOCK_20\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_21\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_22\n\n<!-- request Go -->\n\nCODE_BLOCK_23\n\n<!-- response Go -->\n\nCODE_BLOCK_24\n\n<!-- end -->\n\n<!-- example Another_attribute -->\n\n### 通过另一个属性的聚合进行分面\n\n数据可以通过聚合另一个属性或表达式进行分面。例如，如果文档同时包含品牌 ID 和名称，我们可以在分面中返回品牌名称，但聚合品牌 ID。这可以通过使用 `FACET {expr1} BY {expr2}` 来实现。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_25\n\n<!-- response SQL -->\n\nCODE_BLOCK_26\n\n<!-- end -->\n\n<!-- example Distinct -->\n\n### 去重分面\n\n如果需要从 FACET 返回的桶中去除重复项，可以使用 `DISTINCT field_name`，其中 `field_name` 是你想要进行去重的字段。如果对分布式表进行 FACET 查询且不确定表中是否有唯一 ID（表应为本地且具有相同的模式），也可以使用 `id`（默认值）。\n\n如果查询中有多个 FACET 声明，`field_name` 应在所有声明中保持一致。\n\n`DISTINCT` 会在 `count(*)` 列之前返回一个额外的列 `count(distinct ...)`，允许你同时获得两种结果，而无需进行另一次查询。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_27\n\n<!-- response SQL -->\n\nCODE_BLOCK_28\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_29\n\n<!-- response JSON -->\n\nCODE_BLOCK_30\n\n<!-- end -->\n\n<!-- example Expressions -->\n\n### 基于表达式的分面\n\n分面可以基于表达式进行聚合。一个经典的例子是按特定区间对价格进行分段：\n\n<!-- request SQL -->\n\nCODE_BLOCK_31\n\n<!-- response SQL -->\n\nCODE_BLOCK_32\n\n<!-- request JSON -->\n\nCODE_BLOCK_33\n\n<!-- response JSON -->\n\nCODE_BLOCK_34\n\n<!-- request PHP -->\n\nCODE_BLOCK_35\n\n<!-- response PHP -->\n\nCODE_BLOCK_36\n\n<!-- request Python -->\n\nCODE_BLOCK_37\n\n<!-- response Python -->\n\nCODE_BLOCK_38\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_39\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_40\n\n<!-- request Javascript -->\n\nCODE_BLOCK_41\n\n<!-- response Javascript -->\n\nCODE_BLOCK_42\n\n<!-- request Java -->\n\nCODE_BLOCK_43\n\n<!-- response Java -->\n\nCODE_BLOCK_44\n\n<!-- request C# -->\n\nCODE_BLOCK_45\n\n<!-- response C# -->\n\nCODE_BLOCK_46\n\n<!-- request Rust -->\n\nCODE_BLOCK_47\n\n<!-- response Rust -->\n\nCODE_BLOCK_48",
      "russian": "# Фасетный поиск\n\nФасетный поиск так же важен для современного поискового приложения, как [автозаполнение](../Searching/Autocomplete.md), [исправление опечаток](../Searching/Spell_correction.md) и подсветка поисковых ключевых слов [highlighting](../Searching/Highlighting.md), особенно в продуктах электронной коммерции.\n\n![Faceted search](faceted.png)\n\nФасетный поиск полезен при работе с большими объемами данных и различными взаимосвязанными свойствами, такими как размер, цвет, производитель или другие факторы. При запросе больших объемов данных результаты поиска часто включают множество записей, которые не соответствуют ожиданиям пользователя. Фасетный поиск позволяет конечному пользователю явно определить критерии, которым должны удовлетворять результаты поиска.\n\nВ Manticore Search есть оптимизация, которая сохраняет набор результатов исходного запроса и повторно использует его для каждого вычисления фасета. Поскольку агрегации применяются к уже вычисленному подмножеству документов, они выполняются быстро, и общее время выполнения часто может быть лишь немного дольше, чем у первоначального запроса. Фасеты можно добавлять к любому запросу, и фасет может быть любым атрибутом или выражением. Результат фасета включает значения фасета и количество по фасету. К фасетам можно получить доступ с помощью SQL-запроса `SELECT`, объявляя их в самом конце запроса.\n\n## Агрегации\n\n<!-- example Aggregations -->\n\n### SQL\n\nЗначения фасета могут исходить из атрибута, свойства JSON внутри JSON-атрибута или выражения. Значения фасета также могут иметь псевдонимы, но **псевдоним должен быть уникальным** во всех наборах результатов (основной набор результатов запроса и другие наборы результатов фасетов). Значение фасета выводится из агрегированного атрибута/выражения, но также может исходить из другого атрибута/выражения.\n\nCODE_BLOCK_0\n\nНесколько объявлений фасетов должны разделяться пробелом.\n\n### HTTP JSON\n\nФасеты можно определить в узле `aggs`:\n\nCODE_BLOCK_1\n\nгде:\n\n* `group name` — это псевдоним, присвоенный агрегации\n\n* значение `field` должно содержать имя атрибута или выражения, по которому выполняется фасетирование\n\n* необязательный параметр `size` указывает максимальное количество бакетов, включаемых в результат. Если не указан, наследует лимит основного запроса. Подробнее см. в разделе [Размер результата фасета](../Searching/Faceted_search.md#Size-of-facet-result).\n\n* необязательный параметр `sort` задает массив атрибутов и/или дополнительных свойств с использованием того же синтаксиса, что и [\"параметр sort в основном запросе\"](../Searching/Sorting_and_ranking.md#Sorting-via-JSON).\n\nНабор результатов будет содержать узел `aggregations` с возвращенными фасетами, где `key` — агрегированное значение, а `doc_count` — количество в агрегации.\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- response SQL -->\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_5\n\n<!-- response JSON -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_7\n\n<!-- response PHP -->\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_9\n\n<!-- response Python -->\n\nCODE_BLOCK_10\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_11\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_12\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request Javascript -->\n\nCODE_BLOCK_13\n\n<!-- response Javascript -->\n\nCODE_BLOCK_14\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_15\n\n<!-- response Java -->\n\nCODE_BLOCK_16\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_17\n\n<!-- response C# -->\n\nCODE_BLOCK_18\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_19\n\n<!-- response Rust -->\n\nCODE_BLOCK_20\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_21\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_22\n\n<!-- request Go -->\n\nCODE_BLOCK_23\n\n<!-- response Go -->\n\nCODE_BLOCK_24\n\n<!-- end -->\n\n<!-- example Another_attribute -->\n\n### Фасетирование по агрегации другого атрибута\n\nДанные можно фасетировать, агрегируя другой атрибут или выражение. Например, если документы содержат как идентификатор бренда, так и его название, можно вернуть в фасете названия брендов, но агрегировать идентификаторы брендов. Это можно сделать с помощью `FACET {expr1} BY {expr2}`\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_25\n\n<!-- response SQL -->\n\nCODE_BLOCK_26\n\n<!-- end -->\n\n<!-- example Distinct -->\n\n### Фасетирование без дубликатов\n\nЕсли нужно удалить дубликаты из бакетов, возвращаемых FACET, можно использовать `DISTINCT field_name`, где `field_name` — поле, по которому нужно выполнить дедупликацию. Это также может быть `id` (что является значением по умолчанию), если вы выполняете FACET-запрос к распределенной таблице и не уверены, что у вас уникальные идентификаторы в таблицах (таблицы должны быть локальными и иметь одинаковую схему).\n\nЕсли в вашем запросе несколько объявлений FACET, `field_name` должен быть одинаковым во всех них.\n\n`DISTINCT` возвращает дополнительный столбец `count(distinct ...)` перед столбцом `count(*)`, что позволяет получить оба результата без необходимости делать дополнительный запрос.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_27\n\n<!-- response SQL -->\n\nCODE_BLOCK_28\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_29\n\n<!-- response JSON -->\n\nCODE_BLOCK_30\n\n<!-- end -->\n\n<!-- example Expressions -->\n\n### Фасет по выражениям\n\nФасеты могут агрегировать по выражениям. Классический пример — сегментация цен по определенным диапазонам:\n\n<!-- request SQL -->\n\nCODE_BLOCK_31\n\n<!-- response SQL -->\n\nCODE_BLOCK_32\n\n<!-- request JSON -->\n\nCODE_BLOCK_33\n\n<!-- response JSON -->\n\nCODE_BLOCK_34\n\n<!-- request PHP -->\n\nCODE_BLOCK_35\n\n<!-- response PHP -->\n\nCODE_BLOCK_36\n\n<!-- request Python -->\n\nCODE_BLOCK_37\n\n<!-- response Python -->\n\nCODE_BLOCK_38\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_39\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_40\n\n<!-- request Javascript -->\n\nCODE_BLOCK_41\n\n<!-- response Javascript -->\n\nCODE_BLOCK_42\n\n<!-- request Java -->\n\nCODE_BLOCK_43\n\n<!-- response Java -->\n\nCODE_BLOCK_44\n\n<!-- request C# -->\n\nCODE_BLOCK_45\n\n<!-- response C# -->\n\nCODE_BLOCK_46\n\n<!-- request Rust -->\n\nCODE_BLOCK_47\n\n<!-- response Rust -->\n\nCODE_BLOCK_48"
    },
    "is_code_or_comment": false
  },
  "c0309983392f6fdf9b83889d3a83e19357402d8541741106b4f7990ffcce38b0": {
    "original": "The maximum facet values that can be returned is limited by the query's `max_matches` setting. If you want to implement dynamic `max_matches` (limiting `max_matches` to offset + per page for better performance), it must be taken into account that a too low `max_matches` value can affect the number of facet values. In this case, a minimum `max_matches` value should be used that is sufficient to cover the number of facet values.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_85\n\n<!-- response SQL -->\n\nCODE_BLOCK_86\n\n<!-- request JSON -->\n\nCODE_BLOCK_87\n\n<!-- response JSON -->\n\nCODE_BLOCK_88\n\n<!-- request PHP -->\n\nCODE_BLOCK_89\n\n<!-- response PHP -->\n\nCODE_BLOCK_90\n\n<!-- request Python -->\n\nCODE_BLOCK_91\n\n<!-- response Python -->\n\nCODE_BLOCK_92\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_93\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_94\n\n<!-- request Javascript -->\n\nCODE_BLOCK_95\n\n<!-- response Javascript -->\n\nCODE_BLOCK_96\n\n<!-- request Java -->\n\nCODE_BLOCK_97\n\n<!-- response Java -->\n\nCODE_BLOCK_98\n\n<!-- request C# -->\n\nCODE_BLOCK_99\n\n<!-- response C# -->\n\nCODE_BLOCK_100\n\n<!-- request Rust -->\n\nCODE_BLOCK_101\n\n<!-- response Rust -->\n\nCODE_BLOCK_102\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_103\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_104\n\n<!-- request Go -->\n\nCODE_BLOCK_105\n\n<!-- response Go -->\n\nCODE_BLOCK_106\n\n<!-- end -->\n\n### Returned result set\n\nWhen using SQL, a search with facets returns multiple result sets. The MySQL client/library/connector used **must** support multiple result sets in order to access the facet result sets.\n\n<!-- example Performance -->\n\n### Performance\n\nInternally, the `FACET` is a shorthand for executing a multi-query where the first query contains the main search query and the rest of the queries in the batch have each a clustering. As in the case of multi-query, the common query optimization can kick in for a faceted search, meaning the search query is executed only once, and the facets operate on the search query result, with each facet adding only a fraction of time to the total query time.\n\nTo check if the faceted search ran in an optimized mode, you can look in the [query log](../Logging/Query_logging.md), where all logged queries will contain an `xN` string, where `N` is the number of queries that ran in the optimized group. Alternatively, you can check the output of the [SHOW META](../Node_info_and_management/SHOW_META.md) statement, which will display a `multiplier` metric:\n\n<!-- request SQL -->\n\nCODE_BLOCK_107\n\n<!-- response SQL -->\n\nCODE_BLOCK_108\n\n<!-- request JSON -->\n\nCODE_BLOCK_109\n\n<!-- response JSON -->\n\nCODE_BLOCK_110\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "返回的最大分面值数量受查询的 `max_matches` 设置限制。如果你想实现动态的 `max_matches`（将 `max_matches` 限制为 offset + 每页数量以获得更好的性能），必须考虑到过低的 `max_matches` 值会影响分面值的数量。在这种情况下，应使用一个足够覆盖分面值数量的最小 `max_matches` 值。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_85\n\n<!-- response SQL -->\n\nCODE_BLOCK_86\n\n<!-- request JSON -->\n\nCODE_BLOCK_87\n\n<!-- response JSON -->\n\nCODE_BLOCK_88\n\n<!-- request PHP -->\n\nCODE_BLOCK_89\n\n<!-- response PHP -->\n\nCODE_BLOCK_90\n\n<!-- request Python -->\n\nCODE_BLOCK_91\n\n<!-- response Python -->\n\nCODE_BLOCK_92\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_93\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_94\n\n<!-- request Javascript -->\n\nCODE_BLOCK_95\n\n<!-- response Javascript -->\n\nCODE_BLOCK_96\n\n<!-- request Java -->\n\nCODE_BLOCK_97\n\n<!-- response Java -->\n\nCODE_BLOCK_98\n\n<!-- request C# -->\n\nCODE_BLOCK_99\n\n<!-- response C# -->\n\nCODE_BLOCK_100\n\n<!-- request Rust -->\n\nCODE_BLOCK_101\n\n<!-- response Rust -->\n\nCODE_BLOCK_102\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_103\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_104\n\n<!-- request Go -->\n\nCODE_BLOCK_105\n\n<!-- response Go -->\n\nCODE_BLOCK_106\n\n<!-- end -->\n\n### 返回的结果集\n\n使用 SQL 时，带有分面的搜索会返回多个结果集。所使用的 MySQL 客户端/库/连接器 **必须** 支持多结果集，以便访问分面结果集。\n\n<!-- example Performance -->\n\n### 性能\n\n在内部，`FACET` 是执行多查询的简写，其中第一个查询包含主搜索查询，批处理中的其余查询各自包含一个聚类。与多查询的情况一样，常见的查询优化可以应用于分面搜索，这意味着搜索查询只执行一次，分面操作基于搜索查询结果，每个分面只会为总查询时间增加少量时间。\n\n要检查分面搜索是否以优化模式运行，可以查看[查询日志](../Logging/Query_logging.md)，其中所有记录的查询都会包含一个 `xN` 字符串，`N` 是在优化组中运行的查询数量。或者，你可以检查 [SHOW META](../Node_info_and_management/SHOW_META.md) 语句的输出，它会显示一个 `multiplier` 指标：\n\n<!-- request SQL -->\n\nCODE_BLOCK_107\n\n<!-- response SQL -->\n\nCODE_BLOCK_108\n\n<!-- request JSON -->\n\nCODE_BLOCK_109\n\n<!-- response JSON -->\n\nCODE_BLOCK_110\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "Максимальное количество значений фасетов, которые могут быть возвращены, ограничено настройкой `max_matches` запроса. Если вы хотите реализовать динамическое значение `max_matches` (ограничение `max_matches` по значению offset + per page для лучшей производительности), необходимо учитывать, что слишком низкое значение `max_matches` может повлиять на количество значений фасетов. В этом случае следует использовать минимальное значение `max_matches`, достаточное для покрытия количества значений фасетов.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_85\n\n<!-- response SQL -->\n\nCODE_BLOCK_86\n\n<!-- request JSON -->\n\nCODE_BLOCK_87\n\n<!-- response JSON -->\n\nCODE_BLOCK_88\n\n<!-- request PHP -->\n\nCODE_BLOCK_89\n\n<!-- response PHP -->\n\nCODE_BLOCK_90\n\n<!-- request Python -->\n\nCODE_BLOCK_91\n\n<!-- response Python -->\n\nCODE_BLOCK_92\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_93\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_94\n\n<!-- request Javascript -->\n\nCODE_BLOCK_95\n\n<!-- response Javascript -->\n\nCODE_BLOCK_96\n\n<!-- request Java -->\n\nCODE_BLOCK_97\n\n<!-- response Java -->\n\nCODE_BLOCK_98\n\n<!-- request C# -->\n\nCODE_BLOCK_99\n\n<!-- response C# -->\n\nCODE_BLOCK_100\n\n<!-- request Rust -->\n\nCODE_BLOCK_101\n\n<!-- response Rust -->\n\nCODE_BLOCK_102\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_103\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_104\n\n<!-- request Go -->\n\nCODE_BLOCK_105\n\n<!-- response Go -->\n\nCODE_BLOCK_106\n\n<!-- end -->\n\n### Возвращаемый набор результатов\n\nПри использовании SQL поиск с фасетами возвращает несколько наборов результатов. Клиент/библиотека/коннектор MySQL, используемый вами, **должен** поддерживать множественные наборы результатов для доступа к результатам фасетов.\n\n<!-- example Performance -->\n\n### Производительность\n\nВнутренне `FACET` является сокращением для выполнения мультизапроса, где первый запрос содержит основной поисковый запрос, а остальные запросы в пакете имеют каждое собственную кластеризацию. Как и в случае мультизапроса, общая оптимизация запросов может применяться к фасетному поиску, что означает, что поисковый запрос выполняется только один раз, а фасеты работают с результатом поискового запроса, причем каждый фасет добавляет лишь долю времени к общему времени выполнения запроса.\n\nЧтобы проверить, был ли фасетный поиск выполнен в оптимизированном режиме, вы можете посмотреть в [журнал запросов](../Logging/Query_logging.md), где все зарегистрированные запросы будут содержать строку `xN`, где `N` — количество запросов, выполненных в оптимизированной группе. Альтернативно, можно проверить вывод оператора [SHOW META](../Node_info_and_management/SHOW_META.md), который покажет метрику `multiplier`:\n\n<!-- request SQL -->\n\nCODE_BLOCK_107\n\n<!-- response SQL -->\n\nCODE_BLOCK_108\n\n<!-- request JSON -->\n\nCODE_BLOCK_109\n\n<!-- response JSON -->\n\nCODE_BLOCK_110\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "5f5cea6c4c93a7f7a9025235cafd719c9ca1e7fafddbabc6f003c1d94caa2c9f": {
    "original": "Facets can aggregate over expressions. A classic example is the segmentation of prices by specific ranges:\n\n<!-- request SQL -->\n\nCODE_BLOCK_33\n\n<!-- response SQL -->\n\nCODE_BLOCK_34\n\n<!-- request JSON -->\n\nCODE_BLOCK_35\n\n<!-- response JSON -->\n\nCODE_BLOCK_36\n\n<!-- request PHP -->\n\nCODE_BLOCK_37\n\n<!-- response PHP -->\n\nCODE_BLOCK_38\n\n<!-- request Python -->\n\nCODE_BLOCK_39\n\n<!-- response Python -->\n\nCODE_BLOCK_40\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_41\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_42\n\n<!-- request Javascript -->\n\nCODE_BLOCK_43\n\n<!-- response Javascript -->\n\nCODE_BLOCK_44\n\n<!-- request Java -->\n\nCODE_BLOCK_45\n\n<!-- response Java -->\n\nCODE_BLOCK_46\n\n<!-- request C# -->\n\nCODE_BLOCK_47\n\n<!-- response C# -->\n\nCODE_BLOCK_48\n\n<!-- request Rust -->\n\nCODE_BLOCK_49\n\n<!-- response Rust -->\n\nCODE_BLOCK_50\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_51\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_52\n\n<!-- request Go -->\n\nCODE_BLOCK_53\n\n<!-- response Go -->\n\nCODE_BLOCK_54\n\n<!-- end -->\n\n<!-- example Multi-level -->\n\n### Facet over multi-level grouping\n\nFacets can aggregate over multi-level grouping, with the result set being the same as if the query performed a multi-level grouping:\n\n<!-- request SQL -->\n\nCODE_BLOCK_55\n\n<!-- response SQL -->\n\nCODE_BLOCK_56\n\n<!-- request JSON -->\n\nCODE_BLOCK_57\n\n<!-- response JSON -->\n\nCODE_BLOCK_58\n\n<!-- end -->\n\n<!-- example histogram -->\n\n### Facet over histogram values\n\nFacets can aggregate over histogram values by constructing fixed-size buckets over the values.\n\nThe key function is:\n\nCODE_BLOCK_59\n\nThe histogram argument `interval` must be positive, and the histogram argument `offset` must be positive and less than `interval`. By default, the buckets are returned as an array. The histogram argument `keyed` makes the response a dictionary with the bucket keys.\n\n<!-- request SQL -->\n\nCODE_BLOCK_60\n\n<!-- response SQL -->\n\nCODE_BLOCK_61\n\n<!-- request JSON -->\n\nCODE_BLOCK_62\n\n<!-- response JSON -->\n\nCODE_BLOCK_63\n\n<!-- request JSON 2 -->\n\nCODE_BLOCK_64\n\n<!-- response JSON 2 -->\n\nCODE_BLOCK_65\n\n<!-- end -->\n\n<!-- example histogram_date -->\n\n### Facet over histogram date values\n\nFacets can aggregate over histogram date values, which is similar to the normal histogram. The difference is that the interval is specified using a date or time expression. Such expressions require special support because the intervals are not always of fixed length. Values are rounded to the closest bucket using the following key function:\n\nCODE_BLOCK_66\n\nThe histogram parameter `calendar_interval` understands months to have different amounts of days.\n\nUnlike `calendar_interval`, the `fixed_interval` parameter uses a fixed number of units and does not deviate, regardless of where it falls on the calendar. However `fixed_interval` cannot process units such as months because a month is not a fixed quantity. Attempting to specify units like weeks or months for `fixed_interval` will result in an error.\n\nThe accepted intervals are described in the [date_histogram](../Functions/Date_and_time_functions.md#DATE_HISTOGRAM%28%29) expression. By default, the buckets are returned as an array. The histogram argument `keyed` makes the response a dictionary with the bucket keys.\n\n<!-- request SQL -->\n\nCODE_BLOCK_67\n\n<!-- response SQL -->\n\nCODE_BLOCK_68\n\n<!-- request JSON -->\n\nCODE_BLOCK_69\n\n<!-- response JSON -->\n\nCODE_BLOCK_70\n\n<!-- end -->\n\n<!-- example facet range -->\n\n### Facet over set of ranges\n\nFacets can aggregate over a set of ranges. The values are checked against the bucket range, where each bucket includes the `from` value and excludes the `to` value from the range.\n\nSetting the `keyed` property to `true` makes the response a dictionary with the bucket keys rather than an array.\n\n<!-- request SQL -->\n\nCODE_BLOCK_71\n\n<!-- response SQL -->\n\nCODE_BLOCK_72\n\n<!-- request JSON -->\n\nCODE_BLOCK_73\n\n<!-- response JSON -->\n\nCODE_BLOCK_74\n\n<!-- request JSON 2 -->\n\nCODE_BLOCK_75\n\n<!-- response JSON 2 -->\n\nCODE_BLOCK_76\n\n<!-- end -->\n\n<!-- example facet range_date -->\n\n### Facet over set of date ranges\n\nFacets can aggregate over a set of date ranges, which is similar to the normal range. The difference is that the `from` and `to` values can be expressed in [Date math](../Functions/Date_and_time_functions.md#Date-math) expressions. This aggregation includes the `from` value and excludes the `to` value for each range. Setting the `keyed` property to `true` makes the response a dictionary with the bucket keys rather than an array.\n\n<!-- request SQL -->\n\nCODE_BLOCK_77\n\n<!-- response SQL -->\n\nCODE_BLOCK_78\n\n<!-- request JSON -->\n\nCODE_BLOCK_79\n\n<!-- response JSON -->\n\nCODE_BLOCK_80\n\n<!-- end -->\n\n<!-- example Ordering -->\n\n### Ordering in facet result\n\nFacets support the `ORDER BY` clause just like a standard query. Each facet can have its own ordering, and the facet ordering doesn't affect the main result set's ordering, which is determined by the main query's `ORDER BY`. Sorting can be done on attribute name, count (using `COUNT(*)`, `COUNT(DISTINCT attribute_name)`), or the special `FACET()` function, which provides the aggregated data values. By default, a query with `ORDER BY COUNT(*)` will sort in descending order.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_81\n\n<!-- response SQL -->\n\nCODE_BLOCK_82\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_83\n\n<!-- response JSON -->\n\nCODE_BLOCK_84\n\n<!-- end -->\n\n<!-- example Size -->\n\n### Size of facet result\n\nBy default, each facet result set is limited to 20 values. The number of facet values can be controlled with the `LIMIT` clause individually for each facet by providing either a number of values to return in the format `LIMIT count` or with an offset as `LIMIT offset, count`.",
    "translations": {
      "chinese": "Facets 可以对表达式进行聚合。一个经典的例子是按特定范围对价格进行分段：\n\n<!-- request SQL -->\n\nCODE_BLOCK_33\n\n<!-- response SQL -->\n\nCODE_BLOCK_34\n\n<!-- request JSON -->\n\nCODE_BLOCK_35\n\n<!-- response JSON -->\n\nCODE_BLOCK_36\n\n<!-- request PHP -->\n\nCODE_BLOCK_37\n\n<!-- response PHP -->\n\nCODE_BLOCK_38\n\n<!-- request Python -->\n\nCODE_BLOCK_39\n\n<!-- response Python -->\n\nCODE_BLOCK_40\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_41\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_42\n\n<!-- request Javascript -->\n\nCODE_BLOCK_43\n\n<!-- response Javascript -->\n\nCODE_BLOCK_44\n\n<!-- request Java -->\n\nCODE_BLOCK_45\n\n<!-- response Java -->\n\nCODE_BLOCK_46\n\n<!-- request C# -->\n\nCODE_BLOCK_47\n\n<!-- response C# -->\n\nCODE_BLOCK_48\n\n<!-- request Rust -->\n\nCODE_BLOCK_49\n\n<!-- response Rust -->\n\nCODE_BLOCK_50\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_51\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_52\n\n<!-- request Go -->\n\nCODE_BLOCK_53\n\n<!-- response Go -->\n\nCODE_BLOCK_54\n\n<!-- end -->\n\n<!-- example Multi-level -->\n\n### 多级分组的 Facet\n\nFacets 可以对多级分组进行聚合，结果集与查询执行多级分组时相同：\n\n<!-- request SQL -->\n\nCODE_BLOCK_55\n\n<!-- response SQL -->\n\nCODE_BLOCK_56\n\n<!-- request JSON -->\n\nCODE_BLOCK_57\n\n<!-- response JSON -->\n\nCODE_BLOCK_58\n\n<!-- end -->\n\n<!-- example histogram -->\n\n### 基于直方图值的 Facet\n\nFacets 可以通过构建固定大小的桶对直方图值进行聚合。\n\n关键函数是：\n\nCODE_BLOCK_59\n\n直方图参数 `interval` 必须为正值，`offset` 必须为正且小于 `interval`。默认情况下，桶以数组形式返回。直方图参数 `keyed` 使响应变成一个包含桶键的字典。\n\n<!-- request SQL -->\n\nCODE_BLOCK_60\n\n<!-- response SQL -->\n\nCODE_BLOCK_61\n\n<!-- request JSON -->\n\nCODE_BLOCK_62\n\n<!-- response JSON -->\n\nCODE_BLOCK_63\n\n<!-- request JSON 2 -->\n\nCODE_BLOCK_64\n\n<!-- response JSON 2 -->\n\nCODE_BLOCK_65\n\n<!-- end -->\n\n<!-- example histogram_date -->\n\n### 基于日期直方图值的 Facet\n\nFacets 可以对日期直方图值进行聚合，这与普通直方图类似。区别在于间隔由日期或时间表达式指定。这类表达式需要特殊支持，因为区间长度不总是固定的。值会使用以下关键函数四舍五入到最近的桶：\n\nCODE_BLOCK_66\n\n直方图参数 `calendar_interval` 可以理解月份天数不同。\n\n与 `calendar_interval` 不同，`fixed_interval` 参数使用固定数量的单位且不偏差，无论落在日历的哪里。但 `fixed_interval` 不能处理像月份这样的单位，因为一个月并非固定量。尝试为 `fixed_interval` 指定周或月等单位会导致错误。\n\n所接受的间隔在 [date_histogram](../Functions/Date_and_time_functions.md#DATE_HISTOGRAM%28%29) 表达式中描述。默认情况下，桶以数组形式返回。直方图参数 `keyed` 使响应变成一个包含桶键的字典。\n\n<!-- request SQL -->\n\nCODE_BLOCK_67\n\n<!-- response SQL -->\n\nCODE_BLOCK_68\n\n<!-- request JSON -->\n\nCODE_BLOCK_69\n\n<!-- response JSON -->\n\nCODE_BLOCK_70\n\n<!-- end -->\n\n<!-- example facet range -->\n\n### 基于一组区间的 Facet\n\nFacets 可以对一组区间进行聚合。值会与桶区间进行匹配，每个桶包括区间的 `from` 值，不包括 `to` 值。\n\n将属性 `keyed` 设置为 `true` 会使响应变成一个带有桶键的字典，而不是数组。\n\n<!-- request SQL -->\n\nCODE_BLOCK_71\n\n<!-- response SQL -->\n\nCODE_BLOCK_72\n\n<!-- request JSON -->\n\nCODE_BLOCK_73\n\n<!-- response JSON -->\n\nCODE_BLOCK_74\n\n<!-- request JSON 2 -->\n\nCODE_BLOCK_75\n\n<!-- response JSON 2 -->\n\nCODE_BLOCK_76\n\n<!-- end -->\n\n<!-- example facet range_date -->\n\n### 基于一组日期区间的 Facet\n\nFacets 可以对一组日期区间进行聚合，这类似于普通的区间。区别在于 `from` 和 `to` 值可以使用 [日期数学](../Functions/Date_and_time_functions.md#Date-math) 表达式表示。聚合包括每个区间的 `from` 值，不包括 `to` 值。将属性 `keyed` 设置为 `true` 会使响应变成一个带有桶键的字典，而不是数组。\n\n<!-- request SQL -->\n\nCODE_BLOCK_77\n\n<!-- response SQL -->\n\nCODE_BLOCK_78\n\n<!-- request JSON -->\n\nCODE_BLOCK_79\n\n<!-- response JSON -->\n\nCODE_BLOCK_80\n\n<!-- end -->\n\n<!-- example Ordering -->\n\n### Facet 结果中的排序\n\nFacets 支持与标准查询相同的 `ORDER BY` 子句。每个 facet 可以有自己的排序，facet 的排序不会影响主结果集的排序，后者由主查询的 `ORDER BY` 决定。排序可以基于属性名、计数（使用 `COUNT(*)`、`COUNT(DISTINCT attribute_name)`）或特殊函数 `FACET()`，该函数提供聚合后的数据值。默认情况下，带有 `ORDER BY COUNT(*)` 的查询按降序排序。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_81\n\n<!-- response SQL -->\n\nCODE_BLOCK_82\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_83\n\n<!-- response JSON -->\n\nCODE_BLOCK_84\n\n<!-- end -->\n\n<!-- example Size -->\n\n### Facet 结果的大小\n\n默认情况下，每个 facet 结果集限制为 20 个值。可以使用 `LIMIT` 子句为每个 facet 单独控制返回的 facet 值数量，格式为 `LIMIT count` 指定返回数量，或 `LIMIT offset, count` 带偏移量指定数量。",
      "russian": "Фасеты могут агрегировать по выражениям. Классический пример — сегментация цен по определённым диапазонам:\n\n<!-- request SQL -->\n\nCODE_BLOCK_33\n\n<!-- response SQL -->\n\nCODE_BLOCK_34\n\n<!-- request JSON -->\n\nCODE_BLOCK_35\n\n<!-- response JSON -->\n\nCODE_BLOCK_36\n\n<!-- request PHP -->\n\nCODE_BLOCK_37\n\n<!-- response PHP -->\n\nCODE_BLOCK_38\n\n<!-- request Python -->\n\nCODE_BLOCK_39\n\n<!-- response Python -->\n\nCODE_BLOCK_40\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_41\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_42\n\n<!-- request Javascript -->\n\nCODE_BLOCK_43\n\n<!-- response Javascript -->\n\nCODE_BLOCK_44\n\n<!-- request Java -->\n\nCODE_BLOCK_45\n\n<!-- response Java -->\n\nCODE_BLOCK_46\n\n<!-- request C# -->\n\nCODE_BLOCK_47\n\n<!-- response C# -->\n\nCODE_BLOCK_48\n\n<!-- request Rust -->\n\nCODE_BLOCK_49\n\n<!-- response Rust -->\n\nCODE_BLOCK_50\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_51\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_52\n\n<!-- request Go -->\n\nCODE_BLOCK_53\n\n<!-- response Go -->\n\nCODE_BLOCK_54\n\n<!-- end -->\n\n<!-- example Multi-level -->\n\n### Фасет по многоуровневой группировке\n\nФасеты могут агрегировать по многоуровневой группировке, при этом результирующий набор будет таким же, как если бы запрос выполнял многоуровневую группировку:\n\n<!-- request SQL -->\n\nCODE_BLOCK_55\n\n<!-- response SQL -->\n\nCODE_BLOCK_56\n\n<!-- request JSON -->\n\nCODE_BLOCK_57\n\n<!-- response JSON -->\n\nCODE_BLOCK_58\n\n<!-- end -->\n\n<!-- example histogram -->\n\n### Фасет по значениям гистограммы\n\nФасеты могут агрегировать по значениям гистограммы, конструируя фиксированного размера корзины (бакеты) по значениям.\n\nКлючевая функция:\n\nCODE_BLOCK_59\n\nАргумент гистограммы `interval` должен быть положительным, а аргумент `offset` — положительным и меньшим, чем `interval`. По умолчанию бакеты возвращаются в виде массива. Аргумент гистограммы `keyed` делает ответ словарём с ключами бакетов.\n\n<!-- request SQL -->\n\nCODE_BLOCK_60\n\n<!-- response SQL -->\n\nCODE_BLOCK_61\n\n<!-- request JSON -->\n\nCODE_BLOCK_62\n\n<!-- response JSON -->\n\nCODE_BLOCK_63\n\n<!-- request JSON 2 -->\n\nCODE_BLOCK_64\n\n<!-- response JSON 2 -->\n\nCODE_BLOCK_65\n\n<!-- end -->\n\n<!-- example histogram_date -->\n\n### Фасет по значениям гистограммы дат\n\nФасеты могут агрегировать по значениям гистограммы дат, что похоже на обычную гистограмму. Разница в том, что интервал задаётся с помощью выражения даты или времени. Такие выражения требуют специальной поддержки, поскольку интервалы не всегда имеют фиксированную длину. Значения округляются до ближайшего бакета с использованием следующей ключевой функции:\n\nCODE_BLOCK_66\n\nПараметр гистограммы `calendar_interval` учитывает, что в месяцах разное количество дней.\n\nВ отличие от `calendar_interval`, параметр `fixed_interval` использует фиксированное количество единиц и не отклоняется, независимо от положения на календаре. Однако `fixed_interval` не может обрабатывать такие единицы, как месяцы, так как месяц — это не фиксированная величина. Попытка указать такие единицы, как недели или месяцы для `fixed_interval`, приведёт к ошибке.\n\nДопустимые интервалы описаны в выражении [date_histogram](../Functions/Date_and_time_functions.md#DATE_HISTOGRAM%28%29). По умолчанию бакеты возвращаются в виде массива. Аргумент гистограммы `keyed` делает ответ словарём с ключами бакетов.\n\n<!-- request SQL -->\n\nCODE_BLOCK_67\n\n<!-- response SQL -->\n\nCODE_BLOCK_68\n\n<!-- request JSON -->\n\nCODE_BLOCK_69\n\n<!-- response JSON -->\n\nCODE_BLOCK_70\n\n<!-- end -->\n\n<!-- example facet range -->\n\n### Фасет по набору диапазонов\n\nФасеты могут агрегировать по набору диапазонов. Значения проверяются на принадлежность диапазону бака, где каждый бакет включает значение `from` и исключает значение `to`.\n\nУстановка свойства `keyed` в `true` делает ответ словарём с ключами бакетов вместо массива.\n\n<!-- request SQL -->\n\nCODE_BLOCK_71\n\n<!-- response SQL -->\n\nCODE_BLOCK_72\n\n<!-- request JSON -->\n\nCODE_BLOCK_73\n\n<!-- response JSON -->\n\nCODE_BLOCK_74\n\n<!-- request JSON 2 -->\n\nCODE_BLOCK_75\n\n<!-- response JSON 2 -->\n\nCODE_BLOCK_76\n\n<!-- end -->\n\n<!-- example facet range_date -->\n\n### Фасет по набору датированных диапазонов\n\nФасеты могут агрегировать по набору датированных диапазонов, что похоже на обычные диапазоны. Разница в том, что значения `from` и `to` могут выражаться через выражения [Date math](../Functions/Date_and_time_functions.md#Date-math). Эта агрегация включает значение `from` и исключает значение `to` для каждого диапазона. Установка свойства `keyed` в `true` делает ответ словарём с ключами бакетов вместо массива.\n\n<!-- request SQL -->\n\nCODE_BLOCK_77\n\n<!-- response SQL -->\n\nCODE_BLOCK_78\n\n<!-- request JSON -->\n\nCODE_BLOCK_79\n\n<!-- response JSON -->\n\nCODE_BLOCK_80\n\n<!-- end -->\n\n<!-- example Ordering -->\n\n### Сортировка в результате фасета\n\nФасеты поддерживают оператор `ORDER BY` так же, как и стандартный запрос. Каждый фасет может иметь свою собственную сортировку, и сортировка фасетов не влияет на сортировку основного набора результатов, которая определяется оператором `ORDER BY` основного запроса. Сортировать можно по имени атрибута, количеству (с помощью `COUNT(*)`, `COUNT(DISTINCT attribute_name)`) или специальной функции `FACET()`, которая предоставляет агрегированные значения. По умолчанию запрос с `ORDER BY COUNT(*)` сортирует по убыванию.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_81\n\n<!-- response SQL -->\n\nCODE_BLOCK_82\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_83\n\n<!-- response JSON -->\n\nCODE_BLOCK_84\n\n<!-- end -->\n\n<!-- example Size -->\n\n### Размер результата фасета\n\nПо умолчанию размер каждого результата фасета ограничен 20 значениями. Количество значений фасета можно контролировать с помощью оператора `LIMIT` отдельно для каждого фасета, указав либо количество возвращаемых значений в формате `LIMIT count`, либо с оффсетом как `LIMIT offset, count`."
    },
    "is_code_or_comment": false
  },
  "05defd599ee68533b1863d7533a7184cfb52020243b00629b79ca7361883f2ce": {
    "original": "# Faceted search\n\nFaceted search is as crucial to a modern search application as [autocomplete](../Searching/Autocomplete.md), [spell correction](../Searching/Spell_correction.md), and search keywords [highlighting](../Searching/Highlighting.md), especially in e-commerce products.\n\n![Faceted search](faceted.png)\n\nFaceted search comes in handy when dealing with large quantities of data and various interconnected properties, such as size, color, manufacturer, or other factors. When querying vast amounts of data, search results frequently include numerous entries that don't match the user's expectations. Faceted search enables the end user to explicitly define the criteria they want their search results to satisfy.\n\nIn Manticore Search, there's an optimization that maintains the result set of the original query and reuses it for each facet calculation. Since the aggregations are applied to an already calculated subset of documents, they're fast, and the total execution time can often be only slightly longer than the initial query. Facets can be added to any query, and the facet can be any attribute or expression. A facet result includes the facet values and the facet counts. Facets can be accessed using the SQL `SELECT` statement by declaring them at the very end of the query.\n\n## Aggregations\n\n<!-- example Aggregations -->\n\n### SQL\n\nThe facet values can originate from an attribute, a JSON property within a JSON attribute, or an expression. Facet values can also be aliased, but the **alias must be unique** across all result sets (main query result set and other facets result sets). The facet value is derived from the aggregated attribute/expression, but it can also come from another attribute/expression.\n\nCODE_BLOCK_0\n\nMultiple facet declarations must be separated by a whitespace.\n\n### HTTP JSON\n\nFacets can be defined in the `aggs` node:\n\nCODE_BLOCK_1\n\nwhere:\n\n* `group name` is an alias assigned to the aggregation\n\n* `field` value must contain the name of the attribute or expression being faceted\n\n* optional `size` specifies the maximum number of buckets to include in the result. When not specified, it inherits the main query's limit. More details can be found in the [Size of facet result](../Searching/Faceted_search.md#Size-of-facet-result) section.\n\n* optional `sort` specifies an array of attributes and/or additional properties using the same syntax as the [\"sort\" parameter in the main query](../Searching/Sorting_and_ranking.md#Sorting-via-JSON).\n\nThe result set will contain an `aggregations` node with the returned facets, where `key` is the aggregated value and `doc_count` is the aggregation count.\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- response SQL -->\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_5\n\n<!-- response JSON -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_7\n\n<!-- response PHP -->\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_9\n\n<!-- response Python -->\n\nCODE_BLOCK_10\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_11\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_12\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request Javascript -->\n\nCODE_BLOCK_13\n\n<!-- response Javascript -->\n\nCODE_BLOCK_14\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_15\n\n<!-- response Java -->\n\nCODE_BLOCK_16\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_17\n\n<!-- response C# -->\n\nCODE_BLOCK_18\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_19\n\n<!-- response Rust -->\n\nCODE_BLOCK_20\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_21\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_22\n\n<!-- request Go -->\n\nCODE_BLOCK_23\n\n<!-- response Go -->\n\nCODE_BLOCK_24\n\n<!-- end -->\n\n<!-- example Another_attribute -->\n\n### Faceting by aggregation over another attribute\n\nData can be faceted by aggregating another attribute or expression. For example if the documents contain both the brand id and name, we can return in facet the brand names, but aggregate the brand ids. This can be done by using `FACET {expr1} BY {expr2}`\n\n<!--\n\ndata for the following examples:\n\nDROP TABLE IF EXISTS facetdemo;\n\nCREATE TABLE facetdemo(price float, brand_id int, title text, brand_name string, brand_id int, j json, categories multi);\n\nINSERT INTO facetdemo(price, brand_id, title, brand_name, brand_id, j, categories) VALUES\n\n(306, 1, 'Product Ten Three', 'Brand One', 'Six_Ten', {\"prop1\":66,\"prop2\":91,\"prop3\":\"One\"}, (10,11)),\n\n(400, 10, 'Product Three One', 'Brand Ten', 'Four_Three', {\"prop1\":69,\"prop2\":19,\"prop3\":\"One\"}, (13,14)),\n\n(855, 1, 'Product Seven Two', 'Brand One', 'Eight_Seven', {\"prop1\":63,\"prop2\":78,\"prop3\":\"One\"}, (10,11,12)),\n\n(31, 9, 'Product Four One', 'Brand Nine', 'Ten_Four', {\"prop1\":79,\"prop2\":42,\"prop3\":\"One\"}, '(12,13,14));\n\n--> \n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_25\n\n<!-- response SQL -->\n\nCODE_BLOCK_26\n\n<!-- request JSON -->\n\nCODE_BLOCK_27\n\n<!-- response JSON -->\n\nCODE_BLOCK_28\n\n<!-- end -->\n\n<!-- example Distinct -->\n\n### Faceting without duplicates\n\nIf you need to remove duplicates from the buckets returned by FACET, you can use `DISTINCT field_name`, where `field_name` is the field by which you want to perform deduplication. It can also be `id` (which is the default) if you make a FACET query against a distributed table and are not sure whether you have unique ids in the tables (the tables should be local and have the same schema).\n\nIf you have multiple FACET declarations in your query, `field_name` should be the same in all of them.\n\n`DISTINCT` returns an additional column `count(distinct ...)` before the column `count(*)`, allowing you to obtain both results without needing to make another query.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_29\n\n<!-- response SQL -->\n\nCODE_BLOCK_30\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_31\n\n<!-- response JSON -->\n\nCODE_BLOCK_32\n\n<!-- end -->\n\n<!-- example Expressions -->\n\n### Facet over expressions",
    "translations": {
      "chinese": "# 多面搜索\n\n多面搜索对于现代搜索应用程序来说，与[自动完成](../Searching/Autocomplete.md)、[拼写纠正](../Searching/Spell_correction.md)和搜索关键词的[高亮](../Searching/Highlighting.md)一样重要，尤其是在电子商务产品中。\n\n![多面搜索](faceted.png)\n\n当处理大量数据和各种相互关联的属性（如尺寸、颜色、制造商或其他因素）时，多面搜索非常有用。在查询大量数据时，搜索结果经常包含许多不符合用户期望的条目。多面搜索使最终用户能够明确指定他们希望搜索结果满足的条件。\n\n在 Manticore Search 中，有一种优化手段可以维护原始查询的结果集，并将其用于每个面的计算。由于聚合应用于已经计算好的文档子集，因此它们执行得很快，总执行时间通常仅比初始查询稍长。面可以添加到任何查询中，面可以是任何属性或表达式。面结果包括面值和面计数。可以通过 SQL 的 `SELECT` 语句访问面，只需在查询的最后声明它们。\n\n## 聚合\n\n<!-- example Aggregations -->\n\n### SQL\n\n面值可以来源于属性、JSON 属性中的 JSON 属性，或表达式。面值也可以别名，但**别名在所有结果集（主查询结果集和其他面结果集）中必须唯一**。面值是从聚合的属性/表达式派生的，但它也可以来自另一个属性/表达式。\n\nCODE_BLOCK_0\n\n多个面声明必须用空格分隔。\n\n### HTTP JSON\n\n可在 `aggs` 节点中定义面：\n\nCODE_BLOCK_1\n\n其中：\n\n* `group name` 是赋予聚合的别名\n\n* `field` 值必须包含被面的属性或表达式的名称\n\n* 可选的 `size` 指定结果中包含的桶的最大数量。未指定时，继承主查询的限制。更多细节见[面结果大小](../Searching/Faceted_search.md#Size-of-facet-result)段落。\n\n* 可选的 `sort` 指定一个属性和/或额外属性的数组，使用与[主查询中的“sort”参数](../Searching/Sorting_and_ranking.md#Sorting-via-JSON)相同的语法。\n\n结果集将包含带返回面的 `aggregations` 节点，其中 `key` 是聚合的值，`doc_count` 是聚合计数。\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- response SQL -->\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_5\n\n<!-- response JSON -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_7\n\n<!-- response PHP -->\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_9\n\n<!-- response Python -->\n\nCODE_BLOCK_10\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_11\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_12\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request Javascript -->\n\nCODE_BLOCK_13\n\n<!-- response Javascript -->\n\nCODE_BLOCK_14\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_15\n\n<!-- response Java -->\n\nCODE_BLOCK_16\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_17\n\n<!-- response C# -->\n\nCODE_BLOCK_18\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_19\n\n<!-- response Rust -->\n\nCODE_BLOCK_20\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_21\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_22\n\n<!-- request Go -->\n\nCODE_BLOCK_23\n\n<!-- response Go -->\n\nCODE_BLOCK_24\n\n<!-- end -->\n\n<!-- example Another_attribute -->\n\n### 基于另一属性的聚合面\n\n数据可通过聚合另一属性或表达式来进行面处理。例如，如果文档包含品牌ID和名称，我们可以在面中返回品牌名称，但聚合品牌ID。这可以通过使用 `FACET {expr1} BY {expr2}` 来实现。\n\n<!--\n\ndata for the following examples:\n\nDROP TABLE IF EXISTS facetdemo;\n\nCREATE TABLE facetdemo(price float, brand_id int, title text, brand_name string, brand_id int, j json, categories multi);\n\nINSERT INTO facetdemo(price, brand_id, title, brand_name, brand_id, j, categories) VALUES\n\n(306, 1, 'Product Ten Three', 'Brand One', 'Six_Ten', {\"prop1\":66,\"prop2\":91,\"prop3\":\"One\"}, (10,11)),\n\n(400, 10, 'Product Three One', 'Brand Ten', 'Four_Three', {\"prop1\":69,\"prop2\":19,\"prop3\":\"One\"}, (13,14)),\n\n(855, 1, 'Product Seven Two', 'Brand One', 'Eight_Seven', {\"prop1\":63,\"prop2\":78,\"prop3\":\"One\"}, (10,11,12)),\n\n(31, 9, 'Product Four One', 'Brand Nine', 'Ten_Four', {\"prop1\":79,\"prop2\":42,\"prop3\":\"One\"}, '(12,13,14));\n\n--> \n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_25\n\n<!-- response SQL -->\n\nCODE_BLOCK_26\n\n<!-- request JSON -->\n\nCODE_BLOCK_27\n\n<!-- response JSON -->\n\nCODE_BLOCK_28\n\n<!-- end -->\n\n<!-- example Distinct -->\n\n### 无重复项的面处理\n\n如果需要从 FACET 返回的桶中去重，可以使用 `DISTINCT field_name`，其中 `field_name` 是要去重的字段。如果对分布式表执行 FACET 查询且不确定表中是否有唯一ID，可以使用 `id`（默认）。这些表应是本地且具有相同架构。\n\n如果查询中有多个 FACET 声明，`field_name` 应在所有声明中保持一致。\n\n`DISTINCT` 在 `count(*)` 列前返回一个额外的列 `count(distinct ...)`，允许同时获得两种结果，无需再发起查询。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_29\n\n<!-- response SQL -->\n\nCODE_BLOCK_30\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_31\n\n<!-- response JSON -->\n\nCODE_BLOCK_32\n\n<!-- end -->\n\n<!-- example Expressions -->\n\n### 基于表达式的面",
      "russian": "# Фасетный поиск\n\nФасетный поиск так же важен для современного поискового приложения, как [автозаполнение](../Searching/Autocomplete.md), [исправление орфографии](../Searching/Spell_correction.md) и подсветка поисковых ключевых слов [highlighting](../Searching/Highlighting.md), особенно в продуктах электронной коммерции.\n\n![Фасетный поиск](faceted.png)\n\nФасетный поиск особенно удобен при работе с большим количеством данных и различными взаимосвязанными свойствами, такими как размер, цвет, производитель или другие параметры. При запросе огромных объемов данных результаты поиска часто включают множество записей, не соответствующих ожиданиям пользователя. Фасетный поиск позволяет конечному пользователю явно определить критерии, которым должны удовлетворять результаты его поиска.\n\nВ Manticore Search реализована оптимизация, которая сохраняет набор результатов исходного запроса и повторно использует его для вычисления каждой фасеты. Поскольку агрегации применяются к уже вычисленному подмножеству документов, они выполняются быстро, и общее время выполнения зачастую лишь немного превышает время начального запроса. Фасеты можно добавлять к любому запросу, и фасетой может быть любой атрибут или выражение. Результат фасеты включает значения фасеты и количество элементов для каждого значения. К фасетам можно обращаться с помощью SQL-запроса `SELECT`, объявляя их в самом конце запроса.\n\n## Агрегации\n\n<!-- example Aggregations -->\n\n### SQL\n\nЗначения фасет могут исходить из атрибута, JSON-свойства внутри JSON-атрибута или из выражения. Значения фасет также могут иметь псевдонимы, но **псевдоним должен быть уникальным** во всех наборах результатов (основной набор результатов запроса и другие наборы фасет). Значение фасеты получается из агрегируемого атрибута/выражения, но также может браться из другого атрибута/выражения.\n\nCODE_BLOCK_0\n\nНесколько объявлений фасет должны быть разделены пробелом.\n\n### HTTP JSON\n\nФасеты можно определить в узле `aggs`:\n\nCODE_BLOCK_1\n\nгде:\n\n* `group name` — псевдоним, присвоенный агрегации\n\n* значение `field` должно содержать имя атрибута или выражение, по которому строится фасета\n\n* необязательный параметр `size` указывает максимальное количество корзин (buckets) для включения в результат. Если не указан, наследует ограничение основного запроса. Подробнее см. в разделе [Размер фасетного результата](../Searching/Faceted_search.md#Size-of-facet-result).\n\n* необязательный параметр `sort` задаёт массив атрибутов и/или дополнительных свойств с использованием того же синтаксиса, что и [параметр \"sort\" в основном запросе](../Searching/Sorting_and_ranking.md#Sorting-via-JSON).\n\nНабор результатов будет содержать узел `aggregations` с возвращёнными фасетами, где `key` — это агрегированное значение, а `doc_count` — количество агрегаций.\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- response SQL -->\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_5\n\n<!-- response JSON -->\n\nCODE_BLOCK_6\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_7\n\n<!-- response PHP -->\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n##### Python:\n\n<!-- request Python -->\n\nCODE_BLOCK_9\n\n<!-- response Python -->\n\nCODE_BLOCK_10\n\n<!-- intro -->\n\n##### Python-asyncio:\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_11\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_12\n\n<!-- intro -->\n\n##### Javascript:\n\n<!-- request Javascript -->\n\nCODE_BLOCK_13\n\n<!-- response Javascript -->\n\nCODE_BLOCK_14\n\n<!-- intro -->\n\n##### Java:\n\n<!-- request Java -->\n\nCODE_BLOCK_15\n\n<!-- response Java -->\n\nCODE_BLOCK_16\n\n<!-- intro -->\n\n##### C#:\n\n<!-- request C# -->\n\nCODE_BLOCK_17\n\n<!-- response C# -->\n\nCODE_BLOCK_18\n\n<!-- intro -->\n\n##### Rust:\n\n<!-- request Rust -->\n\nCODE_BLOCK_19\n\n<!-- response Rust -->\n\nCODE_BLOCK_20\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_21\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_22\n\n<!-- request Go -->\n\nCODE_BLOCK_23\n\n<!-- response Go -->\n\nCODE_BLOCK_24\n\n<!-- end -->\n\n<!-- example Another_attribute -->\n\n### Фасетирование с агрегацией по другому атрибуту\n\nДанные можно фасетировать, аггрегируя по другому атрибуту или выражению. Например, если документы содержат как id бренда, так и его имя, мы можем вернуть в фасете имена брендов, но агрегировать id брендов. Это можно сделать, используя `FACET {expr1} BY {expr2}`\n\n<!--\n\ndata for the following examples:\n\nDROP TABLE IF EXISTS facetdemo;\n\nCREATE TABLE facetdemo(price float, brand_id int, title text, brand_name string, brand_id int, j json, categories multi);\n\nINSERT INTO facetdemo(price, brand_id, title, brand_name, brand_id, j, categories) VALUES\n\n(306, 1, 'Product Ten Three', 'Brand One', 'Six_Ten', {\"prop1\":66,\"prop2\":91,\"prop3\":\"One\"}, (10,11)),\n\n(400, 10, 'Product Three One', 'Brand Ten', 'Four_Three', {\"prop1\":69,\"prop2\":19,\"prop3\":\"One\"}, (13,14)),\n\n(855, 1, 'Product Seven Two', 'Brand One', 'Eight_Seven', {\"prop1\":63,\"prop2\":78,\"prop3\":\"One\"}, (10,11,12)),\n\n(31, 9, 'Product Four One', 'Brand Nine', 'Ten_Four', {\"prop1\":79,\"prop2\":42,\"prop3\":\"One\"}, '(12,13,14));\n\n--> \n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_25\n\n<!-- response SQL -->\n\nCODE_BLOCK_26\n\n<!-- request JSON -->\n\nCODE_BLOCK_27\n\n<!-- response JSON -->\n\nCODE_BLOCK_28\n\n<!-- end -->\n\n<!-- example Distinct -->\n\n### Фасетирование без дубликатов\n\nЕсли необходимо убрать дубликаты из корзин, возвращаемых FACET, можно использовать `DISTINCT field_name`, где `field_name` — поле, по которому надо выполнить дедупликацию. Это может быть и `id` (что является значением по умолчанию), если вы делаете FACET-запрос по распределённой таблице и не уверены, что у вас уникальные id в таблицах (таблицы должны быть локальными и иметь одинаковую схему).\n\nЕсли в вашем запросе несколько объявлений FACET, `field_name` должен быть одинаковым во всех из них.\n\n`DISTINCT` возвращает дополнительный столбец `count(distinct ...)` перед столбцом `count(*)`, что позволяет получить оба результата без необходимости делать дополнительный запрос.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_29\n\n<!-- response SQL -->\n\nCODE_BLOCK_30\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_31\n\n<!-- response JSON -->\n\nCODE_BLOCK_32\n\n<!-- end -->\n\n<!-- example Expressions -->\n\n### Фасет по выражениям"
    },
    "is_code_or_comment": false
  }
}
