{
  "285bad50aaa572d1da6f567c5c3d88547ddf156144cce553e3d06a5bc4bd5665": {
    "original": "Specifies distance calculation function. Can be either adaptive or haversine. adaptive is faster and more precise, for more details see `GEODIST()`. Optional, defaults to adaptive.\n\n##### distance\n\nSpecifies the maximum distance from the pin locations. All documents within this distance match. The distance can be specified in various units. If no unit is specified, the distance is assumed to be in meters. Here is a list of supported distance units:\n\n* Meter: `m` or `meters`\n\n* Kilometer: `km` or `kilometers`\n\n* Centimeter: `cm` or `centimeters`\n\n* Millimeter: `mm` or `millimeters`\n\n* Mile: `mi` or `miles`\n\n* Yard: `yd` or `yards`\n\n* Feet: `ft` or `feet`\n\n* Inch: `in` or `inch`\n\n* Nautical mile: `NM`, `nmi` or `nauticalmiles`\n\n`location_anchor` and `location_source` properties accept the following latitude/longitude formats:\n\n* an object with lat and lon keys: `{ \"lat\": \"attr_lat\", \"lon\": \"attr_lon\" }`\n\n* a string of the following structure: `\"attr_lat, attr_lon\"`\n\n* an array with the latitude and longitude in the following order: `[attr_lon, attr_lat]`\n\nLatitude and longitude are specified in degrees.\n\n<!-- request Basic example -->\n\nCODE_BLOCK_17\n\n<!-- request Advanced example -->\n\n`geo_distance` can be used as a filter in bool queries along with matches or other attribute filters.\n\nCODE_BLOCK_18\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "指定距离计算函数。可以是adaptive或haversine。adaptive更快且更精确，更多细节请参见`GEODIST()`。可选，默认值为adaptive。\n\n##### distance\n\n指定距离针脚位置的最大距离。所有在此距离内的文档都匹配。距离可以用各种单位指定。如果未指定单位，则距离默认为米。以下是支持的距离单位列表：\n\n* 米：`m` 或 `meters`\n\n* 千米：`km` 或 `kilometers`\n\n* 厘米：`cm` 或 `centimeters`\n\n* 毫米：`mm` 或 `millimeters`\n\n* 英里：`mi` 或 `miles`\n\n* 码：`yd` 或 `yards`\n\n* 英尺：`ft` 或 `feet`\n\n* 英寸：`in` 或 `inch`\n\n* 海里：`NM`、`nmi` 或 `nauticalmiles`\n\n`location_anchor` 和 `location_source` 属性接受以下纬度/经度格式：\n\n* 带有lat和lon键的对象：`{ \"lat\": \"attr_lat\", \"lon\": \"attr_lon\" }`\n\n* 具有以下结构的字符串：`\"attr_lat, attr_lon\"`\n\n* 按以下顺序排列纬度和经度的数组：`[attr_lon, attr_lat]`\n\n纬度和经度以度为单位指定。\n\n<!-- request Basic example -->\n\nCODE_BLOCK_17\n\n<!-- request Advanced example -->\n\n`geo_distance` 可以作为bool查询中的过滤器，与匹配或其他属性过滤器一起使用。\n\nCODE_BLOCK_18\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "Указывает функцию расчёта расстояния. Может быть либо adaptive, либо haversine. adaptive работает быстрее и точнее, для подробностей смотрите `GEODIST()`. Необязательно, по умолчанию adaptive.\n\n##### distance\n\nУказывает максимальное расстояние от местоположений меток. Все документы в пределах этого расстояния соответствуют запросу. Расстояние можно указать в различных единицах измерения. Если единица не указана, расстояние считается в метрах. Вот список поддерживаемых единиц измерения расстояния:\n\n* Метр: `m` или `meters`\n\n* Километр: `km` или `kilometers`\n\n* Сантиметр: `cm` или `centimeters`\n\n* Миллиметр: `mm` или `millimeters`\n\n* Миля: `mi` или `miles`\n\n* Ярд: `yd` или `yards`\n\n* Фут: `ft` или `feet`\n\n* Дюйм: `in` или `inch`\n\n* Морская миля: `NM`, `nmi` или `nauticalmiles`\n\nСвойства `location_anchor` и `location_source` принимают следующие форматы широты/долготы:\n\n* объект с ключами lat и lon: `{ \"lat\": \"attr_lat\", \"lon\": \"attr_lon\" }`\n\n* строка следующей структуры: `\"attr_lat, attr_lon\"`\n\n* массив с широтой и долготой в следующем порядке: `[attr_lon, attr_lat]`\n\nШирота и долгота указываются в градусах.\n\n<!-- request Basic example -->\n\nCODE_BLOCK_17\n\n<!-- request Advanced example -->\n\n`geo_distance` может использоваться как фильтр в bool-запросах вместе с matches или другими фильтрами атрибутов.\n\nCODE_BLOCK_18\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "40bdd1e62e24eeae65b56512b239da75e0f3a09ff9081767109b2f28b382ae00": {
    "original": "# Filters\n\n## WHERE\n\n`WHERE` is an SQL clause that works for both full-text matching and additional filtering. The following operators are available:\n\n* [Comparison operators](../Searching/Expressions.md#Comparison-operators) `<, >, <=, >=, =, <>, BETWEEN, IN, IS NULL`\n\n* [Boolean operators](../Searching/Full_text_matching/Operators.md#Boolean-operators) `AND, OR, NOT`\n\n`MATCH('query')` is supported and maps to a [full-text query](../Searching/Full_text_matching/Operators.md).\n\nThe `{col_name | expr_alias} [NOT] IN @uservar` condition syntax is supported. Refer to the [SET](../Server_settings/Setting_variables_online.md#SET) syntax for a description of global user variables.\n\n## HTTP JSON\n\nIf you prefer the HTTP JSON interface, you can also apply filtering. It might seem more complex than SQL, but it is recommended for cases when you need to prepare a query programmatically, such as when a user fills out a form in your application.\n\n<!-- example json1 -->\n\nHere's an example of several filters in a `bool` query.\n\nThis full-text query matches all documents containing `product` in any field. These documents must have a price greater than or equal to 500 (`gte`) and less than or equal to 1000 (`lte`). All of these documents must not have a revision less than 15 (`lt`).\n\n<!-- request JSON -->\n\nCODE_BLOCK_0\n\n<!-- end -->\n\n### bool query\n\n<!-- example bool -->\n\nThe `bool` query matches documents based on boolean combinations of other queries and/or filters. Queries and filters must be specified in `must`, `should`, or `must_not` sections and can be [nested](../Searching/Filters.md#Nested-bool-query).\n\n<!-- request JSON -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n<!-- example must_not -->\n\n### must\n\nQueries and filters specified in the `must` section are required to match the documents. If multiple fulltext queries or filters are specified, all of them must match. This is the equivalent of `AND` queries in SQL. Note that if you want to match against an array ([multi-value attribute](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29)), you can specify the attribute multiple times. The result will be positive only if all the queried values are found in the array, e.g.:\n\nCODE_BLOCK_2\n\nNote also, it may be better in terms of performance to use:\n\nCODE_BLOCK_3\n\n(see details below).\n\n### should\n\nQueries and filters specified in the `should` section should match the documents. If some queries are specified in `must` or `must_not`, `should` queries are ignored. On the other hand, if there are no queries other than `should`, then at least one of these queries must match a document for it to match the bool query. This is the equivalent of `OR` queries. Note, if you want to match against an array ([multi-value attribute](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29)) you can specify the attribute multiple times, e.g.:\n\nCODE_BLOCK_4\n\nNote also, it may be better in terms of performance to use:\n\nCODE_BLOCK_5\n\n(see details below).\n\n### must_not\n\nQueries and filters specified in the `must_not` section must not match the documents. If several queries are specified under `must_not`, the document matches if none of them match.\n\n<!-- request JSON -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n### Nested bool query\n\n<!-- example eq_and_or -->\n\nA bool query can be nested inside another bool so you can make more complex queries. To make a nested boolean query just use another `bool` instead of `must`, `should` or `must_not`. Here is how this query:\n\nCODE_BLOCK_7\n\nshould be presented in JSON.\n\n<!-- request JSON -->\n\na = 2 and (a = 10 or b = 0)\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!-- example complex -->\n\nMore complex query:\n\nCODE_BLOCK_9\n\n<!-- request JSON -->\n\n(a = 1 and b = 1) or (a = 10 and b = 2) or (b = 0)\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n### Queries in SQL format\n\n<!-- example query_string -->\n\nQueries in SQL format (`query_string`) can also be used in bool queries.\n\n<!-- request JSON -->\n\nCODE_BLOCK_11\n\n<!-- end -->\n\n## Various filters\n\n### Equality filters\n\n<!-- example equals -->\n\nEquality filters are the simplest filters that work with integer, float and string attributes.\n\n<!-- request JSON -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n<!-- example equals_any -->\n\nFilter `equals` can be applied to a [multi-value attribute](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29) and you can use:\n\n* `any()` which will be positive if the attribute has at least one value which equals to the queried value;\n\n* `all()` which will be positive if the attribute has a single value and it equals to the queried value\n\n<!-- request JSON -->\n\nCODE_BLOCK_13\n\n<!-- end -->\n\n### Set filters\n\n<!-- example set -->\n\nSet filters check if attribute value is equal to any of the values in the specified set.\n\nSet filters support integer, string and multi-value attributes.\n\n<!-- request JSON -->\n\nCODE_BLOCK_14\n\n<!-- end -->\n\n<!-- example set_any -->\n\nWhen applied to a [multi-value attribute](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29) you can use:\n\n* `any()` (equivalent to no function) which will be positive if there's at least one match between the attribute values and the queried values;\n\n* `all()` which will be positive if all the attribute values are in the queried set\n\n<!-- request JSON -->\n\nCODE_BLOCK_15\n\n<!-- end -->\n\n### Range filters\n\n<!-- example range -->\n\nRange filters match documents that have attribute values within a specified range.\n\nRange filters support the following properties:\n\n* `gte`: greater than or equal to\n\n* `gt`: greater than\n\n* `lte`: less than or equal to\n\n* `lt`: less than\n\n<!-- request JSON -->\n\nCODE_BLOCK_16\n\n<!-- end -->\n\n### Geo distance filters\n\n<!-- example geo -->\n\n`geo_distance` filters are used to filter the documents that are within a specific distance from a geo location.\n\n##### location_anchor\n\nSpecifies the pin location, in degrees. Distances are calculated from this point.\n\n##### location_source\n\nSpecifies the attributes that contain latitude and longitude.\n\n##### distance_type",
    "translations": {
      "chinese": "# 过滤器\n\n## WHERE\n\n`WHERE` 是一个 SQL 子句，既适用于全文匹配，也适用于额外的过滤。可用的操作符如下：\n\n* [比较操作符](../Searching/Expressions.md#Comparison-operators) `<, >, <=, >=, =, <>, BETWEEN, IN, IS NULL`\n\n* [布尔操作符](../Searching/Full_text_matching/Operators.md#Boolean-operators) `AND, OR, NOT`\n\n支持 `MATCH('query')`，并映射到[全文查询](../Searching/Full_text_matching/Operators.md)。\n\n支持 `{col_name | expr_alias} [NOT] IN @uservar` 条件语法。有关全局用户变量的描述，请参阅 [SET](../Server_settings/Setting_variables_online.md#SET) 语法。\n\n## HTTP JSON\n\n如果您更喜欢 HTTP JSON 接口，也可以应用过滤。它看起来可能比 SQL 更复杂，但推荐用于需要以编程方式准备查询的情况，例如当用户在您的应用中填写表单时。\n\n<!-- example json1 -->\n\n下面是一个包含多个过滤器的 `bool` 查询示例。\n\n此全文查询匹配所有在任意字段中包含 `product` 的文档。这些文档的价格必须大于或等于 500 (`gte`) 并且小于或等于 1000 (`lte`)。所有这些文档的修订版本必须不小于 15 (`lt`)。\n\n<!-- request JSON -->\n\nCODE_BLOCK_0\n\n<!-- end -->\n\n### bool 查询\n\n<!-- example bool -->\n\n`bool` 查询基于其他查询和/或过滤器的布尔组合来匹配文档。查询和过滤器必须在 `must`、`should` 或 `must_not` 部分指定，并且可以[嵌套](../Searching/Filters.md#Nested-bool-query)。\n\n<!-- request JSON -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n<!-- example must_not -->\n\n### must\n\n在 `must` 部分指定的查询和过滤器是必须匹配文档的。如果指定了多个全文查询或过滤器，则必须全部匹配。这相当于 SQL 中的 `AND` 查询。注意，如果您想匹配数组（[多值属性](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29)），可以多次指定该属性。只有当数组中找到所有查询值时，结果才为正，例如：\n\nCODE_BLOCK_2\n\n另请注意，从性能角度来看，使用以下方式可能更好：\n\nCODE_BLOCK_3\n\n（详见下文）。\n\n### should\n\n在 `should` 部分指定的查询和过滤器应当匹配文档。如果在 `must` 或 `must_not` 中指定了某些查询，则忽略 `should` 查询。另一方面，如果除了 `should` 外没有其他查询，则至少有一个 `should` 查询必须匹配文档，文档才匹配 bool 查询。这相当于 `OR` 查询。注意，如果您想匹配数组（[多值属性](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29)），可以多次指定该属性，例如：\n\nCODE_BLOCK_4\n\n另请注意，从性能角度来看，使用以下方式可能更好：\n\nCODE_BLOCK_5\n\n（详见下文）。\n\n### must_not\n\n在 `must_not` 部分指定的查询和过滤器必须不匹配文档。如果在 `must_not` 下指定了多个查询，则只要没有一个匹配，文档即匹配。\n\n<!-- request JSON -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n### 嵌套 bool 查询\n\n<!-- example eq_and_or -->\n\nbool 查询可以嵌套在另一个 bool 查询中，以构造更复杂的查询。要创建嵌套布尔查询，只需在 `must`、`should` 或 `must_not` 位置使用另一个 `bool`。以下查询：\n\nCODE_BLOCK_7\n\n应在 JSON 中表示为：\n\n<!-- request JSON -->\n\na = 2 and (a = 10 or b = 0)\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!-- example complex -->\n\n更复杂的查询：\n\nCODE_BLOCK_9\n\n<!-- request JSON -->\n\n(a = 1 and b = 1) or (a = 10 and b = 2) or (b = 0)\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n### SQL 格式的查询\n\n<!-- example query_string -->\n\nSQL 格式的查询（`query_string`）也可以用于 bool 查询。\n\n<!-- request JSON -->\n\nCODE_BLOCK_11\n\n<!-- end -->\n\n## 各种过滤器\n\n### 等值过滤器\n\n<!-- example equals -->\n\n等值过滤器是最简单的过滤器，适用于整数、浮点数和字符串属性。\n\n<!-- request JSON -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n<!-- example equals_any -->\n\n`equals` 过滤器可以应用于[多值属性](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29)，您可以使用：\n\n* `any()`，如果属性中至少有一个值等于查询值，则结果为正；\n\n* `all()`，如果属性只有一个值且等于查询值，则结果为正\n\n<!-- request JSON -->\n\nCODE_BLOCK_13\n\n<!-- end -->\n\n### 集合过滤器\n\n<!-- example set -->\n\n集合过滤器检查属性值是否等于指定集合中的任意值。\n\n集合过滤器支持整数、字符串和多值属性。\n\n<!-- request JSON -->\n\nCODE_BLOCK_14\n\n<!-- end -->\n\n<!-- example set_any -->\n\n应用于[多值属性](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29)时，您可以使用：\n\n* `any()`（等同于无函数），如果属性值与查询值之间至少有一个匹配，则结果为正；\n\n* `all()`，如果所有属性值都在查询集合中，则结果为正\n\n<!-- request JSON -->\n\nCODE_BLOCK_15\n\n<!-- end -->\n\n### 范围过滤器\n\n<!-- example range -->\n\n范围过滤器匹配属性值在指定范围内的文档。\n\n范围过滤器支持以下属性：\n\n* `gte`：大于或等于\n\n* `gt`：大于\n\n* `lte`：小于或等于\n\n* `lt`：小于\n\n<!-- request JSON -->\n\nCODE_BLOCK_16\n\n<!-- end -->\n\n### 地理距离过滤器\n\n<!-- example geo -->\n\n`geo_distance` 过滤器用于过滤距离某地理位置在特定距离范围内的文档。\n\n##### location_anchor\n\n指定定位点，单位为度。距离从此点计算。\n\n##### location_source\n\n指定包含纬度和经度的属性。\n\n##### distance_type",
      "russian": "# Фильтры\n\n## WHERE\n\n`WHERE` — это SQL-клауза, которая работает как для полнотекстового поиска, так и для дополнительной фильтрации. Доступны следующие операторы:\n\n* [Операторы сравнения](../Searching/Expressions.md#Comparison-operators) `<, >, <=, >=, =, <>, BETWEEN, IN, IS NULL`\n\n* [Булевы операторы](../Searching/Full_text_matching/Operators.md#Boolean-operators) `AND, OR, NOT`\n\nПоддерживается `MATCH('query')`, который соответствует [полнотекстовому запросу](../Searching/Full_text_matching/Operators.md).\n\nПоддерживается синтаксис условия `{col_name | expr_alias} [NOT] IN @uservar`. Обратитесь к синтаксису [SET](../Server_settings/Setting_variables_online.md#SET) для описания глобальных пользовательских переменных.\n\n## HTTP JSON\n\nЕсли вы предпочитаете интерфейс HTTP JSON, вы также можете применять фильтрацию. Это может показаться сложнее, чем SQL, но рекомендуется в случаях, когда нужно программно подготовить запрос, например, когда пользователь заполняет форму в вашем приложении.\n\n<!-- example json1 -->\n\nВот пример нескольких фильтров в запросе `bool`.\n\nЭтот полнотекстовый запрос находит все документы, содержащие `product` в любом поле. Эти документы должны иметь цену больше или равную 500 (`gte`) и меньше или равную 1000 (`lte`). Все эти документы не должны иметь ревизию меньше 15 (`lt`).\n\n<!-- request JSON -->\n\nCODE_BLOCK_0\n\n<!-- end -->\n\n### bool query\n\n<!-- example bool -->\n\nЗапрос `bool` находит документы на основе булевых комбинаций других запросов и/или фильтров. Запросы и фильтры должны быть указаны в секциях `must`, `should` или `must_not` и могут быть [вложенными](../Searching/Filters.md#Nested-bool-query).\n\n<!-- request JSON -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n<!-- example must_not -->\n\n### must\n\nЗапросы и фильтры, указанные в секции `must`, обязательны для совпадения с документами. Если указано несколько полнотекстовых запросов или фильтров, все они должны совпадать. Это эквивалент запросов с `AND` в SQL. Обратите внимание, что если вы хотите искать по массиву ([мультизначный атрибут](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29)), вы можете указать атрибут несколько раз. Результат будет положительным только если все запрошенные значения найдены в массиве, например:\n\nCODE_BLOCK_2\n\nТакже обратите внимание, что с точки зрения производительности может быть лучше использовать:\n\nCODE_BLOCK_3\n\n(подробнее ниже).\n\n### should\n\nЗапросы и фильтры, указанные в секции `should`, должны совпадать с документами. Если в `must` или `must_not` указаны какие-либо запросы, запросы из `should` игнорируются. С другой стороны, если кроме `should` нет других запросов, то хотя бы один из этих запросов должен совпасть с документом, чтобы он соответствовал запросу bool. Это эквивалент запросов с `OR`. Обратите внимание, если вы хотите искать по массиву ([мультизначный атрибут](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29)), вы можете указать атрибут несколько раз, например:\n\nCODE_BLOCK_4\n\nТакже обратите внимание, что с точки зрения производительности может быть лучше использовать:\n\nCODE_BLOCK_5\n\n(подробнее ниже).\n\n### must_not\n\nЗапросы и фильтры, указанные в секции `must_not`, не должны совпадать с документами. Если несколько запросов указаны в `must_not`, документ совпадает, если ни один из них не совпадает.\n\n<!-- request JSON -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n### Вложенный bool-запрос\n\n<!-- example eq_and_or -->\n\nЗапрос bool может быть вложен в другой bool, чтобы создавать более сложные запросы. Чтобы сделать вложенный булев запрос, просто используйте другой `bool` вместо `must`, `should` или `must_not`. Вот как этот запрос:\n\nCODE_BLOCK_7\n\nдолжен быть представлен в JSON.\n\n<!-- request JSON -->\n\na = 2 and (a = 10 or b = 0)\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!-- example complex -->\n\nБолее сложный запрос:\n\nCODE_BLOCK_9\n\n<!-- request JSON -->\n\n(a = 1 and b = 1) or (a = 10 and b = 2) or (b = 0)\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n### Запросы в формате SQL\n\n<!-- example query_string -->\n\nЗапросы в формате SQL (`query_string`) также могут использоваться в bool-запросах.\n\n<!-- request JSON -->\n\nCODE_BLOCK_11\n\n<!-- end -->\n\n## Различные фильтры\n\n### Фильтры равенства\n\n<!-- example equals -->\n\nФильтры равенства — самые простые фильтры, которые работают с целочисленными, числовыми и строковыми атрибутами.\n\n<!-- request JSON -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n<!-- example equals_any -->\n\nФильтр `equals` может применяться к [мультизначному атрибуту](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29), и вы можете использовать:\n\n* `any()`, который будет положительным, если атрибут содержит хотя бы одно значение, равное запрошенному;\n\n* `all()`, который будет положительным, если атрибут содержит одно значение и оно равно запрошенному\n\n<!-- request JSON -->\n\nCODE_BLOCK_13\n\n<!-- end -->\n\n### Фильтры множества\n\n<!-- example set -->\n\nФильтры множества проверяют, равен ли атрибут любому из значений в указанном наборе.\n\nФильтры множества поддерживают целочисленные, строковые и мультизначные атрибуты.\n\n<!-- request JSON -->\n\nCODE_BLOCK_14\n\n<!-- end -->\n\n<!-- example set_any -->\n\nПри применении к [мультизначному атрибуту](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29) вы можете использовать:\n\n* `any()` (эквивалент отсутствия функции), который будет положительным, если есть хотя бы одно совпадение между значениями атрибута и запрошенными значениями;\n\n* `all()`, который будет положительным, если все значения атрибута находятся в запрошенном наборе\n\n<!-- request JSON -->\n\nCODE_BLOCK_15\n\n<!-- end -->\n\n### Фильтры диапазона\n\n<!-- example range -->\n\nФильтры диапазона находят документы, у которых значения атрибута находятся в указанном диапазоне.\n\nФильтры диапазона поддерживают следующие свойства:\n\n* `gte`: больше или равно\n\n* `gt`: больше\n\n* `lte`: меньше или равно\n\n* `lt`: меньше\n\n<!-- request JSON -->\n\nCODE_BLOCK_16\n\n<!-- end -->\n\n### Фильтры гео-расстояния\n\n<!-- example geo -->\n\nФильтры `geo_distance` используются для фильтрации документов, которые находятся в пределах определённого расстояния от географической точки.\n\n##### location_anchor\n\nУказывает местоположение точки, в градусах. Расстояния вычисляются от этой точки.\n\n##### location_source\n\nУказывает атрибуты, содержащие широту и долготу.\n\n##### distance_type"
    },
    "is_code_or_comment": false
  }
}
