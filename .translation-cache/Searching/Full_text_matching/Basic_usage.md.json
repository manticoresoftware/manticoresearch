{
  "4100f0f8af94228041bb417f06f7a2a12d047551bdc826aba6a7cf5a2275c31b": {
    "original": "# MATCH\n\nThe `MATCH` clause allows for full-text searches in text fields. The input query string is [tokenized](../../Creating_a_table/NLP_and_tokenization/Data_tokenization.md) using the same settings applied to the text during indexing. In addition to the tokenization of input text, the query string supports a number of [full-text operators](../../Searching/Full_text_matching/Operators.md) that enforce various rules on how keywords should provide a valid match.\n\nFull-text match clauses can be combined with attribute [filters](../../Searching/Filters.md) as an AND boolean. **OR relations between full-text matches and attribute filters are not supported**.\n\nThe match query is always executed first in the filtering process, followed by the [attribute filters](../../Searching/Filters.md). The attribute filters are applied to the result set of the match query. A query without a match clause is called a fullscan.\n\nThere must be at most one `MATCH()` in the `SELECT` clause.\n\nUsing the [full-text query syntax](../../Searching/Full_text_matching/Operators.md), matching is performed across all indexed text fields of a document, unless the expression requires a match within a field (like phrase search) or is limited by field operators.\n\nWhen using [JOIN](../../Searching/Joining.md) queries, `MATCH()` can accept an optional second parameter that specifies which table the full-text search should be applied to. By default, the full-text query is applied to the left table in the `JOIN` operation:\n\nCODE_BLOCK_0\n\nThis allows you to perform full-text searches on specific tables in a join operation. For more details on using MATCH with JOINs, see the [Joining tables](../../Searching/Joining.md) section.\n\n## SQL\n\n<!-- example Example_1 -->\n\nCODE_BLOCK_1\n\n- `'search query'`: The full-text search query string, which can include various [full-text operators](../../Searching/Full_text_matching/Operators.md).\n\n- `table_name`: (Optional) The name of the table to apply the full-text search to, used in `JOIN` queries to specify a different table than the default left table.\n\nThe [SELECT](../../Searching/Full_text_matching/Basic_usage.md#SQL) statement uses a [MATCH](../../Searching/Full_text_matching/Basic_usage.md) clause, which must come after WHERE, for performing full-text searches. `MATCH()` accepts an input string in which all [full-text operators](../../Searching/Full_text_matching/Operators.md) are available.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- request MATCH with filters -->\n\nAn example of a more complex query using MATCH with WHERE filters.\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n## HTTP JSON\n\n<!-- example Example_11 -->\n\nFull-text matching is available in the `/search` endpoint and in HTTP-based clients. The following clauses can be used for performing full-text matches:\n\n### match\n\n\"match\" is a simple query that matches the specified keywords in the specified fields.\n\nCODE_BLOCK_5\n\nYou can specify a list of fields:\n\nCODE_BLOCK_6\n\nOr you can use `_all` or `*` to search all fields.\n\nYou can search all fields except one using \"!field\":\n\nCODE_BLOCK_7\n\nBy default, keywords are combined using the OR operator. However, you can change that behavior using the \"operator\" clause:\n\nCODE_BLOCK_8\n\n\"operator\" can be set to \"or\" or \"and\".\n\nThe `boost` modifier can also be applied. It raises the word [IDF](../../Searching/Options.md#idf)_score by the indicated factor in ranking scores that incorporate IDF into their calculations. It does not impact the matching process in any manner.\n\nCODE_BLOCK_9\n\n### match_phrase\n\n\"match_phrase\" is a query that matches the entire phrase. It is similar to a phrase operator in SQL. Here's an example:\n\nCODE_BLOCK_10\n\n### query_string\n\n\"query_string\" accepts an input string as a full-text query in `MATCH()` syntax.\n\nCODE_BLOCK_11\n\n### match_all\n\n\"match_all\" accepts an empty object and returns documents from the table without performing any attribute filtering or full-text matching. Alternatively, you can just omit the `query` clause in the request which will have the same effect.\n\nCODE_BLOCK_12\n\n### Combining full-text filtering with other filters\n\nAll full-text match clauses can be combined with [must](../../Searching/Filters.md#must), [must_not](../../Searching/Filters.md#must_not), and [should](../../Searching/Filters.md#should) operators of a [JSON `bool` query](../../Searching/Filters.md#bool-query).\n\n<!-- intro -->\n\nExamples:\n\n<!-- request match -->\n\nCODE_BLOCK_13\n\n<!-- response match -->\n\nCODE_BLOCK_14\n\n<!-- request match_phrase -->\n\nCODE_BLOCK_15\n\n<!-- response match_phrase -->\n\nCODE_BLOCK_16\n\n<!-- request query_string -->\n\nCODE_BLOCK_17\n\n<!-- response query_string -->\n\nCODE_BLOCK_18\n\n<!-- request PHP -->\n\nCODE_BLOCK_19\n\n<!-- response PHP -->\n\nCODE_BLOCK_20\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_21\n\n<!-- response Python -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_23\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_24\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_25\n\n<!-- response javascript -->\n\nCODE_BLOCK_26\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_27\n\n<!-- response Java -->\n\nCODE_BLOCK_28\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_29\n\n<!-- response C# -->\n\nCODE_BLOCK_30\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_31\n\n<!-- response Rust -->\n\nCODE_BLOCK_32\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_33\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_34\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_35\n\n<!-- response Go -->\n\nCODE_BLOCK_36\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# MATCH\n\n`MATCH` 子句允许在文本字段中进行全文搜索。输入的查询字符串会使用与索引时应用于文本的相同设置进行[分词](../../Creating_a_table/NLP_and_tokenization/Data_tokenization.md)。除了对输入文本的分词外，查询字符串还支持多种[全文操作符](../../Searching/Full_text_matching/Operators.md)，这些操作符对关键词如何提供有效匹配施加各种规则。\n\n全文匹配子句可以与属性[过滤器](../../Searching/Filters.md)以 AND 布尔关系组合。**不支持全文匹配与属性过滤器之间的 OR 关系**。\n\n匹配查询总是在过滤过程的第一步执行，随后是[属性过滤器](../../Searching/Filters.md)。属性过滤器应用于匹配查询的结果集。没有匹配子句的查询称为全表扫描。\n\n`SELECT` 子句中最多只能有一个 `MATCH()`。\n\n使用[全文查询语法](../../Searching/Full_text_matching/Operators.md)时，匹配会在文档的所有已索引文本字段中执行，除非表达式要求在某个字段内匹配（如短语搜索）或被字段操作符限制。\n\n在使用[JOIN](../../Searching/Joining.md)查询时，`MATCH()` 可以接受一个可选的第二个参数，指定全文搜索应应用于哪个表。默认情况下，全文查询应用于 `JOIN` 操作中的左表：\n\nCODE_BLOCK_0\n\n这允许你在连接操作中对特定表执行全文搜索。有关使用 MATCH 与 JOIN 的更多详细信息，请参见[连接表](../../Searching/Joining.md)部分。\n\n## SQL\n\n<!-- example Example_1 -->\n\nCODE_BLOCK_1\n\n- `'search query'`：全文搜索查询字符串，可以包含各种[全文操作符](../../Searching/Full_text_matching/Operators.md)。\n\n- `table_name`：（可选）应用全文搜索的表名，在 `JOIN` 查询中用于指定不同于默认左表的表。\n\n[SELECT](../../Searching/Full_text_matching/Basic_usage.md#SQL) 语句使用 [MATCH](../../Searching/Full_text_matching/Basic_usage.md) 子句，必须位于 WHERE 之后，用于执行全文搜索。`MATCH()` 接受一个输入字符串，其中所有[全文操作符](../../Searching/Full_text_matching/Operators.md)均可用。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- request MATCH with filters -->\n\n使用 MATCH 和 WHERE 过滤器的更复杂查询示例。\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n## HTTP JSON\n\n<!-- example Example_11 -->\n\n全文匹配可在 `/search` 端点和基于 HTTP 的客户端中使用。以下子句可用于执行全文匹配：\n\n### match\n\n\"match\" 是一个简单查询，在指定字段中匹配指定的关键词。\n\nCODE_BLOCK_5\n\n你可以指定字段列表：\n\nCODE_BLOCK_6\n\n或者你可以使用 `_all` 或 `*` 来搜索所有字段。\n\n你可以使用 \"!field\" 搜索除某个字段外的所有字段：\n\nCODE_BLOCK_7\n\n默认情况下，关键词使用 OR 操作符组合。但是，你可以使用 \"operator\" 子句更改此行为：\n\nCODE_BLOCK_8\n\n\"operator\" 可以设置为 \"or\" 或 \"and\"。\n\n还可以应用 `boost` 修饰符。它通过指定的因子提升词的[IDF](../../Searching/Options.md#idf)_分数，在包含 IDF 计算的排名分数中提高权重。它不会以任何方式影响匹配过程。\n\nCODE_BLOCK_9\n\n### match_phrase\n\n\"match_phrase\" 是一个匹配整个短语的查询。它类似于 SQL 中的短语操作符。示例如下：\n\nCODE_BLOCK_10\n\n### query_string\n\n\"query_string\" 接受一个输入字符串，作为 `MATCH()` 语法的全文查询。\n\nCODE_BLOCK_11\n\n### match_all\n\n\"match_all\" 接受一个空对象，返回表中的文档，而不执行任何属性过滤或全文匹配。或者，你也可以在请求中省略 `query` 子句，效果相同。\n\nCODE_BLOCK_12\n\n### 将全文过滤与其他过滤器结合使用\n\n所有全文匹配子句都可以与[必须](../../Searching/Filters.md#must)、[必须不](../../Searching/Filters.md#must_not)和[应该](../../Searching/Filters.md#should)操作符结合使用，构成[JSON `bool` 查询](../../Searching/Filters.md#bool-query)。\n\n<!-- intro -->\n\n示例：\n\n<!-- request match -->\n\nCODE_BLOCK_13\n\n<!-- response match -->\n\nCODE_BLOCK_14\n\n<!-- request match_phrase -->\n\nCODE_BLOCK_15\n\n<!-- response match_phrase -->\n\nCODE_BLOCK_16\n\n<!-- request query_string -->\n\nCODE_BLOCK_17\n\n<!-- response query_string -->\n\nCODE_BLOCK_18\n\n<!-- request PHP -->\n\nCODE_BLOCK_19\n\n<!-- response PHP -->\n\nCODE_BLOCK_20\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_21\n\n<!-- response Python -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_23\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_24\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_25\n\n<!-- response javascript -->\n\nCODE_BLOCK_26\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_27\n\n<!-- response Java -->\n\nCODE_BLOCK_28\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_29\n\n<!-- response C# -->\n\nCODE_BLOCK_30\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_31\n\n<!-- response Rust -->\n\nCODE_BLOCK_32\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_33\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_34\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_35\n\n<!-- response Go -->\n\nCODE_BLOCK_36\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "# MATCH\n\nКлауза `MATCH` позволяет выполнять полнотекстовый поиск в текстовых полях. Входная строка запроса [токенизируется](../../Creating_a_table/NLP_and_tokenization/Data_tokenization.md) с использованием тех же настроек, которые применялись к тексту при индексировании. Помимо токенизации входного текста, строка запроса поддерживает ряд [операторов полнотекстового поиска](../../Searching/Full_text_matching/Operators.md), которые задают различные правила того, как ключевые слова должны обеспечивать валидное совпадение.\n\nКлаузы полнотекстового поиска могут комбинироваться с атрибутными [фильтрами](../../Searching/Filters.md) как логическое И. **Логические ИЛИ между полнотекстовыми совпадениями и атрибутными фильтрами не поддерживаются**.\n\nЗапрос с match всегда выполняется первым в процессе фильтрации, за ним следуют [атрибутные фильтры](../../Searching/Filters.md). Атрибутные фильтры применяются к результату запроса match. Запрос без клаузы match называется fullscan.\n\nВ `SELECT` должно быть не более одного `MATCH()`.\n\nИспользуя [синтаксис полнотекстового запроса](../../Searching/Full_text_matching/Operators.md), поиск выполняется по всем индексированным текстовым полям документа, если выражение не требует совпадения внутри поля (например, поиск фразы) или не ограничено операторами поля.\n\nПри использовании запросов с [JOIN](../../Searching/Joining.md), `MATCH()` может принимать необязательный второй параметр, который указывает, к какой таблице должен применяться полнотекстовый поиск. По умолчанию полнотекстовый запрос применяется к левой таблице в операции `JOIN`:\n\nCODE_BLOCK_0\n\nЭто позволяет выполнять полнотекстовый поиск по конкретным таблицам в операции соединения. Для получения дополнительной информации о использовании MATCH с JOIN смотрите раздел [Joining tables](../../Searching/Joining.md).\n\n## SQL\n\n<!-- example Example_1 -->\n\nCODE_BLOCK_1\n\n- `'search query'`: Строка полнотекстового поискового запроса, которая может включать различные [операторы полнотекстового поиска](../../Searching/Full_text_matching/Operators.md).\n\n- `table_name`: (Опционально) Имя таблицы, к которой применяется полнотекстовый поиск, используется в запросах с `JOIN` для указания таблицы, отличной от левой по умолчанию.\n\nОператор [SELECT](../../Searching/Full_text_matching/Basic_usage.md#SQL) использует клаузу [MATCH](../../Searching/Full_text_matching/Basic_usage.md), которая должна идти после WHERE, для выполнения полнотекстового поиска. `MATCH()` принимает входную строку, в которой доступны все [операторы полнотекстового поиска](../../Searching/Full_text_matching/Operators.md).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- request MATCH with filters -->\n\nПример более сложного запроса с использованием MATCH и фильтров WHERE.\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n## HTTP JSON\n\n<!-- example Example_11 -->\n\nПолнотекстовый поиск доступен в эндпоинте `/search` и в HTTP-клиентах. Для выполнения полнотекстового поиска можно использовать следующие клаузы:\n\n### match\n\n\"match\" — это простой запрос, который ищет указанные ключевые слова в указанных полях.\n\nCODE_BLOCK_5\n\nВы можете указать список полей:\n\nCODE_BLOCK_6\n\nИли использовать `_all` или `*` для поиска по всем полям.\n\nВы можете искать по всем полям, кроме одного, используя \"!field\":\n\nCODE_BLOCK_7\n\nПо умолчанию ключевые слова объединяются оператором OR. Однако вы можете изменить это поведение с помощью клаузы \"operator\":\n\nCODE_BLOCK_8\n\n\"operator\" может быть установлен в \"or\" или \"and\".\n\nТакже можно применить модификатор `boost`. Он повышает значение [IDF](../../Searching/Options.md#idf)_score слова на указанный коэффициент в рейтинговых оценках, которые учитывают IDF в своих вычислениях. Это не влияет на процесс сопоставления.\n\nCODE_BLOCK_9\n\n### match_phrase\n\n\"match_phrase\" — это запрос, который ищет полную фразу. Он похож на оператор фразы в SQL. Пример:\n\nCODE_BLOCK_10\n\n### query_string\n\n\"query_string\" принимает входную строку в синтаксисе `MATCH()` для полнотекстового запроса.\n\nCODE_BLOCK_11\n\n### match_all\n\n\"match_all\" принимает пустой объект и возвращает документы из таблицы без применения атрибутных фильтров или полнотекстового поиска. Альтернативно, можно просто опустить клаузу `query` в запросе, что даст тот же эффект.\n\nCODE_BLOCK_12\n\n### Комбинирование полнотекстовой фильтрации с другими фильтрами\n\nВсе клаузы полнотекстового поиска могут комбинироваться с операторами [must](../../Searching/Filters.md#must), [must_not](../../Searching/Filters.md#must_not) и [should](../../Searching/Filters.md#should) в [JSON `bool` запросе](../../Searching/Filters.md#bool-query).\n\n<!-- intro -->\n\nПримеры:\n\n<!-- request match -->\n\nCODE_BLOCK_13\n\n<!-- response match -->\n\nCODE_BLOCK_14\n\n<!-- request match_phrase -->\n\nCODE_BLOCK_15\n\n<!-- response match_phrase -->\n\nCODE_BLOCK_16\n\n<!-- request query_string -->\n\nCODE_BLOCK_17\n\n<!-- response query_string -->\n\nCODE_BLOCK_18\n\n<!-- request PHP -->\n\nCODE_BLOCK_19\n\n<!-- response PHP -->\n\nCODE_BLOCK_20\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_21\n\n<!-- response Python -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_23\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_24\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_25\n\n<!-- response javascript -->\n\nCODE_BLOCK_26\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_27\n\n<!-- response Java -->\n\nCODE_BLOCK_28\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_29\n\n<!-- response C# -->\n\nCODE_BLOCK_30\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_31\n\n<!-- response Rust -->\n\nCODE_BLOCK_32\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_33\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_34\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_35\n\n<!-- response Go -->\n\nCODE_BLOCK_36\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "2528e83375155b45ae3784a042bd3d64d27e9be7eb26b59e614781a90d2cc75b": {
    "original": "# MATCH\n\nThe `MATCH` clause allows for full-text searches in text fields. The input query string is [tokenized](../../Creating_a_table/NLP_and_tokenization/Data_tokenization.md) using the same settings applied to the text during indexing. In addition to the tokenization of input text, the query string supports a number of [full-text operators](../../Searching/Full_text_matching/Operators.md) that enforce various rules on how keywords should provide a valid match.\n\nFull-text match clauses can be combined with attribute [filters](../../Searching/Filters.md) as an AND boolean. **OR relations between full-text matches and attribute filters are not supported**.\n\nThe match query is always executed first in the filtering process, followed by the [attribute filters](../../Searching/Filters.md). The attribute filters are applied to the result set of the match query. A query without a match clause is called a fullscan.\n\nThere must be at most one `MATCH()` in the `SELECT` clause.\n\nUsing the [full-text query syntax](../../Searching/Full_text_matching/Operators.md), matching is performed across all indexed text fields of a document, unless the expression requires a match within a field (like phrase search) or is limited by field operators.\n\nWhen using [JOIN](../../Searching/Joining.md) queries, `MATCH()` can accept an optional second parameter that specifies which table the full-text search should be applied to. By default, the full-text query is applied to the left table in the `JOIN` operation:\n\nCODE_BLOCK_0\n\nThis allows you to perform full-text searches on specific tables in a join operation. For more details on using MATCH with JOINs, see the [Joining tables](../../Searching/Joining.md) section.\n\n## SQL\n\n<!-- example Example_1 -->\n\nCODE_BLOCK_1\n\n- `'search query'`: The full-text search query string, which can include various [full-text operators](../../Searching/Full_text_matching/Operators.md).\n\n- `table_name`: (Optional) The name of the table to apply the full-text search to, used in `JOIN` queries to specify a different table than the default left table.\n\nThe [SELECT](../../Searching/Full_text_matching/Basic_usage.md#SQL) statement uses a [MATCH](../../Searching/Full_text_matching/Basic_usage.md) clause, which must come after WHERE, for performing full-text searches. `MATCH()` accepts an input string in which all [full-text operators](../../Searching/Full_text_matching/Operators.md) are available.\n\n<!-- intro -->\n\n##### SQL:\n\n<!--\n\ndata for the following example:\n\nDROP TABLE IF EXISTS myindex;\n\nCREATE TABLE myindex(gid int, title text);\n\nINSERT INTO myindex(gid, title) VALUES\n\n(11, 'first find me'),\n\n(12, 'second find me');\n\n-->\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- request JSON -->\n\nCODE_BLOCK_4\n\n<!-- response JSON -->\n\nCODE_BLOCK_5\n\n<!-- request MATCH with filters -->\n\nAn example of a more complex query using MATCH with WHERE filters.\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n## HTTP JSON\n\n<!-- example Example_11 -->\n\nFull-text matching is available in the `/search` endpoint and in HTTP-based clients. The following clauses can be used for performing full-text matches:\n\n### match\n\n\"match\" is a simple query that matches the specified keywords in the specified fields.\n\nCODE_BLOCK_7\n\nYou can specify a list of fields:\n\nCODE_BLOCK_8\n\nOr you can use `_all` or `*` to search all fields.\n\nYou can search all fields except one using \"!field\":\n\nCODE_BLOCK_9\n\nBy default, keywords are combined using the OR operator. However, you can change that behavior using the \"operator\" clause:\n\nCODE_BLOCK_10\n\n\"operator\" can be set to \"or\" or \"and\".\n\nThe `boost` modifier can also be applied. It raises the word [IDF](../../Searching/Options.md#idf)_score by the indicated factor in ranking scores that incorporate IDF into their calculations. It does not impact the matching process in any manner.\n\nCODE_BLOCK_11\n\n### match_phrase\n\n\"match_phrase\" is a query that matches the entire phrase. It is similar to a phrase operator in SQL. Here's an example:\n\nCODE_BLOCK_12\n\n### query_string\n\n\"query_string\" accepts an input string as a full-text query in `MATCH()` syntax.\n\nCODE_BLOCK_13\n\n### match_all\n\n\"match_all\" accepts an empty object and returns documents from the table without performing any attribute filtering or full-text matching. Alternatively, you can just omit the `query` clause in the request which will have the same effect.\n\nCODE_BLOCK_14\n\n### Combining full-text filtering with other filters\n\nAll full-text match clauses can be combined with [must](../../Searching/Filters.md#must), [must_not](../../Searching/Filters.md#must_not), and [should](../../Searching/Filters.md#should) operators of a [JSON `bool` query](../../Searching/Filters.md#bool-query).\n\n<!-- intro -->\n\nExamples:\n\n<!-- request match -->\n\nCODE_BLOCK_15\n\n<!-- response match -->\n\nCODE_BLOCK_16\n\n<!-- request match_phrase -->\n\nCODE_BLOCK_17\n\n<!-- response match_phrase -->\n\nCODE_BLOCK_18\n\n<!-- request query_string -->\n\nCODE_BLOCK_19\n\n<!-- response query_string -->\n\nCODE_BLOCK_20\n\n<!-- request PHP -->\n\nCODE_BLOCK_21\n\n<!-- response PHP -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_23\n\n<!-- response Python -->\n\nCODE_BLOCK_24\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_25\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_26\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_27\n\n<!-- response javascript -->\n\nCODE_BLOCK_28\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_29\n\n<!-- response Java -->\n\nCODE_BLOCK_30\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_31\n\n<!-- response C# -->\n\nCODE_BLOCK_32\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_33\n\n<!-- response Rust -->\n\nCODE_BLOCK_34\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_35\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_36\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_37\n\n<!-- response Go -->\n\nCODE_BLOCK_38\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# MATCH\n\n`MATCH` 子句允许在文本字段中进行全文搜索。输入的查询字符串使用与文本索引时相同的设置进行[分词](../../Creating_a_table/NLP_and_tokenization/Data_tokenization.md)。除了对输入文本进行分词，查询字符串还支持多种[全文操作符](../../Searching/Full_text_matching/Operators.md)，这些操作符规定了关键字如何提供有效匹配的各种规则。\n\n全文匹配子句可以与属性[过滤器](../../Searching/Filters.md)组合为 AND 布尔关系。**全文匹配与属性过滤器之间不支持 OR 关系**。\n\n匹配查询始终在过滤过程中首先执行，随后应用[属性过滤器](../../Searching/Filters.md)。属性过滤器作用于匹配查询的结果集。没有 match 子句的查询称为全扫描。\n\n`SELECT` 子句中最多只能有一个 `MATCH()`。\n\n使用[全文查询语法](../../Searching/Full_text_matching/Operators.md)时，匹配在文档的所有已索引文本字段上执行，除非表达式要求在某个字段内匹配（如短语搜索）或受字段操作符限制。\n\n在使用[JOIN](../../Searching/Joining.md) 查询时，`MATCH()` 可接受一个可选的第二参数，指定全文搜索应应用于哪个表。默认情况下，全文查询应用于 `JOIN` 操作中的左表：\n\nCODE_BLOCK_0\n\n这使您能够对连接操作中的特定表执行全文搜索。有关使用 MATCH 与 JOIN 的详细信息，请参阅[表连接](../../Searching/Joining.md)部分。\n\n## SQL\n\n<!-- example Example_1 -->\n\nCODE_BLOCK_1\n\n- `'search query'`：全文搜索查询字符串，可以包含各种[全文操作符](../../Searching/Full_text_matching/Operators.md)。\n\n- `table_name`：（可选）全文搜索应用的表名，用于 `JOIN` 查询中指定不同于默认左表的表。\n\n[SELECT](../../Searching/Full_text_matching/Basic_usage.md#SQL) 语句使用 [MATCH](../../Searching/Full_text_matching/Basic_usage.md) 子句，该子句必须出现在 WHERE 之后，用于进行全文搜索。`MATCH()` 接受一个输入字符串，所有[全文操作符](../../Searching/Full_text_matching/Operators.md)均可用。\n\n<!-- intro -->\n\n##### SQL:\n\n<!--\n\ndata for the following example:\n\nDROP TABLE IF EXISTS myindex;\n\nCREATE TABLE myindex(gid int, title text);\n\nINSERT INTO myindex(gid, title) VALUES\n\n(11, 'first find me'),\n\n(12, 'second find me');\n\n-->\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- request JSON -->\n\nCODE_BLOCK_4\n\n<!-- response JSON -->\n\nCODE_BLOCK_5\n\n<!-- request MATCH with filters -->\n\n使用 MATCH 和 WHERE 过滤器的更复杂查询示例。\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n## HTTP JSON\n\n<!-- example Example_11 -->\n\n全文匹配可通过 `/search` 端点和基于 HTTP 的客户端实现。可以使用以下子句执行全文匹配：\n\n### match\n\n\"match\" 是一个简单的查询，用于匹配指定字段中的指定关键字。\n\nCODE_BLOCK_7\n\n您可以指定字段列表：\n\nCODE_BLOCK_8\n\n或者使用 `_all` 或 `*` 搜索所有字段。\n\n您可以搜索除某个字段外的所有字段，使用 \"!field\"：\n\nCODE_BLOCK_9\n\n默认情况下，关键字使用 OR 操作符合并。您可以使用 \"operator\" 子句更改此行为：\n\nCODE_BLOCK_10\n\n\"operator\" 可设置为 \"or\" 或 \"and\"。\n\n还可以应用 `boost` 修饰符。它将词的 [IDF](../../Searching/Options.md#idf) _得分按指示的因子提高，在包含 IDF 计算的排名评分中调整权重，但不影响匹配过程。\n\nCODE_BLOCK_11\n\n### match_phrase\n\n\"match_phrase\" 是匹配整个短语的查询，类似于 SQL 中的短语操作符。示例如下：\n\nCODE_BLOCK_12\n\n### query_string\n\n\"query_string\" 接受输入字符串，作为 `MATCH()` 语法的全文查询。\n\nCODE_BLOCK_13\n\n### match_all\n\n\"match_all\" 接受一个空对象，返回表中的所有文档，不执行任何属性过滤或全文匹配。或者您可以在请求中完全省略 `query` 子句，效果相同。\n\nCODE_BLOCK_14\n\n### 结合全文过滤与其他过滤器\n\n所有全文匹配子句都可以与 [must](../../Searching/Filters.md#must)、[must_not](../../Searching/Filters.md#must_not) 和 [should](../../Searching/Filters.md#should) 操作符结合，使用 [JSON `bool` 查询](../../Searching/Filters.md#bool-query)。\n\n<!-- intro -->\n\n示例：\n\n<!-- request match -->\n\nCODE_BLOCK_15\n\n<!-- response match -->\n\nCODE_BLOCK_16\n\n<!-- request match_phrase -->\n\nCODE_BLOCK_17\n\n<!-- response match_phrase -->\n\nCODE_BLOCK_18\n\n<!-- request query_string -->\n\nCODE_BLOCK_19\n\n<!-- response query_string -->\n\nCODE_BLOCK_20\n\n<!-- request PHP -->\n\nCODE_BLOCK_21\n\n<!-- response PHP -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_23\n\n<!-- response Python -->\n\nCODE_BLOCK_24\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_25\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_26\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_27\n\n<!-- response javascript -->\n\nCODE_BLOCK_28\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_29\n\n<!-- response Java -->\n\nCODE_BLOCK_30\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_31\n\n<!-- response C# -->\n\nCODE_BLOCK_32\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_33\n\n<!-- response Rust -->\n\nCODE_BLOCK_34\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_35\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_36\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_37\n\n<!-- response Go -->\n\nCODE_BLOCK_38\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "# MATCH\n\nКлауза `MATCH` позволяет выполнять полнотекстовый поиск в текстовых полях. Входящая строка запроса [токенизируется](../../Creating_a_table/NLP_and_tokenization/Data_tokenization.md) с использованием тех же настроек, что применяются к тексту при индексировании. Помимо токенизации входного текста, строка запроса поддерживает ряд [операторов полнотекстового поиска](../../Searching/Full_text_matching/Operators.md), которые задают различные правила того, как ключевые слова должны обеспечивать валидное совпадение.\n\nКлаузы полнотекстового поиска могут комбинироваться с [фильтрами атрибутов](../../Searching/Filters.md) через булев оператор AND. **Отношения OR между полнотекстовыми поисками и фильтрами атрибутов не поддерживаются**.\n\nЗапрос match всегда выполняется первым в процессе фильтрации, за ним следуют [фильтры атрибутов](../../Searching/Filters.md). Фильтры атрибутов применяются к результирующему набору от запроса match. Запрос без клаузы match называется fullscan.\n\nВ `SELECT` должно быть не более одного вызова `MATCH()`.\n\nИспользуя [синтаксис полнотекстового запроса](../../Searching/Full_text_matching/Operators.md), поиск выполняется по всем индексированным текстовым полям документа, если только выражение не требует совпадения в конкретном поле (например, поиск фраз) или не ограничено операторами поля.\n\nПри использовании [JOIN](../../Searching/Joining.md) запросов, `MATCH()` может принимать необязательный второй параметр, указывающий, к какой таблице следует применить полнотекстовый поиск. По умолчанию полнотекстовый запрос применяется к левой таблице в операции JOIN:\n\nCODE_BLOCK_0\n\nЭто позволяет выполнять полнотекстовый поиск по конкретным таблицам в операции объединения. Для подробностей использования MATCH с JOIN смотрите раздел [Объединение таблиц](../../Searching/Joining.md).\n\n## SQL\n\n<!-- example Example_1 -->\n\nCODE_BLOCK_1\n\n- `'search query'`: строка полнотекстового поискового запроса, которая может включать различные [операторы полнотекстового поиска](../../Searching/Full_text_matching/Operators.md).\n\n- `table_name`: (необязательно) имя таблицы, к которой применять полнотекстовый поиск, используется в JOIN запросах для указания другой таблицы вместо таблицы по умолчанию слева.\n\nВыражение [SELECT](../../Searching/Full_text_matching/Basic_usage.md#SQL) использует клауза [MATCH](../../Searching/Full_text_matching/Basic_usage.md), которая должна идти после WHERE и используется для полнотекстового поиска. `MATCH()` принимает входную строку, в которой доступны все [операторы полнотекстового поиска](../../Searching/Full_text_matching/Operators.md).\n\n<!-- intro -->\n\n##### SQL:\n\n<!--\n\ndata for the following example:\n\nDROP TABLE IF EXISTS myindex;\n\nCREATE TABLE myindex(gid int, title text);\n\nINSERT INTO myindex(gid, title) VALUES\n\n(11, 'first find me'),\n\n(12, 'second find me');\n\n-->\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- request JSON -->\n\nCODE_BLOCK_4\n\n<!-- response JSON -->\n\nCODE_BLOCK_5\n\n<!-- request MATCH with filters -->\n\nПример более сложного запроса с использованием MATCH вместе с фильтрами WHERE.\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n## HTTP JSON\n\n<!-- example Example_11 -->\n\nПолнотекстовый поиск доступен на эндпоинте `/search` и в HTTP-клиентах. Для выполнения полнотекстового поиска можно использовать следующие клаузы:\n\n### match\n\n\"match\" — это простой запрос, который ищет указанные ключевые слова в указанных полях.\n\nCODE_BLOCK_7\n\nМожно указать список полей:\n\nCODE_BLOCK_8\n\nИли можно использовать `_all` или `*` для поиска по всем полям.\n\nМожно выполнить поиск по всем полям, кроме одного, используя \"!field\":\n\nCODE_BLOCK_9\n\nПо умолчанию ключевые слова объединяются оператором OR. Однако можно изменить это поведение, используя параметр \"operator\":\n\nCODE_BLOCK_10\n\n\"operator\" может принимать значения \"or\" или \"and\".\n\nТакже может применяться модификатор `boost`. Он увеличивает значение [IDF](../../Searching/Options.md#idf)_скоринга слова на указанный коэффициент в рейтинговых оценках, где используется IDF. Это не влияет на процесс совпадения.\n\nCODE_BLOCK_11\n\n### match_phrase\n\n\"match_phrase\" — это запрос, который ищет полную фразу. Он похож на оператор фразы в SQL. Пример:\n\nCODE_BLOCK_12\n\n### query_string\n\n\"query_string\" принимает входную строку в синтаксисе `MATCH()` для полнотекстового запроса.\n\nCODE_BLOCK_13\n\n### match_all\n\n\"match_all\" принимает пустой объект и возвращает документы из таблицы без применения фильтров атрибутов или полнотекстового поиска. Альтернативно можно просто опустить клауза `query` в запросе — эффект будет тот же.\n\nCODE_BLOCK_14\n\n### Комбинирование полнотекстовой фильтрации с другими фильтрами\n\nВсе клаузы полнотекстового поиска можно комбинировать с операторами [must](../../Searching/Filters.md#must), [must_not](../../Searching/Filters.md#must_not) и [should](../../Searching/Filters.md#should) JSON-запроса типа `bool` ([bool query](../../Searching/Filters.md#bool-query)).\n\n<!-- intro -->\n\nПримеры:\n\n<!-- request match -->\n\nCODE_BLOCK_15\n\n<!-- response match -->\n\nCODE_BLOCK_16\n\n<!-- request match_phrase -->\n\nCODE_BLOCK_17\n\n<!-- response match_phrase -->\n\nCODE_BLOCK_18\n\n<!-- request query_string -->\n\nCODE_BLOCK_19\n\n<!-- response query_string -->\n\nCODE_BLOCK_20\n\n<!-- request PHP -->\n\nCODE_BLOCK_21\n\n<!-- response PHP -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_23\n\n<!-- response Python -->\n\nCODE_BLOCK_24\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_25\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_26\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_27\n\n<!-- response javascript -->\n\nCODE_BLOCK_28\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_29\n\n<!-- response Java -->\n\nCODE_BLOCK_30\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_31\n\n<!-- response C# -->\n\nCODE_BLOCK_32\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_33\n\n<!-- response Rust -->\n\nCODE_BLOCK_34\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_35\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_36\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_37\n\n<!-- response Go -->\n\nCODE_BLOCK_38\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
