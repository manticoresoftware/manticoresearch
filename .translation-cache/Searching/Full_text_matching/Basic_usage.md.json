{
  "4100f0f8af94228041bb417f06f7a2a12d047551bdc826aba6a7cf5a2275c31b": {
    "original": "# MATCH\n\nThe `MATCH` clause allows for full-text searches in text fields. The input query string is [tokenized](../../Creating_a_table/NLP_and_tokenization/Data_tokenization.md) using the same settings applied to the text during indexing. In addition to the tokenization of input text, the query string supports a number of [full-text operators](../../Searching/Full_text_matching/Operators.md) that enforce various rules on how keywords should provide a valid match.\n\nFull-text match clauses can be combined with attribute [filters](../../Searching/Filters.md) as an AND boolean. **OR relations between full-text matches and attribute filters are not supported**.\n\nThe match query is always executed first in the filtering process, followed by the [attribute filters](../../Searching/Filters.md). The attribute filters are applied to the result set of the match query. A query without a match clause is called a fullscan.\n\nThere must be at most one `MATCH()` in the `SELECT` clause.\n\nUsing the [full-text query syntax](../../Searching/Full_text_matching/Operators.md), matching is performed across all indexed text fields of a document, unless the expression requires a match within a field (like phrase search) or is limited by field operators.\n\nWhen using [JOIN](../../Searching/Joining.md) queries, `MATCH()` can accept an optional second parameter that specifies which table the full-text search should be applied to. By default, the full-text query is applied to the left table in the `JOIN` operation:\n\nCODE_BLOCK_0\n\nThis allows you to perform full-text searches on specific tables in a join operation. For more details on using MATCH with JOINs, see the [Joining tables](../../Searching/Joining.md) section.\n\n## SQL\n\n<!-- example Example_1 -->\n\nCODE_BLOCK_1\n\n- `'search query'`: The full-text search query string, which can include various [full-text operators](../../Searching/Full_text_matching/Operators.md).\n\n- `table_name`: (Optional) The name of the table to apply the full-text search to, used in `JOIN` queries to specify a different table than the default left table.\n\nThe [SELECT](../../Searching/Full_text_matching/Basic_usage.md#SQL) statement uses a [MATCH](../../Searching/Full_text_matching/Basic_usage.md) clause, which must come after WHERE, for performing full-text searches. `MATCH()` accepts an input string in which all [full-text operators](../../Searching/Full_text_matching/Operators.md) are available.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- request MATCH with filters -->\n\nAn example of a more complex query using MATCH with WHERE filters.\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n## HTTP JSON\n\n<!-- example Example_11 -->\n\nFull-text matching is available in the `/search` endpoint and in HTTP-based clients. The following clauses can be used for performing full-text matches:\n\n### match\n\n\"match\" is a simple query that matches the specified keywords in the specified fields.\n\nCODE_BLOCK_5\n\nYou can specify a list of fields:\n\nCODE_BLOCK_6\n\nOr you can use `_all` or `*` to search all fields.\n\nYou can search all fields except one using \"!field\":\n\nCODE_BLOCK_7\n\nBy default, keywords are combined using the OR operator. However, you can change that behavior using the \"operator\" clause:\n\nCODE_BLOCK_8\n\n\"operator\" can be set to \"or\" or \"and\".\n\nThe `boost` modifier can also be applied. It raises the word [IDF](../../Searching/Options.md#idf)_score by the indicated factor in ranking scores that incorporate IDF into their calculations. It does not impact the matching process in any manner.\n\nCODE_BLOCK_9\n\n### match_phrase\n\n\"match_phrase\" is a query that matches the entire phrase. It is similar to a phrase operator in SQL. Here's an example:\n\nCODE_BLOCK_10\n\n### query_string\n\n\"query_string\" accepts an input string as a full-text query in `MATCH()` syntax.\n\nCODE_BLOCK_11\n\n### match_all\n\n\"match_all\" accepts an empty object and returns documents from the table without performing any attribute filtering or full-text matching. Alternatively, you can just omit the `query` clause in the request which will have the same effect.\n\nCODE_BLOCK_12\n\n### Combining full-text filtering with other filters\n\nAll full-text match clauses can be combined with [must](../../Searching/Filters.md#must), [must_not](../../Searching/Filters.md#must_not), and [should](../../Searching/Filters.md#should) operators of a [JSON `bool` query](../../Searching/Filters.md#bool-query).\n\n<!-- intro -->\n\nExamples:\n\n<!-- request match -->\n\nCODE_BLOCK_13\n\n<!-- response match -->\n\nCODE_BLOCK_14\n\n<!-- request match_phrase -->\n\nCODE_BLOCK_15\n\n<!-- response match_phrase -->\n\nCODE_BLOCK_16\n\n<!-- request query_string -->\n\nCODE_BLOCK_17\n\n<!-- response query_string -->\n\nCODE_BLOCK_18\n\n<!-- request PHP -->\n\nCODE_BLOCK_19\n\n<!-- response PHP -->\n\nCODE_BLOCK_20\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_21\n\n<!-- response Python -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_23\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_24\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_25\n\n<!-- response javascript -->\n\nCODE_BLOCK_26\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_27\n\n<!-- response Java -->\n\nCODE_BLOCK_28\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_29\n\n<!-- response C# -->\n\nCODE_BLOCK_30\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_31\n\n<!-- response Rust -->\n\nCODE_BLOCK_32\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_33\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_34\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_35\n\n<!-- response Go -->\n\nCODE_BLOCK_36\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# MATCH\n\n`MATCH` 子句允许在文本字段中进行全文搜索。输入的查询字符串会使用与索引时应用于文本的相同设置进行[分词](../../Creating_a_table/NLP_and_tokenization/Data_tokenization.md)。除了对输入文本的分词外，查询字符串还支持多种[全文操作符](../../Searching/Full_text_matching/Operators.md)，这些操作符对关键词如何提供有效匹配施加各种规则。\n\n全文匹配子句可以与属性[过滤器](../../Searching/Filters.md)以 AND 布尔关系组合。**不支持全文匹配与属性过滤器之间的 OR 关系**。\n\n匹配查询总是在过滤过程的第一步执行，随后是[属性过滤器](../../Searching/Filters.md)。属性过滤器应用于匹配查询的结果集。没有匹配子句的查询称为全表扫描。\n\n`SELECT` 子句中最多只能有一个 `MATCH()`。\n\n使用[全文查询语法](../../Searching/Full_text_matching/Operators.md)时，匹配会在文档的所有已索引文本字段中执行，除非表达式要求在某个字段内匹配（如短语搜索）或被字段操作符限制。\n\n在使用[JOIN](../../Searching/Joining.md)查询时，`MATCH()` 可以接受一个可选的第二个参数，指定全文搜索应应用于哪个表。默认情况下，全文查询应用于 `JOIN` 操作中的左表：\n\nCODE_BLOCK_0\n\n这允许你在连接操作中对特定表执行全文搜索。有关使用 MATCH 与 JOIN 的更多详细信息，请参见[连接表](../../Searching/Joining.md)部分。\n\n## SQL\n\n<!-- example Example_1 -->\n\nCODE_BLOCK_1\n\n- `'search query'`：全文搜索查询字符串，可以包含各种[全文操作符](../../Searching/Full_text_matching/Operators.md)。\n\n- `table_name`：（可选）应用全文搜索的表名，在 `JOIN` 查询中用于指定不同于默认左表的表。\n\n[SELECT](../../Searching/Full_text_matching/Basic_usage.md#SQL) 语句使用 [MATCH](../../Searching/Full_text_matching/Basic_usage.md) 子句，必须位于 WHERE 之后，用于执行全文搜索。`MATCH()` 接受一个输入字符串，其中所有[全文操作符](../../Searching/Full_text_matching/Operators.md)均可用。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- request MATCH with filters -->\n\n使用 MATCH 和 WHERE 过滤器的更复杂查询示例。\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n## HTTP JSON\n\n<!-- example Example_11 -->\n\n全文匹配可在 `/search` 端点和基于 HTTP 的客户端中使用。以下子句可用于执行全文匹配：\n\n### match\n\n\"match\" 是一个简单查询，在指定字段中匹配指定的关键词。\n\nCODE_BLOCK_5\n\n你可以指定字段列表：\n\nCODE_BLOCK_6\n\n或者你可以使用 `_all` 或 `*` 来搜索所有字段。\n\n你可以使用 \"!field\" 搜索除某个字段外的所有字段：\n\nCODE_BLOCK_7\n\n默认情况下，关键词使用 OR 操作符组合。但是，你可以使用 \"operator\" 子句更改此行为：\n\nCODE_BLOCK_8\n\n\"operator\" 可以设置为 \"or\" 或 \"and\"。\n\n还可以应用 `boost` 修饰符。它通过指定的因子提升词的[IDF](../../Searching/Options.md#idf)_分数，在包含 IDF 计算的排名分数中提高权重。它不会以任何方式影响匹配过程。\n\nCODE_BLOCK_9\n\n### match_phrase\n\n\"match_phrase\" 是一个匹配整个短语的查询。它类似于 SQL 中的短语操作符。示例如下：\n\nCODE_BLOCK_10\n\n### query_string\n\n\"query_string\" 接受一个输入字符串，作为 `MATCH()` 语法的全文查询。\n\nCODE_BLOCK_11\n\n### match_all\n\n\"match_all\" 接受一个空对象，返回表中的文档，而不执行任何属性过滤或全文匹配。或者，你也可以在请求中省略 `query` 子句，效果相同。\n\nCODE_BLOCK_12\n\n### 将全文过滤与其他过滤器结合使用\n\n所有全文匹配子句都可以与[必须](../../Searching/Filters.md#must)、[必须不](../../Searching/Filters.md#must_not)和[应该](../../Searching/Filters.md#should)操作符结合使用，构成[JSON `bool` 查询](../../Searching/Filters.md#bool-query)。\n\n<!-- intro -->\n\n示例：\n\n<!-- request match -->\n\nCODE_BLOCK_13\n\n<!-- response match -->\n\nCODE_BLOCK_14\n\n<!-- request match_phrase -->\n\nCODE_BLOCK_15\n\n<!-- response match_phrase -->\n\nCODE_BLOCK_16\n\n<!-- request query_string -->\n\nCODE_BLOCK_17\n\n<!-- response query_string -->\n\nCODE_BLOCK_18\n\n<!-- request PHP -->\n\nCODE_BLOCK_19\n\n<!-- response PHP -->\n\nCODE_BLOCK_20\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_21\n\n<!-- response Python -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_23\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_24\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_25\n\n<!-- response javascript -->\n\nCODE_BLOCK_26\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_27\n\n<!-- response Java -->\n\nCODE_BLOCK_28\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_29\n\n<!-- response C# -->\n\nCODE_BLOCK_30\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_31\n\n<!-- response Rust -->\n\nCODE_BLOCK_32\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_33\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_34\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_35\n\n<!-- response Go -->\n\nCODE_BLOCK_36\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "# MATCH\n\nКлауза `MATCH` позволяет выполнять полнотекстовый поиск в текстовых полях. Входная строка запроса [токенизируется](../../Creating_a_table/NLP_and_tokenization/Data_tokenization.md) с использованием тех же настроек, которые применялись к тексту при индексировании. Помимо токенизации входного текста, строка запроса поддерживает ряд [операторов полнотекстового поиска](../../Searching/Full_text_matching/Operators.md), которые задают различные правила того, как ключевые слова должны обеспечивать валидное совпадение.\n\nКлаузы полнотекстового поиска могут комбинироваться с атрибутными [фильтрами](../../Searching/Filters.md) как логическое И. **Логические ИЛИ между полнотекстовыми совпадениями и атрибутными фильтрами не поддерживаются**.\n\nЗапрос с match всегда выполняется первым в процессе фильтрации, за ним следуют [атрибутные фильтры](../../Searching/Filters.md). Атрибутные фильтры применяются к результату запроса match. Запрос без клаузы match называется fullscan.\n\nВ `SELECT` должно быть не более одного `MATCH()`.\n\nИспользуя [синтаксис полнотекстового запроса](../../Searching/Full_text_matching/Operators.md), поиск выполняется по всем индексированным текстовым полям документа, если выражение не требует совпадения внутри поля (например, поиск фразы) или не ограничено операторами поля.\n\nПри использовании запросов с [JOIN](../../Searching/Joining.md), `MATCH()` может принимать необязательный второй параметр, который указывает, к какой таблице должен применяться полнотекстовый поиск. По умолчанию полнотекстовый запрос применяется к левой таблице в операции `JOIN`:\n\nCODE_BLOCK_0\n\nЭто позволяет выполнять полнотекстовый поиск по конкретным таблицам в операции соединения. Для получения дополнительной информации о использовании MATCH с JOIN смотрите раздел [Joining tables](../../Searching/Joining.md).\n\n## SQL\n\n<!-- example Example_1 -->\n\nCODE_BLOCK_1\n\n- `'search query'`: Строка полнотекстового поискового запроса, которая может включать различные [операторы полнотекстового поиска](../../Searching/Full_text_matching/Operators.md).\n\n- `table_name`: (Опционально) Имя таблицы, к которой применяется полнотекстовый поиск, используется в запросах с `JOIN` для указания таблицы, отличной от левой по умолчанию.\n\nОператор [SELECT](../../Searching/Full_text_matching/Basic_usage.md#SQL) использует клаузу [MATCH](../../Searching/Full_text_matching/Basic_usage.md), которая должна идти после WHERE, для выполнения полнотекстового поиска. `MATCH()` принимает входную строку, в которой доступны все [операторы полнотекстового поиска](../../Searching/Full_text_matching/Operators.md).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- request MATCH with filters -->\n\nПример более сложного запроса с использованием MATCH и фильтров WHERE.\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n## HTTP JSON\n\n<!-- example Example_11 -->\n\nПолнотекстовый поиск доступен в эндпоинте `/search` и в HTTP-клиентах. Для выполнения полнотекстового поиска можно использовать следующие клаузы:\n\n### match\n\n\"match\" — это простой запрос, который ищет указанные ключевые слова в указанных полях.\n\nCODE_BLOCK_5\n\nВы можете указать список полей:\n\nCODE_BLOCK_6\n\nИли использовать `_all` или `*` для поиска по всем полям.\n\nВы можете искать по всем полям, кроме одного, используя \"!field\":\n\nCODE_BLOCK_7\n\nПо умолчанию ключевые слова объединяются оператором OR. Однако вы можете изменить это поведение с помощью клаузы \"operator\":\n\nCODE_BLOCK_8\n\n\"operator\" может быть установлен в \"or\" или \"and\".\n\nТакже можно применить модификатор `boost`. Он повышает значение [IDF](../../Searching/Options.md#idf)_score слова на указанный коэффициент в рейтинговых оценках, которые учитывают IDF в своих вычислениях. Это не влияет на процесс сопоставления.\n\nCODE_BLOCK_9\n\n### match_phrase\n\n\"match_phrase\" — это запрос, который ищет полную фразу. Он похож на оператор фразы в SQL. Пример:\n\nCODE_BLOCK_10\n\n### query_string\n\n\"query_string\" принимает входную строку в синтаксисе `MATCH()` для полнотекстового запроса.\n\nCODE_BLOCK_11\n\n### match_all\n\n\"match_all\" принимает пустой объект и возвращает документы из таблицы без применения атрибутных фильтров или полнотекстового поиска. Альтернативно, можно просто опустить клаузу `query` в запросе, что даст тот же эффект.\n\nCODE_BLOCK_12\n\n### Комбинирование полнотекстовой фильтрации с другими фильтрами\n\nВсе клаузы полнотекстового поиска могут комбинироваться с операторами [must](../../Searching/Filters.md#must), [must_not](../../Searching/Filters.md#must_not) и [should](../../Searching/Filters.md#should) в [JSON `bool` запросе](../../Searching/Filters.md#bool-query).\n\n<!-- intro -->\n\nПримеры:\n\n<!-- request match -->\n\nCODE_BLOCK_13\n\n<!-- response match -->\n\nCODE_BLOCK_14\n\n<!-- request match_phrase -->\n\nCODE_BLOCK_15\n\n<!-- response match_phrase -->\n\nCODE_BLOCK_16\n\n<!-- request query_string -->\n\nCODE_BLOCK_17\n\n<!-- response query_string -->\n\nCODE_BLOCK_18\n\n<!-- request PHP -->\n\nCODE_BLOCK_19\n\n<!-- response PHP -->\n\nCODE_BLOCK_20\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_21\n\n<!-- response Python -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_23\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_24\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_25\n\n<!-- response javascript -->\n\nCODE_BLOCK_26\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_27\n\n<!-- response Java -->\n\nCODE_BLOCK_28\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_29\n\n<!-- response C# -->\n\nCODE_BLOCK_30\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_31\n\n<!-- response Rust -->\n\nCODE_BLOCK_32\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_33\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_34\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_35\n\n<!-- response Go -->\n\nCODE_BLOCK_36\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "c7f0792a7297dba4a252e47110803e3d0c43f2bcf25730ca0aa609f59b0f5ed2": {
    "original": "# MATCH\n\nThe `MATCH` clause allows for full-text searches in text fields. The input query string is [tokenized](../../Creating_a_table/NLP_and_tokenization/Data_tokenization.md) using the same settings applied to the text during indexing. In addition to the tokenization of input text, the query string supports a number of [full-text operators](../../Searching/Full_text_matching/Operators.md) that enforce various rules on how keywords should provide a valid match.\n\nFull-text match clauses can be combined with attribute [filters](../../Searching/Filters.md) as an AND boolean. **OR relations between full-text matches and attribute filters are not supported**.\n\nThe match query is always executed first in the filtering process, followed by the [attribute filters](../../Searching/Filters.md). The attribute filters are applied to the result set of the match query. A query without a match clause is called a fullscan.\n\nThere must be at most one `MATCH()` in the `SELECT` clause.\n\nUsing the [full-text query syntax](../../Searching/Full_text_matching/Operators.md), matching is performed across all indexed text fields of a document, unless the expression requires a match within a field (like phrase search) or is limited by field operators.\n\nWhen using [JOIN](../../Searching/Joining.md) queries, `MATCH()` can accept an optional second parameter that specifies which table the full-text search should be applied to. By default, the full-text query is applied to the left table in the `JOIN` operation:\n\nCODE_BLOCK_0\n\nThis allows you to perform full-text searches on specific tables in a join operation. For more details on using MATCH with JOINs, see the [Joining tables](../../Searching/Joining.md) section.\n\n## SQL\n\n<!-- example Example_1 -->\n\nCODE_BLOCK_1\n\n- `'search query'`: The full-text search query string, which can include various [full-text operators](../../Searching/Full_text_matching/Operators.md).\n\n- `table_name`: (Optional) The name of the table to apply the full-text search to, used in `JOIN` queries to specify a different table than the default left table.\n\nThe [SELECT](../../Searching/Full_text_matching/Basic_usage.md#SQL) statement uses a [MATCH](../../Searching/Full_text_matching/Basic_usage.md) clause, which must come after WHERE, for performing full-text searches. `MATCH()` accepts an input string in which all [full-text operators](../../Searching/Full_text_matching/Operators.md) are available.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- request JSON -->\n\nCODE_BLOCK_4\n\n<!-- response JSON -->\n\nCODE_BLOCK_5\n\n<!-- request MATCH with filters -->\n\nAn example of a more complex query using MATCH with WHERE filters.\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n## HTTP JSON\n\n<!-- example Example_11 -->\n\nFull-text matching is available in the `/search` endpoint and in HTTP-based clients. The following clauses can be used for performing full-text matches:\n\n### match\n\n\"match\" is a simple query that matches the specified keywords in the specified fields.\n\nCODE_BLOCK_7\n\nYou can specify a list of fields:\n\nCODE_BLOCK_8\n\nOr you can use `_all` or `*` to search all fields.\n\nYou can search all fields except one using \"!field\":\n\nCODE_BLOCK_9\n\nBy default, keywords are combined using the OR operator. However, you can change that behavior using the \"operator\" clause:\n\nCODE_BLOCK_10\n\n\"operator\" can be set to \"or\" or \"and\".\n\nThe `boost` modifier can also be applied. It raises the word [IDF](../../Searching/Options.md#idf)_score by the indicated factor in ranking scores that incorporate IDF into their calculations. It does not impact the matching process in any manner.\n\nCODE_BLOCK_11\n\n### match_phrase\n\n\"match_phrase\" is a query that matches the entire phrase. It is similar to a phrase operator in SQL. Here's an example:\n\nCODE_BLOCK_12\n\n### query_string\n\n\"query_string\" accepts an input string as a full-text query in `MATCH()` syntax.\n\nCODE_BLOCK_13\n\n### match_all\n\n\"match_all\" accepts an empty object and returns documents from the table without performing any attribute filtering or full-text matching. Alternatively, you can just omit the `query` clause in the request which will have the same effect.\n\nCODE_BLOCK_14\n\n### Combining full-text filtering with other filters\n\nAll full-text match clauses can be combined with [must](../../Searching/Filters.md#must), [must_not](../../Searching/Filters.md#must_not), and [should](../../Searching/Filters.md#should) operators of a [JSON `bool` query](../../Searching/Filters.md#bool-query).\n\n<!-- intro -->\n\nExamples:\n\n<!-- request match -->\n\nCODE_BLOCK_15\n\n<!-- response match -->\n\nCODE_BLOCK_16\n\n<!-- request match_phrase -->\n\nCODE_BLOCK_17\n\n<!-- response match_phrase -->\n\nCODE_BLOCK_18\n\n<!-- request query_string -->\n\nCODE_BLOCK_19\n\n<!-- response query_string -->\n\nCODE_BLOCK_20\n\n<!-- request PHP -->\n\nCODE_BLOCK_21\n\n<!-- response PHP -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_23\n\n<!-- response Python -->\n\nCODE_BLOCK_24\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_25\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_26\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_27\n\n<!-- response javascript -->\n\nCODE_BLOCK_28\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_29\n\n<!-- response Java -->\n\nCODE_BLOCK_30\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_31\n\n<!-- response C# -->\n\nCODE_BLOCK_32\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_33\n\n<!-- response Rust -->\n\nCODE_BLOCK_34\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_35\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_36\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_37\n\n<!-- response Go -->\n\nCODE_BLOCK_38\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# MATCH\n\n`MATCH` 子句允许在文本字段中进行全文搜索。输入的查询字符串会使用与索引期间应用于文本的相同设置进行[分词](../../Creating_a_table/NLP_and_tokenization/Data_tokenization.md)。除了对输入文本的分词外，查询字符串还支持许多[全文操作符](../../Searching/Full_text_matching/Operators.md)，用于规定关键字应如何提供有效匹配的各种规则。\n\n全文匹配子句可以与属性[过滤器](../../Searching/Filters.md)组合，作为 AND 布尔关系。**全文匹配与属性过滤器之间不支持 OR 关系**。\n\n匹配查询总是在过滤过程中首先执行，随后是[属性过滤器](../../Searching/Filters.md)。属性过滤器应用于匹配查询的结果集。没有 MATCH 子句的查询称为全表扫描（fullscan）。\n\n`SELECT` 子句中最多只能有一个 `MATCH()`。\n\n使用[全文查询语法](../../Searching/Full_text_matching/Operators.md)时，匹配会跨文档的所有已索引文本字段执行，除非表达式要求在某字段内匹配（如短语搜索）或受字段操作符所限制。\n\n在使用[JOIN](../../Searching/Joining.md)查询时，`MATCH()` 可以接受一个可选的第二个参数，指定全文搜索应应用于哪个表。默认情况下，全文查询应用于 `JOIN` 操作中的左表：\n\nCODE_BLOCK_0\n\n这允许你在连接操作中针对特定表执行全文搜索。有关在 JOIN 中使用 MATCH 的更多详细信息，请参见[连接表](../../Searching/Joining.md)部分。\n\n## SQL\n\n<!-- example Example_1 -->\n\nCODE_BLOCK_1\n\n- `'search query'`：全文搜索查询字符串，可以包含各种[全文操作符](../../Searching/Full_text_matching/Operators.md)。\n\n- `table_name`：（可选）要应用全文搜索的表名，用于 `JOIN` 查询中指定不同于默认左表的表。\n\n[SELECT](../../Searching/Full_text_matching/Basic_usage.md#SQL) 语句使用 [MATCH](../../Searching/Full_text_matching/Basic_usage.md) 子句，必须放在 WHERE 之后，用于执行全文搜索。`MATCH()` 接受输入字符串，其中所有[全文操作符](../../Searching/Full_text_matching/Operators.md)都可用。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- request JSON -->\n\nCODE_BLOCK_4\n\n<!-- response JSON -->\n\nCODE_BLOCK_5\n\n<!-- request MATCH with filters -->\n\n一个使用 MATCH 和 WHERE 过滤器进行更复杂查询的示例。\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n## HTTP JSON\n\n<!-- example Example_11 -->\n\n全文匹配功能可在 `/search` 端点及 HTTP 客户端中使用。以下子句可用于执行全文匹配：\n\n### match\n\n\"match\" 是简单查询，在指定字段中匹配指定的关键字。\n\nCODE_BLOCK_7\n\n你可以指定字段列表：\n\nCODE_BLOCK_8\n\n或者使用 `_all` 或 `*` 来搜索所有字段。\n\n你也可以使用 \"!field\" 搜索除某字段外的所有字段：\n\nCODE_BLOCK_9\n\n默认情况下，关键字通过 OR 运算符组合。但你可以通过 \"operator\" 子句更改此行为：\n\nCODE_BLOCK_10\n\n\"operator\" 可设置为 \"or\" 或 \"and\"。\n\n也可以应用 `boost` 修改符。它通过指定的因子提升词的 [IDF](../../Searching/Options.md#idf) 分数（在评分中结合 IDF 的排名分数中体现）。它不会以任何方式影响匹配过程。\n\nCODE_BLOCK_11\n\n### match_phrase\n\n\"match_phrase\" 是匹配整个短语的查询，类似于 SQL 的短语操作符，示例：\n\nCODE_BLOCK_12\n\n### query_string\n\n\"query_string\" 接受一个作为 `MATCH()` 语法的全文查询的输入字符串。\n\nCODE_BLOCK_13\n\n### match_all\n\n\"match_all\" 接受一个空对象，返回表中的文档，不执行任何属性过滤或全文匹配。或者，直接省略请求中的 `query` 子句也有同样效果。\n\nCODE_BLOCK_14\n\n### 结合全文过滤和其他过滤器\n\n所有全文匹配子句都可以结合 [must](../../Searching/Filters.md#must)、[must_not](../../Searching/Filters.md#must_not) 和 [should](../../Searching/Filters.md#should) 操作符使用 [JSON `bool` 查询](../../Searching/Filters.md#bool-query)。\n\n<!-- intro -->\n\n示例：\n\n<!-- request match -->\n\nCODE_BLOCK_15\n\n<!-- response match -->\n\nCODE_BLOCK_16\n\n<!-- request match_phrase -->\n\nCODE_BLOCK_17\n\n<!-- response match_phrase -->\n\nCODE_BLOCK_18\n\n<!-- request query_string -->\n\nCODE_BLOCK_19\n\n<!-- response query_string -->\n\nCODE_BLOCK_20\n\n<!-- request PHP -->\n\nCODE_BLOCK_21\n\n<!-- response PHP -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_23\n\n<!-- response Python -->\n\nCODE_BLOCK_24\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_25\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_26\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_27\n\n<!-- response javascript -->\n\nCODE_BLOCK_28\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_29\n\n<!-- response Java -->\n\nCODE_BLOCK_30\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_31\n\n<!-- response C# -->\n\nCODE_BLOCK_32\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_33\n\n<!-- response Rust -->\n\nCODE_BLOCK_34\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_35\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_36\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_37\n\n<!-- response Go -->\n\nCODE_BLOCK_38\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "# MATCH\n\nКлауза `MATCH` позволяет выполнять полнотекстовый поиск в текстовых полях. Входящая строка запроса [токенизируется](../../Creating_a_table/NLP_and_tokenization/Data_tokenization.md) с использованием тех же настроек, которые применялись к тексту при индексировании. Помимо токенизации входного текста, строка запроса поддерживает ряд [операторов полнотекстового поиска](../../Searching/Full_text_matching/Operators.md), которые задают различные правила, с помощью которых ключевые слова должны обеспечивать валидное совпадение.\n\nКлаузы полнотекстового сопоставления могут комбинироваться с [фильтрами](../../Searching/Filters.md) по атрибутам, используя логическое И (AND). **Отношения ИЛИ между полнотекстовыми совпадениями и атрибутными фильтрами не поддерживаются**.\n\nЗапрос сопоставления всегда выполняется первым на этапе фильтрации, а затем применяются [фильтры атрибутов](../../Searching/Filters.md). Фильтры атрибутов применяются к результату запроса сопоставления. Запрос без клаузы match называется fullscan.\n\nВ клауза `SELECT` может присутствовать не более одной `MATCH()`.\n\nИспользуя [синтаксис полнотекстовых запросов](../../Searching/Full_text_matching/Operators.md), сопоставление выполняется по всем проиндексированным текстовым полям документа, если только выражение не требует совпадения в определённом поле (например, поиск фразы) или не ограничено операторами полей.\n\nПри использовании запросов с [JOIN](../../Searching/Joining.md), `MATCH()` может принимать необязательный второй параметр, который указывает таблицу, к которой следует применить полнотекстовый поиск. По умолчанию полнотекстовый запрос применяется к левой таблице в операции `JOIN`:\n\nCODE_BLOCK_0\n\nЭто позволяет выполнять полнотекстовый поиск по конкретным таблицам в операции объединения. Для подробностей использования MATCH с JOIN смотрите раздел [Объединение таблиц](../../Searching/Joining.md).\n\n## SQL\n\n<!-- example Example_1 -->\n\nCODE_BLOCK_1\n\n- `'search query'`: Строка полнотекстового поискового запроса, которая может включать различные [операторы полнотекстового поиска](../../Searching/Full_text_matching/Operators.md).\n\n- `table_name`: (необязательно) Имя таблицы, к которой применяется полнотекстовый поиск, используется в запросах с `JOIN` для указания таблицы, отличной от левой по умолчанию.\n\nОператор [SELECT](../../Searching/Full_text_matching/Basic_usage.md#SQL) использует клауза [MATCH](../../Searching/Full_text_matching/Basic_usage.md), который должен идти после WHERE, для выполнения полнотекстовых поисков. `MATCH()` принимает входную строку, в которой доступны все [операторы полнотекстового поиска](../../Searching/Full_text_matching/Operators.md).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- request JSON -->\n\nCODE_BLOCK_4\n\n<!-- response JSON -->\n\nCODE_BLOCK_5\n\n<!-- request MATCH with filters -->\n\nПример более сложного запроса с использованием MATCH и фильтров WHERE.\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n## HTTP JSON\n\n<!-- example Example_11 -->\n\nПолнотекстовое сопоставление доступно через эндпоинт `/search` и в HTTP-клиентах. Для полнотекстовых сопоставлений можно использовать следующие клаузы:\n\n### match\n\n\"match\" — простой запрос, который сопоставляет указанные ключевые слова в заданных полях.\n\nCODE_BLOCK_7\n\nМожно указать список полей:\n\nCODE_BLOCK_8\n\nИли использовать `_all` или `*` для поиска по всем полям.\n\nМожно искать по всем полям, кроме одного, используя \"!field\":\n\nCODE_BLOCK_9\n\nПо умолчанию ключевые слова объединяются оператором OR. Однако это поведение можно изменить с помощью клаузы \"operator\":\n\nCODE_BLOCK_10\n\n\"operator\" может быть установлен в \"or\" или \"and\".\n\nТакже можно использовать модификатор `boost`. Он увеличивает значение [IDF](../../Searching/Options.md#idf)_оценки слова на указанный коэффициент в ранжировочных оценках, которые учитывают IDF при вычислениях. Это не влияет на процесс сопоставления.\n\nCODE_BLOCK_11\n\n### match_phrase\n\n\"match_phrase\" — запрос, который сопоставляет всю фразу целиком. Это похоже на оператор фразы в SQL. Пример:\n\nCODE_BLOCK_12\n\n### query_string\n\n\"query_string\" принимает входную строку в синтаксисе `MATCH()` и использует ее как полнотекстовый запрос.\n\nCODE_BLOCK_13\n\n### match_all\n\n\"match_all\" принимает пустой объект и возвращает документы из таблицы без применения фильтров по атрибутам или полнотекстового сопоставления. Альтернативно можно просто опустить клауза `query` в запросе — эффект будет тот же.\n\nCODE_BLOCK_14\n\n### Комбинирование полнотекстового фильтра с другими фильтрами\n\nВсе клаузы полнотекстового сопоставления можно комбинировать с операторами [must](../../Searching/Filters.md#must), [must_not](../../Searching/Filters.md#must_not) и [should](../../Searching/Filters.md#should) JSON `bool` запроса [bool](../../Searching/Filters.md#bool-query).\n\n<!-- intro -->\n\nПримеры:\n\n<!-- request match -->\n\nCODE_BLOCK_15\n\n<!-- response match -->\n\nCODE_BLOCK_16\n\n<!-- request match_phrase -->\n\nCODE_BLOCK_17\n\n<!-- response match_phrase -->\n\nCODE_BLOCK_18\n\n<!-- request query_string -->\n\nCODE_BLOCK_19\n\n<!-- response query_string -->\n\nCODE_BLOCK_20\n\n<!-- request PHP -->\n\nCODE_BLOCK_21\n\n<!-- response PHP -->\n\nCODE_BLOCK_22\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_23\n\n<!-- response Python -->\n\nCODE_BLOCK_24\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_25\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_26\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_27\n\n<!-- response javascript -->\n\nCODE_BLOCK_28\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_29\n\n<!-- response Java -->\n\nCODE_BLOCK_30\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_31\n\n<!-- response C# -->\n\nCODE_BLOCK_32\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_33\n\n<!-- response Rust -->\n\nCODE_BLOCK_34\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_35\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_36\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_37\n\n<!-- response Go -->\n\nCODE_BLOCK_38\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
