{
  "dd2db53015ff6d1825e18f066fd326010925a27b0428c18121feabdeee6d46fb": {
    "original": "# Escaping characters in query string\n\nSince certain characters function as operators in the query string, they must be escaped to prevent query errors or unintended matching conditions.\n\nThe following characters should be escaped using a backslash (`\\`):\n\nCODE_BLOCK_0\n\n## In MySQL command line client\n\nTo escape a single quote ('), use one backslash:\n\nCODE_BLOCK_1\n\nFor the other characters in the list mentioned earlier, which are operators or query constructs, they must be treated as simple characters by the engine, with a preceding escape character.\n\nThe backslash must also be escaped, resulting in two backslashes:\n\nCODE_BLOCK_2\n\nTo use a backslash as a character, you must escape both the backslash as a character and the backslash as the escape operator, which requires four backslashes:\n\nCODE_BLOCK_3\n\nWhen you are working with JSON data in Manticore Search and need to include a double quote (`\"`) within a JSON string, it's important to handle it with proper escaping. In JSON, a double quote within a string is escaped using a backslash (`\\`). However, when inserting the JSON data through an SQL query, Manticore Search interprets the backslash (`\\`) as an escape character within strings.\n\nTo ensure the double quote is correctly inserted into the JSON data, you need to escape the backslash itself. This results in using two backslashes (`\\\\`) before the double quote. For example:\n\nCODE_BLOCK_4\n\n## Using MySQL drivers\n\nMySQL drivers provide escaping functions (e.g., `mysqli_real_escape_string` in PHP or `conn.escape_string` in Python), but they only escape specific characters.\n\nYou will still need to add escaping for the characters from the previously mentioned list that are not escaped by their respective functions.\n\nBecause these functions will escape the backslash for you, you only need to add one backslash.\n\nThis also applies to drivers that support (client-side) prepared statements. For example, with PHP PDO prepared statements, you need to add a backslash for the `$` character:\n\nCODE_BLOCK_5\n\nThis results in the final query `SELECT * FROM index WHERE MATCH('\\\\$manticore');`\n\n## In HTTP JSON API\n\nThe same rules for the SQL protocol apply, with the exception that for JSON, the double quote must be escaped with a single backslash, while the rest of the characters require double escaping.\n\nWhen using JSON libraries or functions that convert data structures to JSON strings, the double quote and single backslash are automatically escaped by these functions and do not need to be explicitly escaped.\n\n## In clients\n\nThe [official clients](https://github.com/manticoresoftware/) utilize common JSON libraries/functions available in their respective programming languages under the hood. The same rules for escaping mentioned earlier apply.\n\n## Escaping asterisk\n\nThe asterisk (`*`) is a unique character that serves two purposes:\n\n* as a wildcard prefix/suffix expander\n\n* as an any-term modifier within a phrase search.\n\nUnlike other special characters that function as operators, the asterisk cannot be escaped when it's in a position to provide one of its functionalities.\n\nIn non-wildcard queries, the asterisk does not require escaping, whether it's in the `charset_table` or not.\n\nIn wildcard queries, an asterisk in the middle of a word does not require escaping. As a wildcard operator (either at the beginning or end of the word), the asterisk will always be interpreted as the wildcard operator, even if escaping is applied.\n\n## Escaping json node names in SQL\n\nTo escape special characters in JSON nodes, use a backtick. For example:\n\nCODE_BLOCK_6\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 查询字符串中的转义字符\n\n由于某些字符在查询字符串中作为操作符使用，必须对它们进行转义以防止查询错误或意外的匹配条件。\n\n以下字符应使用反斜杠（`\\`）进行转义：\n\nCODE_BLOCK_0\n\n## 在 MySQL 命令行客户端中\n\n要转义单引号（'），使用一个反斜杠：\n\nCODE_BLOCK_1\n\n对于前面提到的列表中的其他字符，它们是操作符或查询构造，必须被引擎视为普通字符，并在前面加上转义字符。\n\n反斜杠本身也必须被转义，结果是两个反斜杠：\n\nCODE_BLOCK_2\n\n要将反斜杠作为字符使用，必须同时转义作为字符的反斜杠和作为转义操作符的反斜杠，这需要四个反斜杠：\n\nCODE_BLOCK_3\n\n当您在 Manticore Search 中处理 JSON 数据并需要在 JSON 字符串中包含双引号（`\"`）时，重要的是要正确处理转义。在 JSON 中，字符串中的双引号使用反斜杠（`\\`）转义。然而，当通过 SQL 查询插入 JSON 数据时，Manticore Search 将反斜杠（`\\`）解释为字符串中的转义字符。\n\n为了确保双引号正确插入到 JSON 数据中，您需要对反斜杠本身进行转义。这导致在双引号前使用两个反斜杠（`\\\\`）。例如：\n\nCODE_BLOCK_4\n\n## 使用 MySQL 驱动程序\n\nMySQL 驱动程序提供转义函数（例如 PHP 中的 `mysqli_real_escape_string` 或 Python 中的 `conn.escape_string`），但它们只转义特定字符。\n\n您仍然需要为之前提到的列表中未被其各自函数转义的字符添加转义。\n\n因为这些函数会为您转义反斜杠，所以您只需添加一个反斜杠。\n\n这也适用于支持（客户端）预处理语句的驱动程序。例如，使用 PHP PDO 预处理语句时，您需要为 `$` 字符添加一个反斜杠：\n\nCODE_BLOCK_5\n\n这将导致最终查询为 `SELECT * FROM index WHERE MATCH('\\\\$manticore');`\n\n## 在 HTTP JSON API 中\n\nSQL 协议的相同规则适用，唯一的例外是对于 JSON，双引号必须用单个反斜杠转义，而其余字符需要双重转义。\n\n当使用将数据结构转换为 JSON 字符串的 JSON 库或函数时，双引号和单个反斜杠会被这些函数自动转义，无需显式转义。\n\n## 在客户端中\n\n[官方客户端](https://github.com/manticoresoftware/) 在底层使用各自编程语言中常见的 JSON 库/函数。之前提到的转义规则同样适用。\n\n## 转义星号\n\n星号（`*`）是一个独特的字符，具有两个用途：\n\n* 作为通配符前缀/后缀扩展符\n\n* 作为短语搜索中的任意词修饰符。\n\n与其他作为操作符的特殊字符不同，当星号处于提供其功能的位置时，不能对其进行转义。\n\n在非通配符查询中，无论是否在 `charset_table` 中，星号都不需要转义。\n\n在通配符查询中，单词中间的星号不需要转义。作为通配符操作符（无论在单词开头还是结尾），星号始终被解释为通配符操作符，即使应用了转义。\n\n## 在 SQL 中转义 JSON 节点名称\n\n要转义 JSON 节点中的特殊字符，请使用反引号。例如：\n\nCODE_BLOCK_6\n\n<!-- proofread -->",
      "russian": "# Экранирование символов в строке запроса\n\nПоскольку некоторые символы выполняют функции операторов в строке запроса, их необходимо экранировать, чтобы избежать ошибок запроса или непреднамеренных условий совпадения.\n\nСледующие символы должны быть экранированы с помощью обратного слэша (`\\`):\n\nCODE_BLOCK_0\n\n## В командной строке MySQL\n\nДля экранирования одинарной кавычки ('), используйте один обратный слэш:\n\nCODE_BLOCK_1\n\nДля остальных символов из ранее упомянутого списка, которые являются операторами или конструкциями запроса, они должны рассматриваться движком как обычные символы с предшествующим символом экранирования.\n\nОбратный слэш также должен быть экранирован, что приводит к двум обратным слэшам:\n\nCODE_BLOCK_2\n\nЧтобы использовать обратный слэш как символ, необходимо экранировать и обратный слэш как символ, и обратный слэш как оператор экранирования, что требует четырёх обратных слэшей:\n\nCODE_BLOCK_3\n\nКогда вы работаете с JSON-данными в Manticore Search и нужно включить двойную кавычку (`\"`) внутри JSON-строки, важно правильно её экранировать. В JSON двойная кавычка внутри строки экранируется с помощью обратного слэша (`\\`). Однако при вставке JSON-данных через SQL-запрос Manticore Search интерпретирует обратный слэш (`\\`) как символ экранирования внутри строк.\n\nЧтобы двойная кавычка была корректно вставлена в JSON-данные, необходимо экранировать сам обратный слэш. Это приводит к использованию двух обратных слэшей (`\\\\`) перед двойной кавычкой. Например:\n\nCODE_BLOCK_4\n\n## Использование драйверов MySQL\n\nДрайверы MySQL предоставляют функции экранирования (например, `mysqli_real_escape_string` в PHP или `conn.escape_string` в Python), но они экранируют только определённые символы.\n\nВам всё равно нужно будет добавить экранирование для символов из ранее упомянутого списка, которые не экранируются соответствующими функциями.\n\nПоскольку эти функции экранируют обратный слэш за вас, вам нужно добавить только один обратный слэш.\n\nЭто также относится к драйверам, поддерживающим (клиентские) подготовленные выражения. Например, с подготовленными выражениями PHP PDO необходимо добавить обратный слэш для символа `$`:\n\nCODE_BLOCK_5\n\nВ результате получается итоговый запрос `SELECT * FROM index WHERE MATCH('\\\\$manticore');`\n\n## В HTTP JSON API\n\nТе же правила, что и для SQL-протокола, применимы, за исключением того, что для JSON двойная кавычка должна экранироваться одним обратным слэшем, а остальные символы требуют двойного экранирования.\n\nПри использовании JSON-библиотек или функций, которые преобразуют структуры данных в JSON-строки, двойная кавычка и одиночный обратный слэш автоматически экранируются этими функциями и не требуют явного экранирования.\n\n## В клиентах\n\n[Официальные клиенты](https://github.com/manticoresoftware/) используют общие JSON-библиотеки/функции, доступные в соответствующих языках программирования. Применяются те же правила экранирования, упомянутые ранее.\n\n## Экранирование звёздочки\n\nЗвёздочка (`*`) — уникальный символ, который выполняет две функции:\n\n* как подстановочный символ в начале/конце слова\n\n* как модификатор \"любой термин\" внутри поиска по фразе.\n\nВ отличие от других специальных символов, которые функционируют как операторы, звёздочка не может быть экранирована, когда она находится в позиции, обеспечивающей одну из своих функций.\n\nВ запросах без подстановочных символов звёздочка не требует экранирования, независимо от того, находится ли она в `charset_table` или нет.\n\nВ запросах с подстановочными символами звёздочка в середине слова не требует экранирования. В качестве оператора подстановки (в начале или конце слова) звёздочка всегда будет интерпретироваться как оператор подстановки, даже если применяется экранирование.\n\n## Экранирование имён узлов JSON в SQL\n\nДля экранирования специальных символов в узлах JSON используйте обратные кавычки. Например:\n\nCODE_BLOCK_6\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
