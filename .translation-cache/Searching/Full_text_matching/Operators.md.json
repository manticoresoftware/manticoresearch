{
  "0dc49c94de44ddf3acc7b25256b92c8462bead4be300503f8f8f4ddbd6a3bd00": {
    "original": "The `SENTENCE` and `PARAGRAPH` operators match a document when both of their arguments are within the same sentence or the same paragraph of text, respectively. These arguments can be keywords, phrases, or instances of the same operator.\n\nThe order of the arguments within the sentence or paragraph is irrelevant. These operators function only with tables built with [index_sp](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_sp) (sentence and paragraph indexing feature) enabled and revert to a simple AND operation otherwise. For information on what constitutes a sentence and a paragraph, refer to the [index_sp](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_sp) directive documentation.\n\n### ZONE limit operator\n\nCODE_BLOCK_33\n\nThe `ZONE limit` operator closely resembles the field limit operator but limits matching to a specified in-field zone or a list of zones. It is important to note that subsequent subexpressions do not need to match within a single continuous span of a given zone and may match across multiple spans. For example, the query `(ZONE:th hello world)` will match the following sample document:\n\nCODE_BLOCK_34\n\nThe `ZONE` operator affects the query until the next field or `ZONE` limit operator, or until the closing parenthesis. It functions exclusively with tables built with zone support (refer to [index_zones](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_zones)) and will be disregarded otherwise.\n\n### ZONESPAN limit operator\n\nCODE_BLOCK_35\n\nThe `ZONESPAN` limit operator resembles the `ZONE` operator but mandates that the match occurs within a single continuous span. In the example provided earlier, `ZONESPAN:th hello world` would not match the document, as \"hello\" and \"world\" do not appear within the same span.\n\n<!-- proofread -->",
    "translations": {
      "chinese": "`SENTENCE` 和 `PARAGRAPH` 操作符分别在它们的两个参数位于同一句子或同一段文本内时匹配文档。这些参数可以是关键词、短语或相同操作符的实例。\n\n参数在句子或段落中的顺序无关紧要。这些操作符仅在启用了 [index_sp](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_sp)（句子和段落索引功能）的表中有效，否则退化为简单的 AND 操作。有关句子和段落的定义，请参阅 [index_sp](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_sp) 指令文档。\n\n### ZONE 限定操作符\n\nCODE_BLOCK_33\n\n`ZONE limit` 操作符与字段限定操作符非常相似，但将匹配限制在指定的字段内区域或区域列表中。需要注意的是，后续的子表达式不必在给定区域的单个连续范围内匹配，可以跨多个范围匹配。例如，查询 `(ZONE:th hello world)` 将匹配以下示例文档：\n\nCODE_BLOCK_34\n\n`ZONE` 操作符影响查询，直到遇到下一个字段或 `ZONE` 限定操作符，或直到闭合括号。它仅在支持区域的表中有效（参见 [index_zones](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_zones)），否则将被忽略。\n\n### ZONESPAN 限定操作符\n\nCODE_BLOCK_35\n\n`ZONESPAN` 限定操作符类似于 `ZONE` 操作符，但要求匹配必须发生在单个连续范围内。在前面给出的示例中，`ZONESPAN:th hello world` 不会匹配该文档，因为 \"hello\" 和 \"world\" 不在同一范围内。\n\n<!-- proofread -->",
      "russian": "Операторы `SENTENCE` и `PARAGRAPH` соответствуют документу, когда оба их аргумента находятся в одном предложении или в одном абзаце текста соответственно. Эти аргументы могут быть ключевыми словами, фразами или экземплярами того же оператора.\n\nПорядок аргументов внутри предложения или абзаца не имеет значения. Эти операторы работают только с таблицами, построенными с включённой функцией [index_sp](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_sp) (индексация предложений и абзацев) и в противном случае сводятся к простой операции AND. Для информации о том, что считается предложением и абзацем, обратитесь к документации директивы [index_sp](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_sp).\n\n### Оператор ограничения ZONE\n\nCODE_BLOCK_33\n\nОператор ограничения `ZONE` очень похож на оператор ограничения поля, но ограничивает совпадение указанной зоной внутри поля или списком зон. Важно отметить, что последующие подвыражения не обязаны совпадать в одном непрерывном участке заданной зоны и могут совпадать в нескольких участках. Например, запрос `(ZONE:th hello world)` будет соответствовать следующему примеру документа:\n\nCODE_BLOCK_34\n\nОператор `ZONE` действует на запрос до следующего оператора ограничения поля или `ZONE`, либо до закрывающей скобки. Он работает исключительно с таблицами, построенными с поддержкой зон (см. [index_zones](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_zones)) и в противном случае игнорируется.\n\n### Оператор ограничения ZONESPAN\n\nCODE_BLOCK_35\n\nОператор ограничения `ZONESPAN` похож на оператор `ZONE`, но требует, чтобы совпадение происходило в одном непрерывном участке. В приведённом ранее примере `ZONESPAN:th hello world` не будет соответствовать документу, так как \"hello\" и \"world\" не находятся в одном и том же участке.\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "5316476c036d40fce937bd652b543d69a89efa1894fb99b3a8759f26c7195254": {
    "original": "# Full text operators\n\nThe query string can include specific operators that define the conditions for how the words from the query string should be matched.\n\n### Boolean operators\n\n#### AND operator\n\nAn implicit logical AND operator is always present, so \"hello world\" implies that both \"hello\" and \"world\" must be found in the matching document.\n\nCODE_BLOCK_0\n\nNote: There is no explicit `AND` operator.\n\n#### OR operator\n\nThe logical OR operator `|` has a higher precedence than AND, so `looking for cat | dog | mouse` means `looking for (cat | dog | mouse)` rather than `(looking for cat) | dog | mouse`.\n\nCODE_BLOCK_1\n\nNote: There is no operator `OR`. Please use `|` instead.\n\n### MAYBE operator\n\nCODE_BLOCK_2\n\nThe `MAYBE` operator functions similarly to the `|` operator, but it does not return documents that match only the right subtree expression.\n\n### Negation operator\n\nCODE_BLOCK_3\n\nThe negation operator enforces a rule for a word to not exist.\n\nQueries containing **only** negations are **not** supported by default. To enable, use the server option [not_terms_only_allowed](../../Server_settings/Searchd.md#not_terms_only_allowed).\n\n### Field search operator\n\nCODE_BLOCK_4\n\nThe field limit operator restricts subsequent searches to a specified field. By default, the query will fail with an error message if the given field name does not exist in the searched table. However, this behavior can be suppressed by specifying the `@@relaxed` option at the beginning of the query:\n\nCODE_BLOCK_5\n\nThis can be useful when searching through heterogeneous tables with different schemas.\n\nField position limits additionally constrain the search to the first N positions within a given field (or fields). For example, `@body [50] hello` will not match documents where the keyword `hello` appears at position 51 or later in the body.\n\nCODE_BLOCK_6\n\nMultiple-field search operator:\n\nCODE_BLOCK_7\n\nIgnore field search operator (ignores any matches of 'hello world' from the 'title' field):\n\nCODE_BLOCK_8\n\nIgnore multiple-field search operator (if there are fields 'title', 'subject', and 'body', then `@!(title)` is equivalent to `@(subject,body)`):\n\nCODE_BLOCK_9\n\nAll-field search operator:\n\nCODE_BLOCK_10\n\n### Phrase search operator\n\nCODE_BLOCK_11\n\nThe phrase operator mandates that the words be adjacent to each other.\n\nThe phrase search operator can include a `match any term` modifier. Within the phrase operator, terms are positionally significant. When the 'match any term' modifier is employed, the positions of the subsequent terms in that phrase query will be shifted. As a result, the 'match any' modifier does not affect search performance.\n\nCODE_BLOCK_12\n\nYou can also use the OR operator inside the quotes. The OR operator (`|`) must be enclosed in brackets `()` when used inside phrases. Each option is checked at the same position, and the phrase matches if any of the options fit that position.\n\n**Correct examples** (with brackets):\n\nCODE_BLOCK_13\n\n**Incorrect examples** (without brackets - these won't work):\n\nCODE_BLOCK_14\n\n###  Proximity search operator\n\nCODE_BLOCK_15\n\nProximity distance is measured in words, accounting for word count, and applies to all words within quotes. For example, the query `\"cat dog mouse\"~5` indicates that there must be a span of fewer than 8 words containing all 3 words. Therefore, a document with `CAT aaa bbb ccc DOG eee fff MOUSE` will not match this query, as the span is exactly 8 words long.\n\nYou can also use the OR operator inside a proximity search. The OR operator (`|`) must be enclosed in brackets `()` when used inside proximity searches. Each option is checked separately.\n\n**Correct example** (with brackets):\n\nCODE_BLOCK_16\n\n**Incorrect example** (without brackets - this won't work):\n\nCODE_BLOCK_17\n\n###  Quorum matching operator\n\nCODE_BLOCK_18\n\nThe quorum matching operator introduces a type of fuzzy matching. It will match only those documents that meet a given threshold of specified words. In the example above (`\"the world is a wonderful place\"/3`), it will match all documents containing at least 3 of the 6 specified words. The operator is limited to 255 keywords. Instead of an absolute number, you can also provide a value between 0.0 and 1.0 (representing 0% and 100%), and Manticore will match only documents containing at least the specified percentage of the given words. The same example above could also be expressed as `\"the world is a wonderful place\"/0.5`, and it would match documents with at least 50% of the 6 words.\n\nThe quorum operator supports the OR (`|`) operator. The OR operator (`|`) must be enclosed in brackets `()` when used inside quorum matching. Only one word from each OR group counts toward the match.\n\n**Correct examples** (with brackets):\n\nCODE_BLOCK_19\n\n**Incorrect example** (without brackets - this won't work):\n\nCODE_BLOCK_20\n\n### Strict order operator\n\nCODE_BLOCK_21\n\nThe strict order operator (also known as the \"before\" operator) matches a document only if its argument keywords appear in the document precisely in the order specified in the query. For example, the query `black << cat` will match the document \"black and white cat\" but not the document \"that cat was black\". The order operator has the lowest priority. It can be applied to both individual keywords and more complex expressions. For instance, this is a valid query:\n\nCODE_BLOCK_22\n\n### Exact form modifier\n\nCODE_BLOCK_23\n\nThe exact form keyword modifier matches a document only if the keyword appears in the exact form specified. By default, a document is considered a match if the stemmed/lemmatized keyword matches. For instance, the query \"runs\" will match both a document containing \"runs\" and one containing \"running\", because both forms stem to just \"run\". However, the `=runs` query will only match the first document. The exact form modifier requires the [index_exact_words](../../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words) option to be enabled.",
    "translations": {
      "chinese": "# 全文操作符\n\n查询字符串可以包含特定的操作符，用于定义查询字符串中的单词应如何匹配的条件。\n\n### 布尔操作符\n\n#### AND 操作符\n\n隐式的逻辑 AND 操作符始终存在，因此 \"hello world\" 意味着匹配的文档中必须同时包含 \"hello\" 和 \"world\"。\n\nCODE_BLOCK_0\n\n注意：没有显式的 `AND` 操作符。\n\n#### OR 操作符\n\n逻辑 OR 操作符 `|` 的优先级高于 AND，因此 `looking for cat | dog | mouse` 表示 `looking for (cat | dog | mouse)`，而不是 `(looking for cat) | dog | mouse`。\n\nCODE_BLOCK_1\n\n注意：没有 `OR` 操作符。请使用 `|` 代替。\n\n### MAYBE 操作符\n\nCODE_BLOCK_2\n\n`MAYBE` 操作符的功能类似于 `|` 操作符，但它不会返回仅匹配右子树表达式的文档。\n\n### 否定操作符\n\nCODE_BLOCK_3\n\n否定操作符强制规则要求某个单词不存在。\n\n默认情况下，不支持仅包含否定的查询。要启用此功能，请使用服务器选项 [not_terms_only_allowed](../../Server_settings/Searchd.md#not_terms_only_allowed)。\n\n### 字段搜索操作符\n\nCODE_BLOCK_4\n\n字段限制操作符将后续搜索限制在指定字段。默认情况下，如果给定的字段名在被搜索的表中不存在，查询将失败并显示错误信息。但是，可以通过在查询开头指定 `@@relaxed` 选项来抑制此行为：\n\nCODE_BLOCK_5\n\n这在搜索具有不同模式的异构表时非常有用。\n\n字段位置限制进一步将搜索限制在给定字段（或字段组）的前 N 个位置。例如，`@body [50] hello` 不会匹配关键词 `hello` 出现在正文中第 51 位或之后的文档。\n\nCODE_BLOCK_6\n\n多字段搜索操作符：\n\nCODE_BLOCK_7\n\n忽略字段搜索操作符（忽略 'title' 字段中 'hello world' 的任何匹配）：\n\nCODE_BLOCK_8\n\n忽略多字段搜索操作符（如果存在字段 'title'、'subject' 和 'body'，则 `@!(title)` 等同于 `@(subject,body)`）：\n\nCODE_BLOCK_9\n\n全字段搜索操作符：\n\nCODE_BLOCK_10\n\n### 短语搜索操作符\n\nCODE_BLOCK_11\n\n短语操作符要求单词必须相邻。\n\n短语搜索操作符可以包含“匹配任一词”修饰符。在短语操作符内，词语的位置是有意义的。当使用“匹配任一词”修饰符时，该短语查询中后续词语的位置将被调整。因此，“匹配任一词”修饰符不会影响搜索性能。\n\nCODE_BLOCK_12\n\n你也可以在引号内使用 OR 操作符。OR 操作符 (`|`) 在短语内使用时必须用括号 `()` 括起来。每个选项都会在相同位置进行检查，如果任一选项匹配该位置，则短语匹配。\n\n**正确示例**（带括号）：\n\nCODE_BLOCK_13\n\n**错误示例**（无括号 - 这些不会生效）：\n\nCODE_BLOCK_14\n\n###  近邻搜索操作符\n\nCODE_BLOCK_15\n\n近邻距离以单词数计量，适用于引号内的所有单词。例如，查询 `\"cat dog mouse\"~5` 表示必须有一个少于 8 个单词的范围包含这 3 个单词。因此，包含 `CAT aaa bbb ccc DOG eee fff MOUSE` 的文档不会匹配此查询，因为该范围正好是 8 个单词长。\n\n你也可以在近邻搜索中使用 OR 操作符。OR 操作符 (`|`) 在近邻搜索内使用时必须用括号 `()` 括起来。每个选项单独检查。\n\n**正确示例**（带括号）：\n\nCODE_BLOCK_16\n\n**错误示例**（无括号 - 这不会生效）：\n\nCODE_BLOCK_17\n\n###  法定人数匹配操作符\n\nCODE_BLOCK_18\n\n法定人数匹配操作符引入了一种模糊匹配类型。它只匹配满足指定单词阈值的文档。在上例（`\"the world is a wonderful place\"/3`）中，它将匹配包含至少 3 个指定单词的所有文档。该操作符限制最多 255 个关键词。你也可以提供一个介于 0.0 和 1.0 之间的值（表示 0% 到 100%），Manticore 将只匹配包含至少指定百分比给定单词的文档。上述示例也可以写成 `\"the world is a wonderful place\"/0.5`，它将匹配包含至少 6 个单词中 50% 的文档。\n\n法定人数操作符支持 OR (`|`) 操作符。OR 操作符 (`|`) 在法定人数匹配中使用时必须用括号 `()` 括起来。每个 OR 组中只有一个单词计入匹配。\n\n**正确示例**（带括号）：\n\nCODE_BLOCK_19\n\n**错误示例**（无括号 - 这不会生效）：\n\nCODE_BLOCK_20\n\n### 严格顺序操作符\n\nCODE_BLOCK_21\n\n严格顺序操作符（也称为“之前”操作符）仅当其参数关键词在文档中严格按照查询中指定的顺序出现时才匹配文档。例如，查询 `black << cat` 会匹配文档 \"black and white cat\"，但不会匹配文档 \"that cat was black\"。顺序操作符优先级最低。它可以应用于单个关键词和更复杂的表达式。例如，以下是一个有效查询：\n\nCODE_BLOCK_22\n\n### 精确形式修饰符\n\nCODE_BLOCK_23\n\n精确形式关键词修饰符仅当关键词以指定的精确形式出现时才匹配文档。默认情况下，如果词干/词形还原后的关键词匹配，则文档被视为匹配。例如，查询 \"runs\" 会匹配包含 \"runs\" 和包含 \"running\" 的文档，因为两者词干均为 \"run\"。但是，`=runs` 查询只会匹配第一个文档。精确形式修饰符需要启用 [index_exact_words](../../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words) 选项。",
      "russian": "# Полнотекстовые операторы\n\nСтрока запроса может включать специальные операторы, которые определяют условия того, как слова из строки запроса должны сопоставляться.\n\n### Булевы операторы\n\n#### Оператор AND\n\nНеявный логический оператор AND всегда присутствует, поэтому \"hello world\" означает, что в совпадающем документе должны быть найдены и \"hello\", и \"world\".\n\nCODE_BLOCK_0\n\nПримечание: явного оператора `AND` нет.\n\n#### Оператор OR\n\nЛогический оператор OR `|` имеет более высокий приоритет, чем AND, поэтому `looking for cat | dog | mouse` означает `looking for (cat | dog | mouse)`, а не `(looking for cat) | dog | mouse`.\n\nCODE_BLOCK_1\n\nПримечание: оператора `OR` нет. Пожалуйста, используйте `|`.\n\n### Оператор MAYBE\n\nCODE_BLOCK_2\n\nОператор `MAYBE` работает аналогично оператору `|`, но не возвращает документы, которые совпадают только с выражением правого поддерева.\n\n### Оператор отрицания\n\nCODE_BLOCK_3\n\nОператор отрицания задаёт правило, что слово не должно присутствовать.\n\nЗапросы, содержащие **только** отрицания, по умолчанию **не поддерживаются**. Чтобы включить поддержку, используйте опцию сервера [not_terms_only_allowed](../../Server_settings/Searchd.md#not_terms_only_allowed).\n\n### Оператор поиска по полю\n\nCODE_BLOCK_4\n\nОператор ограничения поля ограничивает последующий поиск указанным полем. По умолчанию запрос завершится ошибкой, если указанное имя поля отсутствует в таблице поиска. Однако это поведение можно подавить, указав опцию `@@relaxed` в начале запроса:\n\nCODE_BLOCK_5\n\nЭто может быть полезно при поиске по гетерогенным таблицам с разными схемами.\n\nОграничения по позиции в поле дополнительно ограничивают поиск первыми N позициями в указанном поле (или полях). Например, `@body [50] hello` не совпадёт с документами, где ключевое слово `hello` встречается на позиции 51 или позже в поле body.\n\nCODE_BLOCK_6\n\nОператор поиска по нескольким полям:\n\nCODE_BLOCK_7\n\nОператор игнорирования поиска по полю (игнорирует любые совпадения 'hello world' из поля 'title'):\n\nCODE_BLOCK_8\n\nОператор игнорирования поиска по нескольким полям (если есть поля 'title', 'subject' и 'body', то `@!(title)` эквивалентен `@(subject,body)`):\n\nCODE_BLOCK_9\n\nОператор поиска по всем полям:\n\nCODE_BLOCK_10\n\n### Оператор поиска фразы\n\nCODE_BLOCK_11\n\nОператор фразы требует, чтобы слова шли подряд.\n\nОператор поиска фразы может включать модификатор `match any term`. Внутри оператора фразы термины имеют позиционное значение. При использовании модификатора 'match any term' позиции последующих терминов в запросе с фразой будут сдвинуты. В результате модификатор 'match any' не влияет на производительность поиска.\n\nCODE_BLOCK_12\n\nТакже можно использовать оператор OR внутри кавычек. Оператор OR (`|`) должен быть заключён в скобки `()` при использовании внутри фраз. Каждая опция проверяется на той же позиции, и фраза совпадает, если любая из опций подходит для этой позиции.\n\n**Правильные примеры** (со скобками):\n\nCODE_BLOCK_13\n\n**Неправильные примеры** (без скобок — не будут работать):\n\nCODE_BLOCK_14\n\n### Оператор поиска по близости\n\nCODE_BLOCK_15\n\nРасстояние близости измеряется в словах, учитывая количество слов, и применяется ко всем словам в кавычках. Например, запрос `\"cat dog mouse\"~5` означает, что должен быть интервал менее 8 слов, содержащий все 3 слова. Следовательно, документ с `CAT aaa bbb ccc DOG eee fff MOUSE` не совпадёт с этим запросом, так как интервал ровно 8 слов.\n\nТакже можно использовать оператор OR внутри поиска по близости. Оператор OR (`|`) должен быть заключён в скобки `()` при использовании внутри поиска по близости. Каждая опция проверяется отдельно.\n\n**Правильный пример** (со скобками):\n\nCODE_BLOCK_16\n\n**Неправильный пример** (без скобок — не будет работать):\n\nCODE_BLOCK_17\n\n### Оператор кворума\n\nCODE_BLOCK_18\n\nОператор кворума вводит тип нечеткого совпадения. Он будет совпадать только с теми документами, которые удовлетворяют заданному порогу по количеству указанных слов. В приведённом выше примере (`\"the world is a wonderful place\"/3`) он совпадёт со всеми документами, содержащими как минимум 3 из 6 указанных слов. Оператор ограничен 255 ключевыми словами. Вместо абсолютного числа можно указать значение от 0.0 до 1.0 (представляющее 0% и 100%), и Manticore будет совпадать только с документами, содержащими не менее указанного процента данных слов. Тот же пример можно записать как `\"the world is a wonderful place\"/0.5`, и он совпадёт с документами, содержащими не менее 50% из 6 слов.\n\nОператор кворума поддерживает оператор OR (`|`). Оператор OR (`|`) должен быть заключён в скобки `()` при использовании внутри кворума. Для совпадения учитывается только одно слово из каждой группы OR.\n\n**Правильные примеры** (со скобками):\n\nCODE_BLOCK_19\n\n**Неправильный пример** (без скобок — не будет работать):\n\nCODE_BLOCK_20\n\n### Оператор строгого порядка\n\nCODE_BLOCK_21\n\nОператор строгого порядка (также известный как оператор \"before\") совпадает с документом только если ключевые слова аргумента появляются в документе именно в том порядке, который указан в запросе. Например, запрос `black << cat` совпадёт с документом \"black and white cat\", но не с документом \"that cat was black\". Оператор порядка имеет самый низкий приоритет. Его можно применять как к отдельным ключевым словам, так и к более сложным выражениям. Например, это валидный запрос:\n\nCODE_BLOCK_22\n\n### Модификатор точной формы\n\nCODE_BLOCK_23\n\nМодификатор точной формы ключевого слова совпадает с документом только если ключевое слово встречается в точной форме, указанной в запросе. По умолчанию документ считается совпадающим, если совпадает слово в его основе/лемматизированной форме. Например, запрос \"runs\" совпадёт как с документом, содержащим \"runs\", так и с документом, содержащим \"running\", потому что обе формы сводятся к основе \"run\". Однако запрос `=runs` совпадёт только с первым документом. Модификатор точной формы требует включения опции [index_exact_words](../../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words)."
    },
    "is_code_or_comment": false
  },
  "cbbb20d66e331aecec36c891d1e32badbd146042fb6075673dcc58850be92db8": {
    "original": "Another use case is to prevent [expanding](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expand_keywords) a keyword to its `*keyword*` form. For example, with `index_exact_words=1` + `expand_keywords=1/star`, `bcd` will find a document containing `abcde`, but `=bcd` will not.\n\nAs a modifier affecting the keyword, it can be used within operators such as phrase, proximity, and quorum operators. Applying an exact form modifier to the phrase operator is possible, and in this case, it internally adds the exact form modifier to all terms in the phrase.\n\n### Wildcard operators\n\nCODE_BLOCK_24\n\nRequires [min_infix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) for prefix (expansion in trail) and/or suffix (expansion in head). If only prefixing is desired, [min_prefix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_prefix_len) can be used instead.\n\nThe search will attempt to find all expansions of the wildcarded tokens, and each expansion is recorded as a matched hit. The number of expansions for a token can be controlled with the [expansion_limit](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expansion_limit) table setting. Wildcarded tokens can have a significant impact on query search time, especially when tokens have short lengths. In such cases, it is desirable to use the expansion limit.\n\nThe wildcard operator can be automatically applied if the [expand_keywords](../../Searching/Options.md#expand_keywords) table setting is used.\n\nIn addition, the following inline wildcard operators are supported:\n\n* `?` can match any single character: `t?st` will match `test`, but not `teast`\n\n* `%` can match zero or one character: `tes%` will match `tes` or `test`, but not `testing`\n\nThe inline operators require `dict=keywords` (enabled by default) and prefixing/infixing enabled.\n\n### REGEX operator\n\nCODE_BLOCK_25\n\nRequires the [min_infix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) or [min_prefix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_prefix_len) and [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=keywords options to be set (which is a default).\n\nSimilarly to the [wildcard operators](../../Searching/Full_text_matching/Operators.md#Wildcard-operators), the REGEX operator attempts to find all tokens matching the provided pattern, and each expansion is recorded as a matched hit. Note, this can have a significant impact on query search time, as the entire dictionary is scanned, and every term in the dictionary undergoes matching with the REGEX pattern.\n\nThe patterns should adhere to the [RE2 syntax](https://github.com/google/re2/wiki/Syntax). The REGEX expression delimiter is the first symbol after the open bracket. In other words, all text between the open bracket followed by the delimiter and the delimiter and the closed bracket is considered as a RE2 expression.\n\nPlease note that the terms stored in the dictionary undergo `charset_table` transformation, meaning that for example, REGEX may not be able to match uppercase characters if all characters are lowercased according to the `charset_table` (which happens by default). To successfully match a term using a REGEX expression, the pattern must correspond to the entire token. To achieve partial matching, place `.*` at the beginning and/or end of your pattern.\n\nCODE_BLOCK_26\n\n### Field-start and field-end modifier\n\nCODE_BLOCK_27\n\nField-start and field-end keyword modifiers ensure that a keyword only matches if it appears at the very beginning or the very end of a full-text field, respectively. For example, the query `\"^hello world$\"` (enclosed in quotes to combine the phrase operator with the start/end modifiers) will exclusively match documents containing at least one field with these two specific keywords.\n\n### IDF boost modifier\n\nCODE_BLOCK_28\n\nThe boost modifier raises the word [IDF](../../Searching/Options.md#idf)_score by the indicated factor in ranking scores that incorporate IDF into their calculations. It does not impact the matching process in any manner.\n\n### NEAR operator\n\nCODE_BLOCK_29\n\nThe `NEAR` operator is a more generalized version of the proximity operator. Its syntax is `NEAR/N`, which is case-sensitive and does not allow spaces between the `NEAR` keywords, slash sign, and distance value.\n\nWhile the original proximity operator works only on sets of keywords, `NEAR` is more versatile and can accept arbitrary subexpressions as its two arguments. It matches a document when both subexpressions are found within N words of each other, regardless of their order. `NEAR` is left-associative and shares the same (lowest) precedence as [BEFORE](../../Searching/Full_text_matching/Operators.md#Strict-order-operator).\n\nIt is important to note that `one NEAR/7 two NEAR/7 three` is not exactly equivalent to `\"one two three\"~7`. The key difference is that the proximity operator allows up to 6 non-matching words between all three matching words, while the version with `NEAR` is less restrictive: it permits up to 6 words between `one` and `two`, and then up to 6 more between that two-word match and `three`.\n\n### NOTNEAR operator\n\nCODE_BLOCK_30\n\nThe `NOTNEAR` operator serves as a negative assertion. It matches a document when the left argument is present and either the right argument is absent from the document or the right argument is a specified distance away from the end of the left matched argument. The distance is denoted in words. The syntax is `NOTNEAR/N`, which is case-sensitive and does not permit spaces between the `NOTNEAR` keyword, slash sign, and distance value. Both arguments of this operator can be terms or any operators or group of operators.\n\n### SENTENCE and PARAGRAPH operators\n\nCODE_BLOCK_31\n\nCODE_BLOCK_32",
    "translations": {
      "chinese": "另一个用例是防止将[扩展](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expand_keywords)关键字为其`*keyword*`形式。例如，使用`index_exact_words=1` + `expand_keywords=1/star`时，`bcd`将找到包含`abcde`的文档，但`=bcd`则不会。\n\n作为影响关键字的修饰符，它可以在短语、邻近和法定人数操作符等操作符中使用。可以将精确形式修饰符应用于短语操作符，在这种情况下，它会在内部将精确形式修饰符添加到短语中的所有词项。\n\n### 通配符操作符\n\nCODE_BLOCK_24\n\n需要为前缀（尾部扩展）和/或后缀（头部扩展）设置[min_infix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len)。如果只需要前缀，可以改用[min_prefix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_prefix_len)。\n\n搜索将尝试找到通配符词项的所有扩展，每个扩展都被记录为匹配命中。词项的扩展数量可以通过[expansion_limit](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expansion_limit)表设置进行控制。通配符词项可能对查询搜索时间产生显著影响，尤其是当词项长度较短时。在这种情况下，建议使用扩展限制。\n\n如果使用了[expand_keywords](../../Searching/Options.md#expand_keywords)表设置，通配符操作符可以自动应用。\n\n此外，支持以下内联通配符操作符：\n\n* `?` 可以匹配任意单个字符：`t?st`将匹配`test`，但不匹配`teast`\n\n* `%` 可以匹配零个或一个字符：`tes%`将匹配`tes`或`test`，但不匹配`testing`\n\n内联操作符需要启用`dict=keywords`（默认启用）以及前缀/中缀启用。\n\n### REGEX操作符\n\nCODE_BLOCK_25\n\n需要设置[min_infix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len)或[min_prefix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_prefix_len)和[dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=keywords选项（默认设置）。\n\n类似于[通配符操作符](../../Searching/Full_text_matching/Operators.md#Wildcard-operators)，REGEX操作符尝试找到所有匹配提供模式的词项，每个扩展都被记录为匹配命中。请注意，这可能对查询搜索时间产生显著影响，因为会扫描整个字典，字典中的每个词项都要与REGEX模式进行匹配。\n\n模式应遵循[RE2语法](https://github.com/google/re2/wiki/Syntax)。REGEX表达式的定界符是开括号后的第一个符号。换句话说，开括号后跟定界符与定界符和闭括号之间的所有文本都被视为RE2表达式。\n\n请注意，存储在字典中的词项会经过`charset_table`转换，这意味着例如，如果根据`charset_table`（默认情况）将所有字符转换为小写，则REGEX可能无法匹配大写字符。要成功使用REGEX表达式匹配词项，模式必须对应整个词项。要实现部分匹配，请在模式的开头和/或结尾放置`.*`。\n\nCODE_BLOCK_26\n\n### 字段起始和字段结束修饰符\n\nCODE_BLOCK_27\n\n字段起始和字段结束关键字修饰符确保关键字仅在出现在全文字段的最开始或最末尾时匹配。例如，查询`\"^hello world$\"`（用引号括起来以将短语操作符与起始/结束修饰符结合）将仅匹配包含至少一个字段具有这两个特定关键字的文档。\n\n### IDF提升修饰符\n\nCODE_BLOCK_28\n\n提升修饰符通过指定的因子提升包含IDF计算的排名分数中的词项[IDF](../../Searching/Options.md#idf)_分数。它不会以任何方式影响匹配过程。\n\n### NEAR操作符\n\nCODE_BLOCK_29\n\n`NEAR`操作符是邻近操作符的更通用版本。其语法为`NEAR/N`，区分大小写，且`NEAR`关键字、斜杠和距离值之间不允许有空格。\n\n虽然原始邻近操作符仅适用于关键字集合，`NEAR`更灵活，可以接受任意子表达式作为其两个参数。当两个子表达式在文档中相距不超过N个词时，无论顺序如何，均匹配该文档。`NEAR`是左结合的，且与[BEFORE](../../Searching/Full_text_matching/Operators.md#Strict-order-operator)具有相同的（最低）优先级。\n\n需要注意的是，`one NEAR/7 two NEAR/7 three`并不完全等同于`\"one two three\"~7`。关键区别在于邻近操作符允许在三个匹配词之间最多有6个不匹配词，而使用`NEAR`的版本限制较少：它允许`one`和`two`之间最多6个词，然后在该两个词匹配与`three`之间再允许最多6个词。\n\n### NOTNEAR操作符\n\nCODE_BLOCK_30\n\n`NOTNEAR`操作符作为否定断言。当左参数存在且右参数不存在于文档中，或右参数与左匹配参数的结尾相距指定距离时，匹配该文档。距离以词数表示。语法为`NOTNEAR/N`，区分大小写，且`NOTNEAR`关键字、斜杠和距离值之间不允许有空格。该操作符的两个参数可以是词项，也可以是任何操作符或操作符组。\n\n### SENTENCE和PARAGRAPH操作符\n\nCODE_BLOCK_31\n\nCODE_BLOCK_32",
      "russian": "Другой вариант использования — предотвратить [расширение](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expand_keywords) ключевого слова до его формы `*keyword*`. Например, при `index_exact_words=1` + `expand_keywords=1/star`, `bcd` найдет документ, содержащий `abcde`, но `=bcd` — нет.\n\nВ качестве модификатора, влияющего на ключевое слово, он может использоваться внутри операторов, таких как оператор фразы, операторы близости и кворума. Применение модификатора точной формы к оператору фразы возможно, и в этом случае он внутренне добавляет модификатор точной формы ко всем терминам в фразе.\n\n### Операторы подстановочных знаков\n\nCODE_BLOCK_24\n\nТребует [min_infix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) для префикса (расширение в конце) и/или суффикса (расширение в начале). Если требуется только префикс, можно использовать [min_prefix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_prefix_len).\n\nПоиск попытается найти все расширения токенов с подстановочными знаками, и каждое расширение фиксируется как совпавшее попадание. Количество расширений для токена можно контролировать с помощью настройки таблицы [expansion_limit](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expansion_limit). Токены с подстановочными знаками могут значительно влиять на время поиска запроса, особенно когда токены имеют короткую длину. В таких случаях желательно использовать ограничение расширения.\n\nОператор подстановочного знака может применяться автоматически, если используется настройка таблицы [expand_keywords](../../Searching/Options.md#expand_keywords).\n\nКроме того, поддерживаются следующие встроенные операторы подстановочных знаков:\n\n* `?` может соответствовать любому одному символу: `t?st` совпадет с `test`, но не с `teast`\n\n* `%` может соответствовать нулю или одному символу: `tes%` совпадет с `tes` или `test`, но не с `testing`\n\nВстроенные операторы требуют `dict=keywords` (включено по умолчанию) и включенного префиксного/инфиксного поиска.\n\n### Оператор REGEX\n\nCODE_BLOCK_25\n\nТребует установки опций [min_infix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) или [min_prefix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_prefix_len) и [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=keywords (что является значением по умолчанию).\n\nАналогично [операторам подстановочных знаков](../../Searching/Full_text_matching/Operators.md#Wildcard-operators), оператор REGEX пытается найти все токены, соответствующие заданному шаблону, и каждое расширение фиксируется как совпавшее попадание. Обратите внимание, что это может значительно повлиять на время поиска запроса, так как сканируется весь словарь, и каждый термин в словаре проверяется на соответствие шаблону REGEX.\n\nШаблоны должны соответствовать [синтаксису RE2](https://github.com/google/re2/wiki/Syntax). Разделителем выражения REGEX является первый символ после открывающей скобки. Другими словами, весь текст между открывающей скобкой с последующим разделителем и разделителем с закрывающей скобкой считается выражением RE2.\n\nОбратите внимание, что термины, хранящиеся в словаре, подвергаются преобразованию `charset_table`, что означает, например, что REGEX может не совпадать с заглавными символами, если все символы приведены к нижнему регистру согласно `charset_table` (что происходит по умолчанию). Чтобы успешно сопоставить термин с помощью выражения REGEX, шаблон должен соответствовать всему токену. Для частичного совпадения поместите `.*` в начале и/или в конце вашего шаблона.\n\nCODE_BLOCK_26\n\n### Модификатор начала и конца поля\n\nCODE_BLOCK_27\n\nМодификаторы ключевых слов начала и конца поля гарантируют, что ключевое слово совпадает только если оно появляется в самом начале или самом конце поля полнотекстового поиска соответственно. Например, запрос `\"^hello world$\"` (в кавычках, чтобы объединить оператор фразы с модификаторами начала/конца) будет совпадать исключительно с документами, содержащими хотя бы одно поле с этими двумя конкретными ключевыми словами.\n\n### Модификатор усиления IDF\n\nCODE_BLOCK_28\n\nМодификатор усиления повышает значение [IDF](../../Searching/Options.md#idf)_оценки слова на указанный коэффициент в рейтинговых оценках, которые включают IDF в свои вычисления. Он не влияет на процесс сопоставления.\n\n### Оператор NEAR\n\nCODE_BLOCK_29\n\nОператор `NEAR` является более общей версией оператора близости. Его синтаксис — `NEAR/N`, чувствителен к регистру и не допускает пробелов между ключевым словом `NEAR`, знаком слэша и значением расстояния.\n\nВ то время как исходный оператор близости работает только с наборами ключевых слов, `NEAR` более универсален и может принимать произвольные подвыражения в качестве своих двух аргументов. Он совпадает с документом, когда оба подвыражения найдены в пределах N слов друг от друга, независимо от их порядка. `NEAR` является левосторонне ассоциативным и имеет такой же (низший) приоритет, как и [BEFORE](../../Searching/Full_text_matching/Operators.md#Strict-order-operator).\n\nВажно отметить, что `one NEAR/7 two NEAR/7 three` не совсем эквивалентно `\"one two three\"~7`. Ключевое отличие в том, что оператор близости допускает до 6 слов, не совпадающих между всеми тремя совпадающими словами, тогда как версия с `NEAR` менее ограничительна: она позволяет до 6 слов между `one` и `two`, а затем еще до 6 между этим двухсловным совпадением и `three`.\n\n### Оператор NOTNEAR\n\nCODE_BLOCK_30\n\nОператор `NOTNEAR` служит отрицательным утверждением. Он совпадает с документом, когда левый аргумент присутствует, а правый аргумент либо отсутствует в документе, либо находится на указанном расстоянии от конца совпавшего левого аргумента. Расстояние указывается в словах. Синтаксис — `NOTNEAR/N`, чувствителен к регистру и не допускает пробелов между ключевым словом `NOTNEAR`, знаком слэша и значением расстояния. Оба аргумента этого оператора могут быть терминами или любыми операторами либо группами операторов.\n\n### Операторы SENTENCE и PARAGRAPH\n\nCODE_BLOCK_31\n\nCODE_BLOCK_32"
    },
    "is_code_or_comment": false
  },
  "1459da81af8af095823ce87ac26a8b82d83d7b1021f635d5b1ad3a2a4b09b837": {
    "original": "Note: When using this operator with queries containing more than 31 keywords, ranking statistics (such as `tf`, `idf`, `bm25`) for keywords at position 31 and above may be under-counted. This is due to a 32-bit mask used internally to track term occurrences within a match. Matching logic (finding documents) remains correct, but ranking scores may be affected for very long queries.\n\n### NOTNEAR operator\n\nCODE_BLOCK_30\n\nThe `NOTNEAR` operator serves as a negative assertion. It matches a document when the left argument is present and either the right argument is absent from the document or the right argument is a specified distance away from the end of the left matched argument. The distance is denoted in words. The syntax is `NOTNEAR/N`, which is case-sensitive and does not permit spaces between the `NOTNEAR` keyword, slash sign, and distance value. Both arguments of this operator can be terms or any operators or group of operators.\n\n### SENTENCE and PARAGRAPH operators\n\nCODE_BLOCK_31\n\nCODE_BLOCK_32\n\nThe `SENTENCE` and `PARAGRAPH` operators match a document when both of their arguments are within the same sentence or the same paragraph of text, respectively. These arguments can be keywords, phrases, or instances of the same operator.\n\nThe order of the arguments within the sentence or paragraph is irrelevant. These operators function only with tables built with [index_sp](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_sp) (sentence and paragraph indexing feature) enabled and revert to a simple AND operation otherwise. For information on what constitutes a sentence and a paragraph, refer to the [index_sp](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_sp) directive documentation.\n\n### ZONE limit operator\n\nCODE_BLOCK_33\n\nThe `ZONE limit` operator closely resembles the field limit operator but limits matching to a specified in-field zone or a list of zones. It is important to note that subsequent subexpressions do not need to match within a single continuous span of a given zone and may match across multiple spans. For example, the query `(ZONE:th hello world)` will match the following sample document:\n\nCODE_BLOCK_34\n\nThe `ZONE` operator affects the query until the next field or `ZONE` limit operator, or until the closing parenthesis. It functions exclusively with tables built with zone support (refer to [index_zones](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_zones)) and will be disregarded otherwise.\n\n### ZONESPAN limit operator\n\nCODE_BLOCK_35\n\nThe `ZONESPAN` limit operator resembles the `ZONE` operator but mandates that the match occurs within a single continuous span. In the example provided earlier, `ZONESPAN:th hello world` would not match the document, as \"hello\" and \"world\" do not appear within the same span.\n\n<!-- proofread -->",
    "translations": {
      "chinese": "注意：当使用此运算符处理包含超过31个关键词的查询时，位置在31及以上的关键词的排名统计（如`tf`、`idf`、`bm25`）可能会被低估。这是由于内部使用了32位掩码来跟踪匹配项中的项目出现情况。匹配逻辑（查找文档）仍然正确，但对于非常长的查询，排名分数可能会受到影响。\n\n### NOTNEAR运算符\n\nCODE_BLOCK_30\n\n`NOTNEAR`运算符作为一个负向断言。当左参数存在，且右参数要么在文档中不存在，要么距离左匹配参数末尾指定的单词数时，匹配一个文档。距离以单词数表示。语法为`NOTNEAR/N`，区分大小写，且不允许在`NOTNEAR`关键词、斜杠符号和距离值之间有空格。此运算符的两个参数可以是项或任何运算符或运算符组。\n\n### SENTENCE和PARAGRAPH运算符\n\nCODE_BLOCK_31\n\nCODE_BLOCK_32\n\n`SENTENCE`和`PARAGRAPH`运算符在两个参数位于同一句子或同一段落时匹配文档。这些参数可以是关键词、短语或相同运算符的实例。\n\n参数在句子或段落中的顺序无关紧要。这些运算符仅在使用[index_sp](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_sp)（句子和段落索引功能）构建的表中有效，否则将恢复为简单的AND操作。关于什么构成句子和段落的信息，请参考[index_sp](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_sp)指令文档。\n\n### ZONE限制运算符\n\nCODE_BLOCK_33\n\n`ZONE限制`运算符与字段限制运算符非常相似，但限制匹配到指定的内部字段区域或区域列表。需要注意的是，后续子表达式不需要在给定区域的单一连续跨度内匹配，可以跨越多个跨度。例如，查询`(ZONE:th hello world)`将匹配以下示例文档：\n\nCODE_BLOCK_34\n\n`ZONE`运算符影响查询直到下一个字段或`ZONE`限制运算符，或直到右括号。它仅在使用区域支持（参考[index_zones](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_zones)）构建的表中有效，否则将被忽略。\n\n### ZONESPAN限制运算符\n\nCODE_BLOCK_35\n\n`ZONESPAN`限制运算符类似于`ZONE`运算符，但要求匹配发生在单一连续跨度内。在前面的示例中，`ZONESPAN:th hello world`将不匹配该文档，因为\"hello\"和\"world\"未出现在同一跨度中。\n\n<!-- proofread -->",
      "russian": "Примечание: При использовании этого оператора в запросах, содержащих более 31 ключевого слова, статистика ранжирования (такая как `tf`, `idf`, `bm25`) для ключевых слов в позиции 31 и выше может быть занижена. Это связано с 32-битной маской, используемой внутренне для отслеживания вхождений терминов в совпадении. Логика сопоставления (поиск документов) остается корректной, но оценки ранжирования могут быть затронуты для очень длинных запросов.\n\n### Оператор NOTNEAR\n\nCODE_BLOCK_30\n\nОператор `NOTNEAR` служит для отрицательного утверждения. Он находит документ, когда левый аргумент присутствует, а правый аргумент либо отсутствует в документе, либо находится на указанном расстоянии от конца левого совпавшего аргумента. Расстояние указывается в словах. Синтаксис — `NOTNEAR/N`, который чувствителен к регистру и не допускает пробелов между ключевым словом `NOTNEAR`, знаком косой черты и значением расстояния. Оба аргумента этого оператора могут быть терминами, операторами или группами операторов.\n\n### Операторы SENTENCE и PARAGRAPH\n\nCODE_BLOCK_31\n\nCODE_BLOCK_32\n\nОператоры `SENTENCE` и `PARAGRAPH` находят документ, когда оба их аргумента находятся в одном предложении или в одном абзаце текста соответственно. Этими аргументами могут быть ключевые слова, фразы или экземпляры того же оператора.\n\nПорядок аргументов внутри предложения или абзаца не имеет значения. Эти операторы работают только с таблицами, построенными с включенной функцией [index_sp](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_sp) (индексирование предложений и абзацев), в противном случае они вырождаются в простую операцию И. Информацию о том, что считается предложением и абзацем, см. в документации по директиве [index_sp](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_sp).\n\n### Оператор ограничения зоны\n\nCODE_BLOCK_33\n\nОператор `ZONE limit` очень похож на оператор ограничения поля, но ограничивает сопоставление указанной зоной внутри поля или списком зон. Важно отметить, что последующие подвыражения не обязательно должны совпадать в пределах одного непрерывного участка данной зоны и могут совпадать в разных участках. Например, запрос `(ZONE:th hello world)` найдет следующий образец документа:\n\nCODE_BLOCK_34\n\nОператор `ZONE` влияет на запрос до следующего оператора ограничения поля или зоны либо до закрывающей скобки. Он работает исключительно с таблицами, построенными с поддержкой зон (см. [index_zones](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_zones)), в противном случае будет проигнорирован.\n\n### Оператор ограничения ZONESPAN\n\nCODE_BLOCK_35\n\nОператор `ZONESPAN limit` похож на оператор `ZONE`, но требует, чтобы совпадение происходило в пределах одного непрерывного участка. В приведенном ранее примере `ZONESPAN:th hello world` не найдет документ, поскольку слова \"hello\" и \"world\" не находятся в одном участке.\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "6448277157f8e387d4e51752cc79ff6c1cd6f76efba899924406b98f53ff53fa": {
    "original": "### Exact form modifier\n\nCODE_BLOCK_23\n\nThe exact form keyword modifier matches a document only if the keyword appears in the exact form specified. By default, a document is considered a match if the stemmed/lemmatized keyword matches. For instance, the query \"runs\" will match both a document containing \"runs\" and one containing \"running\", because both forms stem to just \"run\". However, the `=runs` query will only match the first document. The exact form modifier requires the [index_exact_words](../../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words) option to be enabled.\n\nAnother use case is to prevent [expanding](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expand_keywords) a keyword to its `*keyword*` form. For example, with `index_exact_words=1` + `expand_keywords=1/star`, `bcd` will find a document containing `abcde`, but `=bcd` will not.\n\nAs a modifier affecting the keyword, it can be used within operators such as phrase, proximity, and quorum operators. Applying an exact form modifier to the phrase operator is possible, and in this case, it internally adds the exact form modifier to all terms in the phrase.\n\n### Wildcard operators\n\nCODE_BLOCK_24\n\nRequires [min_infix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) for prefix (expansion in trail) and/or suffix (expansion in head). If only prefixing is desired, [min_prefix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_prefix_len) can be used instead.\n\nThe search will attempt to find all expansions of the wildcarded tokens, and each expansion is recorded as a matched hit. The number of expansions for a token can be controlled with the [expansion_limit](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expansion_limit) table setting. Wildcarded tokens can have a significant impact on query search time, especially when tokens have short lengths. In such cases, it is desirable to use the expansion limit.\n\nThe wildcard operator can be automatically applied if the [expand_keywords](../../Searching/Options.md#expand_keywords) table setting is used.\n\nIn addition, the following inline wildcard operators are supported:\n\n* `?` can match any single character: `t?st` will match `test`, but not `teast`\n\n* `%` can match zero or one character: `tes%` will match `tes` or `test`, but not `testing`\n\nThe inline operators require `dict=keywords` (enabled by default) and prefixing/infixing enabled.\n\n### REGEX operator\n\nCODE_BLOCK_25\n\nRequires the [min_infix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) or [min_prefix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_prefix_len) and [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=keywords options to be set (which is a default).\n\nSimilarly to the [wildcard operators](../../Searching/Full_text_matching/Operators.md#Wildcard-operators), the REGEX operator attempts to find all tokens matching the provided pattern, and each expansion is recorded as a matched hit. Note, this can have a significant impact on query search time, as the entire dictionary is scanned, and every term in the dictionary undergoes matching with the REGEX pattern.\n\nThe patterns should adhere to the [RE2 syntax](https://github.com/google/re2/wiki/Syntax). The REGEX expression delimiter is the first symbol after the open bracket. In other words, all text between the open bracket followed by the delimiter and the delimiter and the closed bracket is considered as a RE2 expression.\n\nPlease note that the terms stored in the dictionary undergo `charset_table` transformation, meaning that for example, REGEX may not be able to match uppercase characters if all characters are lowercased according to the `charset_table` (which happens by default). To successfully match a term using a REGEX expression, the pattern must correspond to the entire token. To achieve partial matching, place `.*` at the beginning and/or end of your pattern.\n\nCODE_BLOCK_26\n\n### Field-start and field-end modifier\n\nCODE_BLOCK_27\n\nField-start and field-end keyword modifiers ensure that a keyword only matches if it appears at the very beginning or the very end of a full-text field, respectively. For example, the query `\"^hello world$\"` (enclosed in quotes to combine the phrase operator with the start/end modifiers) will exclusively match documents containing at least one field with these two specific keywords.\n\n### IDF boost modifier\n\nCODE_BLOCK_28\n\nThe boost modifier raises the word [IDF](../../Searching/Options.md#idf)_score by the indicated factor in ranking scores that incorporate IDF into their calculations. It does not impact the matching process in any manner.\n\n### NEAR operator\n\nCODE_BLOCK_29\n\nThe `NEAR` operator is a more generalized version of the proximity operator. Its syntax is `NEAR/N`, which is case-sensitive and does not allow spaces between the `NEAR` keywords, slash sign, and distance value.\n\nWhile the original proximity operator works only on sets of keywords, `NEAR` is more versatile and can accept arbitrary subexpressions as its two arguments. It matches a document when both subexpressions are found within N words of each other, regardless of their order. `NEAR` is left-associative and shares the same (lowest) precedence as [BEFORE](../../Searching/Full_text_matching/Operators.md#Strict-order-operator).\n\nIt is important to note that `one NEAR/7 two NEAR/7 three` is not exactly equivalent to `\"one two three\"~7`. The key difference is that the proximity operator allows up to 6 non-matching words between all three matching words, while the version with `NEAR` is less restrictive: it permits up to 6 words between `one` and `two`, and then up to 6 more between that two-word match and `three`.",
    "translations": {
      "chinese": "### 精确形式修饰符\n\nCODE_BLOCK_23\n\n精确形式关键词修饰符仅在关键词以指定的确切形式出现时才匹配文档。默认情况下，如果关键词的词干/词形还原匹配，则认为文档是匹配的。例如，查询\"runs\"将同时匹配包含\"runs\"和\"running\"的文档，因为两者的词干都是\"run\"。但是，`=runs`查询将仅匹配第一个文档。精确形式修饰符要求启用 [index_exact_words](../../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words) 选项。\n\n另一个用例是防止将关键词扩展为 `*keyword*` 形式。例如，使用 `index_exact_words=1` + `expand_keywords=1/star`，`bcd` 将查找包含 `abcde` 的文档，但 `=bcd` 不会。\n\n作为影响关键词的修饰符，它可以在短语、邻近性和仲裁运算符等运算符中使用。可以对短语运算符应用精确形式修饰符，在这种情况下，它会在内部为短语中的所有项添加精确形式修饰符。\n\n### 通配符运算符\n\nCODE_BLOCK_24\n\n需要 [min_infix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) 来进行前缀（尾部扩展）和/或后缀（头部扩展）。如果只需要前缀，可以使用 [min_prefix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_prefix_len)。\n\n搜索将尝试查找所有通配符标记的扩展，并将每个扩展记录为匹配命中。可以使用 [expansion_limit](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expansion_limit) 表设置控制标记的扩展次数。通配符标记可能对查询搜索时间有显著影响，尤其是当标记长度较短时。在这种情况下，使用扩展限制是可取的。\n\n如果使用 [expand_keywords](../../Searching/Options.md#expand_keywords) 表设置，通配符运算符可以自动应用。\n\n此外，还支持以下内联通配符运算符：\n\n* `?` 可以匹配任何单个字符：`t?st` 将匹配 `test`，但不匹配 `teast`\n\n* `%` 可以匹配零个或一个字符：`tes%` 将匹配 `tes` 或 `test`，但不匹配 `testing`\n\n内联运算符需要 `dict=keywords`（默认启用）和启用前缀/中缀。\n\n### REGEX运算符\n\nCODE_BLOCK_25\n\n需要设置 [min_infix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) 或 [min_prefix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_prefix_len) 和 [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=keywords 选项（这是默认设置）。\n\n与[通配符运算符](../../Searching/Full_text_matching/Operators.md#Wildcard-operators)类似，REGEX运算符尝试查找所有匹配提供的模式的标记，并将每个扩展记录为匹配命中。请注意，这可能对查询搜索时间产生显著影响，因为需要扫描整个词典，并且词典中的每个术语都要与REGEX模式匹配。\n\n模式应遵循 [RE2 语法](https://github.com/google/re2/wiki/Syntax)。REGEX表达式分隔符是开括号后的第一个符号。换句话说，开括号后的分隔符和分隔符与闭括号之间的所有文本都被视为RE2表达式。\n\n请注意，存储在词典中的术语会经过 `charset_table` 转换，这意味着例如，如果根据 `charset_table`（默认情况下）将所有字符转换为小写，则REGEX可能无法匹配大写字符。要使用REGEX表达式成功匹配术语，模式必须对应整个标记。要实现部分匹配，请在模式的开头和/或结尾放置 `.*`。\n\nCODE_BLOCK_26\n\n### 字段起始和字段结束修饰符\n\nCODE_BLOCK_27\n\n字段起始和字段结束关键词修饰符确保关键词仅在全文字段的开头或结尾处匹配。例如，查询 `\"^hello world$\"`（用引号括起来以将短语运算符与起始/结束修饰符结合）将只匹配包含至少一个具有这两个特定关键词的字段的文档。\n\n### IDF提升修饰符\n\nCODE_BLOCK_28\n\n提升修饰符通过指定的因子提高词语的 [IDF](../../Searching/Options.md#idf) 分数，以纳入 IDF 的排名分数计算中。它不会以任何方式影响匹配过程。\n\n### NEAR运算符\n\nCODE_BLOCK_29\n\n`NEAR` 运算符是邻近运算符的更通用版本。其语法是 `NEAR/N`，区分大小写，并且 `NEAR` 关键词、斜杠符号和距离值之间不允许有空格。\n\n虽然原始邻近运算符仅适用于关键词集合，但 `NEAR` 更加通用，可以接受任意子表达式作为其两个参数。当两个子表达式在 N 个词以内找到时，无论其顺序如何，它都匹配一个文档。`NEAR` 是左结合的，并且与 [BEFORE](../../Searching/Full_text_matching/Operators.md#Strict-order-operator) 共享相同的（最低）优先级。\n\n需要注意的是，`one NEAR/7 two NEAR/7 three` 不完全等同于 `\"one two three\"~7`。关键区别在于，邻近运算符允许在所有三个匹配词之间最多有6个非匹配词，而带有 `NEAR` 的版本限制较少：它允许 `one` 和 `two` 之间最多6个词，然后在该两词匹配和 `three` 之间再允许最多6个词。",
      "russian": "### Точный модификатор формы\n\nCODE_BLOCK_23\n\nКлючевое слово точного модификатора формы сопоставляет документ только в том случае, если ключевое слово встречается в точно указанной форме. По умолчанию документ считается совпадающим, если стемминговое/лемматизированное ключевое слово совпадает. Например, запрос \"runs\" будет соответствовать как документу, содержащему \"runs\", так и содержащему \"running\", поскольку обе формы стемируются до \"run\". Однако запрос `=runs` будет соответствовать только первому документу. Точный модификатор формы требует включения параметра [index_exact_words](../../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words).\n\nДругой вариант использования - предотвращение [расширения](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expand_keywords) ключевого слова до его формы `*keyword*`. Например, при `index_exact_words=1` + `expand_keywords=1/star`, `bcd` найдет документ, содержащий `abcde`, а `=bcd` - нет.\n\nКак модификатор, влияющий на ключевое слово, он может использоваться внутри операторов, таких как фразовый, proximity и кворумный операторы. Применение точного модификатора формы к фразовому оператору возможно, и в этом случае он внутренне добавляет точный модификатор формы ко всем терминам в фразе.\n\n### Операторы подстановки\n\nCODE_BLOCK_24\n\nТребует [min_infix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) для префикса (расширение в конце) и/или суффикса (расширение в начале). Если требуется только префиксация, можно использовать [min_prefix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_prefix_len).\n\nПоиск попытается найти все расширения токенов с подстановочными знаками, и каждое расширение записывается как найденное совпадение. Количество расширений для токена можно контролировать с помощью параметра таблицы [expansion_limit](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expansion_limit). Токены с подстановочными знаками могут существенно влиять на время поиска запроса, особенно когда токены имеют небольшую длину. В таких случаях желательно использовать ограничение расширения.\n\nОператор подстановочных знаков может быть автоматически применен при использовании параметра таблицы [expand_keywords](../../Searching/Options.md#expand_keywords).\n\nКроме того, поддерживаются следующие встроенные операторы подстановочных знаков:\n\n* `?` может соответствовать любому одному символу: `t?st` будет соответствовать `test`, но не `teast`\n\n* `%` может соответствовать нулю или одному символу: `tes%` будет соответствовать `tes` или `test`, но не `testing`\n\nВстроенные операторы требуют `dict=keywords` (включено по умолчанию) и включенной префиксации/инфиксации.\n\n### Оператор REGEX\n\nCODE_BLOCK_25\n\nТребует установки параметров [min_infix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) или [min_prefix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_prefix_len) и [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=keywords (что является настройкой по умолчанию).\n\nПодобно [операторам подстановочных знаков](../../Searching/Full_text_matching/Operators.md#Wildcard-operators), оператор REGEX пытается найти все токены, соответствующие указанному шаблону, и каждое расширение записывается как найденное совпадение. Обратите внимание, что это может существенно повлиять на время поиска запроса, так как сканируется весь словарь, и каждый термин в словаре проходит сопоставление с шаблоном REGEX.\n\nШаблоны должны соответствовать синтаксису [RE2](https://github.com/google/re2/wiki/Syntax). Разделитель выражения REGEX - первый символ после открывающей скобки. Другими словами, весь текст между открывающей скобкой, за которой следует разделитель, и разделителем и закрывающей скобкой считается выражением RE2.\n\nОбратите внимание, что термины, хранящиеся в словаре, проходят преобразование `charset_table`, что означает, например, REGEX может не суметь сопоставить прописные буквы, если все символы преобразованы в строчные согласно `charset_table` (что происходит по умолчанию). Чтобы успешно сопоставить термин с помощью выражения REGEX, шаблон должен соответствовать всему токену. Для достижения частичного сопоставления поместите `.*` в начало и/или конец вашего шаблона.\n\nCODE_BLOCK_26\n\n### Модификатор начала и конца поля\n\nCODE_BLOCK_27\n\nМодификаторы ключевого слова начала и конца поля гарантируют, что ключевое слово будет соответствовать только в том случае, если оно встречается в самом начале или в самом конце полнотекстового поля соответственно. Например, запрос `\"^hello world$\"` (заключенный в кавычки для объединения фразового оператора с модификаторами начала/конца) будет исключительно соответствовать документам, содержащим хотя бы одно поле с этими двумя конкретными ключевыми словами.\n\n### Модификатор усиления IDF\n\nCODE_BLOCK_28\n\nМодификатор усиления повышает [IDF](../../Searching/Options.md#idf)_score на указанный коэффициент при вычислении оценок ранжирования, включающих IDF. Он не влияет на процесс сопоставления никоим образом.\n\n### Оператор NEAR\n\nCODE_BLOCK_29\n\nОператор `NEAR` является более обобщенной версией proximity-оператора. Его синтаксис - `NEAR/N`, который чувствителен к регистру и не допускает пробелов между ключевыми словами `NEAR`, знаком косой черты и значением расстояния.\n\nЕсли исходный proximity-оператор работает только с наборами ключевых слов, `NEAR` является более универсальным и может принимать произвольные подвыражения в качестве своих двух аргументов. Он сопоставляет документ, когда оба подвыражения находятся в пределах N слов друг от друга, независимо от их порядка. `NEAR` левоассоциативен и имеет такой же (самый низкий) приоритет, как и [BEFORE](../../Searching/Full_text_matching/Operators.md#Strict-order-operator).\n\nВажно отметить, что `one NEAR/7 two NEAR/7 three` не совсем эквивалентен `\"one two three\"~7`. Ключевое различие заключается в том, что proximity-оператор допускает до 6 несовпадающих слов между всеми тремя совпадающими словами, в то время как версия с `NEAR` менее ограничительна: она допускает до 6 слов между `one` и `two`, а затем еще до 6 между этим двухсловным совпадением и `three`."
    },
    "is_code_or_comment": false
  },
  "e56fc5e2870bbf8463a06234f01f97fa0a2de337f4205fdc6a9430fb588c9d1e": {
    "original": "# Full text operators\n\nThe query string can include specific operators that define the conditions for how the words from the query string should be matched.\n\n### Boolean operators\n\n#### AND operator\n\nAn implicit logical AND operator is always present, so \"hello world\" implies that both \"hello\" and \"world\" must be found in the matching document.\n\nCODE_BLOCK_0\n\nNote: There is no explicit `AND` operator.\n\n#### OR operator\n\nThe logical OR operator `|` has a higher precedence than AND, so `looking for cat | dog | mouse` means `looking for (cat | dog | mouse)` rather than `(looking for cat) | dog | mouse`.\n\nCODE_BLOCK_1\n\nNote: There is no operator `OR`. Please use `|` instead.\n\n### MAYBE operator\n\nCODE_BLOCK_2\n\nThe `MAYBE` operator functions similarly to the `|` operator, but it does not return documents that match only the right subtree expression.\n\n### Negation operator\n\nCODE_BLOCK_3\n\nThe negation operator enforces a rule for a word to not exist.\n\nQueries containing **only** negations are **not** supported by default. To enable, use the server option [not_terms_only_allowed](../../Server_settings/Searchd.md#not_terms_only_allowed).\n\n### Field search operator\n\nCODE_BLOCK_4\n\nThe field limit operator restricts subsequent searches to a specified field. By default, the query will fail with an error message if the given field name does not exist in the searched table. However, this behavior can be suppressed by specifying the `@@relaxed` option at the beginning of the query:\n\nCODE_BLOCK_5\n\nThis can be useful when searching through heterogeneous tables with different schemas.\n\nField position limits additionally constrain the search to the first N positions within a given field (or fields). For example, `@body [50] hello` will not match documents where the keyword `hello` appears at position 51 or later in the body.\n\nCODE_BLOCK_6\n\nMultiple-field search operator:\n\nCODE_BLOCK_7\n\nIgnore field search operator (ignores any matches of 'hello world' from the 'title' field):\n\nCODE_BLOCK_8\n\nIgnore multiple-field search operator (if there are fields 'title', 'subject', and 'body', then `@!(title)` is equivalent to `@(subject,body)`):\n\nCODE_BLOCK_9\n\nAll-field search operator:\n\nCODE_BLOCK_10\n\n### Phrase search operator\n\nCODE_BLOCK_11\n\nThe phrase operator mandates that the words be adjacent to each other.\n\nThe phrase search operator can include a `match any term` modifier. Within the phrase operator, terms are positionally significant. When the 'match any term' modifier is employed, the positions of the subsequent terms in that phrase query will be shifted. As a result, the 'match any' modifier does not affect search performance.\n\nNote: When using this operator with queries containing more than 31 keywords, ranking statistics (such as `tf`, `idf`, `bm25`) for keywords at position 31 and above may be under-counted. This is due to a 32-bit mask used internally to track term occurrences within a match. Matching logic (finding documents) remains correct, but ranking scores may be affected for very long queries.\n\nCODE_BLOCK_12\n\nYou can also use the OR operator inside the quotes. The OR operator (`|`) must be enclosed in brackets `()` when used inside phrases. Each option is checked at the same position, and the phrase matches if any of the options fit that position.\n\n**Correct examples** (with brackets):\n\nCODE_BLOCK_13\n\n**Incorrect examples** (without brackets - these won't work):\n\nCODE_BLOCK_14\n\n###  Proximity search operator\n\nCODE_BLOCK_15\n\nProximity distance is measured in words, accounting for word count, and applies to all words within quotes. For example, the query `\"cat dog mouse\"~5` indicates that there must be a span of fewer than 8 words containing all 3 words. Therefore, a document with `CAT aaa bbb ccc DOG eee fff MOUSE` will not match this query, as the span is exactly 8 words long.\n\nNote: When using this operator with queries containing more than 31 keywords, ranking statistics (such as `tf`, `idf`, `bm25`) for keywords at position 31 and above may be under-counted. This is due to a 32-bit mask used internally to track term occurrences within a match. Matching logic (finding documents) remains correct, but ranking scores may be affected for very long queries.\n\nYou can also use the OR operator inside a proximity search. The OR operator (`|`) must be enclosed in brackets `()` when used inside proximity searches. Each option is checked separately.\n\n**Correct example** (with brackets):\n\nCODE_BLOCK_16\n\n**Incorrect example** (without brackets - this won't work):\n\nCODE_BLOCK_17\n\n###  Quorum matching operator\n\nCODE_BLOCK_18\n\nThe quorum matching operator introduces a type of fuzzy matching. It will match only those documents that meet a given threshold of specified words. In the example above (`\"the world is a wonderful place\"/3`), it will match all documents containing at least 3 of the 6 specified words. The operator is limited to 255 keywords. Instead of an absolute number, you can also provide a value between 0.0 and 1.0 (representing 0% and 100%), and Manticore will match only documents containing at least the specified percentage of the given words. The same example above could also be expressed as `\"the world is a wonderful place\"/0.5`, and it would match documents with at least 50% of the 6 words.\n\nThe quorum operator supports the OR (`|`) operator. The OR operator (`|`) must be enclosed in brackets `()` when used inside quorum matching. Only one word from each OR group counts toward the match.\n\n**Correct examples** (with brackets):\n\nCODE_BLOCK_19\n\n**Incorrect example** (without brackets - this won't work):\n\nCODE_BLOCK_20\n\n### Strict order operator\n\nCODE_BLOCK_21\n\nThe strict order operator (also known as the \"before\" operator) matches a document only if its argument keywords appear in the document precisely in the order specified in the query. For example, the query `black << cat` will match the document \"black and white cat\" but not the document \"that cat was black\". The order operator has the lowest priority. It can be applied to both individual keywords and more complex expressions. For instance, this is a valid query:\n\nCODE_BLOCK_22",
    "translations": {
      "chinese": "# 全文检索运算符\n\n查询字符串可以包含特定的运算符，这些运算符定义了如何匹配查询字符串中的单词的条件。\n\n### 布尔运算符\n\n#### AND 运算符\n\n隐式的逻辑 AND 运算符始终存在，因此 \"hello world\" 意味着必须在匹配的文档中同时找到 \"hello\" 和 \"world\"。\n\nCODE_BLOCK_0\n\n注意：没有显式的 `AND` 运算符。\n\n#### OR 运算符\n\n逻辑 OR 运算符 `|` 的优先级高于 AND，因此 `looking for cat | dog | mouse` 表示 `looking for (cat | dog | mouse)` 而不是 `(looking for cat) | dog | mouse`。\n\nCODE_BLOCK_1\n\n注意：没有 `OR` 运算符。请改用 `|`。\n\n### MAYBE 运算符\n\nCODE_BLOCK_2\n\n`MAYBE` 运算符的功能类似于 `|` 运算符，但它不会返回仅匹配右子树表达式的文档。\n\n### 否定运算符\n\nCODE_BLOCK_3\n\n否定运算符强制执行单词不存在的规则。\n\n默认情况下，**仅**包含否定的查询是**不**支持的。要启用，请使用服务器选项 [not_terms_only_allowed](../../Server_settings/Searchd.md#not_terms_only_allowed)。\n\n### 字段搜索运算符\n\nCODE_BLOCK_4\n\n字段限制运算符将后续搜索限制在指定的字段。默认情况下，如果给定的字段名在搜索的表中不存在，查询将失败并显示错误消息。但是，可以通过在查询开头指定 `@@relaxed` 选项来抑制此行为：\n\nCODE_BLOCK_5\n\n这在搜索具有不同架构的异构表时很有用。\n\n字段位置限制还可以将搜索进一步限制在给定字段内的前 N 个位置。例如，`@body [50] hello` 将不会匹配关键字 `hello` 出现在正文第 51 位或之后的文档。\n\nCODE_BLOCK_6\n\n多字段搜索运算符：\n\nCODE_BLOCK_7\n\n忽略字段搜索运算符（忽略 'title' 字段中 'hello world' 的任何匹配）：\n\nCODE_BLOCK_8\n\n忽略多字段搜索运算符（如果有 'title'、'subject' 和 'body' 字段，则 `@!(title)` 等同于 `@(subject,body)`）：\n\nCODE_BLOCK_9\n\n全字段搜索运算符：\n\nCODE_BLOCK_10\n\n### 短语搜索运算符\n\nCODE_BLOCK_11\n\n短语运算符要求单词彼此相邻。\n\n短语搜索运算符可以包含 `匹配任意词` 修饰符。在短语运算符内，词的位置很重要。当使用 '匹配任意' 修饰符时，后续词在该短语查询中的位置将被移动。因此，'匹配任意' 修饰符不会影响搜索性能。\n\n注意：当使用包含超过 31 个关键词的查询时，位置 31 及以上的关键词的排名统计（如 `tf`、`idf`、`bm25`）可能会被低估。这是因为内部使用了 32 位掩码来跟踪匹配中的词出现情况。匹配逻辑（查找文档）仍然是正确的，但对于非常长的查询，排名分数可能会受到影响。\n\nCODE_BLOCK_12\n\n你还可以在引号内使用 OR 运算符。在短语内使用时，OR 运算符 (`|`) 必须用括号 `()` 括起来。每个选项在相同位置被检查，如果任何选项匹配该位置，则短语匹配。\n\n**正确示例**（使用括号）：\n\nCODE_BLOCK_13\n\n**错误示例**（没有括号 - 这些不会起作用）：\n\nCODE_BLOCK_14\n\n### 邻近搜索运算符\n\nCODE_BLOCK_15\n\n邻近距离以单词计算，考虑单词数，并适用于引号内的所有单词。例如，查询 `\"cat dog mouse\"~5` 表示必须有少于 8 个单词的跨度包含所有 3 个单词。因此，包含 `CAT aaa bbb ccc DOG eee fff MOUSE` 的文档将不匹配此查询，因为跨度恰好是 8 个单词长。\n\n注意：当使用包含超过 31 个关键词的查询时，位置 31 及以上的关键词的排名统计（如 `tf`、`idf`、`bm25`）可能会被低估。这是因为内部使用了 32 位掩码来跟踪匹配中的词出现情况。匹配逻辑（查找文档）仍然是正确的，但对于非常长的查询，排名分数可能会受到影响。\n\n你还可以在邻近搜索中使用 OR 运算符。在邻近搜索中使用时，OR 运算符 (`|`) 必须用括号 `()` 括起来。每个选项单独检查。\n\n**正确示例**（使用括号）：\n\nCODE_BLOCK_16\n\n**错误示例**（没有括号 - 这不会起作用）：\n\nCODE_BLOCK_17\n\n### 法定人数匹配运算符\n\nCODE_BLOCK_18\n\n法定人数匹配运算符引入了一种模糊匹配。它只匹配满足指定单词给定阈值的文档。在上面的示例中（`\"the world is a wonderful place\"/3`），它将匹配包含至少 6 个指定单词中的 3 个的所有文档。运算符限制为 255 个关键词。除了绝对数字外，你还可以提供 0.0 到 1.0 之间的值（分别代表 0% 和 100%），Manticore 将仅匹配包含给定词至少指定百分比的文档。上面的同一示例也可以表示为 `\"the world is a wonderful place\"/0.5`，它将匹配包含 6 个词中至少 50% 的文档。\n\n法定人数运算符支持 OR (`|`) 运算符。在法定人数匹配中使用时，OR 运算符 (`|`) 必须用括号 `()` 括起来。只有每个 OR 组中的一个词计入匹配。\n\n**正确示例**（使用括号）：\n\nCODE_BLOCK_19\n\n**错误示例**（没有括号 - 这不会起作用）：\n\nCODE_BLOCK_20\n\n### 严格顺序运算符\n\nCODE_BLOCK_21\n\n严格顺序运算符（也称为\"之前\"运算符）只有在其参数关键词以查询中指定的确切顺序出现在文档中时，才匹配一个文档。例如，查询 `black << cat` 将匹配文档 \"black and white cat\"，但不匹配文档 \"that cat was black\"。顺序运算符具有最低的优先级。它可以应用于单个关键词和更复杂的表达式。例如，这是一个有效的查询：\n\nCODE_BLOCK_22",
      "russian": "# Полные текстовые операторы\n\nВ строке запроса могут быть включены специальные операторы, которые определяют условия для сопоставления слов из строки запроса.\n\n### Логические операторы\n\n#### Оператор И\n\nНеявный логический оператор И всегда присутствует, поэтому \"hello world\" подразумевает, что и \"hello\", и \"world\" должны быть найдены в соответствующем документе.\n\nCODE_BLOCK_0\n\nПримечание: Нет явного оператора `И`.\n\n#### Оператор ИЛИ\n\nЛогический оператор ИЛИ `|` имеет более высокий приоритет, чем И, поэтому `looking for cat | dog | mouse` означает `looking for (cat | dog | mouse)`, а не `(looking for cat) | dog | mouse`.\n\nCODE_BLOCK_1\n\nПримечание: Нет оператора `ИЛИ`. Пожалуйста, используйте `|` вместо этого.\n\n### Оператор МОЖЕТ БЫТЬ\n\nCODE_BLOCK_2\n\nОператор `МОЖЕТ БЫТЬ` работает аналогично оператору `|`, но не возвращает документы, которые соответствуют только выражению правого поддерева.\n\n### Оператор отрицания\n\nCODE_BLOCK_3\n\nОператор отрицания налагает правило, что слово не должно существовать.\n\nЗапросы, содержащие **только** отрицания, по умолчанию **не** поддерживаются. Чтобы включить, используйте параметр сервера [not_terms_only_allowed](../../Server_settings/Searchd.md#not_terms_only_allowed).\n\n### Оператор поиска по полю\n\nCODE_BLOCK_4\n\nОператор ограничения поля ограничивает последующий поиск указанным полем. По умолчанию запрос завершится ошибкой, если указанное имя поля не существует в searched таблице. Однако это поведение можно подавить, указав опцию `@@relaxed` в начале запроса:\n\nCODE_BLOCK_5\n\nЭто может быть полезно при поиске через разнородные таблицы с различными схемами.\n\nОграничения позиции поля дополнительно ограничивают поиск первыми N позициями в заданном поле (или полях). Например, `@body [50] hello` не будет сопоставлять документы, где ключевое слово `hello` появляется в позиции 51 или позже в теле.\n\nCODE_BLOCK_6\n\nОператор поиска по нескольким полям:\n\nCODE_BLOCK_7\n\nОператор игнорирования поиска по полю (игнорирует любые совпадения 'hello world' из поля 'title'):\n\nCODE_BLOCK_8\n\nОператор игнорирования поиска по нескольким полям (если есть поля 'title', 'subject' и 'body', то `@!(title)` эквивалентно `@(subject,body)`):\n\nCODE_BLOCK_9\n\nОператор поиска по всем полям:\n\nCODE_BLOCK_10\n\n### Оператор поиска фраз\n\nCODE_BLOCK_11\n\nОператор фраз требует, чтобы слова были расположены рядом друг с другом.\n\nОператор поиска фраз может включать модификатор `сопоставление любого термина`. В операторе фразы термины имеют позиционную значимость. При использовании модификатора 'сопоставление любого' позиции последующих терминов в этом запросе фразы будут смещены. Как следствие, модификатор 'сопоставление любого' не влияет на производительность поиска.\n\nПримечание: При использовании этого оператора с запросами, содержащими более 31 ключевого слова, статистика ранжирования (такая как `tf`, `idf`, `bm25`) для ключевых слов в позиции 31 и выше может быть недосчитана. Это связано с 32-битной маской, используемой внутренне для отслеживания вхождений терминов в совпадении. Логика сопоставления (поиск документов) остается корректной, но оценки ранжирования могут быть затронуты для очень длинных запросов.\n\nCODE_BLOCK_12\n\nМожно также использовать оператор ИЛИ внутри кавычек. Оператор ИЛИ (`|`) должен быть заключен в квадратные скобки `()` при использовании внутри фраз. Каждый вариант проверяется в одной позиции, и фраза совпадает, если любой из вариантов подходит к этой позиции.\n\n**Правильные примеры** (со скобками):\n\nCODE_BLOCK_13\n\n**Неправильные примеры** (без скобок - они не сработают):\n\nCODE_BLOCK_14\n\n### Оператор proximity-поиска\n\nCODE_BLOCK_15\n\nProximity-расстояние измеряется в словах, учитывает количество слов и применяется ко всем словам в кавычках. Например, запрос `\"cat dog mouse\"~5` означает, что должен быть промежуток менее 8 слов, содержащий все 3 слова. Поэтому документ с `CAT aaa bbb ccc DOG eee fff MOUSE` не будет соответствовать этому запросу, так как промежуток составляет ровно 8 слов.\n\nПримечание: При использовании этого оператора с запросами, содержащими более 31 ключевого слова, статистика ранжирования (такая как `tf`, `idf`, `bm25`) для ключевых слов в позиции 31 и выше может быть недосчитана. Это связано с 32-битной маской, используемой внутренне для отслеживания вхождений терминов в совпадении. Логика сопоставления (поиск документов) остается корректной, но оценки ранжирования могут быть затронуты для очень длинных запросов.\n\nМожно также использовать оператор ИЛИ внутри proximity-поиска. Оператор ИЛИ (`|`) должен быть заключен в квадратные скобки `()` при использовании внутри proximity-поисков. Каждый вариант проверяется отдельно.\n\n**Правильный пример** (со скобками):\n\nCODE_BLOCK_16\n\n**Неправильный пример** (без скобок - это не сработает):\n\nCODE_BLOCK_17\n\n### Оператор кворум-сопоставления\n\nCODE_BLOCK_18\n\nОператор кворум-сопоставления вводит тип нечеткого сопоставления. Он будет сопоставлять только те документы, которые удовлетворяют заданному порогу указанных слов. В примере выше (`\"the world is a wonderful place\"/3`) он будет сопоставлять все документы, содержащие по крайней мере 3 из 6 указанных слов. Оператор ограничен 255 ключевыми словами. Вместо абсолютного числа можно также указать значение от 0.0 до 1.0 (представляющее 0% и 100%), и Manticore будет сопоставлять только документы, содержащие по крайней мере указанный процент данных слов. Тот же пример выше также может быть выражен как `\"the world is a wonderful place\"/0.5`, и он будет сопоставлять документы не менее чем с 50% слов.\n\nКворум-оператор поддерживает оператор ИЛИ (`|`). Оператор ИЛИ (`|`) должен быть заключен в квадратные скобки `()` при использовании внутри кворум-сопоставления. Только одно слово из каждой группы ИЛИ учитывается при сопоставлении.\n\n**Правильные примеры** (со скобками):\n\nCODE_BLOCK_19\n\n**Неправильный пример** (без скобок - это не сработает):\n\nCODE_BLOCK_20\n\n### Оператор строгого порядка\n\nCODE_BLOCK_21\n\nОператор строгого порядка (также известный как оператор \"перед\") сопоставляет документ только в том случае, если ключевые слова его аргументов появляются в документе строго в порядке, указанном в запросе. Например, запрос `black << cat` будет сопоставлен с документом \"black and white cat\", но не с документом \"that cat was black\". Оператор порядка имеет самый низкий приоритет. Он может быть применен как к отдельным ключевым словам, так и к более сложным выражениям. Например, это допустимый запрос:\n\nCODE_BLOCK_22"
    },
    "is_code_or_comment": false
  }
}
