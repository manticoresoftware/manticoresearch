{
  "774b173a5f22bbcc2d782abbf1f7b722a7e0ac0850f4efa9686edb1e4aa6b25c": {
    "original": "* The values of document-level factors (such as bm25, field_mask, doc_word_count)\n\n* A list of each field that generated a hit (including lcs, hit_count, word_count, sum_idf, min_hit_pos, etc.)\n\n* A list of each keyword from the query along with their tf and idf values\n\nThese values can be utilized to understand why certain documents receive lower or higher scores in a search or to refine the existing ranking expression.\n\n<!-- intro -->\n\nExample:\n\n<!-- request SQL -->\n\nCODE_BLOCK_52\n\n<!-- response SQL -->\n\nCODE_BLOCK_53\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "* 文档级别因素的值（例如 bm25、field_mask、doc_word_count）\n\n* 生成命中的每个字段的列表（包括 lcs、hit_count、word_count、sum_idf、min_hit_pos 等）\n\n* 查询中每个关键词及其 tf 和 idf 值的列表\n\n这些值可用于理解为什么某些文档在搜索中获得较低或较高的分数，或用于优化现有的排名表达式。\n\n<!-- intro -->\n\nExample:\n\n<!-- request SQL -->\n\nCODE_BLOCK_52\n\n<!-- response SQL -->\n\nCODE_BLOCK_53\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "* Значения факторов на уровне документа (таких как bm25, field_mask, doc_word_count)\n\n* Список каждого поля, которое сгенерировало совпадение (включая lcs, hit_count, word_count, sum_idf, min_hit_pos и т.д.)\n\n* Список каждого ключевого слова из запроса вместе с их значениями tf и idf\n\nЭти значения можно использовать для понимания, почему определённые документы получают более низкие или высокие оценки в поиске, или для уточнения существующего выражения ранжирования.\n\n<!-- intro -->\n\nExample:\n\n<!-- request SQL -->\n\nCODE_BLOCK_52\n\n<!-- response SQL -->\n\nCODE_BLOCK_53\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "4dafa918a1a6af668e7efecadd9227c951f01ba483f4c1dbd8930607b8f4f6fe": {
    "original": "# Search profiling\n\n## How a query is interpreted\n\nConsider this complex query example:\n\nCODE_BLOCK_0\n\nThe full meaning of this search is:\n\n* Locate the words 'hello' and 'world' adjacently in any field within a document;\n\n* Additionally, the same document must also contain the words 'example' and 'program' in the title field, with up to, but not including, 5 words between them; (For instance, \"example PHP program\" would match, but \"example script to introduce outside data into the correct context for your program\" would not, as there are 5 or more words between the two terms)\n\n* Furthermore, the same document must have the word 'python' in the body field, while excluding 'php' or 'perl';\n\n* Finally, the same document must include the word 'code' in any field.\n\nThe OR operator takes precedence over AND, so \"looking for cat | dog | mouse\" means \"looking for (cat | dog | mouse)\" rather than \"(looking for cat) | dog | mouse\".\n\nTo comprehend how a query will be executed, Manticore Search provides query profiling tools to examine the query tree generated by a query expression.\n\n<!-- example profiling -->\n\n## Profiling the query tree in SQL\n\nTo enable full-text query profiling with an SQL statement, you must activate it before executing the desired query:\n\nCODE_BLOCK_1\n\nTo view the query tree, execute the `SHOW PLAN`  command immediately after running the query:\n\nCODE_BLOCK_2\n\nThis command will return the structure of the executed query. Keep in mind that the 3 statements - SET profiling, the query, and SHOW - must be executed within the same session.\n\n## Profiling the query in HTTP JSON\n\nWhen using the HTTP JSON protocol we can just enable `\"profile\":true` to get in response the full-text query tree structure.\n\nCODE_BLOCK_3\n\nThe response will include a `profile` object containing a `query` member.\n\nThe `query` property holds the transformed full-text query tree. Each node consists of:\n\n* `type`: node type, which can be AND, OR, PHRASE, KEYWORD, etc.\n\n* `description`: query subtree for this node represented as a string (in `SHOW PLAN` format)\n\n* `children`: any child nodes, if present\n\n* `max_field_pos`: maximum position within a field\n\n A keyword node will additionally include:\n\n* `word`: the transformed keyword.\n\n* `querypos`: position of this keyword in the query.\n\n* `excluded`: keyword excluded from the query.\n\n* `expanded`: keyword added by prefix expansion.\n\n* `field_start`: keyword must appear at the beginning of the field.\n\n* `field_end`: keyword must appear at the end of the field.\n\n* `boost`: the keyword's IDF will be multiplied by this value.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_4\n\n<!-- response SQL -->\n\nCODE_BLOCK_5\n\n<!-- request JSON -->\n\nCODE_BLOCK_6\n\n<!-- response JSON -->\n\nCODE_BLOCK_7\n\n<!-- request PHP -->\n\nCODE_BLOCK_8\n\n<!-- response PHP -->\n\nCODE_BLOCK_9\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_10\n\n<!-- response Python -->\n\nCODE_BLOCK_11\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_12\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_13\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_14\n\n<!-- response javascript -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_16\n\n<!-- response Java -->\n\nCODE_BLOCK_17\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_18\n\n<!-- response C# -->\n\nCODE_BLOCK_19\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_20\n\n<!-- response Rust -->\n\nCODE_BLOCK_21\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_22\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_23\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_24\n\n<!-- response Go -->\n\nCODE_BLOCK_25\n\n<!-- end -->\n\n<!-- example SHOW PLAN EXPANSION -->\n\nIn some instances, the evaluated query tree may significantly differ from the original one due to expansions and other transformations.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_26\n\n<!-- response SQL -->\n\nCODE_BLOCK_27\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_28\n\n<!-- response JSON -->\n\nCODE_BLOCK_29\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_30\n\n<!-- response PHP -->\n\nCODE_BLOCK_31\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_32\n\n<!-- response Python -->\n\nCODE_BLOCK_33\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_34\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_35\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_36\n\n<!-- response javascript -->\n\nCODE_BLOCK_37\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_38\n\n<!-- response Java -->\n\nCODE_BLOCK_39\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_40\n\n<!-- response C# -->\n\nCODE_BLOCK_41\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_42\n\n<!-- response Rust -->\n\nCODE_BLOCK_43\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_44\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_45\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_46\n\n<!-- response Go -->\n\nCODE_BLOCK_47\n\n<!-- end -->\n\n## Profiling without running a query\n\n<!-- Example Explain_query -->\n\nThe SQL statement `EXPLAIN QUERY` enables the display of the execution tree for a given full-text query without performing an actual search query on the table.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- response SQL -->\n\nCODE_BLOCK_49\n\n<!-- end -->\n\n<!-- Example Explain_query_dot -->\n\n`EXPLAIN QUERY ... option format=dot` allows displaying the execution tree of a provided full-text query in a hierarchical format suitable for visualization by existing tools, such as https://dreampuf.github.io/GraphvizOnline:\n\n![EXPLAIN QUERY graphviz example](graphviz.png)\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_50\n\n<!-- response SQL -->\n\nCODE_BLOCK_51\n\n<!-- end -->\n\n## Viewing the match factors values\n\n<!-- example factors -->\n\nWhen using an expression ranker, it's possible to reveal the values of the calculated factors with the [PACKEDFACTORS()](../../Functions/Searching_and_ranking_functions.md#PACKEDFACTORS%28%29) function.\n\nThe function returns:",
    "translations": {
      "chinese": "# 搜索分析\n\n## 查询的解释方式\n\n考虑以下复杂查询示例：\n\nCODE_BLOCK_0\n\n该搜索的完整含义是：\n\n* 在文档的任何字段中定位相邻的单词 'hello' 和 'world'；\n\n* 此外，同一文档的标题字段中必须包含单词 'example' 和 'program'，两者之间最多有但不包括 5 个单词；（例如，“example PHP program” 会匹配，但“example script to introduce outside data into the correct context for your program” 不会匹配，因为两个词之间有 5 个或更多单词）\n\n* 此外，同一文档的正文字段中必须包含单词 'python'，同时排除 'php' 或 'perl'；\n\n* 最后，同一文档的任何字段中必须包含单词 'code'。\n\nOR 运算符优先于 AND，因此“looking for cat | dog | mouse” 意味着“looking for (cat | dog | mouse)”，而不是“(looking for cat) | dog | mouse”。\n\n为了理解查询将如何执行，Manticore Search 提供了查询分析工具，用于检查由查询表达式生成的查询树。\n\n<!-- example profiling -->\n\n## 在 SQL 中分析查询树\n\n要启用带有 SQL 语句的全文查询分析，必须在执行所需查询之前激活它：\n\nCODE_BLOCK_1\n\n要查看查询树，请在运行查询后立即执行 `SHOW PLAN` 命令：\n\nCODE_BLOCK_2\n\n该命令将返回已执行查询的结构。请记住，3 个语句 - SET profiling、查询和 SHOW - 必须在同一会话中执行。\n\n## 在 HTTP JSON 中分析查询\n\n使用 HTTP JSON 协议时，只需启用 `\"profile\":true`，即可在响应中获得全文查询树结构。\n\nCODE_BLOCK_3\n\n响应将包含一个 `profile` 对象，其中包含一个 `query` 成员。\n\n`query` 属性保存转换后的全文查询树。每个节点包括：\n\n* `type`：节点类型，可以是 AND、OR、PHRASE、KEYWORD 等。\n\n* `description`：该节点的查询子树，以字符串形式表示（`SHOW PLAN` 格式）\n\n* `children`：任何子节点（如果存在）\n\n* `max_field_pos`：字段内的最大位置\n\n关键词节点还将包括：\n\n* `word`：转换后的关键词。\n\n* `querypos`：该关键词在查询中的位置。\n\n* `excluded`：关键词是否被排除在查询之外。\n\n* `expanded`：关键词是否由前缀扩展添加。\n\n* `field_start`：关键词必须出现在字段开头。\n\n* `field_end`：关键词必须出现在字段结尾。\n\n* `boost`：关键词的 IDF 将乘以此值。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_4\n\n<!-- response SQL -->\n\nCODE_BLOCK_5\n\n<!-- request JSON -->\n\nCODE_BLOCK_6\n\n<!-- response JSON -->\n\nCODE_BLOCK_7\n\n<!-- request PHP -->\n\nCODE_BLOCK_8\n\n<!-- response PHP -->\n\nCODE_BLOCK_9\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_10\n\n<!-- response Python -->\n\nCODE_BLOCK_11\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_12\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_13\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_14\n\n<!-- response javascript -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_16\n\n<!-- response Java -->\n\nCODE_BLOCK_17\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_18\n\n<!-- response C# -->\n\nCODE_BLOCK_19\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_20\n\n<!-- response Rust -->\n\nCODE_BLOCK_21\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_22\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_23\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_24\n\n<!-- response Go -->\n\nCODE_BLOCK_25\n\n<!-- end -->\n\n<!-- example SHOW PLAN EXPANSION -->\n\n在某些情况下，由于扩展和其他转换，评估后的查询树可能与原始查询树有显著差异。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_26\n\n<!-- response SQL -->\n\nCODE_BLOCK_27\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_28\n\n<!-- response JSON -->\n\nCODE_BLOCK_29\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_30\n\n<!-- response PHP -->\n\nCODE_BLOCK_31\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_32\n\n<!-- response Python -->\n\nCODE_BLOCK_33\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_34\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_35\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_36\n\n<!-- response javascript -->\n\nCODE_BLOCK_37\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_38\n\n<!-- response Java -->\n\nCODE_BLOCK_39\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_40\n\n<!-- response C# -->\n\nCODE_BLOCK_41\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_42\n\n<!-- response Rust -->\n\nCODE_BLOCK_43\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_44\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_45\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_46\n\n<!-- response Go -->\n\nCODE_BLOCK_47\n\n<!-- end -->\n\n## 不运行查询时的分析\n\n<!-- Example Explain_query -->\n\nSQL 语句 `EXPLAIN QUERY` 允许显示给定全文查询的执行树，而无需对表执行实际的搜索查询。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- response SQL -->\n\nCODE_BLOCK_49\n\n<!-- end -->\n\n<!-- Example Explain_query_dot -->\n\n`EXPLAIN QUERY ... option format=dot` 允许以分层格式显示提供的全文查询的执行树，适合使用现有工具进行可视化，例如 https://dreampuf.github.io/GraphvizOnline：\n\n![EXPLAIN QUERY graphviz example](graphviz.png)\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_50\n\n<!-- response SQL -->\n\nCODE_BLOCK_51\n\n<!-- end -->\n\n## 查看匹配因子值\n\n<!-- example factors -->\n\n使用表达式排序器时，可以通过 [PACKEDFACTORS()](../../Functions/Searching_and_ranking_functions.md#PACKEDFACTORS%28%29) 函数显示计算出的因子值。\n\n该函数返回：",
      "russian": "# Поиск с профилированием\n\n## Как интерпретируется запрос\n\nРассмотрим этот пример сложного запроса:\n\nCODE_BLOCK_0\n\nПолное значение этого поиска:\n\n* Найти слова 'hello' и 'world' рядом друг с другом в любом поле документа;\n\n* Кроме того, в том же документе должны содержаться слова 'example' и 'program' в поле заголовка, с не более чем 5 словами между ними (не включая 5); (например, \"example PHP program\" подойдет, а \"example script to introduce outside data into the correct context for your program\" — нет, так как между двумя терминами 5 или более слов)\n\n* Более того, в том же документе должно быть слово 'python' в поле body, при этом исключая 'php' или 'perl';\n\n* Наконец, в том же документе должно содержаться слово 'code' в любом поле.\n\nОператор OR имеет приоритет над AND, поэтому \"looking for cat | dog | mouse\" означает \"looking for (cat | dog | mouse)\", а не \"(looking for cat) | dog | mouse\".\n\nЧтобы понять, как будет выполняться запрос, Manticore Search предоставляет инструменты профилирования запросов для изучения дерева запроса, сгенерированного выражением запроса.\n\n<!-- example profiling -->\n\n## Профилирование дерева запроса в SQL\n\nЧтобы включить профилирование полнотекстового запроса с помощью SQL-запроса, необходимо активировать его перед выполнением нужного запроса:\n\nCODE_BLOCK_1\n\nЧтобы просмотреть дерево запроса, выполните команду `SHOW PLAN` сразу после выполнения запроса:\n\nCODE_BLOCK_2\n\nЭта команда вернет структуру выполненного запроса. Имейте в виду, что 3 оператора — SET profiling, сам запрос и SHOW — должны выполняться в одной сессии.\n\n## Профилирование запроса в HTTP JSON\n\nПри использовании протокола HTTP JSON можно просто включить `\"profile\":true`, чтобы получить в ответе структуру дерева полнотекстового запроса.\n\nCODE_BLOCK_3\n\nВ ответе будет объект `profile`, содержащий член `query`.\n\nСвойство `query` содержит преобразованное дерево полнотекстового запроса. Каждый узел состоит из:\n\n* `type`: тип узла, который может быть AND, OR, PHRASE, KEYWORD и т.д.\n\n* `description`: поддерево запроса для этого узла, представленное в виде строки (в формате `SHOW PLAN`)\n\n* `children`: дочерние узлы, если есть\n\n* `max_field_pos`: максимальная позиция в поле\n\nУ узла ключевого слова дополнительно будут:\n\n* `word`: преобразованное ключевое слово.\n\n* `querypos`: позиция этого ключевого слова в запросе.\n\n* `excluded`: ключевое слово исключено из запроса.\n\n* `expanded`: ключевое слово добавлено расширением префикса.\n\n* `field_start`: ключевое слово должно появиться в начале поля.\n\n* `field_end`: ключевое слово должно появиться в конце поля.\n\n* `boost`: IDF ключевого слова будет умножен на это значение.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_4\n\n<!-- response SQL -->\n\nCODE_BLOCK_5\n\n<!-- request JSON -->\n\nCODE_BLOCK_6\n\n<!-- response JSON -->\n\nCODE_BLOCK_7\n\n<!-- request PHP -->\n\nCODE_BLOCK_8\n\n<!-- response PHP -->\n\nCODE_BLOCK_9\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_10\n\n<!-- response Python -->\n\nCODE_BLOCK_11\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_12\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_13\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_14\n\n<!-- response javascript -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_16\n\n<!-- response Java -->\n\nCODE_BLOCK_17\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_18\n\n<!-- response C# -->\n\nCODE_BLOCK_19\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_20\n\n<!-- response Rust -->\n\nCODE_BLOCK_21\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_22\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_23\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_24\n\n<!-- response Go -->\n\nCODE_BLOCK_25\n\n<!-- end -->\n\n<!-- example SHOW PLAN EXPANSION -->\n\nВ некоторых случаях оцениваемое дерево запроса может значительно отличаться от исходного из-за расширений и других преобразований.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_26\n\n<!-- response SQL -->\n\nCODE_BLOCK_27\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_28\n\n<!-- response JSON -->\n\nCODE_BLOCK_29\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_30\n\n<!-- response PHP -->\n\nCODE_BLOCK_31\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_32\n\n<!-- response Python -->\n\nCODE_BLOCK_33\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_34\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_35\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_36\n\n<!-- response javascript -->\n\nCODE_BLOCK_37\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_38\n\n<!-- response Java -->\n\nCODE_BLOCK_39\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_40\n\n<!-- response C# -->\n\nCODE_BLOCK_41\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_42\n\n<!-- response Rust -->\n\nCODE_BLOCK_43\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_44\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_45\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_46\n\n<!-- response Go -->\n\nCODE_BLOCK_47\n\n<!-- end -->\n\n## Профилирование без выполнения запроса\n\n<!-- Example Explain_query -->\n\nSQL-оператор `EXPLAIN QUERY` позволяет отобразить дерево выполнения для заданного полнотекстового запроса без фактического выполнения поискового запроса по таблице.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- response SQL -->\n\nCODE_BLOCK_49\n\n<!-- end -->\n\n<!-- Example Explain_query_dot -->\n\n`EXPLAIN QUERY ... option format=dot` позволяет отобразить дерево выполнения заданного полнотекстового запроса в иерархическом формате, подходящем для визуализации с помощью существующих инструментов, таких как https://dreampuf.github.io/GraphvizOnline:\n\n![EXPLAIN QUERY graphviz example](graphviz.png)\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_50\n\n<!-- response SQL -->\n\nCODE_BLOCK_51\n\n<!-- end -->\n\n## Просмотр значений факторов совпадения\n\n<!-- example factors -->\n\nПри использовании ранжировщика выражений можно вывести значения вычисленных факторов с помощью функции [PACKEDFACTORS()](../../Functions/Searching_and_ranking_functions.md#PACKEDFACTORS%28%29).\n\nФункция возвращает:"
    },
    "is_code_or_comment": false
  },
  "1592a6a32210b6a76c6684f5a63c7dae64f22635acac61b6a9134497621625c2": {
    "original": "When using an expression ranker, it's possible to reveal the values of the calculated factors with the [PACKEDFACTORS()](../../Functions/Searching_and_ranking_functions.md#PACKEDFACTORS%28%29) function.\n\nThe function returns:\n\n* The values of document-level factors (such as bm25, field_mask, doc_word_count)\n\n* A list of each field that generated a hit (including lcs, hit_count, word_count, sum_idf, min_hit_pos, etc.)\n\n* A list of each keyword from the query along with their tf and idf values\n\nThese values can be utilized to understand why certain documents receive lower or higher scores in a search or to refine the existing ranking expression.\n\n<!-- intro -->\n\nExample:\n\n<!-- request SQL -->\n\nCODE_BLOCK_58\n\n<!-- response SQL -->\n\nCODE_BLOCK_59\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "使用表达式排序器时，可以使用 [PACKEDFACTORS()](../../Functions/Searching_and_ranking_functions.md#PACKEDFACTORS%28%29) 函数显示计算因子的值。\n\n该函数返回：\n\n* 文档级因子的值（例如 bm25、field_mask、doc_word_count）\n\n* 生成命中的每个字段的列表（包括 lcs、hit_count、word_count、sum_idf、min_hit_pos 等）\n\n* 查询中每个关键词及其 tf 和 idf 值的列表\n\n这些值可以用来了解为什么某些文档在搜索中得分较低或较高，或用于优化现有的排序表达式。\n\n<!-- intro -->\n\n示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_58\n\n<!-- response SQL -->\n\nCODE_BLOCK_59\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "При использовании ранжировщика выражений возможно вывести значения вычисленных факторов с помощью функции [PACKEDFACTORS()](../../Functions/Searching_and_ranking_functions.md#PACKEDFACTORS%28%29).\n\nФункция возвращает:\n\n* Значения факторов на уровне документа (такие как bm25, field_mask, doc_word_count)\n\n* Список каждого поля, которое сгенерировало совпадение (включая lcs, hit_count, word_count, sum_idf, min_hit_pos и др.)\n\n* Список каждого ключевого слова из запроса вместе с их значениями tf и idf\n\nЭти значения можно использовать, чтобы понять, почему определённые документы получают более низкие или более высокие оценки при поиске, или для уточнения существующего выражения ранжирования.\n\n<!-- intro -->\n\nПример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_58\n\n<!-- response SQL -->\n\nCODE_BLOCK_59\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "c55ae64a728af90c483bb8e024f1279a3cf1a6843944b7099226d95034e764a1": {
    "original": "# Search profiling\n\n## How a query is interpreted\n\nConsider this complex query example:\n\nCODE_BLOCK_0\n\nThe full meaning of this search is:\n\n* Locate the words 'hello' and 'world' adjacently in any field within a document;\n\n* Additionally, the same document must also contain the words 'example' and 'program' in the title field, with up to, but not including, 5 words between them; (For instance, \"example PHP program\" would match, but \"example script to introduce outside data into the correct context for your program\" would not, as there are 5 or more words between the two terms)\n\n* Furthermore, the same document must have the word 'python' in the body field, while excluding 'php' or 'perl';\n\n* Finally, the same document must include the word 'code' in any field.\n\nThe OR operator takes precedence over AND, so \"looking for cat | dog | mouse\" means \"looking for (cat | dog | mouse)\" rather than \"(looking for cat) | dog | mouse\".\n\nTo comprehend how a query will be executed, Manticore Search provides query profiling tools to examine the query tree generated by a query expression.\n\n<!-- example profiling -->\n\n## Profiling the query tree in SQL\n\nTo enable full-text query profiling with an SQL statement, you must activate it before executing the desired query:\n\nCODE_BLOCK_1\n\nTo view the query tree, execute the `SHOW PLAN`  command immediately after running the query:\n\nCODE_BLOCK_2\n\nThis command will return the structure of the executed query. Keep in mind that the 3 statements - SET profiling, the query, and SHOW - must be executed within the same session.\n\n## Profiling the query in HTTP JSON\n\nWhen using the HTTP JSON protocol we can just enable `\"profile\":true` to get in response the full-text query tree structure.\n\nCODE_BLOCK_3\n\nThe response will include a `profile` object containing a `query` member.\n\nThe `query` property holds the transformed full-text query tree. Each node consists of:\n\n* `type`: node type, which can be AND, OR, PHRASE, KEYWORD, etc.\n\n* `description`: query subtree for this node represented as a string (in `SHOW PLAN` format)\n\n* `children`: any child nodes, if present\n\n* `max_field_pos`: maximum position within a field\n\n A keyword node will additionally include:\n\n* `word`: the transformed keyword.\n\n* `querypos`: position of this keyword in the query.\n\n* `excluded`: keyword excluded from the query.\n\n* `expanded`: keyword added by prefix expansion.\n\n* `field_start`: keyword must appear at the beginning of the field.\n\n* `field_end`: keyword must appear at the end of the field.\n\n* `boost`: the keyword's IDF will be multiplied by this value.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_4\n\n<!-- response SQL -->\n\nCODE_BLOCK_5\n\n<!-- request JSON -->\n\nCODE_BLOCK_6\n\n<!-- response JSON -->\n\nCODE_BLOCK_7\n\n<!-- request PHP -->\n\nCODE_BLOCK_8\n\n<!-- response PHP -->\n\nCODE_BLOCK_9\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_10\n\n<!-- response Python -->\n\nCODE_BLOCK_11\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_12\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_13\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_14\n\n<!-- response javascript -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_16\n\n<!-- response Java -->\n\nCODE_BLOCK_17\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_18\n\n<!-- response C# -->\n\nCODE_BLOCK_19\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_20\n\n<!-- response Rust -->\n\nCODE_BLOCK_21\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_22\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_23\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_24\n\n<!-- response Go -->\n\nCODE_BLOCK_25\n\n<!-- end -->\n\n<!-- example SHOW PLAN EXPANSION -->\n\nIn some instances, the evaluated query tree may significantly differ from the original one due to expansions and other transformations.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_26\n\n<!-- response SQL -->\n\nCODE_BLOCK_27\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_28\n\n<!-- response JSON -->\n\nCODE_BLOCK_29\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_30\n\n<!-- response PHP -->\n\nCODE_BLOCK_31\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_32\n\n<!-- response Python -->\n\nCODE_BLOCK_33\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_34\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_35\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_36\n\n<!-- response javascript -->\n\nCODE_BLOCK_37\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_38\n\n<!-- response Java -->\n\nCODE_BLOCK_39\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_40\n\n<!-- response C# -->\n\nCODE_BLOCK_41\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_42\n\n<!-- response Rust -->\n\nCODE_BLOCK_43\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_44\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_45\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_46\n\n<!-- response Go -->\n\nCODE_BLOCK_47\n\n<!-- end -->\n\n## Profiling without running a query\n\n<!-- Example Explain_query -->\n\nThe SQL statement `EXPLAIN QUERY` enables the display of the execution tree for a given full-text query without performing an actual search query on the table.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- response SQL -->\n\nCODE_BLOCK_49\n\n<!-- request JSON -->\n\nCODE_BLOCK_50\n\n<!-- response JSON -->\n\nCODE_BLOCK_51\n\n<!-- end -->\n\n<!-- Example Explain_query_dot -->\n\n`EXPLAIN QUERY ... option format=dot` allows displaying the execution tree of a provided full-text query in a hierarchical format suitable for visualization by existing tools, such as https://dreampuf.github.io/GraphvizOnline:\n\n![EXPLAIN QUERY graphviz example](graphviz.png)\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_52\n\n<!-- response SQL -->\n\nCODE_BLOCK_53\n\n<!-- request JSON -->\n\nCODE_BLOCK_54\n\n<!-- response JSON -->\n\nCODE_BLOCK_55\n\n<!-- request JSON -->\n\nCODE_BLOCK_56\n\n<!-- response JSON -->\n\nCODE_BLOCK_57\n\n<!-- end -->\n\n## Viewing the match factors values\n\n<!-- example factors -->",
    "translations": {
      "chinese": "# 搜索分析\n\n## 查询的解释方式\n\n考虑以下复杂查询示例：\n\nCODE_BLOCK_0\n\n该搜索的完整含义是：\n\n* 在文档的任何字段中查找相邻的单词 'hello' 和 'world'；\n\n* 此外，同一文档的标题字段中必须包含单词 'example' 和 'program'，它们之间最多但不超过5个单词；（例如，\"example PHP program\" 会匹配，但 \"example script to introduce outside data into the correct context for your program\" 不会，因为两词之间有5个或更多单词）\n\n* 此外，同一文档的正文字段中必须包含单词 'python'，同时排除 'php' 或 'perl'；\n\n* 最后，同一文档的任何字段中必须包含单词 'code'。\n\nOR 操作符优先于 AND，因此 \"looking for cat | dog | mouse\" 的含义是 \"looking for (cat | dog | mouse)\"，而不是 \"(looking for cat) | dog | mouse\"。\n\n为了理解查询如何执行，Manticore Search 提供了查询分析工具来检查由查询表达式生成的查询树。\n\n<!-- example profiling -->\n\n## SQL 中的查询树分析\n\n要启用使用 SQL 语句的全文查询分析，必须在执行所需查询之前激活它：\n\nCODE_BLOCK_1\n\n要查看查询树，请在运行查询后立即执行 `SHOW PLAN` 命令：\n\nCODE_BLOCK_2\n\n此命令将返回执行查询的结构。请注意，3 条语句 - SET profiling、查询本身和 SHOW - 必须在同一会话中执行。\n\n## HTTP JSON 中的查询分析\n\n使用 HTTP JSON 协议时，只需启用 `\"profile\":true`，即可在响应中获得全文查询树结构。\n\nCODE_BLOCK_3\n\n响应将包含一个 `profile` 对象，其中包含 `query` 成员。\n\n`query` 属性保存转换后的全文查询树。每个节点包含：\n\n* `type`：节点类型，可以是 AND、OR、PHRASE、KEYWORD 等。\n\n* `description`：该节点的查询子树，表示为字符串（`SHOW PLAN` 格式）\n\n* `children`：如果有，子节点列表\n\n* `max_field_pos`：字段内的最大位置\n\n一个关键词节点还会包括：\n\n* `word`：转换后的关键词。\n\n* `querypos`：该关键词在查询中的位置。\n\n* `excluded`：被排除的关键词。\n\n* `expanded`：前缀扩展添加的关键词。\n\n* `field_start`：关键词必须出现在字段开头。\n\n* `field_end`：关键词必须出现在字段结尾。\n\n* `boost`：关键词的 IDF 会乘以此值。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_4\n\n<!-- response SQL -->\n\nCODE_BLOCK_5\n\n<!-- request JSON -->\n\nCODE_BLOCK_6\n\n<!-- response JSON -->\n\nCODE_BLOCK_7\n\n<!-- request PHP -->\n\nCODE_BLOCK_8\n\n<!-- response PHP -->\n\nCODE_BLOCK_9\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_10\n\n<!-- response Python -->\n\nCODE_BLOCK_11\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_12\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_13\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_14\n\n<!-- response javascript -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_16\n\n<!-- response Java -->\n\nCODE_BLOCK_17\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_18\n\n<!-- response C# -->\n\nCODE_BLOCK_19\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_20\n\n<!-- response Rust -->\n\nCODE_BLOCK_21\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_22\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_23\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_24\n\n<!-- response Go -->\n\nCODE_BLOCK_25\n\n<!-- end -->\n\n<!-- example SHOW PLAN EXPANSION -->\n\n在某些情况下，评估后的查询树可能与原始查询树大不相同，这是由于扩展和其他转换导致的。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_26\n\n<!-- response SQL -->\n\nCODE_BLOCK_27\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_28\n\n<!-- response JSON -->\n\nCODE_BLOCK_29\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_30\n\n<!-- response PHP -->\n\nCODE_BLOCK_31\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_32\n\n<!-- response Python -->\n\nCODE_BLOCK_33\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_34\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_35\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_36\n\n<!-- response javascript -->\n\nCODE_BLOCK_37\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_38\n\n<!-- response Java -->\n\nCODE_BLOCK_39\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_40\n\n<!-- response C# -->\n\nCODE_BLOCK_41\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_42\n\n<!-- response Rust -->\n\nCODE_BLOCK_43\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_44\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_45\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_46\n\n<!-- response Go -->\n\nCODE_BLOCK_47\n\n<!-- end -->\n\n## 无需执行查询即分析\n\n<!-- Example Explain_query -->\n\nSQL 语句 `EXPLAIN QUERY` 允许显示给定全文查询的执行树，而无需对表执行实际的搜索查询。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- response SQL -->\n\nCODE_BLOCK_49\n\n<!-- request JSON -->\n\nCODE_BLOCK_50\n\n<!-- response JSON -->\n\nCODE_BLOCK_51\n\n<!-- end -->\n\n<!-- Example Explain_query_dot -->\n\n`EXPLAIN QUERY ... option format=dot` 允许以层级格式显示提供的全文查询执行树，适合使用现有工具（如 https://dreampuf.github.io/GraphvizOnline）进行可视化：\n\n![EXPLAIN QUERY graphviz example](graphviz.png)\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_52\n\n<!-- response SQL -->\n\nCODE_BLOCK_53\n\n<!-- request JSON -->\n\nCODE_BLOCK_54\n\n<!-- response JSON -->\n\nCODE_BLOCK_55\n\n<!-- request JSON -->\n\nCODE_BLOCK_56\n\n<!-- response JSON -->\n\nCODE_BLOCK_57\n\n<!-- end -->\n\n## 查看匹配因子值\n\n<!-- example factors -->",
      "russian": "# Профилирование поиска\n\n## Как интерпретируется запрос\n\nРассмотрим следующий сложный пример запроса:\n\nCODE_BLOCK_0\n\nПолное значение этого поиска:\n\n* Найти слова 'hello' и 'world' расположенные рядом в любом поле документа;\n\n* Кроме того, тот же документ должен содержать слова 'example' и 'program' в поле title, с максимум, но не включая, 5 словами между ними; (например, \"example PHP program\" подойдет, но \"example script to introduce outside data into the correct context for your program\" не подойдет, так как между двумя словами 5 или более слов)\n\n* Более того, тот же документ должен содержать слово 'python' в поле body, при этом исключая 'php' или 'perl';\n\n* Наконец, в том же документе должно быть слово 'code' в любом поле.\n\nОператор OR имеет приоритет над AND, поэтому \"looking for cat | dog | mouse\" означает \"looking for (cat | dog | mouse)\", а не \"(looking for cat) | dog | mouse\".\n\nЧтобы понять, как будет выполняться запрос, Manticore Search предоставляют инструменты профилирования запросов для изучения дерева запроса, созданного выражением запроса.\n\n<!-- example profiling -->\n\n## Профилирование дерева запроса в SQL\n\nЧтобы включить профилирование полнотекстового запроса с помощью SQL-запроса, нужно активировать его перед выполнением нужного запроса:\n\nCODE_BLOCK_1\n\nЧтобы посмотреть дерево запроса, выполните команду `SHOW PLAN` сразу после выполнения запроса:\n\nCODE_BLOCK_2\n\nЭта команда вернет структуру выполненного запроса. Учтите, что все 3 инструкции - SET profiling, сам запрос и SHOW - должны быть выполнены в одной сессии.\n\n## Профилирование запроса через HTTP JSON\n\nПри использовании протокола HTTP JSON можно просто включить `\"profile\":true`, чтобы получить в ответе структуру дерева полнотекстового запроса.\n\nCODE_BLOCK_3\n\nВ ответе будет объект `profile`, содержащий член `query`.\n\nСвойство `query` содержит преобразованное дерево полнотекстового запроса. Каждый узел состоит из:\n\n* `type`: тип узла, который может быть AND, OR, PHRASE, KEYWORD и др.\n\n* `description`: поддерево запроса для этого узла, представленное строкой (в формате `SHOW PLAN`)\n\n* `children`: дочерние узлы, если есть\n\n* `max_field_pos`: максимальная позиция внутри поля\n\nУ узла типа keyword дополнительно будут:\n\n* `word`: преобразованное ключевое слово.\n\n* `querypos`: позиция этого ключевого слова в запросе.\n\n* `excluded`: ключевое слово исключено из запроса.\n\n* `expanded`: ключевое слово добавлено расширением префикса.\n\n* `field_start`: ключевое слово должно появляться в начале поля.\n\n* `field_end`: ключевое слово должно появляться в конце поля.\n\n* `boost`: ИДФ ключевого слова будет умножаться на это значение.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_4\n\n<!-- response SQL -->\n\nCODE_BLOCK_5\n\n<!-- request JSON -->\n\nCODE_BLOCK_6\n\n<!-- response JSON -->\n\nCODE_BLOCK_7\n\n<!-- request PHP -->\n\nCODE_BLOCK_8\n\n<!-- response PHP -->\n\nCODE_BLOCK_9\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_10\n\n<!-- response Python -->\n\nCODE_BLOCK_11\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_12\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_13\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_14\n\n<!-- response javascript -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_16\n\n<!-- response Java -->\n\nCODE_BLOCK_17\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_18\n\n<!-- response C# -->\n\nCODE_BLOCK_19\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_20\n\n<!-- response Rust -->\n\nCODE_BLOCK_21\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_22\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_23\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_24\n\n<!-- response Go -->\n\nCODE_BLOCK_25\n\n<!-- end -->\n\n<!-- example SHOW PLAN EXPANSION -->\n\nВ некоторых случаях вычисленное дерево запроса может значительно отличаться от исходного из-за расширений и других преобразований.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_26\n\n<!-- response SQL -->\n\nCODE_BLOCK_27\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_28\n\n<!-- response JSON -->\n\nCODE_BLOCK_29\n\n<!-- intro -->\n\n##### PHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_30\n\n<!-- response PHP -->\n\nCODE_BLOCK_31\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_32\n\n<!-- response Python -->\n\nCODE_BLOCK_33\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_34\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_35\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_36\n\n<!-- response javascript -->\n\nCODE_BLOCK_37\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_38\n\n<!-- response Java -->\n\nCODE_BLOCK_39\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_40\n\n<!-- response C# -->\n\nCODE_BLOCK_41\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_42\n\n<!-- response Rust -->\n\nCODE_BLOCK_43\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_44\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_45\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_46\n\n<!-- response Go -->\n\nCODE_BLOCK_47\n\n<!-- end -->\n\n## Профилирование без выполнения запроса\n\n<!-- Example Explain_query -->\n\nSQL-инструкция `EXPLAIN QUERY` позволяет отобразить дерево выполнения для заданного полнотекстового запроса без фактического выполнения поиска по таблице.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- response SQL -->\n\nCODE_BLOCK_49\n\n<!-- request JSON -->\n\nCODE_BLOCK_50\n\n<!-- response JSON -->\n\nCODE_BLOCK_51\n\n<!-- end -->\n\n<!-- Example Explain_query_dot -->\n\n`EXPLAIN QUERY ... option format=dot` позволяет отобразить дерево выполнения заданного полнотекстового запроса в иерархическом формате, подходящем для визуализации с помощью существующих инструментов, таких как https://dreampuf.github.io/GraphvizOnline:\n\n![Пример EXPLAIN QUERY graphviz](graphviz.png)\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_52\n\n<!-- response SQL -->\n\nCODE_BLOCK_53\n\n<!-- request JSON -->\n\nCODE_BLOCK_54\n\n<!-- response JSON -->\n\nCODE_BLOCK_55\n\n<!-- request JSON -->\n\nCODE_BLOCK_56\n\n<!-- response JSON -->\n\nCODE_BLOCK_57\n\n<!-- end -->\n\n## Просмотр значений факторов совпадения\n\n<!-- example factors -->"
    },
    "is_code_or_comment": false
  }
}
