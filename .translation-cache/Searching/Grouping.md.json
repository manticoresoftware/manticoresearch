{
  "1488d87346b8d56362461229f83245f6942de2d2bb8a2bbef7ee94eeabc22531": {
    "original": "<!-- response TypeScript -->\n\nCODE_BLOCK_92\n\n<!-- request Go -->\n\nCODE_BLOCK_93\n\n<!-- response Go -->\n\nCODE_BLOCK_94\n\n<!-- end -->\n\n## Aggregation functions\n\nBesides `COUNT(*)`, which returns the number of elements in each group, you can use various other aggregation functions:\n\n<!-- example distinct -->\n\n##### COUNT(DISTINCT field)\n\nWhile `COUNT(*)` returns the number of all elements in the group, `COUNT(DISTINCT field)` returns the number of unique values of the field in the group, which may be completely different from the total count. For instance, you can have 100 elements in the group, but all with the same value for a certain field. `COUNT(DISTINCT field)` helps to determine that. To demonstrate this, let's create a table \"students\" with the student's name, age, and major:\n\nCODE_BLOCK_95\n\nso we have:\n\nCODE_BLOCK_96\n\nIn the example, you can see that if we GROUP BY major and display both `COUNT(*)` and `COUNT(DISTINCT age)`, it becomes clear that there are two students who chose the major \"cs\" with two unique ages, but for the major \"arts\", there are also two students, yet only one unique age.\n\nThere can be at most one `COUNT(DISTINCT)` per query.\n\n** By default, counts are approximate **\n\nActually, some of them are exact, while others are approximate. More on that below.\n\nManticore supports two algorithms for computing counts of distinct values. One is a legacy algorithm that uses a lot of memory and is usually slow. It collects `{group; value}` pairs, sorts them, and periodically discards duplicates. The benefit of this approach is that it guarantees exact counts within a plain table. You can enable it by setting the [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) option to `0`.\n\nThe other algorithm (enabled by default) loads counts into a hash table and returns its size. If the hash table becomes too large, its contents are moved into a `HyperLogLog`. This is where the counts become approximate since `HyperLogLog` is a probabilistic algorithm. The advantage is that the maximum memory usage per group is fixed and depends on the accuracy of the `HyperLogLog`. The overall memory usage also depends on the [max_matches](../Searching/Options.md#max_matches) setting, which reflects the number of groups.\n\nThe [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) option sets the threshold below which counts are guaranteed to be exact. The `HyperLogLog` accuracy setting and the threshold for the \"hash table to HyperLogLog\" conversion are derived from this setting. It's important to use this option with caution because doubling it will double the maximum memory required for count calculations. The maximum memory usage can be roughly estimated using this formula: `64 * max_matches * distinct_precision_threshold`. Note that this is the worst-case scenario, and in most cases, count calculations will use significantly less RAM.\n\n**`COUNT(DISTINCT)` against a distributed table or a real-time table consisting of multiple disk chunks may return inaccurate results**, but the result should be accurate for a distributed table consisting of local plain or real-time tables with the same schema (identical set/order of fields, but may have different tokenization settings).\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_97\n\n<!-- response SQL -->\n\nCODE_BLOCK_98\n\n<!-- end -->\n\n<!-- example concat -->\n\n##### GROUP_CONCAT(field)\n\nOften, you want to better understand the contents of each group. You can use [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) for that, but it would return additional rows you might not want in the output. `GROUP_CONCAT()` enriches your grouping by concatenating values of a specific field in the group. Let's take the previous example and improve it by displaying all the ages in each group.\n\n`GROUP_CONCAT(field)` returns the list as comma-separated values.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_99\n\n<!-- response SQL -->\n\nCODE_BLOCK_100\n\n<!-- end -->\n\n<!-- example sum -->\n\n##### SUM(), MIN(), MAX(), AVG()\n\nOf course, you can also obtain the sum, average, minimum, and maximum values within a group.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_101\n\n<!-- response SQL -->\n\nCODE_BLOCK_102\n\n<!-- end -->\n\n<!-- example accuracy -->\n\n## Grouping accuracy\n\nGrouping is done in fixed memory, which depends on the [max_matches](../Searching/Options.md#max_matches) setting. If `max_matches` allows for storage of all found groups, the results will be 100% accurate. However, if the value of `max_matches` is lower, the results will be less accurate.\n\nWhen parallel processing is involved, it can become more complicated. When `pseudo_sharding` is enabled and/or when using an RT table with several disk chunks, each chunk or pseudo shard gets a result set that is no larger than `max_matches`. This can lead to inaccuracies in aggregates and group counts when the result sets from different threads are merged. To fix this, either a larger `max_matches` value or disabling parallel processing can be used.\n\nManticore will try to increase `max_matches` up to [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold) if it detects that groupby may return inaccurate results. Detection is based on the number of unique values of the groupby attribute, which is retrieved from secondary indexes (if present).\n\nTo ensure accurate aggregates and/or group counts when using RT tables or `pseudo_sharding`, `accurate_aggregation` can be enabled. This will try to increase `max_matches` up to the threshold, and if the threshold is not high enough, Manticore will disable parallel processing for the query.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_103\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "<!-- response TypeScript -->\n\nCODE_BLOCK_92\n\n<!-- request Go -->\n\nCODE_BLOCK_93\n\n<!-- response Go -->\n\nCODE_BLOCK_94\n\n<!-- end -->\n\n## Aggregation functions\n\nBesides `COUNT(*)`, which returns the number of elements in each group, you can use various other aggregation functions:\n\n<!-- example distinct -->\n\n##### COUNT(DISTINCT field)\n\nWhile `COUNT(*)` returns the number of all elements in the group, `COUNT(DISTINCT field)` returns the number of unique values of the field in the group, which may be completely different from the total count. For instance, you can have 100 elements in the group, but all with the same value for a certain field. `COUNT(DISTINCT field)` helps to determine that. To demonstrate this, let's create a table \"students\" with the student's name, age, and major:\n\nCODE_BLOCK_95\n\nso we have:\n\nCODE_BLOCK_96\n\nIn the example, you can see that if we GROUP BY major and display both `COUNT(*)` and `COUNT(DISTINCT age)`, it becomes clear that there are two students who chose the major \"cs\" with two unique ages, but for the major \"arts\", there are also two students, yet only one unique age.\n\nThere can be at most one `COUNT(DISTINCT)` per query.\n\n** By default, counts are approximate **\n\nActually, some of them are exact, while others are approximate. More on that below.\n\nManticore supports two algorithms for computing counts of distinct values. One is a legacy algorithm that uses a lot of memory and is usually slow. It collects `{group; value}` pairs, sorts them, and periodically discards duplicates. The benefit of this approach is that it guarantees exact counts within a plain table. You can enable it by setting the [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) option to `0`.\n\nThe other algorithm (enabled by default) loads counts into a hash table and returns its size. If the hash table becomes too large, its contents are moved into a `HyperLogLog`. This is where the counts become approximate since `HyperLogLog` is a probabilistic algorithm. The advantage is that the maximum memory usage per group is fixed and depends on the accuracy of the `HyperLogLog`. The overall memory usage also depends on the [max_matches](../Searching/Options.md#max_matches) setting, which reflects the number of groups.\n\nThe [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) option sets the threshold below which counts are guaranteed to be exact. The `HyperLogLog` accuracy setting and the threshold for the \"hash table to HyperLogLog\" conversion are derived from this setting. It's important to use this option with caution because doubling it will double the maximum memory required for count calculations. The maximum memory usage can be roughly estimated using this formula: `64 * max_matches * distinct_precision_threshold`. Note that this is the worst-case scenario, and in most cases, count calculations will use significantly less RAM.\n\n**`COUNT(DISTINCT)` against a distributed table or a real-time table consisting of multiple disk chunks may return inaccurate results**, but the result should be accurate for a distributed table consisting of local plain or real-time tables with the same schema (identical set/order of fields, but may have different tokenization settings).\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_97\n\n<!-- response SQL -->\n\nCODE_BLOCK_98\n\n<!-- end -->\n\n<!-- example concat -->\n\n##### GROUP_CONCAT(field)\n\nOften, you want to better understand the contents of each group. You can use [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) for that, but it would return additional rows you might not want in the output. `GROUP_CONCAT()` enriches your grouping by concatenating values of a specific field in the group. Let's take the previous example and improve it by displaying all the ages in each group.\n\n`GROUP_CONCAT(field)` returns the list as comma-separated values.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_99\n\n<!-- response SQL -->\n\nCODE_BLOCK_100\n\n<!-- end -->\n\n<!-- example sum -->\n\n##### SUM(), MIN(), MAX(), AVG()\n\nOf course, you can also obtain the sum, average, minimum, and maximum values within a group.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_101\n\n<!-- response SQL -->\n\nCODE_BLOCK_102\n\n<!-- end -->\n\n<!-- example accuracy -->\n\n## Grouping accuracy\n\nGrouping is done in fixed memory, which depends on the [max_matches](../Searching/Options.md#max_matches) setting. If `max_matches` allows for storage of all found groups, the results will be 100% accurate. However, if the value of `max_matches` is lower, the results will be less accurate.\n\nWhen parallel processing is involved, it can become more complicated. When `pseudo_sharding` is enabled and/or when using an RT table with several disk chunks, each chunk or pseudo shard gets a result set that is no larger than `max_matches`. This can lead to inaccuracies in aggregates and group counts when the result sets from different threads are merged. To fix this, either a larger `max_matches` value or disabling parallel processing can be used.\n\nManticore will try to increase `max_matches` up to [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold) if it detects that groupby may return inaccurate results. Detection is based on the number of unique values of the groupby attribute, which is retrieved from secondary indexes (if present).\n\nTo ensure accurate aggregates and/or group counts when using RT tables or `pseudo_sharding`, `accurate_aggregation` can be enabled. This will try to increase `max_matches` up to the threshold, and if the threshold is not high enough, Manticore will disable parallel processing for the query.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_103\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "<!-- response TypeScript -->\n\nCODE_BLOCK_92\n\n<!-- request Go -->\n\nCODE_BLOCK_93\n\n<!-- response Go -->\n\nCODE_BLOCK_94\n\n<!-- end -->\n\n## Aggregation functions\n\nBesides `COUNT(*)`, which returns the number of elements in each group, you can use various other aggregation functions:\n\n<!-- example distinct -->\n\n##### COUNT(DISTINCT field)\n\nWhile `COUNT(*)` returns the number of all elements in the group, `COUNT(DISTINCT field)` returns the number of unique values of the field in the group, which may be completely different from the total count. For instance, you can have 100 elements in the group, but all with the same value for a certain field. `COUNT(DISTINCT field)` helps to determine that. To demonstrate this, let's create a table \"students\" with the student's name, age, and major:\n\nCODE_BLOCK_95\n\nso we have:\n\nCODE_BLOCK_96\n\nIn the example, you can see that if we GROUP BY major and display both `COUNT(*)` and `COUNT(DISTINCT age)`, it becomes clear that there are two students who chose the major \"cs\" with two unique ages, but for the major \"arts\", there are also two students, yet only one unique age.\n\nThere can be at most one `COUNT(DISTINCT)` per query.\n\n** By default, counts are approximate **\n\nActually, some of them are exact, while others are approximate. More on that below.\n\nManticore supports two algorithms for computing counts of distinct values. One is a legacy algorithm that uses a lot of memory and is usually slow. It collects `{group; value}` pairs, sorts them, and periodically discards duplicates. The benefit of this approach is that it guarantees exact counts within a plain table. You can enable it by setting the [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) option to `0`.\n\nThe other algorithm (enabled by default) loads counts into a hash table and returns its size. If the hash table becomes too large, its contents are moved into a `HyperLogLog`. This is where the counts become approximate since `HyperLogLog` is a probabilistic algorithm. The advantage is that the maximum memory usage per group is fixed and depends on the accuracy of the `HyperLogLog`. The overall memory usage also depends on the [max_matches](../Searching/Options.md#max_matches) setting, which reflects the number of groups.\n\nThe [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) option sets the threshold below which counts are guaranteed to be exact. The `HyperLogLog` accuracy setting and the threshold for the \"hash table to HyperLogLog\" conversion are derived from this setting. It's important to use this option with caution because doubling it will double the maximum memory required for count calculations. The maximum memory usage can be roughly estimated using this formula: `64 * max_matches * distinct_precision_threshold`. Note that this is the worst-case scenario, and in most cases, count calculations will use significantly less RAM.\n\n**`COUNT(DISTINCT)` against a distributed table or a real-time table consisting of multiple disk chunks may return inaccurate results**, but the result should be accurate for a distributed table consisting of local plain or real-time tables with the same schema (identical set/order of fields, but may have different tokenization settings).\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_97\n\n<!-- response SQL -->\n\nCODE_BLOCK_98\n\n<!-- end -->\n\n<!-- example concat -->\n\n##### GROUP_CONCAT(field)\n\nOften, you want to better understand the contents of each group. You can use [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) for that, but it would return additional rows you might not want in the output. `GROUP_CONCAT()` enriches your grouping by concatenating values of a specific field in the group. Let's take the previous example and improve it by displaying all the ages in each group.\n\n`GROUP_CONCAT(field)` returns the list as comma-separated values.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_99\n\n<!-- response SQL -->\n\nCODE_BLOCK_100\n\n<!-- end -->\n\n<!-- example sum -->\n\n##### SUM(), MIN(), MAX(), AVG()\n\nOf course, you can also obtain the sum, average, minimum, and maximum values within a group.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_101\n\n<!-- response SQL -->\n\nCODE_BLOCK_102\n\n<!-- end -->\n\n<!-- example accuracy -->\n\n## Grouping accuracy\n\nGrouping is done in fixed memory, which depends on the [max_matches](../Searching/Options.md#max_matches) setting. If `max_matches` allows for storage of all found groups, the results will be 100% accurate. However, if the value of `max_matches` is lower, the results will be less accurate.\n\nWhen parallel processing is involved, it can become more complicated. When `pseudo_sharding` is enabled and/or when using an RT table with several disk chunks, each chunk or pseudo shard gets a result set that is no larger than `max_matches`. This can lead to inaccuracies in aggregates and group counts when the result sets from different threads are merged. To fix this, either a larger `max_matches` value or disabling parallel processing can be used.\n\nManticore will try to increase `max_matches` up to [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold) if it detects that groupby may return inaccurate results. Detection is based on the number of unique values of the groupby attribute, which is retrieved from secondary indexes (if present).\n\nTo ensure accurate aggregates and/or group counts when using RT tables or `pseudo_sharding`, `accurate_aggregation` can be enabled. This will try to increase `max_matches` up to the threshold, and if the threshold is not high enough, Manticore will disable parallel processing for the query.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_103\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": true
  },
  "33a62fad63e0639f879c04a221a6e46f18af5d32dbd1ea2596792c82b52b242a": {
    "original": "# Grouping search results\n\n<!-- example general -->\n\nGrouping search results is often helpful for obtaining per-group match counts or other aggregations. For example, it's useful for creating a graph illustrating the number of matching blog posts per month or grouping web search results by site or forum posts by author, etc.\n\nManticore supports the grouping of search results by single or multiple columns and computed expressions. The results can:\n\n* Be sorted within a group\n\n* Return more than one row per group\n\n* Have groups filtered\n\n* Have groups sorted\n\n* Be aggregated using the [aggregation functions](../Searching/Grouping.md#Aggregation-functions)\n\n<!-- intro -->\n\nThe general syntax is:\n\n<!-- request SQL -->\n\nGeneral syntax\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nJSON query format currently supports a basic grouping that can retrieve aggregate values and their count(*).\n\nCODE_BLOCK_1\n\nThe standard query output returns the result set without grouping, which can be hidden using `limit` (or `size`).\n\nThe aggregation requires setting a `size` for the group's result set size.\n\n<!-- end -->\n\n<!-- example group1 -->\n\n### Just Grouping\n\nGrouping is quite simple - just add \"GROUP BY smth\" to the end of your `SELECT` query. The something can be:\n\n* Any non-full-text field from the table: integer, float, string, MVA (multi-value attribute)\n\n* Or, if you used an alias in the `SELECT` list, you can GROUP BY it too\n\nYou can omit any [aggregation functions](../Searching/Grouping.md#Aggregation-functions) in the `SELECT` list and it will still work:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- example group2 -->\n\nIn most cases, however, you'll want to obtain some aggregated data for each group, such as:\n\n* `COUNT(*)` to simply get the number of elements in each group\n\n* or `AVG(field)` to calculate the average value of the field within the group\n\nFor HTTP JSON requests, using a single `aggs` bucket with `limit=0` at the main query level works similarly to a SQL query with `GROUP BY` and `COUNT(*)`, providing equivalent behavior and performance.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_4\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_5\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_6\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_7\n\n<!-- request JSON -->\n\nCODE_BLOCK_8\n\n<!-- response JSON -->\n\nCODE_BLOCK_9\n\n<!-- request PHP -->\n\nCODE_BLOCK_10\n\n<!-- response PHP -->\n\nCODE_BLOCK_11\n\n<!-- request Python -->\n\nCODE_BLOCK_12\n\n<!-- response Python -->\n\nCODE_BLOCK_13\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_14\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_15\n\n<!-- request Javascript -->\n\nCODE_BLOCK_16\n\n<!-- response Javascript -->\n\nCODE_BLOCK_17\n\n<!-- request Java -->\n\nCODE_BLOCK_18\n\n<!-- response Java -->\n\nCODE_BLOCK_19\n\n<!-- request C# -->\n\nCODE_BLOCK_20\n\n<!-- response C# -->\n\nCODE_BLOCK_21\n\n<!-- request Rust -->\n\nCODE_BLOCK_22\n\n<!-- response Rust -->\n\nCODE_BLOCK_23\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_24\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_25\n\n<!-- request Go -->\n\nCODE_BLOCK_26\n\n<!-- response Go -->\n\nCODE_BLOCK_27\n\n<!-- end -->\n\n<!-- example sort1 -->\n\n##### Sorting groups\n\nBy default, groups are not sorted, and the next thing you typically want to do is order them by something, like the field you're grouping by:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_28\n\n<!-- response SQL -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n<!-- example sort2 -->\n\nAlternatively, you can sort by the aggregation:\n\n* by `count(*)` to display groups with the most elements first\n\n* by `avg(rental_rate)` to show the highest-rated movies first. Note that in the example, it's done via an alias: `avg(rental_rate)` is first mapped to `avg` in the `SELECT` list, and then we simply do `ORDER BY avg`\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_30\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_31\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_32\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n<!-- example group3 -->\n\n##### GROUP BY multiple fields at once\n\nIn some cases, you might want to group not just by a single field, but by multiple fields at once, such as a movie's category and year:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_34\n\n<!-- response SQL -->\n\nCODE_BLOCK_35\n\n<!-- request JSON -->\n\nCODE_BLOCK_36\n\n<!-- response JSON -->\n\nCODE_BLOCK_37\n\n<!-- end -->\n\n<!-- example group4 -->\n\n##### Give me N rows\n\nSometimes it's useful to see not just a single element per group, but multiple. This can be easily achieved with the help of `GROUP N BY`. For example, in the following case, we get two movies for each year rather than just one, which a simple `GROUP BY release_year` would have returned.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_38\n\n<!-- response SQL -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example group5 -->\n\n##### Sorting inside a group\n\nAnother crucial analytics requirement is to sort elements within a group. To achieve this, use the `WITHIN GROUP ORDER BY ... {ASC|DESC}` clause. For example, let's get the highest-rated film for each year. Note that it works in parallel with just `ORDER BY`:\n\n* `WITHIN GROUP ORDER BY` sorts results **inside a group**\n\n* while just `GROUP BY` **sorts the groups themselves**\n\nThese two work entirely independently.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_40\n\n<!-- response SQL -->\n\nCODE_BLOCK_41\n\n<!-- end -->\n\n<!-- example group6 -->\n\n##### Filter groups\n\n`HAVING expression` is a helpful clause for filtering groups. While `WHERE` is applied before grouping, `HAVING` works with the groups. For example, let's keep only those years when the average rental rate of the films for that year was higher than 3. We get only four years:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_42\n\n<!-- response SQL -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\nNote that `HAVING` does not affect `total_found` in the [search query meta info](../Node_info_and_management/SHOW_META.md#SHOW-META).\n\n<!-- example group7 -->\n\n##### GROUPBY()",
    "translations": {
      "chinese": "# 分组搜索结果\n\n<!-- example general -->\n\n分组搜索结果通常有助于获取每组的匹配计数或其他聚合。例如，它对于创建每月匹配博客文章数量的图表，或按网站分组网页搜索结果，或按作者分组论坛帖子等非常有用。\n\nManticore 支持按单列或多列以及计算表达式对搜索结果进行分组。结果可以：\n\n* 在组内排序\n\n* 每组返回多行\n\n* 过滤组\n\n* 对组进行排序\n\n* 使用[聚合函数](../Searching/Grouping.md#Aggregation-functions)进行聚合\n\n<!-- intro -->\n\n通用语法是：\n\n<!-- request SQL -->\n\n通用语法\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nJSON 查询格式目前支持基本分组，可以检索聚合值及其 count(*)。\n\nCODE_BLOCK_1\n\n标准查询输出返回未分组的结果集，可以使用 `limit`（或 `size`）隐藏。\n\n聚合需要设置组结果集的 `size`。\n\n<!-- end -->\n\n<!-- example group1 -->\n\n### 仅分组\n\n分组非常简单——只需在 `SELECT` 查询末尾添加 \"GROUP BY smth\"。这里的某物可以是：\n\n* 表中的任何非全文字段：整数、浮点数、字符串、多值属性（MVA）\n\n* 或者，如果你在 `SELECT` 列表中使用了别名，也可以按别名分组\n\n你可以省略 `SELECT` 列表中的任何[聚合函数](../Searching/Grouping.md#Aggregation-functions)，它仍然有效：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- example group2 -->\n\n然而，在大多数情况下，你会想为每个组获取一些聚合数据，例如：\n\n* `COUNT(*)` 用于简单获取每组中的元素数量\n\n* 或者 `AVG(field)` 用于计算组内字段的平均值\n\n对于 HTTP JSON 请求，使用单个带有 `limit=0` 的 `aggs` 桶，在主查询级别，效果类似于带有 `GROUP BY` 和 `COUNT(*)` 的 SQL 查询，提供等效的行为和性能。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_4\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_5\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_6\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_7\n\n<!-- request JSON -->\n\nCODE_BLOCK_8\n\n<!-- response JSON -->\n\nCODE_BLOCK_9\n\n<!-- request PHP -->\n\nCODE_BLOCK_10\n\n<!-- response PHP -->\n\nCODE_BLOCK_11\n\n<!-- request Python -->\n\nCODE_BLOCK_12\n\n<!-- response Python -->\n\nCODE_BLOCK_13\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_14\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_15\n\n<!-- request Javascript -->\n\nCODE_BLOCK_16\n\n<!-- response Javascript -->\n\nCODE_BLOCK_17\n\n<!-- request Java -->\n\nCODE_BLOCK_18\n\n<!-- response Java -->\n\nCODE_BLOCK_19\n\n<!-- request C# -->\n\nCODE_BLOCK_20\n\n<!-- response C# -->\n\nCODE_BLOCK_21\n\n<!-- request Rust -->\n\nCODE_BLOCK_22\n\n<!-- response Rust -->\n\nCODE_BLOCK_23\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_24\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_25\n\n<!-- request Go -->\n\nCODE_BLOCK_26\n\n<!-- response Go -->\n\nCODE_BLOCK_27\n\n<!-- end -->\n\n<!-- example sort1 -->\n\n##### 对组进行排序\n\n默认情况下，组不排序，接下来你通常想做的是按某个字段排序，比如你分组所用的字段：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_28\n\n<!-- response SQL -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n<!-- example sort2 -->\n\n或者，你可以按聚合排序：\n\n* 按 `count(*)` 显示元素最多的组优先\n\n* 按 `avg(rental_rate)` 显示评分最高的电影优先。注意示例中是通过别名完成的：`avg(rental_rate)` 首先在 `SELECT` 列表中映射为 `avg`，然后我们简单地做 `ORDER BY avg`\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_30\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_31\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_32\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n<!-- example group3 -->\n\n##### 同时按多个字段 GROUP BY\n\n在某些情况下，你可能想不仅按单个字段分组，而是同时按多个字段分组，比如电影的类别和年份：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_34\n\n<!-- response SQL -->\n\nCODE_BLOCK_35\n\n<!-- request JSON -->\n\nCODE_BLOCK_36\n\n<!-- response JSON -->\n\nCODE_BLOCK_37\n\n<!-- end -->\n\n<!-- example group4 -->\n\n##### 给我 N 行\n\n有时查看每组不止一个元素很有用。这可以通过 `GROUP N BY` 轻松实现。例如，下面的例子中，我们为每年获取两部电影，而不是简单的 `GROUP BY release_year` 返回的一部。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_38\n\n<!-- response SQL -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example group5 -->\n\n##### 组内排序\n\n另一个关键的分析需求是对组内元素排序。为此，使用 `WITHIN GROUP ORDER BY ... {ASC|DESC}` 子句。例如，我们获取每年评分最高的电影。注意它与单独的 `ORDER BY` 并行工作：\n\n* `WITHIN GROUP ORDER BY` 对组内结果排序\n\n* 而单独的 `GROUP BY` 对组本身排序\n\n这两者完全独立工作。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_40\n\n<!-- response SQL -->\n\nCODE_BLOCK_41\n\n<!-- end -->\n\n<!-- example group6 -->\n\n##### 过滤组\n\n`HAVING expression` 是过滤组的有用子句。`WHERE` 在分组前应用，而 `HAVING` 作用于组。例如，我们只保留那些该年电影平均租赁率高于 3 的年份。结果只有四个年份：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_42\n\n<!-- response SQL -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n注意 `HAVING` 不影响[搜索查询元信息](../Node_info_and_management/SHOW_META.md#SHOW-META)中的 `total_found`。\n\n<!-- example group7 -->\n\n##### GROUPBY()",
      "russian": "# Группировка результатов поиска\n\n<!-- example general -->\n\nГруппировка результатов поиска часто полезна для получения количества совпадений по группам или других агрегатов. Например, это удобно для создания графика, иллюстрирующего количество совпадающих блог-постов по месяцам, или для группировки результатов веб-поиска по сайту, или сообщений на форуме по автору и т.д.\n\nManticore поддерживает группировку результатов поиска по одному или нескольким столбцам и вычисляемым выражениям. Результаты могут:\n\n* Быть отсортированы внутри группы\n\n* Возвращать более одной строки на группу\n\n* Иметь отфильтрованные группы\n\n* Иметь отсортированные группы\n\n* Быть агрегированы с помощью [функций агрегации](../Searching/Grouping.md#Aggregation-functions)\n\n<!-- intro -->\n\nОбщий синтаксис:\n\n<!-- request SQL -->\n\nОбщий синтаксис\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nФормат JSON-запроса в настоящее время поддерживает базовую группировку, которая может получать агрегированные значения и их count(*).\n\nCODE_BLOCK_1\n\nСтандартный вывод запроса возвращает набор результатов без группировки, который можно скрыть с помощью `limit` (или `size`).\n\nАгрегация требует установки `size` для размера набора результатов группы.\n\n<!-- end -->\n\n<!-- example group1 -->\n\n### Просто группировка\n\nГруппировка довольно проста — просто добавьте \"GROUP BY smth\" в конец вашего запроса `SELECT`. Что-то может быть:\n\n* Любым не полнотекстовым полем из таблицы: integer, float, string, MVA (мульти-значение атрибута)\n\n* Или, если вы использовали псевдоним в списке `SELECT`, вы также можете группировать по нему\n\nВы можете опустить любые [функции агрегации](../Searching/Grouping.md#Aggregation-functions) в списке `SELECT`, и это всё равно будет работать:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- example group2 -->\n\nВ большинстве случаев, однако, вы захотите получить некоторые агрегированные данные для каждой группы, например:\n\n* `COUNT(*)`, чтобы просто получить количество элементов в каждой группе\n\n* или `AVG(field)`, чтобы вычислить среднее значение поля внутри группы\n\nДля HTTP JSON-запросов использование одного `aggs` bucket с `limit=0` на уровне основного запроса работает аналогично SQL-запросу с `GROUP BY` и `COUNT(*)`, обеспечивая эквивалентное поведение и производительность.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_4\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_5\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_6\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_7\n\n<!-- request JSON -->\n\nCODE_BLOCK_8\n\n<!-- response JSON -->\n\nCODE_BLOCK_9\n\n<!-- request PHP -->\n\nCODE_BLOCK_10\n\n<!-- response PHP -->\n\nCODE_BLOCK_11\n\n<!-- request Python -->\n\nCODE_BLOCK_12\n\n<!-- response Python -->\n\nCODE_BLOCK_13\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_14\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_15\n\n<!-- request Javascript -->\n\nCODE_BLOCK_16\n\n<!-- response Javascript -->\n\nCODE_BLOCK_17\n\n<!-- request Java -->\n\nCODE_BLOCK_18\n\n<!-- response Java -->\n\nCODE_BLOCK_19\n\n<!-- request C# -->\n\nCODE_BLOCK_20\n\n<!-- response C# -->\n\nCODE_BLOCK_21\n\n<!-- request Rust -->\n\nCODE_BLOCK_22\n\n<!-- response Rust -->\n\nCODE_BLOCK_23\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_24\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_25\n\n<!-- request Go -->\n\nCODE_BLOCK_26\n\n<!-- response Go -->\n\nCODE_BLOCK_27\n\n<!-- end -->\n\n<!-- example sort1 -->\n\n##### Сортировка групп\n\nПо умолчанию группы не сортируются, и следующим шагом обычно является их упорядочивание по чему-то, например, по полю, по которому вы группируете:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_28\n\n<!-- response SQL -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n<!-- example sort2 -->\n\nИли вы можете сортировать по агрегату:\n\n* по `count(*)`, чтобы сначала отображать группы с наибольшим количеством элементов\n\n* по `avg(rental_rate)`, чтобы показывать фильмы с наивысшим рейтингом первыми. Обратите внимание, что в примере это сделано через псевдоним: `avg(rental_rate)` сначала сопоставляется с `avg` в списке `SELECT`, а затем мы просто делаем `ORDER BY avg`\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_30\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_31\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_32\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n<!-- example group3 -->\n\n##### GROUP BY по нескольким полям одновременно\n\nВ некоторых случаях вы можете захотеть группировать не только по одному полю, но и по нескольким сразу, например, по категории фильма и году:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_34\n\n<!-- response SQL -->\n\nCODE_BLOCK_35\n\n<!-- request JSON -->\n\nCODE_BLOCK_36\n\n<!-- response JSON -->\n\nCODE_BLOCK_37\n\n<!-- end -->\n\n<!-- example group4 -->\n\n##### Дайте мне N строк\n\nИногда полезно видеть не только один элемент на группу, а несколько. Это легко достигается с помощью `GROUP N BY`. Например, в следующем случае мы получаем два фильма для каждого года, а не только один, как вернул бы простой `GROUP BY release_year`.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_38\n\n<!-- response SQL -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example group5 -->\n\n##### Сортировка внутри группы\n\nЕще одно важное требование аналитики — сортировать элементы внутри группы. Для этого используйте конструкцию `WITHIN GROUP ORDER BY ... {ASC|DESC}`. Например, получим фильм с наивысшим рейтингом для каждого года. Обратите внимание, что это работает параллельно с обычным `ORDER BY`:\n\n* `WITHIN GROUP ORDER BY` сортирует результаты **внутри группы**\n\n* в то время как просто `GROUP BY` **сортирует сами группы**\n\nЭти два работают полностью независимо.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_40\n\n<!-- response SQL -->\n\nCODE_BLOCK_41\n\n<!-- end -->\n\n<!-- example group6 -->\n\n##### Фильтрация групп\n\n`HAVING expression` — полезное выражение для фильтрации групп. В то время как `WHERE` применяется до группировки, `HAVING` работает с группами. Например, оставим только те годы, когда средний рейтинг аренды фильмов за этот год был выше 3. Мы получаем только четыре года:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_42\n\n<!-- response SQL -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\nОбратите внимание, что `HAVING` не влияет на `total_found` в [метаинформации поискового запроса](../Node_info_and_management/SHOW_META.md#SHOW-META).\n\n<!-- example group7 -->\n\n##### GROUPBY()"
    },
    "is_code_or_comment": false
  },
  "78a82db0b5037b2fa9f9ca03667decb540e7c31fb332dc0937353aa3b651afa1": {
    "original": "There is a function `GROUPBY()` which returns the key of the current group. It's useful in many cases, especially when you [GROUP BY an MVA](../Searching/Grouping.md#Grouping-by-MVA-%28multi-value-attributes%29) or a [JSON value](../Searching/Grouping.md#Grouping-by-a-JSON-node).\n\nIt can also be used in `HAVING`, for example, to keep only years 2000 and 2002.\n\nNote that `GROUPBY()`is not recommended for use when you GROUP BY multiple fields at once. It will still work, but since the group key in this case is a compound of field values, it may not appear the way you expect.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_44\n\n<!-- response SQL -->\n\nCODE_BLOCK_45\n\n<!-- end -->\n\n<!-- example mva -->\n\n##### Grouping by MVA (multi-value attributes)\n\nManticore supports grouping by [MVA](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29). To demonstrate how it works, let's create a table \"shoes\" with MVA \"sizes\" and insert a few documents into it:\n\nCODE_BLOCK_46\n\nso we have:\n\nCODE_BLOCK_47\n\nIf we now GROUP BY \"sizes\", it will process all our multi-value attributes and return an aggregation for each, in this case just the count:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- response SQL -->\n\nCODE_BLOCK_49\n\n<!-- request JSON -->\n\nCODE_BLOCK_50\n\n<!-- response JSON -->\n\nCODE_BLOCK_51\n\n<!-- request PHP -->\n\nCODE_BLOCK_52\n\n<!-- response PHP -->\n\nCODE_BLOCK_53\n\n<!-- request Python -->\n\nCODE_BLOCK_54\n\n<!-- response Python -->\n\nCODE_BLOCK_55\n\n<!-- request Javascript -->\n\nCODE_BLOCK_56\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_57\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_58\n\n<!-- request Javascript -->\n\nCODE_BLOCK_59\n\n<!-- response Javascript -->\n\nCODE_BLOCK_60\n\n<!-- request Java -->\n\nCODE_BLOCK_61\n\n<!-- response Java -->\n\nCODE_BLOCK_62\n\n<!-- request C# -->\n\nCODE_BLOCK_63\n\n<!-- response C# -->\n\nCODE_BLOCK_64\n\n<!-- request Rust -->\n\nCODE_BLOCK_65\n\n<!-- response Rust -->\n\nCODE_BLOCK_66\n\nres = await searchApi.search({\n\n  index: 'test',\n\n  aggs: {\n\n    mva_agg: {\n\n      terms: { field: \"mva_field\", size: 2 }\n\n    }\n\n  }\n\n});\n\nCODE_BLOCK_67\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":4,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_68\n\nquery := map[string]interface{} {};\n\nsearchRequest.SetQuery(query);\n\naggTerms := manticoreclient.NewAggregationTerms()\n\naggTerms.SetField(\"mva_field\")\n\naggTerms.SetSize(2)\n\naggregation := manticoreclient.NewAggregation()\n\naggregation.setTerms(aggTerms)\n\nsearchRequest.SetAggregation(aggregation)\n\nres, _, _ := apiClient.SearchAPI.Search(context.Background()).SearchRequest(*searchRequest).Execute()\n\nCODE_BLOCK_69\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":5,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_70\n\ncreate table products(title text, meta json);\n\ninsert into products values(0,'nike','{\"color\":\"red\"}'),(0,'adidas','{\"color\":\"red\"}'),(0,'puma','{\"color\":\"green\"}');\n\nCODE_BLOCK_71\n\nSELECT * FROM products;\n\n+---------------------+-------------------+--------+\n\n| id                  | meta              | title  |\n\n+---------------------+-------------------+--------+\n\n| 1657851069130080268 | {\"color\":\"red\"}   | nike   |\n\n| 1657851069130080269 | {\"color\":\"red\"}   | adidas |\n\n| 1657851069130080270 | {\"color\":\"green\"} | puma   |\n\n+---------------------+-------------------+--------+\n\nCODE_BLOCK_72\n\nSELECT groupby() color, count(*) from products GROUP BY meta.color;\n\nCODE_BLOCK_73\n\n+-------+----------+\n\n| color | count(*) |\n\n+-------+----------+\n\n| red   |        2 |\n\n| green |        1 |\n\n+-------+----------+\n\nCODE_BLOCK_74\n\nPOST /search -d '\n\n    {\n\n     \"table\" : \"products\",\n\n     \"limit\": 0,\n\n     \"aggs\" :\n\n     {\n\n        \"color\" :\n\n         {\n\n            \"terms\" :\n\n             {\n\n              \"field\":\"meta.color\",\n\n              \"size\":100\n\n             }\n\n         }\n\n     }\n\n    }\n\n'\n\nCODE_BLOCK_75\n\n{\n\n  \"took\": 0,\n\n  \"timed_out\": false,\n\n  \"hits\": {\n\n    \"total\": 3,\n\n    \"hits\": [\n\n    ]\n\n  },\n\n  \"aggregations\": {\n\n    \"color\": {\n\n      \"buckets\": [\n\n        {\n\n          \"key\": \"green\",\n\n          \"doc_count\": 1\n\n        },\n\n        {\n\n          \"key\": \"red\",\n\n          \"doc_count\": 2\n\n        }\n\n      ]\n\n    }\n\n  }\n\n}\n\nCODE_BLOCK_76\n\n$index->setName('products');\n\n$search = $index->search('');\n\n$search->limit(0);\n\n$search->facet('meta.color','color',100);\n\n$results = $search->get();\n\nprint_r($results->getFacets());\n\nCODE_BLOCK_77\n\nArray\n\n(\n\n    [color] => Array\n\n        (\n\n            [buckets] => Array\n\n                (\n\n                    [0] => Array\n\n                        (\n\n                            [key] => green\n\n                            [doc_count] => 1\n\n                        )\n\n                    [1] => Array\n\n                        (\n\n                            [key] => red\n\n                            [doc_count] => 2\n\n                        )\n\n                )\n\n        )\n\n)\n\nCODE_BLOCK_78\n\nres =searchApi.search({\"table\":\"products\",\"limit\":0,\"aggs\":{\"color\":{\"terms\":{\"field\":\"meta.color\",\"size\":100}}}})\n\nCODE_BLOCK_79\n\n{'aggregations': {u'color': {u'buckets': [{u'doc_count': 1,\n\n                                           u'key': u'green'},\n\n                                          {u'doc_count': 2, u'key': u'red'}]}},\n\n 'hits': {'hits': [], 'max_score': None, 'total': 3},\n\n 'profile': None,\n\n 'timed_out': False,\n\n 'took': 0}\n\nCODE_BLOCK_80\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_81\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_82\n\n<!-- request Javascript -->\n\nCODE_BLOCK_83\n\n<!-- response Javascript -->\n\nCODE_BLOCK_84\n\n<!-- request Java -->\n\nCODE_BLOCK_85\n\n<!-- response Java -->\n\nCODE_BLOCK_86\n\n<!-- request C# -->\n\nCODE_BLOCK_87\n\n<!-- response C# -->\n\nCODE_BLOCK_88\n\n<!-- request Rust -->\n\nCODE_BLOCK_89\n\n<!-- response Rust -->\n\nCODE_BLOCK_90\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_91",
    "translations": {
      "chinese": "有一个函数 `GROUPBY()`，它返回当前分组的键。在许多情况下非常有用，特别是当你[按 MVA 分组](../Searching/Grouping.md#Grouping-by-MVA-%28multi-value-attributes%29)或按[JSON 值分组](../Searching/Grouping.md#Grouping-by-a-JSON-node)时。\n\n它也可以用于 `HAVING`，例如，只保留年份 2000 和 2002。\n\n注意，当你一次按多个字段进行 GROUP BY 时，不推荐使用 `GROUPBY()`。它仍然可以工作，但由于此时的分组键是字段值的复合，可能不会以你期望的方式出现。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_44\n\n<!-- response SQL -->\n\nCODE_BLOCK_45\n\n<!-- end -->\n\n<!-- example mva -->\n\n##### 按 MVA（多值属性）分组\n\nManticore 支持按[MVA](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29)分组。为了演示其工作原理，我们创建一个包含 MVA 字段 \"sizes\" 的表 \"shoes\"，并插入一些文档：\n\nCODE_BLOCK_46\n\n所以我们有：\n\nCODE_BLOCK_47\n\n如果现在按 \"sizes\" 进行 GROUP BY，它将处理所有多值属性，并为每个返回一个聚合，在此例中仅是计数：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- response SQL -->\n\nCODE_BLOCK_49\n\n<!-- request JSON -->\n\nCODE_BLOCK_50\n\n<!-- response JSON -->\n\nCODE_BLOCK_51\n\n<!-- request PHP -->\n\nCODE_BLOCK_52\n\n<!-- response PHP -->\n\nCODE_BLOCK_53\n\n<!-- request Python -->\n\nCODE_BLOCK_54\n\n<!-- response Python -->\n\nCODE_BLOCK_55\n\n<!-- request Javascript -->\n\nCODE_BLOCK_56\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_57\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_58\n\n<!-- request Javascript -->\n\nCODE_BLOCK_59\n\n<!-- response Javascript -->\n\nCODE_BLOCK_60\n\n<!-- request Java -->\n\nCODE_BLOCK_61\n\n<!-- response Java -->\n\nCODE_BLOCK_62\n\n<!-- request C# -->\n\nCODE_BLOCK_63\n\n<!-- response C# -->\n\nCODE_BLOCK_64\n\n<!-- request Rust -->\n\nCODE_BLOCK_65\n\n<!-- response Rust -->\n\nCODE_BLOCK_66\n\nres = await searchApi.search({\n\n  index: 'test',\n\n  aggs: {\n\n    mva_agg: {\n\n      terms: { field: \"mva_field\", size: 2 }\n\n    }\n\n  }\n\n});\n\nCODE_BLOCK_67\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":4,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_68\n\nquery := map[string]interface{} {};\n\nsearchRequest.SetQuery(query);\n\naggTerms := manticoreclient.NewAggregationTerms()\n\naggTerms.SetField(\"mva_field\")\n\naggTerms.SetSize(2)\n\naggregation := manticoreclient.NewAggregation()\n\naggregation.setTerms(aggTerms)\n\nsearchRequest.SetAggregation(aggregation)\n\nres, _, _ := apiClient.SearchAPI.Search(context.Background()).SearchRequest(*searchRequest).Execute()\n\nCODE_BLOCK_69\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":5,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_70\n\ncreate table products(title text, meta json);\n\ninsert into products values(0,'nike','{\"color\":\"red\"}'),(0,'adidas','{\"color\":\"red\"}'),(0,'puma','{\"color\":\"green\"}');\n\nCODE_BLOCK_71\n\nSELECT * FROM products;\n\n+---------------------+-------------------+--------+\n\n| id                  | meta              | title  |\n\n+---------------------+-------------------+--------+\n\n| 1657851069130080268 | {\"color\":\"red\"}   | nike   |\n\n| 1657851069130080269 | {\"color\":\"red\"}   | adidas |\n\n| 1657851069130080270 | {\"color\":\"green\"} | puma   |\n\n+---------------------+-------------------+--------+\n\nCODE_BLOCK_72\n\nSELECT groupby() color, count(*) from products GROUP BY meta.color;\n\nCODE_BLOCK_73\n\n+-------+----------+\n\n| color | count(*) |\n\n+-------+----------+\n\n| red   |        2 |\n\n| green |        1 |\n\n+-------+----------+\n\nCODE_BLOCK_74\n\nPOST /search -d '\n\n    {\n\n     \"table\" : \"products\",\n\n     \"limit\": 0,\n\n     \"aggs\" :\n\n     {\n\n        \"color\" :\n\n         {\n\n            \"terms\" :\n\n             {\n\n              \"field\":\"meta.color\",\n\n              \"size\":100\n\n             }\n\n         }\n\n     }\n\n    }\n\n'\n\nCODE_BLOCK_75\n\n{\n\n  \"took\": 0,\n\n  \"timed_out\": false,\n\n  \"hits\": {\n\n    \"total\": 3,\n\n    \"hits\": [\n\n    ]\n\n  },\n\n  \"aggregations\": {\n\n    \"color\": {\n\n      \"buckets\": [\n\n        {\n\n          \"key\": \"green\",\n\n          \"doc_count\": 1\n\n        },\n\n        {\n\n          \"key\": \"red\",\n\n          \"doc_count\": 2\n\n        }\n\n      ]\n\n    }\n\n  }\n\n}\n\nCODE_BLOCK_76\n\n$index->setName('products');\n\n$search = $index->search('');\n\n$search->limit(0);\n\n$search->facet('meta.color','color',100);\n\n$results = $search->get();\n\nprint_r($results->getFacets());\n\nCODE_BLOCK_77\n\nArray\n\n(\n\n    [color] => Array\n\n        (\n\n            [buckets] => Array\n\n                (\n\n                    [0] => Array\n\n                        (\n\n                            [key] => green\n\n                            [doc_count] => 1\n\n                        )\n\n                    [1] => Array\n\n                        (\n\n                            [key] => red\n\n                            [doc_count] => 2\n\n                        )\n\n                )\n\n        )\n\n)\n\nCODE_BLOCK_78\n\nres =searchApi.search({\"table\":\"products\",\"limit\":0,\"aggs\":{\"color\":{\"terms\":{\"field\":\"meta.color\",\"size\":100}}}})\n\nCODE_BLOCK_79\n\n{'aggregations': {u'color': {u'buckets': [{u'doc_count': 1,\n\n                                           u'key': u'green'},\n\n                                          {u'doc_count': 2, u'key': u'red'}]}},\n\n 'hits': {'hits': [], 'max_score': None, 'total': 3},\n\n 'profile': None,\n\n 'timed_out': False,\n\n 'took': 0}\n\nCODE_BLOCK_80\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_81\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_82\n\n<!-- request Javascript -->\n\nCODE_BLOCK_83\n\n<!-- response Javascript -->\n\nCODE_BLOCK_84\n\n<!-- request Java -->\n\nCODE_BLOCK_85\n\n<!-- response Java -->\n\nCODE_BLOCK_86\n\n<!-- request C# -->\n\nCODE_BLOCK_87\n\n<!-- response C# -->\n\nCODE_BLOCK_88\n\n<!-- request Rust -->\n\nCODE_BLOCK_89\n\n<!-- response Rust -->\n\nCODE_BLOCK_90\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_91",
      "russian": "Есть функция `GROUPBY()`, которая возвращает ключ текущей группы. Она полезна во многих случаях, особенно когда вы [GROUP BY по MVA](../Searching/Grouping.md#Grouping-by-MVA-%28multi-value-attributes%29) или по [JSON значению](../Searching/Grouping.md#Grouping-by-a-JSON-node).\n\nЕё также можно использовать в `HAVING`, например, чтобы оставить только годы 2000 и 2002.\n\nОбратите внимание, что `GROUPBY()` не рекомендуется использовать, когда вы GROUP BY по нескольким полям одновременно. Она всё равно будет работать, но поскольку ключ группы в этом случае является составным из значений полей, он может не отображаться так, как вы ожидаете.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_44\n\n<!-- response SQL -->\n\nCODE_BLOCK_45\n\n<!-- end -->\n\n<!-- example mva -->\n\n##### Группировка по MVA (мультизначным атрибутам)\n\nManticore поддерживает группировку по [MVA](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29). Чтобы показать, как это работает, давайте создадим таблицу \"shoes\" с MVA \"sizes\" и вставим в неё несколько документов:\n\nCODE_BLOCK_46\n\nтак что у нас есть:\n\nCODE_BLOCK_47\n\nЕсли теперь мы сделаем GROUP BY по \"sizes\", он обработает все наши мультизначные атрибуты и вернёт агрегацию для каждого, в данном случае просто количество:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- response SQL -->\n\nCODE_BLOCK_49\n\n<!-- request JSON -->\n\nCODE_BLOCK_50\n\n<!-- response JSON -->\n\nCODE_BLOCK_51\n\n<!-- request PHP -->\n\nCODE_BLOCK_52\n\n<!-- response PHP -->\n\nCODE_BLOCK_53\n\n<!-- request Python -->\n\nCODE_BLOCK_54\n\n<!-- response Python -->\n\nCODE_BLOCK_55\n\n<!-- request Javascript -->\n\nCODE_BLOCK_56\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_57\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_58\n\n<!-- request Javascript -->\n\nCODE_BLOCK_59\n\n<!-- response Javascript -->\n\nCODE_BLOCK_60\n\n<!-- request Java -->\n\nCODE_BLOCK_61\n\n<!-- response Java -->\n\nCODE_BLOCK_62\n\n<!-- request C# -->\n\nCODE_BLOCK_63\n\n<!-- response C# -->\n\nCODE_BLOCK_64\n\n<!-- request Rust -->\n\nCODE_BLOCK_65\n\n<!-- response Rust -->\n\nCODE_BLOCK_66\n\nres = await searchApi.search({\n\n  index: 'test',\n\n  aggs: {\n\n    mva_agg: {\n\n      terms: { field: \"mva_field\", size: 2 }\n\n    }\n\n  }\n\n});\n\nCODE_BLOCK_67\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":4,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_68\n\nquery := map[string]interface{} {};\n\nsearchRequest.SetQuery(query);\n\naggTerms := manticoreclient.NewAggregationTerms()\n\naggTerms.SetField(\"mva_field\")\n\naggTerms.SetSize(2)\n\naggregation := manticoreclient.NewAggregation()\n\naggregation.setTerms(aggTerms)\n\nsearchRequest.SetAggregation(aggregation)\n\nres, _, _ := apiClient.SearchAPI.Search(context.Background()).SearchRequest(*searchRequest).Execute()\n\nCODE_BLOCK_69\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":5,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_70\n\ncreate table products(title text, meta json);\n\ninsert into products values(0,'nike','{\"color\":\"red\"}'),(0,'adidas','{\"color\":\"red\"}'),(0,'puma','{\"color\":\"green\"}');\n\nCODE_BLOCK_71\n\nSELECT * FROM products;\n\n+---------------------+-------------------+--------+\n\n| id                  | meta              | title  |\n\n+---------------------+-------------------+--------+\n\n| 1657851069130080268 | {\"color\":\"red\"}   | nike   |\n\n| 1657851069130080269 | {\"color\":\"red\"}   | adidas |\n\n| 1657851069130080270 | {\"color\":\"green\"} | puma   |\n\n+---------------------+-------------------+--------+\n\nCODE_BLOCK_72\n\nSELECT groupby() color, count(*) from products GROUP BY meta.color;\n\nCODE_BLOCK_73\n\n+-------+----------+\n\n| color | count(*) |\n\n+-------+----------+\n\n| red   |        2 |\n\n| green |        1 |\n\n+-------+----------+\n\nCODE_BLOCK_74\n\nPOST /search -d '\n\n    {\n\n     \"table\" : \"products\",\n\n     \"limit\": 0,\n\n     \"aggs\" :\n\n     {\n\n        \"color\" :\n\n         {\n\n            \"terms\" :\n\n             {\n\n              \"field\":\"meta.color\",\n\n              \"size\":100\n\n             }\n\n         }\n\n     }\n\n    }\n\n'\n\nCODE_BLOCK_75\n\n{\n\n  \"took\": 0,\n\n  \"timed_out\": false,\n\n  \"hits\": {\n\n    \"total\": 3,\n\n    \"hits\": [\n\n    ]\n\n  },\n\n  \"aggregations\": {\n\n    \"color\": {\n\n      \"buckets\": [\n\n        {\n\n          \"key\": \"green\",\n\n          \"doc_count\": 1\n\n        },\n\n        {\n\n          \"key\": \"red\",\n\n          \"doc_count\": 2\n\n        }\n\n      ]\n\n    }\n\n  }\n\n}\n\nCODE_BLOCK_76\n\n$index->setName('products');\n\n$search = $index->search('');\n\n$search->limit(0);\n\n$search->facet('meta.color','color',100);\n\n$results = $search->get();\n\nprint_r($results->getFacets());\n\nCODE_BLOCK_77\n\nArray\n\n(\n\n    [color] => Array\n\n        (\n\n            [buckets] => Array\n\n                (\n\n                    [0] => Array\n\n                        (\n\n                            [key] => green\n\n                            [doc_count] => 1\n\n                        )\n\n                    [1] => Array\n\n                        (\n\n                            [key] => red\n\n                            [doc_count] => 2\n\n                        )\n\n                )\n\n        )\n\n)\n\nCODE_BLOCK_78\n\nres =searchApi.search({\"table\":\"products\",\"limit\":0,\"aggs\":{\"color\":{\"terms\":{\"field\":\"meta.color\",\"size\":100}}}})\n\nCODE_BLOCK_79\n\n{'aggregations': {u'color': {u'buckets': [{u'doc_count': 1,\n\n                                           u'key': u'green'},\n\n                                          {u'doc_count': 2, u'key': u'red'}]}},\n\n 'hits': {'hits': [], 'max_score': None, 'total': 3},\n\n 'profile': None,\n\n 'timed_out': False,\n\n 'took': 0}\n\nCODE_BLOCK_80\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_81\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_82\n\n<!-- request Javascript -->\n\nCODE_BLOCK_83\n\n<!-- response Javascript -->\n\nCODE_BLOCK_84\n\n<!-- request Java -->\n\nCODE_BLOCK_85\n\n<!-- response Java -->\n\nCODE_BLOCK_86\n\n<!-- request C# -->\n\nCODE_BLOCK_87\n\n<!-- response C# -->\n\nCODE_BLOCK_88\n\n<!-- request Rust -->\n\nCODE_BLOCK_89\n\n<!-- response Rust -->\n\nCODE_BLOCK_90\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_91"
    },
    "is_code_or_comment": false
  },
  "a57081049e78fd08c7a9f16e7d4a4197490f76ca42882b50bfed4bdebcb68978": {
    "original": "# Grouping search results\n\n<!-- example general -->\n\nGrouping search results is often helpful for obtaining per-group match counts or other aggregations. For example, it's useful for creating a graph illustrating the number of matching blog posts per month or grouping web search results by site or forum posts by author, etc.\n\nManticore supports the grouping of search results by single or multiple columns and computed expressions. The results can:\n\n* Be sorted within a group\n\n* Return more than one row per group\n\n* Have groups filtered\n\n* Have groups sorted\n\n* Be aggregated using the [aggregation functions](../Searching/Grouping.md#Aggregation-functions)\n\n<!-- intro -->\n\nThe general syntax is:\n\n<!-- request SQL -->\n\nGeneral syntax\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nJSON query format currently supports a basic grouping that can retrieve aggregate values and their count(*).\n\nCODE_BLOCK_1\n\nThe standard query output returns the result set without grouping, which can be hidden using `limit` (or `size`).\n\nThe aggregation requires setting a `size` for the group's result set size.\n\n<!-- end -->\n\n<!-- example group1 -->\n\n### Just Grouping\n\nGrouping is quite simple - just add \"GROUP BY smth\" to the end of your `SELECT` query. The something can be:\n\n* Any non-full-text field from the table: integer, float, string, MVA (multi-value attribute)\n\n* Or, if you used an alias in the `SELECT` list, you can GROUP BY it too\n\nYou can omit any [aggregation functions](../Searching/Grouping.md#Aggregation-functions) in the `SELECT` list and it will still work:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- example group2 -->\n\nIn most cases, however, you'll want to obtain some aggregated data for each group, such as:\n\n* `COUNT(*)` to simply get the number of elements in each group\n\n* or `AVG(field)` to calculate the average value of the field within the group\n\nFor HTTP JSON requests, using a single `aggs` bucket with `limit=0` at the main query level works similarly to a SQL query with `GROUP BY` and `COUNT(*)`, providing equivalent behavior and performance.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_4\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_5\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_6\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_7\n\n<!-- request JSON -->\n\nCODE_BLOCK_8\n\n<!-- response JSON -->\n\nCODE_BLOCK_9\n\n<!-- request PHP -->\n\nCODE_BLOCK_10\n\n<!-- response PHP -->\n\nCODE_BLOCK_11\n\n<!-- request Python -->\n\nCODE_BLOCK_12\n\n<!-- response Python -->\n\nCODE_BLOCK_13\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_14\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_15\n\n<!-- request Javascript -->\n\nCODE_BLOCK_16\n\n<!-- response Javascript -->\n\nCODE_BLOCK_17\n\n<!-- request Java -->\n\nCODE_BLOCK_18\n\n<!-- response Java -->\n\nCODE_BLOCK_19\n\n<!-- request C# -->\n\nCODE_BLOCK_20\n\n<!-- response C# -->\n\nCODE_BLOCK_21\n\n<!-- request Rust -->\n\nCODE_BLOCK_22\n\n<!-- response Rust -->\n\nCODE_BLOCK_23\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_24\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_25\n\n<!-- request Go -->\n\nCODE_BLOCK_26\n\n<!-- response Go -->\n\nCODE_BLOCK_27\n\n<!-- end -->\n\n<!-- example sort1 -->\n\n##### Sorting groups\n\nBy default, groups are not sorted, and the next thing you typically want to do is order them by something, like the field you're grouping by:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_28\n\n<!-- response SQL -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n<!-- example sort2 -->\n\nAlternatively, you can sort by the aggregation:\n\n* by `count(*)` to display groups with the most elements first\n\n* by `avg(rental_rate)` to show the highest-rated movies first. Note that in the example, it's done via an alias: `avg(rental_rate)` is first mapped to `avg` in the `SELECT` list, and then we simply do `ORDER BY avg`\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_30\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_31\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_32\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n<!-- example group3 -->\n\n##### GROUP BY multiple fields at once\n\nIn some cases, you might want to group not just by a single field, but by multiple fields at once, such as a movie's category and year:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_34\n\n<!-- response SQL -->\n\nCODE_BLOCK_35\n\n<!-- request JSON -->\n\nCODE_BLOCK_36\n\n<!-- response JSON -->\n\nCODE_BLOCK_37\n\n<!-- end -->\n\n<!-- example group4 -->\n\n##### Give me N rows\n\nSometimes it's useful to see not just a single element per group, but multiple. This can be easily achieved with the help of `GROUP N BY`. For example, in the following case, we get two movies for each year rather than just one, which a simple `GROUP BY release_year` would have returned.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_38\n\n<!-- response SQL -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example group5 -->\n\n##### Sorting inside a group\n\nAnother crucial analytics requirement is to sort elements within a group. To achieve this, use the `WITHIN GROUP ORDER BY ... {ASC|DESC}` clause. For example, let's get the highest-rated film for each year. Note that it works in parallel with just `ORDER BY`:\n\n* `WITHIN GROUP ORDER BY` sorts results **inside a group**\n\n* while just `GROUP BY` **sorts the groups themselves**\n\nThese two work entirely independently.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_40\n\n<!-- response SQL -->\n\nCODE_BLOCK_41\n\n<!-- end -->\n\n<!-- example group6 -->\n\n##### Filter groups\n\n`HAVING expression` is a helpful clause for filtering groups. While `WHERE` is applied before grouping, `HAVING` works with the groups. For example, let's keep only those years when the average rental rate of the films for that year was higher than 3. We get only four years:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_42\n\n<!-- response SQL -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n<!-- example group7 -->\n\n##### GROUPBY()",
    "translations": {
      "chinese": "# 分组搜索结果\n\n<!-- example general -->\n\n分组搜索结果通常有助于获取每个组的匹配计数或其他聚合。例如，它对于创建按月匹配博客帖子数量的图表，或按站点分组网页搜索结果，或按作者分组论坛帖子等非常有用。\n\nManticore 支持按单列、多列和计算表达式对搜索结果进行分组。结果可以：\n\n* 在组内排序\n\n* 每组返回多行\n\n* 对组进行过滤\n\n* 对组进行排序\n\n* 使用[聚合函数](../Searching/Grouping.md#Aggregation-functions)进行聚合\n\n<!-- intro -->\n\n一般语法是：\n\n<!-- request SQL -->\n\n通用语法\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nJSON 查询格式目前支持基本分组，可检索聚合值及其 count(*)。\n\nCODE_BLOCK_1\n\n标准查询输出返回未分组的结果集，可以通过 `limit`（或 `size`）将其隐藏。\n\n聚合需要设置组结果集大小 `size`。\n\n<!-- end -->\n\n<!-- example group1 -->\n\n### 仅分组\n\n分组相当简单——只需在 `SELECT` 查询末尾添加 \"GROUP BY smth\"。该某物可以是：\n\n* 表中的任何非全文字段：整数、浮点、字符串、多值属性(MVA)\n\n* 或者，如果你在 `SELECT` 列表中使用了别名，也可以按它分组\n\n你可以省略 `SELECT` 列表中的任何[聚合函数](../Searching/Grouping.md#Aggregation-functions)，仍然有效：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- example group2 -->\n\n然而，在大多数情况下，你会想为每个组获得一些聚合数据，例如：\n\n* `COUNT(*)` 仅仅获取每组的元素数量\n\n* 或 `AVG(field)` 计算组内字段的平均值\n\n对于 HTTP JSON 请求，使用单个 `aggs` 桶，并在主查询级别设置 `limit=0`，效果类似于 SQL 查询中的 `GROUP BY` 和 `COUNT(*)`，提供等效的行为和性能。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_4\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_5\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_6\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_7\n\n<!-- request JSON -->\n\nCODE_BLOCK_8\n\n<!-- response JSON -->\n\nCODE_BLOCK_9\n\n<!-- request PHP -->\n\nCODE_BLOCK_10\n\n<!-- response PHP -->\n\nCODE_BLOCK_11\n\n<!-- request Python -->\n\nCODE_BLOCK_12\n\n<!-- response Python -->\n\nCODE_BLOCK_13\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_14\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_15\n\n<!-- request Javascript -->\n\nCODE_BLOCK_16\n\n<!-- response Javascript -->\n\nCODE_BLOCK_17\n\n<!-- request Java -->\n\nCODE_BLOCK_18\n\n<!-- response Java -->\n\nCODE_BLOCK_19\n\n<!-- request C# -->\n\nCODE_BLOCK_20\n\n<!-- response C# -->\n\nCODE_BLOCK_21\n\n<!-- request Rust -->\n\nCODE_BLOCK_22\n\n<!-- response Rust -->\n\nCODE_BLOCK_23\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_24\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_25\n\n<!-- request Go -->\n\nCODE_BLOCK_26\n\n<!-- response Go -->\n\nCODE_BLOCK_27\n\n<!-- end -->\n\n<!-- example sort1 -->\n\n##### 组内排序\n\n默认情况下，组不排序，接下来你通常想做的是按某个字段排序，比如你分组用的字段：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_28\n\n<!-- response SQL -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n<!-- example sort2 -->\n\n另外，你也可以按聚合排序：\n\n* 按 `count(*)` 排序，优先显示包含最多元素的组\n\n* 按 `avg(rental_rate)` 排序，优先显示评分最高的电影。注意，在示例中，这是通过别名完成的：先在 `SELECT` 列表中将 `avg(rental_rate)` 映射为 `avg`，然后简单地执行 `ORDER BY avg`\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_30\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_31\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_32\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n<!-- example group3 -->\n\n##### 一次按多个字段 GROUP BY\n\n有时你可能想按多个字段分组，而不仅仅是单个字段，比如电影的类别和年份：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_34\n\n<!-- response SQL -->\n\nCODE_BLOCK_35\n\n<!-- request JSON -->\n\nCODE_BLOCK_36\n\n<!-- response JSON -->\n\nCODE_BLOCK_37\n\n<!-- end -->\n\n<!-- example group4 -->\n\n##### 给我 N 行\n\n有时看到每组不止一个元素也很有用。这可以通过 `GROUP N BY` 很容易实现。例如，下面的例子中，我们为每个年份获取两部电影，而不是简单 `GROUP BY release_year` 只返回一部。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_38\n\n<!-- response SQL -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example group5 -->\n\n##### 组内排序\n\n另一个关键的分析需求是对组内元素排序。为此，使用 `WITHIN GROUP ORDER BY ... {ASC|DESC}` 子句。例如，获取每年评分最高的电影。注意它与普通的 `ORDER BY` 并行工作：\n\n* `WITHIN GROUP ORDER BY` 对**组内**结果排序\n\n* 而仅用 `GROUP BY` 对**组本身**排序\n\n这两者完全独立工作。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_40\n\n<!-- response SQL -->\n\nCODE_BLOCK_41\n\n<!-- end -->\n\n<!-- example group6 -->\n\n##### 过滤组\n\n`HAVING expression` 是过滤组的有用子句。`WHERE` 用于分组前过滤，而 `HAVING` 用于分组后过滤。例如，我们只保留那些该年电影平均租赁率高于3的年份。结果只有四个年份：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_42\n\n<!-- response SQL -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n<!-- example group7 -->\n\n##### GROUPBY()",
      "russian": "# Группировка результатов поиска\n\n<!-- example general -->\n\nГруппировка результатов поиска часто полезна для получения количества совпадений по группам или других агрегатов. Например, это удобно для построения графика, иллюстрирующего количество совпадающих публикаций в блогах по месяцам, или для группировки результатов веб-поиска по сайту, сообщений форума по автору и т.д.\n\nManticore поддерживает группировку результатов поиска по одному или нескольким столбцам и вычисляемым выражениям. Результаты могут:\n\n* Быть отсортированы внутри группы\n\n* Возвращать более одной строки на группу\n\n* Фильтровать группы\n\n* Сортировать группы\n\n* Агрегироваться с помощью [функций агрегации](../Searching/Grouping.md#Aggregation-functions)\n\n<!-- intro -->\n\nОбщий синтаксис:\n\n<!-- request SQL -->\n\nОбщий синтаксис\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nФормат JSON-запроса в настоящее время поддерживает базовую группировку, которая может получать агрегатные значения и их count(*).\n\nCODE_BLOCK_1\n\nСтандартный вывод запроса возвращает набор результатов без группировки, который можно скрыть с помощью `limit` (или `size`).\n\nДля агрегации необходимо установить `size` для размера результирующего набора групп.\n\n<!-- end -->\n\n<!-- example group1 -->\n\n### Просто группировка\n\nГруппировка довольно проста — просто добавьте \"GROUP BY smth\" в конец вашего `SELECT` запроса. Что-то может быть:\n\n* Любым нефулл-текстовым полем из таблицы: integer, float, string, MVA (атрибут с множественным значением)\n\n* Или, если вы использовали псевдоним в списке `SELECT`, вы также можете использовать GROUP BY по нему\n\nВы можете опустить любые [функции агрегации](../Searching/Grouping.md#Aggregation-functions) в списке `SELECT`, и это все равно будет работать:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- example group2 -->\n\nВ большинстве случаев, однако, вы захотите получить некоторую агрегированную информацию для каждой группы, например:\n\n* `COUNT(*)` просто чтобы получить количество элементов в каждой группе\n\n* или `AVG(field)`, чтобы вычислить среднее значение поля внутри группы\n\nДля HTTP JSON-запросов использование одного бакета `aggs` с `limit=0` на уровне основного запроса работает аналогично SQL-запросу с `GROUP BY` и `COUNT(*)`, обеспечивая эквивалентное поведение и производительность.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_4\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_5\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_6\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_7\n\n<!-- request JSON -->\n\nCODE_BLOCK_8\n\n<!-- response JSON -->\n\nCODE_BLOCK_9\n\n<!-- request PHP -->\n\nCODE_BLOCK_10\n\n<!-- response PHP -->\n\nCODE_BLOCK_11\n\n<!-- request Python -->\n\nCODE_BLOCK_12\n\n<!-- response Python -->\n\nCODE_BLOCK_13\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_14\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_15\n\n<!-- request Javascript -->\n\nCODE_BLOCK_16\n\n<!-- response Javascript -->\n\nCODE_BLOCK_17\n\n<!-- request Java -->\n\nCODE_BLOCK_18\n\n<!-- response Java -->\n\nCODE_BLOCK_19\n\n<!-- request C# -->\n\nCODE_BLOCK_20\n\n<!-- response C# -->\n\nCODE_BLOCK_21\n\n<!-- request Rust -->\n\nCODE_BLOCK_22\n\n<!-- response Rust -->\n\nCODE_BLOCK_23\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_24\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_25\n\n<!-- request Go -->\n\nCODE_BLOCK_26\n\n<!-- response Go -->\n\nCODE_BLOCK_27\n\n<!-- end -->\n\n<!-- example sort1 -->\n\n##### Сортировка групп\n\nПо умолчанию группы не сортируются, и следующим обычно желаемым действием является их упорядочивание по чему-то, например, по полю, по которому происходит группировка:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_28\n\n<!-- response SQL -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n<!-- example sort2 -->\n\nВ качестве альтернативы, вы можете сортировать по агрегату:\n\n* по `count(*)`, чтобы сначала показать группы с наибольшим количеством элементов\n\n* по `avg(rental_rate)`, чтобы сначала показать фильмы с наивысшим рейтингом. Обратите внимание, что в примере это делается через псевдоним: `avg(rental_rate)` сначала сопоставлен с `avg` в списке `SELECT`, а затем мы просто делаем `ORDER BY avg`\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_30\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_31\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_32\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n<!-- example group3 -->\n\n##### GROUP BY по нескольким полям одновременно\n\nВ некоторых случаях вы можете захотеть группировать не только по одному полю, но по нескольким сразу, например, по категории фильма и году:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_34\n\n<!-- response SQL -->\n\nCODE_BLOCK_35\n\n<!-- request JSON -->\n\nCODE_BLOCK_36\n\n<!-- response JSON -->\n\nCODE_BLOCK_37\n\n<!-- end -->\n\n<!-- example group4 -->\n\n##### Дайте мне N строк\n\nИногда полезно видеть не только один элемент на группу, но и несколько. Это легко достигается с помощью `GROUP N BY`. Например, в следующем случае мы получаем два фильма для каждого года вместо одного, который вернул бы простой `GROUP BY release_year`.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_38\n\n<!-- response SQL -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example group5 -->\n\n##### Сортировка внутри группы\n\nЕще одно важное требование для аналитики — сортировка элементов внутри группы. Для этого используйте конструкцию `WITHIN GROUP ORDER BY ... {ASC|DESC}`. Например, получим фильм с наивысшим рейтингом для каждого года. Обратите внимание, что это работает параллельно с обычным `ORDER BY`:\n\n* `WITHIN GROUP ORDER BY` сортирует результаты **внутри группы**\n\n* а простой `GROUP BY` **сортирует сами группы**\n\nЭти два работают полностью независимо.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_40\n\n<!-- response SQL -->\n\nCODE_BLOCK_41\n\n<!-- end -->\n\n<!-- example group6 -->\n\n##### Фильтрация групп\n\n`HAVING expression` — полезная конструкция для фильтрации групп. В то время как `WHERE` применяется до группировки, `HAVING` работает с уже сгруппированными данными. Например, оставим только те года, когда средний рейтинг аренды фильмов за этот год был выше 3. В итоге мы получаем только четыре года:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_42\n\n<!-- response SQL -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n<!-- example group7 -->\n\n##### GROUPBY()"
    },
    "is_code_or_comment": false
  },
  "0084ee77b3be8c955c0604da4441d4b54fa7fd6c5bdd36e0e5412017a7624843": {
    "original": "CODE_BLOCK_84\n\n<!-- request Java -->\n\nCODE_BLOCK_85\n\n<!-- response Java -->\n\nCODE_BLOCK_86\n\n<!-- request C# -->\n\nCODE_BLOCK_87\n\n<!-- response C# -->\n\nCODE_BLOCK_88\n\n<!-- request Rust -->\n\nCODE_BLOCK_89\n\n<!-- response Rust -->\n\nCODE_BLOCK_90\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_91\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_92\n\n<!-- request Go -->\n\nCODE_BLOCK_93\n\n<!-- response Go -->\n\nCODE_BLOCK_94\n\n<!-- end -->\n\n## Aggregation functions\n\nBesides `COUNT(*)`, which returns the number of elements in each group, you can use various other aggregation functions:\n\n<!-- example distinct -->\n\n##### COUNT(DISTINCT field)\n\nWhile `COUNT(*)` returns the number of all elements in the group, `COUNT(DISTINCT field)` returns the number of unique values of the field in the group, which may be completely different from the total count. For instance, you can have 100 elements in the group, but all with the same value for a certain field. `COUNT(DISTINCT field)` helps to determine that. To demonstrate this, let's create a table \"students\" with the student's name, age, and major:\n\nCODE_BLOCK_95\n\nso we have:\n\nCODE_BLOCK_96\n\nIn the example, you can see that if we GROUP BY major and display both `COUNT(*)` and `COUNT(DISTINCT age)`, it becomes clear that there are two students who chose the major \"cs\" with two unique ages, but for the major \"arts\", there are also two students, yet only one unique age.\n\nThere can be at most one `COUNT(DISTINCT)` per query.\n\n** By default, counts are approximate **\n\nActually, some of them are exact, while others are approximate. More on that below.\n\nManticore supports two algorithms for computing counts of distinct values. One is a legacy algorithm that uses a lot of memory and is usually slow. It collects `{group; value}` pairs, sorts them, and periodically discards duplicates. The benefit of this approach is that it guarantees exact counts within a plain table. You can enable it by setting the [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) option to `0`.\n\nThe other algorithm (enabled by default) loads counts into a hash table and returns its size. If the hash table becomes too large, its contents are moved into a `HyperLogLog`. This is where the counts become approximate since `HyperLogLog` is a probabilistic algorithm. The advantage is that the maximum memory usage per group is fixed and depends on the accuracy of the `HyperLogLog`. The overall memory usage also depends on the [max_matches](../Searching/Options.md#max_matches) setting, which reflects the number of groups.\n\nThe [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) option sets the threshold below which counts are guaranteed to be exact. The `HyperLogLog` accuracy setting and the threshold for the \"hash table to HyperLogLog\" conversion are derived from this setting. It's important to use this option with caution because doubling it will double the maximum memory required for count calculations. The maximum memory usage can be roughly estimated using this formula: `64 * max_matches * distinct_precision_threshold`. Note that this is the worst-case scenario, and in most cases, count calculations will use significantly less RAM.\n\n**`COUNT(DISTINCT)` against a distributed table or a real-time table consisting of multiple disk chunks may return inaccurate results**, but the result should be accurate for a distributed table consisting of local plain or real-time tables with the same schema (identical set/order of fields, but may have different tokenization settings).\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_97\n\n<!-- response SQL -->\n\nCODE_BLOCK_98\n\n<!-- end -->\n\n<!-- example concat -->\n\n##### GROUP_CONCAT(field)\n\nOften, you want to better understand the contents of each group. You can use [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) for that, but it would return additional rows you might not want in the output. `GROUP_CONCAT()` enriches your grouping by concatenating values of a specific field in the group. Let's take the previous example and improve it by displaying all the ages in each group.\n\n`GROUP_CONCAT(field)` returns the list as comma-separated values.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_99\n\n<!-- response SQL -->\n\nCODE_BLOCK_100\n\n<!-- end -->\n\n<!-- example sum -->\n\n##### SUM(), MIN(), MAX(), AVG()\n\nOf course, you can also obtain the sum, average, minimum, and maximum values within a group.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_101\n\n<!-- response SQL -->\n\nCODE_BLOCK_102\n\n<!-- end -->\n\n<!-- example accuracy -->\n\n## Grouping accuracy\n\nGrouping is done in fixed memory, which depends on the [max_matches](../Searching/Options.md#max_matches) setting. If `max_matches` allows for storage of all found groups, the results will be 100% accurate. However, if the value of `max_matches` is lower, the results will be less accurate.\n\nWhen parallel processing is involved, it can become more complicated. When `pseudo_sharding` is enabled and/or when using an RT table with several disk chunks, each chunk or pseudo shard gets a result set that is no larger than `max_matches`. This can lead to inaccuracies in aggregates and group counts when the result sets from different threads are merged. To fix this, either a larger `max_matches` value or disabling parallel processing can be used.\n\nManticore will try to increase `max_matches` up to [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold) if it detects that groupby may return inaccurate results. Detection is based on the number of unique values of the groupby attribute, which is retrieved from secondary indexes (if present).\n\nTo ensure accurate aggregates and/or group counts when using RT tables or `pseudo_sharding`, `accurate_aggregation` can be enabled. This will try to increase `max_matches` up to the threshold, and if the threshold is not high enough, Manticore will disable parallel processing for the query.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_103\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "CODE_BLOCK_84\n\n<!-- request Java -->\n\nCODE_BLOCK_85\n\n<!-- response Java -->\n\nCODE_BLOCK_86\n\n<!-- request C# -->\n\nCODE_BLOCK_87\n\n<!-- response C# -->\n\nCODE_BLOCK_88\n\n<!-- request Rust -->\n\nCODE_BLOCK_89\n\n<!-- response Rust -->\n\nCODE_BLOCK_90\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_91\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_92\n\n<!-- request Go -->\n\nCODE_BLOCK_93\n\n<!-- response Go -->\n\nCODE_BLOCK_94\n\n<!-- end -->\n\n## 聚合函数\n\n除了返回每个分组元素个数的 `COUNT(*)` 外，你还可以使用各种其他聚合函数：\n\n<!-- example distinct -->\n\n##### COUNT(DISTINCT field)\n\n虽然 `COUNT(*)` 返回组内所有元素的数量，`COUNT(DISTINCT field)` 返回该组内字段的唯一值数量，这可能与总数完全不同。例如，你可能有100个元素，但某个字段的值全部相同。`COUNT(DISTINCT field)` 有助于判断这一点。为了说明这一点，我们创建一个包含学生姓名、年龄和专业的表 \"students\"：\n\nCODE_BLOCK_95\n\n所以我们有：\n\nCODE_BLOCK_96\n\n在这个例子中，你可以看到，如果我们按照专业分组并显示 `COUNT(*)` 和 `COUNT(DISTINCT age)`，很明显，有两个选择了专业 \"cs\" 的学生，且年龄各不相同，但对专业 \"arts\" 来说，同样是两个学生，却只有一个唯一的年龄。\n\n每个查询最多只能有一个 `COUNT(DISTINCT)`。\n\n** 默认情况下，计数是近似的 **\n\n实际上，有些计数是精确的，有些是近似的。下面会详细介绍。\n\nManticore 支持两种计算不同值计数的算法。一种是传统算法，使用大量内存且通常较慢。它收集 `{group; value}` 对，进行排序，并定期去除重复项。这种方法的优点是在普通表中保证计数的精确。你可以通过将 [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) 选项设置为 `0` 来启用它。\n\n另一种算法（默认启用）将计数加载到哈希表中，并返回其大小。如果哈希表过大，其内容会被转移到 `HyperLogLog` 中。此时计数变为近似，因为 `HyperLogLog` 是一种概率算法。优势是每个组的最大内存使用量是固定的，取决于 `HyperLogLog` 的精度。总体内存使用也取决于反映组数的 [max_matches](../Searching/Options.md#max_matches) 设置。\n\n[distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) 选项设置了保证计数精确的阈值。`HyperLogLog` 的精度设置和“从哈希表转为 HyperLogLog”的阈值均由该设置决定。此选项需谨慎使用，因为其值加倍会使计算计数的最大内存需求加倍。内存最大使用量可以通过公式大致估算：`64 * max_matches * distinct_precision_threshold`。注意，这是最坏情况，通常计数计算所用内存远低于此值。\n\n** 对于分布式表或多个磁盘块组成的实时表，`COUNT(DISTINCT)` 可能返回不准确结果 **，但对于由本地普通表或实时表（具有相同架构，即字段集/顺序相同，但可能分词设置不同）组成的分布式表，应返回准确结果。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_97\n\n<!-- response SQL -->\n\nCODE_BLOCK_98\n\n<!-- end -->\n\n<!-- example concat -->\n\n##### GROUP_CONCAT(field)\n\n通常，你希望更好地理解每个分组的内容。你可以使用 [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) 实现，但会返回你可能不想要的额外行。`GROUP_CONCAT()` 通过将组内指定字段的值连接，丰富了分组信息。我们以上一个例子为例，改进为显示每个组内所有年龄。\n\n`GROUP_CONCAT(field)` 返回以逗号分隔的值列表。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_99\n\n<!-- response SQL -->\n\nCODE_BLOCK_100\n\n<!-- end -->\n\n<!-- example sum -->\n\n##### SUM(), MIN(), MAX(), AVG()\n\n当然，你也可以获取组内的和、平均值、最小值和最大值。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_101\n\n<!-- response SQL -->\n\nCODE_BLOCK_102\n\n<!-- end -->\n\n<!-- example accuracy -->\n\n## 分组准确性\n\n分组操作使用固定内存，大小由 [max_matches](../Searching/Options.md#max_matches) 设置决定。如果 `max_matches` 允许存储所有找到的组，结果将是100%准确的。但如果 `max_matches` 过小，结果将不够准确。\n\n当涉及并行处理时，情况会更复杂。当启用 `pseudo_sharding` 和/或使用多个磁盘块的 RT 表时，每个块或伪分片返回的结果集大小均不超过 `max_matches`，这可能导致多个线程的结果集合并时聚合和分组计数不准确。解决方法是增大 `max_matches` 或禁用并行处理。\n\n如果 Manticore 侦测到分组可能返回不准确结果，会尝试将 `max_matches` 增加到 [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold)。侦测基于从辅助索引（如存在）获取的分组属性唯一值数量。\n\n当使用 RT 表或 `pseudo_sharding` 时，为确保聚合和分组计数准确，可启用 `accurate_aggregation`。该选项将尝试将 `max_matches` 提升到阈值，若阈值不足以保证准确，则禁用查询的并行处理。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_103\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "CODE_BLOCK_84\n\n<!-- request Java -->\n\nCODE_BLOCK_85\n\n<!-- response Java -->\n\nCODE_BLOCK_86\n\n<!-- request C# -->\n\nCODE_BLOCK_87\n\n<!-- response C# -->\n\nCODE_BLOCK_88\n\n<!-- request Rust -->\n\nCODE_BLOCK_89\n\n<!-- response Rust -->\n\nCODE_BLOCK_90\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_91\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_92\n\n<!-- request Go -->\n\nCODE_BLOCK_93\n\n<!-- response Go -->\n\nCODE_BLOCK_94\n\n<!-- end -->\n\n## Функции агрегации\n\nПомимо `COUNT(*)`, который возвращает количество элементов в каждой группе, вы можете использовать различные другие функции агрегации:\n\n<!-- example distinct -->\n\n##### COUNT(DISTINCT field)\n\nВ то время как `COUNT(*)` возвращает количество всех элементов в группе, `COUNT(DISTINCT field)` возвращает количество уникальных значений поля в группе, что может значительно отличаться от общего количества. Например, в группе может быть 100 элементов, но все с одинаковым значением определённого поля. `COUNT(DISTINCT field)` помогает определить это. Чтобы продемонстрировать это, создадим таблицу \"students\" с именем студента, возрастом и специализацией:\n\nCODE_BLOCK_95\n\nтак у нас есть:\n\nCODE_BLOCK_96\n\nВ примере видно, что при группировке по \"major\" и отображении как `COUNT(*)`, так и `COUNT(DISTINCT age)`, становится ясно, что есть два студента, выбравших специализацию \"cs\" с двумя уникальными возрастами, но для \"arts\" тоже два студента, но только один уникальный возраст.\n\nВ запросе может быть не более одного `COUNT(DISTINCT)`.\n\n** По умолчанию подсчёты являются приблизительными **\n\nФактически, некоторые из них точные, другие приближённые. Подробнее об этом ниже.\n\nManticore поддерживает два алгоритма подсчёта количества уникальных значений. Один — устаревший алгоритм, который использует много памяти и обычно медленный. Он собирает пары `{group; value}`, сортирует их и периодически удаляет дубликаты. Преимущество этого подхода — гарантированная точность подсчётов в обычной таблице. Его можно включить, установив опцию [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) в `0`.\n\nДругой алгоритм (включён по умолчанию) загружает подсчёты в хеш-таблицу и возвращает её размер. Если хеш-таблица становится слишком большой, её содержимое перемещается в `HyperLogLog`. Здесь подсчёты становятся приближенными, так как `HyperLogLog` — вероятностный алгоритм. Преимущество в том, что максимальное использование памяти на одну группу фиксировано и зависит от точности `HyperLogLog`. Общее потребление памяти также зависит от настройки [max_matches](../Searching/Options.md#max_matches), которая отражает количество групп.\n\nОпция [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) задаёт порог, ниже которого подсчёты гарантированно точные. Настройки точности `HyperLogLog` и порог конверсии из хеш-таблицы в `HyperLogLog` выводятся из этой опции. Важно использовать этот параметр с осторожностью, так как его удвоение удвоит максимальный объём памяти, необходимый для вычисления подсчётов. Максимальное использование памяти можно примерно оценить формулой: `64 * max_matches * distinct_precision_threshold`. Обратите внимание, что это худший сценарий, и в большинстве случаев использование памяти будет значительно меньше.\n\n**`COUNT(DISTINCT)` для распределённой таблицы или RT-таблицы, состоящей из нескольких дисковых чанков, может возвращать неточные результаты**, но результат должен быть точным для распределённой таблицы, состоящей из локальных обычных или RT-таблиц с одинаковой схемой (одинаковым набором/порядком полей, но с возможными различиями в настройках токенизации).\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_97\n\n<!-- response SQL -->\n\nCODE_BLOCK_98\n\n<!-- end -->\n\n<!-- example concat -->\n\n##### GROUP_CONCAT(field)\n\nЧасто хочется лучше понять содержимое каждой группы. Для этого можно использовать [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows), но он вернёт дополнительные строки, которые вам могут быть не нужны в выводе. `GROUP_CONCAT()` улучшает группировку, конкатенируя значения конкретного поля в группе. Возьмём предыдущий пример и улучшим его, отображая все возраста в каждой группе.\n\n`GROUP_CONCAT(field)` возвращает список значений, разделённых запятыми.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_99\n\n<!-- response SQL -->\n\nCODE_BLOCK_100\n\n<!-- end -->\n\n<!-- example sum -->\n\n##### SUM(), MIN(), MAX(), AVG()\n\nКонечно, вы также можете получить сумму, среднее, минимальное и максимальное значения в группе.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_101\n\n<!-- response SQL -->\n\nCODE_BLOCK_102\n\n<!-- end -->\n\n<!-- example accuracy -->\n\n## Точность группировки\n\nГруппировка выполняется в фиксированной памяти, которая зависит от настройки [max_matches](../Searching/Options.md#max_matches). Если `max_matches` позволяет сохранить все найденные группы, результаты будут на 100% точными. Однако, если значение `max_matches` меньше, результаты будут менее точными.\n\nПри параллельной обработке ситуация может стать сложнее. При включённом `pseudo_sharding` и/или использовании RT-таблицы с несколькими дисковыми чанками каждый чанк или псевдо-шард получает набор результатов не больше `max_matches`. Это может привести к неточностям в агрегатах и подсчётах групп при объединении результатов из разных потоков. Для устранения этого можно использовать большее значение `max_matches` или отключить параллельную обработку.\n\nЕсли Manticore обнаруживает, что группировка может вернуть неточные результаты, он попытается увеличить `max_matches` до [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold). Обнаружение основано на числе уникальных значений атрибута группировки, получаемом из вторичных индексов (если они есть).\n\nДля обеспечения точных агрегатов и/или подсчёта групп при использовании RT-таблиц или `pseudo_sharding` можно включить `accurate_aggregation`. Это попытается увеличить `max_matches` до порога, а если порог будет недостаточным, Manticore отключит параллельную обработку для запроса.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_103\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "7e8b5ee509de8110fa2bf7408562e61d0530a4050feeeb037b52c17177787d68": {
    "original": "# Grouping search results\n\n<!-- example general -->\n\nGrouping search results is often helpful for obtaining per-group match counts or other aggregations. For example, it's useful for creating a graph illustrating the number of matching blog posts per month or grouping web search results by site or forum posts by author, etc.\n\nManticore supports the grouping of search results by single or multiple columns and computed expressions. The results can:\n\n* Be sorted within a group\n\n* Return more than one row per group\n\n* Have groups filtered\n\n* Have groups sorted\n\n* Be aggregated using the [aggregation functions](../Searching/Grouping.md#Aggregation-functions)\n\n<!-- intro -->\n\nThe general syntax is:\n\n<!-- request SQL -->\n\nGeneral syntax\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nJSON query format currently supports a basic grouping that can retrieve aggregate values and their count(*).\n\nCODE_BLOCK_1\n\nThe standard query output returns the result set without grouping, which can be hidden using `limit` (or `size`).\n\nThe aggregation requires setting a `size` for the group's result set size.\n\n<!-- end -->\n\n<!-- example group1 -->\n\n### Just Grouping\n\nGrouping is quite simple - just add \"GROUP BY smth\" to the end of your `SELECT` query. The something can be:\n\n* Any non-full-text field from the table: integer, float, string, MVA (multi-value attribute)\n\n* Or, if you used an alias in the `SELECT` list, you can GROUP BY it too\n\nYou can omit any [aggregation functions](../Searching/Grouping.md#Aggregation-functions) in the `SELECT` list and it will still work:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- example group2 -->\n\nIn most cases, however, you'll want to obtain some aggregated data for each group, such as:\n\n* `COUNT(*)` to simply get the number of elements in each group\n\n* or `AVG(field)` to calculate the average value of the field within the group\n\nFor HTTP JSON requests, using a single `aggs` bucket with `limit=0` at the main query level works similarly to a SQL query with `GROUP BY` and `COUNT(*)`, providing equivalent behavior and performance.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_4\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_5\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_6\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_7\n\n<!-- request JSON -->\n\nCODE_BLOCK_8\n\n<!-- response JSON -->\n\nCODE_BLOCK_9\n\n<!-- request PHP -->\n\nCODE_BLOCK_10\n\n<!-- response PHP -->\n\nCODE_BLOCK_11\n\n<!-- request Python -->\n\nCODE_BLOCK_12\n\n<!-- response Python -->\n\nCODE_BLOCK_13\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_14\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_15\n\n<!-- request Javascript -->\n\nCODE_BLOCK_16\n\n<!-- response Javascript -->\n\nCODE_BLOCK_17\n\n<!-- request Java -->\n\nCODE_BLOCK_18\n\n<!-- response Java -->\n\nCODE_BLOCK_19\n\n<!-- request C# -->\n\nCODE_BLOCK_20\n\n<!-- response C# -->\n\nCODE_BLOCK_21\n\n<!-- request Rust -->\n\nCODE_BLOCK_22\n\n<!-- response Rust -->\n\nCODE_BLOCK_23\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_24\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_25\n\n<!-- request Go -->\n\nCODE_BLOCK_26\n\n<!-- response Go -->\n\nCODE_BLOCK_27\n\n<!-- end -->\n\n<!-- example sort1 -->\n\n##### Sorting groups\n\nBy default, groups are not sorted, and the next thing you typically want to do is order them by something, like the field you're grouping by:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_28\n\n<!-- response SQL -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n<!-- example sort2 -->\n\nAlternatively, you can sort by the aggregation:\n\n* by `count(*)` to display groups with the most elements first\n\n* by `avg(rental_rate)` to show the highest-rated movies first. Note that in the example, it's done via an alias: `avg(rental_rate)` is first mapped to `avg` in the `SELECT` list, and then we simply do `ORDER BY avg`\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_30\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_31\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_32\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n<!-- example group3 -->\n\n##### GROUP BY multiple fields at once\n\nIn some cases, you might want to group not just by a single field, but by multiple fields at once, such as a movie's category and year:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_34\n\n<!-- response SQL -->\n\nCODE_BLOCK_35\n\n<!-- request JSON -->\n\nCODE_BLOCK_36\n\n<!-- response JSON -->\n\nCODE_BLOCK_37\n\n<!-- end -->\n\n<!-- example group4 -->\n\n##### Give me N rows\n\nSometimes it's useful to see not just a single element per group, but multiple. This can be easily achieved with the help of `GROUP N BY`. For example, in the following case, we get two movies for each year rather than just one, which a simple `GROUP BY release_year` would have returned.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_38\n\n<!-- response SQL -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example group5 -->\n\n##### Sorting inside a group\n\nAnother crucial analytics requirement is to sort elements within a group. To achieve this, use the `WITHIN GROUP ORDER BY ... {ASC|DESC}` clause. For example, let's get the highest-rated film for each year. Note that it works in parallel with just `ORDER BY`:\n\n* `WITHIN GROUP ORDER BY` sorts results **inside a group**\n\n* while just `GROUP BY` **sorts the groups themselves**\n\nThese two work entirely independently.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_40\n\n<!-- response SQL -->\n\nCODE_BLOCK_41\n\n<!-- end -->\n\n<!-- example group6 -->\n\n##### Filter groups\n\n`HAVING expression` is a helpful clause for filtering groups. While `WHERE` is applied before grouping, `HAVING` works with the groups. For example, let's keep only those years when the average rental rate of the films for that year was higher than 3. We get only four years:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_42\n\n<!-- response SQL -->\n\nCODE_BLOCK_43\n\n<!-- end -->",
    "translations": {
      "chinese": "# 结果分组搜索\n\n<!-- example general -->\n\n结果分组搜索通常有助于获取每个分组的匹配计数或其他聚合信息。例如，它对生成按月份显示匹配博客文章数量的图表有用，或者将网页搜索结果按网站分组，论坛帖子按作者分组等。\n\nManticore 支持按单列或多列以及计算表达式进行搜索结果分组。结果可以：\n\n* 在分组内排序\n\n* 每个分组返回多行\n\n* 对分组进行筛选\n\n* 对分组进行排序\n\n* 使用[聚合函数](../Searching/Grouping.md#Aggregation-functions)进行聚合\n\n<!-- intro -->\n\n通用语法为：\n\n<!-- request SQL -->\n\n通用语法\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nJSON 查询格式目前支持基本分组，可以检索聚合值及其 count(*)。\n\nCODE_BLOCK_1\n\n标准查询输出返回未分组的结果集，可以使用 `limit` (或 `size`) 隐藏。\n\n聚合操作需要设置分组结果集的 `size`。\n\n<!-- end -->\n\n<!-- example group1 -->\n\n### 仅进行分组\n\n分组非常简单，只需在 `SELECT` 查询结尾添加 \"GROUP BY smth\" 。这里的 \"something\" 可以是：\n\n* 表中的任何非全文字段：整数、浮点数、字符串、多值属性 (MVA)\n\n* 或者，如果您在 `SELECT` 列表中使用了别名，也可以按别名进行分组\n\n您可以省略 `SELECT` 列表中的任何[聚合函数](../Searching/Grouping.md#Aggregation-functions)，依然有效：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- example group2 -->\n\n然而，大多数情况下，您可能想要获取每个分组的一些聚合数据，例如：\n\n* `COUNT(*)` 用于简单获取每个分组中的元素数量\n\n* 或者 `AVG(field)` 用于计算组内某字段的平均值\n\n对于 HTTP JSON 请求，在主查询级别使用带有 `limit=0` 的单个 `aggs` 桶，效果类似于带有 `GROUP BY` 和 `COUNT(*)` 的 SQL 查询，具有等效的行为和性能。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_4\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_5\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_6\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_7\n\n<!-- request JSON -->\n\nCODE_BLOCK_8\n\n<!-- response JSON -->\n\nCODE_BLOCK_9\n\n<!-- request PHP -->\n\nCODE_BLOCK_10\n\n<!-- response PHP -->\n\nCODE_BLOCK_11\n\n<!-- request Python -->\n\nCODE_BLOCK_12\n\n<!-- response Python -->\n\nCODE_BLOCK_13\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_14\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_15\n\n<!-- request Javascript -->\n\nCODE_BLOCK_16\n\n<!-- response Javascript -->\n\nCODE_BLOCK_17\n\n<!-- request Java -->\n\nCODE_BLOCK_18\n\n<!-- response Java -->\n\nCODE_BLOCK_19\n\n<!-- request C# -->\n\nCODE_BLOCK_20\n\n<!-- response C# -->\n\nCODE_BLOCK_21\n\n<!-- request Rust -->\n\nCODE_BLOCK_22\n\n<!-- response Rust -->\n\nCODE_BLOCK_23\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_24\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_25\n\n<!-- request Go -->\n\nCODE_BLOCK_26\n\n<!-- response Go -->\n\nCODE_BLOCK_27\n\n<!-- end -->\n\n<!-- example sort1 -->\n\n##### 对分组排序\n\n默认情况下，分组不排序，通常您接下来想做的就是按某些内容排序，比如按您分组的字段：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_28\n\n<!-- response SQL -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n<!-- example sort2 -->\n\n另一种方式是按聚合排序：\n\n* 按 `count(*)` 显示元素最多的分组优先\n\n* 按 `avg(rental_rate)` 显示评分最高的电影优先。示例中通过别名实现：`avg(rental_rate)` 先映射为 `avg` 在 `SELECT` 列表中，然后直接使用 `ORDER BY avg`\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_30\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_31\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_32\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n<!-- example group3 -->\n\n##### 同时按多个字段分组\n\n有时，您可能想不仅按单字段分组，而是同时按多个字段，比如电影的类别和年份：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_34\n\n<!-- response SQL -->\n\nCODE_BLOCK_35\n\n<!-- request JSON -->\n\nCODE_BLOCK_36\n\n<!-- response JSON -->\n\nCODE_BLOCK_37\n\n<!-- end -->\n\n<!-- example group4 -->\n\n##### 返回每组 N 行\n\n有时您想看到每个分组的不止一个元素。使用 `GROUP N BY` 可以轻松实现。例如，下面的例子显示每年两部电影，而不是简单 `GROUP BY release_year` 只返回一部电影。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_38\n\n<!-- response SQL -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example group5 -->\n\n##### 分组内排序\n\n另一个重要的分析需求是对组内元素排序。实现方式是使用 `WITHIN GROUP ORDER BY ... {ASC|DESC}` 子句。例如，获取每年评分最高的电影。注意它和普通的 `ORDER BY` 是并行工作的：\n\n* `WITHIN GROUP ORDER BY` 排序**组内的结果**\n\n* 而普通的 `GROUP BY` 排序**分组本身**\n\n这两者相互独立地工作。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_40\n\n<!-- response SQL -->\n\nCODE_BLOCK_41\n\n<!-- end -->\n\n<!-- example group6 -->\n\n##### 筛选分组\n\n`HAVING expression` 是用来筛选分组的有用子句。`WHERE` 在分组前应用，而 `HAVING` 是针对分组进行过滤。例如，保留那些该年电影平均租金价格超过 3 的年份。结果只得到四个年份：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_42\n\n<!-- response SQL -->\n\nCODE_BLOCK_43\n\n<!-- end -->",
      "russian": "# Группировка результатов поиска\n\n<!-- example general -->\n\nГруппировка результатов поиска часто полезна для получения количества совпадений по каждой группе или других агрегированных данных. Например, это удобно для создания графика с количеством совпадающих блог-постов по месяцам или группировки веб-поиска по сайтам, а сообщений на форумах — по авторам и т.д.\n\nManticore поддерживает группировку результатов поиска по одному или нескольким столбцам и вычисляемым выражениям. Результаты могут:\n\n* Быть отсортированы внутри группы\n\n* Возвращать более одной строки на группу\n\n* Фильтровать группы\n\n* Сортировать группы\n\n* Агрегироваться с использованием [функций агрегации](../Searching/Grouping.md#Aggregation-functions)\n\n<!-- intro -->\n\nОбщий синтаксис:\n\n<!-- request SQL -->\n\nОбщий синтаксис\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nФормат JSON-запроса в настоящее время поддерживает базовую группировку, которая может получать агрегированные значения и их count(*).\n\nCODE_BLOCK_1\n\nСтандартный вывод запроса возвращает набор результатов без группировки, который можно скрыть с помощью `limit` (или `size`).\n\nДля агрегации требуется установить `size` для размера результата группы.\n\n<!-- end -->\n\n<!-- example group1 -->\n\n### Простая группировка\n\nГруппировка очень проста — просто добавьте \"GROUP BY smth\" в конец вашего запроса `SELECT`. Что именно — может быть:\n\n* Любое поле из таблицы, не являющееся полнотекстовым: целое число, число с плавающей точкой, строка, MVA (мультизначный атрибут)\n\n* Или, если вы использовали псевдоним в списке `SELECT`, вы можете сгруппировать по нему\n\nВы можете опустить любые [функции агрегации](../Searching/Grouping.md#Aggregation-functions) в списке `SELECT`, и это всё равно будет работать:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- example group2 -->\n\nВ большинстве случаев, однако, вы захотите получить агрегированные данные для каждой группы, такие как:\n\n* `COUNT(*)`, чтобы просто получить количество элементов в каждой группе\n\n* или `AVG(field)`, чтобы вычислить среднее значение поля в группе\n\nДля HTTP JSON-запросов использование одного контейнера `aggs` с `limit=0` на уровне основного запроса работает аналогично SQL-запросу с `GROUP BY` и `COUNT(*)`, обеспечивая эквивалентное поведение и производительность.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_4\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_5\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_6\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_7\n\n<!-- request JSON -->\n\nCODE_BLOCK_8\n\n<!-- response JSON -->\n\nCODE_BLOCK_9\n\n<!-- request PHP -->\n\nCODE_BLOCK_10\n\n<!-- response PHP -->\n\nCODE_BLOCK_11\n\n<!-- request Python -->\n\nCODE_BLOCK_12\n\n<!-- response Python -->\n\nCODE_BLOCK_13\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_14\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_15\n\n<!-- request Javascript -->\n\nCODE_BLOCK_16\n\n<!-- response Javascript -->\n\nCODE_BLOCK_17\n\n<!-- request Java -->\n\nCODE_BLOCK_18\n\n<!-- response Java -->\n\nCODE_BLOCK_19\n\n<!-- request C# -->\n\nCODE_BLOCK_20\n\n<!-- response C# -->\n\nCODE_BLOCK_21\n\n<!-- request Rust -->\n\nCODE_BLOCK_22\n\n<!-- response Rust -->\n\nCODE_BLOCK_23\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_24\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_25\n\n<!-- request Go -->\n\nCODE_BLOCK_26\n\n<!-- response Go -->\n\nCODE_BLOCK_27\n\n<!-- end -->\n\n<!-- example sort1 -->\n\n##### Сортировка групп\n\nПо умолчанию группы не сортируются, и следующим типичным шагом является упорядочение их по чему-то, например, по полю, по которому происходит группировка:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_28\n\n<!-- response SQL -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n<!-- example sort2 -->\n\nИли вы можете сортировать по агрегации:\n\n* по `count(*)`, чтобы сначала отображать группы с наибольшим количеством элементов\n\n* по `avg(rental_rate)`, чтобы показывать сначала фильмы с наивысшим рейтингом. Обратите внимание, что в примере это делается через псевдоним: `avg(rental_rate)` сначала отображается в `avg` в списке `SELECT`, а затем просто делается `ORDER BY avg`\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_30\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_31\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_32\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n<!-- example group3 -->\n\n##### GROUP BY по нескольким полям одновременно\n\nВ некоторых случаях вы можете захотеть группировать не по одному полю, а сразу по нескольким, например, по категории фильма и году:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_34\n\n<!-- response SQL -->\n\nCODE_BLOCK_35\n\n<!-- request JSON -->\n\nCODE_BLOCK_36\n\n<!-- response JSON -->\n\nCODE_BLOCK_37\n\n<!-- end -->\n\n<!-- example group4 -->\n\n##### Дайте мне N строк\n\nИногда полезно видеть не просто один элемент на группу, а несколько. Это легко достигается с помощью `GROUP N BY`. Например, в следующем примере мы получаем два фильма на каждый год, а не только один, как это было бы при обычном `GROUP BY release_year`.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_38\n\n<!-- response SQL -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example group5 -->\n\n##### Сортировка внутри группы\n\nЕще одним важным требованием аналитики является сортировка элементов внутри группы. Для этого используйте конструкцию `WITHIN GROUP ORDER BY ... {ASC|DESC}`. Например, давайте выберем фильм с наивысшим рейтингом за каждый год. Обратите внимание, что это работает параллельно с обычным `ORDER BY`:\n\n* `WITHIN GROUP ORDER BY` сортирует результаты **внутри группы**\n\n* тогда как просто `GROUP BY` сортирует **самих группы**\n\nЭти два работают полностью независимо друг от друга.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_40\n\n<!-- response SQL -->\n\nCODE_BLOCK_41\n\n<!-- end -->\n\n<!-- example group6 -->\n\n##### Фильтрация групп\n\n`HAVING expression` — полезное выражение для фильтрации групп. В то время как `WHERE` применяется до группировки, `HAVING` работает с группами. Например, оставим только те годы, когда средняя ставка аренды фильмов за этот год была выше 3. Мы получаем всего четыре года:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_42\n\n<!-- response SQL -->\n\nCODE_BLOCK_43\n\n<!-- end -->"
    },
    "is_code_or_comment": false
  },
  "b29afafeca699220ae4fe38893c964510851be79823871bc2d549f5621cb50f8": {
    "original": "**Note:** The `total_found` value in [search query meta info](../Node_info_and_management/SHOW_META.md#SHOW-META) reflects the number of groups that match the `HAVING` condition. This enables proper pagination when using `HAVING` clauses with `GROUP BY`.\n\n<!-- example group7 -->\n\n##### GROUPBY()\n\nThere is a function `GROUPBY()` which returns the key of the current group. It's useful in many cases, especially when you [GROUP BY an MVA](../Searching/Grouping.md#Grouping-by-MVA-%28multi-value-attributes%29) or a [JSON value](../Searching/Grouping.md#Grouping-by-a-JSON-node).\n\nIt can also be used in `HAVING`, for example, to keep only years 2000 and 2002.\n\nNote that `GROUPBY()`is not recommended for use when you GROUP BY multiple fields at once. It will still work, but since the group key in this case is a compound of field values, it may not appear the way you expect.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_44\n\n<!-- response SQL -->\n\nCODE_BLOCK_45\n\n<!-- end -->\n\n<!-- example mva -->\n\n##### Grouping by MVA (multi-value attributes)\n\nManticore supports grouping by [MVA](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29). To demonstrate how it works, let's create a table \"shoes\" with MVA \"sizes\" and insert a few documents into it:\n\nCODE_BLOCK_46\n\nso we have:\n\nCODE_BLOCK_47\n\nIf we now GROUP BY \"sizes\", it will process all our multi-value attributes and return an aggregation for each, in this case just the count:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- response SQL -->\n\nCODE_BLOCK_49\n\n<!-- request JSON -->\n\nCODE_BLOCK_50\n\n<!-- response JSON -->\n\nCODE_BLOCK_51\n\n<!-- request PHP -->\n\nCODE_BLOCK_52\n\n<!-- response PHP -->\n\nCODE_BLOCK_53\n\n<!-- request Python -->\n\nCODE_BLOCK_54\n\n<!-- response Python -->\n\nCODE_BLOCK_55\n\n<!-- request Javascript -->\n\nCODE_BLOCK_56\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_57\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_58\n\n<!-- request Javascript -->\n\nCODE_BLOCK_59\n\n<!-- response Javascript -->\n\nCODE_BLOCK_60\n\n<!-- request Java -->\n\nCODE_BLOCK_61\n\n<!-- response Java -->\n\nCODE_BLOCK_62\n\n<!-- request C# -->\n\nCODE_BLOCK_63\n\n<!-- response C# -->\n\nCODE_BLOCK_64\n\n<!-- request Rust -->\n\nCODE_BLOCK_65\n\n<!-- response Rust -->\n\nCODE_BLOCK_66\n\nres = await searchApi.search({\n\n  index: 'test',\n\n  aggs: {\n\n    mva_agg: {\n\n      terms: { field: \"mva_field\", size: 2 }\n\n    }\n\n  }\n\n});\n\nCODE_BLOCK_67\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":4,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_68\n\nquery := map[string]interface{} {};\n\nsearchRequest.SetQuery(query);\n\naggTerms := manticoreclient.NewAggregationTerms()\n\naggTerms.SetField(\"mva_field\")\n\naggTerms.SetSize(2)\n\naggregation := manticoreclient.NewAggregation()\n\naggregation.setTerms(aggTerms)\n\nsearchRequest.SetAggregation(aggregation)\n\nres, _, _ := apiClient.SearchAPI.Search(context.Background()).SearchRequest(*searchRequest).Execute()\n\nCODE_BLOCK_69\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":5,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_70\n\ncreate table products(title text, meta json);\n\ninsert into products values(0,'nike','{\"color\":\"red\"}'),(0,'adidas','{\"color\":\"red\"}'),(0,'puma','{\"color\":\"green\"}');\n\nCODE_BLOCK_71\n\nSELECT * FROM products;\n\n+---------------------+-------------------+--------+\n\n| id                  | meta              | title  |\n\n+---------------------+-------------------+--------+\n\n| 1657851069130080268 | {\"color\":\"red\"}   | nike   |\n\n| 1657851069130080269 | {\"color\":\"red\"}   | adidas |\n\n| 1657851069130080270 | {\"color\":\"green\"} | puma   |\n\n+---------------------+-------------------+--------+\n\nCODE_BLOCK_72\n\nSELECT groupby() color, count(*) from products GROUP BY meta.color;\n\nCODE_BLOCK_73\n\n+-------+----------+\n\n| color | count(*) |\n\n+-------+----------+\n\n| red   |        2 |\n\n| green |        1 |\n\n+-------+----------+\n\nCODE_BLOCK_74\n\nPOST /search -d '\n\n    {\n\n     \"table\" : \"products\",\n\n     \"limit\": 0,\n\n     \"aggs\" :\n\n     {\n\n        \"color\" :\n\n         {\n\n            \"terms\" :\n\n             {\n\n              \"field\":\"meta.color\",\n\n              \"size\":100\n\n             }\n\n         }\n\n     }\n\n    }\n\n'\n\nCODE_BLOCK_75\n\n{\n\n  \"took\": 0,\n\n  \"timed_out\": false,\n\n  \"hits\": {\n\n    \"total\": 3,\n\n    \"hits\": [\n\n    ]\n\n  },\n\n  \"aggregations\": {\n\n    \"color\": {\n\n      \"buckets\": [\n\n        {\n\n          \"key\": \"green\",\n\n          \"doc_count\": 1\n\n        },\n\n        {\n\n          \"key\": \"red\",\n\n          \"doc_count\": 2\n\n        }\n\n      ]\n\n    }\n\n  }\n\n}\n\nCODE_BLOCK_76\n\n$index->setName('products');\n\n$search = $index->search('');\n\n$search->limit(0);\n\n$search->facet('meta.color','color',100);\n\n$results = $search->get();\n\nprint_r($results->getFacets());\n\nCODE_BLOCK_77\n\nArray\n\n(\n\n    [color] => Array\n\n        (\n\n            [buckets] => Array\n\n                (\n\n                    [0] => Array\n\n                        (\n\n                            [key] => green\n\n                            [doc_count] => 1\n\n                        )\n\n                    [1] => Array\n\n                        (\n\n                            [key] => red\n\n                            [doc_count] => 2\n\n                        )\n\n                )\n\n        )\n\n)\n\nCODE_BLOCK_78\n\nres =searchApi.search({\"table\":\"products\",\"limit\":0,\"aggs\":{\"color\":{\"terms\":{\"field\":\"meta.color\",\"size\":100}}}})\n\nCODE_BLOCK_79\n\n{'aggregations': {u'color': {u'buckets': [{u'doc_count': 1,\n\n                                           u'key': u'green'},\n\n                                          {u'doc_count': 2, u'key': u'red'}]}},\n\n 'hits': {'hits': [], 'max_score': None, 'total': 3},\n\n 'profile': None,\n\n 'timed_out': False,\n\n 'took': 0}\n\nCODE_BLOCK_80\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_81\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_82\n\n<!-- request Javascript -->\n\nCODE_BLOCK_83\n\n<!-- response Javascript -->",
    "translations": {
      "chinese": "**注意：** [搜索查询元信息](../Node_info_and_management/SHOW_META.md#SHOW-META)中的`total_found`值反映了符合`HAVING`条件的分组数量。这使得在使用`HAVING`子句和`GROUP BY`时能够实现正确的分页。\n\n<!-- example group7 -->\n\n##### GROUPBY()\n\n有一个函数`GROUPBY()`，返回当前分组的键。在许多情况下都很有用，尤其是在你[按MVA分组](../Searching/Grouping.md#Grouping-by-MVA-%28multi-value-attributes%29)或按[JSON值分组](../Searching/Grouping.md#Grouping-by-a-JSON-node)时。\n\n它也可以用于`HAVING`，例如，只保留年份2000和2002。\n\n注意，当你同时按多个字段GROUP BY时，不建议使用`GROUPBY()`。它仍然可以工作，但由于此时分组键是字段值的复合，可能不会以你期望的方式展示。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_44\n\n<!-- response SQL -->\n\nCODE_BLOCK_45\n\n<!-- end -->\n\n<!-- example mva -->\n\n##### 按MVA（多值属性）分组\n\nManticore支持按[MVA](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29)分组。为了演示其工作方式，我们创建一个名为\"shoes\"且带有MVA \"sizes\"的表，并插入几个文档：\n\nCODE_BLOCK_46\n\n所以我们有：\n\nCODE_BLOCK_47\n\n如果现在我们按\"sizes\"分组，它会处理所有我们的多值属性，并为每个返回聚合结果，在本例中仅是计数：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- response SQL -->\n\nCODE_BLOCK_49\n\n<!-- request JSON -->\n\nCODE_BLOCK_50\n\n<!-- response JSON -->\n\nCODE_BLOCK_51\n\n<!-- request PHP -->\n\nCODE_BLOCK_52\n\n<!-- response PHP -->\n\nCODE_BLOCK_53\n\n<!-- request Python -->\n\nCODE_BLOCK_54\n\n<!-- response Python -->\n\nCODE_BLOCK_55\n\n<!-- request Javascript -->\n\nCODE_BLOCK_56\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_57\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_58\n\n<!-- request Javascript -->\n\nCODE_BLOCK_59\n\n<!-- response Javascript -->\n\nCODE_BLOCK_60\n\n<!-- request Java -->\n\nCODE_BLOCK_61\n\n<!-- response Java -->\n\nCODE_BLOCK_62\n\n<!-- request C# -->\n\nCODE_BLOCK_63\n\n<!-- response C# -->\n\nCODE_BLOCK_64\n\n<!-- request Rust -->\n\nCODE_BLOCK_65\n\n<!-- response Rust -->\n\nCODE_BLOCK_66\n\nres = await searchApi.search({\n\n  index: 'test',\n\n  aggs: {\n\n    mva_agg: {\n\n      terms: { field: \"mva_field\", size: 2 }\n\n    }\n\n  }\n\n});\n\nCODE_BLOCK_67\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":4,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_68\n\nquery := map[string]interface{} {};\n\nsearchRequest.SetQuery(query);\n\naggTerms := manticoreclient.NewAggregationTerms()\n\naggTerms.SetField(\"mva_field\")\n\naggTerms.SetSize(2)\n\naggregation := manticoreclient.NewAggregation()\n\naggregation.setTerms(aggTerms)\n\nsearchRequest.SetAggregation(aggregation)\n\nres, _, _ := apiClient.SearchAPI.Search(context.Background()).SearchRequest(*searchRequest).Execute()\n\nCODE_BLOCK_69\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":5,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_70\n\ncreate table products(title text, meta json);\n\ninsert into products values(0,'nike','{\"color\":\"red\"}'),(0,'adidas','{\"color\":\"red\"}'),(0,'puma','{\"color\":\"green\"}');\n\nCODE_BLOCK_71\n\nSELECT * FROM products;\n\n+---------------------+-------------------+--------+\n\n| id                  | meta              | title  |\n\n+---------------------+-------------------+--------+\n\n| 1657851069130080268 | {\"color\":\"red\"}   | nike   |\n\n| 1657851069130080269 | {\"color\":\"red\"}   | adidas |\n\n| 1657851069130080270 | {\"color\":\"green\"} | puma   |\n\n+---------------------+-------------------+--------+\n\nCODE_BLOCK_72\n\nSELECT groupby() color, count(*) from products GROUP BY meta.color;\n\nCODE_BLOCK_73\n\n+-------+----------+\n\n| color | count(*) |\n\n+-------+----------+\n\n| red   |        2 |\n\n| green |        1 |\n\n+-------+----------+\n\nCODE_BLOCK_74\n\nPOST /search -d '\n\n    {\n\n     \"table\" : \"products\",\n\n     \"limit\": 0,\n\n     \"aggs\" :\n\n     {\n\n        \"color\" :\n\n         {\n\n            \"terms\" :\n\n             {\n\n              \"field\":\"meta.color\",\n\n              \"size\":100\n\n             }\n\n         }\n\n     }\n\n    }\n\n'\n\nCODE_BLOCK_75\n\n{\n\n  \"took\": 0,\n\n  \"timed_out\": false,\n\n  \"hits\": {\n\n    \"total\": 3,\n\n    \"hits\": [\n\n    ]\n\n  },\n\n  \"aggregations\": {\n\n    \"color\": {\n\n      \"buckets\": [\n\n        {\n\n          \"key\": \"green\",\n\n          \"doc_count\": 1\n\n        },\n\n        {\n\n          \"key\": \"red\",\n\n          \"doc_count\": 2\n\n        }\n\n      ]\n\n    }\n\n  }\n\n}\n\nCODE_BLOCK_76\n\n$index->setName('products');\n\n$search = $index->search('');\n\n$search->limit(0);\n\n$search->facet('meta.color','color',100);\n\n$results = $search->get();\n\nprint_r($results->getFacets());\n\nCODE_BLOCK_77\n\nArray\n\n(\n\n    [color] => Array\n\n        (\n\n            [buckets] => Array\n\n                (\n\n                    [0] => Array\n\n                        (\n\n                            [key] => green\n\n                            [doc_count] => 1\n\n                        )\n\n                    [1] => Array\n\n                        (\n\n                            [key] => red\n\n                            [doc_count] => 2\n\n                        )\n\n                )\n\n        )\n\n)\n\nCODE_BLOCK_78\n\nres =searchApi.search({\"table\":\"products\",\"limit\":0,\"aggs\":{\"color\":{\"terms\":{\"field\":\"meta.color\",\"size\":100}}}})\n\nCODE_BLOCK_79\n\n{'aggregations': {u'color': {u'buckets': [{u'doc_count': 1,\n\n                                           u'key': u'green'},\n\n                                          {u'doc_count': 2, u'key': u'red'}]}},\n\n 'hits': {'hits': [], 'max_score': None, 'total': 3},\n\n 'profile': None,\n\n 'timed_out': False,\n\n 'took': 0}\n\nCODE_BLOCK_80\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_81\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_82\n\n<!-- request Javascript -->\n\nCODE_BLOCK_83\n\n<!-- response Javascript -->",
      "russian": "**Примечание:** Значение `total_found` в [метаинформации поискового запроса](../Node_info_and_management/SHOW_META.md#SHOW-META) отражает количество групп, которые соответствуют условию `HAVING`. Это обеспечивает правильную постраничную навигацию при использовании условий `HAVING` вместе с `GROUP BY`.\n\n<!-- example group7 -->\n\n##### GROUPBY()\n\nСуществует функция `GROUPBY()`, которая возвращает ключ текущей группы. Она полезна во многих случаях, особенно когда вы [группируете по MVA](../Searching/Grouping.md#Grouping-by-MVA-%28multi-value-attributes%29) или по [значению JSON](../Searching/Grouping.md#Grouping-by-a-JSON-node).\n\nЕё также можно использовать в `HAVING`, например, чтобы оставить только года 2000 и 2002.\n\nОбратите внимание, что `GROUPBY()` не рекомендуется использовать при группировке сразу по нескольким полям. Она всё равно будет работать, но так как ключ группы в таком случае является составным из значений полей, он может появиться в неожиданном виде.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_44\n\n<!-- response SQL -->\n\nCODE_BLOCK_45\n\n<!-- end -->\n\n<!-- example mva -->\n\n##### Группировка по MVA (мульти-значимые атрибуты)\n\nManticore поддерживает группировку по [MVA](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29). Чтобы показать, как это работает, давайте создадим таблицу \"shoes\" с MVA \"sizes\" и добавим в неё несколько документов:\n\nCODE_BLOCK_46\n\nитак, у нас есть:\n\nCODE_BLOCK_47\n\nЕсли теперь сделать GROUP BY по \"sizes\", будут обработаны все наши мульти-значимые атрибуты и возвращена агрегация для каждого, в данном случае просто подсчёт:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- response SQL -->\n\nCODE_BLOCK_49\n\n<!-- request JSON -->\n\nCODE_BLOCK_50\n\n<!-- response JSON -->\n\nCODE_BLOCK_51\n\n<!-- request PHP -->\n\nCODE_BLOCK_52\n\n<!-- response PHP -->\n\nCODE_BLOCK_53\n\n<!-- request Python -->\n\nCODE_BLOCK_54\n\n<!-- response Python -->\n\nCODE_BLOCK_55\n\n<!-- request Javascript -->\n\nCODE_BLOCK_56\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_57\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_58\n\n<!-- request Javascript -->\n\nCODE_BLOCK_59\n\n<!-- response Javascript -->\n\nCODE_BLOCK_60\n\n<!-- request Java -->\n\nCODE_BLOCK_61\n\n<!-- response Java -->\n\nCODE_BLOCK_62\n\n<!-- request C# -->\n\nCODE_BLOCK_63\n\n<!-- response C# -->\n\nCODE_BLOCK_64\n\n<!-- request Rust -->\n\nCODE_BLOCK_65\n\n<!-- response Rust -->\n\nCODE_BLOCK_66\n\nres = await searchApi.search({\n\n  index: 'test',\n\n  aggs: {\n\n    mva_agg: {\n\n      terms: { field: \"mva_field\", size: 2 }\n\n    }\n\n  }\n\n});\n\nCODE_BLOCK_67\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":4,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_68\n\nquery := map[string]interface{} {};\n\nsearchRequest.SetQuery(query);\n\naggTerms := manticoreclient.NewAggregationTerms()\n\naggTerms.SetField(\"mva_field\")\n\naggTerms.SetSize(2)\n\naggregation := manticoreclient.NewAggregation()\n\naggregation.setTerms(aggTerms)\n\nsearchRequest.SetAggregation(aggregation)\n\nres, _, _ := apiClient.SearchAPI.Search(context.Background()).SearchRequest(*searchRequest).Execute()\n\nCODE_BLOCK_69\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":5,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_70\n\ncreate table products(title text, meta json);\n\ninsert into products values(0,'nike','{\"color\":\"red\"}'),(0,'adidas','{\"color\":\"red\"}'),(0,'puma','{\"color\":\"green\"}');\n\nCODE_BLOCK_71\n\nSELECT * FROM products;\n\n+---------------------+-------------------+--------+\n\n| id                  | meta              | title  |\n\n+---------------------+-------------------+--------+\n\n| 1657851069130080268 | {\"color\":\"red\"}   | nike   |\n\n| 1657851069130080269 | {\"color\":\"red\"}   | adidas |\n\n| 1657851069130080270 | {\"color\":\"green\"} | puma   |\n\n+---------------------+-------------------+--------+\n\nCODE_BLOCK_72\n\nSELECT groupby() color, count(*) from products GROUP BY meta.color;\n\nCODE_BLOCK_73\n\n+-------+----------+\n\n| color | count(*) |\n\n+-------+----------+\n\n| red   |        2 |\n\n| green |        1 |\n\n+-------+----------+\n\nCODE_BLOCK_74\n\nPOST /search -d '\n\n    {\n\n     \"table\" : \"products\",\n\n     \"limit\": 0,\n\n     \"aggs\" :\n\n     {\n\n        \"color\" :\n\n         {\n\n            \"terms\" :\n\n             {\n\n              \"field\":\"meta.color\",\n\n              \"size\":100\n\n             }\n\n         }\n\n     }\n\n    }\n\n'\n\nCODE_BLOCK_75\n\n{\n\n  \"took\": 0,\n\n  \"timed_out\": false,\n\n  \"hits\": {\n\n    \"total\": 3,\n\n    \"hits\": [\n\n    ]\n\n  },\n\n  \"aggregations\": {\n\n    \"color\": {\n\n      \"buckets\": [\n\n        {\n\n          \"key\": \"green\",\n\n          \"doc_count\": 1\n\n        },\n\n        {\n\n          \"key\": \"red\",\n\n          \"doc_count\": 2\n\n        }\n\n      ]\n\n    }\n\n  }\n\n}\n\nCODE_BLOCK_76\n\n$index->setName('products');\n\n$search = $index->search('');\n\n$search->limit(0);\n\n$search->facet('meta.color','color',100);\n\n$results = $search->get();\n\nprint_r($results->getFacets());\n\nCODE_BLOCK_77\n\nArray\n\n(\n\n    [color] => Array\n\n        (\n\n            [buckets] => Array\n\n                (\n\n                    [0] => Array\n\n                        (\n\n                            [key] => green\n\n                            [doc_count] => 1\n\n                        )\n\n                    [1] => Array\n\n                        (\n\n                            [key] => red\n\n                            [doc_count] => 2\n\n                        )\n\n                )\n\n        )\n\n)\n\nCODE_BLOCK_78\n\nres =searchApi.search({\"table\":\"products\",\"limit\":0,\"aggs\":{\"color\":{\"terms\":{\"field\":\"meta.color\",\"size\":100}}}})\n\nCODE_BLOCK_79\n\n{'aggregations': {u'color': {u'buckets': [{u'doc_count': 1,\n\n                                           u'key': u'green'},\n\n                                          {u'doc_count': 2, u'key': u'red'}]}},\n\n 'hits': {'hits': [], 'max_score': None, 'total': 3},\n\n 'profile': None,\n\n 'timed_out': False,\n\n 'took': 0}\n\nCODE_BLOCK_80\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_81\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_82\n\n<!-- request Javascript -->\n\nCODE_BLOCK_83\n\n<!-- response Javascript -->"
    },
    "is_code_or_comment": false
  },
  "afa23fbb2f90e679f4017160095396fc158e99f371e43604014aa13f79aac94a": {
    "original": "When parallel processing is involved, it can become more complicated. When `pseudo_sharding` is enabled and/or when using an RT table with several disk chunks, each chunk or pseudo shard gets a result set that is no larger than `max_matches`. This can lead to inaccuracies in aggregates and group counts when the result sets from different threads are merged. To fix this, either a larger `max_matches` value or disabling parallel processing can be used.\n\nManticore will try to increase `max_matches` up to [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold) if it detects that groupby may return inaccurate results. Detection is based on the number of unique values of the groupby attribute, which is retrieved from secondary indexes (if present).\n\nTo ensure accurate aggregates and/or group counts when using RT tables or `pseudo_sharding`, `accurate_aggregation` can be enabled. This will try to increase `max_matches` up to the threshold, and if the threshold is not high enough, Manticore will disable parallel processing for the query.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_123\n\n<!-- request JSON -->\n\nCODE_BLOCK_124\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "当涉及并行处理时，情况可能变得更加复杂。当启用 `pseudo_sharding` 和/或使用具有多个磁盘块的 RT 表时，每个块或伪分片都会得到一个不超过 `max_matches` 的结果集。这在不同线程的结果集合并时，可能导致聚合和分组计数的不准确。为了解决这个问题，可以使用更大的 `max_matches` 值或禁用并行处理。\n\n如果检测到 groupby 可能返回不准确的结果，Manticore 会尝试将 `max_matches` 提高到 [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold) 以进行修正。检测基于从二级索引（如果存在）检索的 groupby 属性的唯一值数量。\n\n为了在使用 RT 表或 `pseudo_sharding` 时确保聚合和/或分组计数的准确，可以启用 `accurate_aggregation`。这将尝试将 `max_matches` 提高到阈值，如果阈值不足够高，Manticore 将为查询禁用并行处理。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_123\n\n<!-- request JSON -->\n\nCODE_BLOCK_124\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "Когда задействована параллельная обработка, ситуация может стать более сложной. Когда включён `pseudo_sharding` и/или используется RT-таблица с несколькими дисковыми чанками, каждый чанк или псевдо-шард получает набор результатов не больше, чем `max_matches`. Это может привести к неточностям в агрегатах и подсчётах групп при объединении наборов результатов с разных потоков. Чтобы исправить это, можно использовать либо большее значение `max_matches`, либо отключить параллельную обработку.\n\nManticore попытается увеличить `max_matches` до [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold), если обнаружит, что groupby может вернуть неточные результаты. Обнаружение основано на количестве уникальных значений атрибута groupby, которое извлекается из вторичных индексов (если они есть).\n\nЧтобы обеспечить точные агрегаты и/или подсчёты групп при использовании RT-таблиц или `pseudo_sharding`, можно включить `accurate_aggregation`. Это попытается увеличить `max_matches` до порога, а если порог окажется недостаточно высоким, Manticore отключит параллельную обработку для запроса.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_123\n\n<!-- request JSON -->\n\nCODE_BLOCK_124\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "aa4599aa8618029ed698b5dbd78eec3880845ccf8f539bc14906a479cd20ab1b": {
    "original": "# Grouping search results\n\n<!-- example general -->\n\nGrouping search results is often helpful for obtaining per-group match counts or other aggregations. For example, it's useful for creating a graph illustrating the number of matching blog posts per month or grouping web search results by site or forum posts by author, etc.\n\nManticore supports the grouping of search results by single or multiple columns and computed expressions. The results can:\n\n* Be sorted within a group\n\n* Return more than one row per group\n\n* Have groups filtered\n\n* Have groups sorted\n\n* Be aggregated using the [aggregation functions](../Searching/Grouping.md#Aggregation-functions)\n\n<!-- intro -->\n\nThe general syntax is:\n\n<!-- request SQL -->\n\nGeneral syntax\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nJSON query format currently supports a basic grouping that can retrieve aggregate values and their count(*).\n\nCODE_BLOCK_1\n\nThe standard query output returns the result set without grouping, which can be hidden using `limit` (or `size`).\n\nThe aggregation requires setting a `size` for the group's result set size.\n\n<!-- end -->\n\n<!-- example group1 -->\n\n### Just Grouping\n\nGrouping is quite simple - just add \"GROUP BY smth\" to the end of your `SELECT` query. The something can be:\n\n* Any non-full-text field from the table: integer, float, string, MVA (multi-value attribute)\n\n* Or, if you used an alias in the `SELECT` list, you can GROUP BY it too\n\nYou can omit any [aggregation functions](../Searching/Grouping.md#Aggregation-functions) in the `SELECT` list and it will still work:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- request JSON -->\n\nCODE_BLOCK_4\n\n<!-- response JSON -->\n\nCODE_BLOCK_5\n\n<!-- end -->\n\n<!-- example group2 -->\n\nIn most cases, however, you'll want to obtain some aggregated data for each group, such as:\n\n* `COUNT(*)` to simply get the number of elements in each group\n\n* or `AVG(field)` to calculate the average value of the field within the group\n\nFor HTTP JSON requests, using a single `aggs` bucket with `limit=0` at the main query level works similarly to a SQL query with `GROUP BY` and `COUNT(*)`, providing equivalent behavior and performance.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_6\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_7\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_8\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_9\n\n<!-- request JSON -->\n\nCODE_BLOCK_10\n\n<!-- response JSON -->\n\nCODE_BLOCK_11\n\n<!-- request PHP -->\n\nCODE_BLOCK_12\n\n<!-- response PHP -->\n\nCODE_BLOCK_13\n\n<!-- request Python -->\n\nCODE_BLOCK_14\n\n<!-- response Python -->\n\nCODE_BLOCK_15\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_16\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_17\n\n<!-- request Javascript -->\n\nCODE_BLOCK_18\n\n<!-- response Javascript -->\n\nCODE_BLOCK_19\n\n<!-- request Java -->\n\nCODE_BLOCK_20\n\n<!-- response Java -->\n\nCODE_BLOCK_21\n\n<!-- request C# -->\n\nCODE_BLOCK_22\n\n<!-- response C# -->\n\nCODE_BLOCK_23\n\n<!-- request Rust -->\n\nCODE_BLOCK_24\n\n<!-- response Rust -->\n\nCODE_BLOCK_25\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_26\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_27\n\n<!-- request Go -->\n\nCODE_BLOCK_28\n\n<!-- response Go -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n<!-- example sort1 -->\n\n##### Sorting groups\n\nBy default, groups are not sorted, and the next thing you typically want to do is order them by something, like the field you're grouping by:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_30\n\n<!-- response SQL -->\n\nCODE_BLOCK_31\n\n<!-- request JSON -->\n\nCODE_BLOCK_32\n\n<!-- response JSON -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n<!-- example sort2 -->\n\nAlternatively, you can sort by the aggregation:\n\n* by `count(*)` to display groups with the most elements first\n\n* by `avg(rental_rate)` to show the highest-rated movies first. Note that in the example, it's done via an alias: `avg(rental_rate)` is first mapped to `avg` in the `SELECT` list, and then we simply do `ORDER BY avg`\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_34\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_35\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_36\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_37\n\n<!-- request JSON -->\n\nCODE_BLOCK_38\n\n<!-- response JSON -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example group3 -->\n\n##### GROUP BY multiple fields at once\n\nIn some cases, you might want to group not just by a single field, but by multiple fields at once, such as a movie's category and year:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_40\n\n<!-- response SQL -->\n\nCODE_BLOCK_41\n\n<!-- request JSON -->\n\nCODE_BLOCK_42\n\n<!-- response JSON -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n<!-- example group4 -->\n\n##### Give me N rows\n\nSometimes it's useful to see not just a single element per group, but multiple. This can be easily achieved with the help of `GROUP N BY`. For example, in the following case, we get two movies for each year rather than just one, which a simple `GROUP BY release_year` would have returned.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_44\n\n<!-- response SQL -->\n\nCODE_BLOCK_45\n\n<!-- request JSON -->\n\nCODE_BLOCK_46\n\n<!-- response JSON -->\n\nCODE_BLOCK_47\n\n<!-- end -->\n\n<!-- example group5 -->\n\n##### Sorting inside a group\n\nAnother crucial analytics requirement is to sort elements within a group. To achieve this, use the `WITHIN GROUP ORDER BY ... {ASC|DESC}` clause. For example, let's get the highest-rated film for each year. Note that it works in parallel with just `ORDER BY`:\n\n* `WITHIN GROUP ORDER BY` sorts results **inside a group**\n\n* while just `GROUP BY` **sorts the groups themselves**\n\nThese two work entirely independently.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- response SQL -->\n\nCODE_BLOCK_49\n\n<!-- request JSON -->\n\nCODE_BLOCK_50\n\n<!-- response JSON -->\n\nCODE_BLOCK_51\n\n<!-- end -->\n\n<!-- example group6 -->\n\n##### Filter groups",
    "translations": {
      "chinese": "# 分组搜索结果\n\n<!-- example general -->\n\n分组搜索结果通常有助于获取每组的匹配数量或其他聚合。例如，它对于创建说明每月匹配博客文章数量的图表，或按站点分组网页搜索结果，或按作者分组论坛帖子等非常有用。\n\nManticore 支持按单个或多个列以及计算表达式对搜索结果进行分组。结果可以：\n\n* 在组内排序\n\n* 每组返回多行\n\n* 对组进行过滤\n\n* 对组进行排序\n\n* 使用[聚合函数](../Searching/Grouping.md#Aggregation-functions)进行聚合\n\n<!-- intro -->\n\n通用语法为：\n\n<!-- request SQL -->\n\n通用语法\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nJSON 查询格式当前支持基本分组，可以检索聚合值及其 count(*)。\n\nCODE_BLOCK_1\n\n标准查询输出返回未分组的结果集，可以使用 `limit`（或 `size`）隐藏。\n\n聚合需要设置分组结果集大小的 `size`。\n\n<!-- end -->\n\n<!-- example group1 -->\n\n### 仅分组\n\n分组非常简单——只需在 `SELECT` 查询末尾添加 \"GROUP BY smth\"。这里的内容可以是：\n\n* 表中的任何非全文字段：整数、浮点数、字符串、多值属性（MVA）\n\n* 或者，如果在 `SELECT` 列表中使用了别名，也可以对其进行 GROUP BY\n\n你可以省略 `SELECT` 列表中的任何[聚合函数](../Searching/Grouping.md#Aggregation-functions)，分组依然有效：\n\n<!-- intro -->\n\n##### 例子：\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- request JSON -->\n\nCODE_BLOCK_4\n\n<!-- response JSON -->\n\nCODE_BLOCK_5\n\n<!-- end -->\n\n<!-- example group2 -->\n\n然而，在大多数情况下，你会希望为每个组获取一些聚合数据，例如：\n\n* 使用 `COUNT(*)` 仅获取每组的元素数量\n\n* 或者使用 `AVG(field)` 计算组内字段的平均值\n\n对于 HTTP JSON 请求，在主查询级别使用带有 `limit=0` 的单个 `aggs` 桶，作用类似于带有 `GROUP BY` 和 `COUNT(*)` 的 SQL 查询，提供等效的行为和性能。\n\n<!-- intro -->\n\n##### 例子：\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_6\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_7\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_8\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_9\n\n<!-- request JSON -->\n\nCODE_BLOCK_10\n\n<!-- response JSON -->\n\nCODE_BLOCK_11\n\n<!-- request PHP -->\n\nCODE_BLOCK_12\n\n<!-- response PHP -->\n\nCODE_BLOCK_13\n\n<!-- request Python -->\n\nCODE_BLOCK_14\n\n<!-- response Python -->\n\nCODE_BLOCK_15\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_16\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_17\n\n<!-- request Javascript -->\n\nCODE_BLOCK_18\n\n<!-- response Javascript -->\n\nCODE_BLOCK_19\n\n<!-- request Java -->\n\nCODE_BLOCK_20\n\n<!-- response Java -->\n\nCODE_BLOCK_21\n\n<!-- request C# -->\n\nCODE_BLOCK_22\n\n<!-- response C# -->\n\nCODE_BLOCK_23\n\n<!-- request Rust -->\n\nCODE_BLOCK_24\n\n<!-- response Rust -->\n\nCODE_BLOCK_25\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_26\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_27\n\n<!-- request Go -->\n\nCODE_BLOCK_28\n\n<!-- response Go -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n<!-- example sort1 -->\n\n##### 对组进行排序\n\n默认情况下，组不会排序，通常下一步你会希望按某个字段排序，比如你用于分组的字段：\n\n<!-- intro -->\n\n##### 例子：\n\n<!-- request SQL -->\n\nCODE_BLOCK_30\n\n<!-- response SQL -->\n\nCODE_BLOCK_31\n\n<!-- request JSON -->\n\nCODE_BLOCK_32\n\n<!-- response JSON -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n<!-- example sort2 -->\n\n或者，你可以按聚合排序：\n\n* 按 `count(*)` 排序，以显示元素最多的组优先\n\n* 按 `avg(rental_rate)` 排序，以显示评分最高的电影优先。注意，在示例中是通过别名完成的：`avg(rental_rate)` 首先映射为 `avg`，然后简单执行 `ORDER BY avg`\n\n<!-- intro -->\n\n##### 例子：\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_34\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_35\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_36\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_37\n\n<!-- request JSON -->\n\nCODE_BLOCK_38\n\n<!-- response JSON -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example group3 -->\n\n##### 同时按多个字段 GROUP BY\n\n有时你可能希望不仅按一个字段分组，而是按多个字段一起分组，比如电影的分类和年份：\n\n<!-- intro -->\n\n##### 例子：\n\n<!-- request SQL -->\n\nCODE_BLOCK_40\n\n<!-- response SQL -->\n\nCODE_BLOCK_41\n\n<!-- request JSON -->\n\nCODE_BLOCK_42\n\n<!-- response JSON -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n<!-- example group4 -->\n\n##### 给我 N 条记录\n\n有时不仅需要每组的单个元素，而是多个。这可以使用 `GROUP N BY` 轻松实现。例如，下面的情况中，我们为每个年份获取两部电影，而不是简单的 `GROUP BY release_year` 返回的一部。\n\n<!-- intro -->\n\n##### 例子：\n\n<!-- request SQL -->\n\nCODE_BLOCK_44\n\n<!-- response SQL -->\n\nCODE_BLOCK_45\n\n<!-- request JSON -->\n\nCODE_BLOCK_46\n\n<!-- response JSON -->\n\nCODE_BLOCK_47\n\n<!-- end -->\n\n<!-- example group5 -->\n\n##### 组内排序\n\n另一个关键的分析需求是对组内元素排序。为此，使用 `WITHIN GROUP ORDER BY ... {ASC|DESC}` 子句。例如，让我们获取每年评分最高的电影。注意，这与仅使用 `ORDER BY` 并行工作：\n\n* `WITHIN GROUP ORDER BY` 对结果**组内排序**\n\n* 仅 `GROUP BY` **对组本身排序**\n\n这两者完全独立工作。\n\n<!-- intro -->\n\n##### 例子：\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- response SQL -->\n\nCODE_BLOCK_49\n\n<!-- request JSON -->\n\nCODE_BLOCK_50\n\n<!-- response JSON -->\n\nCODE_BLOCK_51\n\n<!-- end -->\n\n<!-- example group6 -->\n\n##### 过滤组",
      "russian": "# Группировка результатов поиска\n\n<!-- example general -->\n\nГруппировка результатов поиска часто помогает получить количество совпадений для каждой группы или другие агрегаты. Например, это удобно для создания графика с количеством подходящих блогов за месяц, группировки результатов веб-поиска по сайтам или сообщений форума по авторам и т.д.\n\nManticore поддерживает группировку результатов поиска по одному или нескольким столбцам и вычисляемым выражениям. Результаты могут:\n\n* Быть отсортированы внутри группы\n\n* Возвращать более одной строки на группу\n\n* Иметь фильтрованные группы\n\n* Иметь отсортированные группы\n\n* Быть агрегированы с помощью [функций агрегации](../Searching/Grouping.md#Aggregation-functions)\n\n<!-- intro -->\n\nОбщий синтаксис:\n\n<!-- request SQL -->\n\nОбщий синтаксис\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nФормат JSON запроса в настоящее время поддерживает базовую группировку, которая может возвращать агрегированные значения и их количество с помощью count(*).\n\nCODE_BLOCK_1\n\nСтандартный вывод запроса возвращает набор результатов без группировки, который можно скрыть с помощью `limit` (или `size`).\n\nАгрегация требует установки `size` для определения размера набора результатов группы.\n\n<!-- end -->\n\n<!-- example group1 -->\n\n### Простая группировка\n\nГруппировка достаточно проста — просто добавьте \"GROUP BY smth\" в конец вашего `SELECT` запроса. Что угодно может быть:\n\n* Любым не-текстовым полем таблицы: целое число, число с плавающей точкой, строка, MVA (атрибут с несколькими значениями)\n\n* Или, если вы использовали псевдоним в списке `SELECT`, вы также можете делать GROUP BY по нему\n\nВы можете опустить любые [функции агрегации](../Searching/Grouping.md#Aggregation-functions) в списке `SELECT`, и это всё равно будет работать:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- request JSON -->\n\nCODE_BLOCK_4\n\n<!-- response JSON -->\n\nCODE_BLOCK_5\n\n<!-- end -->\n\n<!-- example group2 -->\n\nОднако в большинстве случаев вы захотите получить агрегированные данные для каждой группы, например:\n\n* `COUNT(*)`, чтобы просто узнать количество элементов в каждой группе\n\n* или `AVG(field)`, чтобы вычислить среднее значение поля в группе\n\nДля HTTP JSON запросов вариант с одним бакетом `aggs` и `limit=0` на уровне основного запроса работает аналогично SQL запросу с `GROUP BY` и `COUNT(*)`, обеспечивая эквивалентное поведение и производительность.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_6\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_7\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_8\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_9\n\n<!-- request JSON -->\n\nCODE_BLOCK_10\n\n<!-- response JSON -->\n\nCODE_BLOCK_11\n\n<!-- request PHP -->\n\nCODE_BLOCK_12\n\n<!-- response PHP -->\n\nCODE_BLOCK_13\n\n<!-- request Python -->\n\nCODE_BLOCK_14\n\n<!-- response Python -->\n\nCODE_BLOCK_15\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_16\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_17\n\n<!-- request Javascript -->\n\nCODE_BLOCK_18\n\n<!-- response Javascript -->\n\nCODE_BLOCK_19\n\n<!-- request Java -->\n\nCODE_BLOCK_20\n\n<!-- response Java -->\n\nCODE_BLOCK_21\n\n<!-- request C# -->\n\nCODE_BLOCK_22\n\n<!-- response C# -->\n\nCODE_BLOCK_23\n\n<!-- request Rust -->\n\nCODE_BLOCK_24\n\n<!-- response Rust -->\n\nCODE_BLOCK_25\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_26\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_27\n\n<!-- request Go -->\n\nCODE_BLOCK_28\n\n<!-- response Go -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n<!-- example sort1 -->\n\n##### Сортировка групп\n\nПо умолчанию группы не сортируются, и следующим шагом обычно бывает упорядочить их по чему-нибудь, например, по полю, по которому вы группируете:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_30\n\n<!-- response SQL -->\n\nCODE_BLOCK_31\n\n<!-- request JSON -->\n\nCODE_BLOCK_32\n\n<!-- response JSON -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n<!-- example sort2 -->\n\nАльтернативно, вы можете сортировать по агрегату:\n\n* по `count(*)`, чтобы показывать группы с наибольшим числом элементов первыми\n\n* по `avg(rental_rate)`, чтобы отображать фильмы с наивысшим рейтингом первыми. Обратите внимание, что в примере это делается через псевдоним: `avg(rental_rate)` сначала сопоставляется с `avg` в списке `SELECT`, а потом мы просто пишем `ORDER BY avg`\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_34\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_35\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_36\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_37\n\n<!-- request JSON -->\n\nCODE_BLOCK_38\n\n<!-- response JSON -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example group3 -->\n\n##### Группировка по нескольким полям сразу\n\nИногда может потребоваться группировать не только по одному полю, но и по нескольким одновременно, например, по категории фильма и году:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_40\n\n<!-- response SQL -->\n\nCODE_BLOCK_41\n\n<!-- request JSON -->\n\nCODE_BLOCK_42\n\n<!-- response JSON -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n<!-- example group4 -->\n\n##### Вывести N строк\n\nИногда полезно видеть не один элемент на группу, а несколько. Это легко достигается с помощью `GROUP N BY`. Например, в следующем случае мы получаем по два фильма для каждого года, а не по одному, как вернула бы простая команда `GROUP BY release_year`.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_44\n\n<!-- response SQL -->\n\nCODE_BLOCK_45\n\n<!-- request JSON -->\n\nCODE_BLOCK_46\n\n<!-- response JSON -->\n\nCODE_BLOCK_47\n\n<!-- end -->\n\n<!-- example group5 -->\n\n##### Сортировка внутри группы\n\nЕще одно важное требование аналитики — сортировать элементы внутри группы. Чтобы достичь этого, используйте конструкцию `WITHIN GROUP ORDER BY ... {ASC|DESC}`. Например, получим фильм с наивысшим рейтингом для каждого года. Обратите внимание, что это работает параллельно с просто `ORDER BY`:\n\n* `WITHIN GROUP ORDER BY` сортирует результаты **внутри группы**\n\n* тогда как просто `GROUP BY` **сортирует сами группы**\n\nОбе операции работают полностью независимо.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- response SQL -->\n\nCODE_BLOCK_49\n\n<!-- request JSON -->\n\nCODE_BLOCK_50\n\n<!-- response JSON -->\n\nCODE_BLOCK_51\n\n<!-- end -->\n\n<!-- example group6 -->\n\n##### Фильтрация групп"
    },
    "is_code_or_comment": false
  },
  "d16a30102e224f0e608bbb03f94822027e621efe0a66d3129237f5576a27d222": {
    "original": "res =searchApi.search({\"table\":\"products\",\"limit\":0,\"aggs\":{\"color\":{\"terms\":{\"field\":\"meta.color\",\"size\":100}}}})\n\nCODE_BLOCK_93\n\n{'aggregations': {u'color': {u'buckets': [{u'doc_count': 1,\n\n                                           u'key': u'green'},\n\n                                          {u'doc_count': 2, u'key': u'red'}]}},\n\n 'hits': {'hits': [], 'max_score': None, 'total': 3},\n\n 'profile': None,\n\n 'timed_out': False,\n\n 'took': 0}\n\nCODE_BLOCK_94\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_95\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_96\n\n<!-- request Javascript -->\n\nCODE_BLOCK_97\n\n<!-- response Javascript -->\n\nCODE_BLOCK_98\n\n<!-- request Java -->\n\nCODE_BLOCK_99\n\n<!-- response Java -->\n\nCODE_BLOCK_100\n\n<!-- request C# -->\n\nCODE_BLOCK_101\n\n<!-- response C# -->\n\nCODE_BLOCK_102\n\n<!-- request Rust -->\n\nCODE_BLOCK_103\n\n<!-- response Rust -->\n\nCODE_BLOCK_104\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_105\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_106\n\n<!-- request Go -->\n\nCODE_BLOCK_107\n\n<!-- response Go -->\n\nCODE_BLOCK_108\n\n<!-- end -->\n\n## Aggregation functions\n\nBesides `COUNT(*)`, which returns the number of elements in each group, you can use various other aggregation functions:\n\n<!-- example distinct -->\n\n##### COUNT(DISTINCT field)\n\nWhile `COUNT(*)` returns the number of all elements in the group, `COUNT(DISTINCT field)` returns the number of unique values of the field in the group, which may be completely different from the total count. For instance, you can have 100 elements in the group, but all with the same value for a certain field. `COUNT(DISTINCT field)` helps to determine that. To demonstrate this, let's create a table \"students\" with the student's name, age, and major:\n\nCODE_BLOCK_109\n\nso we have:\n\nCODE_BLOCK_110\n\nIn the example, you can see that if we GROUP BY major and display both `COUNT(*)` and `COUNT(DISTINCT age)`, it becomes clear that there are two students who chose the major \"cs\" with two unique ages, but for the major \"arts\", there are also two students, yet only one unique age.\n\nThere can be at most one `COUNT(DISTINCT)` per query.\n\n** By default, counts are approximate **\n\nActually, some of them are exact, while others are approximate. More on that below.\n\nManticore supports two algorithms for computing counts of distinct values. One is a legacy algorithm that uses a lot of memory and is usually slow. It collects `{group; value}` pairs, sorts them, and periodically discards duplicates. The benefit of this approach is that it guarantees exact counts within a plain table. You can enable it by setting the [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) option to `0`.\n\nThe other algorithm (enabled by default) loads counts into a hash table and returns its size. If the hash table becomes too large, its contents are moved into a `HyperLogLog`. This is where the counts become approximate since `HyperLogLog` is a probabilistic algorithm. The advantage is that the maximum memory usage per group is fixed and depends on the accuracy of the `HyperLogLog`. The overall memory usage also depends on the [max_matches](../Searching/Options.md#max_matches) setting, which reflects the number of groups.\n\nThe [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) option sets the threshold below which counts are guaranteed to be exact. The `HyperLogLog` accuracy setting and the threshold for the \"hash table to HyperLogLog\" conversion are derived from this setting. It's important to use this option with caution because doubling it will double the maximum memory required for count calculations. The maximum memory usage can be roughly estimated using this formula: `64 * max_matches * distinct_precision_threshold`. Note that this is the worst-case scenario, and in most cases, count calculations will use significantly less RAM.\n\n**`COUNT(DISTINCT)` against a distributed table or a real-time table consisting of multiple disk chunks may return inaccurate results**, but the result should be accurate for a distributed table consisting of local plain or real-time tables with the same schema (identical set/order of fields, but may have different tokenization settings).\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_111\n\n<!-- response SQL -->\n\nCODE_BLOCK_112\n\n<!-- request JSON -->\n\nCODE_BLOCK_113\n\n<!-- response JSON -->\n\nCODE_BLOCK_114\n\n<!-- end -->\n\n<!-- example concat -->\n\n##### GROUP_CONCAT(field)\n\nOften, you want to better understand the contents of each group. You can use [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) for that, but it would return additional rows you might not want in the output. `GROUP_CONCAT()` enriches your grouping by concatenating values of a specific field in the group. Let's take the previous example and improve it by displaying all the ages in each group.\n\n`GROUP_CONCAT(field)` returns the list as comma-separated values.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_115\n\n<!-- response SQL -->\n\nCODE_BLOCK_116\n\n<!-- request JSON -->\n\nCODE_BLOCK_117\n\n<!-- response JSON -->\n\nCODE_BLOCK_118\n\n<!-- end -->\n\n<!-- example sum -->\n\n##### SUM(), MIN(), MAX(), AVG()\n\nOf course, you can also obtain the sum, average, minimum, and maximum values within a group.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_119\n\n<!-- response SQL -->\n\nCODE_BLOCK_120\n\n<!-- request JSON -->\n\nCODE_BLOCK_121\n\n<!-- response JSON -->\n\nCODE_BLOCK_122\n\n<!-- end -->\n\n<!-- example accuracy -->\n\n## Grouping accuracy\n\nGrouping is done in fixed memory, which depends on the [max_matches](../Searching/Options.md#max_matches) setting. If `max_matches` allows for storage of all found groups, the results will be 100% accurate. However, if the value of `max_matches` is lower, the results will be less accurate.",
    "translations": {
      "chinese": "res =searchApi.search({\"table\":\"products\",\"limit\":0,\"aggs\":{\"color\":{\"terms\":{\"field\":\"meta.color\",\"size\":100}}}})\n\nCODE_BLOCK_93\n\n{'aggregations': {u'color': {u'buckets': [{u'doc_count': 1,\n\n                                           u'key': u'green'},\n\n                                          {u'doc_count': 2, u'key': u'red'}]}},\n\n 'hits': {'hits': [], 'max_score': None, 'total': 3},\n\n 'profile': None,\n\n 'timed_out': False,\n\n 'took': 0}\n\nCODE_BLOCK_94\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_95\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_96\n\n<!-- request Javascript -->\n\nCODE_BLOCK_97\n\n<!-- response Javascript -->\n\nCODE_BLOCK_98\n\n<!-- request Java -->\n\nCODE_BLOCK_99\n\n<!-- response Java -->\n\nCODE_BLOCK_100\n\n<!-- request C# -->\n\nCODE_BLOCK_101\n\n<!-- response C# -->\n\nCODE_BLOCK_102\n\n<!-- request Rust -->\n\nCODE_BLOCK_103\n\n<!-- response Rust -->\n\nCODE_BLOCK_104\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_105\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_106\n\n<!-- request Go -->\n\nCODE_BLOCK_107\n\n<!-- response Go -->\n\nCODE_BLOCK_108\n\n<!-- end -->\n\n## 聚合函数\n\n除了返回每组元素数量的 `COUNT(*)` 外，你还可以使用各种其他聚合函数：\n\n<!-- example distinct -->\n\n##### COUNT(DISTINCT field)\n\n虽然 `COUNT(*)` 返回组中所有元素的数量，`COUNT(DISTINCT field)` 返回组内该字段唯一值的数量，可能与总计数完全不同。例如，一个组中可能有100个元素，但某个字段的值全部相同。`COUNT(DISTINCT field)` 可以帮助确定这种情况。为此，我们创建一个包含学生姓名、年龄和专业的 \"students\" 表：\n\nCODE_BLOCK_109\n\n所以我们有：\n\nCODE_BLOCK_110\n\n在这个例子中，你可以看到，如果按专业分组并同时显示 `COUNT(*)` 和 `COUNT(DISTINCT age)`，就能清楚发现选择专业为 \"cs\" 的学生有两个，且年龄有两个不同值，而选择 \"arts\" 专业的学生也是两个，但只有一个唯一年龄。\n\n每个查询最多只能有一个 `COUNT(DISTINCT)`。\n\n**默认情况下，计数是近似值**\n\n实际上，有些是精确的，有些是近似的。下面将详细说明。\n\nManticore 支持两种计算唯一值计数的算法。一种是使用大量内存且通常较慢的旧算法。它收集 `{group; value}` 对，排序后定期去重。该方法的优点是保证普通表中的计数是精确的。通过将 [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) 选项设置为 `0` 可以启用该算法。\n\n另一种算法（默认启用）将计数加载到哈希表中并返回哈希表大小。如果哈希表变得过大，其内容会被移入 `HyperLogLog`。这时计数变为近似，因为 `HyperLogLog` 是一种概率算法。其优势是每个组的最大内存使用量固定，取决于 `HyperLogLog` 的精度。整体内存使用还取决于反映组数的 [max_matches](../Searching/Options.md#max_matches) 设置。\n\n[distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) 选项设置保证计数精确的阈值。`HyperLogLog` 的精度设置和“哈希表转换为 HyperLogLog”的阈值都从此选项中派生。使用该选项时需谨慎，因为其值加倍将使计数所需的最大内存加倍。最大内存使用可以粗略估算为：`64 * max_matches * distinct_precision_threshold`。请注意，这只是最坏情况，大多数情况下计数计算所用 RAM 会远低于该值。\n\n**针对分布式表或由多个磁盘块组成的实时表，`COUNT(DISTINCT)` 可能返回不准确的结果**，但对于由本地普通表或实时表（具有相同模式，即字段集合/顺序相同，但可能有不同的分词设置）组成的分布式表，结果应是准确的。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_111\n\n<!-- response SQL -->\n\nCODE_BLOCK_112\n\n<!-- request JSON -->\n\nCODE_BLOCK_113\n\n<!-- response JSON -->\n\nCODE_BLOCK_114\n\n<!-- end -->\n\n<!-- example concat -->\n\n##### GROUP_CONCAT(field)\n\n通常，你想更好地了解每个组的内容。可以使用 [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) 实现，但它会返回你可能不希望出现在结果中的额外行。`GROUP_CONCAT()` 通过将组中特定字段的值连接起来丰富你的分组。以之前的示例为例，改进显示每组中的所有年龄。\n\n`GROUP_CONCAT(field)` 返回逗号分隔的值列表。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_115\n\n<!-- response SQL -->\n\nCODE_BLOCK_116\n\n<!-- request JSON -->\n\nCODE_BLOCK_117\n\n<!-- response JSON -->\n\nCODE_BLOCK_118\n\n<!-- end -->\n\n<!-- example sum -->\n\n##### SUM(), MIN(), MAX(), AVG()\n\n当然，你还可以获得组内的总和、平均值、最小值和最大值。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_119\n\n<!-- response SQL -->\n\nCODE_BLOCK_120\n\n<!-- request JSON -->\n\nCODE_BLOCK_121\n\n<!-- response JSON -->\n\nCODE_BLOCK_122\n\n<!-- end -->\n\n<!-- example accuracy -->\n\n## 分组准确性\n\n分组操作是在固定内存中完成的，该内存依赖于 [max_matches](../Searching/Options.md#max_matches) 设置。如果 `max_matches` 足够存储所有找到的组，结果将是 100% 准确的。但是，如果 `max_matches` 设定较低，结果的准确性会降低。",
      "russian": "res =searchApi.search({\"table\":\"products\",\"limit\":0,\"aggs\":{\"color\":{\"terms\":{\"field\":\"meta.color\",\"size\":100}}}})\n\nCODE_BLOCK_93\n\n{'aggregations': {u'color': {u'buckets': [{u'doc_count': 1,\n\n                                           u'key': u'green'},\n\n                                          {u'doc_count': 2, u'key': u'red'}]}},\n\n 'hits': {'hits': [], 'max_score': None, 'total': 3},\n\n 'profile': None,\n\n 'timed_out': False,\n\n 'took': 0}\n\nCODE_BLOCK_94\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_95\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_96\n\n<!-- request Javascript -->\n\nCODE_BLOCK_97\n\n<!-- response Javascript -->\n\nCODE_BLOCK_98\n\n<!-- request Java -->\n\nCODE_BLOCK_99\n\n<!-- response Java -->\n\nCODE_BLOCK_100\n\n<!-- request C# -->\n\nCODE_BLOCK_101\n\n<!-- response C# -->\n\nCODE_BLOCK_102\n\n<!-- request Rust -->\n\nCODE_BLOCK_103\n\n<!-- response Rust -->\n\nCODE_BLOCK_104\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_105\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_106\n\n<!-- request Go -->\n\nCODE_BLOCK_107\n\n<!-- response Go -->\n\nCODE_BLOCK_108\n\n<!-- end -->\n\n## Функции агрегации\n\nПомимо `COUNT(*)`, который возвращает количество элементов в каждой группе, вы можете использовать различные другие функции агрегации:\n\n<!-- example distinct -->\n\n##### COUNT(DISTINCT field)\n\nВ то время как `COUNT(*)` возвращает количество всех элементов в группе, `COUNT(DISTINCT field)` возвращает количество уникальных значений поля в группе, что может существенно отличаться от общего подсчёта. Например, в группе может быть 100 элементов, но все с одинаковым значением для определённого поля. `COUNT(DISTINCT field)` помогает это определить. Для демонстрации создадим таблицу \"students\" с именем студента, возрастом и специальностью:\n\nCODE_BLOCK_109\n\nтак у нас есть:\n\nCODE_BLOCK_110\n\nВ примере видно, что если сгруппировать по специальности (major) и отобразить одновременно `COUNT(*)` и `COUNT(DISTINCT age)`, становится ясно, что в специальности \"cs\" два студента с двумя уникальными возрастами, а для специальности \"arts\" также два студента, но только один уникальный возраст.\n\nВ одном запросе может быть не более одного `COUNT(DISTINCT)`.\n\n** По умолчанию подсчёты являются приближенными **\n\nФактически некоторые из них точные, а другие - приближённые. Подробнее об этом ниже.\n\nManticore поддерживает два алгоритма вычисления подсчётов уникальных значений. Один — устаревший алгоритм, который требует много памяти и обычно медленный. Он собирает пары {group; value}, сортирует их и периодически удаляет дубликаты. Преимущество этого подхода в том, что он гарантирует точный подсчёт в простой таблице. Его можно включить, установив опцию [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) в значение `0`.\n\nДругой алгоритм (включён по умолчанию) загружает подсчёты в хеш-таблицу и возвращает её размер. Если хеш-таблица становится слишком большой, её содержимое переносится в `HyperLogLog`. Именно здесь подсчёты становятся приближенными, так как `HyperLogLog` — вероятностный алгоритм. Преимущество в том, что максимальное использование памяти на группу фиксировано и зависит от точности `HyperLogLog`. Общее использование памяти также зависит от настройки [max_matches](../Searching/Options.md#max_matches), которая отражает количество групп.\n\nОпция [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) задаёт порог, при котором подсчёты гарантированно точны. Настройка точности `HyperLogLog` и порог для конвертации \"хеш-таблица в HyperLogLog\" выводятся из этой настройки. Важно использовать эту опцию с осторожностью, так как удвоение её значения удвоит максимальное необходимое количество памяти для подсчёта. Максимальное использование памяти можно примерно оценить по формуле: `64 * max_matches * distinct_precision_threshold`. Учтите, что это худший сценарий, и в большинстве случаев для подсчётов будет использоваться значительно меньше оперативной памяти.\n\n**`COUNT(DISTINCT)` в отношении распределённой таблицы или таблицы в реальном времени, состоящей из нескольких дисковых чанков, может вернуть неточные результаты**, но результат должен быть точным для распределённой таблицы, состоящей из локальных простых или реальных таблиц с одинаковой схемой (одинаковый набор/порядок полей, но могут отличаться настройки токенизации).\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_111\n\n<!-- response SQL -->\n\nCODE_BLOCK_112\n\n<!-- request JSON -->\n\nCODE_BLOCK_113\n\n<!-- response JSON -->\n\nCODE_BLOCK_114\n\n<!-- end -->\n\n<!-- example concat -->\n\n##### GROUP_CONCAT(field)\n\nЧасто хочется лучше понять содержимое каждой группы. Для этого можно использовать [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows), но он вернёт дополнительные строки, которые вы, возможно, не хотите видеть в выводе. `GROUP_CONCAT()` расширяет вашу группировку, конкатенируя значения конкретного поля в группе. Возьмём предыдущий пример и улучшить его, отображая все возраста в каждой группе.\n\n`GROUP_CONCAT(field)` возвращает список в виде значений, разделённых запятыми.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_115\n\n<!-- response SQL -->\n\nCODE_BLOCK_116\n\n<!-- request JSON -->\n\nCODE_BLOCK_117\n\n<!-- response JSON -->\n\nCODE_BLOCK_118\n\n<!-- end -->\n\n<!-- example sum -->\n\n##### SUM(), MIN(), MAX(), AVG()\n\nКонечно, вы также можете получить сумму, среднее, минимальное и максимальное значения в группе.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_119\n\n<!-- response SQL -->\n\nCODE_BLOCK_120\n\n<!-- request JSON -->\n\nCODE_BLOCK_121\n\n<!-- response JSON -->\n\nCODE_BLOCK_122\n\n<!-- end -->\n\n<!-- example accuracy -->\n\n## Точность группировки\n\nГруппировка выполняется в фиксированной памяти, зависящей от настройки [max_matches](../Searching/Options.md#max_matches). Если `max_matches` позволяет хранить все найденные группы, результаты будут 100% точными. Однако, если значение `max_matches` ниже, точность результатов снижается."
    },
    "is_code_or_comment": false
  },
  "ecc090a753603627bceb6622cd47bad2957ef7b3b91aa80faca87c62a01cafdf": {
    "original": "`HAVING expression` is a helpful clause for filtering groups. While `WHERE` is applied before grouping, `HAVING` works with the groups. For example, let's keep only those years when the average rental rate of the films for that year was higher than 3. We get only four years:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_52\n\n<!-- response SQL -->\n\nCODE_BLOCK_53\n\n<!-- request JSON -->\n\nCODE_BLOCK_54\n\n<!-- response JSON -->\n\nCODE_BLOCK_55\n\n<!-- end -->\n\n**Note:** The `total_found` value in [search query meta info](../Node_info_and_management/SHOW_META.md#SHOW-META) reflects the number of groups that match the `HAVING` condition. This enables proper pagination when using `HAVING` clauses with `GROUP BY`.\n\n<!-- example group7 -->\n\n##### GROUPBY()\n\nThere is a function `GROUPBY()` which returns the key of the current group. It's useful in many cases, especially when you [GROUP BY an MVA](../Searching/Grouping.md#Grouping-by-MVA-%28multi-value-attributes%29) or a [JSON value](../Searching/Grouping.md#Grouping-by-a-JSON-node).\n\nIt can also be used in `HAVING`, for example, to keep only years 2000 and 2002.\n\nNote that `GROUPBY()`is not recommended for use when you GROUP BY multiple fields at once. It will still work, but since the group key in this case is a compound of field values, it may not appear the way you expect.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_56\n\n<!-- response SQL -->\n\nCODE_BLOCK_57\n\n<!-- request JSON -->\n\nCODE_BLOCK_58\n\n<!-- response JSON -->\n\nCODE_BLOCK_59\n\n<!-- end -->\n\n<!-- example mva -->\n\n##### Grouping by MVA (multi-value attributes)\n\nManticore supports grouping by [MVA](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29). To demonstrate how it works, let's create a table \"shoes\" with MVA \"sizes\" and insert a few documents into it:\n\nCODE_BLOCK_60\n\nso we have:\n\nCODE_BLOCK_61\n\nIf we now GROUP BY \"sizes\", it will process all our multi-value attributes and return an aggregation for each, in this case just the count:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_62\n\n<!-- response SQL -->\n\nCODE_BLOCK_63\n\n<!-- request JSON -->\n\nCODE_BLOCK_64\n\n<!-- response JSON -->\n\nCODE_BLOCK_65\n\n<!-- request PHP -->\n\nCODE_BLOCK_66\n\n<!-- response PHP -->\n\nCODE_BLOCK_67\n\n<!-- request Python -->\n\nCODE_BLOCK_68\n\n<!-- response Python -->\n\nCODE_BLOCK_69\n\n<!-- request Javascript -->\n\nCODE_BLOCK_70\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_71\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_72\n\n<!-- request Javascript -->\n\nCODE_BLOCK_73\n\n<!-- response Javascript -->\n\nCODE_BLOCK_74\n\n<!-- request Java -->\n\nCODE_BLOCK_75\n\n<!-- response Java -->\n\nCODE_BLOCK_76\n\n<!-- request C# -->\n\nCODE_BLOCK_77\n\n<!-- response C# -->\n\nCODE_BLOCK_78\n\n<!-- request Rust -->\n\nCODE_BLOCK_79\n\n<!-- response Rust -->\n\nCODE_BLOCK_80\n\nres = await searchApi.search({\n\n  index: 'test',\n\n  aggs: {\n\n    mva_agg: {\n\n      terms: { field: \"mva_field\", size: 2 }\n\n    }\n\n  }\n\n});\n\nCODE_BLOCK_81\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":4,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_82\n\nquery := map[string]interface{} {};\n\nsearchRequest.SetQuery(query);\n\naggTerms := manticoreclient.NewAggregationTerms()\n\naggTerms.SetField(\"mva_field\")\n\naggTerms.SetSize(2)\n\naggregation := manticoreclient.NewAggregation()\n\naggregation.setTerms(aggTerms)\n\nsearchRequest.SetAggregation(aggregation)\n\nres, _, _ := apiClient.SearchAPI.Search(context.Background()).SearchRequest(*searchRequest).Execute()\n\nCODE_BLOCK_83\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":5,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_84\n\ncreate table products(title text, meta json);\n\ninsert into products values(0,'nike','{\"color\":\"red\"}'),(0,'adidas','{\"color\":\"red\"}'),(0,'puma','{\"color\":\"green\"}');\n\nCODE_BLOCK_85\n\nSELECT * FROM products;\n\n+---------------------+-------------------+--------+\n\n| id                  | meta              | title  |\n\n+---------------------+-------------------+--------+\n\n| 1657851069130080268 | {\"color\":\"red\"}   | nike   |\n\n| 1657851069130080269 | {\"color\":\"red\"}   | adidas |\n\n| 1657851069130080270 | {\"color\":\"green\"} | puma   |\n\n+---------------------+-------------------+--------+\n\nCODE_BLOCK_86\n\nSELECT groupby() color, count(*) from products GROUP BY meta.color;\n\nCODE_BLOCK_87\n\n+-------+----------+\n\n| color | count(*) |\n\n+-------+----------+\n\n| red   |        2 |\n\n| green |        1 |\n\n+-------+----------+\n\nCODE_BLOCK_88\n\nPOST /search -d '\n\n    {\n\n     \"table\" : \"products\",\n\n     \"limit\": 0,\n\n     \"aggs\" :\n\n     {\n\n        \"color\" :\n\n         {\n\n            \"terms\" :\n\n             {\n\n              \"field\":\"meta.color\",\n\n              \"size\":100\n\n             }\n\n         }\n\n     }\n\n    }\n\n'\n\nCODE_BLOCK_89\n\n{\n\n  \"took\": 0,\n\n  \"timed_out\": false,\n\n  \"hits\": {\n\n    \"total\": 3,\n\n    \"hits\": [\n\n    ]\n\n  },\n\n  \"aggregations\": {\n\n    \"color\": {\n\n      \"buckets\": [\n\n        {\n\n          \"key\": \"green\",\n\n          \"doc_count\": 1\n\n        },\n\n        {\n\n          \"key\": \"red\",\n\n          \"doc_count\": 2\n\n        }\n\n      ]\n\n    }\n\n  }\n\n}\n\nCODE_BLOCK_90\n\n$index->setName('products');\n\n$search = $index->search('');\n\n$search->limit(0);\n\n$search->facet('meta.color','color',100);\n\n$results = $search->get();\n\nprint_r($results->getFacets());\n\nCODE_BLOCK_91\n\nArray\n\n(\n\n    [color] => Array\n\n        (\n\n            [buckets] => Array\n\n                (\n\n                    [0] => Array\n\n                        (\n\n                            [key] => green\n\n                            [doc_count] => 1\n\n                        )\n\n                    [1] => Array\n\n                        (\n\n                            [key] => red\n\n                            [doc_count] => 2\n\n                        )\n\n                )\n\n        )\n\n)\n\nCODE_BLOCK_92",
    "translations": {
      "chinese": "`HAVING expression` 是一个用于过滤分组的有用子句。虽然 `WHERE` 应用于分组之前，`HAVING` 则作用于分组。例如，我们只保留那些该年份电影的平均租赁价格高于 3 的年份。结果只得到四个年份：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_52\n\n<!-- response SQL -->\n\nCODE_BLOCK_53\n\n<!-- request JSON -->\n\nCODE_BLOCK_54\n\n<!-- response JSON -->\n\nCODE_BLOCK_55\n\n<!-- end -->\n\n**注意：** 在[搜索查询元信息](../Node_info_and_management/SHOW_META.md#SHOW-META)中，`total_found` 值反映了符合 `HAVING` 条件的分组数量。这使得在使用带有 `GROUP BY` 的 `HAVING` 子句时能够实现正确的分页。\n\n<!-- example group7 -->\n\n##### GROUPBY()\n\n有一个函数 `GROUPBY()`，它返回当前分组的键。它在很多情况下都很有用，尤其是在你[按 MVA 分组](../Searching/Grouping.md#Grouping-by-MVA-%28multi-value-attributes%29)或[按 JSON 值分组](../Searching/Grouping.md#Grouping-by-a-JSON-node)时。\n\n它也可以用在 `HAVING` 中，例如，只保留年份 2000 和 2002。\n\n注意，当你同时按多个字段进行分组时，不推荐使用 `GROUPBY()`。尽管它仍将起作用，但由于此时分组键是字段值的复合，结果可能不会符合你的预期。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_56\n\n<!-- response SQL -->\n\nCODE_BLOCK_57\n\n<!-- request JSON -->\n\nCODE_BLOCK_58\n\n<!-- response JSON -->\n\nCODE_BLOCK_59\n\n<!-- end -->\n\n<!-- example mva -->\n\n##### 按多值属性 (MVA) 分组\n\nManticore 支持按[MVA](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29)分组。为演示其工作原理，创建一个包含 MVA 字段 \"sizes\" 的表 \"shoes\" 并插入几个文档：\n\nCODE_BLOCK_60\n\n得到以下数据：\n\nCODE_BLOCK_61\n\n如果现在按 \"sizes\" 进行分组，它将处理所有多值属性并为每个值返回聚合，这里只是计数：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_62\n\n<!-- response SQL -->\n\nCODE_BLOCK_63\n\n<!-- request JSON -->\n\nCODE_BLOCK_64\n\n<!-- response JSON -->\n\nCODE_BLOCK_65\n\n<!-- request PHP -->\n\nCODE_BLOCK_66\n\n<!-- response PHP -->\n\nCODE_BLOCK_67\n\n<!-- request Python -->\n\nCODE_BLOCK_68\n\n<!-- response Python -->\n\nCODE_BLOCK_69\n\n<!-- request Javascript -->\n\nCODE_BLOCK_70\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_71\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_72\n\n<!-- request Javascript -->\n\nCODE_BLOCK_73\n\n<!-- response Javascript -->\n\nCODE_BLOCK_74\n\n<!-- request Java -->\n\nCODE_BLOCK_75\n\n<!-- response Java -->\n\nCODE_BLOCK_76\n\n<!-- request C# -->\n\nCODE_BLOCK_77\n\n<!-- response C# -->\n\nCODE_BLOCK_78\n\n<!-- request Rust -->\n\nCODE_BLOCK_79\n\n<!-- response Rust -->\n\nCODE_BLOCK_80\n\nres = await searchApi.search({\n\n  index: 'test',\n\n  aggs: {\n\n    mva_agg: {\n\n      terms: { field: \"mva_field\", size: 2 }\n\n    }\n\n  }\n\n});\n\nCODE_BLOCK_81\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":4,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_82\n\nquery := map[string]interface{} {};\n\nsearchRequest.SetQuery(query);\n\naggTerms := manticoreclient.NewAggregationTerms()\n\naggTerms.SetField(\"mva_field\")\n\naggTerms.SetSize(2)\n\naggregation := manticoreclient.NewAggregation()\n\naggregation.setTerms(aggTerms)\n\nsearchRequest.SetAggregation(aggregation)\n\nres, _, _ := apiClient.SearchAPI.Search(context.Background()).SearchRequest(*searchRequest).Execute()\n\nCODE_BLOCK_83\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":5,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_84\n\ncreate table products(title text, meta json);\n\ninsert into products values(0,'nike','{\"color\":\"red\"}'),(0,'adidas','{\"color\":\"red\"}'),(0,'puma','{\"color\":\"green\"}');\n\nCODE_BLOCK_85\n\nSELECT * FROM products;\n\n+---------------------+-------------------+--------+\n\n| id                  | meta              | title  |\n\n+---------------------+-------------------+--------+\n\n| 1657851069130080268 | {\"color\":\"red\"}   | nike   |\n\n| 1657851069130080269 | {\"color\":\"red\"}   | adidas |\n\n| 1657851069130080270 | {\"color\":\"green\"} | puma   |\n\n+---------------------+-------------------+--------+\n\nCODE_BLOCK_86\n\nSELECT groupby() color, count(*) from products GROUP BY meta.color;\n\nCODE_BLOCK_87\n\n+-------+----------+\n\n| color | count(*) |\n\n+-------+----------+\n\n| red   |        2 |\n\n| green |        1 |\n\n+-------+----------+\n\nCODE_BLOCK_88\n\nPOST /search -d '\n\n    {\n\n     \"table\" : \"products\",\n\n     \"limit\": 0,\n\n     \"aggs\" :\n\n     {\n\n        \"color\" :\n\n         {\n\n            \"terms\" :\n\n             {\n\n              \"field\":\"meta.color\",\n\n              \"size\":100\n\n             }\n\n         }\n\n     }\n\n    }\n\n'\n\nCODE_BLOCK_89\n\n{\n\n  \"took\": 0,\n\n  \"timed_out\": false,\n\n  \"hits\": {\n\n    \"total\": 3,\n\n    \"hits\": [\n\n    ]\n\n  },\n\n  \"aggregations\": {\n\n    \"color\": {\n\n      \"buckets\": [\n\n        {\n\n          \"key\": \"green\",\n\n          \"doc_count\": 1\n\n        },\n\n        {\n\n          \"key\": \"red\",\n\n          \"doc_count\": 2\n\n        }\n\n      ]\n\n    }\n\n  }\n\n}\n\nCODE_BLOCK_90\n\n$index->setName('products');\n\n$search = $index->search('');\n\n$search->limit(0);\n\n$search->facet('meta.color','color',100);\n\n$results = $search->get();\n\nprint_r($results->getFacets());\n\nCODE_BLOCK_91\n\nArray\n\n(\n\n    [color] => Array\n\n        (\n\n            [buckets] => Array\n\n                (\n\n                    [0] => Array\n\n                        (\n\n                            [key] => green\n\n                            [doc_count] => 1\n\n                        )\n\n                    [1] => Array\n\n                        (\n\n                            [key] => red\n\n                            [doc_count] => 2\n\n                        )\n\n                )\n\n        )\n\n)\n\nCODE_BLOCK_92",
      "russian": "`HAVING expression` — это полезный оператор для фильтрации групп. В то время как `WHERE` применяется до группировки, `HAVING` работает уже с группами. Например, оставим только те годы, когда средняя арендная ставка фильмов за этот год была выше 3. Получаем всего четыре года:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_52\n\n<!-- response SQL -->\n\nCODE_BLOCK_53\n\n<!-- request JSON -->\n\nCODE_BLOCK_54\n\n<!-- response JSON -->\n\nCODE_BLOCK_55\n\n<!-- end -->\n\n**Примечание:** Значение `total_found` в [метаинформации поискового запроса](../Node_info_and_management/SHOW_META.md#SHOW-META) отражает количество групп, соответствующих условию `HAVING`. Это позволяет корректно выполнять пагинацию при использовании `HAVING` вместе с `GROUP BY`.\n\n<!-- example group7 -->\n\n##### GROUPBY()\n\nСуществует функция `GROUPBY()`, которая возвращает ключ текущей группы. Она полезна во многих случаях, особенно когда вы делаете [GROUP BY по MVA](../Searching/Grouping.md#Grouping-by-MVA-%28multi-value-attributes%29) или по [значению JSON](../Searching/Grouping.md#Grouping-by-a-JSON-node).\n\nТакже её можно использовать в `HAVING`, например, чтобы оставить только годы 2000 и 2002.\n\nОбратите внимание, что `GROUPBY()` не рекомендуется использовать при одновременной группировке по нескольким полям. Она по-прежнему будет работать, но поскольку ключ группы в этом случае является составным из значений полей, он может не отображаться так, как вы ожидаете.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_56\n\n<!-- response SQL -->\n\nCODE_BLOCK_57\n\n<!-- request JSON -->\n\nCODE_BLOCK_58\n\n<!-- response JSON -->\n\nCODE_BLOCK_59\n\n<!-- end -->\n\n<!-- example mva -->\n\n##### Группировка по MVA (мультизначные атрибуты)\n\nManticore поддерживает группировку по [MVA](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29). Чтобы продемонстрировать, как это работает, создадим таблицу \"shoes\" с MVA \"sizes\" и вставим в неё несколько документов:\n\nCODE_BLOCK_60\n\nтак что у нас есть:\n\nCODE_BLOCK_61\n\nЕсли теперь сделать GROUP BY по \"sizes\", будут обработаны все наши мультизначные атрибуты, и для каждого будет возвращена агрегация, в данном случае просто количество:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_62\n\n<!-- response SQL -->\n\nCODE_BLOCK_63\n\n<!-- request JSON -->\n\nCODE_BLOCK_64\n\n<!-- response JSON -->\n\nCODE_BLOCK_65\n\n<!-- request PHP -->\n\nCODE_BLOCK_66\n\n<!-- response PHP -->\n\nCODE_BLOCK_67\n\n<!-- request Python -->\n\nCODE_BLOCK_68\n\n<!-- response Python -->\n\nCODE_BLOCK_69\n\n<!-- request Javascript -->\n\nCODE_BLOCK_70\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_71\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_72\n\n<!-- request Javascript -->\n\nCODE_BLOCK_73\n\n<!-- response Javascript -->\n\nCODE_BLOCK_74\n\n<!-- request Java -->\n\nCODE_BLOCK_75\n\n<!-- response Java -->\n\nCODE_BLOCK_76\n\n<!-- request C# -->\n\nCODE_BLOCK_77\n\n<!-- response C# -->\n\nCODE_BLOCK_78\n\n<!-- request Rust -->\n\nCODE_BLOCK_79\n\n<!-- response Rust -->\n\nCODE_BLOCK_80\n\nres = await searchApi.search({\n\n  index: 'test',\n\n  aggs: {\n\n    mva_agg: {\n\n      terms: { field: \"mva_field\", size: 2 }\n\n    }\n\n  }\n\n});\n\nCODE_BLOCK_81\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":4,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_82\n\nquery := map[string]interface{} {};\n\nsearchRequest.SetQuery(query);\n\naggTerms := manticoreclient.NewAggregationTerms()\n\naggTerms.SetField(\"mva_field\")\n\naggTerms.SetSize(2)\n\naggregation := manticoreclient.NewAggregation()\n\naggregation.setTerms(aggTerms)\n\nsearchRequest.SetAggregation(aggregation)\n\nres, _, _ := apiClient.SearchAPI.Search(context.Background()).SearchRequest(*searchRequest).Execute()\n\nCODE_BLOCK_83\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":5,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_84\n\ncreate table products(title text, meta json);\n\ninsert into products values(0,'nike','{\"color\":\"red\"}'),(0,'adidas','{\"color\":\"red\"}'),(0,'puma','{\"color\":\"green\"}');\n\nCODE_BLOCK_85\n\nSELECT * FROM products;\n\n+---------------------+-------------------+--------+\n\n| id                  | meta              | title  |\n\n+---------------------+-------------------+--------+\n\n| 1657851069130080268 | {\"color\":\"red\"}   | nike   |\n\n| 1657851069130080269 | {\"color\":\"red\"}   | adidas |\n\n| 1657851069130080270 | {\"color\":\"green\"} | puma   |\n\n+---------------------+-------------------+--------+\n\nCODE_BLOCK_86\n\nSELECT groupby() color, count(*) from products GROUP BY meta.color;\n\nCODE_BLOCK_87\n\n+-------+----------+\n\n| color | count(*) |\n\n+-------+----------+\n\n| red   |        2 |\n\n| green |        1 |\n\n+-------+----------+\n\nCODE_BLOCK_88\n\nPOST /search -d '\n\n    {\n\n     \"table\" : \"products\",\n\n     \"limit\": 0,\n\n     \"aggs\" :\n\n     {\n\n        \"color\" :\n\n         {\n\n            \"terms\" :\n\n             {\n\n              \"field\":\"meta.color\",\n\n              \"size\":100\n\n             }\n\n         }\n\n     }\n\n    }\n\n'\n\nCODE_BLOCK_89\n\n{\n\n  \"took\": 0,\n\n  \"timed_out\": false,\n\n  \"hits\": {\n\n    \"total\": 3,\n\n    \"hits\": [\n\n    ]\n\n  },\n\n  \"aggregations\": {\n\n    \"color\": {\n\n      \"buckets\": [\n\n        {\n\n          \"key\": \"green\",\n\n          \"doc_count\": 1\n\n        },\n\n        {\n\n          \"key\": \"red\",\n\n          \"doc_count\": 2\n\n        }\n\n      ]\n\n    }\n\n  }\n\n}\n\nCODE_BLOCK_90\n\n$index->setName('products');\n\n$search = $index->search('');\n\n$search->limit(0);\n\n$search->facet('meta.color','color',100);\n\n$results = $search->get();\n\nprint_r($results->getFacets());\n\nCODE_BLOCK_91\n\nArray\n\n(\n\n    [color] => Array\n\n        (\n\n            [buckets] => Array\n\n                (\n\n                    [0] => Array\n\n                        (\n\n                            [key] => green\n\n                            [doc_count] => 1\n\n                        )\n\n                    [1] => Array\n\n                        (\n\n                            [key] => red\n\n                            [doc_count] => 2\n\n                        )\n\n                )\n\n        )\n\n)\n\nCODE_BLOCK_92"
    },
    "is_code_or_comment": false
  }
}
