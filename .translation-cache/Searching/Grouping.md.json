{
  "1488d87346b8d56362461229f83245f6942de2d2bb8a2bbef7ee94eeabc22531": {
    "original": "<!-- response TypeScript -->\n\nCODE_BLOCK_92\n\n<!-- request Go -->\n\nCODE_BLOCK_93\n\n<!-- response Go -->\n\nCODE_BLOCK_94\n\n<!-- end -->\n\n## Aggregation functions\n\nBesides `COUNT(*)`, which returns the number of elements in each group, you can use various other aggregation functions:\n\n<!-- example distinct -->\n\n##### COUNT(DISTINCT field)\n\nWhile `COUNT(*)` returns the number of all elements in the group, `COUNT(DISTINCT field)` returns the number of unique values of the field in the group, which may be completely different from the total count. For instance, you can have 100 elements in the group, but all with the same value for a certain field. `COUNT(DISTINCT field)` helps to determine that. To demonstrate this, let's create a table \"students\" with the student's name, age, and major:\n\nCODE_BLOCK_95\n\nso we have:\n\nCODE_BLOCK_96\n\nIn the example, you can see that if we GROUP BY major and display both `COUNT(*)` and `COUNT(DISTINCT age)`, it becomes clear that there are two students who chose the major \"cs\" with two unique ages, but for the major \"arts\", there are also two students, yet only one unique age.\n\nThere can be at most one `COUNT(DISTINCT)` per query.\n\n** By default, counts are approximate **\n\nActually, some of them are exact, while others are approximate. More on that below.\n\nManticore supports two algorithms for computing counts of distinct values. One is a legacy algorithm that uses a lot of memory and is usually slow. It collects `{group; value}` pairs, sorts them, and periodically discards duplicates. The benefit of this approach is that it guarantees exact counts within a plain table. You can enable it by setting the [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) option to `0`.\n\nThe other algorithm (enabled by default) loads counts into a hash table and returns its size. If the hash table becomes too large, its contents are moved into a `HyperLogLog`. This is where the counts become approximate since `HyperLogLog` is a probabilistic algorithm. The advantage is that the maximum memory usage per group is fixed and depends on the accuracy of the `HyperLogLog`. The overall memory usage also depends on the [max_matches](../Searching/Options.md#max_matches) setting, which reflects the number of groups.\n\nThe [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) option sets the threshold below which counts are guaranteed to be exact. The `HyperLogLog` accuracy setting and the threshold for the \"hash table to HyperLogLog\" conversion are derived from this setting. It's important to use this option with caution because doubling it will double the maximum memory required for count calculations. The maximum memory usage can be roughly estimated using this formula: `64 * max_matches * distinct_precision_threshold`. Note that this is the worst-case scenario, and in most cases, count calculations will use significantly less RAM.\n\n**`COUNT(DISTINCT)` against a distributed table or a real-time table consisting of multiple disk chunks may return inaccurate results**, but the result should be accurate for a distributed table consisting of local plain or real-time tables with the same schema (identical set/order of fields, but may have different tokenization settings).\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_97\n\n<!-- response SQL -->\n\nCODE_BLOCK_98\n\n<!-- end -->\n\n<!-- example concat -->\n\n##### GROUP_CONCAT(field)\n\nOften, you want to better understand the contents of each group. You can use [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) for that, but it would return additional rows you might not want in the output. `GROUP_CONCAT()` enriches your grouping by concatenating values of a specific field in the group. Let's take the previous example and improve it by displaying all the ages in each group.\n\n`GROUP_CONCAT(field)` returns the list as comma-separated values.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_99\n\n<!-- response SQL -->\n\nCODE_BLOCK_100\n\n<!-- end -->\n\n<!-- example sum -->\n\n##### SUM(), MIN(), MAX(), AVG()\n\nOf course, you can also obtain the sum, average, minimum, and maximum values within a group.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_101\n\n<!-- response SQL -->\n\nCODE_BLOCK_102\n\n<!-- end -->\n\n<!-- example accuracy -->\n\n## Grouping accuracy\n\nGrouping is done in fixed memory, which depends on the [max_matches](../Searching/Options.md#max_matches) setting. If `max_matches` allows for storage of all found groups, the results will be 100% accurate. However, if the value of `max_matches` is lower, the results will be less accurate.\n\nWhen parallel processing is involved, it can become more complicated. When `pseudo_sharding` is enabled and/or when using an RT table with several disk chunks, each chunk or pseudo shard gets a result set that is no larger than `max_matches`. This can lead to inaccuracies in aggregates and group counts when the result sets from different threads are merged. To fix this, either a larger `max_matches` value or disabling parallel processing can be used.\n\nManticore will try to increase `max_matches` up to [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold) if it detects that groupby may return inaccurate results. Detection is based on the number of unique values of the groupby attribute, which is retrieved from secondary indexes (if present).\n\nTo ensure accurate aggregates and/or group counts when using RT tables or `pseudo_sharding`, `accurate_aggregation` can be enabled. This will try to increase `max_matches` up to the threshold, and if the threshold is not high enough, Manticore will disable parallel processing for the query.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_103\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "<!-- response TypeScript -->\n\nCODE_BLOCK_92\n\n<!-- request Go -->\n\nCODE_BLOCK_93\n\n<!-- response Go -->\n\nCODE_BLOCK_94\n\n<!-- end -->\n\n## Aggregation functions\n\nBesides `COUNT(*)`, which returns the number of elements in each group, you can use various other aggregation functions:\n\n<!-- example distinct -->\n\n##### COUNT(DISTINCT field)\n\nWhile `COUNT(*)` returns the number of all elements in the group, `COUNT(DISTINCT field)` returns the number of unique values of the field in the group, which may be completely different from the total count. For instance, you can have 100 elements in the group, but all with the same value for a certain field. `COUNT(DISTINCT field)` helps to determine that. To demonstrate this, let's create a table \"students\" with the student's name, age, and major:\n\nCODE_BLOCK_95\n\nso we have:\n\nCODE_BLOCK_96\n\nIn the example, you can see that if we GROUP BY major and display both `COUNT(*)` and `COUNT(DISTINCT age)`, it becomes clear that there are two students who chose the major \"cs\" with two unique ages, but for the major \"arts\", there are also two students, yet only one unique age.\n\nThere can be at most one `COUNT(DISTINCT)` per query.\n\n** By default, counts are approximate **\n\nActually, some of them are exact, while others are approximate. More on that below.\n\nManticore supports two algorithms for computing counts of distinct values. One is a legacy algorithm that uses a lot of memory and is usually slow. It collects `{group; value}` pairs, sorts them, and periodically discards duplicates. The benefit of this approach is that it guarantees exact counts within a plain table. You can enable it by setting the [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) option to `0`.\n\nThe other algorithm (enabled by default) loads counts into a hash table and returns its size. If the hash table becomes too large, its contents are moved into a `HyperLogLog`. This is where the counts become approximate since `HyperLogLog` is a probabilistic algorithm. The advantage is that the maximum memory usage per group is fixed and depends on the accuracy of the `HyperLogLog`. The overall memory usage also depends on the [max_matches](../Searching/Options.md#max_matches) setting, which reflects the number of groups.\n\nThe [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) option sets the threshold below which counts are guaranteed to be exact. The `HyperLogLog` accuracy setting and the threshold for the \"hash table to HyperLogLog\" conversion are derived from this setting. It's important to use this option with caution because doubling it will double the maximum memory required for count calculations. The maximum memory usage can be roughly estimated using this formula: `64 * max_matches * distinct_precision_threshold`. Note that this is the worst-case scenario, and in most cases, count calculations will use significantly less RAM.\n\n**`COUNT(DISTINCT)` against a distributed table or a real-time table consisting of multiple disk chunks may return inaccurate results**, but the result should be accurate for a distributed table consisting of local plain or real-time tables with the same schema (identical set/order of fields, but may have different tokenization settings).\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_97\n\n<!-- response SQL -->\n\nCODE_BLOCK_98\n\n<!-- end -->\n\n<!-- example concat -->\n\n##### GROUP_CONCAT(field)\n\nOften, you want to better understand the contents of each group. You can use [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) for that, but it would return additional rows you might not want in the output. `GROUP_CONCAT()` enriches your grouping by concatenating values of a specific field in the group. Let's take the previous example and improve it by displaying all the ages in each group.\n\n`GROUP_CONCAT(field)` returns the list as comma-separated values.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_99\n\n<!-- response SQL -->\n\nCODE_BLOCK_100\n\n<!-- end -->\n\n<!-- example sum -->\n\n##### SUM(), MIN(), MAX(), AVG()\n\nOf course, you can also obtain the sum, average, minimum, and maximum values within a group.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_101\n\n<!-- response SQL -->\n\nCODE_BLOCK_102\n\n<!-- end -->\n\n<!-- example accuracy -->\n\n## Grouping accuracy\n\nGrouping is done in fixed memory, which depends on the [max_matches](../Searching/Options.md#max_matches) setting. If `max_matches` allows for storage of all found groups, the results will be 100% accurate. However, if the value of `max_matches` is lower, the results will be less accurate.\n\nWhen parallel processing is involved, it can become more complicated. When `pseudo_sharding` is enabled and/or when using an RT table with several disk chunks, each chunk or pseudo shard gets a result set that is no larger than `max_matches`. This can lead to inaccuracies in aggregates and group counts when the result sets from different threads are merged. To fix this, either a larger `max_matches` value or disabling parallel processing can be used.\n\nManticore will try to increase `max_matches` up to [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold) if it detects that groupby may return inaccurate results. Detection is based on the number of unique values of the groupby attribute, which is retrieved from secondary indexes (if present).\n\nTo ensure accurate aggregates and/or group counts when using RT tables or `pseudo_sharding`, `accurate_aggregation` can be enabled. This will try to increase `max_matches` up to the threshold, and if the threshold is not high enough, Manticore will disable parallel processing for the query.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_103\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "<!-- response TypeScript -->\n\nCODE_BLOCK_92\n\n<!-- request Go -->\n\nCODE_BLOCK_93\n\n<!-- response Go -->\n\nCODE_BLOCK_94\n\n<!-- end -->\n\n## Aggregation functions\n\nBesides `COUNT(*)`, which returns the number of elements in each group, you can use various other aggregation functions:\n\n<!-- example distinct -->\n\n##### COUNT(DISTINCT field)\n\nWhile `COUNT(*)` returns the number of all elements in the group, `COUNT(DISTINCT field)` returns the number of unique values of the field in the group, which may be completely different from the total count. For instance, you can have 100 elements in the group, but all with the same value for a certain field. `COUNT(DISTINCT field)` helps to determine that. To demonstrate this, let's create a table \"students\" with the student's name, age, and major:\n\nCODE_BLOCK_95\n\nso we have:\n\nCODE_BLOCK_96\n\nIn the example, you can see that if we GROUP BY major and display both `COUNT(*)` and `COUNT(DISTINCT age)`, it becomes clear that there are two students who chose the major \"cs\" with two unique ages, but for the major \"arts\", there are also two students, yet only one unique age.\n\nThere can be at most one `COUNT(DISTINCT)` per query.\n\n** By default, counts are approximate **\n\nActually, some of them are exact, while others are approximate. More on that below.\n\nManticore supports two algorithms for computing counts of distinct values. One is a legacy algorithm that uses a lot of memory and is usually slow. It collects `{group; value}` pairs, sorts them, and periodically discards duplicates. The benefit of this approach is that it guarantees exact counts within a plain table. You can enable it by setting the [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) option to `0`.\n\nThe other algorithm (enabled by default) loads counts into a hash table and returns its size. If the hash table becomes too large, its contents are moved into a `HyperLogLog`. This is where the counts become approximate since `HyperLogLog` is a probabilistic algorithm. The advantage is that the maximum memory usage per group is fixed and depends on the accuracy of the `HyperLogLog`. The overall memory usage also depends on the [max_matches](../Searching/Options.md#max_matches) setting, which reflects the number of groups.\n\nThe [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) option sets the threshold below which counts are guaranteed to be exact. The `HyperLogLog` accuracy setting and the threshold for the \"hash table to HyperLogLog\" conversion are derived from this setting. It's important to use this option with caution because doubling it will double the maximum memory required for count calculations. The maximum memory usage can be roughly estimated using this formula: `64 * max_matches * distinct_precision_threshold`. Note that this is the worst-case scenario, and in most cases, count calculations will use significantly less RAM.\n\n**`COUNT(DISTINCT)` against a distributed table or a real-time table consisting of multiple disk chunks may return inaccurate results**, but the result should be accurate for a distributed table consisting of local plain or real-time tables with the same schema (identical set/order of fields, but may have different tokenization settings).\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_97\n\n<!-- response SQL -->\n\nCODE_BLOCK_98\n\n<!-- end -->\n\n<!-- example concat -->\n\n##### GROUP_CONCAT(field)\n\nOften, you want to better understand the contents of each group. You can use [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) for that, but it would return additional rows you might not want in the output. `GROUP_CONCAT()` enriches your grouping by concatenating values of a specific field in the group. Let's take the previous example and improve it by displaying all the ages in each group.\n\n`GROUP_CONCAT(field)` returns the list as comma-separated values.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_99\n\n<!-- response SQL -->\n\nCODE_BLOCK_100\n\n<!-- end -->\n\n<!-- example sum -->\n\n##### SUM(), MIN(), MAX(), AVG()\n\nOf course, you can also obtain the sum, average, minimum, and maximum values within a group.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_101\n\n<!-- response SQL -->\n\nCODE_BLOCK_102\n\n<!-- end -->\n\n<!-- example accuracy -->\n\n## Grouping accuracy\n\nGrouping is done in fixed memory, which depends on the [max_matches](../Searching/Options.md#max_matches) setting. If `max_matches` allows for storage of all found groups, the results will be 100% accurate. However, if the value of `max_matches` is lower, the results will be less accurate.\n\nWhen parallel processing is involved, it can become more complicated. When `pseudo_sharding` is enabled and/or when using an RT table with several disk chunks, each chunk or pseudo shard gets a result set that is no larger than `max_matches`. This can lead to inaccuracies in aggregates and group counts when the result sets from different threads are merged. To fix this, either a larger `max_matches` value or disabling parallel processing can be used.\n\nManticore will try to increase `max_matches` up to [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold) if it detects that groupby may return inaccurate results. Detection is based on the number of unique values of the groupby attribute, which is retrieved from secondary indexes (if present).\n\nTo ensure accurate aggregates and/or group counts when using RT tables or `pseudo_sharding`, `accurate_aggregation` can be enabled. This will try to increase `max_matches` up to the threshold, and if the threshold is not high enough, Manticore will disable parallel processing for the query.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_103\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": true
  },
  "33a62fad63e0639f879c04a221a6e46f18af5d32dbd1ea2596792c82b52b242a": {
    "original": "# Grouping search results\n\n<!-- example general -->\n\nGrouping search results is often helpful for obtaining per-group match counts or other aggregations. For example, it's useful for creating a graph illustrating the number of matching blog posts per month or grouping web search results by site or forum posts by author, etc.\n\nManticore supports the grouping of search results by single or multiple columns and computed expressions. The results can:\n\n* Be sorted within a group\n\n* Return more than one row per group\n\n* Have groups filtered\n\n* Have groups sorted\n\n* Be aggregated using the [aggregation functions](../Searching/Grouping.md#Aggregation-functions)\n\n<!-- intro -->\n\nThe general syntax is:\n\n<!-- request SQL -->\n\nGeneral syntax\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nJSON query format currently supports a basic grouping that can retrieve aggregate values and their count(*).\n\nCODE_BLOCK_1\n\nThe standard query output returns the result set without grouping, which can be hidden using `limit` (or `size`).\n\nThe aggregation requires setting a `size` for the group's result set size.\n\n<!-- end -->\n\n<!-- example group1 -->\n\n### Just Grouping\n\nGrouping is quite simple - just add \"GROUP BY smth\" to the end of your `SELECT` query. The something can be:\n\n* Any non-full-text field from the table: integer, float, string, MVA (multi-value attribute)\n\n* Or, if you used an alias in the `SELECT` list, you can GROUP BY it too\n\nYou can omit any [aggregation functions](../Searching/Grouping.md#Aggregation-functions) in the `SELECT` list and it will still work:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- example group2 -->\n\nIn most cases, however, you'll want to obtain some aggregated data for each group, such as:\n\n* `COUNT(*)` to simply get the number of elements in each group\n\n* or `AVG(field)` to calculate the average value of the field within the group\n\nFor HTTP JSON requests, using a single `aggs` bucket with `limit=0` at the main query level works similarly to a SQL query with `GROUP BY` and `COUNT(*)`, providing equivalent behavior and performance.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_4\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_5\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_6\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_7\n\n<!-- request JSON -->\n\nCODE_BLOCK_8\n\n<!-- response JSON -->\n\nCODE_BLOCK_9\n\n<!-- request PHP -->\n\nCODE_BLOCK_10\n\n<!-- response PHP -->\n\nCODE_BLOCK_11\n\n<!-- request Python -->\n\nCODE_BLOCK_12\n\n<!-- response Python -->\n\nCODE_BLOCK_13\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_14\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_15\n\n<!-- request Javascript -->\n\nCODE_BLOCK_16\n\n<!-- response Javascript -->\n\nCODE_BLOCK_17\n\n<!-- request Java -->\n\nCODE_BLOCK_18\n\n<!-- response Java -->\n\nCODE_BLOCK_19\n\n<!-- request C# -->\n\nCODE_BLOCK_20\n\n<!-- response C# -->\n\nCODE_BLOCK_21\n\n<!-- request Rust -->\n\nCODE_BLOCK_22\n\n<!-- response Rust -->\n\nCODE_BLOCK_23\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_24\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_25\n\n<!-- request Go -->\n\nCODE_BLOCK_26\n\n<!-- response Go -->\n\nCODE_BLOCK_27\n\n<!-- end -->\n\n<!-- example sort1 -->\n\n##### Sorting groups\n\nBy default, groups are not sorted, and the next thing you typically want to do is order them by something, like the field you're grouping by:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_28\n\n<!-- response SQL -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n<!-- example sort2 -->\n\nAlternatively, you can sort by the aggregation:\n\n* by `count(*)` to display groups with the most elements first\n\n* by `avg(rental_rate)` to show the highest-rated movies first. Note that in the example, it's done via an alias: `avg(rental_rate)` is first mapped to `avg` in the `SELECT` list, and then we simply do `ORDER BY avg`\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_30\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_31\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_32\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n<!-- example group3 -->\n\n##### GROUP BY multiple fields at once\n\nIn some cases, you might want to group not just by a single field, but by multiple fields at once, such as a movie's category and year:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_34\n\n<!-- response SQL -->\n\nCODE_BLOCK_35\n\n<!-- request JSON -->\n\nCODE_BLOCK_36\n\n<!-- response JSON -->\n\nCODE_BLOCK_37\n\n<!-- end -->\n\n<!-- example group4 -->\n\n##### Give me N rows\n\nSometimes it's useful to see not just a single element per group, but multiple. This can be easily achieved with the help of `GROUP N BY`. For example, in the following case, we get two movies for each year rather than just one, which a simple `GROUP BY release_year` would have returned.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_38\n\n<!-- response SQL -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example group5 -->\n\n##### Sorting inside a group\n\nAnother crucial analytics requirement is to sort elements within a group. To achieve this, use the `WITHIN GROUP ORDER BY ... {ASC|DESC}` clause. For example, let's get the highest-rated film for each year. Note that it works in parallel with just `ORDER BY`:\n\n* `WITHIN GROUP ORDER BY` sorts results **inside a group**\n\n* while just `GROUP BY` **sorts the groups themselves**\n\nThese two work entirely independently.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_40\n\n<!-- response SQL -->\n\nCODE_BLOCK_41\n\n<!-- end -->\n\n<!-- example group6 -->\n\n##### Filter groups\n\n`HAVING expression` is a helpful clause for filtering groups. While `WHERE` is applied before grouping, `HAVING` works with the groups. For example, let's keep only those years when the average rental rate of the films for that year was higher than 3. We get only four years:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_42\n\n<!-- response SQL -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\nNote that `HAVING` does not affect `total_found` in the [search query meta info](../Node_info_and_management/SHOW_META.md#SHOW-META).\n\n<!-- example group7 -->\n\n##### GROUPBY()",
    "translations": {
      "chinese": "# 分组搜索结果\n\n<!-- example general -->\n\n分组搜索结果通常有助于获取每组的匹配计数或其他聚合。例如，它对于创建每月匹配博客文章数量的图表，或按网站分组网页搜索结果，或按作者分组论坛帖子等非常有用。\n\nManticore 支持按单列或多列以及计算表达式对搜索结果进行分组。结果可以：\n\n* 在组内排序\n\n* 每组返回多行\n\n* 过滤组\n\n* 对组进行排序\n\n* 使用[聚合函数](../Searching/Grouping.md#Aggregation-functions)进行聚合\n\n<!-- intro -->\n\n通用语法是：\n\n<!-- request SQL -->\n\n通用语法\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nJSON 查询格式目前支持基本分组，可以检索聚合值及其 count(*)。\n\nCODE_BLOCK_1\n\n标准查询输出返回未分组的结果集，可以使用 `limit`（或 `size`）隐藏。\n\n聚合需要设置组结果集的 `size`。\n\n<!-- end -->\n\n<!-- example group1 -->\n\n### 仅分组\n\n分组非常简单——只需在 `SELECT` 查询末尾添加 \"GROUP BY smth\"。这里的某物可以是：\n\n* 表中的任何非全文字段：整数、浮点数、字符串、多值属性（MVA）\n\n* 或者，如果你在 `SELECT` 列表中使用了别名，也可以按别名分组\n\n你可以省略 `SELECT` 列表中的任何[聚合函数](../Searching/Grouping.md#Aggregation-functions)，它仍然有效：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- example group2 -->\n\n然而，在大多数情况下，你会想为每个组获取一些聚合数据，例如：\n\n* `COUNT(*)` 用于简单获取每组中的元素数量\n\n* 或者 `AVG(field)` 用于计算组内字段的平均值\n\n对于 HTTP JSON 请求，使用单个带有 `limit=0` 的 `aggs` 桶，在主查询级别，效果类似于带有 `GROUP BY` 和 `COUNT(*)` 的 SQL 查询，提供等效的行为和性能。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_4\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_5\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_6\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_7\n\n<!-- request JSON -->\n\nCODE_BLOCK_8\n\n<!-- response JSON -->\n\nCODE_BLOCK_9\n\n<!-- request PHP -->\n\nCODE_BLOCK_10\n\n<!-- response PHP -->\n\nCODE_BLOCK_11\n\n<!-- request Python -->\n\nCODE_BLOCK_12\n\n<!-- response Python -->\n\nCODE_BLOCK_13\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_14\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_15\n\n<!-- request Javascript -->\n\nCODE_BLOCK_16\n\n<!-- response Javascript -->\n\nCODE_BLOCK_17\n\n<!-- request Java -->\n\nCODE_BLOCK_18\n\n<!-- response Java -->\n\nCODE_BLOCK_19\n\n<!-- request C# -->\n\nCODE_BLOCK_20\n\n<!-- response C# -->\n\nCODE_BLOCK_21\n\n<!-- request Rust -->\n\nCODE_BLOCK_22\n\n<!-- response Rust -->\n\nCODE_BLOCK_23\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_24\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_25\n\n<!-- request Go -->\n\nCODE_BLOCK_26\n\n<!-- response Go -->\n\nCODE_BLOCK_27\n\n<!-- end -->\n\n<!-- example sort1 -->\n\n##### 对组进行排序\n\n默认情况下，组不排序，接下来你通常想做的是按某个字段排序，比如你分组所用的字段：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_28\n\n<!-- response SQL -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n<!-- example sort2 -->\n\n或者，你可以按聚合排序：\n\n* 按 `count(*)` 显示元素最多的组优先\n\n* 按 `avg(rental_rate)` 显示评分最高的电影优先。注意示例中是通过别名完成的：`avg(rental_rate)` 首先在 `SELECT` 列表中映射为 `avg`，然后我们简单地做 `ORDER BY avg`\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_30\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_31\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_32\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n<!-- example group3 -->\n\n##### 同时按多个字段 GROUP BY\n\n在某些情况下，你可能想不仅按单个字段分组，而是同时按多个字段分组，比如电影的类别和年份：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_34\n\n<!-- response SQL -->\n\nCODE_BLOCK_35\n\n<!-- request JSON -->\n\nCODE_BLOCK_36\n\n<!-- response JSON -->\n\nCODE_BLOCK_37\n\n<!-- end -->\n\n<!-- example group4 -->\n\n##### 给我 N 行\n\n有时查看每组不止一个元素很有用。这可以通过 `GROUP N BY` 轻松实现。例如，下面的例子中，我们为每年获取两部电影，而不是简单的 `GROUP BY release_year` 返回的一部。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_38\n\n<!-- response SQL -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example group5 -->\n\n##### 组内排序\n\n另一个关键的分析需求是对组内元素排序。为此，使用 `WITHIN GROUP ORDER BY ... {ASC|DESC}` 子句。例如，我们获取每年评分最高的电影。注意它与单独的 `ORDER BY` 并行工作：\n\n* `WITHIN GROUP ORDER BY` 对组内结果排序\n\n* 而单独的 `GROUP BY` 对组本身排序\n\n这两者完全独立工作。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_40\n\n<!-- response SQL -->\n\nCODE_BLOCK_41\n\n<!-- end -->\n\n<!-- example group6 -->\n\n##### 过滤组\n\n`HAVING expression` 是过滤组的有用子句。`WHERE` 在分组前应用，而 `HAVING` 作用于组。例如，我们只保留那些该年电影平均租赁率高于 3 的年份。结果只有四个年份：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_42\n\n<!-- response SQL -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n注意 `HAVING` 不影响[搜索查询元信息](../Node_info_and_management/SHOW_META.md#SHOW-META)中的 `total_found`。\n\n<!-- example group7 -->\n\n##### GROUPBY()",
      "russian": "# Группировка результатов поиска\n\n<!-- example general -->\n\nГруппировка результатов поиска часто полезна для получения количества совпадений по группам или других агрегатов. Например, это удобно для создания графика, иллюстрирующего количество совпадающих блог-постов по месяцам, или для группировки результатов веб-поиска по сайту, или сообщений на форуме по автору и т.д.\n\nManticore поддерживает группировку результатов поиска по одному или нескольким столбцам и вычисляемым выражениям. Результаты могут:\n\n* Быть отсортированы внутри группы\n\n* Возвращать более одной строки на группу\n\n* Иметь отфильтрованные группы\n\n* Иметь отсортированные группы\n\n* Быть агрегированы с помощью [функций агрегации](../Searching/Grouping.md#Aggregation-functions)\n\n<!-- intro -->\n\nОбщий синтаксис:\n\n<!-- request SQL -->\n\nОбщий синтаксис\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nФормат JSON-запроса в настоящее время поддерживает базовую группировку, которая может получать агрегированные значения и их count(*).\n\nCODE_BLOCK_1\n\nСтандартный вывод запроса возвращает набор результатов без группировки, который можно скрыть с помощью `limit` (или `size`).\n\nАгрегация требует установки `size` для размера набора результатов группы.\n\n<!-- end -->\n\n<!-- example group1 -->\n\n### Просто группировка\n\nГруппировка довольно проста — просто добавьте \"GROUP BY smth\" в конец вашего запроса `SELECT`. Что-то может быть:\n\n* Любым не полнотекстовым полем из таблицы: integer, float, string, MVA (мульти-значение атрибута)\n\n* Или, если вы использовали псевдоним в списке `SELECT`, вы также можете группировать по нему\n\nВы можете опустить любые [функции агрегации](../Searching/Grouping.md#Aggregation-functions) в списке `SELECT`, и это всё равно будет работать:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- example group2 -->\n\nВ большинстве случаев, однако, вы захотите получить некоторые агрегированные данные для каждой группы, например:\n\n* `COUNT(*)`, чтобы просто получить количество элементов в каждой группе\n\n* или `AVG(field)`, чтобы вычислить среднее значение поля внутри группы\n\nДля HTTP JSON-запросов использование одного `aggs` bucket с `limit=0` на уровне основного запроса работает аналогично SQL-запросу с `GROUP BY` и `COUNT(*)`, обеспечивая эквивалентное поведение и производительность.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_4\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_5\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_6\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_7\n\n<!-- request JSON -->\n\nCODE_BLOCK_8\n\n<!-- response JSON -->\n\nCODE_BLOCK_9\n\n<!-- request PHP -->\n\nCODE_BLOCK_10\n\n<!-- response PHP -->\n\nCODE_BLOCK_11\n\n<!-- request Python -->\n\nCODE_BLOCK_12\n\n<!-- response Python -->\n\nCODE_BLOCK_13\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_14\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_15\n\n<!-- request Javascript -->\n\nCODE_BLOCK_16\n\n<!-- response Javascript -->\n\nCODE_BLOCK_17\n\n<!-- request Java -->\n\nCODE_BLOCK_18\n\n<!-- response Java -->\n\nCODE_BLOCK_19\n\n<!-- request C# -->\n\nCODE_BLOCK_20\n\n<!-- response C# -->\n\nCODE_BLOCK_21\n\n<!-- request Rust -->\n\nCODE_BLOCK_22\n\n<!-- response Rust -->\n\nCODE_BLOCK_23\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_24\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_25\n\n<!-- request Go -->\n\nCODE_BLOCK_26\n\n<!-- response Go -->\n\nCODE_BLOCK_27\n\n<!-- end -->\n\n<!-- example sort1 -->\n\n##### Сортировка групп\n\nПо умолчанию группы не сортируются, и следующим шагом обычно является их упорядочивание по чему-то, например, по полю, по которому вы группируете:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_28\n\n<!-- response SQL -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n<!-- example sort2 -->\n\nИли вы можете сортировать по агрегату:\n\n* по `count(*)`, чтобы сначала отображать группы с наибольшим количеством элементов\n\n* по `avg(rental_rate)`, чтобы показывать фильмы с наивысшим рейтингом первыми. Обратите внимание, что в примере это сделано через псевдоним: `avg(rental_rate)` сначала сопоставляется с `avg` в списке `SELECT`, а затем мы просто делаем `ORDER BY avg`\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_30\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_31\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_32\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n<!-- example group3 -->\n\n##### GROUP BY по нескольким полям одновременно\n\nВ некоторых случаях вы можете захотеть группировать не только по одному полю, но и по нескольким сразу, например, по категории фильма и году:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_34\n\n<!-- response SQL -->\n\nCODE_BLOCK_35\n\n<!-- request JSON -->\n\nCODE_BLOCK_36\n\n<!-- response JSON -->\n\nCODE_BLOCK_37\n\n<!-- end -->\n\n<!-- example group4 -->\n\n##### Дайте мне N строк\n\nИногда полезно видеть не только один элемент на группу, а несколько. Это легко достигается с помощью `GROUP N BY`. Например, в следующем случае мы получаем два фильма для каждого года, а не только один, как вернул бы простой `GROUP BY release_year`.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_38\n\n<!-- response SQL -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example group5 -->\n\n##### Сортировка внутри группы\n\nЕще одно важное требование аналитики — сортировать элементы внутри группы. Для этого используйте конструкцию `WITHIN GROUP ORDER BY ... {ASC|DESC}`. Например, получим фильм с наивысшим рейтингом для каждого года. Обратите внимание, что это работает параллельно с обычным `ORDER BY`:\n\n* `WITHIN GROUP ORDER BY` сортирует результаты **внутри группы**\n\n* в то время как просто `GROUP BY` **сортирует сами группы**\n\nЭти два работают полностью независимо.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_40\n\n<!-- response SQL -->\n\nCODE_BLOCK_41\n\n<!-- end -->\n\n<!-- example group6 -->\n\n##### Фильтрация групп\n\n`HAVING expression` — полезное выражение для фильтрации групп. В то время как `WHERE` применяется до группировки, `HAVING` работает с группами. Например, оставим только те годы, когда средний рейтинг аренды фильмов за этот год был выше 3. Мы получаем только четыре года:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_42\n\n<!-- response SQL -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\nОбратите внимание, что `HAVING` не влияет на `total_found` в [метаинформации поискового запроса](../Node_info_and_management/SHOW_META.md#SHOW-META).\n\n<!-- example group7 -->\n\n##### GROUPBY()"
    },
    "is_code_or_comment": false
  },
  "78a82db0b5037b2fa9f9ca03667decb540e7c31fb332dc0937353aa3b651afa1": {
    "original": "There is a function `GROUPBY()` which returns the key of the current group. It's useful in many cases, especially when you [GROUP BY an MVA](../Searching/Grouping.md#Grouping-by-MVA-%28multi-value-attributes%29) or a [JSON value](../Searching/Grouping.md#Grouping-by-a-JSON-node).\n\nIt can also be used in `HAVING`, for example, to keep only years 2000 and 2002.\n\nNote that `GROUPBY()`is not recommended for use when you GROUP BY multiple fields at once. It will still work, but since the group key in this case is a compound of field values, it may not appear the way you expect.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_44\n\n<!-- response SQL -->\n\nCODE_BLOCK_45\n\n<!-- end -->\n\n<!-- example mva -->\n\n##### Grouping by MVA (multi-value attributes)\n\nManticore supports grouping by [MVA](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29). To demonstrate how it works, let's create a table \"shoes\" with MVA \"sizes\" and insert a few documents into it:\n\nCODE_BLOCK_46\n\nso we have:\n\nCODE_BLOCK_47\n\nIf we now GROUP BY \"sizes\", it will process all our multi-value attributes and return an aggregation for each, in this case just the count:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- response SQL -->\n\nCODE_BLOCK_49\n\n<!-- request JSON -->\n\nCODE_BLOCK_50\n\n<!-- response JSON -->\n\nCODE_BLOCK_51\n\n<!-- request PHP -->\n\nCODE_BLOCK_52\n\n<!-- response PHP -->\n\nCODE_BLOCK_53\n\n<!-- request Python -->\n\nCODE_BLOCK_54\n\n<!-- response Python -->\n\nCODE_BLOCK_55\n\n<!-- request Javascript -->\n\nCODE_BLOCK_56\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_57\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_58\n\n<!-- request Javascript -->\n\nCODE_BLOCK_59\n\n<!-- response Javascript -->\n\nCODE_BLOCK_60\n\n<!-- request Java -->\n\nCODE_BLOCK_61\n\n<!-- response Java -->\n\nCODE_BLOCK_62\n\n<!-- request C# -->\n\nCODE_BLOCK_63\n\n<!-- response C# -->\n\nCODE_BLOCK_64\n\n<!-- request Rust -->\n\nCODE_BLOCK_65\n\n<!-- response Rust -->\n\nCODE_BLOCK_66\n\nres = await searchApi.search({\n\n  index: 'test',\n\n  aggs: {\n\n    mva_agg: {\n\n      terms: { field: \"mva_field\", size: 2 }\n\n    }\n\n  }\n\n});\n\nCODE_BLOCK_67\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":4,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_68\n\nquery := map[string]interface{} {};\n\nsearchRequest.SetQuery(query);\n\naggTerms := manticoreclient.NewAggregationTerms()\n\naggTerms.SetField(\"mva_field\")\n\naggTerms.SetSize(2)\n\naggregation := manticoreclient.NewAggregation()\n\naggregation.setTerms(aggTerms)\n\nsearchRequest.SetAggregation(aggregation)\n\nres, _, _ := apiClient.SearchAPI.Search(context.Background()).SearchRequest(*searchRequest).Execute()\n\nCODE_BLOCK_69\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":5,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_70\n\ncreate table products(title text, meta json);\n\ninsert into products values(0,'nike','{\"color\":\"red\"}'),(0,'adidas','{\"color\":\"red\"}'),(0,'puma','{\"color\":\"green\"}');\n\nCODE_BLOCK_71\n\nSELECT * FROM products;\n\n+---------------------+-------------------+--------+\n\n| id                  | meta              | title  |\n\n+---------------------+-------------------+--------+\n\n| 1657851069130080268 | {\"color\":\"red\"}   | nike   |\n\n| 1657851069130080269 | {\"color\":\"red\"}   | adidas |\n\n| 1657851069130080270 | {\"color\":\"green\"} | puma   |\n\n+---------------------+-------------------+--------+\n\nCODE_BLOCK_72\n\nSELECT groupby() color, count(*) from products GROUP BY meta.color;\n\nCODE_BLOCK_73\n\n+-------+----------+\n\n| color | count(*) |\n\n+-------+----------+\n\n| red   |        2 |\n\n| green |        1 |\n\n+-------+----------+\n\nCODE_BLOCK_74\n\nPOST /search -d '\n\n    {\n\n     \"table\" : \"products\",\n\n     \"limit\": 0,\n\n     \"aggs\" :\n\n     {\n\n        \"color\" :\n\n         {\n\n            \"terms\" :\n\n             {\n\n              \"field\":\"meta.color\",\n\n              \"size\":100\n\n             }\n\n         }\n\n     }\n\n    }\n\n'\n\nCODE_BLOCK_75\n\n{\n\n  \"took\": 0,\n\n  \"timed_out\": false,\n\n  \"hits\": {\n\n    \"total\": 3,\n\n    \"hits\": [\n\n    ]\n\n  },\n\n  \"aggregations\": {\n\n    \"color\": {\n\n      \"buckets\": [\n\n        {\n\n          \"key\": \"green\",\n\n          \"doc_count\": 1\n\n        },\n\n        {\n\n          \"key\": \"red\",\n\n          \"doc_count\": 2\n\n        }\n\n      ]\n\n    }\n\n  }\n\n}\n\nCODE_BLOCK_76\n\n$index->setName('products');\n\n$search = $index->search('');\n\n$search->limit(0);\n\n$search->facet('meta.color','color',100);\n\n$results = $search->get();\n\nprint_r($results->getFacets());\n\nCODE_BLOCK_77\n\nArray\n\n(\n\n    [color] => Array\n\n        (\n\n            [buckets] => Array\n\n                (\n\n                    [0] => Array\n\n                        (\n\n                            [key] => green\n\n                            [doc_count] => 1\n\n                        )\n\n                    [1] => Array\n\n                        (\n\n                            [key] => red\n\n                            [doc_count] => 2\n\n                        )\n\n                )\n\n        )\n\n)\n\nCODE_BLOCK_78\n\nres =searchApi.search({\"table\":\"products\",\"limit\":0,\"aggs\":{\"color\":{\"terms\":{\"field\":\"meta.color\",\"size\":100}}}})\n\nCODE_BLOCK_79\n\n{'aggregations': {u'color': {u'buckets': [{u'doc_count': 1,\n\n                                           u'key': u'green'},\n\n                                          {u'doc_count': 2, u'key': u'red'}]}},\n\n 'hits': {'hits': [], 'max_score': None, 'total': 3},\n\n 'profile': None,\n\n 'timed_out': False,\n\n 'took': 0}\n\nCODE_BLOCK_80\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_81\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_82\n\n<!-- request Javascript -->\n\nCODE_BLOCK_83\n\n<!-- response Javascript -->\n\nCODE_BLOCK_84\n\n<!-- request Java -->\n\nCODE_BLOCK_85\n\n<!-- response Java -->\n\nCODE_BLOCK_86\n\n<!-- request C# -->\n\nCODE_BLOCK_87\n\n<!-- response C# -->\n\nCODE_BLOCK_88\n\n<!-- request Rust -->\n\nCODE_BLOCK_89\n\n<!-- response Rust -->\n\nCODE_BLOCK_90\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_91",
    "translations": {
      "chinese": "有一个函数 `GROUPBY()`，它返回当前分组的键。在许多情况下非常有用，特别是当你[按 MVA 分组](../Searching/Grouping.md#Grouping-by-MVA-%28multi-value-attributes%29)或按[JSON 值分组](../Searching/Grouping.md#Grouping-by-a-JSON-node)时。\n\n它也可以用于 `HAVING`，例如，只保留年份 2000 和 2002。\n\n注意，当你一次按多个字段进行 GROUP BY 时，不推荐使用 `GROUPBY()`。它仍然可以工作，但由于此时的分组键是字段值的复合，可能不会以你期望的方式出现。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_44\n\n<!-- response SQL -->\n\nCODE_BLOCK_45\n\n<!-- end -->\n\n<!-- example mva -->\n\n##### 按 MVA（多值属性）分组\n\nManticore 支持按[MVA](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29)分组。为了演示其工作原理，我们创建一个包含 MVA 字段 \"sizes\" 的表 \"shoes\"，并插入一些文档：\n\nCODE_BLOCK_46\n\n所以我们有：\n\nCODE_BLOCK_47\n\n如果现在按 \"sizes\" 进行 GROUP BY，它将处理所有多值属性，并为每个返回一个聚合，在此例中仅是计数：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- response SQL -->\n\nCODE_BLOCK_49\n\n<!-- request JSON -->\n\nCODE_BLOCK_50\n\n<!-- response JSON -->\n\nCODE_BLOCK_51\n\n<!-- request PHP -->\n\nCODE_BLOCK_52\n\n<!-- response PHP -->\n\nCODE_BLOCK_53\n\n<!-- request Python -->\n\nCODE_BLOCK_54\n\n<!-- response Python -->\n\nCODE_BLOCK_55\n\n<!-- request Javascript -->\n\nCODE_BLOCK_56\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_57\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_58\n\n<!-- request Javascript -->\n\nCODE_BLOCK_59\n\n<!-- response Javascript -->\n\nCODE_BLOCK_60\n\n<!-- request Java -->\n\nCODE_BLOCK_61\n\n<!-- response Java -->\n\nCODE_BLOCK_62\n\n<!-- request C# -->\n\nCODE_BLOCK_63\n\n<!-- response C# -->\n\nCODE_BLOCK_64\n\n<!-- request Rust -->\n\nCODE_BLOCK_65\n\n<!-- response Rust -->\n\nCODE_BLOCK_66\n\nres = await searchApi.search({\n\n  index: 'test',\n\n  aggs: {\n\n    mva_agg: {\n\n      terms: { field: \"mva_field\", size: 2 }\n\n    }\n\n  }\n\n});\n\nCODE_BLOCK_67\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":4,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_68\n\nquery := map[string]interface{} {};\n\nsearchRequest.SetQuery(query);\n\naggTerms := manticoreclient.NewAggregationTerms()\n\naggTerms.SetField(\"mva_field\")\n\naggTerms.SetSize(2)\n\naggregation := manticoreclient.NewAggregation()\n\naggregation.setTerms(aggTerms)\n\nsearchRequest.SetAggregation(aggregation)\n\nres, _, _ := apiClient.SearchAPI.Search(context.Background()).SearchRequest(*searchRequest).Execute()\n\nCODE_BLOCK_69\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":5,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_70\n\ncreate table products(title text, meta json);\n\ninsert into products values(0,'nike','{\"color\":\"red\"}'),(0,'adidas','{\"color\":\"red\"}'),(0,'puma','{\"color\":\"green\"}');\n\nCODE_BLOCK_71\n\nSELECT * FROM products;\n\n+---------------------+-------------------+--------+\n\n| id                  | meta              | title  |\n\n+---------------------+-------------------+--------+\n\n| 1657851069130080268 | {\"color\":\"red\"}   | nike   |\n\n| 1657851069130080269 | {\"color\":\"red\"}   | adidas |\n\n| 1657851069130080270 | {\"color\":\"green\"} | puma   |\n\n+---------------------+-------------------+--------+\n\nCODE_BLOCK_72\n\nSELECT groupby() color, count(*) from products GROUP BY meta.color;\n\nCODE_BLOCK_73\n\n+-------+----------+\n\n| color | count(*) |\n\n+-------+----------+\n\n| red   |        2 |\n\n| green |        1 |\n\n+-------+----------+\n\nCODE_BLOCK_74\n\nPOST /search -d '\n\n    {\n\n     \"table\" : \"products\",\n\n     \"limit\": 0,\n\n     \"aggs\" :\n\n     {\n\n        \"color\" :\n\n         {\n\n            \"terms\" :\n\n             {\n\n              \"field\":\"meta.color\",\n\n              \"size\":100\n\n             }\n\n         }\n\n     }\n\n    }\n\n'\n\nCODE_BLOCK_75\n\n{\n\n  \"took\": 0,\n\n  \"timed_out\": false,\n\n  \"hits\": {\n\n    \"total\": 3,\n\n    \"hits\": [\n\n    ]\n\n  },\n\n  \"aggregations\": {\n\n    \"color\": {\n\n      \"buckets\": [\n\n        {\n\n          \"key\": \"green\",\n\n          \"doc_count\": 1\n\n        },\n\n        {\n\n          \"key\": \"red\",\n\n          \"doc_count\": 2\n\n        }\n\n      ]\n\n    }\n\n  }\n\n}\n\nCODE_BLOCK_76\n\n$index->setName('products');\n\n$search = $index->search('');\n\n$search->limit(0);\n\n$search->facet('meta.color','color',100);\n\n$results = $search->get();\n\nprint_r($results->getFacets());\n\nCODE_BLOCK_77\n\nArray\n\n(\n\n    [color] => Array\n\n        (\n\n            [buckets] => Array\n\n                (\n\n                    [0] => Array\n\n                        (\n\n                            [key] => green\n\n                            [doc_count] => 1\n\n                        )\n\n                    [1] => Array\n\n                        (\n\n                            [key] => red\n\n                            [doc_count] => 2\n\n                        )\n\n                )\n\n        )\n\n)\n\nCODE_BLOCK_78\n\nres =searchApi.search({\"table\":\"products\",\"limit\":0,\"aggs\":{\"color\":{\"terms\":{\"field\":\"meta.color\",\"size\":100}}}})\n\nCODE_BLOCK_79\n\n{'aggregations': {u'color': {u'buckets': [{u'doc_count': 1,\n\n                                           u'key': u'green'},\n\n                                          {u'doc_count': 2, u'key': u'red'}]}},\n\n 'hits': {'hits': [], 'max_score': None, 'total': 3},\n\n 'profile': None,\n\n 'timed_out': False,\n\n 'took': 0}\n\nCODE_BLOCK_80\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_81\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_82\n\n<!-- request Javascript -->\n\nCODE_BLOCK_83\n\n<!-- response Javascript -->\n\nCODE_BLOCK_84\n\n<!-- request Java -->\n\nCODE_BLOCK_85\n\n<!-- response Java -->\n\nCODE_BLOCK_86\n\n<!-- request C# -->\n\nCODE_BLOCK_87\n\n<!-- response C# -->\n\nCODE_BLOCK_88\n\n<!-- request Rust -->\n\nCODE_BLOCK_89\n\n<!-- response Rust -->\n\nCODE_BLOCK_90\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_91",
      "russian": "Есть функция `GROUPBY()`, которая возвращает ключ текущей группы. Она полезна во многих случаях, особенно когда вы [GROUP BY по MVA](../Searching/Grouping.md#Grouping-by-MVA-%28multi-value-attributes%29) или по [JSON значению](../Searching/Grouping.md#Grouping-by-a-JSON-node).\n\nЕё также можно использовать в `HAVING`, например, чтобы оставить только годы 2000 и 2002.\n\nОбратите внимание, что `GROUPBY()` не рекомендуется использовать, когда вы GROUP BY по нескольким полям одновременно. Она всё равно будет работать, но поскольку ключ группы в этом случае является составным из значений полей, он может не отображаться так, как вы ожидаете.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_44\n\n<!-- response SQL -->\n\nCODE_BLOCK_45\n\n<!-- end -->\n\n<!-- example mva -->\n\n##### Группировка по MVA (мультизначным атрибутам)\n\nManticore поддерживает группировку по [MVA](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29). Чтобы показать, как это работает, давайте создадим таблицу \"shoes\" с MVA \"sizes\" и вставим в неё несколько документов:\n\nCODE_BLOCK_46\n\nтак что у нас есть:\n\nCODE_BLOCK_47\n\nЕсли теперь мы сделаем GROUP BY по \"sizes\", он обработает все наши мультизначные атрибуты и вернёт агрегацию для каждого, в данном случае просто количество:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- response SQL -->\n\nCODE_BLOCK_49\n\n<!-- request JSON -->\n\nCODE_BLOCK_50\n\n<!-- response JSON -->\n\nCODE_BLOCK_51\n\n<!-- request PHP -->\n\nCODE_BLOCK_52\n\n<!-- response PHP -->\n\nCODE_BLOCK_53\n\n<!-- request Python -->\n\nCODE_BLOCK_54\n\n<!-- response Python -->\n\nCODE_BLOCK_55\n\n<!-- request Javascript -->\n\nCODE_BLOCK_56\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_57\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_58\n\n<!-- request Javascript -->\n\nCODE_BLOCK_59\n\n<!-- response Javascript -->\n\nCODE_BLOCK_60\n\n<!-- request Java -->\n\nCODE_BLOCK_61\n\n<!-- response Java -->\n\nCODE_BLOCK_62\n\n<!-- request C# -->\n\nCODE_BLOCK_63\n\n<!-- response C# -->\n\nCODE_BLOCK_64\n\n<!-- request Rust -->\n\nCODE_BLOCK_65\n\n<!-- response Rust -->\n\nCODE_BLOCK_66\n\nres = await searchApi.search({\n\n  index: 'test',\n\n  aggs: {\n\n    mva_agg: {\n\n      terms: { field: \"mva_field\", size: 2 }\n\n    }\n\n  }\n\n});\n\nCODE_BLOCK_67\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":4,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_68\n\nquery := map[string]interface{} {};\n\nsearchRequest.SetQuery(query);\n\naggTerms := manticoreclient.NewAggregationTerms()\n\naggTerms.SetField(\"mva_field\")\n\naggTerms.SetSize(2)\n\naggregation := manticoreclient.NewAggregation()\n\naggregation.setTerms(aggTerms)\n\nsearchRequest.SetAggregation(aggregation)\n\nres, _, _ := apiClient.SearchAPI.Search(context.Background()).SearchRequest(*searchRequest).Execute()\n\nCODE_BLOCK_69\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":5,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_70\n\ncreate table products(title text, meta json);\n\ninsert into products values(0,'nike','{\"color\":\"red\"}'),(0,'adidas','{\"color\":\"red\"}'),(0,'puma','{\"color\":\"green\"}');\n\nCODE_BLOCK_71\n\nSELECT * FROM products;\n\n+---------------------+-------------------+--------+\n\n| id                  | meta              | title  |\n\n+---------------------+-------------------+--------+\n\n| 1657851069130080268 | {\"color\":\"red\"}   | nike   |\n\n| 1657851069130080269 | {\"color\":\"red\"}   | adidas |\n\n| 1657851069130080270 | {\"color\":\"green\"} | puma   |\n\n+---------------------+-------------------+--------+\n\nCODE_BLOCK_72\n\nSELECT groupby() color, count(*) from products GROUP BY meta.color;\n\nCODE_BLOCK_73\n\n+-------+----------+\n\n| color | count(*) |\n\n+-------+----------+\n\n| red   |        2 |\n\n| green |        1 |\n\n+-------+----------+\n\nCODE_BLOCK_74\n\nPOST /search -d '\n\n    {\n\n     \"table\" : \"products\",\n\n     \"limit\": 0,\n\n     \"aggs\" :\n\n     {\n\n        \"color\" :\n\n         {\n\n            \"terms\" :\n\n             {\n\n              \"field\":\"meta.color\",\n\n              \"size\":100\n\n             }\n\n         }\n\n     }\n\n    }\n\n'\n\nCODE_BLOCK_75\n\n{\n\n  \"took\": 0,\n\n  \"timed_out\": false,\n\n  \"hits\": {\n\n    \"total\": 3,\n\n    \"hits\": [\n\n    ]\n\n  },\n\n  \"aggregations\": {\n\n    \"color\": {\n\n      \"buckets\": [\n\n        {\n\n          \"key\": \"green\",\n\n          \"doc_count\": 1\n\n        },\n\n        {\n\n          \"key\": \"red\",\n\n          \"doc_count\": 2\n\n        }\n\n      ]\n\n    }\n\n  }\n\n}\n\nCODE_BLOCK_76\n\n$index->setName('products');\n\n$search = $index->search('');\n\n$search->limit(0);\n\n$search->facet('meta.color','color',100);\n\n$results = $search->get();\n\nprint_r($results->getFacets());\n\nCODE_BLOCK_77\n\nArray\n\n(\n\n    [color] => Array\n\n        (\n\n            [buckets] => Array\n\n                (\n\n                    [0] => Array\n\n                        (\n\n                            [key] => green\n\n                            [doc_count] => 1\n\n                        )\n\n                    [1] => Array\n\n                        (\n\n                            [key] => red\n\n                            [doc_count] => 2\n\n                        )\n\n                )\n\n        )\n\n)\n\nCODE_BLOCK_78\n\nres =searchApi.search({\"table\":\"products\",\"limit\":0,\"aggs\":{\"color\":{\"terms\":{\"field\":\"meta.color\",\"size\":100}}}})\n\nCODE_BLOCK_79\n\n{'aggregations': {u'color': {u'buckets': [{u'doc_count': 1,\n\n                                           u'key': u'green'},\n\n                                          {u'doc_count': 2, u'key': u'red'}]}},\n\n 'hits': {'hits': [], 'max_score': None, 'total': 3},\n\n 'profile': None,\n\n 'timed_out': False,\n\n 'took': 0}\n\nCODE_BLOCK_80\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_81\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_82\n\n<!-- request Javascript -->\n\nCODE_BLOCK_83\n\n<!-- response Javascript -->\n\nCODE_BLOCK_84\n\n<!-- request Java -->\n\nCODE_BLOCK_85\n\n<!-- response Java -->\n\nCODE_BLOCK_86\n\n<!-- request C# -->\n\nCODE_BLOCK_87\n\n<!-- response C# -->\n\nCODE_BLOCK_88\n\n<!-- request Rust -->\n\nCODE_BLOCK_89\n\n<!-- response Rust -->\n\nCODE_BLOCK_90\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_91"
    },
    "is_code_or_comment": false
  }
}
