{
  "1488d87346b8d56362461229f83245f6942de2d2bb8a2bbef7ee94eeabc22531": {
    "original": "<!-- response TypeScript -->\n\nCODE_BLOCK_92\n\n<!-- request Go -->\n\nCODE_BLOCK_93\n\n<!-- response Go -->\n\nCODE_BLOCK_94\n\n<!-- end -->\n\n## Aggregation functions\n\nBesides `COUNT(*)`, which returns the number of elements in each group, you can use various other aggregation functions:\n\n<!-- example distinct -->\n\n##### COUNT(DISTINCT field)\n\nWhile `COUNT(*)` returns the number of all elements in the group, `COUNT(DISTINCT field)` returns the number of unique values of the field in the group, which may be completely different from the total count. For instance, you can have 100 elements in the group, but all with the same value for a certain field. `COUNT(DISTINCT field)` helps to determine that. To demonstrate this, let's create a table \"students\" with the student's name, age, and major:\n\nCODE_BLOCK_95\n\nso we have:\n\nCODE_BLOCK_96\n\nIn the example, you can see that if we GROUP BY major and display both `COUNT(*)` and `COUNT(DISTINCT age)`, it becomes clear that there are two students who chose the major \"cs\" with two unique ages, but for the major \"arts\", there are also two students, yet only one unique age.\n\nThere can be at most one `COUNT(DISTINCT)` per query.\n\n** By default, counts are approximate **\n\nActually, some of them are exact, while others are approximate. More on that below.\n\nManticore supports two algorithms for computing counts of distinct values. One is a legacy algorithm that uses a lot of memory and is usually slow. It collects `{group; value}` pairs, sorts them, and periodically discards duplicates. The benefit of this approach is that it guarantees exact counts within a plain table. You can enable it by setting the [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) option to `0`.\n\nThe other algorithm (enabled by default) loads counts into a hash table and returns its size. If the hash table becomes too large, its contents are moved into a `HyperLogLog`. This is where the counts become approximate since `HyperLogLog` is a probabilistic algorithm. The advantage is that the maximum memory usage per group is fixed and depends on the accuracy of the `HyperLogLog`. The overall memory usage also depends on the [max_matches](../Searching/Options.md#max_matches) setting, which reflects the number of groups.\n\nThe [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) option sets the threshold below which counts are guaranteed to be exact. The `HyperLogLog` accuracy setting and the threshold for the \"hash table to HyperLogLog\" conversion are derived from this setting. It's important to use this option with caution because doubling it will double the maximum memory required for count calculations. The maximum memory usage can be roughly estimated using this formula: `64 * max_matches * distinct_precision_threshold`. Note that this is the worst-case scenario, and in most cases, count calculations will use significantly less RAM.\n\n**`COUNT(DISTINCT)` against a distributed table or a real-time table consisting of multiple disk chunks may return inaccurate results**, but the result should be accurate for a distributed table consisting of local plain or real-time tables with the same schema (identical set/order of fields, but may have different tokenization settings).\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_97\n\n<!-- response SQL -->\n\nCODE_BLOCK_98\n\n<!-- end -->\n\n<!-- example concat -->\n\n##### GROUP_CONCAT(field)\n\nOften, you want to better understand the contents of each group. You can use [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) for that, but it would return additional rows you might not want in the output. `GROUP_CONCAT()` enriches your grouping by concatenating values of a specific field in the group. Let's take the previous example and improve it by displaying all the ages in each group.\n\n`GROUP_CONCAT(field)` returns the list as comma-separated values.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_99\n\n<!-- response SQL -->\n\nCODE_BLOCK_100\n\n<!-- end -->\n\n<!-- example sum -->\n\n##### SUM(), MIN(), MAX(), AVG()\n\nOf course, you can also obtain the sum, average, minimum, and maximum values within a group.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_101\n\n<!-- response SQL -->\n\nCODE_BLOCK_102\n\n<!-- end -->\n\n<!-- example accuracy -->\n\n## Grouping accuracy\n\nGrouping is done in fixed memory, which depends on the [max_matches](../Searching/Options.md#max_matches) setting. If `max_matches` allows for storage of all found groups, the results will be 100% accurate. However, if the value of `max_matches` is lower, the results will be less accurate.\n\nWhen parallel processing is involved, it can become more complicated. When `pseudo_sharding` is enabled and/or when using an RT table with several disk chunks, each chunk or pseudo shard gets a result set that is no larger than `max_matches`. This can lead to inaccuracies in aggregates and group counts when the result sets from different threads are merged. To fix this, either a larger `max_matches` value or disabling parallel processing can be used.\n\nManticore will try to increase `max_matches` up to [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold) if it detects that groupby may return inaccurate results. Detection is based on the number of unique values of the groupby attribute, which is retrieved from secondary indexes (if present).\n\nTo ensure accurate aggregates and/or group counts when using RT tables or `pseudo_sharding`, `accurate_aggregation` can be enabled. This will try to increase `max_matches` up to the threshold, and if the threshold is not high enough, Manticore will disable parallel processing for the query.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_103\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "<!-- response TypeScript -->\n\nCODE_BLOCK_92\n\n<!-- request Go -->\n\nCODE_BLOCK_93\n\n<!-- response Go -->\n\nCODE_BLOCK_94\n\n<!-- end -->\n\n## Aggregation functions\n\nBesides `COUNT(*)`, which returns the number of elements in each group, you can use various other aggregation functions:\n\n<!-- example distinct -->\n\n##### COUNT(DISTINCT field)\n\nWhile `COUNT(*)` returns the number of all elements in the group, `COUNT(DISTINCT field)` returns the number of unique values of the field in the group, which may be completely different from the total count. For instance, you can have 100 elements in the group, but all with the same value for a certain field. `COUNT(DISTINCT field)` helps to determine that. To demonstrate this, let's create a table \"students\" with the student's name, age, and major:\n\nCODE_BLOCK_95\n\nso we have:\n\nCODE_BLOCK_96\n\nIn the example, you can see that if we GROUP BY major and display both `COUNT(*)` and `COUNT(DISTINCT age)`, it becomes clear that there are two students who chose the major \"cs\" with two unique ages, but for the major \"arts\", there are also two students, yet only one unique age.\n\nThere can be at most one `COUNT(DISTINCT)` per query.\n\n** By default, counts are approximate **\n\nActually, some of them are exact, while others are approximate. More on that below.\n\nManticore supports two algorithms for computing counts of distinct values. One is a legacy algorithm that uses a lot of memory and is usually slow. It collects `{group; value}` pairs, sorts them, and periodically discards duplicates. The benefit of this approach is that it guarantees exact counts within a plain table. You can enable it by setting the [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) option to `0`.\n\nThe other algorithm (enabled by default) loads counts into a hash table and returns its size. If the hash table becomes too large, its contents are moved into a `HyperLogLog`. This is where the counts become approximate since `HyperLogLog` is a probabilistic algorithm. The advantage is that the maximum memory usage per group is fixed and depends on the accuracy of the `HyperLogLog`. The overall memory usage also depends on the [max_matches](../Searching/Options.md#max_matches) setting, which reflects the number of groups.\n\nThe [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) option sets the threshold below which counts are guaranteed to be exact. The `HyperLogLog` accuracy setting and the threshold for the \"hash table to HyperLogLog\" conversion are derived from this setting. It's important to use this option with caution because doubling it will double the maximum memory required for count calculations. The maximum memory usage can be roughly estimated using this formula: `64 * max_matches * distinct_precision_threshold`. Note that this is the worst-case scenario, and in most cases, count calculations will use significantly less RAM.\n\n**`COUNT(DISTINCT)` against a distributed table or a real-time table consisting of multiple disk chunks may return inaccurate results**, but the result should be accurate for a distributed table consisting of local plain or real-time tables with the same schema (identical set/order of fields, but may have different tokenization settings).\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_97\n\n<!-- response SQL -->\n\nCODE_BLOCK_98\n\n<!-- end -->\n\n<!-- example concat -->\n\n##### GROUP_CONCAT(field)\n\nOften, you want to better understand the contents of each group. You can use [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) for that, but it would return additional rows you might not want in the output. `GROUP_CONCAT()` enriches your grouping by concatenating values of a specific field in the group. Let's take the previous example and improve it by displaying all the ages in each group.\n\n`GROUP_CONCAT(field)` returns the list as comma-separated values.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_99\n\n<!-- response SQL -->\n\nCODE_BLOCK_100\n\n<!-- end -->\n\n<!-- example sum -->\n\n##### SUM(), MIN(), MAX(), AVG()\n\nOf course, you can also obtain the sum, average, minimum, and maximum values within a group.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_101\n\n<!-- response SQL -->\n\nCODE_BLOCK_102\n\n<!-- end -->\n\n<!-- example accuracy -->\n\n## Grouping accuracy\n\nGrouping is done in fixed memory, which depends on the [max_matches](../Searching/Options.md#max_matches) setting. If `max_matches` allows for storage of all found groups, the results will be 100% accurate. However, if the value of `max_matches` is lower, the results will be less accurate.\n\nWhen parallel processing is involved, it can become more complicated. When `pseudo_sharding` is enabled and/or when using an RT table with several disk chunks, each chunk or pseudo shard gets a result set that is no larger than `max_matches`. This can lead to inaccuracies in aggregates and group counts when the result sets from different threads are merged. To fix this, either a larger `max_matches` value or disabling parallel processing can be used.\n\nManticore will try to increase `max_matches` up to [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold) if it detects that groupby may return inaccurate results. Detection is based on the number of unique values of the groupby attribute, which is retrieved from secondary indexes (if present).\n\nTo ensure accurate aggregates and/or group counts when using RT tables or `pseudo_sharding`, `accurate_aggregation` can be enabled. This will try to increase `max_matches` up to the threshold, and if the threshold is not high enough, Manticore will disable parallel processing for the query.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_103\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "<!-- response TypeScript -->\n\nCODE_BLOCK_92\n\n<!-- request Go -->\n\nCODE_BLOCK_93\n\n<!-- response Go -->\n\nCODE_BLOCK_94\n\n<!-- end -->\n\n## Aggregation functions\n\nBesides `COUNT(*)`, which returns the number of elements in each group, you can use various other aggregation functions:\n\n<!-- example distinct -->\n\n##### COUNT(DISTINCT field)\n\nWhile `COUNT(*)` returns the number of all elements in the group, `COUNT(DISTINCT field)` returns the number of unique values of the field in the group, which may be completely different from the total count. For instance, you can have 100 elements in the group, but all with the same value for a certain field. `COUNT(DISTINCT field)` helps to determine that. To demonstrate this, let's create a table \"students\" with the student's name, age, and major:\n\nCODE_BLOCK_95\n\nso we have:\n\nCODE_BLOCK_96\n\nIn the example, you can see that if we GROUP BY major and display both `COUNT(*)` and `COUNT(DISTINCT age)`, it becomes clear that there are two students who chose the major \"cs\" with two unique ages, but for the major \"arts\", there are also two students, yet only one unique age.\n\nThere can be at most one `COUNT(DISTINCT)` per query.\n\n** By default, counts are approximate **\n\nActually, some of them are exact, while others are approximate. More on that below.\n\nManticore supports two algorithms for computing counts of distinct values. One is a legacy algorithm that uses a lot of memory and is usually slow. It collects `{group; value}` pairs, sorts them, and periodically discards duplicates. The benefit of this approach is that it guarantees exact counts within a plain table. You can enable it by setting the [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) option to `0`.\n\nThe other algorithm (enabled by default) loads counts into a hash table and returns its size. If the hash table becomes too large, its contents are moved into a `HyperLogLog`. This is where the counts become approximate since `HyperLogLog` is a probabilistic algorithm. The advantage is that the maximum memory usage per group is fixed and depends on the accuracy of the `HyperLogLog`. The overall memory usage also depends on the [max_matches](../Searching/Options.md#max_matches) setting, which reflects the number of groups.\n\nThe [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) option sets the threshold below which counts are guaranteed to be exact. The `HyperLogLog` accuracy setting and the threshold for the \"hash table to HyperLogLog\" conversion are derived from this setting. It's important to use this option with caution because doubling it will double the maximum memory required for count calculations. The maximum memory usage can be roughly estimated using this formula: `64 * max_matches * distinct_precision_threshold`. Note that this is the worst-case scenario, and in most cases, count calculations will use significantly less RAM.\n\n**`COUNT(DISTINCT)` against a distributed table or a real-time table consisting of multiple disk chunks may return inaccurate results**, but the result should be accurate for a distributed table consisting of local plain or real-time tables with the same schema (identical set/order of fields, but may have different tokenization settings).\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_97\n\n<!-- response SQL -->\n\nCODE_BLOCK_98\n\n<!-- end -->\n\n<!-- example concat -->\n\n##### GROUP_CONCAT(field)\n\nOften, you want to better understand the contents of each group. You can use [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) for that, but it would return additional rows you might not want in the output. `GROUP_CONCAT()` enriches your grouping by concatenating values of a specific field in the group. Let's take the previous example and improve it by displaying all the ages in each group.\n\n`GROUP_CONCAT(field)` returns the list as comma-separated values.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_99\n\n<!-- response SQL -->\n\nCODE_BLOCK_100\n\n<!-- end -->\n\n<!-- example sum -->\n\n##### SUM(), MIN(), MAX(), AVG()\n\nOf course, you can also obtain the sum, average, minimum, and maximum values within a group.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_101\n\n<!-- response SQL -->\n\nCODE_BLOCK_102\n\n<!-- end -->\n\n<!-- example accuracy -->\n\n## Grouping accuracy\n\nGrouping is done in fixed memory, which depends on the [max_matches](../Searching/Options.md#max_matches) setting. If `max_matches` allows for storage of all found groups, the results will be 100% accurate. However, if the value of `max_matches` is lower, the results will be less accurate.\n\nWhen parallel processing is involved, it can become more complicated. When `pseudo_sharding` is enabled and/or when using an RT table with several disk chunks, each chunk or pseudo shard gets a result set that is no larger than `max_matches`. This can lead to inaccuracies in aggregates and group counts when the result sets from different threads are merged. To fix this, either a larger `max_matches` value or disabling parallel processing can be used.\n\nManticore will try to increase `max_matches` up to [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold) if it detects that groupby may return inaccurate results. Detection is based on the number of unique values of the groupby attribute, which is retrieved from secondary indexes (if present).\n\nTo ensure accurate aggregates and/or group counts when using RT tables or `pseudo_sharding`, `accurate_aggregation` can be enabled. This will try to increase `max_matches` up to the threshold, and if the threshold is not high enough, Manticore will disable parallel processing for the query.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_103\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": true
  },
  "33a62fad63e0639f879c04a221a6e46f18af5d32dbd1ea2596792c82b52b242a": {
    "original": "# Grouping search results\n\n<!-- example general -->\n\nGrouping search results is often helpful for obtaining per-group match counts or other aggregations. For example, it's useful for creating a graph illustrating the number of matching blog posts per month or grouping web search results by site or forum posts by author, etc.\n\nManticore supports the grouping of search results by single or multiple columns and computed expressions. The results can:\n\n* Be sorted within a group\n\n* Return more than one row per group\n\n* Have groups filtered\n\n* Have groups sorted\n\n* Be aggregated using the [aggregation functions](../Searching/Grouping.md#Aggregation-functions)\n\n<!-- intro -->\n\nThe general syntax is:\n\n<!-- request SQL -->\n\nGeneral syntax\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nJSON query format currently supports a basic grouping that can retrieve aggregate values and their count(*).\n\nCODE_BLOCK_1\n\nThe standard query output returns the result set without grouping, which can be hidden using `limit` (or `size`).\n\nThe aggregation requires setting a `size` for the group's result set size.\n\n<!-- end -->\n\n<!-- example group1 -->\n\n### Just Grouping\n\nGrouping is quite simple - just add \"GROUP BY smth\" to the end of your `SELECT` query. The something can be:\n\n* Any non-full-text field from the table: integer, float, string, MVA (multi-value attribute)\n\n* Or, if you used an alias in the `SELECT` list, you can GROUP BY it too\n\nYou can omit any [aggregation functions](../Searching/Grouping.md#Aggregation-functions) in the `SELECT` list and it will still work:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- example group2 -->\n\nIn most cases, however, you'll want to obtain some aggregated data for each group, such as:\n\n* `COUNT(*)` to simply get the number of elements in each group\n\n* or `AVG(field)` to calculate the average value of the field within the group\n\nFor HTTP JSON requests, using a single `aggs` bucket with `limit=0` at the main query level works similarly to a SQL query with `GROUP BY` and `COUNT(*)`, providing equivalent behavior and performance.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_4\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_5\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_6\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_7\n\n<!-- request JSON -->\n\nCODE_BLOCK_8\n\n<!-- response JSON -->\n\nCODE_BLOCK_9\n\n<!-- request PHP -->\n\nCODE_BLOCK_10\n\n<!-- response PHP -->\n\nCODE_BLOCK_11\n\n<!-- request Python -->\n\nCODE_BLOCK_12\n\n<!-- response Python -->\n\nCODE_BLOCK_13\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_14\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_15\n\n<!-- request Javascript -->\n\nCODE_BLOCK_16\n\n<!-- response Javascript -->\n\nCODE_BLOCK_17\n\n<!-- request Java -->\n\nCODE_BLOCK_18\n\n<!-- response Java -->\n\nCODE_BLOCK_19\n\n<!-- request C# -->\n\nCODE_BLOCK_20\n\n<!-- response C# -->\n\nCODE_BLOCK_21\n\n<!-- request Rust -->\n\nCODE_BLOCK_22\n\n<!-- response Rust -->\n\nCODE_BLOCK_23\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_24\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_25\n\n<!-- request Go -->\n\nCODE_BLOCK_26\n\n<!-- response Go -->\n\nCODE_BLOCK_27\n\n<!-- end -->\n\n<!-- example sort1 -->\n\n##### Sorting groups\n\nBy default, groups are not sorted, and the next thing you typically want to do is order them by something, like the field you're grouping by:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_28\n\n<!-- response SQL -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n<!-- example sort2 -->\n\nAlternatively, you can sort by the aggregation:\n\n* by `count(*)` to display groups with the most elements first\n\n* by `avg(rental_rate)` to show the highest-rated movies first. Note that in the example, it's done via an alias: `avg(rental_rate)` is first mapped to `avg` in the `SELECT` list, and then we simply do `ORDER BY avg`\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_30\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_31\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_32\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n<!-- example group3 -->\n\n##### GROUP BY multiple fields at once\n\nIn some cases, you might want to group not just by a single field, but by multiple fields at once, such as a movie's category and year:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_34\n\n<!-- response SQL -->\n\nCODE_BLOCK_35\n\n<!-- request JSON -->\n\nCODE_BLOCK_36\n\n<!-- response JSON -->\n\nCODE_BLOCK_37\n\n<!-- end -->\n\n<!-- example group4 -->\n\n##### Give me N rows\n\nSometimes it's useful to see not just a single element per group, but multiple. This can be easily achieved with the help of `GROUP N BY`. For example, in the following case, we get two movies for each year rather than just one, which a simple `GROUP BY release_year` would have returned.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_38\n\n<!-- response SQL -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example group5 -->\n\n##### Sorting inside a group\n\nAnother crucial analytics requirement is to sort elements within a group. To achieve this, use the `WITHIN GROUP ORDER BY ... {ASC|DESC}` clause. For example, let's get the highest-rated film for each year. Note that it works in parallel with just `ORDER BY`:\n\n* `WITHIN GROUP ORDER BY` sorts results **inside a group**\n\n* while just `GROUP BY` **sorts the groups themselves**\n\nThese two work entirely independently.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_40\n\n<!-- response SQL -->\n\nCODE_BLOCK_41\n\n<!-- end -->\n\n<!-- example group6 -->\n\n##### Filter groups\n\n`HAVING expression` is a helpful clause for filtering groups. While `WHERE` is applied before grouping, `HAVING` works with the groups. For example, let's keep only those years when the average rental rate of the films for that year was higher than 3. We get only four years:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_42\n\n<!-- response SQL -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\nNote that `HAVING` does not affect `total_found` in the [search query meta info](../Node_info_and_management/SHOW_META.md#SHOW-META).\n\n<!-- example group7 -->\n\n##### GROUPBY()",
    "translations": {
      "chinese": "# 分组搜索结果\n\n<!-- example general -->\n\n分组搜索结果通常有助于获取每组的匹配计数或其他聚合。例如，它对于创建每月匹配博客文章数量的图表，或按网站分组网页搜索结果，或按作者分组论坛帖子等非常有用。\n\nManticore 支持按单列或多列以及计算表达式对搜索结果进行分组。结果可以：\n\n* 在组内排序\n\n* 每组返回多行\n\n* 过滤组\n\n* 对组进行排序\n\n* 使用[聚合函数](../Searching/Grouping.md#Aggregation-functions)进行聚合\n\n<!-- intro -->\n\n通用语法是：\n\n<!-- request SQL -->\n\n通用语法\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nJSON 查询格式目前支持基本分组，可以检索聚合值及其 count(*)。\n\nCODE_BLOCK_1\n\n标准查询输出返回未分组的结果集，可以使用 `limit`（或 `size`）隐藏。\n\n聚合需要设置组结果集的 `size`。\n\n<!-- end -->\n\n<!-- example group1 -->\n\n### 仅分组\n\n分组非常简单——只需在 `SELECT` 查询末尾添加 \"GROUP BY smth\"。这里的某物可以是：\n\n* 表中的任何非全文字段：整数、浮点数、字符串、多值属性（MVA）\n\n* 或者，如果你在 `SELECT` 列表中使用了别名，也可以按别名分组\n\n你可以省略 `SELECT` 列表中的任何[聚合函数](../Searching/Grouping.md#Aggregation-functions)，它仍然有效：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- example group2 -->\n\n然而，在大多数情况下，你会想为每个组获取一些聚合数据，例如：\n\n* `COUNT(*)` 用于简单获取每组中的元素数量\n\n* 或者 `AVG(field)` 用于计算组内字段的平均值\n\n对于 HTTP JSON 请求，使用单个带有 `limit=0` 的 `aggs` 桶，在主查询级别，效果类似于带有 `GROUP BY` 和 `COUNT(*)` 的 SQL 查询，提供等效的行为和性能。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_4\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_5\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_6\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_7\n\n<!-- request JSON -->\n\nCODE_BLOCK_8\n\n<!-- response JSON -->\n\nCODE_BLOCK_9\n\n<!-- request PHP -->\n\nCODE_BLOCK_10\n\n<!-- response PHP -->\n\nCODE_BLOCK_11\n\n<!-- request Python -->\n\nCODE_BLOCK_12\n\n<!-- response Python -->\n\nCODE_BLOCK_13\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_14\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_15\n\n<!-- request Javascript -->\n\nCODE_BLOCK_16\n\n<!-- response Javascript -->\n\nCODE_BLOCK_17\n\n<!-- request Java -->\n\nCODE_BLOCK_18\n\n<!-- response Java -->\n\nCODE_BLOCK_19\n\n<!-- request C# -->\n\nCODE_BLOCK_20\n\n<!-- response C# -->\n\nCODE_BLOCK_21\n\n<!-- request Rust -->\n\nCODE_BLOCK_22\n\n<!-- response Rust -->\n\nCODE_BLOCK_23\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_24\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_25\n\n<!-- request Go -->\n\nCODE_BLOCK_26\n\n<!-- response Go -->\n\nCODE_BLOCK_27\n\n<!-- end -->\n\n<!-- example sort1 -->\n\n##### 对组进行排序\n\n默认情况下，组不排序，接下来你通常想做的是按某个字段排序，比如你分组所用的字段：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_28\n\n<!-- response SQL -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n<!-- example sort2 -->\n\n或者，你可以按聚合排序：\n\n* 按 `count(*)` 显示元素最多的组优先\n\n* 按 `avg(rental_rate)` 显示评分最高的电影优先。注意示例中是通过别名完成的：`avg(rental_rate)` 首先在 `SELECT` 列表中映射为 `avg`，然后我们简单地做 `ORDER BY avg`\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_30\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_31\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_32\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n<!-- example group3 -->\n\n##### 同时按多个字段 GROUP BY\n\n在某些情况下，你可能想不仅按单个字段分组，而是同时按多个字段分组，比如电影的类别和年份：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_34\n\n<!-- response SQL -->\n\nCODE_BLOCK_35\n\n<!-- request JSON -->\n\nCODE_BLOCK_36\n\n<!-- response JSON -->\n\nCODE_BLOCK_37\n\n<!-- end -->\n\n<!-- example group4 -->\n\n##### 给我 N 行\n\n有时查看每组不止一个元素很有用。这可以通过 `GROUP N BY` 轻松实现。例如，下面的例子中，我们为每年获取两部电影，而不是简单的 `GROUP BY release_year` 返回的一部。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_38\n\n<!-- response SQL -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example group5 -->\n\n##### 组内排序\n\n另一个关键的分析需求是对组内元素排序。为此，使用 `WITHIN GROUP ORDER BY ... {ASC|DESC}` 子句。例如，我们获取每年评分最高的电影。注意它与单独的 `ORDER BY` 并行工作：\n\n* `WITHIN GROUP ORDER BY` 对组内结果排序\n\n* 而单独的 `GROUP BY` 对组本身排序\n\n这两者完全独立工作。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_40\n\n<!-- response SQL -->\n\nCODE_BLOCK_41\n\n<!-- end -->\n\n<!-- example group6 -->\n\n##### 过滤组\n\n`HAVING expression` 是过滤组的有用子句。`WHERE` 在分组前应用，而 `HAVING` 作用于组。例如，我们只保留那些该年电影平均租赁率高于 3 的年份。结果只有四个年份：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_42\n\n<!-- response SQL -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n注意 `HAVING` 不影响[搜索查询元信息](../Node_info_and_management/SHOW_META.md#SHOW-META)中的 `total_found`。\n\n<!-- example group7 -->\n\n##### GROUPBY()",
      "russian": "# Группировка результатов поиска\n\n<!-- example general -->\n\nГруппировка результатов поиска часто полезна для получения количества совпадений по группам или других агрегатов. Например, это удобно для создания графика, иллюстрирующего количество совпадающих блог-постов по месяцам, или для группировки результатов веб-поиска по сайту, или сообщений на форуме по автору и т.д.\n\nManticore поддерживает группировку результатов поиска по одному или нескольким столбцам и вычисляемым выражениям. Результаты могут:\n\n* Быть отсортированы внутри группы\n\n* Возвращать более одной строки на группу\n\n* Иметь отфильтрованные группы\n\n* Иметь отсортированные группы\n\n* Быть агрегированы с помощью [функций агрегации](../Searching/Grouping.md#Aggregation-functions)\n\n<!-- intro -->\n\nОбщий синтаксис:\n\n<!-- request SQL -->\n\nОбщий синтаксис\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nФормат JSON-запроса в настоящее время поддерживает базовую группировку, которая может получать агрегированные значения и их count(*).\n\nCODE_BLOCK_1\n\nСтандартный вывод запроса возвращает набор результатов без группировки, который можно скрыть с помощью `limit` (или `size`).\n\nАгрегация требует установки `size` для размера набора результатов группы.\n\n<!-- end -->\n\n<!-- example group1 -->\n\n### Просто группировка\n\nГруппировка довольно проста — просто добавьте \"GROUP BY smth\" в конец вашего запроса `SELECT`. Что-то может быть:\n\n* Любым не полнотекстовым полем из таблицы: integer, float, string, MVA (мульти-значение атрибута)\n\n* Или, если вы использовали псевдоним в списке `SELECT`, вы также можете группировать по нему\n\nВы можете опустить любые [функции агрегации](../Searching/Grouping.md#Aggregation-functions) в списке `SELECT`, и это всё равно будет работать:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- example group2 -->\n\nВ большинстве случаев, однако, вы захотите получить некоторые агрегированные данные для каждой группы, например:\n\n* `COUNT(*)`, чтобы просто получить количество элементов в каждой группе\n\n* или `AVG(field)`, чтобы вычислить среднее значение поля внутри группы\n\nДля HTTP JSON-запросов использование одного `aggs` bucket с `limit=0` на уровне основного запроса работает аналогично SQL-запросу с `GROUP BY` и `COUNT(*)`, обеспечивая эквивалентное поведение и производительность.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_4\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_5\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_6\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_7\n\n<!-- request JSON -->\n\nCODE_BLOCK_8\n\n<!-- response JSON -->\n\nCODE_BLOCK_9\n\n<!-- request PHP -->\n\nCODE_BLOCK_10\n\n<!-- response PHP -->\n\nCODE_BLOCK_11\n\n<!-- request Python -->\n\nCODE_BLOCK_12\n\n<!-- response Python -->\n\nCODE_BLOCK_13\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_14\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_15\n\n<!-- request Javascript -->\n\nCODE_BLOCK_16\n\n<!-- response Javascript -->\n\nCODE_BLOCK_17\n\n<!-- request Java -->\n\nCODE_BLOCK_18\n\n<!-- response Java -->\n\nCODE_BLOCK_19\n\n<!-- request C# -->\n\nCODE_BLOCK_20\n\n<!-- response C# -->\n\nCODE_BLOCK_21\n\n<!-- request Rust -->\n\nCODE_BLOCK_22\n\n<!-- response Rust -->\n\nCODE_BLOCK_23\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_24\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_25\n\n<!-- request Go -->\n\nCODE_BLOCK_26\n\n<!-- response Go -->\n\nCODE_BLOCK_27\n\n<!-- end -->\n\n<!-- example sort1 -->\n\n##### Сортировка групп\n\nПо умолчанию группы не сортируются, и следующим шагом обычно является их упорядочивание по чему-то, например, по полю, по которому вы группируете:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_28\n\n<!-- response SQL -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n<!-- example sort2 -->\n\nИли вы можете сортировать по агрегату:\n\n* по `count(*)`, чтобы сначала отображать группы с наибольшим количеством элементов\n\n* по `avg(rental_rate)`, чтобы показывать фильмы с наивысшим рейтингом первыми. Обратите внимание, что в примере это сделано через псевдоним: `avg(rental_rate)` сначала сопоставляется с `avg` в списке `SELECT`, а затем мы просто делаем `ORDER BY avg`\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_30\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_31\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_32\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n<!-- example group3 -->\n\n##### GROUP BY по нескольким полям одновременно\n\nВ некоторых случаях вы можете захотеть группировать не только по одному полю, но и по нескольким сразу, например, по категории фильма и году:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_34\n\n<!-- response SQL -->\n\nCODE_BLOCK_35\n\n<!-- request JSON -->\n\nCODE_BLOCK_36\n\n<!-- response JSON -->\n\nCODE_BLOCK_37\n\n<!-- end -->\n\n<!-- example group4 -->\n\n##### Дайте мне N строк\n\nИногда полезно видеть не только один элемент на группу, а несколько. Это легко достигается с помощью `GROUP N BY`. Например, в следующем случае мы получаем два фильма для каждого года, а не только один, как вернул бы простой `GROUP BY release_year`.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_38\n\n<!-- response SQL -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example group5 -->\n\n##### Сортировка внутри группы\n\nЕще одно важное требование аналитики — сортировать элементы внутри группы. Для этого используйте конструкцию `WITHIN GROUP ORDER BY ... {ASC|DESC}`. Например, получим фильм с наивысшим рейтингом для каждого года. Обратите внимание, что это работает параллельно с обычным `ORDER BY`:\n\n* `WITHIN GROUP ORDER BY` сортирует результаты **внутри группы**\n\n* в то время как просто `GROUP BY` **сортирует сами группы**\n\nЭти два работают полностью независимо.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_40\n\n<!-- response SQL -->\n\nCODE_BLOCK_41\n\n<!-- end -->\n\n<!-- example group6 -->\n\n##### Фильтрация групп\n\n`HAVING expression` — полезное выражение для фильтрации групп. В то время как `WHERE` применяется до группировки, `HAVING` работает с группами. Например, оставим только те годы, когда средний рейтинг аренды фильмов за этот год был выше 3. Мы получаем только четыре года:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_42\n\n<!-- response SQL -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\nОбратите внимание, что `HAVING` не влияет на `total_found` в [метаинформации поискового запроса](../Node_info_and_management/SHOW_META.md#SHOW-META).\n\n<!-- example group7 -->\n\n##### GROUPBY()"
    },
    "is_code_or_comment": false
  },
  "78a82db0b5037b2fa9f9ca03667decb540e7c31fb332dc0937353aa3b651afa1": {
    "original": "There is a function `GROUPBY()` which returns the key of the current group. It's useful in many cases, especially when you [GROUP BY an MVA](../Searching/Grouping.md#Grouping-by-MVA-%28multi-value-attributes%29) or a [JSON value](../Searching/Grouping.md#Grouping-by-a-JSON-node).\n\nIt can also be used in `HAVING`, for example, to keep only years 2000 and 2002.\n\nNote that `GROUPBY()`is not recommended for use when you GROUP BY multiple fields at once. It will still work, but since the group key in this case is a compound of field values, it may not appear the way you expect.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_44\n\n<!-- response SQL -->\n\nCODE_BLOCK_45\n\n<!-- end -->\n\n<!-- example mva -->\n\n##### Grouping by MVA (multi-value attributes)\n\nManticore supports grouping by [MVA](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29). To demonstrate how it works, let's create a table \"shoes\" with MVA \"sizes\" and insert a few documents into it:\n\nCODE_BLOCK_46\n\nso we have:\n\nCODE_BLOCK_47\n\nIf we now GROUP BY \"sizes\", it will process all our multi-value attributes and return an aggregation for each, in this case just the count:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- response SQL -->\n\nCODE_BLOCK_49\n\n<!-- request JSON -->\n\nCODE_BLOCK_50\n\n<!-- response JSON -->\n\nCODE_BLOCK_51\n\n<!-- request PHP -->\n\nCODE_BLOCK_52\n\n<!-- response PHP -->\n\nCODE_BLOCK_53\n\n<!-- request Python -->\n\nCODE_BLOCK_54\n\n<!-- response Python -->\n\nCODE_BLOCK_55\n\n<!-- request Javascript -->\n\nCODE_BLOCK_56\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_57\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_58\n\n<!-- request Javascript -->\n\nCODE_BLOCK_59\n\n<!-- response Javascript -->\n\nCODE_BLOCK_60\n\n<!-- request Java -->\n\nCODE_BLOCK_61\n\n<!-- response Java -->\n\nCODE_BLOCK_62\n\n<!-- request C# -->\n\nCODE_BLOCK_63\n\n<!-- response C# -->\n\nCODE_BLOCK_64\n\n<!-- request Rust -->\n\nCODE_BLOCK_65\n\n<!-- response Rust -->\n\nCODE_BLOCK_66\n\nres = await searchApi.search({\n\n  index: 'test',\n\n  aggs: {\n\n    mva_agg: {\n\n      terms: { field: \"mva_field\", size: 2 }\n\n    }\n\n  }\n\n});\n\nCODE_BLOCK_67\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":4,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_68\n\nquery := map[string]interface{} {};\n\nsearchRequest.SetQuery(query);\n\naggTerms := manticoreclient.NewAggregationTerms()\n\naggTerms.SetField(\"mva_field\")\n\naggTerms.SetSize(2)\n\naggregation := manticoreclient.NewAggregation()\n\naggregation.setTerms(aggTerms)\n\nsearchRequest.SetAggregation(aggregation)\n\nres, _, _ := apiClient.SearchAPI.Search(context.Background()).SearchRequest(*searchRequest).Execute()\n\nCODE_BLOCK_69\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":5,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_70\n\ncreate table products(title text, meta json);\n\ninsert into products values(0,'nike','{\"color\":\"red\"}'),(0,'adidas','{\"color\":\"red\"}'),(0,'puma','{\"color\":\"green\"}');\n\nCODE_BLOCK_71\n\nSELECT * FROM products;\n\n+---------------------+-------------------+--------+\n\n| id                  | meta              | title  |\n\n+---------------------+-------------------+--------+\n\n| 1657851069130080268 | {\"color\":\"red\"}   | nike   |\n\n| 1657851069130080269 | {\"color\":\"red\"}   | adidas |\n\n| 1657851069130080270 | {\"color\":\"green\"} | puma   |\n\n+---------------------+-------------------+--------+\n\nCODE_BLOCK_72\n\nSELECT groupby() color, count(*) from products GROUP BY meta.color;\n\nCODE_BLOCK_73\n\n+-------+----------+\n\n| color | count(*) |\n\n+-------+----------+\n\n| red   |        2 |\n\n| green |        1 |\n\n+-------+----------+\n\nCODE_BLOCK_74\n\nPOST /search -d '\n\n    {\n\n     \"table\" : \"products\",\n\n     \"limit\": 0,\n\n     \"aggs\" :\n\n     {\n\n        \"color\" :\n\n         {\n\n            \"terms\" :\n\n             {\n\n              \"field\":\"meta.color\",\n\n              \"size\":100\n\n             }\n\n         }\n\n     }\n\n    }\n\n'\n\nCODE_BLOCK_75\n\n{\n\n  \"took\": 0,\n\n  \"timed_out\": false,\n\n  \"hits\": {\n\n    \"total\": 3,\n\n    \"hits\": [\n\n    ]\n\n  },\n\n  \"aggregations\": {\n\n    \"color\": {\n\n      \"buckets\": [\n\n        {\n\n          \"key\": \"green\",\n\n          \"doc_count\": 1\n\n        },\n\n        {\n\n          \"key\": \"red\",\n\n          \"doc_count\": 2\n\n        }\n\n      ]\n\n    }\n\n  }\n\n}\n\nCODE_BLOCK_76\n\n$index->setName('products');\n\n$search = $index->search('');\n\n$search->limit(0);\n\n$search->facet('meta.color','color',100);\n\n$results = $search->get();\n\nprint_r($results->getFacets());\n\nCODE_BLOCK_77\n\nArray\n\n(\n\n    [color] => Array\n\n        (\n\n            [buckets] => Array\n\n                (\n\n                    [0] => Array\n\n                        (\n\n                            [key] => green\n\n                            [doc_count] => 1\n\n                        )\n\n                    [1] => Array\n\n                        (\n\n                            [key] => red\n\n                            [doc_count] => 2\n\n                        )\n\n                )\n\n        )\n\n)\n\nCODE_BLOCK_78\n\nres =searchApi.search({\"table\":\"products\",\"limit\":0,\"aggs\":{\"color\":{\"terms\":{\"field\":\"meta.color\",\"size\":100}}}})\n\nCODE_BLOCK_79\n\n{'aggregations': {u'color': {u'buckets': [{u'doc_count': 1,\n\n                                           u'key': u'green'},\n\n                                          {u'doc_count': 2, u'key': u'red'}]}},\n\n 'hits': {'hits': [], 'max_score': None, 'total': 3},\n\n 'profile': None,\n\n 'timed_out': False,\n\n 'took': 0}\n\nCODE_BLOCK_80\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_81\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_82\n\n<!-- request Javascript -->\n\nCODE_BLOCK_83\n\n<!-- response Javascript -->\n\nCODE_BLOCK_84\n\n<!-- request Java -->\n\nCODE_BLOCK_85\n\n<!-- response Java -->\n\nCODE_BLOCK_86\n\n<!-- request C# -->\n\nCODE_BLOCK_87\n\n<!-- response C# -->\n\nCODE_BLOCK_88\n\n<!-- request Rust -->\n\nCODE_BLOCK_89\n\n<!-- response Rust -->\n\nCODE_BLOCK_90\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_91",
    "translations": {
      "chinese": "有一个函数 `GROUPBY()`，它返回当前分组的键。在许多情况下非常有用，特别是当你[按 MVA 分组](../Searching/Grouping.md#Grouping-by-MVA-%28multi-value-attributes%29)或按[JSON 值分组](../Searching/Grouping.md#Grouping-by-a-JSON-node)时。\n\n它也可以用于 `HAVING`，例如，只保留年份 2000 和 2002。\n\n注意，当你一次按多个字段进行 GROUP BY 时，不推荐使用 `GROUPBY()`。它仍然可以工作，但由于此时的分组键是字段值的复合，可能不会以你期望的方式出现。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_44\n\n<!-- response SQL -->\n\nCODE_BLOCK_45\n\n<!-- end -->\n\n<!-- example mva -->\n\n##### 按 MVA（多值属性）分组\n\nManticore 支持按[MVA](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29)分组。为了演示其工作原理，我们创建一个包含 MVA 字段 \"sizes\" 的表 \"shoes\"，并插入一些文档：\n\nCODE_BLOCK_46\n\n所以我们有：\n\nCODE_BLOCK_47\n\n如果现在按 \"sizes\" 进行 GROUP BY，它将处理所有多值属性，并为每个返回一个聚合，在此例中仅是计数：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- response SQL -->\n\nCODE_BLOCK_49\n\n<!-- request JSON -->\n\nCODE_BLOCK_50\n\n<!-- response JSON -->\n\nCODE_BLOCK_51\n\n<!-- request PHP -->\n\nCODE_BLOCK_52\n\n<!-- response PHP -->\n\nCODE_BLOCK_53\n\n<!-- request Python -->\n\nCODE_BLOCK_54\n\n<!-- response Python -->\n\nCODE_BLOCK_55\n\n<!-- request Javascript -->\n\nCODE_BLOCK_56\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_57\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_58\n\n<!-- request Javascript -->\n\nCODE_BLOCK_59\n\n<!-- response Javascript -->\n\nCODE_BLOCK_60\n\n<!-- request Java -->\n\nCODE_BLOCK_61\n\n<!-- response Java -->\n\nCODE_BLOCK_62\n\n<!-- request C# -->\n\nCODE_BLOCK_63\n\n<!-- response C# -->\n\nCODE_BLOCK_64\n\n<!-- request Rust -->\n\nCODE_BLOCK_65\n\n<!-- response Rust -->\n\nCODE_BLOCK_66\n\nres = await searchApi.search({\n\n  index: 'test',\n\n  aggs: {\n\n    mva_agg: {\n\n      terms: { field: \"mva_field\", size: 2 }\n\n    }\n\n  }\n\n});\n\nCODE_BLOCK_67\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":4,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_68\n\nquery := map[string]interface{} {};\n\nsearchRequest.SetQuery(query);\n\naggTerms := manticoreclient.NewAggregationTerms()\n\naggTerms.SetField(\"mva_field\")\n\naggTerms.SetSize(2)\n\naggregation := manticoreclient.NewAggregation()\n\naggregation.setTerms(aggTerms)\n\nsearchRequest.SetAggregation(aggregation)\n\nres, _, _ := apiClient.SearchAPI.Search(context.Background()).SearchRequest(*searchRequest).Execute()\n\nCODE_BLOCK_69\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":5,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_70\n\ncreate table products(title text, meta json);\n\ninsert into products values(0,'nike','{\"color\":\"red\"}'),(0,'adidas','{\"color\":\"red\"}'),(0,'puma','{\"color\":\"green\"}');\n\nCODE_BLOCK_71\n\nSELECT * FROM products;\n\n+---------------------+-------------------+--------+\n\n| id                  | meta              | title  |\n\n+---------------------+-------------------+--------+\n\n| 1657851069130080268 | {\"color\":\"red\"}   | nike   |\n\n| 1657851069130080269 | {\"color\":\"red\"}   | adidas |\n\n| 1657851069130080270 | {\"color\":\"green\"} | puma   |\n\n+---------------------+-------------------+--------+\n\nCODE_BLOCK_72\n\nSELECT groupby() color, count(*) from products GROUP BY meta.color;\n\nCODE_BLOCK_73\n\n+-------+----------+\n\n| color | count(*) |\n\n+-------+----------+\n\n| red   |        2 |\n\n| green |        1 |\n\n+-------+----------+\n\nCODE_BLOCK_74\n\nPOST /search -d '\n\n    {\n\n     \"table\" : \"products\",\n\n     \"limit\": 0,\n\n     \"aggs\" :\n\n     {\n\n        \"color\" :\n\n         {\n\n            \"terms\" :\n\n             {\n\n              \"field\":\"meta.color\",\n\n              \"size\":100\n\n             }\n\n         }\n\n     }\n\n    }\n\n'\n\nCODE_BLOCK_75\n\n{\n\n  \"took\": 0,\n\n  \"timed_out\": false,\n\n  \"hits\": {\n\n    \"total\": 3,\n\n    \"hits\": [\n\n    ]\n\n  },\n\n  \"aggregations\": {\n\n    \"color\": {\n\n      \"buckets\": [\n\n        {\n\n          \"key\": \"green\",\n\n          \"doc_count\": 1\n\n        },\n\n        {\n\n          \"key\": \"red\",\n\n          \"doc_count\": 2\n\n        }\n\n      ]\n\n    }\n\n  }\n\n}\n\nCODE_BLOCK_76\n\n$index->setName('products');\n\n$search = $index->search('');\n\n$search->limit(0);\n\n$search->facet('meta.color','color',100);\n\n$results = $search->get();\n\nprint_r($results->getFacets());\n\nCODE_BLOCK_77\n\nArray\n\n(\n\n    [color] => Array\n\n        (\n\n            [buckets] => Array\n\n                (\n\n                    [0] => Array\n\n                        (\n\n                            [key] => green\n\n                            [doc_count] => 1\n\n                        )\n\n                    [1] => Array\n\n                        (\n\n                            [key] => red\n\n                            [doc_count] => 2\n\n                        )\n\n                )\n\n        )\n\n)\n\nCODE_BLOCK_78\n\nres =searchApi.search({\"table\":\"products\",\"limit\":0,\"aggs\":{\"color\":{\"terms\":{\"field\":\"meta.color\",\"size\":100}}}})\n\nCODE_BLOCK_79\n\n{'aggregations': {u'color': {u'buckets': [{u'doc_count': 1,\n\n                                           u'key': u'green'},\n\n                                          {u'doc_count': 2, u'key': u'red'}]}},\n\n 'hits': {'hits': [], 'max_score': None, 'total': 3},\n\n 'profile': None,\n\n 'timed_out': False,\n\n 'took': 0}\n\nCODE_BLOCK_80\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_81\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_82\n\n<!-- request Javascript -->\n\nCODE_BLOCK_83\n\n<!-- response Javascript -->\n\nCODE_BLOCK_84\n\n<!-- request Java -->\n\nCODE_BLOCK_85\n\n<!-- response Java -->\n\nCODE_BLOCK_86\n\n<!-- request C# -->\n\nCODE_BLOCK_87\n\n<!-- response C# -->\n\nCODE_BLOCK_88\n\n<!-- request Rust -->\n\nCODE_BLOCK_89\n\n<!-- response Rust -->\n\nCODE_BLOCK_90\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_91",
      "russian": "Есть функция `GROUPBY()`, которая возвращает ключ текущей группы. Она полезна во многих случаях, особенно когда вы [GROUP BY по MVA](../Searching/Grouping.md#Grouping-by-MVA-%28multi-value-attributes%29) или по [JSON значению](../Searching/Grouping.md#Grouping-by-a-JSON-node).\n\nЕё также можно использовать в `HAVING`, например, чтобы оставить только годы 2000 и 2002.\n\nОбратите внимание, что `GROUPBY()` не рекомендуется использовать, когда вы GROUP BY по нескольким полям одновременно. Она всё равно будет работать, но поскольку ключ группы в этом случае является составным из значений полей, он может не отображаться так, как вы ожидаете.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_44\n\n<!-- response SQL -->\n\nCODE_BLOCK_45\n\n<!-- end -->\n\n<!-- example mva -->\n\n##### Группировка по MVA (мультизначным атрибутам)\n\nManticore поддерживает группировку по [MVA](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29). Чтобы показать, как это работает, давайте создадим таблицу \"shoes\" с MVA \"sizes\" и вставим в неё несколько документов:\n\nCODE_BLOCK_46\n\nтак что у нас есть:\n\nCODE_BLOCK_47\n\nЕсли теперь мы сделаем GROUP BY по \"sizes\", он обработает все наши мультизначные атрибуты и вернёт агрегацию для каждого, в данном случае просто количество:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- response SQL -->\n\nCODE_BLOCK_49\n\n<!-- request JSON -->\n\nCODE_BLOCK_50\n\n<!-- response JSON -->\n\nCODE_BLOCK_51\n\n<!-- request PHP -->\n\nCODE_BLOCK_52\n\n<!-- response PHP -->\n\nCODE_BLOCK_53\n\n<!-- request Python -->\n\nCODE_BLOCK_54\n\n<!-- response Python -->\n\nCODE_BLOCK_55\n\n<!-- request Javascript -->\n\nCODE_BLOCK_56\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_57\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_58\n\n<!-- request Javascript -->\n\nCODE_BLOCK_59\n\n<!-- response Javascript -->\n\nCODE_BLOCK_60\n\n<!-- request Java -->\n\nCODE_BLOCK_61\n\n<!-- response Java -->\n\nCODE_BLOCK_62\n\n<!-- request C# -->\n\nCODE_BLOCK_63\n\n<!-- response C# -->\n\nCODE_BLOCK_64\n\n<!-- request Rust -->\n\nCODE_BLOCK_65\n\n<!-- response Rust -->\n\nCODE_BLOCK_66\n\nres = await searchApi.search({\n\n  index: 'test',\n\n  aggs: {\n\n    mva_agg: {\n\n      terms: { field: \"mva_field\", size: 2 }\n\n    }\n\n  }\n\n});\n\nCODE_BLOCK_67\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":4,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_68\n\nquery := map[string]interface{} {};\n\nsearchRequest.SetQuery(query);\n\naggTerms := manticoreclient.NewAggregationTerms()\n\naggTerms.SetField(\"mva_field\")\n\naggTerms.SetSize(2)\n\naggregation := manticoreclient.NewAggregation()\n\naggregation.setTerms(aggTerms)\n\nsearchRequest.SetAggregation(aggregation)\n\nres, _, _ := apiClient.SearchAPI.Search(context.Background()).SearchRequest(*searchRequest).Execute()\n\nCODE_BLOCK_69\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":5,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_70\n\ncreate table products(title text, meta json);\n\ninsert into products values(0,'nike','{\"color\":\"red\"}'),(0,'adidas','{\"color\":\"red\"}'),(0,'puma','{\"color\":\"green\"}');\n\nCODE_BLOCK_71\n\nSELECT * FROM products;\n\n+---------------------+-------------------+--------+\n\n| id                  | meta              | title  |\n\n+---------------------+-------------------+--------+\n\n| 1657851069130080268 | {\"color\":\"red\"}   | nike   |\n\n| 1657851069130080269 | {\"color\":\"red\"}   | adidas |\n\n| 1657851069130080270 | {\"color\":\"green\"} | puma   |\n\n+---------------------+-------------------+--------+\n\nCODE_BLOCK_72\n\nSELECT groupby() color, count(*) from products GROUP BY meta.color;\n\nCODE_BLOCK_73\n\n+-------+----------+\n\n| color | count(*) |\n\n+-------+----------+\n\n| red   |        2 |\n\n| green |        1 |\n\n+-------+----------+\n\nCODE_BLOCK_74\n\nPOST /search -d '\n\n    {\n\n     \"table\" : \"products\",\n\n     \"limit\": 0,\n\n     \"aggs\" :\n\n     {\n\n        \"color\" :\n\n         {\n\n            \"terms\" :\n\n             {\n\n              \"field\":\"meta.color\",\n\n              \"size\":100\n\n             }\n\n         }\n\n     }\n\n    }\n\n'\n\nCODE_BLOCK_75\n\n{\n\n  \"took\": 0,\n\n  \"timed_out\": false,\n\n  \"hits\": {\n\n    \"total\": 3,\n\n    \"hits\": [\n\n    ]\n\n  },\n\n  \"aggregations\": {\n\n    \"color\": {\n\n      \"buckets\": [\n\n        {\n\n          \"key\": \"green\",\n\n          \"doc_count\": 1\n\n        },\n\n        {\n\n          \"key\": \"red\",\n\n          \"doc_count\": 2\n\n        }\n\n      ]\n\n    }\n\n  }\n\n}\n\nCODE_BLOCK_76\n\n$index->setName('products');\n\n$search = $index->search('');\n\n$search->limit(0);\n\n$search->facet('meta.color','color',100);\n\n$results = $search->get();\n\nprint_r($results->getFacets());\n\nCODE_BLOCK_77\n\nArray\n\n(\n\n    [color] => Array\n\n        (\n\n            [buckets] => Array\n\n                (\n\n                    [0] => Array\n\n                        (\n\n                            [key] => green\n\n                            [doc_count] => 1\n\n                        )\n\n                    [1] => Array\n\n                        (\n\n                            [key] => red\n\n                            [doc_count] => 2\n\n                        )\n\n                )\n\n        )\n\n)\n\nCODE_BLOCK_78\n\nres =searchApi.search({\"table\":\"products\",\"limit\":0,\"aggs\":{\"color\":{\"terms\":{\"field\":\"meta.color\",\"size\":100}}}})\n\nCODE_BLOCK_79\n\n{'aggregations': {u'color': {u'buckets': [{u'doc_count': 1,\n\n                                           u'key': u'green'},\n\n                                          {u'doc_count': 2, u'key': u'red'}]}},\n\n 'hits': {'hits': [], 'max_score': None, 'total': 3},\n\n 'profile': None,\n\n 'timed_out': False,\n\n 'took': 0}\n\nCODE_BLOCK_80\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_81\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_82\n\n<!-- request Javascript -->\n\nCODE_BLOCK_83\n\n<!-- response Javascript -->\n\nCODE_BLOCK_84\n\n<!-- request Java -->\n\nCODE_BLOCK_85\n\n<!-- response Java -->\n\nCODE_BLOCK_86\n\n<!-- request C# -->\n\nCODE_BLOCK_87\n\n<!-- response C# -->\n\nCODE_BLOCK_88\n\n<!-- request Rust -->\n\nCODE_BLOCK_89\n\n<!-- response Rust -->\n\nCODE_BLOCK_90\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_91"
    },
    "is_code_or_comment": false
  },
  "a57081049e78fd08c7a9f16e7d4a4197490f76ca42882b50bfed4bdebcb68978": {
    "original": "# Grouping search results\n\n<!-- example general -->\n\nGrouping search results is often helpful for obtaining per-group match counts or other aggregations. For example, it's useful for creating a graph illustrating the number of matching blog posts per month or grouping web search results by site or forum posts by author, etc.\n\nManticore supports the grouping of search results by single or multiple columns and computed expressions. The results can:\n\n* Be sorted within a group\n\n* Return more than one row per group\n\n* Have groups filtered\n\n* Have groups sorted\n\n* Be aggregated using the [aggregation functions](../Searching/Grouping.md#Aggregation-functions)\n\n<!-- intro -->\n\nThe general syntax is:\n\n<!-- request SQL -->\n\nGeneral syntax\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nJSON query format currently supports a basic grouping that can retrieve aggregate values and their count(*).\n\nCODE_BLOCK_1\n\nThe standard query output returns the result set without grouping, which can be hidden using `limit` (or `size`).\n\nThe aggregation requires setting a `size` for the group's result set size.\n\n<!-- end -->\n\n<!-- example group1 -->\n\n### Just Grouping\n\nGrouping is quite simple - just add \"GROUP BY smth\" to the end of your `SELECT` query. The something can be:\n\n* Any non-full-text field from the table: integer, float, string, MVA (multi-value attribute)\n\n* Or, if you used an alias in the `SELECT` list, you can GROUP BY it too\n\nYou can omit any [aggregation functions](../Searching/Grouping.md#Aggregation-functions) in the `SELECT` list and it will still work:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- example group2 -->\n\nIn most cases, however, you'll want to obtain some aggregated data for each group, such as:\n\n* `COUNT(*)` to simply get the number of elements in each group\n\n* or `AVG(field)` to calculate the average value of the field within the group\n\nFor HTTP JSON requests, using a single `aggs` bucket with `limit=0` at the main query level works similarly to a SQL query with `GROUP BY` and `COUNT(*)`, providing equivalent behavior and performance.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_4\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_5\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_6\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_7\n\n<!-- request JSON -->\n\nCODE_BLOCK_8\n\n<!-- response JSON -->\n\nCODE_BLOCK_9\n\n<!-- request PHP -->\n\nCODE_BLOCK_10\n\n<!-- response PHP -->\n\nCODE_BLOCK_11\n\n<!-- request Python -->\n\nCODE_BLOCK_12\n\n<!-- response Python -->\n\nCODE_BLOCK_13\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_14\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_15\n\n<!-- request Javascript -->\n\nCODE_BLOCK_16\n\n<!-- response Javascript -->\n\nCODE_BLOCK_17\n\n<!-- request Java -->\n\nCODE_BLOCK_18\n\n<!-- response Java -->\n\nCODE_BLOCK_19\n\n<!-- request C# -->\n\nCODE_BLOCK_20\n\n<!-- response C# -->\n\nCODE_BLOCK_21\n\n<!-- request Rust -->\n\nCODE_BLOCK_22\n\n<!-- response Rust -->\n\nCODE_BLOCK_23\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_24\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_25\n\n<!-- request Go -->\n\nCODE_BLOCK_26\n\n<!-- response Go -->\n\nCODE_BLOCK_27\n\n<!-- end -->\n\n<!-- example sort1 -->\n\n##### Sorting groups\n\nBy default, groups are not sorted, and the next thing you typically want to do is order them by something, like the field you're grouping by:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_28\n\n<!-- response SQL -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n<!-- example sort2 -->\n\nAlternatively, you can sort by the aggregation:\n\n* by `count(*)` to display groups with the most elements first\n\n* by `avg(rental_rate)` to show the highest-rated movies first. Note that in the example, it's done via an alias: `avg(rental_rate)` is first mapped to `avg` in the `SELECT` list, and then we simply do `ORDER BY avg`\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_30\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_31\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_32\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n<!-- example group3 -->\n\n##### GROUP BY multiple fields at once\n\nIn some cases, you might want to group not just by a single field, but by multiple fields at once, such as a movie's category and year:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_34\n\n<!-- response SQL -->\n\nCODE_BLOCK_35\n\n<!-- request JSON -->\n\nCODE_BLOCK_36\n\n<!-- response JSON -->\n\nCODE_BLOCK_37\n\n<!-- end -->\n\n<!-- example group4 -->\n\n##### Give me N rows\n\nSometimes it's useful to see not just a single element per group, but multiple. This can be easily achieved with the help of `GROUP N BY`. For example, in the following case, we get two movies for each year rather than just one, which a simple `GROUP BY release_year` would have returned.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_38\n\n<!-- response SQL -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example group5 -->\n\n##### Sorting inside a group\n\nAnother crucial analytics requirement is to sort elements within a group. To achieve this, use the `WITHIN GROUP ORDER BY ... {ASC|DESC}` clause. For example, let's get the highest-rated film for each year. Note that it works in parallel with just `ORDER BY`:\n\n* `WITHIN GROUP ORDER BY` sorts results **inside a group**\n\n* while just `GROUP BY` **sorts the groups themselves**\n\nThese two work entirely independently.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_40\n\n<!-- response SQL -->\n\nCODE_BLOCK_41\n\n<!-- end -->\n\n<!-- example group6 -->\n\n##### Filter groups\n\n`HAVING expression` is a helpful clause for filtering groups. While `WHERE` is applied before grouping, `HAVING` works with the groups. For example, let's keep only those years when the average rental rate of the films for that year was higher than 3. We get only four years:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_42\n\n<!-- response SQL -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n<!-- example group7 -->\n\n##### GROUPBY()",
    "translations": {
      "chinese": "# 分组搜索结果\n\n<!-- example general -->\n\n分组搜索结果通常有助于获取每个组的匹配计数或其他聚合。例如，它对于创建按月匹配博客帖子数量的图表，或按站点分组网页搜索结果，或按作者分组论坛帖子等非常有用。\n\nManticore 支持按单列、多列和计算表达式对搜索结果进行分组。结果可以：\n\n* 在组内排序\n\n* 每组返回多行\n\n* 对组进行过滤\n\n* 对组进行排序\n\n* 使用[聚合函数](../Searching/Grouping.md#Aggregation-functions)进行聚合\n\n<!-- intro -->\n\n一般语法是：\n\n<!-- request SQL -->\n\n通用语法\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nJSON 查询格式目前支持基本分组，可检索聚合值及其 count(*)。\n\nCODE_BLOCK_1\n\n标准查询输出返回未分组的结果集，可以通过 `limit`（或 `size`）将其隐藏。\n\n聚合需要设置组结果集大小 `size`。\n\n<!-- end -->\n\n<!-- example group1 -->\n\n### 仅分组\n\n分组相当简单——只需在 `SELECT` 查询末尾添加 \"GROUP BY smth\"。该某物可以是：\n\n* 表中的任何非全文字段：整数、浮点、字符串、多值属性(MVA)\n\n* 或者，如果你在 `SELECT` 列表中使用了别名，也可以按它分组\n\n你可以省略 `SELECT` 列表中的任何[聚合函数](../Searching/Grouping.md#Aggregation-functions)，仍然有效：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- example group2 -->\n\n然而，在大多数情况下，你会想为每个组获得一些聚合数据，例如：\n\n* `COUNT(*)` 仅仅获取每组的元素数量\n\n* 或 `AVG(field)` 计算组内字段的平均值\n\n对于 HTTP JSON 请求，使用单个 `aggs` 桶，并在主查询级别设置 `limit=0`，效果类似于 SQL 查询中的 `GROUP BY` 和 `COUNT(*)`，提供等效的行为和性能。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_4\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_5\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_6\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_7\n\n<!-- request JSON -->\n\nCODE_BLOCK_8\n\n<!-- response JSON -->\n\nCODE_BLOCK_9\n\n<!-- request PHP -->\n\nCODE_BLOCK_10\n\n<!-- response PHP -->\n\nCODE_BLOCK_11\n\n<!-- request Python -->\n\nCODE_BLOCK_12\n\n<!-- response Python -->\n\nCODE_BLOCK_13\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_14\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_15\n\n<!-- request Javascript -->\n\nCODE_BLOCK_16\n\n<!-- response Javascript -->\n\nCODE_BLOCK_17\n\n<!-- request Java -->\n\nCODE_BLOCK_18\n\n<!-- response Java -->\n\nCODE_BLOCK_19\n\n<!-- request C# -->\n\nCODE_BLOCK_20\n\n<!-- response C# -->\n\nCODE_BLOCK_21\n\n<!-- request Rust -->\n\nCODE_BLOCK_22\n\n<!-- response Rust -->\n\nCODE_BLOCK_23\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_24\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_25\n\n<!-- request Go -->\n\nCODE_BLOCK_26\n\n<!-- response Go -->\n\nCODE_BLOCK_27\n\n<!-- end -->\n\n<!-- example sort1 -->\n\n##### 组内排序\n\n默认情况下，组不排序，接下来你通常想做的是按某个字段排序，比如你分组用的字段：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_28\n\n<!-- response SQL -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n<!-- example sort2 -->\n\n另外，你也可以按聚合排序：\n\n* 按 `count(*)` 排序，优先显示包含最多元素的组\n\n* 按 `avg(rental_rate)` 排序，优先显示评分最高的电影。注意，在示例中，这是通过别名完成的：先在 `SELECT` 列表中将 `avg(rental_rate)` 映射为 `avg`，然后简单地执行 `ORDER BY avg`\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_30\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_31\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_32\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n<!-- example group3 -->\n\n##### 一次按多个字段 GROUP BY\n\n有时你可能想按多个字段分组，而不仅仅是单个字段，比如电影的类别和年份：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_34\n\n<!-- response SQL -->\n\nCODE_BLOCK_35\n\n<!-- request JSON -->\n\nCODE_BLOCK_36\n\n<!-- response JSON -->\n\nCODE_BLOCK_37\n\n<!-- end -->\n\n<!-- example group4 -->\n\n##### 给我 N 行\n\n有时看到每组不止一个元素也很有用。这可以通过 `GROUP N BY` 很容易实现。例如，下面的例子中，我们为每个年份获取两部电影，而不是简单 `GROUP BY release_year` 只返回一部。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_38\n\n<!-- response SQL -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example group5 -->\n\n##### 组内排序\n\n另一个关键的分析需求是对组内元素排序。为此，使用 `WITHIN GROUP ORDER BY ... {ASC|DESC}` 子句。例如，获取每年评分最高的电影。注意它与普通的 `ORDER BY` 并行工作：\n\n* `WITHIN GROUP ORDER BY` 对**组内**结果排序\n\n* 而仅用 `GROUP BY` 对**组本身**排序\n\n这两者完全独立工作。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_40\n\n<!-- response SQL -->\n\nCODE_BLOCK_41\n\n<!-- end -->\n\n<!-- example group6 -->\n\n##### 过滤组\n\n`HAVING expression` 是过滤组的有用子句。`WHERE` 用于分组前过滤，而 `HAVING` 用于分组后过滤。例如，我们只保留那些该年电影平均租赁率高于3的年份。结果只有四个年份：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_42\n\n<!-- response SQL -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n<!-- example group7 -->\n\n##### GROUPBY()",
      "russian": "# Группировка результатов поиска\n\n<!-- example general -->\n\nГруппировка результатов поиска часто полезна для получения количества совпадений по группам или других агрегатов. Например, это удобно для построения графика, иллюстрирующего количество совпадающих публикаций в блогах по месяцам, или для группировки результатов веб-поиска по сайту, сообщений форума по автору и т.д.\n\nManticore поддерживает группировку результатов поиска по одному или нескольким столбцам и вычисляемым выражениям. Результаты могут:\n\n* Быть отсортированы внутри группы\n\n* Возвращать более одной строки на группу\n\n* Фильтровать группы\n\n* Сортировать группы\n\n* Агрегироваться с помощью [функций агрегации](../Searching/Grouping.md#Aggregation-functions)\n\n<!-- intro -->\n\nОбщий синтаксис:\n\n<!-- request SQL -->\n\nОбщий синтаксис\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nФормат JSON-запроса в настоящее время поддерживает базовую группировку, которая может получать агрегатные значения и их count(*).\n\nCODE_BLOCK_1\n\nСтандартный вывод запроса возвращает набор результатов без группировки, который можно скрыть с помощью `limit` (или `size`).\n\nДля агрегации необходимо установить `size` для размера результирующего набора групп.\n\n<!-- end -->\n\n<!-- example group1 -->\n\n### Просто группировка\n\nГруппировка довольно проста — просто добавьте \"GROUP BY smth\" в конец вашего `SELECT` запроса. Что-то может быть:\n\n* Любым нефулл-текстовым полем из таблицы: integer, float, string, MVA (атрибут с множественным значением)\n\n* Или, если вы использовали псевдоним в списке `SELECT`, вы также можете использовать GROUP BY по нему\n\nВы можете опустить любые [функции агрегации](../Searching/Grouping.md#Aggregation-functions) в списке `SELECT`, и это все равно будет работать:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- example group2 -->\n\nВ большинстве случаев, однако, вы захотите получить некоторую агрегированную информацию для каждой группы, например:\n\n* `COUNT(*)` просто чтобы получить количество элементов в каждой группе\n\n* или `AVG(field)`, чтобы вычислить среднее значение поля внутри группы\n\nДля HTTP JSON-запросов использование одного бакета `aggs` с `limit=0` на уровне основного запроса работает аналогично SQL-запросу с `GROUP BY` и `COUNT(*)`, обеспечивая эквивалентное поведение и производительность.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_4\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_5\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_6\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_7\n\n<!-- request JSON -->\n\nCODE_BLOCK_8\n\n<!-- response JSON -->\n\nCODE_BLOCK_9\n\n<!-- request PHP -->\n\nCODE_BLOCK_10\n\n<!-- response PHP -->\n\nCODE_BLOCK_11\n\n<!-- request Python -->\n\nCODE_BLOCK_12\n\n<!-- response Python -->\n\nCODE_BLOCK_13\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_14\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_15\n\n<!-- request Javascript -->\n\nCODE_BLOCK_16\n\n<!-- response Javascript -->\n\nCODE_BLOCK_17\n\n<!-- request Java -->\n\nCODE_BLOCK_18\n\n<!-- response Java -->\n\nCODE_BLOCK_19\n\n<!-- request C# -->\n\nCODE_BLOCK_20\n\n<!-- response C# -->\n\nCODE_BLOCK_21\n\n<!-- request Rust -->\n\nCODE_BLOCK_22\n\n<!-- response Rust -->\n\nCODE_BLOCK_23\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_24\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_25\n\n<!-- request Go -->\n\nCODE_BLOCK_26\n\n<!-- response Go -->\n\nCODE_BLOCK_27\n\n<!-- end -->\n\n<!-- example sort1 -->\n\n##### Сортировка групп\n\nПо умолчанию группы не сортируются, и следующим обычно желаемым действием является их упорядочивание по чему-то, например, по полю, по которому происходит группировка:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_28\n\n<!-- response SQL -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n<!-- example sort2 -->\n\nВ качестве альтернативы, вы можете сортировать по агрегату:\n\n* по `count(*)`, чтобы сначала показать группы с наибольшим количеством элементов\n\n* по `avg(rental_rate)`, чтобы сначала показать фильмы с наивысшим рейтингом. Обратите внимание, что в примере это делается через псевдоним: `avg(rental_rate)` сначала сопоставлен с `avg` в списке `SELECT`, а затем мы просто делаем `ORDER BY avg`\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_30\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_31\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_32\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n<!-- example group3 -->\n\n##### GROUP BY по нескольким полям одновременно\n\nВ некоторых случаях вы можете захотеть группировать не только по одному полю, но по нескольким сразу, например, по категории фильма и году:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_34\n\n<!-- response SQL -->\n\nCODE_BLOCK_35\n\n<!-- request JSON -->\n\nCODE_BLOCK_36\n\n<!-- response JSON -->\n\nCODE_BLOCK_37\n\n<!-- end -->\n\n<!-- example group4 -->\n\n##### Дайте мне N строк\n\nИногда полезно видеть не только один элемент на группу, но и несколько. Это легко достигается с помощью `GROUP N BY`. Например, в следующем случае мы получаем два фильма для каждого года вместо одного, который вернул бы простой `GROUP BY release_year`.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_38\n\n<!-- response SQL -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example group5 -->\n\n##### Сортировка внутри группы\n\nЕще одно важное требование для аналитики — сортировка элементов внутри группы. Для этого используйте конструкцию `WITHIN GROUP ORDER BY ... {ASC|DESC}`. Например, получим фильм с наивысшим рейтингом для каждого года. Обратите внимание, что это работает параллельно с обычным `ORDER BY`:\n\n* `WITHIN GROUP ORDER BY` сортирует результаты **внутри группы**\n\n* а простой `GROUP BY` **сортирует сами группы**\n\nЭти два работают полностью независимо.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_40\n\n<!-- response SQL -->\n\nCODE_BLOCK_41\n\n<!-- end -->\n\n<!-- example group6 -->\n\n##### Фильтрация групп\n\n`HAVING expression` — полезная конструкция для фильтрации групп. В то время как `WHERE` применяется до группировки, `HAVING` работает с уже сгруппированными данными. Например, оставим только те года, когда средний рейтинг аренды фильмов за этот год был выше 3. В итоге мы получаем только четыре года:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_42\n\n<!-- response SQL -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n<!-- example group7 -->\n\n##### GROUPBY()"
    },
    "is_code_or_comment": false
  },
  "e7208864ffb1c2cc0588fbaa1ea4285aa03b26c182e2acd247ff6e721ca02b7f": {
    "original": "Manticore will try to increase `max_matches` up to [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold) if it detects that groupby may return inaccurate results. Detection is based on the number of unique values of the groupby attribute, which is retrieved from secondary indexes (if present).\n\nTo ensure accurate aggregates and/or group counts when using RT tables or `pseudo_sharding`, `accurate_aggregation` can be enabled. This will try to increase `max_matches` up to the threshold, and if the threshold is not high enough, Manticore will disable parallel processing for the query.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_123\n\n<!-- request JSON -->\n\nCODE_BLOCK_124\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "Manticore 将尝试将 `max_matches` 增加到 [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold)，如果它检测到 groupby 可能返回不准确的结果。检测基于 groupby 属性的唯一值数量，这些值是从二级索引（如果存在）中检索的。\n\n为了确保在使用 RT 表或 `pseudo_sharding` 时聚合和/或组计数的准确性，可以启用 `accurate_aggregation`。这将尝试将 `max_matches` 增加到阈值，如果阈值不够高，Manticore 将禁用该查询的并行处理。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_123\n\n<!-- request JSON -->\n\nCODE_BLOCK_124\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "Manticore попробует увеличить `max_matches` до [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold), если обнаружит, что groupby может возвращать неточные результаты. Обнаружение основывается на количестве уникальных значений атрибута groupby, которые извлекаются из вторичных индексов (если они присутствуют).\n\nДля обеспечения точных агрегатов и/или подсчёта групп при использовании RT таблиц или `pseudo_sharding` можно включить `accurate_aggregation`. Это попытается увеличить `max_matches` до порога, а если порог недостаточно высок, Manticore отключит параллельную обработку для запроса.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_123\n\n<!-- request JSON -->\n\nCODE_BLOCK_124\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "aa4599aa8618029ed698b5dbd78eec3880845ccf8f539bc14906a479cd20ab1b": {
    "original": "# Grouping search results\n\n<!-- example general -->\n\nGrouping search results is often helpful for obtaining per-group match counts or other aggregations. For example, it's useful for creating a graph illustrating the number of matching blog posts per month or grouping web search results by site or forum posts by author, etc.\n\nManticore supports the grouping of search results by single or multiple columns and computed expressions. The results can:\n\n* Be sorted within a group\n\n* Return more than one row per group\n\n* Have groups filtered\n\n* Have groups sorted\n\n* Be aggregated using the [aggregation functions](../Searching/Grouping.md#Aggregation-functions)\n\n<!-- intro -->\n\nThe general syntax is:\n\n<!-- request SQL -->\n\nGeneral syntax\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nJSON query format currently supports a basic grouping that can retrieve aggregate values and their count(*).\n\nCODE_BLOCK_1\n\nThe standard query output returns the result set without grouping, which can be hidden using `limit` (or `size`).\n\nThe aggregation requires setting a `size` for the group's result set size.\n\n<!-- end -->\n\n<!-- example group1 -->\n\n### Just Grouping\n\nGrouping is quite simple - just add \"GROUP BY smth\" to the end of your `SELECT` query. The something can be:\n\n* Any non-full-text field from the table: integer, float, string, MVA (multi-value attribute)\n\n* Or, if you used an alias in the `SELECT` list, you can GROUP BY it too\n\nYou can omit any [aggregation functions](../Searching/Grouping.md#Aggregation-functions) in the `SELECT` list and it will still work:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- request JSON -->\n\nCODE_BLOCK_4\n\n<!-- response JSON -->\n\nCODE_BLOCK_5\n\n<!-- end -->\n\n<!-- example group2 -->\n\nIn most cases, however, you'll want to obtain some aggregated data for each group, such as:\n\n* `COUNT(*)` to simply get the number of elements in each group\n\n* or `AVG(field)` to calculate the average value of the field within the group\n\nFor HTTP JSON requests, using a single `aggs` bucket with `limit=0` at the main query level works similarly to a SQL query with `GROUP BY` and `COUNT(*)`, providing equivalent behavior and performance.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_6\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_7\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_8\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_9\n\n<!-- request JSON -->\n\nCODE_BLOCK_10\n\n<!-- response JSON -->\n\nCODE_BLOCK_11\n\n<!-- request PHP -->\n\nCODE_BLOCK_12\n\n<!-- response PHP -->\n\nCODE_BLOCK_13\n\n<!-- request Python -->\n\nCODE_BLOCK_14\n\n<!-- response Python -->\n\nCODE_BLOCK_15\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_16\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_17\n\n<!-- request Javascript -->\n\nCODE_BLOCK_18\n\n<!-- response Javascript -->\n\nCODE_BLOCK_19\n\n<!-- request Java -->\n\nCODE_BLOCK_20\n\n<!-- response Java -->\n\nCODE_BLOCK_21\n\n<!-- request C# -->\n\nCODE_BLOCK_22\n\n<!-- response C# -->\n\nCODE_BLOCK_23\n\n<!-- request Rust -->\n\nCODE_BLOCK_24\n\n<!-- response Rust -->\n\nCODE_BLOCK_25\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_26\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_27\n\n<!-- request Go -->\n\nCODE_BLOCK_28\n\n<!-- response Go -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n<!-- example sort1 -->\n\n##### Sorting groups\n\nBy default, groups are not sorted, and the next thing you typically want to do is order them by something, like the field you're grouping by:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_30\n\n<!-- response SQL -->\n\nCODE_BLOCK_31\n\n<!-- request JSON -->\n\nCODE_BLOCK_32\n\n<!-- response JSON -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n<!-- example sort2 -->\n\nAlternatively, you can sort by the aggregation:\n\n* by `count(*)` to display groups with the most elements first\n\n* by `avg(rental_rate)` to show the highest-rated movies first. Note that in the example, it's done via an alias: `avg(rental_rate)` is first mapped to `avg` in the `SELECT` list, and then we simply do `ORDER BY avg`\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_34\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_35\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_36\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_37\n\n<!-- request JSON -->\n\nCODE_BLOCK_38\n\n<!-- response JSON -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example group3 -->\n\n##### GROUP BY multiple fields at once\n\nIn some cases, you might want to group not just by a single field, but by multiple fields at once, such as a movie's category and year:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_40\n\n<!-- response SQL -->\n\nCODE_BLOCK_41\n\n<!-- request JSON -->\n\nCODE_BLOCK_42\n\n<!-- response JSON -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n<!-- example group4 -->\n\n##### Give me N rows\n\nSometimes it's useful to see not just a single element per group, but multiple. This can be easily achieved with the help of `GROUP N BY`. For example, in the following case, we get two movies for each year rather than just one, which a simple `GROUP BY release_year` would have returned.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_44\n\n<!-- response SQL -->\n\nCODE_BLOCK_45\n\n<!-- request JSON -->\n\nCODE_BLOCK_46\n\n<!-- response JSON -->\n\nCODE_BLOCK_47\n\n<!-- end -->\n\n<!-- example group5 -->\n\n##### Sorting inside a group\n\nAnother crucial analytics requirement is to sort elements within a group. To achieve this, use the `WITHIN GROUP ORDER BY ... {ASC|DESC}` clause. For example, let's get the highest-rated film for each year. Note that it works in parallel with just `ORDER BY`:\n\n* `WITHIN GROUP ORDER BY` sorts results **inside a group**\n\n* while just `GROUP BY` **sorts the groups themselves**\n\nThese two work entirely independently.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- response SQL -->\n\nCODE_BLOCK_49\n\n<!-- request JSON -->\n\nCODE_BLOCK_50\n\n<!-- response JSON -->\n\nCODE_BLOCK_51\n\n<!-- end -->\n\n<!-- example group6 -->\n\n##### Filter groups",
    "translations": {
      "chinese": "# 分组搜索结果\n\n<!-- example general -->\n\n分组搜索结果通常有助于获得每个组的匹配计数或其他聚合。例如，它对于创建显示每月匹配博客文章数量的图表，或者按网站对网络搜索结果分组，或按作者对论坛帖子分组等非常有用。\n\nManticore 支持按单列或多列以及计算表达式对搜索结果进行分组。结果可以：\n\n* 在组内排序\n\n* 每组返回多行\n\n* 过滤组\n\n* 对组排序\n\n* 使用[聚合函数](../Searching/Grouping.md#Aggregation-functions)进行聚合\n\n<!-- intro -->\n\n一般语法是：\n\n<!-- request SQL -->\n\n通用语法\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nJSON 查询格式当前支持基本分组，可以检索聚合值及其 count(*)。\n\nCODE_BLOCK_1\n\n标准查询输出返回未分组的结果集，可以使用 `limit`（或 `size`）将其隐藏。\n\n聚合需要设置组结果集大小的 `size`。\n\n<!-- end -->\n\n<!-- example group1 -->\n\n### 仅分组\n\n分组非常简单——只需在 `SELECT` 查询末尾添加 \"GROUP BY smth\"。这里的某物可以是：\n\n* 表中的任何非全文字段：整数、浮点数、字符串、多值属性（MVA）\n\n* 或者，如果你在 `SELECT` 列表中使用了别名，也可以按该别名分组\n\n你可以在 `SELECT` 列表中省略任何[聚合函数](../Searching/Grouping.md#Aggregation-functions)，它仍然可以工作：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- request JSON -->\n\nCODE_BLOCK_4\n\n<!-- response JSON -->\n\nCODE_BLOCK_5\n\n<!-- end -->\n\n<!-- example group2 -->\n\n不过在大多数情况下，你会想获得每个组的一些聚合数据，比如：\n\n* `COUNT(*)` 仅获取每组元素数量\n\n* 或 `AVG(field)` 计算组内字段的平均值\n\n对于 HTTP JSON 请求，主查询层使用单个带 `limit=0` 的 `aggs` bucket，效果类似于 SQL 查询中的 `GROUP BY` 和 `COUNT(*)`，提供等效的行为和性能。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_6\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_7\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_8\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_9\n\n<!-- request JSON -->\n\nCODE_BLOCK_10\n\n<!-- response JSON -->\n\nCODE_BLOCK_11\n\n<!-- request PHP -->\n\nCODE_BLOCK_12\n\n<!-- response PHP -->\n\nCODE_BLOCK_13\n\n<!-- request Python -->\n\nCODE_BLOCK_14\n\n<!-- response Python -->\n\nCODE_BLOCK_15\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_16\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_17\n\n<!-- request Javascript -->\n\nCODE_BLOCK_18\n\n<!-- response Javascript -->\n\nCODE_BLOCK_19\n\n<!-- request Java -->\n\nCODE_BLOCK_20\n\n<!-- response Java -->\n\nCODE_BLOCK_21\n\n<!-- request C# -->\n\nCODE_BLOCK_22\n\n<!-- response C# -->\n\nCODE_BLOCK_23\n\n<!-- request Rust -->\n\nCODE_BLOCK_24\n\n<!-- response Rust -->\n\nCODE_BLOCK_25\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_26\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_27\n\n<!-- request Go -->\n\nCODE_BLOCK_28\n\n<!-- response Go -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n<!-- example sort1 -->\n\n##### 分组排序\n\n默认情况下，组不排序，通常接下来你会想按某个字段排序，比如你分组的字段：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_30\n\n<!-- response SQL -->\n\nCODE_BLOCK_31\n\n<!-- request JSON -->\n\nCODE_BLOCK_32\n\n<!-- response JSON -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n<!-- example sort2 -->\n\n或者，你可以按聚合排序：\n\n* 按 `count(*)` 显示元素最多的组优先\n\n* 按 `avg(rental_rate)` 显示评分最高的电影优先。注意在示例中是通过别名完成的：`avg(rental_rate)` 首先映射为 `avg`，然后直接使用 `ORDER BY avg`\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_34\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_35\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_36\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_37\n\n<!-- request JSON -->\n\nCODE_BLOCK_38\n\n<!-- response JSON -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example group3 -->\n\n##### 同时按多个字段 GROUP BY\n\n有时，你可能想不仅按单个字段分组，而是同时按多个字段，比如电影的类别和年份：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_40\n\n<!-- response SQL -->\n\nCODE_BLOCK_41\n\n<!-- request JSON -->\n\nCODE_BLOCK_42\n\n<!-- response JSON -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n<!-- example group4 -->\n\n##### 每组返回 N 行\n\n有时不仅想查看每组一个元素，而是多个，这可以通过 `GROUP N BY` 轻松实现。例如，下面的情况我们每年获取两部电影，而不是简单的 `GROUP BY release_year` 只返回一部。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_44\n\n<!-- response SQL -->\n\nCODE_BLOCK_45\n\n<!-- request JSON -->\n\nCODE_BLOCK_46\n\n<!-- response JSON -->\n\nCODE_BLOCK_47\n\n<!-- end -->\n\n<!-- example group5 -->\n\n##### 组内排序\n\n另一个关键的分析需求是对组内元素排序。为此，使用 `WITHIN GROUP ORDER BY ... {ASC|DESC}` 子句。例如，我们想获取每年评分最高的电影。注意它与简单的 `ORDER BY` 并行工作：\n\n* `WITHIN GROUP ORDER BY` 用于排序**组内结果**\n\n* 而简单的 `GROUP BY` **排序的是组本身**\n\n两者彼此完全独立。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- response SQL -->\n\nCODE_BLOCK_49\n\n<!-- request JSON -->\n\nCODE_BLOCK_50\n\n<!-- response JSON -->\n\nCODE_BLOCK_51\n\n<!-- end -->\n\n<!-- example group6 -->\n\n##### 过滤组",
      "russian": "# Группировка результатов поиска\n\n<!-- example general -->\n\nГруппировка результатов поиска часто полезна для получения количества совпадений по каждой группе или других агрегатов. Например, это удобно для создания графика с количеством подходящих блог-постов по месяцам или группировки результатов веб-поиска по сайтам, форумных сообщений по авторам и т.д.\n\nManticore поддерживает группировку результатов поиска по одному или нескольким столбцам и вычисляемым выражениям. Результаты могут:\n\n* Быть отсортированы внутри группы\n\n* Возвращать более одной строки на группу\n\n* Фильтровать группы\n\n* Сортировать группы\n\n* Агрегироваться с использованием [функций агрегации](../Searching/Grouping.md#Aggregation-functions)\n\n<!-- intro -->\n\nОбщий синтаксис:\n\n<!-- request SQL -->\n\nОбщий синтаксис\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nФормат JSON-запроса на данный момент поддерживает базовую группировку, которая может извлекать агрегированные значения и их count(*).\n\nCODE_BLOCK_1\n\nСтандартный результат запроса возвращает набор без группировки, который можно скрыть с помощью `limit` (или `size`).\n\nДля агрегации необходимо задать `size` в размере набора результатов для группы.\n\n<!-- end -->\n\n<!-- example group1 -->\n\n### Просто группировка\n\nГруппировка достаточно проста - просто добавьте \"GROUP BY smth\" в конец вашего `SELECT` запроса. Что-то может быть:\n\n* Любым не полнотекстовым полем из таблицы: integer, float, string, MVA (мульти-значение атрибута)\n\n* Или, если вы использовали псевдоним в списке `SELECT`, вы также можете группировать по нему\n\nВы можете опустить любые [функции агрегации](../Searching/Grouping.md#Aggregation-functions) в списке `SELECT`, и это продолжит работать:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- request JSON -->\n\nCODE_BLOCK_4\n\n<!-- response JSON -->\n\nCODE_BLOCK_5\n\n<!-- end -->\n\n<!-- example group2 -->\n\nВ большинстве случаев, однако, вы захотите получить некоторые агрегированные данные для каждой группы, такие как:\n\n* `COUNT(*)`, чтобы просто получить количество элементов в каждой группе\n\n* или `AVG(field)`, чтобы вычислить среднее значение поля внутри группы\n\nДля HTTP JSON-запросов использование одного `aggs` bucket с `limit=0` на основном уровне запроса работает аналогично SQL запросу с `GROUP BY` и `COUNT(*)`, обеспечивая эквивалентное поведение и производительность.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_6\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_7\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_8\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_9\n\n<!-- request JSON -->\n\nCODE_BLOCK_10\n\n<!-- response JSON -->\n\nCODE_BLOCK_11\n\n<!-- request PHP -->\n\nCODE_BLOCK_12\n\n<!-- response PHP -->\n\nCODE_BLOCK_13\n\n<!-- request Python -->\n\nCODE_BLOCK_14\n\n<!-- response Python -->\n\nCODE_BLOCK_15\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_16\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_17\n\n<!-- request Javascript -->\n\nCODE_BLOCK_18\n\n<!-- response Javascript -->\n\nCODE_BLOCK_19\n\n<!-- request Java -->\n\nCODE_BLOCK_20\n\n<!-- response Java -->\n\nCODE_BLOCK_21\n\n<!-- request C# -->\n\nCODE_BLOCK_22\n\n<!-- response C# -->\n\nCODE_BLOCK_23\n\n<!-- request Rust -->\n\nCODE_BLOCK_24\n\n<!-- response Rust -->\n\nCODE_BLOCK_25\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_26\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_27\n\n<!-- request Go -->\n\nCODE_BLOCK_28\n\n<!-- response Go -->\n\nCODE_BLOCK_29\n\n<!-- end -->\n\n<!-- example sort1 -->\n\n##### Сортировка групп\n\nПо умолчанию группы не сортируются, и следующая типичная операция — отсортировать их по чему-либо, например, по полю, по которому ведется группировка:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_30\n\n<!-- response SQL -->\n\nCODE_BLOCK_31\n\n<!-- request JSON -->\n\nCODE_BLOCK_32\n\n<!-- response JSON -->\n\nCODE_BLOCK_33\n\n<!-- end -->\n\n<!-- example sort2 -->\n\nИли же можно сортировать по агрегату:\n\n* по `count(*)`, чтобы показывать группы с наибольшим количеством элементов первыми\n\n* по `avg(rental_rate)`, чтобы показывать фильмы с самым высоким рейтингом первыми. Обратите внимание, что в примере это сделано через псевдоним: `avg(rental_rate)` сначала отображается в `avg` в списке `SELECT`, а потом мы просто делаем `ORDER BY avg`\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL1 -->\n\nCODE_BLOCK_34\n\n<!-- response SQL1 -->\n\nCODE_BLOCK_35\n\n<!-- request SQL2 -->\n\nCODE_BLOCK_36\n\n<!-- response SQL2 -->\n\nCODE_BLOCK_37\n\n<!-- request JSON -->\n\nCODE_BLOCK_38\n\n<!-- response JSON -->\n\nCODE_BLOCK_39\n\n<!-- end -->\n\n<!-- example group3 -->\n\n##### GROUP BY по нескольким полям одновременно\n\nВ некоторых случаях вы можете захотеть группировать не только по одному полю, но и по нескольким сразу, например, по категории фильма и году:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_40\n\n<!-- response SQL -->\n\nCODE_BLOCK_41\n\n<!-- request JSON -->\n\nCODE_BLOCK_42\n\n<!-- response JSON -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n<!-- example group4 -->\n\n##### Дайте мне N строк\n\nИногда полезно видеть не только один элемент на группу, а несколько. Это легко достигается с помощью `GROUP N BY`. Например, в следующем случае мы получаем два фильма для каждого года вместо одного, что вернул бы простой `GROUP BY release_year`.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_44\n\n<!-- response SQL -->\n\nCODE_BLOCK_45\n\n<!-- request JSON -->\n\nCODE_BLOCK_46\n\n<!-- response JSON -->\n\nCODE_BLOCK_47\n\n<!-- end -->\n\n<!-- example group5 -->\n\n##### Сортировка внутри группы\n\nЕще одно важное требование аналитики — сортировать элементы внутри группы. Для этого используйте конструкцию `WITHIN GROUP ORDER BY ... {ASC|DESC}`. Например, получим фильм с наивысшим рейтингом за каждый год. Обратите внимание, что это работает параллельно с обычным `ORDER BY`:\n\n* `WITHIN GROUP ORDER BY` сортирует результаты **внутри группы**\n\n* в то время как просто `GROUP BY` **сортирует сами группы**\n\nЭти два работают полностью независимо.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_48\n\n<!-- response SQL -->\n\nCODE_BLOCK_49\n\n<!-- request JSON -->\n\nCODE_BLOCK_50\n\n<!-- response JSON -->\n\nCODE_BLOCK_51\n\n<!-- end -->\n\n<!-- example group6 -->\n\n##### Фильтрация групп"
    },
    "is_code_or_comment": false
  },
  "d21ec20dc8e7de7851bc025b62f9df7d8ab74014dbf499b677c37f462ff1c756": {
    "original": "`HAVING expression` is a helpful clause for filtering groups. While `WHERE` is applied before grouping, `HAVING` works with the groups. For example, let's keep only those years when the average rental rate of the films for that year was higher than 3. We get only four years:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_52\n\n<!-- response SQL -->\n\nCODE_BLOCK_53\n\n<!-- request JSON -->\n\nCODE_BLOCK_54\n\n<!-- response JSON -->\n\nCODE_BLOCK_55\n\n<!-- end -->\n\n<!-- example group7 -->\n\n##### GROUPBY()\n\nThere is a function `GROUPBY()` which returns the key of the current group. It's useful in many cases, especially when you [GROUP BY an MVA](../Searching/Grouping.md#Grouping-by-MVA-%28multi-value-attributes%29) or a [JSON value](../Searching/Grouping.md#Grouping-by-a-JSON-node).\n\nIt can also be used in `HAVING`, for example, to keep only years 2000 and 2002.\n\nNote that `GROUPBY()`is not recommended for use when you GROUP BY multiple fields at once. It will still work, but since the group key in this case is a compound of field values, it may not appear the way you expect.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_56\n\n<!-- response SQL -->\n\nCODE_BLOCK_57\n\n<!-- request JSON -->\n\nCODE_BLOCK_58\n\n<!-- response JSON -->\n\nCODE_BLOCK_59\n\n<!-- end -->\n\n<!-- example mva -->\n\n##### Grouping by MVA (multi-value attributes)\n\nManticore supports grouping by [MVA](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29). To demonstrate how it works, let's create a table \"shoes\" with MVA \"sizes\" and insert a few documents into it:\n\nCODE_BLOCK_60\n\nso we have:\n\nCODE_BLOCK_61\n\nIf we now GROUP BY \"sizes\", it will process all our multi-value attributes and return an aggregation for each, in this case just the count:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_62\n\n<!-- response SQL -->\n\nCODE_BLOCK_63\n\n<!-- request JSON -->\n\nCODE_BLOCK_64\n\n<!-- response JSON -->\n\nCODE_BLOCK_65\n\n<!-- request PHP -->\n\nCODE_BLOCK_66\n\n<!-- response PHP -->\n\nCODE_BLOCK_67\n\n<!-- request Python -->\n\nCODE_BLOCK_68\n\n<!-- response Python -->\n\nCODE_BLOCK_69\n\n<!-- request Javascript -->\n\nCODE_BLOCK_70\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_71\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_72\n\n<!-- request Javascript -->\n\nCODE_BLOCK_73\n\n<!-- response Javascript -->\n\nCODE_BLOCK_74\n\n<!-- request Java -->\n\nCODE_BLOCK_75\n\n<!-- response Java -->\n\nCODE_BLOCK_76\n\n<!-- request C# -->\n\nCODE_BLOCK_77\n\n<!-- response C# -->\n\nCODE_BLOCK_78\n\n<!-- request Rust -->\n\nCODE_BLOCK_79\n\n<!-- response Rust -->\n\nCODE_BLOCK_80\n\nres = await searchApi.search({\n\n  index: 'test',\n\n  aggs: {\n\n    mva_agg: {\n\n      terms: { field: \"mva_field\", size: 2 }\n\n    }\n\n  }\n\n});\n\nCODE_BLOCK_81\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":4,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_82\n\nquery := map[string]interface{} {};\n\nsearchRequest.SetQuery(query);\n\naggTerms := manticoreclient.NewAggregationTerms()\n\naggTerms.SetField(\"mva_field\")\n\naggTerms.SetSize(2)\n\naggregation := manticoreclient.NewAggregation()\n\naggregation.setTerms(aggTerms)\n\nsearchRequest.SetAggregation(aggregation)\n\nres, _, _ := apiClient.SearchAPI.Search(context.Background()).SearchRequest(*searchRequest).Execute()\n\nCODE_BLOCK_83\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":5,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_84\n\ncreate table products(title text, meta json);\n\ninsert into products values(0,'nike','{\"color\":\"red\"}'),(0,'adidas','{\"color\":\"red\"}'),(0,'puma','{\"color\":\"green\"}');\n\nCODE_BLOCK_85\n\nSELECT * FROM products;\n\n+---------------------+-------------------+--------+\n\n| id                  | meta              | title  |\n\n+---------------------+-------------------+--------+\n\n| 1657851069130080268 | {\"color\":\"red\"}   | nike   |\n\n| 1657851069130080269 | {\"color\":\"red\"}   | adidas |\n\n| 1657851069130080270 | {\"color\":\"green\"} | puma   |\n\n+---------------------+-------------------+--------+\n\nCODE_BLOCK_86\n\nSELECT groupby() color, count(*) from products GROUP BY meta.color;\n\nCODE_BLOCK_87\n\n+-------+----------+\n\n| color | count(*) |\n\n+-------+----------+\n\n| red   |        2 |\n\n| green |        1 |\n\n+-------+----------+\n\nCODE_BLOCK_88\n\nPOST /search -d '\n\n    {\n\n     \"table\" : \"products\",\n\n     \"limit\": 0,\n\n     \"aggs\" :\n\n     {\n\n        \"color\" :\n\n         {\n\n            \"terms\" :\n\n             {\n\n              \"field\":\"meta.color\",\n\n              \"size\":100\n\n             }\n\n         }\n\n     }\n\n    }\n\n'\n\nCODE_BLOCK_89\n\n{\n\n  \"took\": 0,\n\n  \"timed_out\": false,\n\n  \"hits\": {\n\n    \"total\": 3,\n\n    \"hits\": [\n\n    ]\n\n  },\n\n  \"aggregations\": {\n\n    \"color\": {\n\n      \"buckets\": [\n\n        {\n\n          \"key\": \"green\",\n\n          \"doc_count\": 1\n\n        },\n\n        {\n\n          \"key\": \"red\",\n\n          \"doc_count\": 2\n\n        }\n\n      ]\n\n    }\n\n  }\n\n}\n\nCODE_BLOCK_90\n\n$index->setName('products');\n\n$search = $index->search('');\n\n$search->limit(0);\n\n$search->facet('meta.color','color',100);\n\n$results = $search->get();\n\nprint_r($results->getFacets());\n\nCODE_BLOCK_91\n\nArray\n\n(\n\n    [color] => Array\n\n        (\n\n            [buckets] => Array\n\n                (\n\n                    [0] => Array\n\n                        (\n\n                            [key] => green\n\n                            [doc_count] => 1\n\n                        )\n\n                    [1] => Array\n\n                        (\n\n                            [key] => red\n\n                            [doc_count] => 2\n\n                        )\n\n                )\n\n        )\n\n)\n\nCODE_BLOCK_92\n\nres =searchApi.search({\"table\":\"products\",\"limit\":0,\"aggs\":{\"color\":{\"terms\":{\"field\":\"meta.color\",\"size\":100}}}})\n\nCODE_BLOCK_93\n\n{'aggregations': {u'color': {u'buckets': [{u'doc_count': 1,\n\n                                           u'key': u'green'},\n\n                                          {u'doc_count': 2, u'key': u'red'}]}},",
    "translations": {
      "chinese": "`HAVING expression` 是一个用于过滤分组的有用子句。虽然 `WHERE` 在分组之前应用，`HAVING` 则作用于分组。例如，我们只保留那些该年份电影的平均租赁费率高于 3 的年份。结果只剩下四个年份：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_52\n\n<!-- response SQL -->\n\nCODE_BLOCK_53\n\n<!-- request JSON -->\n\nCODE_BLOCK_54\n\n<!-- response JSON -->\n\nCODE_BLOCK_55\n\n<!-- end -->\n\n<!-- example group7 -->\n\n##### GROUPBY()\n\n有一个函数 `GROUPBY()`，它返回当前分组的键。在很多情况下非常有用，特别是当你[对 MVA 进行 GROUP BY](../Searching/Grouping.md#Grouping-by-MVA-%28multi-value-attributes%29)或对[JSON 值进行 GROUP BY](../Searching/Grouping.md#Grouping-by-a-JSON-node)时。\n\n它也可以在 `HAVING` 中使用，例如，只保留年份 2000 和 2002。\n\n注意，当你同时对多个字段进行 GROUP BY 时，不推荐使用 `GROUPBY()`。它仍然可以工作，但由于此时分组键是字段值的复合，可能不会按你预期的方式显示。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_56\n\n<!-- response SQL -->\n\nCODE_BLOCK_57\n\n<!-- request JSON -->\n\nCODE_BLOCK_58\n\n<!-- response JSON -->\n\nCODE_BLOCK_59\n\n<!-- end -->\n\n<!-- example mva -->\n\n##### 按 MVA（多值属性）分组\n\nManticore 支持按[MVA](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29)分组。为演示其工作方式，我们创建一个带有 MVA “sizes” 的表 \"shoes\"，并插入几条文档：\n\nCODE_BLOCK_60\n\n所以我们有：\n\nCODE_BLOCK_61\n\n如果我们现在对 \"sizes\" 进行 GROUP BY，它会处理所有的多值属性，并为每个值返回一个聚合，在此例中只是计数：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_62\n\n<!-- response SQL -->\n\nCODE_BLOCK_63\n\n<!-- request JSON -->\n\nCODE_BLOCK_64\n\n<!-- response JSON -->\n\nCODE_BLOCK_65\n\n<!-- request PHP -->\n\nCODE_BLOCK_66\n\n<!-- response PHP -->\n\nCODE_BLOCK_67\n\n<!-- request Python -->\n\nCODE_BLOCK_68\n\n<!-- response Python -->\n\nCODE_BLOCK_69\n\n<!-- request Javascript -->\n\nCODE_BLOCK_70\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_71\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_72\n\n<!-- request Javascript -->\n\nCODE_BLOCK_73\n\n<!-- response Javascript -->\n\nCODE_BLOCK_74\n\n<!-- request Java -->\n\nCODE_BLOCK_75\n\n<!-- response Java -->\n\nCODE_BLOCK_76\n\n<!-- request C# -->\n\nCODE_BLOCK_77\n\n<!-- response C# -->\n\nCODE_BLOCK_78\n\n<!-- request Rust -->\n\nCODE_BLOCK_79\n\n<!-- response Rust -->\n\nCODE_BLOCK_80\n\nres = await searchApi.search({\n\n  index: 'test',\n\n  aggs: {\n\n    mva_agg: {\n\n      terms: { field: \"mva_field\", size: 2 }\n\n    }\n\n  }\n\n});\n\nCODE_BLOCK_81\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":4,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_82\n\nquery := map[string]interface{} {};\n\nsearchRequest.SetQuery(query);\n\naggTerms := manticoreclient.NewAggregationTerms()\n\naggTerms.SetField(\"mva_field\")\n\naggTerms.SetSize(2)\n\naggregation := manticoreclient.NewAggregation()\n\naggregation.setTerms(aggTerms)\n\nsearchRequest.SetAggregation(aggregation)\n\nres, _, _ := apiClient.SearchAPI.Search(context.Background()).SearchRequest(*searchRequest).Execute()\n\nCODE_BLOCK_83\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":5,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_84\n\ncreate table products(title text, meta json);\n\ninsert into products values(0,'nike','{\"color\":\"red\"}'),(0,'adidas','{\"color\":\"red\"}'),(0,'puma','{\"color\":\"green\"}');\n\nCODE_BLOCK_85\n\nSELECT * FROM products;\n\n+---------------------+-------------------+--------+\n\n| id                  | meta              | title  |\n\n+---------------------+-------------------+--------+\n\n| 1657851069130080268 | {\"color\":\"red\"}   | nike   |\n\n| 1657851069130080269 | {\"color\":\"red\"}   | adidas |\n\n| 1657851069130080270 | {\"color\":\"green\"} | puma   |\n\n+---------------------+-------------------+--------+\n\nCODE_BLOCK_86\n\nSELECT groupby() color, count(*) from products GROUP BY meta.color;\n\nCODE_BLOCK_87\n\n+-------+----------+\n\n| color | count(*) |\n\n+-------+----------+\n\n| red   |        2 |\n\n| green |        1 |\n\n+-------+----------+\n\nCODE_BLOCK_88\n\nPOST /search -d '\n\n    {\n\n     \"table\" : \"products\",\n\n     \"limit\": 0,\n\n     \"aggs\" :\n\n     {\n\n        \"color\" :\n\n         {\n\n            \"terms\" :\n\n             {\n\n              \"field\":\"meta.color\",\n\n              \"size\":100\n\n             }\n\n         }\n\n     }\n\n    }\n\n'\n\nCODE_BLOCK_89\n\n{\n\n  \"took\": 0,\n\n  \"timed_out\": false,\n\n  \"hits\": {\n\n    \"total\": 3,\n\n    \"hits\": [\n\n    ]\n\n  },\n\n  \"aggregations\": {\n\n    \"color\": {\n\n      \"buckets\": [\n\n        {\n\n          \"key\": \"green\",\n\n          \"doc_count\": 1\n\n        },\n\n        {\n\n          \"key\": \"red\",\n\n          \"doc_count\": 2\n\n        }\n\n      ]\n\n    }\n\n  }\n\n}\n\nCODE_BLOCK_90\n\n$index->setName('products');\n\n$search = $index->search('');\n\n$search->limit(0);\n\n$search->facet('meta.color','color',100);\n\n$results = $search->get();\n\nprint_r($results->getFacets());\n\nCODE_BLOCK_91\n\nArray\n\n(\n\n    [color] => Array\n\n        (\n\n            [buckets] => Array\n\n                (\n\n                    [0] => Array\n\n                        (\n\n                            [key] => green\n\n                            [doc_count] => 1\n\n                        )\n\n                    [1] => Array\n\n                        (\n\n                            [key] => red\n\n                            [doc_count] => 2\n\n                        )\n\n                )\n\n        )\n\n)\n\nCODE_BLOCK_92\n\nres =searchApi.search({\"table\":\"products\",\"limit\":0,\"aggs\":{\"color\":{\"terms\":{\"field\":\"meta.color\",\"size\":100}}}})\n\nCODE_BLOCK_93\n\n{'aggregations': {u'color': {u'buckets': [{u'doc_count': 1,\n\n                                           u'key': u'green'},\n\n                                          {u'doc_count': 2, u'key': u'red'}]}},",
      "russian": "`HAVING expression` — полезный оператор для фильтрации групп. В то время как `WHERE` применяется до группировки, `HAVING` работает с группами. Например, оставим только те годы, когда средняя арендная ставка фильмов за этот год была выше 3. Мы получим только четыре года:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_52\n\n<!-- response SQL -->\n\nCODE_BLOCK_53\n\n<!-- request JSON -->\n\nCODE_BLOCK_54\n\n<!-- response JSON -->\n\nCODE_BLOCK_55\n\n<!-- end -->\n\n<!-- example group7 -->\n\n##### GROUPBY()\n\nСуществует функция `GROUPBY()`, которая возвращает ключ текущей группы. Она полезна во многих случаях, особенно когда вы [GROUP BY по MVA](../Searching/Grouping.md#Grouping-by-MVA-%28multi-value-attributes%29) или по [JSON значению](../Searching/Grouping.md#Grouping-by-a-JSON-node).\n\nЕё также можно использовать в `HAVING`, например, чтобы оставить только годы 2000 и 2002.\n\nОбратите внимание, что `GROUPBY()` не рекомендуется использовать, когда вы группируете по нескольким полям одновременно. Она всё ещё будет работать, но поскольку ключ группы в этом случае является составным из значений полей, он может не отображаться так, как вы ожидаете.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_56\n\n<!-- response SQL -->\n\nCODE_BLOCK_57\n\n<!-- request JSON -->\n\nCODE_BLOCK_58\n\n<!-- response JSON -->\n\nCODE_BLOCK_59\n\n<!-- end -->\n\n<!-- example mva -->\n\n##### Группировка по MVA (многозначные атрибуты)\n\nManticore поддерживает группировку по [MVA](../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29). Чтобы показать, как это работает, создадим таблицу \"shoes\" с MVA \"sizes\" и вставим в неё несколько документов:\n\nCODE_BLOCK_60\n\nтаким образом у нас есть:\n\nCODE_BLOCK_61\n\nЕсли теперь мы сделаем GROUP BY по \"sizes\", будут обработаны все наши многозначные атрибуты и возвращена агрегация для каждого, в данном случае просто количество:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_62\n\n<!-- response SQL -->\n\nCODE_BLOCK_63\n\n<!-- request JSON -->\n\nCODE_BLOCK_64\n\n<!-- response JSON -->\n\nCODE_BLOCK_65\n\n<!-- request PHP -->\n\nCODE_BLOCK_66\n\n<!-- response PHP -->\n\nCODE_BLOCK_67\n\n<!-- request Python -->\n\nCODE_BLOCK_68\n\n<!-- response Python -->\n\nCODE_BLOCK_69\n\n<!-- request Javascript -->\n\nCODE_BLOCK_70\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_71\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_72\n\n<!-- request Javascript -->\n\nCODE_BLOCK_73\n\n<!-- response Javascript -->\n\nCODE_BLOCK_74\n\n<!-- request Java -->\n\nCODE_BLOCK_75\n\n<!-- response Java -->\n\nCODE_BLOCK_76\n\n<!-- request C# -->\n\nCODE_BLOCK_77\n\n<!-- response C# -->\n\nCODE_BLOCK_78\n\n<!-- request Rust -->\n\nCODE_BLOCK_79\n\n<!-- response Rust -->\n\nCODE_BLOCK_80\n\nres = await searchApi.search({\n\n  index: 'test',\n\n  aggs: {\n\n    mva_agg: {\n\n      terms: { field: \"mva_field\", size: 2 }\n\n    }\n\n  }\n\n});\n\nCODE_BLOCK_81\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":4,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_82\n\nquery := map[string]interface{} {};\n\nsearchRequest.SetQuery(query);\n\naggTerms := manticoreclient.NewAggregationTerms()\n\naggTerms.SetField(\"mva_field\")\n\naggTerms.SetSize(2)\n\naggregation := manticoreclient.NewAggregation()\n\naggregation.setTerms(aggTerms)\n\nsearchRequest.SetAggregation(aggregation)\n\nres, _, _ := apiClient.SearchAPI.Search(context.Background()).SearchRequest(*searchRequest).Execute()\n\nCODE_BLOCK_83\n\n{\n\n\t\"took\":0,\n\n\t\"timed_out\":false,\n\n\t\"aggregations\":\n\n\t{\n\n\t\t\"mva_agg\":\n\n\t\t{\n\n\t\t\t\"buckets\":\n\n\t\t\t[{\n\n\t\t\t\t\"key\":1,\n\n\t\t\t\t\"doc_count\":4\n\n\t\t\t},\n\n\t\t\t{\n\n\t\t\t\t\"key\":2,\n\n\t\t\t\t\"doc_count\":2\n\n\t\t\t}]\n\n\t\t}\n\n\t},\n\n\t\"hits\":\n\n\t{\n\n\t\t\"total\":5,\n\n\t\t\"hits\":[]\n\n\t}\n\n}\n\nCODE_BLOCK_84\n\ncreate table products(title text, meta json);\n\ninsert into products values(0,'nike','{\"color\":\"red\"}'),(0,'adidas','{\"color\":\"red\"}'),(0,'puma','{\"color\":\"green\"}');\n\nCODE_BLOCK_85\n\nSELECT * FROM products;\n\n+---------------------+-------------------+--------+\n\n| id                  | meta              | title  |\n\n+---------------------+-------------------+--------+\n\n| 1657851069130080268 | {\"color\":\"red\"}   | nike   |\n\n| 1657851069130080269 | {\"color\":\"red\"}   | adidas |\n\n| 1657851069130080270 | {\"color\":\"green\"} | puma   |\n\n+---------------------+-------------------+--------+\n\nCODE_BLOCK_86\n\nSELECT groupby() color, count(*) from products GROUP BY meta.color;\n\nCODE_BLOCK_87\n\n+-------+----------+\n\n| color | count(*) |\n\n+-------+----------+\n\n| red   |        2 |\n\n| green |        1 |\n\n+-------+----------+\n\nCODE_BLOCK_88\n\nPOST /search -d '\n\n    {\n\n     \"table\" : \"products\",\n\n     \"limit\": 0,\n\n     \"aggs\" :\n\n     {\n\n        \"color\" :\n\n         {\n\n            \"terms\" :\n\n             {\n\n              \"field\":\"meta.color\",\n\n              \"size\":100\n\n             }\n\n         }\n\n     }\n\n    }\n\n'\n\nCODE_BLOCK_89\n\n{\n\n  \"took\": 0,\n\n  \"timed_out\": false,\n\n  \"hits\": {\n\n    \"total\": 3,\n\n    \"hits\": [\n\n    ]\n\n  },\n\n  \"aggregations\": {\n\n    \"color\": {\n\n      \"buckets\": [\n\n        {\n\n          \"key\": \"green\",\n\n          \"doc_count\": 1\n\n        },\n\n        {\n\n          \"key\": \"red\",\n\n          \"doc_count\": 2\n\n        }\n\n      ]\n\n    }\n\n  }\n\n}\n\nCODE_BLOCK_90\n\n$index->setName('products');\n\n$search = $index->search('');\n\n$search->limit(0);\n\n$search->facet('meta.color','color',100);\n\n$results = $search->get();\n\nprint_r($results->getFacets());\n\nCODE_BLOCK_91\n\nArray\n\n(\n\n    [color] => Array\n\n        (\n\n            [buckets] => Array\n\n                (\n\n                    [0] => Array\n\n                        (\n\n                            [key] => green\n\n                            [doc_count] => 1\n\n                        )\n\n                    [1] => Array\n\n                        (\n\n                            [key] => red\n\n                            [doc_count] => 2\n\n                        )\n\n                )\n\n        )\n\n)\n\nCODE_BLOCK_92\n\nres =searchApi.search({\"table\":\"products\",\"limit\":0,\"aggs\":{\"color\":{\"terms\":{\"field\":\"meta.color\",\"size\":100}}}})\n\nCODE_BLOCK_93\n\n{'aggregations': {u'color': {u'buckets': [{u'doc_count': 1,\n\n                                           u'key': u'green'},\n\n                                          {u'doc_count': 2, u'key': u'red'}]}},"
    },
    "is_code_or_comment": false
  },
  "ce6b9c226a0862422e9f41cc030a4bf17e4affd4875f0d241309982eba72ad0b": {
    "original": " 'hits': {'hits': [], 'max_score': None, 'total': 3},\n\n 'profile': None,\n\n 'timed_out': False,\n\n 'took': 0}\n\nCODE_BLOCK_94\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_95\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_96\n\n<!-- request Javascript -->\n\nCODE_BLOCK_97\n\n<!-- response Javascript -->\n\nCODE_BLOCK_98\n\n<!-- request Java -->\n\nCODE_BLOCK_99\n\n<!-- response Java -->\n\nCODE_BLOCK_100\n\n<!-- request C# -->\n\nCODE_BLOCK_101\n\n<!-- response C# -->\n\nCODE_BLOCK_102\n\n<!-- request Rust -->\n\nCODE_BLOCK_103\n\n<!-- response Rust -->\n\nCODE_BLOCK_104\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_105\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_106\n\n<!-- request Go -->\n\nCODE_BLOCK_107\n\n<!-- response Go -->\n\nCODE_BLOCK_108\n\n<!-- end -->\n\n## Aggregation functions\n\nBesides `COUNT(*)`, which returns the number of elements in each group, you can use various other aggregation functions:\n\n<!-- example distinct -->\n\n##### COUNT(DISTINCT field)\n\nWhile `COUNT(*)` returns the number of all elements in the group, `COUNT(DISTINCT field)` returns the number of unique values of the field in the group, which may be completely different from the total count. For instance, you can have 100 elements in the group, but all with the same value for a certain field. `COUNT(DISTINCT field)` helps to determine that. To demonstrate this, let's create a table \"students\" with the student's name, age, and major:\n\nCODE_BLOCK_109\n\nso we have:\n\nCODE_BLOCK_110\n\nIn the example, you can see that if we GROUP BY major and display both `COUNT(*)` and `COUNT(DISTINCT age)`, it becomes clear that there are two students who chose the major \"cs\" with two unique ages, but for the major \"arts\", there are also two students, yet only one unique age.\n\nThere can be at most one `COUNT(DISTINCT)` per query.\n\n** By default, counts are approximate **\n\nActually, some of them are exact, while others are approximate. More on that below.\n\nManticore supports two algorithms for computing counts of distinct values. One is a legacy algorithm that uses a lot of memory and is usually slow. It collects `{group; value}` pairs, sorts them, and periodically discards duplicates. The benefit of this approach is that it guarantees exact counts within a plain table. You can enable it by setting the [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) option to `0`.\n\nThe other algorithm (enabled by default) loads counts into a hash table and returns its size. If the hash table becomes too large, its contents are moved into a `HyperLogLog`. This is where the counts become approximate since `HyperLogLog` is a probabilistic algorithm. The advantage is that the maximum memory usage per group is fixed and depends on the accuracy of the `HyperLogLog`. The overall memory usage also depends on the [max_matches](../Searching/Options.md#max_matches) setting, which reflects the number of groups.\n\nThe [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) option sets the threshold below which counts are guaranteed to be exact. The `HyperLogLog` accuracy setting and the threshold for the \"hash table to HyperLogLog\" conversion are derived from this setting. It's important to use this option with caution because doubling it will double the maximum memory required for count calculations. The maximum memory usage can be roughly estimated using this formula: `64 * max_matches * distinct_precision_threshold`. Note that this is the worst-case scenario, and in most cases, count calculations will use significantly less RAM.\n\n**`COUNT(DISTINCT)` against a distributed table or a real-time table consisting of multiple disk chunks may return inaccurate results**, but the result should be accurate for a distributed table consisting of local plain or real-time tables with the same schema (identical set/order of fields, but may have different tokenization settings).\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_111\n\n<!-- response SQL -->\n\nCODE_BLOCK_112\n\n<!-- request JSON -->\n\nCODE_BLOCK_113\n\n<!-- response JSON -->\n\nCODE_BLOCK_114\n\n<!-- end -->\n\n<!-- example concat -->\n\n##### GROUP_CONCAT(field)\n\nOften, you want to better understand the contents of each group. You can use [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) for that, but it would return additional rows you might not want in the output. `GROUP_CONCAT()` enriches your grouping by concatenating values of a specific field in the group. Let's take the previous example and improve it by displaying all the ages in each group.\n\n`GROUP_CONCAT(field)` returns the list as comma-separated values.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_115\n\n<!-- response SQL -->\n\nCODE_BLOCK_116\n\n<!-- request JSON -->\n\nCODE_BLOCK_117\n\n<!-- response JSON -->\n\nCODE_BLOCK_118\n\n<!-- end -->\n\n<!-- example sum -->\n\n##### SUM(), MIN(), MAX(), AVG()\n\nOf course, you can also obtain the sum, average, minimum, and maximum values within a group.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request SQL -->\n\nCODE_BLOCK_119\n\n<!-- response SQL -->\n\nCODE_BLOCK_120\n\n<!-- request JSON -->\n\nCODE_BLOCK_121\n\n<!-- response JSON -->\n\nCODE_BLOCK_122\n\n<!-- end -->\n\n<!-- example accuracy -->\n\n## Grouping accuracy\n\nGrouping is done in fixed memory, which depends on the [max_matches](../Searching/Options.md#max_matches) setting. If `max_matches` allows for storage of all found groups, the results will be 100% accurate. However, if the value of `max_matches` is lower, the results will be less accurate.\n\nWhen parallel processing is involved, it can become more complicated. When `pseudo_sharding` is enabled and/or when using an RT table with several disk chunks, each chunk or pseudo shard gets a result set that is no larger than `max_matches`. This can lead to inaccuracies in aggregates and group counts when the result sets from different threads are merged. To fix this, either a larger `max_matches` value or disabling parallel processing can be used.",
    "translations": {
      "chinese": " 'hits': {'hits': [], 'max_score': None, 'total': 3},\n\n 'profile': None,\n\n 'timed_out': False,\n\n 'took': 0}\n\nCODE_BLOCK_94\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_95\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_96\n\n<!-- request Javascript -->\n\nCODE_BLOCK_97\n\n<!-- response Javascript -->\n\nCODE_BLOCK_98\n\n<!-- request Java -->\n\nCODE_BLOCK_99\n\n<!-- response Java -->\n\nCODE_BLOCK_100\n\n<!-- request C# -->\n\nCODE_BLOCK_101\n\n<!-- response C# -->\n\nCODE_BLOCK_102\n\n<!-- request Rust -->\n\nCODE_BLOCK_103\n\n<!-- response Rust -->\n\nCODE_BLOCK_104\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_105\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_106\n\n<!-- request Go -->\n\nCODE_BLOCK_107\n\n<!-- response Go -->\n\nCODE_BLOCK_108\n\n<!-- end -->\n\n## 聚合函数\n\n除了返回每组元素数量的 `COUNT(*)` 外，你还可以使用各种其他聚合函数：\n\n<!-- example distinct -->\n\n##### COUNT(DISTINCT 字段)\n\n虽然 `COUNT(*)` 返回组中所有元素的数量，但 `COUNT(DISTINCT 字段)` 返回该字段在组中唯一值的数量，这可能与总数完全不同。例如，你可以有 100 个元素在组中，但它们某个字段的值都是相同的。`COUNT(DISTINCT 字段)` 有助于判断这一点。为演示此功能，创建一个包含学生姓名、年龄和专业的表 \"students\"：\n\nCODE_BLOCK_109\n\n所以我们有：\n\nCODE_BLOCK_110\n\n在示例中，你可以看到如果我们按专业进行 GROUP BY 并同时显示 `COUNT(*)` 和 `COUNT(DISTINCT age)`，很明显专业为 \"cs\" 的有两名学生，他们的年龄各不相同，而专业为 \"arts\" 的同样有两名学生，但是只有一个唯一年龄。\n\n每个查询最多只能有一个 `COUNT(DISTINCT)`。\n\n** 默认情况下，计数是近似的 **\n\n实际上，有些计数是精确的，有些是近似的。下面会详细说明。\n\nManticore 支持两种计算不同值计数的算法。一种是传统算法，使用大量内存且通常速度较慢。它收集 `{group; value}` 对，排序并定期剔除重复项。这种方法的好处是能保证在纯表中计数的精确。你可以通过将 [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) 选项设置为 `0` 来启用它。\n\n另一种算法（默认启用）将计数加载到哈希表中并返回其大小。如果哈希表变得过大，其内容会被移动至 `HyperLogLog`。这时计数成为近似值，因为 `HyperLogLog` 是概率算法。优点是每组最大内存使用固定，且依赖于 `HyperLogLog` 的精度。整体内存消耗也受 [max_matches](../Searching/Options.md#max_matches) 设置影响，该设置反映了组的数量。\n\n[distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) 选项设置了计数保证精确的阈值。`HyperLogLog` 的精度设置以及从哈希表转换到 `HyperLogLog` 的阈值都来源于该设置。使用此选项需谨慎，因为阈值加倍将使计算计数所需的最大内存加倍。最大内存使用可粗略估算为：`64 * max_matches * distinct_precision_threshold`。请注意这是最坏情况，大多数情况下计数计算会使用明显更少的内存。\n\n** 对分布式表或包含多个磁盘块的实时表执行 `COUNT(DISTINCT)` 可能返回不准确结果，**但对于由本地纯表或实时表（结构相同）组成的分布式表，结果应当准确（字段集合/顺序一致，但可能有不同的分词设置）。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_111\n\n<!-- response SQL -->\n\nCODE_BLOCK_112\n\n<!-- request JSON -->\n\nCODE_BLOCK_113\n\n<!-- response JSON -->\n\nCODE_BLOCK_114\n\n<!-- end -->\n\n<!-- example concat -->\n\n##### GROUP_CONCAT(字段)\n\n通常，你想更好地了解每个分组的内容。你可以使用 [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows) 来实现，但它会返回你可能不想要的额外行。`GROUP_CONCAT()` 通过将组中特定字段的值连接起来丰富你的分组。让我们用之前的例子来改进，通过显示每个组中所有年龄。\n\n`GROUP_CONCAT(字段)` 返回逗号分隔的值列表。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_115\n\n<!-- response SQL -->\n\nCODE_BLOCK_116\n\n<!-- request JSON -->\n\nCODE_BLOCK_117\n\n<!-- response JSON -->\n\nCODE_BLOCK_118\n\n<!-- end -->\n\n<!-- example sum -->\n\n##### SUM(), MIN(), MAX(), AVG()\n\n当然，你也可以获得组内的总和、平均值、最小值和最大值。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request SQL -->\n\nCODE_BLOCK_119\n\n<!-- response SQL -->\n\nCODE_BLOCK_120\n\n<!-- request JSON -->\n\nCODE_BLOCK_121\n\n<!-- response JSON -->\n\nCODE_BLOCK_122\n\n<!-- end -->\n\n<!-- example accuracy -->\n\n## 分组精度\n\n分组是在固定内存中完成的，内存大小取决于 [max_matches](../Searching/Options.md#max_matches) 设置。如果 `max_matches` 允许存储所有找到的组，结果将是 100% 精确的。然而，如果 `max_matches` 的值较小，则结果会降低准确性。\n\n当涉及并行处理时，情况会更复杂。启用 `pseudo_sharding` 和/或使用带有多个磁盘块的 RT 表时，每个块或伪分片获得的结果集大小不超过 `max_matches`。这可能在不同线程的结果集合并时导致聚合和分组计数不准确。为解决此问题，可以使用更大的 `max_matches` 值或禁用并行处理。",
      "russian": " 'hits': {'hits': [], 'max_score': None, 'total': 3},\n\n 'profile': None,\n\n 'timed_out': False,\n\n 'took': 0}\n\nCODE_BLOCK_94\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_95\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_96\n\n<!-- request Javascript -->\n\nCODE_BLOCK_97\n\n<!-- response Javascript -->\n\nCODE_BLOCK_98\n\n<!-- request Java -->\n\nCODE_BLOCK_99\n\n<!-- response Java -->\n\nCODE_BLOCK_100\n\n<!-- request C# -->\n\nCODE_BLOCK_101\n\n<!-- response C# -->\n\nCODE_BLOCK_102\n\n<!-- request Rust -->\n\nCODE_BLOCK_103\n\n<!-- response Rust -->\n\nCODE_BLOCK_104\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_105\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_106\n\n<!-- request Go -->\n\nCODE_BLOCK_107\n\n<!-- response Go -->\n\nCODE_BLOCK_108\n\n<!-- end -->\n\n## Функции агрегации\n\nКроме `COUNT(*)`, который возвращает количество элементов в каждой группе, вы можете использовать различные другие функции агрегации:\n\n<!-- example distinct -->\n\n##### COUNT(DISTINCT field)\n\nВ то время как `COUNT(*)` возвращает количество всех элементов в группе, `COUNT(DISTINCT field)` возвращает количество уникальных значений поля в группе, что может существенно отличаться от общего количества. Например, в группе может быть 100 элементов, но все с одинаковым значением определённого поля. `COUNT(DISTINCT field)` помогает это определить. Для демонстрации создадим таблицу \"students\" с именем студента, возрастом и специальностью:\n\nCODE_BLOCK_109\n\nтак что у нас есть:\n\nCODE_BLOCK_110\n\nВ примере видно, что если мы делаем GROUP BY по major и показываем одновременно `COUNT(*)` и `COUNT(DISTINCT age)`, становится ясно, что среди студентов, выбравших специальность \"cs\", двое и у них два уникальных возраста, а для специальности \"arts\" также двое студентов, но только один уникальный возраст.\n\nВ одном запросе может быть не более одного `COUNT(DISTINCT)`.\n\n**По умолчанию подсчёты приблизительные**\n\nНа самом деле, некоторые из них точные, а другие — приблизительные. Подробнее об этом ниже.\n\nManticore поддерживает два алгоритма подсчёта количества уникальных значений. Один — устаревший алгоритм, который использует много памяти и обычно медленный. Он собирает пары `{group; value}`, сортирует их и периодически удаляет дубликаты. Преимущество этого подхода в том, что он гарантирует точный подсчёт для простой таблицы. Его можно включить, установив опцию [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) в значение `0`.\n\nДругой алгоритм (включён по умолчанию) загружает подсчёты в хеш-таблицу и возвращает её размер. Если хеш-таблица становится слишком большой, её содержимое переносится в `HyperLogLog`. Здесь подсчёты становятся приблизительными, поскольку `HyperLogLog` — вероятностный алгоритм. Преимущество в том, что максимальное использование памяти на группу фиксировано и зависит от точности `HyperLogLog`. Общее потребление памяти также зависит от настройки [max_matches](../Searching/Options.md#max_matches), отражающей количество групп.\n\nОпция [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) задаёт порог, ниже которого подсчёты гарантированно точные. Настройки точности `HyperLogLog` и порог конверсии \"хеш-таблица в HyperLogLog\" выводятся из этой настройки. Важно с осторожностью использовать эту опцию, поскольку её удвоение приведёт к удвоению максимального объёма памяти, требуемой для подсчётов. Максимальное использование памяти примерно можно оценить формулой: `64 * max_matches * distinct_precision_threshold`. Учтите, что это наихудший сценарий, в большинстве случаев подсчёты используют существенно меньше оперативной памяти.\n\n**`COUNT(DISTINCT)` для распределённой таблицы или таблицы реального времени, состоящей из нескольких дисковых чанк, может возвращать неточные результаты**, но результат должен быть точным для распределённой таблицы, состоящей из локальных простых или таблиц реального времени с одинаковой схемой (идентичный набор/порядок полей, но настройки токенизации могут отличаться).\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_111\n\n<!-- response SQL -->\n\nCODE_BLOCK_112\n\n<!-- request JSON -->\n\nCODE_BLOCK_113\n\n<!-- response JSON -->\n\nCODE_BLOCK_114\n\n<!-- end -->\n\n<!-- example concat -->\n\n##### GROUP_CONCAT(field)\n\nЧасто хочется лучше понять содержимое каждой группы. Для этого можно использовать [GROUP N BY](../Searching/Grouping.md#Give-me-N-rows), но он вернёт дополнительные строки, которых может не быть в выводе. `GROUP_CONCAT()` обогащает группировку, объединяя значения конкретного поля в группе. Возьмём предыдущий пример и улучшим его, отобразив все возраста в каждой группе.\n\n`GROUP_CONCAT(field)` возвращает список через запятую.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_115\n\n<!-- response SQL -->\n\nCODE_BLOCK_116\n\n<!-- request JSON -->\n\nCODE_BLOCK_117\n\n<!-- response JSON -->\n\nCODE_BLOCK_118\n\n<!-- end -->\n\n<!-- example sum -->\n\n##### SUM(), MIN(), MAX(), AVG()\n\nРазумеется, можно получить сумму, среднее, минимальное и максимальное значения в группе.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request SQL -->\n\nCODE_BLOCK_119\n\n<!-- response SQL -->\n\nCODE_BLOCK_120\n\n<!-- request JSON -->\n\nCODE_BLOCK_121\n\n<!-- response JSON -->\n\nCODE_BLOCK_122\n\n<!-- end -->\n\n<!-- example accuracy -->\n\n## Точность группировки\n\nГруппировка выполняется в фиксированной памяти, которая зависит от настройки [max_matches](../Searching/Options.md#max_matches). Если `max_matches` позволяет сохранить все найденные группы, результаты будут 100% точными. Однако, если значение `max_matches` меньше, результаты будут менее точными.\n\nПри использовании параллельной обработки ситуация усложняется. При включённом `pseudo_sharding` и/или при использовании RT-таблицы с несколькими дисковыми чанками каждая часть или псевдо-шард получает набор результатов не больше чем `max_matches`. Это может привести к неточностям в агрегатах и подсчётах групп при объединении результатов из разных потоков. Чтобы исправить это, можно либо увеличить значение `max_matches`, либо отключить параллельную обработку."
    },
    "is_code_or_comment": false
  }
}
