{
  "6ffe90a58303f4d8615536a935728bc3fce2c8a2a972f4f73c54f391a397ea21": {
    "original": "This query demonstrates full-text matching across both the `customers` and `orders` tables, combined with range filtering and faceting. It searches for customers named \"Alice\" or \"Bob\" and their orders containing \"laptop\", \"phone\", or \"tablet\" with prices above $500. The results are ordered by order ID and faceted by warranty terms.\n\n<!-- request SQL -->\n\nCODE_BLOCK_25\n\n<!-- request JSON -->\n\nCODE_BLOCK_26\n\n<!-- response SQL -->\n\nCODE_BLOCK_27\n\n<!-- response JSON -->\n\nCODE_BLOCK_28\n\n<!-- end -->\n\n## Search options and match weights\n\nSeparate options can be specified for queries in a join: for the left table and the right table. The syntax is `OPTION(<table_name>)` for SQL queries and one or more subobjects under `\"options\"` for JSON queries.\n\n<!-- example join_options -->\n\nHere's an example of how to specify different field weights for a full-text query on the right table. To retrieve match weights via SQL, use the `<table_name>.weight()` expression.\n\nIn JSON queries, this weight is represented as `<table_name>._score`.\n\n<!-- request SQL -->\n\nCODE_BLOCK_29\n\n<!-- request JSON -->\n\nCODE_BLOCK_30\n\n<!-- response SQL -->\n\nCODE_BLOCK_31\n\n<!-- response JSON -->\n\nCODE_BLOCK_32\n\n<!-- end -->\n\n## Join batching\n\nWhen performing table joins, Manticore Search processes the results in batches to optimize performance and resource usage. Here's how it works:\n\n- **How Batching Works**:\n\n  - The query on the left table is executed first, and the results are accumulated into a batch.\n\n  - This batch is then used as input for the query on the right table, which is executed as a single operation.\n\n  - This approach minimizes the number of queries sent to the right table, improving efficiency.\n\n- **Configuring Batch Size**:\n\n  - The size of the batch can be adjusted using the `join_batch_size` search option.\n\n  - It is also [configurable](../Server_settings/Searchd.md#join_batch_size) in the `searchd` section of the configuration file.\n\n  - The default batch size is `1000`, but you can increase or decrease it depending on your use case.\n\n  - Setting `join_batch_size=0` disables batching entirely, which may be useful for debugging or specific scenarios.\n\n- **Performance Considerations**:\n\n  - A larger batch size can improve performance by reducing the number of queries executed on the right table.\n\n  - However, larger batches may consume more memory, especially for complex queries or large datasets.\n\n  - Experiment with different batch sizes to find the optimal balance between performance and resource usage.\n\n## Join caching\n\nTo further optimize join operations, Manticore Search employs a caching mechanism for queries executed on the right table. Here's what you need to know:\n\n- **How Caching Works**:\n\n  - Each query on the right table is defined by the `JOIN ON` conditions.\n\n  - If the same `JOIN ON` conditions are repeated across multiple queries, the results are cached and reused.\n\n  - This avoids redundant queries and speeds up subsequent join operations.\n\n- **Configuring Cache Size**:\n\n  - The size of the join cache can be configured using the [join_cache_size](../Server_settings/Searchd.md#join_cache_size) option in the `searchd` section of the configuration file.\n\n  - The default cache size is `20MB`, but you can adjust it based on your workload and available memory.\n\n  - Setting `join_cache_size=0` disables caching entirely.\n\n- **Memory Considerations**:\n\n  - Each thread maintains its own cache, so the total memory usage depends on the number of threads and the cache size.\n\n  - Ensure your server has sufficient memory to accommodate the cache, especially for high-concurrency environments.\n\n## Joining distributed tables\n\nDistributed tables consisting only of local tables are supported on both the left and right sides of a join query. However, distributed tables that include remote tables are not supported.\n\n## Caveats and best practices\n\nWhen using JOINs in Manticore Search, keep the following points in mind:\n\n1. **Field selection**: When selecting fields from two tables in a JOIN, do not prefix fields from the left table, but do prefix fields from the right table. For example:\n\n   ```sql\n\n   SELECT field_name, right_table.field_name FROM ...\n\n   ```\n\n2. **JOIN conditions**: Always explicitly specify the table names in your JOIN conditions:\n\n   ```sql\n\n   JOIN ON table_name.some_field = another_table_name.some_field\n\n   ```\n\n3. **Expressions with JOINs**: When using expressions that combine fields from both joined tables, alias the result of the expression:\n\n   ```sql\n\n   SELECT *, (nums2.n + 3) AS x, x * n FROM nums LEFT JOIN nums2 ON nums2.id = nums.num2_id\n\n   ```\n\n4. **Filtering on aliased expressions**: You cannot use aliases for expressions involving fields from both tables in the WHERE clause.\n\n5. **JSON attributes**: When joining on JSON attributes, you must explicitly cast the values to the appropriate type:\n\n   ```sql\n\n   -- Correct:\n\n   SELECT * FROM t1 LEFT JOIN t2 ON int(t1.json_attr.id) = t2.json_attr.id\n\n   -- Incorrect:\n\n   SELECT * FROM t1 LEFT JOIN t2 ON t1.json_attr.id = t2.json_attr.id\n\n   ```\n\n6. **NULL handling**: You can use IS NULL and IS NOT NULL conditions on joined fields:\n\n   ```sql\n\n   SELECT * FROM t1 LEFT JOIN t2 ON t1.id = t2.id WHERE t2.name IS NULL\n\n   SELECT * FROM t1 LEFT JOIN t2 ON t1.id = t2.id WHERE t2.name IS NOT NULL\n\n   ```\n\n7. **Using ANY with MVA**: When using the `ANY()` function with multi-valued attributes in JOINs, alias the multi-valued attribute from the joined table:\n\n   ```sql\n\n   SELECT *, t2.m AS alias\n\n   FROM t\n\n   LEFT JOIN t2 ON t.id = t2.t_id\n\n   WHERE ANY(alias) IN (3, 5)\n\n   ```\n\nBy following these guidelines, you can effectively use JOINs in Manticore Search to combine data from multiple indexes and perform complex queries.\n\n<!-- proofread -->",
    "translations": {
      "chinese": "该查询演示了跨 `customers` 和 `orders` 两个表的全文匹配，结合范围过滤和分面搜索。它搜索名为 \"Alice\" 或 \"Bob\" 的客户及其包含 \"laptop\"、\"phone\" 或 \"tablet\" 且价格高于 500 美元的订单。结果按订单 ID 排序，并按保修条款进行分面。\n\n<!-- request SQL -->\n\nCODE_BLOCK_25\n\n<!-- request JSON -->\n\nCODE_BLOCK_26\n\n<!-- response SQL -->\n\nCODE_BLOCK_27\n\n<!-- response JSON -->\n\nCODE_BLOCK_28\n\n<!-- end -->\n\n## 搜索选项和匹配权重\n\n可以为连接中的查询分别指定选项：左表和右表。语法为 SQL 查询中的 `OPTION(<table_name>)`，以及 JSON 查询中 `\"options\"` 下的一个或多个子对象。\n\n<!-- example join_options -->\n\n下面是如何为右表的全文查询指定不同字段权重的示例。要通过 SQL 获取匹配权重，请使用 `<table_name>.weight()` 表达式。\n\n在 JSON 查询中，该权重表示为 `<table_name>._score`。\n\n<!-- request SQL -->\n\nCODE_BLOCK_29\n\n<!-- request JSON -->\n\nCODE_BLOCK_30\n\n<!-- response SQL -->\n\nCODE_BLOCK_31\n\n<!-- response JSON -->\n\nCODE_BLOCK_32\n\n<!-- end -->\n\n## 连接批处理\n\n执行表连接时，Manticore Search 会批量处理结果以优化性能和资源使用。工作原理如下：\n\n- **批处理工作原理**：\n\n  - 首先执行左表的查询，并将结果累积到一个批次中。\n\n  - 然后将该批次用作右表查询的输入，右表查询作为单次操作执行。\n\n  - 这种方法减少了发送到右表的查询次数，提高了效率。\n\n- **配置批次大小**：\n\n  - 可以使用 `join_batch_size` 搜索选项调整批次大小。\n\n  - 也可以在配置文件的 `searchd` 部分通过 [join_batch_size](../Server_settings/Searchd.md#join_batch_size) 进行配置。\n\n  - 默认批次大小为 `1000`，您可以根据使用场景增大或减小。\n\n  - 设置 `join_batch_size=0` 可完全禁用批处理，这在调试或特定场景下可能有用。\n\n- **性能考虑**：\n\n  - 较大的批次大小可以通过减少右表查询次数来提升性能。\n\n  - 但较大的批次可能会消耗更多内存，尤其是对于复杂查询或大数据集。\n\n  - 通过尝试不同批次大小，找到性能和资源使用的最佳平衡点。\n\n## 连接缓存\n\n为了进一步优化连接操作，Manticore Search 对右表执行的查询采用缓存机制。您需要了解以下内容：\n\n- **缓存工作原理**：\n\n  - 右表的每个查询由 `JOIN ON` 条件定义。\n\n  - 如果多个查询中重复相同的 `JOIN ON` 条件，结果会被缓存并重用。\n\n  - 这避免了冗余查询，加快了后续连接操作。\n\n- **配置缓存大小**：\n\n  - 可以通过配置文件 `searchd` 部分的 [join_cache_size](../Server_settings/Searchd.md#join_cache_size) 选项配置连接缓存大小。\n\n  - 默认缓存大小为 `20MB`，您可以根据工作负载和可用内存调整。\n\n  - 设置 `join_cache_size=0` 可完全禁用缓存。\n\n- **内存考虑**：\n\n  - 每个线程维护自己的缓存，因此总内存使用取决于线程数和缓存大小。\n\n  - 确保服务器有足够内存以容纳缓存，尤其是在高并发环境下。\n\n## 连接分布式表\n\n仅包含本地表的分布式表支持作为连接查询的左侧和右侧表。然而，包含远程表的分布式表不被支持。\n\n## 注意事项和最佳实践\n\n在 Manticore Search 中使用 JOIN 时，请注意以下几点：\n\n1. **字段选择**：在 JOIN 中选择两个表的字段时，不要为左表字段加前缀，但要为右表字段加前缀。例如：\n\n   ```sql\n\n   SELECT field_name, right_table.field_name FROM ...\n\n   ```\n\n2. **JOIN 条件**：始终在 JOIN 条件中显式指定表名：\n\n   ```sql\n\n   JOIN ON table_name.some_field = another_table_name.some_field\n\n   ```\n\n3. **带 JOIN 的表达式**：当使用结合两个连接表字段的表达式时，为表达式结果设置别名：\n\n   ```sql\n\n   SELECT *, (nums2.n + 3) AS x, x * n FROM nums LEFT JOIN nums2 ON nums2.id = nums.num2_id\n\n   ```\n\n4. **基于别名表达式的过滤**：不能在 WHERE 子句中使用涉及两个表字段的表达式别名。\n\n5. **JSON 属性**：连接 JSON 属性时，必须显式将值转换为适当类型：\n\n   ```sql\n\n   -- 正确：\n\n   SELECT * FROM t1 LEFT JOIN t2 ON int(t1.json_attr.id) = t2.json_attr.id\n\n   -- 错误：\n\n   SELECT * FROM t1 LEFT JOIN t2 ON t1.json_attr.id = t2.json_attr.id\n\n   ```\n\n6. **NULL 处理**：可以对连接字段使用 IS NULL 和 IS NOT NULL 条件：\n\n   ```sql\n\n   SELECT * FROM t1 LEFT JOIN t2 ON t1.id = t2.id WHERE t2.name IS NULL\n\n   SELECT * FROM t1 LEFT JOIN t2 ON t1.id = t2.id WHERE t2.name IS NOT NULL\n\n   ```\n\n7. **使用带 MVA 的 ANY**：在 JOIN 中使用带多值属性的 `ANY()` 函数时，为连接表的多值属性设置别名：\n\n   ```sql\n\n   SELECT *, t2.m AS alias\n\n   FROM t\n\n   LEFT JOIN t2 ON t.id = t2.t_id\n\n   WHERE ANY(alias) IN (3, 5)\n\n   ```\n\n遵循这些指南，您可以有效地使用 Manticore Search 中的 JOIN 来组合多个索引的数据并执行复杂查询。\n\n<!-- proofread -->",
      "russian": "Этот запрос демонстрирует полнотекстовый поиск по таблицам `customers` и `orders`, объединённый с фильтрацией по диапазону и фасетным поиском. Он ищет клиентов с именами \"Alice\" или \"Bob\" и их заказы, содержащие \"laptop\", \"phone\" или \"tablet\" с ценами выше $500. Результаты упорядочены по ID заказа и фасетированы по условиям гарантии.\n\n<!-- request SQL -->\n\nCODE_BLOCK_25\n\n<!-- request JSON -->\n\nCODE_BLOCK_26\n\n<!-- response SQL -->\n\nCODE_BLOCK_27\n\n<!-- response JSON -->\n\nCODE_BLOCK_28\n\n<!-- end -->\n\n## Параметры поиска и веса совпадений\n\nДля запросов в объединении можно задать отдельные параметры: для левой и правой таблиц. Синтаксис — `OPTION(<table_name>)` для SQL-запросов и один или несколько подобъектов в `\"options\"` для JSON-запросов.\n\n<!-- example join_options -->\n\nВот пример, как задать разные веса полей для полнотекстового запроса по правой таблице. Чтобы получить веса совпадений через SQL, используйте выражение `<table_name>.weight()`.\n\nВ JSON-запросах этот вес представлен как `<table_name>._score`.\n\n<!-- request SQL -->\n\nCODE_BLOCK_29\n\n<!-- request JSON -->\n\nCODE_BLOCK_30\n\n<!-- response SQL -->\n\nCODE_BLOCK_31\n\n<!-- response JSON -->\n\nCODE_BLOCK_32\n\n<!-- end -->\n\n## Пакетная обработка объединений\n\nПри выполнении объединений таблиц Manticore Search обрабатывает результаты пакетами для оптимизации производительности и использования ресурсов. Вот как это работает:\n\n- **Как работает пакетная обработка**:\n\n  - Сначала выполняется запрос к левой таблице, и результаты накапливаются в пакет.\n\n  - Этот пакет затем используется как входные данные для запроса к правой таблице, который выполняется как единая операция.\n\n  - Такой подход минимизирует количество запросов к правой таблице, повышая эффективность.\n\n- **Настройка размера пакета**:\n\n  - Размер пакета можно настроить с помощью опции поиска `join_batch_size`.\n\n  - Также он [настраивается](../Server_settings/Searchd.md#join_batch_size) в разделе `searchd` конфигурационного файла.\n\n  - Размер пакета по умолчанию — `1000`, но вы можете увеличить или уменьшить его в зависимости от задачи.\n\n  - Установка `join_batch_size=0` полностью отключает пакетную обработку, что может быть полезно для отладки или специфических сценариев.\n\n- **Особенности производительности**:\n\n  - Больший размер пакета может улучшить производительность за счёт уменьшения количества запросов к правой таблице.\n\n  - Однако большие пакеты могут потреблять больше памяти, особенно при сложных запросах или больших данных.\n\n  - Экспериментируйте с разными размерами пакетов, чтобы найти оптимальный баланс между производительностью и использованием ресурсов.\n\n## Кэширование объединений\n\nДля дальнейшей оптимизации операций объединения Manticore Search использует механизм кэширования запросов, выполняемых по правой таблице. Вот что важно знать:\n\n- **Как работает кэширование**:\n\n  - Каждый запрос к правой таблице определяется условиями `JOIN ON`.\n\n  - Если одни и те же условия `JOIN ON` повторяются в нескольких запросах, результаты кэшируются и переиспользуются.\n\n  - Это позволяет избежать избыточных запросов и ускорить последующие операции объединения.\n\n- **Настройка размера кэша**:\n\n  - Размер кэша объединений можно настроить с помощью опции [join_cache_size](../Server_settings/Searchd.md#join_cache_size) в разделе `searchd` конфигурационного файла.\n\n  - Размер кэша по умолчанию — `20MB`, но вы можете изменить его в зависимости от нагрузки и доступной памяти.\n\n  - Установка `join_cache_size=0` полностью отключает кэширование.\n\n- **Особенности использования памяти**:\n\n  - Каждый поток поддерживает собственный кэш, поэтому общий объём памяти зависит от количества потоков и размера кэша.\n\n  - Убедитесь, что на сервере достаточно памяти для кэша, особенно при высокой конкуренции запросов.\n\n## Объединение распределённых таблиц\n\nРаспределённые таблицы, состоящие только из локальных таблиц, поддерживаются как слева, так и справа в запросах с объединением. Однако распределённые таблицы, включающие удалённые таблицы, не поддерживаются.\n\n## Особенности и рекомендации\n\nПри использовании JOIN в Manticore Search учитывайте следующие моменты:\n\n1. **Выбор полей**: При выборе полей из двух таблиц в JOIN не используйте префикс для полей левой таблицы, но используйте префикс для полей правой таблицы. Например:\n\n   ```sql\n\n   SELECT field_name, right_table.field_name FROM ...\n\n   ```\n\n2. **Условия JOIN**: Всегда явно указывайте имена таблиц в условиях JOIN:\n\n   ```sql\n\n   JOIN ON table_name.some_field = another_table_name.some_field\n\n   ```\n\n3. **Выражения с JOIN**: При использовании выражений, объединяющих поля из обеих таблиц, задавайте псевдоним для результата выражения:\n\n   ```sql\n\n   SELECT *, (nums2.n + 3) AS x, x * n FROM nums LEFT JOIN nums2 ON nums2.id = nums.num2_id\n\n   ```\n\n4. **Фильтрация по псевдонимам выражений**: Нельзя использовать псевдонимы выражений, включающих поля из обеих таблиц, в условии WHERE.\n\n5. **JSON-атрибуты**: При объединении по JSON-атрибутам необходимо явно приводить значения к нужному типу:\n\n   ```sql\n\n   -- Правильно:\n\n   SELECT * FROM t1 LEFT JOIN t2 ON int(t1.json_attr.id) = t2.json_attr.id\n\n   -- Неправильно:\n\n   SELECT * FROM t1 LEFT JOIN t2 ON t1.json_attr.id = t2.json_attr.id\n\n   ```\n\n6. **Обработка NULL**: Можно использовать условия IS NULL и IS NOT NULL для объединённых полей:\n\n   ```sql\n\n   SELECT * FROM t1 LEFT JOIN t2 ON t1.id = t2.id WHERE t2.name IS NULL\n\n   SELECT * FROM t1 LEFT JOIN t2 ON t1.id = t2.id WHERE t2.name IS NOT NULL\n\n   ```\n\n7. **Использование ANY с MVA**: При использовании функции `ANY()` с мультизначными атрибутами в JOIN задавайте псевдоним для мультизначного атрибута из присоединённой таблицы:\n\n   ```sql\n\n   SELECT *, t2.m AS alias\n\n   FROM t\n\n   LEFT JOIN t2 ON t.id = t2.t_id\n\n   WHERE ANY(alias) IN (3, 5)\n\n   ```\n\nСледуя этим рекомендациям, вы сможете эффективно использовать JOIN в Manticore Search для объединения данных из нескольких индексов и выполнения сложных запросов.\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "e3c6e6e521c83c4a3c3dea82dcd89ac027b19d1f0416890482998883294c9c36": {
    "original": "# Joining tables\n\nTable joins in Manticore Search enable you to combine documents from two tables by matching related columns. This functionality allows for more complex queries and enhanced data retrieval across multiple tables.\n\n## General syntax\n\n### SQL\n\nCODE_BLOCK_0\n\nFor more information on select options, refer to the [SELECT](../Searching/Intro.md#General-syntax) section.\n\n<!--example join_sql_json_type -->\n\nWhen joining by a value from a JSON attribute, you need to explicitly specify the value's type using the `int()` or `string()` function.\n\n<!-- request String JSON attribute -->\n\nCODE_BLOCK_1\n\n<!-- request Int JSON attribute -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n### JSON\n\nCODE_BLOCK_3\n\nNote, there is the `type` field in the `left` operand section which you should use when joining two tables using json attributes. The allowed values are `string` and `int`.\n\n## Types of joins\n\nManticore Search supports two types of joins:\n\n<!-- example inner_basic -->\n\n1. **INNER JOIN**: Returns only the rows where there is a match in both tables. For example, the query performs an INNER JOIN between the `orders` and `customers` tables, including only the orders that have matching customers.\n\n<!-- request SQL -->\n\nCODE_BLOCK_4\n\n<!-- request JSON -->\n\nCODE_BLOCK_5\n\n<!-- response SQL -->\n\nCODE_BLOCK_6\n\n<!-- response JSON -->\n\nCODE_BLOCK_7\n\n<!-- end -->\n\n<!-- example left_basic -->\n\n2. **LEFT JOIN**: Returns all rows from the left table and the matched rows from the right table. If there is no match, NULL values are returned for the right table's columns. For example, this query retrieves all customers along with their corresponding orders using a LEFT JOIN. If no corresponding order exists, NULL values will appear. The results are sorted by the customer's email, and only the customer's name and the order quantity are selected.\n\n<!-- request SQL -->\n\nCODE_BLOCK_8\n\n<!-- request JSON -->\n\nCODE_BLOCK_9\n\n<!-- response SQL -->\n\nCODE_BLOCK_10\n\n<!-- response JSON -->\n\nCODE_BLOCK_11\n\n<!-- end -->\n\n## Full-text matching across joined tables\n\nOne of the powerful features of table joins in Manticore Search is the ability to perform full-text searches on both the left and right tables simultaneously. This allows you to create complex queries that filter based on text content in multiple tables.\n\n<!-- example fulltext_basic -->\n\nYou can use separate `MATCH()` functions for each table in your JOIN query. The query filters results based on text content in both tables.\n\n<!-- request SQL -->\n\nCODE_BLOCK_12\n\n<!-- request JSON -->\n\nCODE_BLOCK_13\n\n<!-- response SQL -->\n\nCODE_BLOCK_14\n\n<!-- response JSON -->\n\nCODE_BLOCK_15\n\n<!-- end -->\n\n### JSON query structure for joins\n\nIn JSON API queries, table-specific full-text matching is structured differently than SQL:\n\n<!-- example fulltext_json_structure -->\n\n**Main table query**: The `\"query\"` field at the root level applies to the main table (specified in `\"table\"`).\n\n**Joined table query**: Each join definition can include its own `\"query\"` field that applies specifically to that joined table.\n\n<!-- request JSON -->\n\nCODE_BLOCK_16\n\n<!-- response JSON -->\n\nCODE_BLOCK_17\n\n<!-- end -->\n\n### Understanding query behavior in JOIN operations\n\n<!-- example fulltext_json_behavior -->\n\n**1. Query on main table only**: Returns all matching rows from the main table. For unmatched joined records (LEFT JOIN), SQL returns NULL values while JSON API returns default values (0 for numbers, empty strings for text).\n\n<!-- request SQL -->\n\nCODE_BLOCK_18\n\n<!-- response SQL -->\n\nCODE_BLOCK_19\n\n<!-- request JSON -->\n\nCODE_BLOCK_20\n\n<!-- response JSON -->\n\nCODE_BLOCK_21\n\n<!--end -->\n\n<!-- example fulltext_json_behavior_2 -->\n\n**2. Query on joined table acts as filter**: When a joined table has a query, only records matching both the join condition AND the query condition are returned.\n\n<!-- request JSON -->\n\nCODE_BLOCK_22\n\n<!-- response JSON -->\n\nCODE_BLOCK_23\n\n<!-- end -->\n\n**3. JOIN type affects filtering**: INNER JOIN requires both join and query conditions to be satisfied, while LEFT JOIN returns matching left table rows even when right table conditions fail.\n\n### Important considerations for full-text matching in JOINs\n\nWhen using full-text matching with joins, keep these points in mind:\n\n1. **Table-specific matching**: \n\n   - **SQL**: Each `MATCH()` function should specify which table to search in: `MATCH('term', table_name)`\n\n   - **JSON**: Use the root-level `\"query\"` for the main table and `\"query\"` within each join definition for joined tables\n\n2. **Query syntax flexibility**: JSON API supports both `\"query_string\"` and `\"match\"` syntaxes for full-text queries\n\n3. **Performance implications**: Full-text matching on both tables may impact query performance, especially with large datasets. Consider using appropriate indexes and batch sizes.\n\n4. **NULL/default value handling**: With LEFT JOIN, if there's no matching record in the right table, the query optimizer decides whether to evaluate full-text conditions or filtering conditions first based on performance. SQL returns NULL values while JSON API returns default values (0 for numbers, empty strings for text).\n\n5. **Filtering behavior**: Queries on joined tables act as filters - they restrict results to records that satisfy both join and query conditions.\n\n6. **Full-text operator support**: All [full-text operators](../Searching/Full_text_matching/Operators.md) are supported in JOIN queries, including phrase, proximity, field search, NEAR, quorum matching, and advanced operators.\n\n7. **Score calculation**: Each table maintains its own relevance score, accessible via `table_name.weight()` in SQL or `table_name._score` in JSON responses.\n\n## Example: Complex JOIN with faceting\n\nBuilding on the previous examples, let's explore a more advanced scenario where we combine table joins with faceting and full-text matching across multiple tables. This demonstrates the full power of Manticore's JOIN capabilities with complex filtering and aggregation.\n\n<details>\n\nInit queries for the following example:\n\nCODE_BLOCK_24\n\n</details>\n\n<!-- example basic_complex -->",
    "translations": {
      "chinese": "# 连接表\n\nManticore Search 中的表连接使您能够通过匹配相关列来组合两个表中的文档。此功能允许更复杂的查询和跨多个表的增强数据检索。\n\n## 通用语法\n\n### SQL\n\nCODE_BLOCK_0\n\n有关选择选项的更多信息，请参阅[SELECT](../Searching/Intro.md#General-syntax)部分。\n\n<!--example join_sql_json_type -->\n\n当通过 JSON 属性中的值进行连接时，您需要使用 `int()` 或 `string()` 函数显式指定该值的类型。\n\n<!-- request String JSON attribute -->\n\nCODE_BLOCK_1\n\n<!-- request Int JSON attribute -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n### JSON\n\nCODE_BLOCK_3\n\n注意，`left` 操作数部分中有一个 `type` 字段，当使用 json 属性连接两个表时应使用。允许的值为 `string` 和 `int`。\n\n## 连接类型\n\nManticore Search 支持两种类型的连接：\n\n<!-- example inner_basic -->\n\n1. **INNER JOIN**：仅返回两个表中都有匹配的行。例如，该查询在 `orders` 和 `customers` 表之间执行 INNER JOIN，仅包含具有匹配客户的订单。\n\n<!-- request SQL -->\n\nCODE_BLOCK_4\n\n<!-- request JSON -->\n\nCODE_BLOCK_5\n\n<!-- response SQL -->\n\nCODE_BLOCK_6\n\n<!-- response JSON -->\n\nCODE_BLOCK_7\n\n<!-- end -->\n\n<!-- example left_basic -->\n\n2. **LEFT JOIN**：返回左表中的所有行以及右表中匹配的行。如果没有匹配，则右表的列返回 NULL 值。例如，此查询使用 LEFT JOIN 检索所有客户及其对应的订单。如果不存在对应订单，则显示 NULL 值。结果按客户的电子邮件排序，仅选择客户的姓名和订单数量。\n\n<!-- request SQL -->\n\nCODE_BLOCK_8\n\n<!-- request JSON -->\n\nCODE_BLOCK_9\n\n<!-- response SQL -->\n\nCODE_BLOCK_10\n\n<!-- response JSON -->\n\nCODE_BLOCK_11\n\n<!-- end -->\n\n## 跨连接表的全文匹配\n\nManticore Search 表连接的强大功能之一是能够同时对左表和右表执行全文搜索。这允许您创建基于多个表中文本内容过滤的复杂查询。\n\n<!-- example fulltext_basic -->\n\n您可以在 JOIN 查询中为每个表使用单独的 `MATCH()` 函数。查询基于两个表中的文本内容过滤结果。\n\n<!-- request SQL -->\n\nCODE_BLOCK_12\n\n<!-- request JSON -->\n\nCODE_BLOCK_13\n\n<!-- response SQL -->\n\nCODE_BLOCK_14\n\n<!-- response JSON -->\n\nCODE_BLOCK_15\n\n<!-- end -->\n\n### 连接的 JSON 查询结构\n\n在 JSON API 查询中，特定表的全文匹配结构与 SQL 不同：\n\n<!-- example fulltext_json_structure -->\n\n**主表查询**：根级别的 `\"query\"` 字段应用于主表（在 `\"table\"` 中指定）。\n\n**连接表查询**：每个连接定义可以包含其自己的 `\"query\"` 字段，专门应用于该连接表。\n\n<!-- request JSON -->\n\nCODE_BLOCK_16\n\n<!-- response JSON -->\n\nCODE_BLOCK_17\n\n<!-- end -->\n\n### 理解 JOIN 操作中的查询行为\n\n<!-- example fulltext_json_behavior -->\n\n**1. 仅主表查询**：返回主表中所有匹配的行。对于未匹配的连接记录（LEFT JOIN），SQL 返回 NULL 值，而 JSON API 返回默认值（数字为 0，文本为空字符串）。\n\n<!-- request SQL -->\n\nCODE_BLOCK_18\n\n<!-- response SQL -->\n\nCODE_BLOCK_19\n\n<!-- request JSON -->\n\nCODE_BLOCK_20\n\n<!-- response JSON -->\n\nCODE_BLOCK_21\n\n<!--end -->\n\n<!-- example fulltext_json_behavior_2 -->\n\n**2. 连接表上的查询作为过滤器**：当连接表有查询时，仅返回同时满足连接条件和查询条件的记录。\n\n<!-- request JSON -->\n\nCODE_BLOCK_22\n\n<!-- response JSON -->\n\nCODE_BLOCK_23\n\n<!-- end -->\n\n**3. JOIN 类型影响过滤**：INNER JOIN 需要同时满足连接和查询条件，而 LEFT JOIN 即使右表条件不满足，也返回匹配的左表行。\n\n### JOIN 中全文匹配的重要注意事项\n\n使用连接进行全文匹配时，请注意以下几点：\n\n1. **特定表匹配**：\n\n   - **SQL**：每个 `MATCH()` 函数应指定搜索的表：`MATCH('term', table_name)`\n\n   - **JSON**：主表使用根级 `\"query\"`，连接表使用各自连接定义内的 `\"query\"`\n\n2. **查询语法灵活性**：JSON API 支持全文查询的 `\"query_string\"` 和 `\"match\"` 语法\n\n3. **性能影响**：对两个表进行全文匹配可能影响查询性能，尤其是大数据集。请考虑使用适当的索引和批处理大小。\n\n4. **NULL/默认值处理**：使用 LEFT JOIN 时，如果右表无匹配记录，查询优化器会根据性能决定先评估全文条件还是过滤条件。SQL 返回 NULL 值，JSON API 返回默认值（数字为 0，文本为空字符串）。\n\n5. **过滤行为**：连接表上的查询作为过滤器——限制结果为同时满足连接和查询条件的记录。\n\n6. **全文操作符支持**：JOIN 查询支持所有[全文操作符](../Searching/Full_text_matching/Operators.md)，包括短语、邻近、字段搜索、NEAR、法定人数匹配和高级操作符。\n\n7. **评分计算**：每个表维护自己的相关性评分，可通过 SQL 中的 `table_name.weight()` 或 JSON 响应中的 `table_name._score` 访问。\n\n## 示例：带分面功能的复杂 JOIN\n\n基于前面的示例，让我们探索一个更高级的场景，将表连接与分面和跨多个表的全文匹配结合起来。这展示了 Manticore JOIN 功能在复杂过滤和聚合中的全部威力。\n\n<details>\n\n以下示例的初始化查询：\n\nCODE_BLOCK_24\n\n</details>\n\n<!-- example basic_complex -->",
      "russian": "# Объединение таблиц\n\nОбъединения таблиц в Manticore Search позволяют комбинировать документы из двух таблиц, сопоставляя связанные столбцы. Эта функциональность обеспечивает более сложные запросы и улучшенный поиск данных по нескольким таблицам.\n\n## Общий синтаксис\n\n### SQL\n\nCODE_BLOCK_0\n\nДля получения дополнительной информации о параметрах select обратитесь к разделу [SELECT](../Searching/Intro.md#General-syntax).\n\n<!--example join_sql_json_type -->\n\nПри объединении по значению из JSON-атрибута необходимо явно указать тип значения с помощью функции `int()` или `string()`.\n\n<!-- request String JSON attribute -->\n\nCODE_BLOCK_1\n\n<!-- request Int JSON attribute -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n### JSON\n\nCODE_BLOCK_3\n\nОбратите внимание, что в разделе операнда `left` есть поле `type`, которое следует использовать при объединении двух таблиц с использованием json-атрибутов. Допустимые значения — `string` и `int`.\n\n## Типы объединений\n\nManticore Search поддерживает два типа объединений:\n\n<!-- example inner_basic -->\n\n1. **INNER JOIN**: Возвращает только строки, где есть совпадение в обеих таблицах. Например, запрос выполняет INNER JOIN между таблицами `orders` и `customers`, включая только заказы, у которых есть соответствующие клиенты.\n\n<!-- request SQL -->\n\nCODE_BLOCK_4\n\n<!-- request JSON -->\n\nCODE_BLOCK_5\n\n<!-- response SQL -->\n\nCODE_BLOCK_6\n\n<!-- response JSON -->\n\nCODE_BLOCK_7\n\n<!-- end -->\n\n<!-- example left_basic -->\n\n2. **LEFT JOIN**: Возвращает все строки из левой таблицы и совпадающие строки из правой таблицы. Если совпадения нет, для столбцов правой таблицы возвращаются значения NULL. Например, этот запрос извлекает всех клиентов вместе с их соответствующими заказами с помощью LEFT JOIN. Если соответствующего заказа нет, появятся значения NULL. Результаты сортируются по электронной почте клиента, и выбираются только имя клиента и количество заказов.\n\n<!-- request SQL -->\n\nCODE_BLOCK_8\n\n<!-- request JSON -->\n\nCODE_BLOCK_9\n\n<!-- response SQL -->\n\nCODE_BLOCK_10\n\n<!-- response JSON -->\n\nCODE_BLOCK_11\n\n<!-- end -->\n\n## Полнотекстовый поиск по объединённым таблицам\n\nОдна из мощных возможностей объединений таблиц в Manticore Search — это возможность выполнять полнотекстовый поиск одновременно по левой и правой таблицам. Это позволяет создавать сложные запросы, фильтрующие данные на основе текстового содержимого в нескольких таблицах.\n\n<!-- example fulltext_basic -->\n\nВы можете использовать отдельные функции `MATCH()` для каждой таблицы в вашем JOIN-запросе. Запрос фильтрует результаты на основе текстового содержимого в обеих таблицах.\n\n<!-- request SQL -->\n\nCODE_BLOCK_12\n\n<!-- request JSON -->\n\nCODE_BLOCK_13\n\n<!-- response SQL -->\n\nCODE_BLOCK_14\n\n<!-- response JSON -->\n\nCODE_BLOCK_15\n\n<!-- end -->\n\n### Структура JSON-запроса для объединений\n\nВ JSON API запросах полнотекстовый поиск по таблицам структурируется иначе, чем в SQL:\n\n<!-- example fulltext_json_structure -->\n\n**Запрос основной таблицы**: Поле `\"query\"` на корневом уровне применяется к основной таблице (указанной в `\"table\"`).\n\n**Запрос объединённой таблицы**: Каждое определение объединения может включать собственное поле `\"query\"`, которое применяется конкретно к этой объединённой таблице.\n\n<!-- request JSON -->\n\nCODE_BLOCK_16\n\n<!-- response JSON -->\n\nCODE_BLOCK_17\n\n<!-- end -->\n\n### Понимание поведения запроса в операциях JOIN\n\n<!-- example fulltext_json_behavior -->\n\n**1. Запрос только к основной таблице**: Возвращает все совпадающие строки из основной таблицы. Для несопоставленных записей объединённой таблицы (LEFT JOIN) SQL возвращает значения NULL, а JSON API — значения по умолчанию (0 для чисел, пустые строки для текста).\n\n<!-- request SQL -->\n\nCODE_BLOCK_18\n\n<!-- response SQL -->\n\nCODE_BLOCK_19\n\n<!-- request JSON -->\n\nCODE_BLOCK_20\n\n<!-- response JSON -->\n\nCODE_BLOCK_21\n\n<!--end -->\n\n<!-- example fulltext_json_behavior_2 -->\n\n**2. Запрос к объединённой таблице действует как фильтр**: Когда у объединённой таблицы есть запрос, возвращаются только записи, удовлетворяющие как условию объединения, так и условию запроса.\n\n<!-- request JSON -->\n\nCODE_BLOCK_22\n\n<!-- response JSON -->\n\nCODE_BLOCK_23\n\n<!-- end -->\n\n**3. Тип JOIN влияет на фильтрацию**: INNER JOIN требует выполнения условий объединения и запроса, тогда как LEFT JOIN возвращает совпадающие строки левой таблицы даже при несоответствии условий правой таблицы.\n\n### Важные моменты при полнотекстовом поиске в JOIN\n\nПри использовании полнотекстового поиска с объединениями учитывайте следующие моменты:\n\n1. **Поиск по конкретным таблицам**: \n\n   - **SQL**: Каждая функция `MATCH()` должна указывать, в какой таблице искать: `MATCH('term', table_name)`\n\n   - **JSON**: Используйте корневое поле `\"query\"` для основной таблицы и поле `\"query\"` внутри каждого определения объединения для объединённых таблиц\n\n2. **Гибкость синтаксиса запроса**: JSON API поддерживает синтаксис как `\"query_string\"`, так и `\"match\"` для полнотекстовых запросов\n\n3. **Влияние на производительность**: Полнотекстовый поиск по обеим таблицам может повлиять на производительность запроса, особенно при больших объёмах данных. Рекомендуется использовать соответствующие индексы и размеры пакетов.\n\n4. **Обработка NULL/значений по умолчанию**: При LEFT JOIN, если нет совпадающей записи в правой таблице, оптимизатор запроса решает, сначала ли оценивать полнотекстовые условия или условия фильтрации, исходя из производительности. SQL возвращает значения NULL, а JSON API — значения по умолчанию (0 для чисел, пустые строки для текста).\n\n5. **Поведение фильтрации**: Запросы к объединённым таблицам действуют как фильтры — они ограничивают результаты записями, удовлетворяющими и условиям объединения, и условиям запроса.\n\n6. **Поддержка полнотекстовых операторов**: Все [операторы полнотекстового поиска](../Searching/Full_text_matching/Operators.md) поддерживаются в JOIN-запросах, включая фразы, близость, поиск по полям, NEAR, кворум и расширенные операторы.\n\n7. **Вычисление оценки релевантности**: Каждая таблица поддерживает собственный балл релевантности, доступный через `table_name.weight()` в SQL или `table_name._score` в JSON-ответах.\n\n## Пример: Сложный JOIN с фасетированием\n\nОпираясь на предыдущие примеры, рассмотрим более продвинутый сценарий, где мы комбинируем объединения таблиц с фасетированием и полнотекстовым поиском по нескольким таблицам. Это демонстрирует всю мощь возможностей JOIN в Manticore с комплексной фильтрацией и агрегацией.\n\n<details>\n\nИнициализационные запросы для следующего примера:\n\nCODE_BLOCK_24\n\n</details>\n\n<!-- example basic_complex -->"
    },
    "is_code_or_comment": false
  }
}
