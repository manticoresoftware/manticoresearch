{
  "384e7926633ad3bd119a972defabb5e7fec382339d6d7726e8b97764fadb9deb": {
    "original": "# Multi-queries\n\nMulti-queries, or query batches, allow you to send multiple search queries to Manticore in a single network request.\n\n👍 Why use multi-queries?\n\nThe primary reason is performance. By sending requests to Manticore in a batch instead of one by one, you save time by reducing network round-trips. Additionally, sending queries in a batch allows Manticore to perform certain internal optimizations. If no batch optimizations can be applied, queries will be processed individually.\n\n⛔ When not to use multi-queries?\n\nMulti-queries require all search queries in a batch to be independent, which isn't always the case. Sometimes query B depends on query A's results, meaning query B can only be set up after executing query A. For example, you might want to display results from a secondary index only if no results were found in the primary table, or you may want to specify an offset into the 2nd result set based on the number of matches in the 1st result set. In these cases, you'll need to use separate queries (or separate batches).\n\n<!-- example multi-query 1 -->\n\nYou can run multiple search queries with SQL by separating them with a semicolon. When Manticore receives a query formatted like this from a client, all inter-statement optimizations will be applied.\n\nMulti-queries don't support queries with `FACET`. The number of multi-queries in one batch shouldn't exceed [max_batch_queries](../Server_settings/Searchd.md#max_batch_queries).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- end -->\n\n## Multi-queries optimizations\n\nThere are two major optimizations to be aware of: common query optimization and common subtree optimization.\n\n**Common query optimization** means that `searchd` will identify all those queries in a batch where only the sorting and group-by settings differ, and *only perform searching once*. For example, if a batch consists of 3 queries, all of them are for \"ipod nano\", but the 1st query requests the top-10 results sorted by price, the 2nd query groups by vendor ID and requests the top-5 vendors sorted by rating, and the 3rd query requests the max price, full-text search for \"ipod nano\" will only be performed once, and its results will be reused to build 3 different result sets.\n\n[Faceted search](../Searching/Faceted_search.md) is a particularly important case that benefits from this optimization. Indeed, faceted searching can be implemented by running several queries, one to retrieve search results themselves, and a few others with the same full-text query but different group-by settings to retrieve all the required groups of results (top-3 authors, top-5 vendors, etc). As long as the full-text query and filtering settings stay the same, common query optimization will trigger, and greatly improve performance.\n\n**Common subtree optimization** is even more interesting. It allows `searchd` to exploit similarities between batched full-text queries. It identifies common full-text query parts (subtrees) in all queries and caches them between queries. For example, consider the following query batch:\n\nCODE_BLOCK_1\n\nThere's a common two-word part `donald trump` that can be computed only once, then cached and shared across the queries. And common subtree optimization does just that. Per-query cache size is strictly controlled by [subtree_docs_cache](../Server_settings/Searchd.md#subtree_docs_cache) and [subtree_hits_cache](../Server_settings/Searchd.md#subtree_hits_cache) directives (so that caching *all* sixteen gazillions of documents that match \"i am\" does not exhaust the RAM and instantly kill your server).\n\n<!-- example multi-query 2 -->\n\nHow can you tell if the queries in the batch were actually optimized? If they were, the respective query log will have a \"multiplier\" field that specifies how many queries were processed together:\n\nNote the \"x3\" field. It means that this query was optimized and processed in a sub-batch of 3 queries.\n\n<!-- intro -->\n\n##### log:\n\n<!-- request log -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n<!-- example multi-query 3 -->\n\nFor reference, this is how the regular log would look like if the queries were not batched:\n\n<!-- intro -->\n\n##### log:\n\n<!-- request log -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\nNotice how the per-query time in the multi-query case improved by a factor of 1.5x to 2.3x, depending on the specific sorting mode.\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 多查询\n\n多查询，或称查询批处理，允许您在一次网络请求中向 Manticore 发送多个搜索查询。\n\n👍 为什么使用多查询？\n\n主要原因是性能。通过批量发送请求给 Manticore，而不是逐个发送，您可以通过减少网络往返时间来节省时间。此外，批量发送查询允许 Manticore 执行某些内部优化。如果无法应用批量优化，查询将被单独处理。\n\n⛔ 何时不使用多查询？\n\n多查询要求批处理中的所有搜索查询相互独立，但情况并非总是如此。有时查询 B 依赖于查询 A 的结果，这意味着查询 B 只能在执行查询 A 后设置。例如，您可能只想在主表中未找到结果时显示来自辅助索引的结果，或者您可能想根据第一个结果集中的匹配数指定第二个结果集的偏移量。在这些情况下，您需要使用单独的查询（或单独的批处理）。\n\n<!-- example multi-query 1 -->\n\n您可以通过用分号分隔多个搜索查询来运行多查询。当 Manticore 从客户端接收到这样格式的查询时，将应用所有语句间的优化。\n\n多查询不支持带有 `FACET` 的查询。单个批处理中的多查询数量不应超过 [max_batch_queries](../Server_settings/Searchd.md#max_batch_queries)。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- end -->\n\n## 多查询优化\n\n需要注意两种主要优化：公共查询优化和公共子树优化。\n\n**公共查询优化** 意味着 `searchd` 会识别批处理中所有仅排序和分组设置不同的查询，并且*只执行一次搜索*。例如，如果一个批处理包含 3 个查询，它们都是针对“ipod nano”的，但第一个查询请求按价格排序的前 10 个结果，第二个查询按供应商 ID 分组并请求按评分排序的前 5 个供应商，第三个查询请求最大价格，则全文搜索“ipod nano”只会执行一次，其结果将被重用以构建 3 个不同的结果集。\n\n[分面搜索](../Searching/Faceted_search.md) 是特别受益于此优化的一个重要案例。实际上，分面搜索可以通过运行多个查询来实现，一个用于检索搜索结果本身，其他几个使用相同的全文查询但不同的分组设置来检索所有所需的结果组（前 3 名作者，前 5 名供应商等）。只要全文查询和过滤设置保持不变，公共查询优化就会触发，并大大提高性能。\n\n**公共子树优化** 更加有趣。它允许 `searchd` 利用批量全文查询之间的相似性。它识别所有查询中的公共全文查询部分（子树）并在查询之间缓存它们。例如，考虑以下查询批处理：\n\nCODE_BLOCK_1\n\n有一个公共的两词部分 `donald trump`，只需计算一次，然后缓存并在查询间共享。公共子树优化正是这样做的。每个查询的缓存大小由 [subtree_docs_cache](../Server_settings/Searchd.md#subtree_docs_cache) 和 [subtree_hits_cache](../Server_settings/Searchd.md#subtree_hits_cache) 指令严格控制（以防缓存*所有*匹配“i am”的十六亿亿文档耗尽内存并立即导致服务器崩溃）。\n\n<!-- example multi-query 2 -->\n\n如何判断批处理中的查询是否真的被优化了？如果是，相关的查询日志将有一个“multiplier”字段，指定一起处理了多少个查询：\n\n注意“x3”字段。这意味着该查询被优化并在一个包含 3 个查询的子批处理中处理。\n\n<!-- intro -->\n\n##### 日志:\n\n<!-- request log -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n<!-- example multi-query 3 -->\n\n作为参考，如果查询未批处理，常规日志将如下所示：\n\n<!-- intro -->\n\n##### 日志:\n\n<!-- request log -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n注意多查询情况下每个查询的时间提升了 1.5 倍到 2.3 倍，具体取决于排序模式。\n\n<!-- proofread -->",
      "russian": "# Мультизапросы\n\nМультизапросы, или пакеты запросов, позволяют отправлять несколько поисковых запросов в Manticore в одном сетевом запросе.\n\n👍 Почему стоит использовать мультизапросы?\n\nОсновная причина — производительность. Отправляя запросы в Manticore пакетами, а не по одному, вы экономите время за счёт уменьшения количества сетевых обращений. Кроме того, отправка запросов пакетами позволяет Manticore выполнять определённые внутренние оптимизации. Если оптимизации пакета применить нельзя, запросы будут обработаны по отдельности.\n\n⛔ Когда не стоит использовать мультизапросы?\n\nМультизапросы требуют, чтобы все поисковые запросы в пакете были независимы, что бывает не всегда. Иногда запрос B зависит от результатов запроса A, то есть запрос B можно сформировать только после выполнения запроса A. Например, вы можете захотеть показать результаты из вторичного индекса только если в основной таблице не было найдено результатов, или указать смещение во втором наборе результатов на основе количества совпадений в первом наборе. В таких случаях нужно использовать отдельные запросы (или отдельные пакеты).\n\n<!-- example multi-query 1 -->\n\nВы можете выполнять несколько поисковых запросов в SQL, разделяя их точкой с запятой. Когда Manticore получает такой запрос от клиента, применяются все оптимизации между запросами.\n\nМультизапросы не поддерживают запросы с `FACET`. Количество мультизапросов в одном пакете не должно превышать [max_batch_queries](../Server_settings/Searchd.md#max_batch_queries).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- end -->\n\n## Оптимизации мультизапросов\n\nСуществует две основные оптимизации, о которых стоит знать: оптимизация общих запросов и оптимизация общих поддеревьев.\n\n**Оптимизация общих запросов** означает, что `searchd` определит все запросы в пакете, которые отличаются только настройками сортировки и группировки, и *выполнит поиск только один раз*. Например, если пакет состоит из 3 запросов, все они по запросу \"ipod nano\", но первый запрос запрашивает топ-10 результатов, отсортированных по цене, второй группирует по ID поставщика и запрашивает топ-5 поставщиков, отсортированных по рейтингу, а третий запрашивает максимальную цену, полнотекстовый поиск по \"ipod nano\" будет выполнен только один раз, а его результаты будут использованы для построения трёх разных наборов результатов.\n\n[Фасетный поиск](../Searching/Faceted_search.md) — особенно важный случай, который выигрывает от этой оптимизации. Действительно, фасетный поиск можно реализовать, выполняя несколько запросов: один для получения самих результатов поиска и несколько других с тем же полнотекстовым запросом, но с разными настройками группировки, чтобы получить все необходимые группы результатов (топ-3 авторов, топ-5 поставщиков и т.д.). Пока полнотекстовый запрос и настройки фильтрации остаются одинаковыми, сработает оптимизация общих запросов, значительно улучшая производительность.\n\n**Оптимизация общих поддеревьев** ещё интереснее. Она позволяет `searchd` использовать сходства между пакетными полнотекстовыми запросами. Он выявляет общие части полнотекстовых запросов (поддеревья) во всех запросах и кэширует их между запросами. Например, рассмотрим следующий пакет запросов:\n\nCODE_BLOCK_1\n\nЕсть общая двухсловная часть `donald trump`, которую можно вычислить один раз, затем закэшировать и использовать во всех запросах. Именно это и делает оптимизация общих поддеревьев. Размер кэша на запрос строго контролируется директивами [subtree_docs_cache](../Server_settings/Searchd.md#subtree_docs_cache) и [subtree_hits_cache](../Server_settings/Searchd.md#subtree_hits_cache) (чтобы кэширование *всех* шестнадцати миллиардов документов, соответствующих \"i am\", не исчерпало оперативную память и не убило сервер).\n\n<!-- example multi-query 2 -->\n\nКак узнать, были ли запросы в пакете действительно оптимизированы? Если да, в соответствующем логе запросов появится поле \"multiplier\", указывающее, сколько запросов было обработано вместе:\n\nОбратите внимание на поле \"x3\". Это означает, что запрос был оптимизирован и обработан в под-пакете из 3 запросов.\n\n<!-- intro -->\n\n##### log:\n\n<!-- request log -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n<!-- example multi-query 3 -->\n\nДля сравнения, вот как выглядел бы обычный лог, если бы запросы не были объединены в пакет:\n\n<!-- intro -->\n\n##### log:\n\n<!-- request log -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\nОбратите внимание, что время на запрос в случае мультизапроса улучшилось в 1.5–2.3 раза, в зависимости от конкретного режима сортировки.\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "4b5322ec3abc541e7be9a6f3684ad3fcedfa151adab44f70d7096de8ca93f6a6": {
    "original": "You can use `set` only for `set profiling`. All other `set` will be silently ignored.\n\nOrder of execution is also differs. Daemon process batches in 2 passes.\n\nFirst, it collects all `select` statements, and at the same time run all `set` statements it sees. As a side effect, only last `set profiling` is effective. If you run multi-query as `set profiling=1; select...; show meta; show profile; set profiling=0`, you will not see any profile, because on the first pass daemon executes `set profiling=1`, and then, immediately, last `set profiling=0`.\n\nSecond, daemon try to execute single batch query with all collected `select` statements. If statements are not related; it will execute them one-by-one.\n\nFinally, it iterates over initial batch sequence, and for each `select` and `show` returns it's sub-result data and meta from resultset. All `set` statements were already executed in the first pass, and so, on this second pass they are skipped. ",
    "translations": {
      "chinese": "你只能对 `set profiling` 使用 `set`。所有其他的 `set` 将被静默忽略。\n\n执行顺序也有所不同。守护进程分两遍批处理。\n\n首先，它收集所有的 `select` 语句，同时运行它见到的所有 `set` 语句。作为副作用，只有最后的 `set profiling` 生效。如果你以 `set profiling=1; select...; show meta; show profile; set profiling=0` 运行多查询，你将看不到任何性能分析，因为在第一遍中守护进程执行了 `set profiling=1`，然后立刻执行了最后的 `set profiling=0`。\n\n其次，守护进程尝试执行包含所有收集的 `select` 语句的单批查询。如果语句不相关；它将逐一执行它们。\n\n最后，它迭代初始批处理序列，并为每个 `select` 和 `show` 返回其子结果数据和来自结果集的元数据。所有 `set` 语句已经在第一遍执行过了，因此在第二遍中被跳过。",
      "russian": "Вы можете использовать `set` только для `set profiling`. Все остальные команды `set` будут проигнорированы без уведомления.\n\nПорядок выполнения также отличается. Демон обрабатывает пакет запросов в 2 прохода.\n\nСначала он собирает все операторы `select` и одновременно выполняет все встречающиеся `set`. В качестве побочного эффекта, эффективно только последнее `set profiling`. Если вы запускаете мультизапрос как `set profiling=1; select...; show meta; show profile; set profiling=0`, вы не увидите профиль, потому что на первом проходе демон выполняет `set profiling=1`, а затем сразу же последнее `set profiling=0`.\n\nВо втором проходе демон пытается выполнить пакетный запрос с собранными операторами `select`. Если операторы не связаны, он выполняет их по одному.\n\nНаконец, он проходит по исходной последовательности пакета и для каждого `select` и `show` возвращает его подрезультат и метаданные из набора результатов. Все операторы `set` уже были выполнены в первом проходе, и поэтому на втором они пропускаются."
    },
    "is_code_or_comment": false
  },
  "2e13d07f81a1a2aba5b4cce798e3c34bef143841a2c18ac507fd9eedf12046fc": {
    "original": "# Multi-queries\n\nMulti-queries, or query batches, allow you to send multiple search queries to Manticore in a single network request.\n\n👍 Why use multi-queries?\n\nThe primary reason is performance. By sending requests to Manticore in a batch instead of one by one, you save time by reducing network round-trips. Additionally, sending queries in a batch allows Manticore to perform certain internal optimizations. If no batch optimizations can be applied, queries will be processed individually.\n\n⛔ When not to use multi-queries?\n\nMulti-queries require all search queries in a batch to be independent, which isn't always the case. Sometimes query B depends on query A's results, meaning query B can only be set up after executing query A. For example, you might want to display results from a secondary index only if no results were found in the primary table, or you may want to specify an offset into the 2nd result set based on the number of matches in the 1st result set. In these cases, you'll need to use separate queries (or separate batches).\n\nWhen using connector libraries, like `mysqli` in php, you can add several queries, and then run all of them as single batch. That will work as single multi-query batch.\n\nNotice: if you use console mysql client, by default it interprets semicolon as delimiter itself, and then sends queries to the server one-by-one; that is NOT multi-query batch. To override this, redefine separator on client side to another character with internal command `delimiter`. After such operation, client will send whole string with semicolons unchanged, and so, multi-query magic can work.\n\nThis aside behavior of console client often confuses, because you can notice, that one and same sequence of commands behaves differently from mysql client console, in opposite to another proto like sql-over-http. That is exactly because mysql console client itself divides queries by semicolon, but another proto may send whole sequence as single batch.\n\n<!-- example multi-query 1 -->\n\nYou can run multiple search queries with SQL by separating them with a semicolon. When Manticore receives a query formatted like this from a client, all inter-statement optimizations will be applied.\n\nMulti-queries don't support queries with `FACET`. The number of multi-queries in one batch shouldn't exceed [max_batch_queries](../Server_settings/Searchd.md#max_batch_queries).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- end -->\n\nFrom console mysql/mariadb client:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n## Multi-queries optimizations\n\nThere are two major optimizations to be aware of: common query optimization and common subtree optimization.\n\n**Common query optimization** means that `searchd` will identify all those queries in a batch where only the sorting and group-by settings differ, and *only perform searching once*. For example, if a batch consists of 3 queries, all of them are for \"ipod nano\", but the 1st query requests the top-10 results sorted by price, the 2nd query groups by vendor ID and requests the top-5 vendors sorted by rating, and the 3rd query requests the max price, full-text search for \"ipod nano\" will only be performed once, and its results will be reused to build 3 different result sets.\n\n[Faceted search](../Searching/Faceted_search.md) is a particularly important case that benefits from this optimization. Indeed, faceted searching can be implemented by running several queries, one to retrieve search results themselves, and a few others with the same full-text query but different group-by settings to retrieve all the required groups of results (top-3 authors, top-5 vendors, etc). As long as the full-text query and filtering settings stay the same, common query optimization will trigger, and greatly improve performance.\n\n**Common subtree optimization** is even more interesting. It allows `searchd` to exploit similarities between batched full-text queries. It identifies common full-text query parts (subtrees) in all queries and caches them between queries. For example, consider the following query batch:\n\nCODE_BLOCK_2\n\nThere's a common two-word part `donald trump` that can be computed only once, then cached and shared across the queries. And common subtree optimization does just that. Per-query cache size is strictly controlled by [subtree_docs_cache](../Server_settings/Searchd.md#subtree_docs_cache) and [subtree_hits_cache](../Server_settings/Searchd.md#subtree_hits_cache) directives (so that caching *all* sixteen gazillions of documents that match \"i am\" does not exhaust the RAM and instantly kill your server).\n\n<!-- example multi-query 2 -->\n\nHow can you tell if the queries in the batch were actually optimized? If they were, the respective query log will have a \"multiplier\" field that specifies how many queries were processed together:\n\nNote the \"x3\" field. It means that this query was optimized and processed in a sub-batch of 3 queries.\n\n<!-- intro -->\n\n##### log:\n\n<!-- request log -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- example multi-query 3 -->\n\nFor reference, this is how the regular log would look like if the queries were not batched:\n\n<!-- intro -->\n\n##### log:\n\n<!-- request log -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\nNotice how the per-query time in the multi-query case improved by a factor of 1.5x to 2.3x, depending on the specific sorting mode.\n\n## Multi-queries limitations and flow\n\nMulti-queries supported mainly for batching queries and receiving meta-info after such batches. Because of it, only small subset of statements allowed in batches. In one batch you can combine only `select`, `show`, and `set` statements.\n\nYou can use `select` as usual; but notice, that they will be run all together in one pass. If queries are not related, there are no benefits from multi-query. Daemon will detect it, and run queries one-by-one.\n\nYou can use `show` for processing warnings, status, agent status, meta, profile, and plan. All other `show` in batches\n\nwill be silently ignored with no output. For example, you can't `show tables`, or `show threads`, or\n\n`show variables`, or whatever not mentioned above with batching.",
    "translations": {
      "chinese": "# 多查询\n\n多查询，或查询批处理，允许您在一次网络请求中向 Manticore 发送多个搜索查询。\n\n👍 为什么使用多查询？\n\n主要原因是性能。通过批量发送请求给 Manticore，而不是逐个发送，您可以通过减少网络往返次数来节省时间。此外，批量发送查询允许 Manticore 执行某些内部优化。如果无法应用批处理优化，查询将单独处理。\n\n⛔ 什么时候不使用多查询？\n\n多查询要求批处理中的所有搜索查询相互独立，但情况并非总是如此。有时查询 B 依赖于查询 A 的结果，这意味着只能在执行查询 A 后设置查询 B。例如，您可能只想在主表中未找到结果时显示来自辅助索引的结果，或者您可能想根据第一个结果集中的匹配数量指定第二个结果集中的偏移量。在这些情况下，您需要使用单独的查询（或单独的批处理）。\n\n使用像 php 中的 `mysqli` 这样的连接库时，您可以添加多个查询，然后将它们作为单个批处理运行。这将作为单个多查询批处理工作。\n\n注意：如果您使用控制台 mysql 客户端，默认情况下它会自行将分号解释为分隔符，然后逐条发送查询到服务器；这不是多查询批处理。要覆盖此行为，请在客户端使用内部命令 `delimiter` 将分隔符重新定义为另一个字符。完成此操作后，客户端将发送带有未更改分号的整个字符串，因此，多查询的功能才能生效。\n\n这种控制台客户端的特殊行为经常令人困惑，因为您可能会注意到同一串命令在 mysql 控制台客户端中的表现与在其它协议如 sql-over-http 中不同。这正是因为 mysql 控制台客户端本身通过分号分割查询，而其他协议可能将整个序列作为单个批处理发送。\n\n<!-- example multi-query 1 -->\n\n您可以通过用分号分隔的方式使用 SQL 运行多个搜索查询。当 Manticore 从客户端收到这样格式化的查询时，将应用所有语句间的优化。\n\n多查询不支持带有 `FACET` 的查询。单个批处理中的多查询数量不应超过 [max_batch_queries](../Server_settings/Searchd.md#max_batch_queries)。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- end -->\n\n在控制台 mysql/mariadb 客户端中：\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n## 多查询优化\n\n有两种主要的优化需要注意：公共查询优化和公共子树优化。\n\n**公共查询优化** 意味着 `searchd` 会识别批处理中那些仅排序和分组设置不同的查询，并且*只执行一次搜索*。例如，如果批处理中有3个查询，全部针对“ipod nano”，第一个查询请求按价格排序的前10名结果，第二个查询按供应商 ID 分组并请求按评分排序的前5名供应商，第三个查询请求最大价格，则全文搜索“ipod nano”只执行一次，其结果将被重用来构建三个不同的结果集。\n\n[分面搜索](../Searching/Faceted_search.md) 是特别受益于此优化的一个重要场景。实际上，分面搜索可以通过运行几个查询来实现，一个用于获取搜索结果本身，其他几个带有相同全文查询但不同分组设置的查询用于获取所有需要的结果组（如前3名作者，前5名供应商等）。只要全文查询和过滤设置保持不变，公共查询优化将被触发，显著提升性能。\n\n**公共子树优化** 更加有趣。它允许 `searchd` 利用批量全文查询中的相似性。它识别所有查询中共有的全文查询部分（子树），在查询间缓存它们。例如，考虑如下查询批处理：\n\nCODE_BLOCK_2\n\n存在一段公共的两词部分 `donald trump`，只需计算一次，然后缓存并在所有查询间共享。公共子树优化就是这样做的。每个查询的缓存大小严格受 [subtree_docs_cache](../Server_settings/Searchd.md#subtree_docs_cache) 和 [subtree_hits_cache](../Server_settings/Searchd.md#subtree_hits_cache) 指令控制（以避免缓存 *所有* 数十亿个匹配“i am”的文档而耗尽内存并导致服务器崩溃）。\n\n<!-- example multi-query 2 -->\n\n如何判断批处理中的查询是否实际进行了优化？如果优化了，相应的查询日志会有一个“multiplier”字段，指定一起处理的查询数量：\n\n注意 \"x3\" 字段。它表示此查询被优化并在一个包含3个查询的子批处理中处理。\n\n<!-- intro -->\n\n##### 日志:\n\n<!-- request log -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- example multi-query 3 -->\n\n作为参考，如果查询没有批处理，常规日志看起来会是这样：\n\n<!-- intro -->\n\n##### 日志:\n\n<!-- request log -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n注意在多查询情况下，每个查询的执行时间提升了约 1.5 倍到 2.3 倍，具体取决于排序模式。\n\n## 多查询的限制和流程\n\n多查询主要支持批处理查询和在批次结束后接收元信息。因此，批处理中只允许使用少量语句。在一个批处理里，您只能组合使用 `select`、`show` 和 `set` 语句。\n\n您可以像往常一样使用 `select`，但请注意，它们将同时在一次执行中运行。如果查询之间不相关，多查询无益。守护进程会检测这一点，并逐个运行查询。\n\n您可以用 `show` 查看警告、状态、代理状态、元信息、性能分析及执行计划。所有其他 `show` 语句在批处理中\n\n将被静默忽略且无输出。例如，您不能在批处理中执行 `show tables`，或者 `show threads`，或者\n\n`show variables`，或者其他未提及的 `show` 命令。",
      "russian": "# Мульти-запросы\n\nМульти-запросы, или пакетные запросы, позволяют отправлять несколько поисковых запросов в Manticore в одном сетевом запросе.\n\n👍 Почему стоит использовать мульти-запросы?\n\nОсновная причина — производительность. Отправляя запросы в Manticore пачкой, а не по одному, вы экономите время, сокращая количество сетевых кругов. Кроме того, отправка запросов пачкой позволяет Manticore выполнять определённые внутренние оптимизации. Если оптимизации пакета применить нельзя, запросы будут обработаны по отдельности.\n\n⛔ Когда не стоит использовать мульти-запросы?\n\nМульти-запросы требуют, чтобы все поисковые запросы в пачке были независимыми, что бывает не всегда. Иногда запрос B зависит от результатов запроса A, то есть запрос B можно сформировать только после выполнения запроса A. Например, можно захотеть показать результаты из вторичного индекса только в случае отсутствия результатов в основной таблице, или задать смещение во втором наборе результатов на основе количества совпадений в первом наборе. В таких случаях следует использовать отдельные запросы (или отдельные пачки).\n\nПри использовании библиотек-коннекторов, например `mysqli` в php, можно добавить несколько запросов, а затем выполнить их все единой пачкой. Это будет работать как один мульти-запрос.\n\nВажно: если вы используете консольный mysql клиент, по умолчанию он сам разбирает точку с запятой как разделитель и отправляет запросы по отдельности; это НЕ мульти-запрос. Чтобы отменить это поведение, переопределите разделитель в клиенте на другой символ внутренней командой `delimiter`. После этого клиент будет отправлять всю строку с точками с запятой без изменений, и мульти-запрос будет работать.\n\nЭто поведение консольного клиента часто вызывает путаницу, потому что кажется, что одна и та же последовательность команд ведёт себя по-разному в mysql консоли и, например, в sql-over-http. Именно потому, что mysql клиент сам делит запросы по точкам с запятой, а другой протокол может отослать всю последовательность как один пакет.\n\n<!-- example multi-query 1 -->\n\nВы можете выполнить несколько поисковых запросов через SQL, разделяя их точкой с запятой. Когда Manticore получает такой формат запроса от клиента, применяются все оптимизации между операторами.\n\nМульти-запросы не поддерживают запросы с `FACET`. Число мульти-запросов в одной пачке не должно превышать [max_batch_queries](../Server_settings/Searchd.md#max_batch_queries).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- end -->\n\nИз консольного клиента mysql/mariadb:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n## Оптимизации мульти-запросов\n\nСуществуют две основные оптимизации, о которых стоит знать: оптимизация общих запросов и оптимизация общих поддеревьев.\n\n**Оптимизация общих запросов** означает, что `searchd` выявит все запросы в пачке, отличающиеся только настройками сортировки и группировки, и выполнит поиск *только один раз*. Например, если пачка состоит из 3 запросов, все они ищут \"ipod nano\", но первый запрос запрашивает топ-10 результатов, отсортированных по цене, второй группирует по ID поставщика и запрашивает топ-5 по рейтингу, а третий запрашивает максимальную цену, полнотекстовый поиск \"ipod nano\" будет выполнен единожды, результаты которого будут переиспользованы для построения трёх различных наборов результатов.\n\n[Фасетный поиск](../Searching/Faceted_search.md) особенно выигрывает от этой оптимизации. Действительно, фасетный поиск можно реализовать, выполнив несколько запросов: один для получения результатов поиска, и несколько других с тем же полнотекстовым запросом, но разными настройками группировки, чтобы получить необходимые группы результатов (топ-3 автора, топ-5 поставщиков и т.д.). Пока полнотекстовый запрос и фильтры не меняются, сработает оптимизация общих запросов, что существенно повысит производительность.\n\n**Оптимизация общих поддеревьев** ещё более интересна. Она позволяет `searchd` использовать схожесть между пакетными полнотекстовыми запросами. Ищутся общие части полнотекстовых запросов (поддеревья) среди всех запросов и кешируются для повторного использования. Например, рассмотрим следующую пачку запросов:\n\nCODE_BLOCK_2\n\nЗдесь есть общая двухсловная часть `donald trump`, которую можно вычислить один раз, затем кешировать и использовать во всех запросах. Именно этим и занимается оптимизация общих поддеревьев. Размер кеша на запрос строго контролируется директивами [subtree_docs_cache](../Server_settings/Searchd.md#subtree_docs_cache) и [subtree_hits_cache](../Server_settings/Searchd.md#subtree_hits_cache) (чтобы кеширование *всех* бесчисленных документов, соответствующих \"i am\", не исчерпало ОЗУ и не убило ваш сервер).\n\n<!-- example multi-query 2 -->\n\nКак понять, были ли запросы в пакете действительно оптимизированы? Если да, в соответствующем логе запроса появится поле \"multiplier\", указывающее, сколько запросов было обработано вместе:\n\nОбратите внимание на поле \"x3\". Это значит, что запрос был оптимизирован и выполнен в сабпакете из 3 запросов.\n\n<!-- intro -->\n\n##### log:\n\n<!-- request log -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n<!-- example multi-query 3 -->\n\nДля сравнения, вот как выглядел бы обычный лог, если бы запросы не были объединены в пакет:\n\n<!-- intro -->\n\n##### log:\n\n<!-- request log -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\nОбратите внимание, что время обработки запроса в случае мульти-запроса улучшилось в 1.5–2.3 раза в зависимости от режима сортировки.\n\n## Ограничения и порядок работы мульти-запросов\n\nМульти-запросы поддерживаются в основном для пакетной обработки запросов и получения мета-информации в одном вызове. Из-за этого в пакетах разрешён только небольшой подмножество операторов. В одной пачке можно использовать только операторы `select`, `show` и `set`.\n\nВы можете использовать `select` как обычно; при этом они будут выполнены все вместе за один проход. Если запросы не связаны, мульти-запрос не даст преимуществ. Демон это определит и выполнит запросы по отдельности.\n\nВы можете использовать `show` для получения предупреждений, статуса, состояния агентов, мета-информации, профилей и планов. Все остальные запросы `show` в пакетах будут тихо игнорироваться без вывода. Например, нельзя выполнять `show tables`, `show threads`, `show variables` и подобные с помощью пакетных запросов."
    },
    "is_code_or_comment": false
  }
}
