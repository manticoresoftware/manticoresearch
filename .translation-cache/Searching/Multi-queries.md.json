{
  "384e7926633ad3bd119a972defabb5e7fec382339d6d7726e8b97764fadb9deb": {
    "original": "# Multi-queries\n\nMulti-queries, or query batches, allow you to send multiple search queries to Manticore in a single network request.\n\n👍 Why use multi-queries?\n\nThe primary reason is performance. By sending requests to Manticore in a batch instead of one by one, you save time by reducing network round-trips. Additionally, sending queries in a batch allows Manticore to perform certain internal optimizations. If no batch optimizations can be applied, queries will be processed individually.\n\n⛔ When not to use multi-queries?\n\nMulti-queries require all search queries in a batch to be independent, which isn't always the case. Sometimes query B depends on query A's results, meaning query B can only be set up after executing query A. For example, you might want to display results from a secondary index only if no results were found in the primary table, or you may want to specify an offset into the 2nd result set based on the number of matches in the 1st result set. In these cases, you'll need to use separate queries (or separate batches).\n\n<!-- example multi-query 1 -->\n\nYou can run multiple search queries with SQL by separating them with a semicolon. When Manticore receives a query formatted like this from a client, all inter-statement optimizations will be applied.\n\nMulti-queries don't support queries with `FACET`. The number of multi-queries in one batch shouldn't exceed [max_batch_queries](../Server_settings/Searchd.md#max_batch_queries).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- end -->\n\n## Multi-queries optimizations\n\nThere are two major optimizations to be aware of: common query optimization and common subtree optimization.\n\n**Common query optimization** means that `searchd` will identify all those queries in a batch where only the sorting and group-by settings differ, and *only perform searching once*. For example, if a batch consists of 3 queries, all of them are for \"ipod nano\", but the 1st query requests the top-10 results sorted by price, the 2nd query groups by vendor ID and requests the top-5 vendors sorted by rating, and the 3rd query requests the max price, full-text search for \"ipod nano\" will only be performed once, and its results will be reused to build 3 different result sets.\n\n[Faceted search](../Searching/Faceted_search.md) is a particularly important case that benefits from this optimization. Indeed, faceted searching can be implemented by running several queries, one to retrieve search results themselves, and a few others with the same full-text query but different group-by settings to retrieve all the required groups of results (top-3 authors, top-5 vendors, etc). As long as the full-text query and filtering settings stay the same, common query optimization will trigger, and greatly improve performance.\n\n**Common subtree optimization** is even more interesting. It allows `searchd` to exploit similarities between batched full-text queries. It identifies common full-text query parts (subtrees) in all queries and caches them between queries. For example, consider the following query batch:\n\nCODE_BLOCK_1\n\nThere's a common two-word part `donald trump` that can be computed only once, then cached and shared across the queries. And common subtree optimization does just that. Per-query cache size is strictly controlled by [subtree_docs_cache](../Server_settings/Searchd.md#subtree_docs_cache) and [subtree_hits_cache](../Server_settings/Searchd.md#subtree_hits_cache) directives (so that caching *all* sixteen gazillions of documents that match \"i am\" does not exhaust the RAM and instantly kill your server).\n\n<!-- example multi-query 2 -->\n\nHow can you tell if the queries in the batch were actually optimized? If they were, the respective query log will have a \"multiplier\" field that specifies how many queries were processed together:\n\nNote the \"x3\" field. It means that this query was optimized and processed in a sub-batch of 3 queries.\n\n<!-- intro -->\n\n##### log:\n\n<!-- request log -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n<!-- example multi-query 3 -->\n\nFor reference, this is how the regular log would look like if the queries were not batched:\n\n<!-- intro -->\n\n##### log:\n\n<!-- request log -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\nNotice how the per-query time in the multi-query case improved by a factor of 1.5x to 2.3x, depending on the specific sorting mode.\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 多查询\n\n多查询，或称查询批处理，允许您在一次网络请求中向 Manticore 发送多个搜索查询。\n\n👍 为什么使用多查询？\n\n主要原因是性能。通过批量发送请求给 Manticore，而不是逐个发送，您可以通过减少网络往返时间来节省时间。此外，批量发送查询允许 Manticore 执行某些内部优化。如果无法应用批量优化，查询将被单独处理。\n\n⛔ 何时不使用多查询？\n\n多查询要求批处理中的所有搜索查询相互独立，但情况并非总是如此。有时查询 B 依赖于查询 A 的结果，这意味着查询 B 只能在执行查询 A 后设置。例如，您可能只想在主表中未找到结果时显示来自辅助索引的结果，或者您可能想根据第一个结果集中的匹配数指定第二个结果集的偏移量。在这些情况下，您需要使用单独的查询（或单独的批处理）。\n\n<!-- example multi-query 1 -->\n\n您可以通过用分号分隔多个搜索查询来运行多查询。当 Manticore 从客户端接收到这样格式的查询时，将应用所有语句间的优化。\n\n多查询不支持带有 `FACET` 的查询。单个批处理中的多查询数量不应超过 [max_batch_queries](../Server_settings/Searchd.md#max_batch_queries)。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- end -->\n\n## 多查询优化\n\n需要注意两种主要优化：公共查询优化和公共子树优化。\n\n**公共查询优化** 意味着 `searchd` 会识别批处理中所有仅排序和分组设置不同的查询，并且*只执行一次搜索*。例如，如果一个批处理包含 3 个查询，它们都是针对“ipod nano”的，但第一个查询请求按价格排序的前 10 个结果，第二个查询按供应商 ID 分组并请求按评分排序的前 5 个供应商，第三个查询请求最大价格，则全文搜索“ipod nano”只会执行一次，其结果将被重用以构建 3 个不同的结果集。\n\n[分面搜索](../Searching/Faceted_search.md) 是特别受益于此优化的一个重要案例。实际上，分面搜索可以通过运行多个查询来实现，一个用于检索搜索结果本身，其他几个使用相同的全文查询但不同的分组设置来检索所有所需的结果组（前 3 名作者，前 5 名供应商等）。只要全文查询和过滤设置保持不变，公共查询优化就会触发，并大大提高性能。\n\n**公共子树优化** 更加有趣。它允许 `searchd` 利用批量全文查询之间的相似性。它识别所有查询中的公共全文查询部分（子树）并在查询之间缓存它们。例如，考虑以下查询批处理：\n\nCODE_BLOCK_1\n\n有一个公共的两词部分 `donald trump`，只需计算一次，然后缓存并在查询间共享。公共子树优化正是这样做的。每个查询的缓存大小由 [subtree_docs_cache](../Server_settings/Searchd.md#subtree_docs_cache) 和 [subtree_hits_cache](../Server_settings/Searchd.md#subtree_hits_cache) 指令严格控制（以防缓存*所有*匹配“i am”的十六亿亿文档耗尽内存并立即导致服务器崩溃）。\n\n<!-- example multi-query 2 -->\n\n如何判断批处理中的查询是否真的被优化了？如果是，相关的查询日志将有一个“multiplier”字段，指定一起处理了多少个查询：\n\n注意“x3”字段。这意味着该查询被优化并在一个包含 3 个查询的子批处理中处理。\n\n<!-- intro -->\n\n##### 日志:\n\n<!-- request log -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n<!-- example multi-query 3 -->\n\n作为参考，如果查询未批处理，常规日志将如下所示：\n\n<!-- intro -->\n\n##### 日志:\n\n<!-- request log -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n注意多查询情况下每个查询的时间提升了 1.5 倍到 2.3 倍，具体取决于排序模式。\n\n<!-- proofread -->",
      "russian": "# Мультизапросы\n\nМультизапросы, или пакеты запросов, позволяют отправлять несколько поисковых запросов в Manticore в одном сетевом запросе.\n\n👍 Почему стоит использовать мультизапросы?\n\nОсновная причина — производительность. Отправляя запросы в Manticore пакетами, а не по одному, вы экономите время за счёт уменьшения количества сетевых обращений. Кроме того, отправка запросов пакетами позволяет Manticore выполнять определённые внутренние оптимизации. Если оптимизации пакета применить нельзя, запросы будут обработаны по отдельности.\n\n⛔ Когда не стоит использовать мультизапросы?\n\nМультизапросы требуют, чтобы все поисковые запросы в пакете были независимы, что бывает не всегда. Иногда запрос B зависит от результатов запроса A, то есть запрос B можно сформировать только после выполнения запроса A. Например, вы можете захотеть показать результаты из вторичного индекса только если в основной таблице не было найдено результатов, или указать смещение во втором наборе результатов на основе количества совпадений в первом наборе. В таких случаях нужно использовать отдельные запросы (или отдельные пакеты).\n\n<!-- example multi-query 1 -->\n\nВы можете выполнять несколько поисковых запросов в SQL, разделяя их точкой с запятой. Когда Manticore получает такой запрос от клиента, применяются все оптимизации между запросами.\n\nМультизапросы не поддерживают запросы с `FACET`. Количество мультизапросов в одном пакете не должно превышать [max_batch_queries](../Server_settings/Searchd.md#max_batch_queries).\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- end -->\n\n## Оптимизации мультизапросов\n\nСуществует две основные оптимизации, о которых стоит знать: оптимизация общих запросов и оптимизация общих поддеревьев.\n\n**Оптимизация общих запросов** означает, что `searchd` определит все запросы в пакете, которые отличаются только настройками сортировки и группировки, и *выполнит поиск только один раз*. Например, если пакет состоит из 3 запросов, все они по запросу \"ipod nano\", но первый запрос запрашивает топ-10 результатов, отсортированных по цене, второй группирует по ID поставщика и запрашивает топ-5 поставщиков, отсортированных по рейтингу, а третий запрашивает максимальную цену, полнотекстовый поиск по \"ipod nano\" будет выполнен только один раз, а его результаты будут использованы для построения трёх разных наборов результатов.\n\n[Фасетный поиск](../Searching/Faceted_search.md) — особенно важный случай, который выигрывает от этой оптимизации. Действительно, фасетный поиск можно реализовать, выполняя несколько запросов: один для получения самих результатов поиска и несколько других с тем же полнотекстовым запросом, но с разными настройками группировки, чтобы получить все необходимые группы результатов (топ-3 авторов, топ-5 поставщиков и т.д.). Пока полнотекстовый запрос и настройки фильтрации остаются одинаковыми, сработает оптимизация общих запросов, значительно улучшая производительность.\n\n**Оптимизация общих поддеревьев** ещё интереснее. Она позволяет `searchd` использовать сходства между пакетными полнотекстовыми запросами. Он выявляет общие части полнотекстовых запросов (поддеревья) во всех запросах и кэширует их между запросами. Например, рассмотрим следующий пакет запросов:\n\nCODE_BLOCK_1\n\nЕсть общая двухсловная часть `donald trump`, которую можно вычислить один раз, затем закэшировать и использовать во всех запросах. Именно это и делает оптимизация общих поддеревьев. Размер кэша на запрос строго контролируется директивами [subtree_docs_cache](../Server_settings/Searchd.md#subtree_docs_cache) и [subtree_hits_cache](../Server_settings/Searchd.md#subtree_hits_cache) (чтобы кэширование *всех* шестнадцати миллиардов документов, соответствующих \"i am\", не исчерпало оперативную память и не убило сервер).\n\n<!-- example multi-query 2 -->\n\nКак узнать, были ли запросы в пакете действительно оптимизированы? Если да, в соответствующем логе запросов появится поле \"multiplier\", указывающее, сколько запросов было обработано вместе:\n\nОбратите внимание на поле \"x3\". Это означает, что запрос был оптимизирован и обработан в под-пакете из 3 запросов.\n\n<!-- intro -->\n\n##### log:\n\n<!-- request log -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n<!-- example multi-query 3 -->\n\nДля сравнения, вот как выглядел бы обычный лог, если бы запросы не были объединены в пакет:\n\n<!-- intro -->\n\n##### log:\n\n<!-- request log -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\nОбратите внимание, что время на запрос в случае мультизапроса улучшилось в 1.5–2.3 раза, в зависимости от конкретного режима сортировки.\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
