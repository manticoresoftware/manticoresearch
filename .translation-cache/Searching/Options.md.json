{
  "4d289b509b43403d14193cceffe34d851804e53c04875340fd5d5e3d15dbaa0c": {
    "original": "You can also enforce a guaranteed groupby/aggregate accuracy mode using the [accurate_aggregation](../Searching/Options.md#accurate_aggregation) option.\n\n### max_query_time\n\nSets the maximum search query time in milliseconds. Must be a non-negative integer. The default value is 0, which means \"do not limit.\" Local search queries will be stopped once the specified time has elapsed. Note that if you're performing a search that queries multiple local tables, this limit applies to each table separately. Be aware that this may slightly increase the query's response time due to the overhead caused by constantly tracking whether it's time to stop the query.\n\n### max_predicted_time\n\nInteger. Maximum predicted search time; see [predicted_time_costs](../Server_settings/Searchd.md#predicted_time_costs).\n\n### morphology\n\n`none` allows replacing all query terms with their exact forms if the table was built with [index_exact_words](../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words) enabled. This is useful for preventing stemming or lemmatizing query terms.\n\n### not_terms_only_allowed\n\n<!-- example not_terms_only_allowed -->\n\n`0` or `1` allows standalone [negation](../Searching/Full_text_matching/Operators.md#Negation-operator) for the query. The default is 0. See also the corresponding [global setting](../Server_settings/Searchd.md#not_terms_only_allowed).\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- end -->\n\n### ranker\n\nChoose from the following options:\n\n* `proximity_bm25`\n\n* `bm25`\n\n* `none`\n\n* `wordcount`\n\n* `proximity`\n\n* `matchany`\n\n* `fieldmask`\n\n* `sph04`\n\n* `expr`\n\n* `export`\n\nFor more details on each ranker, refer to [Search results ranking](../Searching/Sorting_and_ranking.md#Available-built-in-rankers).\n\n### rand_seed\n\nAllows you to specify a specific integer seed value for an `ORDER BY RAND()` query, for example: `... OPTION rand_seed=1234`. By default, a new and different seed value is autogenerated for every query.\n\n### retry_count\n\nInteger. Distributed retries count.\n\n### retry_delay\n\nInteger. Distributed retry delay, in milliseconds.\n\n### scroll\n\nString. A scroll token for paginating results using the [Scroll pagination approach](../Searching/Pagination.md#Scroll-Search-Option).\n\n### sort_method\n\n* `pq` - priority queue, set by default\n\n* `kbuffer` - provides faster sorting for already pre-sorted data, e.g., table data sorted by id\n\nThe result set is the same in both cases; choosing one option or the other may simply improve (or worsen) performance.\n\n### threads\n\nLimits the max number of threads used for current query processing. Default - no limit (the query can occupy all [threads](../Server_settings/Searchd.md#threads) as defined globally).\n\nFor a batch of queries, the option must be attached to the very first query in the batch, and it is then applied when the working queue is created and is effective for the entire batch. This option has the same meaning as the option [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query), but is applied only to the current query or batch of queries.\n\n### token_filter\n\nQuoted, colon-separated string of `library name:plugin name:optional string of settings`. A query-time token filter is created for each search when full-text is invoked by every table involved, allowing you to implement a custom tokenizer that generates tokens according to custom rules.\n\nCODE_BLOCK_10\n\n### expansion_limit\n\nRestricts the maximum number of expanded keywords for a single wildcard, with a default value of 0 indicating no limit. For additional details, refer to [expansion_limit](../Server_settings/Searchd.md#expansion_limit).\n\n## Query optimizer hints\n\n<!-- example options_force -->\n\nIn rare cases, Manticore's built-in query analyzer may be incorrect in understanding a query and determining whether a docid index, secondary indexes, or columnar scan should be used. To override the query optimizer's decisions, you can use the following hints in your query:\n\n* `/*+ DocidIndex(id) */`  to force the use of a docid index, `/*+ NO_DocidIndex(id) */` to tell the optimizer to ignore it\n\n* `/*+ SecondaryIndex(<attr_name1>[, <attr_nameN>]) */` to force the use of a secondary index (if available), `/*+ NO_SecondaryIndex(id) */`  to tell the optimizer to ignore it\n\n* `/*+ ColumnarScan(<attr_name1>[, <attr_nameN>]) */`  to force the use of a columnar scan (if the attribute is columnar), `/*+ NO_ColumnarScan(id) */` to tell the optimizer to ignore it\n\nNote that when executing a full-text query with filters, the query optimizer decides between intersecting the results of the full-text tree with the filter results or using a standard match-then-filter approach. Specifying *any* hint will force the daemon to use the code path that performs the intersection of the full-text tree results with the filter results.\n\nFor more information on how the query optimizer works, refer to the [Cost based optimizer](../Searching/Cost_based_optimizer.md) page.\n\n<!-- request SQL -->\n\nCODE_BLOCK_11\n\n<!-- end -->\n\n<!-- example comments -->\n\nWhen using a MySQL/MariaDB client, make sure to include the `--comments` flag to enable the hints in your queries.\n\n<!-- request mysql -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "您还可以使用[accurate_aggregation](../Searching/Options.md#accurate_aggregation)选项强制执行保证的groupby/聚合准确模式。\n\n### max_query_time\n\n设置最大搜索查询时间，单位为毫秒。必须是非负整数。默认值为0，表示“不限制”。本地搜索查询将在指定时间到达后停止。请注意，如果您执行的是查询多个本地表的搜索，则此限制分别适用于每个表。请注意，由于不断跟踪是否该停止查询，这可能会略微增加查询的响应时间。\n\n### max_predicted_time\n\n整数。最大预测搜索时间；参见[predicted_time_costs](../Server_settings/Searchd.md#predicted_time_costs)。\n\n### morphology\n\n`none`允许将所有查询词替换为其精确形式，前提是表是在启用[index_exact_words](../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words)的情况下构建的。这对于防止查询词的词干提取或词形还原非常有用。\n\n### not_terms_only_allowed\n\n<!-- example not_terms_only_allowed -->\n\n`0`或`1`允许查询中独立的[否定](../Searching/Full_text_matching/Operators.md#Negation-operator)。默认值为0。另请参见相应的[全局设置](../Server_settings/Searchd.md#not_terms_only_allowed)。\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- end -->\n\n### ranker\n\n可从以下选项中选择：\n\n* `proximity_bm25`\n\n* `bm25`\n\n* `none`\n\n* `wordcount`\n\n* `proximity`\n\n* `matchany`\n\n* `fieldmask`\n\n* `sph04`\n\n* `expr`\n\n* `export`\n\n有关每个排序器的更多详细信息，请参阅[搜索结果排名](../Searching/Sorting_and_ranking.md#Available-built-in-rankers)。\n\n### rand_seed\n\n允许您为`ORDER BY RAND()`查询指定特定的整数种子值，例如：`... OPTION rand_seed=1234`。默认情况下，每个查询都会自动生成一个新的不同的种子值。\n\n### retry_count\n\n整数。分布式重试次数。\n\n### retry_delay\n\n整数。分布式重试延迟，单位为毫秒。\n\n### scroll\n\n字符串。用于使用[滚动分页方法](../Searching/Pagination.md#Scroll-Search-Option)进行结果分页的滚动令牌。\n\n### sort_method\n\n* `pq` - 优先队列，默认设置\n\n* `kbuffer` - 为已预排序数据提供更快的排序，例如按id排序的表数据\n\n两种情况下的结果集相同；选择其中一个选项可能仅仅是提高（或降低）性能。\n\n### threads\n\n限制当前查询处理使用的最大线程数。默认 - 无限制（查询可以占用全局定义的所有[线程](../Server_settings/Searchd.md#threads)）。\n\n对于一批查询，该选项必须附加到批次中的第一个查询，然后在创建工作队列时应用，并对整个批次生效。此选项与选项[max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query)含义相同，但仅应用于当前查询或查询批次。\n\n### token_filter\n\n带引号的、用冒号分隔的字符串，格式为`library name:plugin name:optional string of settings`。每当涉及的每个表调用全文搜索时，都会为每次搜索创建一个查询时令牌过滤器，允许您实现根据自定义规则生成令牌的自定义分词器。\n\nCODE_BLOCK_10\n\n### expansion_limit\n\n限制单个通配符展开的最大关键字数，默认值为0表示无限制。更多详情请参阅[expansion_limit](../Server_settings/Searchd.md#expansion_limit)。\n\n## 查询优化器提示\n\n<!-- example options_force -->\n\n在极少数情况下，Manticore内置的查询分析器可能无法正确理解查询并确定应使用docid索引、二级索引还是列扫描。要覆盖查询优化器的决策，您可以在查询中使用以下提示：\n\n* `/*+ DocidIndex(id) */` 强制使用docid索引，`/*+ NO_DocidIndex(id) */` 告诉优化器忽略它\n\n* `/*+ SecondaryIndex(<attr_name1>[, <attr_nameN>]) */` 强制使用二级索引（如果可用），`/*+ NO_SecondaryIndex(id) */` 告诉优化器忽略它\n\n* `/*+ ColumnarScan(<attr_name1>[, <attr_nameN>]) */` 强制使用列扫描（如果属性是列式的），`/*+ NO_ColumnarScan(id) */` 告诉优化器忽略它\n\n请注意，在执行带过滤器的全文查询时，查询优化器会决定是将全文树结果与过滤器结果相交，还是使用标准的先匹配后过滤方法。指定*任何*提示都会强制守护进程使用执行全文树结果与过滤器结果相交的代码路径。\n\n有关查询优化器工作原理的更多信息，请参阅[基于成本的优化器](../Searching/Cost_based_optimizer.md)页面。\n\n<!-- request SQL -->\n\nCODE_BLOCK_11\n\n<!-- end -->\n\n<!-- example comments -->\n\n使用MySQL/MariaDB客户端时，请确保包含`--comments`标志以启用查询中的提示。\n\n<!-- request mysql -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "Вы также можете включить режим гарантированной точности groupby/aggregate с помощью опции [accurate_aggregation](../Searching/Options.md#accurate_aggregation).\n\n### max_query_time\n\nУстанавливает максимальное время выполнения поискового запроса в миллисекундах. Должно быть неотрицательным целым числом. Значение по умолчанию — 0, что означает «не ограничивать». Локальные поисковые запросы будут остановлены после истечения указанного времени. Обратите внимание, что если вы выполняете поиск, который обращается к нескольким локальным таблицам, это ограничение применяется к каждой таблице отдельно. Имейте в виду, что это может немного увеличить время отклика запроса из-за накладных расходов, связанных с постоянным отслеживанием времени остановки запроса.\n\n### max_predicted_time\n\nЦелое число. Максимальное предсказанное время поиска; см. [predicted_time_costs](../Server_settings/Searchd.md#predicted_time_costs).\n\n### morphology\n\n`none` позволяет заменять все термины запроса их точными формами, если таблица была построена с включённым [index_exact_words](../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words). Это полезно для предотвращения стемминга или лемматизации терминов запроса.\n\n### not_terms_only_allowed\n\n<!-- example not_terms_only_allowed -->\n\n`0` или `1` разрешает использование отдельного [отрицания](../Searching/Full_text_matching/Operators.md#Negation-operator) в запросе. Значение по умолчанию — 0. См. также соответствующую [глобальную настройку](../Server_settings/Searchd.md#not_terms_only_allowed).\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- end -->\n\n### ranker\n\nВыберите из следующих вариантов:\n\n* `proximity_bm25`\n\n* `bm25`\n\n* `none`\n\n* `wordcount`\n\n* `proximity`\n\n* `matchany`\n\n* `fieldmask`\n\n* `sph04`\n\n* `expr`\n\n* `export`\n\nДля получения подробной информации о каждом ранжировщике смотрите [Ранжирование результатов поиска](../Searching/Sorting_and_ranking.md#Available-built-in-rankers).\n\n### rand_seed\n\nПозволяет указать конкретное целочисленное значение зерна для запроса `ORDER BY RAND()`, например: `... OPTION rand_seed=1234`. По умолчанию для каждого запроса автоматически генерируется новое и уникальное значение зерна.\n\n### retry_count\n\nЦелое число. Количество повторных попыток в распределённом режиме.\n\n### retry_delay\n\nЦелое число. Задержка между повторными попытками в распределённом режиме, в миллисекундах.\n\n### scroll\n\nСтрока. Токен прокрутки для постраничного вывода результатов с использованием [подхода Scroll pagination](../Searching/Pagination.md#Scroll-Search-Option).\n\n### sort_method\n\n* `pq` — очередь с приоритетом, установлена по умолчанию\n\n* `kbuffer` — обеспечивает более быструю сортировку для уже предварительно отсортированных данных, например, данных таблицы, отсортированных по id\n\nНабор результатов одинаков в обоих случаях; выбор одного из вариантов может просто улучшить (или ухудшить) производительность.\n\n### threads\n\nОграничивает максимальное количество потоков, используемых для обработки текущего запроса. По умолчанию — без ограничений (запрос может использовать все [потоки](../Server_settings/Searchd.md#threads), определённые глобально).\n\nДля пакета запросов опция должна быть добавлена к самому первому запросу в пакете, после чего применяется при создании рабочей очереди и действует для всего пакета. Эта опция имеет то же значение, что и опция [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query), но применяется только к текущему запросу или пакету запросов.\n\n### token_filter\n\nЗаключённая в кавычки строка с разделением двоеточиями в формате `название библиотеки:название плагина:необязательная строка настроек`. Для каждого поиска при вызове полнотекстового поиска каждой задействованной таблицей создаётся фильтр токенов во время выполнения запроса, что позволяет реализовать пользовательский токенизатор, генерирующий токены согласно пользовательским правилам.\n\nCODE_BLOCK_10\n\n### expansion_limit\n\nОграничивает максимальное количество расширенных ключевых слов для одного подстановочного знака, значение по умолчанию 0 означает отсутствие ограничения. Для дополнительной информации смотрите [expansion_limit](../Server_settings/Searchd.md#expansion_limit).\n\n## Подсказки оптимизатора запросов\n\n<!-- example options_force -->\n\nВ редких случаях встроенный анализатор запросов Manticore может неправильно понять запрос и определить, следует ли использовать индекс docid, вторичные индексы или колонковое сканирование. Чтобы переопределить решения оптимизатора запросов, вы можете использовать следующие подсказки в вашем запросе:\n\n* `/*+ DocidIndex(id) */` — принудительно использовать индекс docid, `/*+ NO_DocidIndex(id) */` — указать оптимизатору игнорировать его\n\n* `/*+ SecondaryIndex(<attr_name1>[, <attr_nameN>]) */` — принудительно использовать вторичный индекс (если доступен), `/*+ NO_SecondaryIndex(id) */` — указать оптимизатору игнорировать его\n\n* `/*+ ColumnarScan(<attr_name1>[, <attr_nameN>]) */` — принудительно использовать колонковое сканирование (если атрибут колонковый), `/*+ NO_ColumnarScan(id) */` — указать оптимизатору игнорировать его\n\nОбратите внимание, что при выполнении полнотекстового запроса с фильтрами оптимизатор запросов выбирает между пересечением результатов полнотекстового дерева с результатами фильтра или использованием стандартного подхода match-then-filter. Указание *любой* подсказки заставит демон использовать путь кода, который выполняет пересечение результатов полнотекстового дерева с результатами фильтра.\n\nДля получения дополнительной информации о работе оптимизатора запросов смотрите страницу [Оптимизатор на основе стоимости](../Searching/Cost_based_optimizer.md).\n\n<!-- request SQL -->\n\nCODE_BLOCK_11\n\n<!-- end -->\n\n<!-- example comments -->\n\nПри использовании клиента MySQL/MariaDB убедитесь, что включён флаг `--comments` для активации подсказок в ваших запросах.\n\n<!-- request mysql -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "bf64263170a785801db2b3ac030896be9052420baa9935a1ecff157e66c045d7": {
    "original": "`0` or `1` (`0` by default). Expands keywords with exact forms and/or stars when possible. Refer to [expand_keywords](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expand_keywords) for more details.\n\n### field_weights\n\nNamed integer list (per-field user weights for ranking).\n\nExample:\n\nCODE_BLOCK_8\n\n### global_idf\n\nUse global statistics (frequencies) from the [global_idf](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#global_idf) file for IDF computations.\n\n### idf\n\nQuoted, comma-separated list of IDF computation flags. Known flags are:\n\n* `normalized`: BM25 variant, idf = log((N-n+1)/n), as per Robertson et al\n\n* `plain`: plain variant, idf = log(N/n), as per Sparck-Jones\n\n* `tfidf_normalized`: additionally divide IDF by query word count, so that `TF*IDF` fits into [0, 1] range\n\n* `tfidf_unnormalized`: do not additionally divide IDF by query word count where N is the collection size and n is the number of matched documents\n\nThe historically default IDF (Inverse Document Frequency) in Manticore is equivalent to `OPTION idf='normalized,tfidf_normalized'`, and those normalizations may cause several undesired effects.\n\nFirst, `idf=normalized` causes keyword penalization. For instance, if you search for `the | something` and `the` occurs in more than 50% of the documents, then documents with both keywords `the` and `something` will get less weight than documents with just one keyword `something`. Using `OPTION idf=plain` avoids this. Plain IDF varies in `[0, log(N)]` range, and keywords are never penalized; while the normalized IDF varies in `[-log(N), log(N)]` range, and too frequent keywords are penalized.\n\nSecond, `idf=tfidf_normalized` leads to IDF drift across queries. Historically, IDF was also divided by the query keyword count, ensuring the entire `sum(tf*idf)` across all keywords remained within the [0,1] range. However, this meant that queries like `word1` and `word1 | nonmatchingword2` would assign different weights to the exact same result set, as the IDFs for both `word1` and `nonmatchingword2` would be divided by 2. Using `OPTION idf='tfidf_unnormalized'` resolves this issue. Keep in mind that BM25, BM25A, BM25F() ranking factors will be adjusted accordingly when you disable this normalization.\n\nIDF flags can be combined; `plain` and `normalized` are mutually exclusive; `tfidf_unnormalized` and `tfidf_normalized` are also mutually exclusive; and unspecified flags in such mutually exclusive groups default to their original settings. This means `OPTION idf=plain` is the same as specifying `OPTION idf='plain,tfidf_normalized'` in its entirety.\n\n### jieba_mode\n\nSpecifies the Jieba segmentation mode for the query.\n\nWhen using Jieba Chinese segmentation, it can sometimes help to use different segmentation modes for tokenizing the documents and the query. For a complete list of modes, refer to [jieba_mode](../Creating_a_table/NLP_and_tokenization/Morphology.md#jieba_mode).\n\n### index_weights\n\nNamed integer list. Per-table user weights for ranking.\n\n### local_df\n\n`0` or `1`, automatically sum DFs over all local parts of a distributed table, ensuring consistent (and accurate) IDF across a locally sharded table. Enabled by default for disk chunks of the RT table. Query terms with wildcards are ignored.\n\n### low_priority\n\n`0` or `1` (`0` by default). Setting `low_priority=1` executes the query with a lower priority, rescheduling its jobs 10 times less frequently than other queries with normal priority.\n\n### max_matches\n\nInteger. Per-query max matches value.\n\nThe maximum number of matches that the server retains in RAM for each table and can return to the client. The default is 1000.\n\nIntroduced to control and limit RAM usage, the `max_matches` setting determines how many matches will be kept in RAM while searching each table. Every match found is still processed, but only the best N of them will be retained in memory and returned to the client in the end. For example, suppose a table contains 2,000,000 matches for a query. It's rare that you would need to retrieve all of them. Instead, you need to scan all of them but only choose the \"best\" 500, for instance, based on some criteria (e.g., sorted by relevance, price, or other factors) and display those 500 matches to the end user in pages of 20 to 100 matches. Tracking only the best 500 matches is much more RAM and CPU efficient than keeping all 2,000,000 matches, sorting them, and then discarding everything but the first 20 needed for the search results page. `max_matches` controls the N in that \"best N\" amount.\n\nThis parameter significantly impacts per-query RAM and CPU usage. Values of 1,000 to 10,000 are generally acceptable, but higher limits should be used with caution. Carelessly increasing max_matches to 1,000,000 means that `searchd` will have to allocate and initialize a 1-million-entry matches buffer for every query. This will inevitably increase per-query RAM usage and, in some cases, can noticeably affect performance.\n\nRefer to [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold) for additional information on how it can influence the behavior of the `max_matches` option.\n\n### max_matches_increase_threshold\n\nInteger. Sets the threshold that `max_matches` can be increased to. Default is 16384.\n\nManticore may increase `max_matches` to enhance groupby and/or aggregation accuracy when `pseudo_sharding` is enabled, and if it detects that the number of unique values of the groupby attribute is less than this threshold. Loss of accuracy may occur when pseudo-sharding executes the query in multiple threads or when an RT table conducts parallel searches in disk chunks.\n\nIf the number of unique values of the groupby attribute is less than the threshold, `max_matches` will be set to this number. Otherwise, the default `max_matches` will be used.\n\nIf `max_matches` was explicitly set in query options, this threshold has no effect.\n\nKeep in mind that if this threshold is set too high, it will result in increased memory consumption and general performance degradation.",
    "translations": {
      "chinese": "`0` 或 `1`（默认 `0`）。在可能的情况下，扩展关键词为精确形式和/或通配符。详情请参阅 [expand_keywords](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expand_keywords)。\n\n### field_weights\n\n命名的整数列表（每字段用户权重，用于排名）。\n\n示例：\n\nCODE_BLOCK_8\n\n### global_idf\n\n使用来自 [global_idf](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#global_idf) 文件的全局统计数据（频率）进行 IDF 计算。\n\n### idf\n\n带引号的、逗号分隔的 IDF 计算标志列表。已知标志有：\n\n* `normalized`：BM25 变体，idf = log((N-n+1)/n)，依据 Robertson 等人的定义\n\n* `plain`：普通变体，idf = log(N/n)，依据 Sparck-Jones 的定义\n\n* `tfidf_normalized`：额外将 IDF 除以查询词数，使得 `TF*IDF` 适合于 [0, 1] 范围内\n\n* `tfidf_unnormalized`：不额外将 IDF 除以查询词数，其中 N 是集合大小，n 是匹配文档数\n\nManticore 历史上的默认 IDF（逆文档频率）等同于 `OPTION idf='normalized,tfidf_normalized'`，这些归一化可能导致若干不期望的效果。\n\n首先，`idf=normalized` 会导致关键词惩罚。例如，如果你搜索 `the | something`，且 `the` 出现在超过 50% 的文档中，那么同时包含关键词 `the` 和 `something` 的文档权重会低于仅包含关键词 `something` 的文档。使用 `OPTION idf=plain` 可以避免这种情况。普通 IDF 变化范围为 `[0, log(N)]`，关键词不会被惩罚；而归一化 IDF 变化范围为 `[-log(N), log(N)]`，频繁出现的关键词会被惩罚。\n\n其次，`idf=tfidf_normalized` 会导致跨查询的 IDF 漂移。历史上，IDF 也被除以查询关键词数，确保所有关键词的 `sum(tf*idf)` 保持在 [0,1] 范围内。然而，这意味着像 `word1` 和 `word1 | nonmatchingword2` 这样的查询会对完全相同的结果集赋予不同权重，因为 `word1` 和 `nonmatchingword2` 的 IDF 都会被除以 2。使用 `OPTION idf='tfidf_unnormalized'` 可以解决此问题。请注意，当你禁用此归一化时，BM25、BM25A、BM25F() 排名因子将相应调整。\n\nIDF 标志可以组合使用；`plain` 和 `normalized` 互斥；`tfidf_unnormalized` 和 `tfidf_normalized` 也互斥；未指定的互斥组标志默认为其原始设置。这意味着 `OPTION idf=plain` 等同于完整指定 `OPTION idf='plain,tfidf_normalized'`。\n\n### jieba_mode\n\n指定查询的 Jieba 分词模式。\n\n使用 Jieba 中文分词时，有时对文档和查询使用不同的分词模式会有所帮助。完整模式列表请参阅 [jieba_mode](../Creating_a_table/NLP_and_tokenization/Morphology.md#jieba_mode)。\n\n### index_weights\n\n命名的整数列表。每表用户权重，用于排名。\n\n### local_df\n\n`0` 或 `1`，自动对分布式表的所有本地部分的 DF 求和，确保本地分片表中 IDF 的一致性（和准确性）。默认对 RT 表的磁盘分片启用。带通配符的查询词会被忽略。\n\n### low_priority\n\n`0` 或 `1`（默认 `0`）。设置 `low_priority=1` 会以较低优先级执行查询，其作业调度频率比正常优先级的查询低 10 倍。\n\n### max_matches\n\n整数。每查询最大匹配数值。\n\n服务器为每个表保留在 RAM 中并返回给客户端的最大匹配数。默认值为 1000。\n\n该设置用于控制和限制 RAM 使用，决定在搜索每个表时保留多少匹配。每个找到的匹配仍会被处理，但只保留最优的 N 个匹配在内存中，最终返回给客户端。例如，假设一个表中某查询有 2,000,000 个匹配。通常你不需要检索全部匹配，而是需要扫描所有匹配，但只选择“最佳”的 500 个（例如，基于相关性、价格或其他因素排序），并以每页 20 到 100 个匹配的形式展示给最终用户。仅跟踪最佳 500 个匹配比保留全部 2,000,000 个匹配、排序后再丢弃多余的匹配要高效得多。`max_matches` 控制这个“最佳 N”数量。\n\n该参数显著影响每查询的 RAM 和 CPU 使用。一般接受的值为 1,000 到 10,000，但更高的限制应谨慎使用。随意将 max_matches 增加到 1,000,000 意味着 `searchd` 必须为每个查询分配并初始化一个包含一百万条目的匹配缓冲区。这必然会增加每查询的 RAM 使用，有时会明显影响性能。\n\n更多关于 `max_matches` 行为影响的信息，请参阅 [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold)。\n\n### max_matches_increase_threshold\n\n整数。设置 `max_matches` 可增加的阈值。默认值为 16384。\n\n当启用 `pseudo_sharding` 并检测到 groupby 属性的唯一值数量少于此阈值时，Manticore 可能会增加 `max_matches` 以提高 groupby 和/或聚合的准确性。当伪分片在多个线程中执行查询，或 RT 表在磁盘分片中进行并行搜索时，可能会出现准确性损失。\n\n如果 groupby 属性的唯一值数量少于阈值，`max_matches` 将被设置为该数量。否则，使用默认的 `max_matches`。\n\n如果查询选项中显式设置了 `max_matches`，此阈值无效。\n\n请注意，如果该阈值设置过高，会导致内存消耗增加和整体性能下降。",
      "russian": "`0` или `1` (по умолчанию `0`). Расширяет ключевые слова точными формами и/или звёздочками, когда это возможно. Подробнее см. [expand_keywords](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expand_keywords).\n\n### field_weights\n\nИменованный список целых чисел (веса пользователя для ранжирования по полям).\n\nПример:\n\nCODE_BLOCK_8\n\n### global_idf\n\nИспользовать глобальную статистику (частоты) из файла [global_idf](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#global_idf) для вычисления IDF.\n\n### idf\n\nКавычками, через запятую перечисленные флаги вычисления IDF. Известные флаги:\n\n* `normalized`: вариант BM25, idf = log((N-n+1)/n), согласно Робертсону и др.\n\n* `plain`: простой вариант, idf = log(N/n), согласно Спарку-Джонсу\n\n* `tfidf_normalized`: дополнительно делить IDF на количество слов в запросе, чтобы `TF*IDF` попадал в диапазон [0, 1]\n\n* `tfidf_unnormalized`: не делить дополнительно IDF на количество слов в запросе, где N — размер коллекции, а n — количество совпадающих документов\n\nИсторически стандартный IDF (обратная частота документа) в Manticore эквивалентен `OPTION idf='normalized,tfidf_normalized'`, и эти нормализации могут вызывать несколько нежелательных эффектов.\n\nВо-первых, `idf=normalized` приводит к штрафованию ключевых слов. Например, если вы ищете `the | something` и `the` встречается более чем в 50% документов, то документы с обоими ключевыми словами `the` и `something` получат меньший вес, чем документы только с ключевым словом `something`. Использование `OPTION idf=plain` этого избегает. Простой IDF варьируется в диапазоне `[0, log(N)]`, и ключевые слова никогда не штрафуются; в то время как нормализованный IDF варьируется в диапазоне `[-log(N), log(N)]`, и слишком частые ключевые слова штрафуются.\n\nВо-вторых, `idf=tfidf_normalized` приводит к дрейфу IDF между запросами. Исторически IDF также делился на количество ключевых слов в запросе, что обеспечивало, что сумма `sum(tf*idf)` по всем ключевым словам оставалась в диапазоне [0,1]. Однако это означало, что запросы вроде `word1` и `word1 | nonmatchingword2` присваивали разные веса одному и тому же набору результатов, так как IDF для `word1` и `nonmatchingword2` делились на 2. Использование `OPTION idf='tfidf_unnormalized'` решает эту проблему. Учтите, что факторы ранжирования BM25, BM25A, BM25F() будут соответственно скорректированы при отключении этой нормализации.\n\nФлаги IDF могут комбинироваться; `plain` и `normalized` взаимоисключающие; `tfidf_unnormalized` и `tfidf_normalized` также взаимоисключающие; и неуказанные флаги в таких взаимоисключающих группах по умолчанию принимают свои исходные настройки. Это означает, что `OPTION idf=plain` эквивалентно полному указанию `OPTION idf='plain,tfidf_normalized'`.\n\n### jieba_mode\n\nЗадает режим сегментации Jieba для запроса.\n\nПри использовании китайской сегментации Jieba иногда полезно использовать разные режимы сегментации для токенизации документов и запроса. Полный список режимов см. в [jieba_mode](../Creating_a_table/NLP_and_tokenization/Morphology.md#jieba_mode).\n\n### index_weights\n\nИменованный список целых чисел. Веса пользователя для ранжирования по таблицам.\n\n### local_df\n\n`0` или `1`, автоматически суммирует DF по всем локальным частям распределённой таблицы, обеспечивая согласованный (и точный) IDF для локально шардированной таблицы. По умолчанию включено для дисковых чанков RT-таблицы. Термины запроса с подстановочными знаками игнорируются.\n\n### low_priority\n\n`0` или `1` (по умолчанию `0`). Установка `low_priority=1` выполняет запрос с пониженным приоритетом, перепланируя его задачи в 10 раз реже, чем запросы с нормальным приоритетом.\n\n### max_matches\n\nЦелое число. Максимальное количество совпадений на запрос.\n\nМаксимальное количество совпадений, которое сервер хранит в ОЗУ для каждой таблицы и может вернуть клиенту. По умолчанию 1000.\n\nВведено для контроля и ограничения использования ОЗУ, настройка `max_matches` определяет, сколько совпадений будет храниться в памяти при поиске по каждой таблице. Каждое найденное совпадение всё равно обрабатывается, но в памяти сохраняются только лучшие N из них, которые в итоге возвращаются клиенту. Например, если в таблице для запроса найдено 2 000 000 совпадений, редко нужно получить их все. Вместо этого нужно просканировать все, но выбрать только \"лучшие\" 500, например, по какому-то критерию (например, по релевантности, цене или другим факторам) и показать эти 500 совпадений пользователю постранично по 20-100 совпадений. Отслеживание только лучших 500 совпадений гораздо эффективнее по памяти и CPU, чем хранение всех 2 000 000, их сортировка и затем отбрасывание всего, кроме первых 20 для страницы результатов. `max_matches` контролирует N в этом количестве \"лучших N\".\n\nЭтот параметр существенно влияет на использование ОЗУ и CPU на запрос. Значения от 1000 до 10 000 обычно приемлемы, но более высокие лимиты следует использовать с осторожностью. Бездумное увеличение max_matches до 1 000 000 означает, что `searchd` должен выделить и инициализировать буфер для совпадений на миллион записей для каждого запроса. Это неизбежно увеличит использование ОЗУ на запрос и в некоторых случаях заметно повлияет на производительность.\n\nДополнительную информацию о влиянии на поведение опции `max_matches` см. в [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold).\n\n### max_matches_increase_threshold\n\nЦелое число. Устанавливает порог, до которого может быть увеличен `max_matches`. По умолчанию 16384.\n\nManticore может увеличить `max_matches` для повышения точности groupby и/или агрегаций при включённом `pseudo_sharding`, если обнаружит, что количество уникальных значений атрибута groupby меньше этого порога. Потеря точности может возникать, когда pseudo-sharding выполняет запрос в нескольких потоках или когда RT-таблица проводит параллельные поиски в дисковых чанках.\n\nЕсли количество уникальных значений атрибута groupby меньше порога, `max_matches` будет установлено в это число. В противном случае будет использоваться значение `max_matches` по умолчанию.\n\nЕсли `max_matches` было явно задано в опциях запроса, этот порог не действует.\n\nУчтите, что слишком высокий порог приведёт к увеличенному потреблению памяти и общему снижению производительности."
    },
    "is_code_or_comment": false
  },
  "3fb25cc58d485094438765c6b3ff5a195846b016269fd274b71502c2044ae8ba": {
    "original": "# Search options\n\nThe SQL [SELECT](../Searching/Full_text_matching/Basic_usage.md#SQL) clause and the HTTP [/search](../Searching/Full_text_matching/Basic_usage.md#HTTP-JSON) endpoint support a number of options that can be used to fine-tune search behavior.\n\n## OPTION\n\n### General syntax\n\n<!-- example options -->\n\n**SQL**:\n\nCODE_BLOCK_0\n\n**HTTP**:\n\nCODE_BLOCK_1\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_4\n\n<!-- response JSON -->\n\nCODE_BLOCK_5\n\n<!-- end -->\n\nSupported options are:\n\n### accurate_aggregation\n\nInteger. Enables or disables guaranteed aggregate accuracy when running groupby queries in multiple threads. Default is 0.\n\nWhen running a groupby query, it can be run in parallel on a plain table with several pseudo shards (if `pseudo_sharding` is on). A similar approach works on RT tables. Each shard/chunk executes the query, but the number of groups is limited by `max_matches`. If the result sets from different shards/chunks have different groups, the group counts and aggregates may be inaccurate. Note that Manticore tries to increase `max_matches` up to [`max_matches_increase_threshold`](../Searching/Options.md#max_matches_increase_threshold) based on the number of unique values of the groupby attribute (retrieved from secondary indexes). If it succeeds, there will be no loss in accuracy.\n\nHowever, if the number of unique values of the groupby attribute is high, further increasing `max_matches` may not be a good strategy because it can lead to a loss in performance and higher memory usage. Setting `accurate_aggregation` to 1 forces groupby searches to run in a single thread, which fixes the accuracy issue. Note that running in a single thread is only enforced when `max_matches` cannot be set high enough; otherwise, searches with `accurate_aggregation=1` will still run in multiple threads.\n\nOverall, setting `accurate_aggregation` to 1 ensures group count and aggregate accuracy in RT tables and plain tables with `pseudo_sharding=1`. The drawback is that searches will run slower since they will be forced to operate in a single thread.\n\nHowever, if we have an RT table and a plain table containing the same data, and we run a query with `accurate_aggregation=1`, we might still receive different results. This occurs because the daemon might choose different `max_matches` settings for the RT and plain table due to the [`max_matches_increase_threshold`](../Searching/Options.md#max_matches_increase_threshold) setting.\n\n### agent_query_timeout\n\nInteger. Max time in milliseconds to wait for remote queries to complete, see [this section](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_query_timeout).\n\n### boolean_simplify\n\n`0` or `1` (`1` by default). `boolean_simplify=1` enables [simplifying the query](../Searching/Full_text_matching/Boolean_optimization.md) to speed it up.\n\nThis option can also be set globally in the [searchd configuration](../Server_settings/Searchd.md#boolean_simplify) to change the default behavior for all queries. The per-query option will override the global setting.\n\n### comment\n\nString, user comment that gets copied to a query log file.\n\n### cutoff\n\nInteger. Specifies the maximum number of matches to process. If not set, Manticore will select an appropriate value automatically.\n\n<!-- example cutoff_aggregation -->\n\n* `N = 0`: Disables the limit on the number of matches.\n\n* `N > 0`: Instructs Manticore to stop processing results as soon as it finds `N` matching documents.\n\n* Not set: Manticore decides the threshold automatically.\n\nWhen Manticore cannot determine the exact count of matching documents, the `total_relation` field in the query [meta information](../Node_info_and_management/SHOW_META.md#SHOW-META) will show `gte`, which stands for **Greater Than or Equal to**. This indicates that the actual count of matches is at least the reported `total_found` (in SQL) or `hits.total` (in JSON). When the count is exact, `total_relation` will display `eq`.\n\nNote: Using `cutoff` in aggregation queries is not recommended because it can produce inaccurate or incomplete results.\n\n<!-- request Example -->\n\nUsing `cutoff` in aggregation queries can lead to incorrect or misleading results, as shown in the following example:\n\nCODE_BLOCK_6\n\nCompare it with the same query without `cutoff`:\n\nCODE_BLOCK_7\n\n<!-- end -->\n\n### distinct_precision_threshold\n\nInteger. Default is `3500`. This option sets the threshold below which counts returned by `count distinct` are guaranteed to be exact within a plain table.\n\nAccepted values range from `500` to `15500`. Values outside this range will be clamped.\n\nWhen this option is set to 0, it enables an algorithm that ensures exact counts. This algorithm collects `{group, value}` pairs, sorts them, and periodically eliminates duplicates. The result is precise counts within a plain table. However, this approach is not suitable for high-cardinality datasets due to its high memory consumption and slow query execution.\n\nWhen `distinct_precision_threshold` is set to a value greater than `0`, Manticore employs a different algorithm. It loads counts into a hash table and returns the size of the table. If the hash table becomes too large, its contents are moved into a `HyperLogLog` data structure. At this point, the counts become approximate because HyperLogLog is a probabilistic algorithm. This approach maintains a fixed maximum memory usage per group, but there is a tradeoff in count accuracy.\n\nThe accuracy of the `HyperLogLog` and the threshold for converting from the hash table to HyperLogLog are derived from the `distinct_precision_threshold` setting. It's important to use this option with caution since doubling its value will also double the maximum memory required to calculate counts. The maximum memory usage can be roughly estimated using this formula: `64 * max_matches * distinct_precision_threshold`, although in practice, count calculations often use less memory than the worst-case scenario.\n\n### expand_keywords",
    "translations": {
      "chinese": "# 搜索选项\n\nSQL 的 [SELECT](../Searching/Full_text_matching/Basic_usage.md#SQL) 子句和 HTTP 的 [/search](../Searching/Full_text_matching/Basic_usage.md#HTTP-JSON) 端点支持多种选项，可用于微调搜索行为。\n\n## OPTION\n\n### 通用语法\n\n<!-- example options -->\n\n**SQL**:\n\nCODE_BLOCK_0\n\n**HTTP**:\n\nCODE_BLOCK_1\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_4\n\n<!-- response JSON -->\n\nCODE_BLOCK_5\n\n<!-- end -->\n\n支持的选项有：\n\n### accurate_aggregation\n\n整数。启用或禁用在多线程运行 groupby 查询时保证聚合准确性。默认值为 0。\n\n运行 groupby 查询时，可以在带有多个伪分片的普通表上并行运行（如果启用了 `pseudo_sharding`）。类似的方法也适用于 RT 表。每个分片/块执行查询，但分组数量受 `max_matches` 限制。如果来自不同分片/块的结果集包含不同的分组，分组计数和聚合可能不准确。注意，Manticore 会尝试根据 groupby 属性的唯一值数量（从二级索引获取）将 `max_matches` 增加到 [`max_matches_increase_threshold`](../Searching/Options.md#max_matches_increase_threshold)。如果成功，则不会有准确性损失。\n\n然而，如果 groupby 属性的唯一值数量很高，进一步增加 `max_matches` 可能不是好策略，因为这会导致性能下降和内存使用增加。将 `accurate_aggregation` 设置为 1 会强制 groupby 搜索在单线程中运行，从而解决准确性问题。注意，只有当 `max_matches` 无法设置得足够高时，才会强制单线程运行；否则，设置了 `accurate_aggregation=1` 的搜索仍会在多线程中运行。\n\n总体来说，将 `accurate_aggregation` 设置为 1 可确保 RT 表和带有 `pseudo_sharding=1` 的普通表中的分组计数和聚合准确性。缺点是搜索速度会变慢，因为它们被强制在单线程中运行。\n\n但是，如果我们有一个 RT 表和一个包含相同数据的普通表，并且运行带有 `accurate_aggregation=1` 的查询，仍可能得到不同的结果。这是因为守护进程可能会基于 [`max_matches_increase_threshold`](../Searching/Options.md#max_matches_increase_threshold) 设置为 RT 表和普通表选择不同的 `max_matches` 设置。\n\n### agent_query_timeout\n\n整数。等待远程查询完成的最大时间（毫秒），详见[此部分](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_query_timeout)。\n\n### boolean_simplify\n\n`0` 或 `1`（默认值为 `1`）。`boolean_simplify=1` 启用[简化查询](../Searching/Full_text_matching/Boolean_optimization.md)以加快速度。\n\n此选项也可以在 [searchd 配置](../Server_settings/Searchd.md#boolean_simplify)中全局设置，以更改所有查询的默认行为。每个查询的选项会覆盖全局设置。\n\n### comment\n\n字符串，用户注释，会被复制到查询日志文件中。\n\n### cutoff\n\n整数。指定要处理的最大匹配数。如果未设置，Manticore 会自动选择合适的值。\n\n<!-- example cutoff_aggregation -->\n\n* `N = 0`：禁用匹配数限制。\n\n* `N > 0`：指示 Manticore 在找到 `N` 个匹配文档后停止处理结果。\n\n* 未设置：Manticore 自动决定阈值。\n\n当 Manticore 无法确定匹配文档的确切数量时，查询的[元信息](../Node_info_and_management/SHOW_META.md#SHOW-META)中的 `total_relation` 字段将显示 `gte`，表示**大于或等于**。这意味着实际匹配数至少是报告的 `total_found`（SQL）或 `hits.total`（JSON）。当计数准确时，`total_relation` 显示为 `eq`。\n\n注意：不建议在聚合查询中使用 `cutoff`，因为它可能产生不准确或不完整的结果。\n\n<!-- request Example -->\n\n在聚合查询中使用 `cutoff` 可能导致错误或误导性的结果，如下例所示：\n\nCODE_BLOCK_6\n\n与不使用 `cutoff` 的相同查询对比：\n\nCODE_BLOCK_7\n\n<!-- end -->\n\n### distinct_precision_threshold\n\n整数。默认值为 `3500`。此选项设置在普通表中 `count distinct` 返回的计数保证准确的阈值。\n\n接受的值范围为 `500` 到 `15500`。超出此范围的值将被限制。\n\n当此选项设置为 0 时，启用一种确保精确计数的算法。该算法收集 `{group, value}` 对，排序并定期消除重复项。结果是在普通表中获得精确计数。然而，由于其高内存消耗和查询执行缓慢，该方法不适合高基数数据集。\n\n当 `distinct_precision_threshold` 设置为大于 0 的值时，Manticore 使用另一种算法。它将计数加载到哈希表中并返回表的大小。如果哈希表过大，其内容会被转移到 `HyperLogLog` 数据结构中。此时计数变为近似，因为 HyperLogLog 是一种概率算法。该方法保持每个分组的最大内存使用固定，但计数准确性有所折衷。\n\n`HyperLogLog` 的准确性和从哈希表转换到 HyperLogLog 的阈值由 `distinct_precision_threshold` 设置决定。使用此选项时需谨慎，因为其值加倍会使计算计数所需的最大内存也加倍。最大内存使用量可大致估算为：`64 * max_matches * distinct_precision_threshold`，尽管实际计数计算通常使用的内存少于最坏情况。\n\n### expand_keywords",
      "russian": "# Параметры поиска\n\nSQL [SELECT](../Searching/Full_text_matching/Basic_usage.md#SQL) оператор и HTTP [/search](../Searching/Full_text_matching/Basic_usage.md#HTTP-JSON) эндпоинт поддерживают ряд опций, которые можно использовать для тонкой настройки поведения поиска.\n\n## OPTION\n\n### Общий синтаксис\n\n<!-- example options -->\n\n**SQL**:\n\nCODE_BLOCK_0\n\n**HTTP**:\n\nCODE_BLOCK_1\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- response SQL -->\n\nCODE_BLOCK_3\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_4\n\n<!-- response JSON -->\n\nCODE_BLOCK_5\n\n<!-- end -->\n\nПоддерживаемые опции:\n\n### accurate_aggregation\n\nЦелое число. Включает или отключает гарантированную точность агрегатов при выполнении запросов groupby в нескольких потоках. По умолчанию 0.\n\nПри выполнении запроса groupby он может выполняться параллельно на простой таблице с несколькими псевдо-шардами (если включен `pseudo_sharding`). Аналогичный подход работает с RT таблицами. Каждый шард/чанк выполняет запрос, но количество групп ограничено `max_matches`. Если наборы результатов из разных шардов/чанков содержат разные группы, подсчёты групп и агрегаты могут быть неточными. Обратите внимание, что Manticore пытается увеличить `max_matches` до [`max_matches_increase_threshold`](../Searching/Options.md#max_matches_increase_threshold) на основе количества уникальных значений атрибута groupby (получаемых из вторичных индексов). Если это удаётся, потери точности не будет.\n\nОднако, если количество уникальных значений атрибута groupby велико, дальнейшее увеличение `max_matches` может быть не лучшей стратегией, так как это может привести к снижению производительности и увеличению использования памяти. Установка `accurate_aggregation` в 1 заставляет groupby-запросы выполняться в одном потоке, что решает проблему точности. Обратите внимание, что выполнение в одном потоке принудительно только тогда, когда `max_matches` нельзя установить достаточно высоким; в противном случае запросы с `accurate_aggregation=1` всё равно будут выполняться в нескольких потоках.\n\nВ целом, установка `accurate_aggregation` в 1 обеспечивает точность подсчёта групп и агрегатов в RT таблицах и простых таблицах с `pseudo_sharding=1`. Недостаток в том, что запросы будут выполняться медленнее, так как будут вынуждены работать в одном потоке.\n\nОднако, если у нас есть RT таблица и простая таблица с одинаковыми данными, и мы выполняем запрос с `accurate_aggregation=1`, мы всё равно можем получить разные результаты. Это происходит потому, что демон может выбрать разные настройки `max_matches` для RT и простой таблицы из-за настройки [`max_matches_increase_threshold`](../Searching/Options.md#max_matches_increase_threshold).\n\n### agent_query_timeout\n\nЦелое число. Максимальное время в миллисекундах ожидания завершения удалённых запросов, см. [этот раздел](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_query_timeout).\n\n### boolean_simplify\n\n`0` или `1` (по умолчанию `1`). `boolean_simplify=1` включает [упрощение запроса](../Searching/Full_text_matching/Boolean_optimization.md) для ускорения его выполнения.\n\nЭту опцию также можно установить глобально в [конфигурации searchd](../Server_settings/Searchd.md#boolean_simplify), чтобы изменить поведение по умолчанию для всех запросов. Опция на уровне запроса переопределит глобальную настройку.\n\n### comment\n\nСтрока, пользовательский комментарий, который копируется в файл журнала запросов.\n\n### cutoff\n\nЦелое число. Указывает максимальное количество обрабатываемых совпадений. Если не задано, Manticore автоматически выберет подходящее значение.\n\n<!-- example cutoff_aggregation -->\n\n* `N = 0`: Отключает ограничение на количество совпадений.\n\n* `N > 0`: Инструктирует Manticore прекратить обработку результатов, как только будет найдено `N` совпадающих документов.\n\n* Не задано: Manticore самостоятельно определяет порог.\n\nКогда Manticore не может определить точное количество совпадающих документов, поле `total_relation` в [метаинформации](../Node_info_and_management/SHOW_META.md#SHOW-META) запроса покажет `gte`, что означает **Больше или равно**. Это указывает, что фактическое количество совпадений как минимум равно указанному `total_found` (в SQL) или `hits.total` (в JSON). Когда количество точное, `total_relation` будет показывать `eq`.\n\nПримечание: использование `cutoff` в агрегатных запросах не рекомендуется, так как это может привести к неточным или неполным результатам.\n\n<!-- request Example -->\n\nИспользование `cutoff` в агрегатных запросах может привести к неправильным или вводящим в заблуждение результатам, как показано в следующем примере:\n\nCODE_BLOCK_6\n\nСравните с тем же запросом без `cutoff`:\n\nCODE_BLOCK_7\n\n<!-- end -->\n\n### distinct_precision_threshold\n\nЦелое число. По умолчанию `3500`. Эта опция задаёт порог, ниже которого подсчёты, возвращаемые `count distinct`, гарантированно точны в пределах простой таблицы.\n\nДопустимые значения варьируются от `500` до `15500`. Значения вне этого диапазона будут ограничены.\n\nЕсли эта опция установлена в 0, включается алгоритм, обеспечивающий точные подсчёты. Этот алгоритм собирает пары `{group, value}`, сортирует их и периодически устраняет дубликаты. Результат — точные подсчёты в пределах простой таблицы. Однако этот подход не подходит для наборов данных с высокой кардинальностью из-за высокого потребления памяти и медленного выполнения запросов.\n\nЕсли `distinct_precision_threshold` установлен в значение больше 0, Manticore использует другой алгоритм. Он загружает подсчёты в хеш-таблицу и возвращает размер таблицы. Если хеш-таблица становится слишком большой, её содержимое переносится в структуру данных `HyperLogLog`. В этот момент подсчёты становятся приближенными, так как HyperLogLog — вероятностный алгоритм. Этот подход поддерживает фиксированное максимальное использование памяти на группу, но с компромиссом в точности подсчётов.\n\nТочность `HyperLogLog` и порог для перехода от хеш-таблицы к HyperLogLog выводятся из настройки `distinct_precision_threshold`. Важно использовать эту опцию с осторожностью, так как удвоение её значения также удвоит максимальное количество памяти, необходимое для подсчётов. Максимальное использование памяти можно примерно оценить по формуле: `64 * max_matches * distinct_precision_threshold`, хотя на практике подсчёты часто используют меньше памяти, чем в худшем случае.\n\n### expand_keywords"
    },
    "is_code_or_comment": false
  },
  "a8c5e962e88e64ca89c29ea97bb26e5e91b30bf0169cc18bf991c9baa821d269": {
    "original": "You can also enforce a guaranteed groupby/aggregate accuracy mode using the [accurate_aggregation](../Searching/Options.md#accurate_aggregation) option.\n\n### max_query_time\n\nSets the maximum search query time in milliseconds. Must be a non-negative integer. The default value is 0, which means \"do not limit.\" Local search queries will be stopped once the specified time has elapsed. Note that if you're performing a search that queries multiple local tables, this limit applies to each table separately. Be aware that this may slightly increase the query's response time due to the overhead caused by constantly tracking whether it's time to stop the query.\n\n### max_predicted_time\n\nInteger. Maximum predicted search time; see [predicted_time_costs](../Server_settings/Searchd.md#predicted_time_costs).\n\n### morphology\n\n`none` allows replacing all query terms with their exact forms if the table was built with [index_exact_words](../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words) enabled. This is useful for preventing stemming or lemmatizing query terms.\n\n### not_terms_only_allowed\n\n<!--\n\ndata for the following example:\n\nDROP TABLE IF EXISTS t;\n\nCREATE TABLE t(f1 text, f2 int);\n\nINSERT INTO t(f1, f2) VALUES\n\n('b', 2),\n\n('c', 3),\n\n('b', 2);\n\n-->\n\n<!-- example not_terms_only_allowed -->\n\n`0` or `1` allows standalone [negation](../Searching/Full_text_matching/Operators.md#Negation-operator) for the query. The default is 0. See also the corresponding [global setting](../Server_settings/Searchd.md#not_terms_only_allowed).\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- request JSON -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n### ranker\n\nChoose from the following options:\n\n* `proximity_bm25`\n\n* `bm25`\n\n* `none`\n\n* `wordcount`\n\n* `proximity`\n\n* `matchany`\n\n* `fieldmask`\n\n* `sph04`\n\n* `expr`\n\n* `export`\n\nFor more details on each ranker, refer to [Search results ranking](../Searching/Sorting_and_ranking.md#Available-built-in-rankers).\n\n### rand_seed\n\nAllows you to specify a specific integer seed value for an `ORDER BY RAND()` query, for example: `... OPTION rand_seed=1234`. By default, a new and different seed value is autogenerated for every query.\n\n### retry_count\n\nInteger. Distributed retries count.\n\n### retry_delay\n\nInteger. Distributed retry delay, in milliseconds.\n\n### scroll\n\nString. A scroll token for paginating results using the [Scroll pagination approach](../Searching/Pagination.md#Scroll-Search-Option).\n\n### sort_method\n\n* `pq` - priority queue, set by default\n\n* `kbuffer` - provides faster sorting for already pre-sorted data, e.g., table data sorted by id\n\nThe result set is the same in both cases; choosing one option or the other may simply improve (or worsen) performance.\n\n### threads\n\nLimits the max number of threads used for current query processing. Default - no limit (the query can occupy all [threads](../Server_settings/Searchd.md#threads) as defined globally).\n\nFor a batch of queries, the option must be attached to the very first query in the batch, and it is then applied when the working queue is created and is effective for the entire batch. This option has the same meaning as the option [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query), but is applied only to the current query or batch of queries.\n\n### token_filter\n\nQuoted, colon-separated string of `library name:plugin name:optional string of settings`. A query-time token filter is created for each search when full-text is invoked by every table involved, allowing you to implement a custom tokenizer that generates tokens according to custom rules.\n\nCODE_BLOCK_11\n\n### expansion_limit\n\nRestricts the maximum number of expanded keywords for a single wildcard, with a default value of 0 indicating no limit. For additional details, refer to [expansion_limit](../Server_settings/Searchd.md#expansion_limit).\n\n## Query optimizer hints\n\n<!-- example options_force -->\n\nIn rare cases, Manticore's built-in query analyzer may be incorrect in understanding a query and determining whether a docid index, secondary indexes, or columnar scan should be used. To override the query optimizer's decisions, you can use the following hints in your query:\n\n* `/*+ DocidIndex(id) */`  to force the use of a docid index, `/*+ NO_DocidIndex(id) */` to tell the optimizer to ignore it\n\n* `/*+ SecondaryIndex(<attr_name1>[, <attr_nameN>]) */` to force the use of a secondary index (if available), `/*+ NO_SecondaryIndex(id) */`  to tell the optimizer to ignore it\n\n* `/*+ ColumnarScan(<attr_name1>[, <attr_nameN>]) */`  to force the use of a columnar scan (if the attribute is columnar), `/*+ NO_ColumnarScan(id) */` to tell the optimizer to ignore it\n\nNote that when executing a full-text query with filters, the query optimizer decides between intersecting the results of the full-text tree with the filter results or using a standard match-then-filter approach. Specifying *any* hint will force the daemon to use the code path that performs the intersection of the full-text tree results with the filter results.\n\nFor more information on how the query optimizer works, refer to the [Cost based optimizer](../Searching/Cost_based_optimizer.md) page.\n\n<!-- request SQL -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n<!-- example comments -->\n\nWhen using a MySQL/MariaDB client, make sure to include the `--comments` flag to enable the hints in your queries.\n\n<!-- request mysql -->\n\nCODE_BLOCK_13\n\n<!-- request JSON -->\n\nCODE_BLOCK_14\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "您还可以使用 [accurate_aggregation](../Searching/Options.md#accurate_aggregation) 选项强制启用保证的 groupby/aggregate 精度模式。\n\n### max_query_time\n\n设置最大搜索查询时间（毫秒）。必须是非负整数。默认值为 0，表示“不限制”。本地搜索查询将在达到指定时间后停止。请注意，如果您执行的搜索查询多个本地表，此限制将分别适用于每个表。需要注意的是，由于持续跟踪是否达到停止查询时间的开销，这可能会略微增加查询响应时间。\n\n### max_predicted_time\n\n整数。最大预测搜索时间；详见 [predicted_time_costs](../Server_settings/Searchd.md#predicted_time_costs)。\n\n### morphology\n\n`none` 允许将所有查询词都替换为其精确形式（如果表是在启用了 [index_exact_words](../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words) 的情况下构建的）。这对于防止查询词进行词干提取或词形还原非常有用。\n\n### not_terms_only_allowed\n\n<!--\n\ndata for the following example:\n\nDROP TABLE IF EXISTS t;\n\nCREATE TABLE t(f1 text, f2 int);\n\nINSERT INTO t(f1, f2) VALUES\n\n('b', 2),\n\n('c', 3),\n\n('b', 2);\n\n-->\n\n<!-- example not_terms_only_allowed -->\n\n`0` 或 `1` 允许查询中使用独立的[否定](../Searching/Full_text_matching/Operators.md#Negation-operator)操作符。默认值为 0。另见对应的 [全局设置](../Server_settings/Searchd.md#not_terms_only_allowed)。\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- request JSON -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n### ranker\n\n可从以下选项中选择：\n\n* `proximity_bm25`\n\n* `bm25`\n\n* `none`\n\n* `wordcount`\n\n* `proximity`\n\n* `matchany`\n\n* `fieldmask`\n\n* `sph04`\n\n* `expr`\n\n* `export`\n\n有关各排序器的更多详情，请参阅 [搜索结果排序](../Searching/Sorting_and_ranking.md#Available-built-in-rankers)。\n\n### rand_seed\n\n允许您为 `ORDER BY RAND()` 查询指定一个特定的整数种子值，例如：`... OPTION rand_seed=1234`。默认情况下，每个查询都会自动生成一个新的不同种子值。\n\n### retry_count\n\n整数。分布式重试次数。\n\n### retry_delay\n\n整数。分布式重试延迟，单位为毫秒。\n\n### scroll\n\n字符串。用于使用[滚动分页方法](../Searching/Pagination.md#Scroll-Search-Option)进行结果分页的滚动令牌。\n\n### sort_method\n\n* `pq` - 优先队列，默认设置\n\n* `kbuffer` - 对已预排序数据提供更快的排序，例如按 id 排序的表数据\n\n两者的结果集相同；选择不同选项仅可能提升（或降低）性能。\n\n### threads\n\n限制当前查询处理所使用的最大线程数。默认值为无上限（查询可以占用全局定义的所有[线程](../Server_settings/Searchd.md#threads)）。\n\n对于一批查询，该选项必须附加在该批第一个查询上，然后在创建工作队列时应用，并对整个批次生效。此选项与 [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query) 具有相同含义，但仅应用于当前查询或查询批次。\n\n### token_filter\n\n引号括起的、用冒号分隔的字符串，格式为 `library name:plugin name:optional string of settings`。每当涉及的每个表调用全文搜索时，都会为查询时创建一个令牌过滤器，允许您实现按自定义规则生成令牌的自定义分词器。\n\nCODE_BLOCK_11\n\n### expansion_limit\n\n限制单个通配符展开的关键字最大数量，默认值为 0 表示不限制。更多细节请参见 [expansion_limit](../Server_settings/Searchd.md#expansion_limit)。\n\n## 查询优化器提示\n\n<!-- example options_force -->\n\n在极少数情况下，Manticore 内置的查询分析器可能误判查询，无法正确决定是否应使用 docid 索引、二级索引或列扫描。为了覆盖查询优化器的决策，您可以在查询中使用以下提示：\n\n* `/*+ DocidIndex(id) */` 强制使用 docid 索引，`/*+ NO_DocidIndex(id) */` 告诉优化器忽略它\n\n* `/*+ SecondaryIndex(<attr_name1>[, <attr_nameN>]) */` 强制使用二级索引（如果存在），`/*+ NO_SecondaryIndex(id) */` 告诉优化器忽略它\n\n* `/*+ ColumnarScan(<attr_name1>[, <attr_nameN>]) */` 强制使用列扫描（如果属性为列式），`/*+ NO_ColumnarScan(id) */` 告诉优化器忽略它\n\n请注意，在执行带过滤器的全文查询时，查询优化器会决定是取全文树结果与过滤器结果的交集，还是使用标准的先匹配后过滤方法。指定*任何*提示都会强制守护进程使用执行全文树结果与过滤器结果交集的代码路径。\n\n有关查询优化器工作原理的更多信息，请参考 [基于成本的优化器](../Searching/Cost_based_optimizer.md) 页面。\n\n<!-- request SQL -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n<!-- example comments -->\n\n使用 MySQL/MariaDB 客户端时，请确保带上 `--comments` 标志以启用查询中的提示。\n\n<!-- request mysql -->\n\nCODE_BLOCK_13\n\n<!-- request JSON -->\n\nCODE_BLOCK_14\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "Вы также можете включить режим гарантированной точности groupby/aggregate с помощью опции [accurate_aggregation](../Searching/Options.md#accurate_aggregation).\n\n### max_query_time\n\nУстанавливает максимальное время выполнения поискового запроса в миллисекундах. Значение должно быть неотрицательным целым числом. Значение по умолчанию 0 означает «не ограничивать». Локальные поисковые запросы будут остановлены по истечении указанного времени. Обратите внимание, что если вы выполняете поиск, который опрашивает несколько локальных таблиц, это ограничение применяется к каждой таблице отдельно. Учтите, что это может немного увеличить время отклика запроса из-за накладных расходов, связанных с постоянным отслеживанием момента, когда нужно остановить запрос.\n\n### max_predicted_time\n\nЦелое число. Максимальное предсказанное время поиска; см. [predicted_time_costs](../Server_settings/Searchd.md#predicted_time_costs).\n\n### morphology\n\n`none` позволяет заменять все термины запроса на их точные формы, если таблица была построена с включённой опцией [index_exact_words](../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words). Это полезно для предотвращения стемминга или лемматизации терминов запроса.\n\n### not_terms_only_allowed\n\n<!--\n\ndata for the following example:\n\nDROP TABLE IF EXISTS t;\n\nCREATE TABLE t(f1 text, f2 int);\n\nINSERT INTO t(f1, f2) VALUES\n\n('b', 2),\n\n('c', 3),\n\n('b', 2);\n\n-->\n\n<!-- example not_terms_only_allowed -->\n\n`0` или `1` разрешают отдельное использование [негации](../Searching/Full_text_matching/Operators.md#Negation-operator) в запросе. Значение по умолчанию — 0. См. также соответствующую [глобальную настройку](../Server_settings/Searchd.md#not_terms_only_allowed).\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- request JSON -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n### ranker\n\nВыберите один из следующих вариантов:\n\n* `proximity_bm25`\n\n* `bm25`\n\n* `none`\n\n* `wordcount`\n\n* `proximity`\n\n* `matchany`\n\n* `fieldmask`\n\n* `sph04`\n\n* `expr`\n\n* `export`\n\nДля получения дополнительной информации о каждом ранжировщике смотрите [Ранжирование результатов поиска](../Searching/Sorting_and_ranking.md#Available-built-in-rankers).\n\n### rand_seed\n\nПозволяет указать конкретное целочисленное значение seed для запроса `ORDER BY RAND()`, например: `... OPTION rand_seed=1234`. По умолчанию для каждого запроса автоматически генерируется новое и уникальное значение seed.\n\n### retry_count\n\nЦелое число. Количество повторных попыток для распределенного запроса.\n\n### retry_delay\n\nЦелое число. Задержка между повторными попытками для распределенного запроса в миллисекундах.\n\n### scroll\n\nСтрока. Токен прокрутки для постраничного получения результатов с использованием [Scroll pagination approach](../Searching/Pagination.md#Scroll-Search-Option).\n\n### sort_method\n\n* `pq` — приоритетная очередь, установлена по умолчанию\n\n* `kbuffer` — обеспечивает более быструю сортировку для уже предварительно отсортированных данных, например, для данных таблицы, отсортированной по id\n\nНабор результатов одинаков в обоих случаях; выбор того или иного варианта может просто улучшить (или ухудшить) производительность.\n\n### threads\n\nОграничивает максимальное количество потоков, используемых при обработке текущего запроса. По умолчанию — без ограничений (запрос может использовать все [потоки](../Server_settings/Searchd.md#threads), определённые глобально).\n\nДля пакета запросов опция должна быть применена к самому первому запросу в пакете, после чего будет применена при создании рабочей очереди и эффективно работать для всего пакета. Эта опция имеет то же значение, что и опция [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query), но применяется только к текущему запросу или пакету запросов.\n\n### token_filter\n\nКотированная строка, разделённая двоеточиями, в формате `имя библиотеки:имя плагина:необязательная строка настроек`. Для каждого поиска при вызове полнотекстового поиска каждой задействованной таблицей создаётся токен-фильтр времени запроса, позволяя реализовать пользовательский токенизатор, который генерирует токены согласно индивидуальным правилам.\n\nCODE_BLOCK_11\n\n### expansion_limit\n\nОграничивает максимальное количество расширенных ключевых слов для одного wildcard, по умолчанию 0, что означает отсутствие ограничений. Подробнее см. [expansion_limit](../Server_settings/Searchd.md#expansion_limit).\n\n## Подсказки оптимизатора запросов\n\n<!-- example options_force -->\n\nВ редких случаях встроенный анализатор запросов Manticore может неправильно интерпретировать запрос и решить, использовать ли индекс docid, вторичные индексы или колонковое сканирование. Чтобы переопределить решения оптимизатора запросов, вы можете использовать следующие подсказки в вашем запросе:\n\n* `/*+ DocidIndex(id) */` чтобы принудительно использовать индекс docid, `/*+ NO_DocidIndex(id) */` чтобы игнорировать его оптимизатором\n\n* `/*+ SecondaryIndex(<attr_name1>[, <attr_nameN>]) */` чтобы принудительно использовать вторичный индекс (если есть), `/*+ NO_SecondaryIndex(id) */` чтобы игнорировать его оптимизатором\n\n* `/*+ ColumnarScan(<attr_name1>[, <attr_nameN>]) */` чтобы принудительно использовать колонковое сканирование (если атрибут колонковый), `/*+ NO_ColumnarScan(id) */` чтобы игнорировать его оптимизатором\n\nОбратите внимание, что при выполнении полнотекстового запроса с фильтрами оптимизатор запросов выбирает между пересечением результатов полнотекстового дерева с результатами фильтра или использованием стандартного подхода match-then-filter. Указание *любой* подсказки заставит демон использовать путь кода, который выполняет пересечение результатов полнотекстового дерева с результатами фильтра.\n\nДля получения дополнительной информации о работе оптимизатора запросов смотрите страницу [Оптимизатор на основе стоимости (Cost based optimizer)](../Searching/Cost_based_optimizer.md).\n\n<!-- request SQL -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n<!-- example comments -->\n\nПри использовании клиента MySQL/MariaDB убедитесь, что включена опция `--comments` для поддержки подсказок в ваших запросах.\n\n<!-- request mysql -->\n\nCODE_BLOCK_13\n\n<!-- request JSON -->\n\nCODE_BLOCK_14\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
