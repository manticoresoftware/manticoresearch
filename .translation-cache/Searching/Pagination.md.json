{
  "04d66db3951e23663453bce2b97b90c41bfb81e726e9aae161ed1450051c096d": {
    "original": "# Pagination of search results\n\n<!-- example general -->\n\nManticore Search returns the top 20 matched documents in the result set by default.\n\n#### SQL\n\nIn SQL, you can navigate through the result set using the `LIMIT` clause.\n\n`LIMIT` can accept either one number as the size of the returned set with a zero offset, or a pair of offset and size values.\n\n#### HTTP JSON\n\nWhen using HTTP JSON, the nodes `offset` and `limit` control the offset of the result set and the size of the returned set. Alternatively, you can use the pair `size` and `from` instead.\n\n<!-- intro -->\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n<!-- example maxMatches -->\n\n### Result set window\n\nBy default, Manticore Search uses a result set window of 1000 best-ranked documents that can be returned in the result set. If the result set is paginated beyond this value, the query will end in error.\n\nThis limitation can be adjusted with the query option [max_matches](../Searching/Options.md#max_matches).\n\nIncreasing the `max_matches` to very high values should only be done if it's necessary for the navigation to reach such points. A high `max_matches` value requires more memory and can increase the query response time. One way to work with deep result sets is to set `max_matches` as the sum of the offset and limit.\n\nLowering `max_matches` below 1000 has the benefit of reducing the memory used by the query. It can also reduce the query time, but in most cases, it might not be a noticeable gain.\n\n<!-- intro -->\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- request JSON -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n## Scroll Search Option\n\nThe scroll search option provides an efficient and reliable way to paginate through large result sets. Unlike traditional offset-based pagination, scroll search offers better performance for deep pagination and provides an easier way to implement pagination.\n\nWhile it utilizes the same `max_matches` window as offset-based pagination, scroll search **can return more documents than the `max_matches` value** by retrieving results over multiple requests using a scroll token.\n\nWhen using scroll pagination, there's no need to use `offset` and `limit` together — it's redundant and generally considered overengineering. Instead, just specify a `limit` along with the `scroll` token to fetch each subsequent page.\n\n#### Scrolling via SQL\n\n<!-- example scroll_sql_init -->\n\n**Initial Query with Sorting Criteria**\n\nStart by executing an initial query with your desired sorting criteria. The only requirement is that `id` must be included in the ORDER BY clause to ensure consistent pagination. The query will return both your results and a scroll token for subsequent pages.\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\nExample:\n\n<!-- request Initial Query Example -->\n\nCODE_BLOCK_5\n\n<!-- response Initial Query Example -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n<!-- example scroll_sql_show -->\n\n**Retrieving the Scroll Token**\n\nAfter executing the initial query, retrieve the scroll token by executing the `SHOW SCROLL` command.\n\nYou must call `SHOW SCROLL` after **every** query in the scroll sequence to obtain the updated scroll token for the next page.\n\nEach query generates a new token that reflects the latest scroll position.\n\nCODE_BLOCK_7\n\nResponse:\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\nExample:\n\n<!-- request Scroll Token Example -->\n\nCODE_BLOCK_9\n\n<!-- response Scroll Token Example -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n<!-- example scroll_sql_paginated -->\n\n**Paginated Query Using scroll**\n\n To retrieve the next page of results, include the scroll token in the subsequent query as an option. When the `scroll` option is provided, specifying the sort criteria is optional.\n\nRemember to call `SHOW SCROLL` again after this query to obtain the new token needed for the following page.\n\nCODE_BLOCK_11\n\nThis ensures that pagination continues seamlessly, maintaining the sorting context established in the initial query.\n\n<!-- intro -->\n\nExample:\n\n<!-- request Paginated Query Example -->\n\nCODE_BLOCK_12\n\n<!-- response Paginated Query Example -->\n\nCODE_BLOCK_13\n\n<!-- end -->\n\n#### Scrolling via JSON\n\n<!-- example scroll_json_init -->\n\n**Initial Request**\n\nIn the initial request, specify `\"scroll\": true` in the options and the desired sorting criteria. Note that `id` must be present in the `sort` array. The response will include a scroll token, which can be used for pagination in subsequent requests.\n\nCODE_BLOCK_14\n\nExample output:\n\nCODE_BLOCK_15\n\n<!-- request Initial Request Example -->\n\nCODE_BLOCK_16\n\n<!-- response Initial Request Example -->\n\nCODE_BLOCK_17\n\n<!-- end -->\n\n<!-- example scroll_json_paginated -->\n\n**Paginated Request Using scroll**\n\nTo continue pagination, include the scroll token obtained from the previous response within the options object of the next request. Specifying the sort criteria is optional.\n\nCODE_BLOCK_18\n\n<!-- request Paginated Request Example -->\n\nCODE_BLOCK_19\n\n<!-- response Paginated Request Example -->\n\nCODE_BLOCK_20\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 搜索结果的分页\n\n<!-- example general -->\n\nManticore Search 默认返回结果集中排名前20的匹配文档。\n\n#### SQL\n\n在 SQL 中，可以使用 `LIMIT` 子句来导航结果集。\n\n`LIMIT` 可以接受一个数字作为返回集的大小（偏移量为零），也可以接受一对偏移量和大小的值。\n\n#### HTTP JSON\n\n使用 HTTP JSON 时，节点 `offset` 和 `limit` 控制结果集的偏移量和返回集的大小。或者，也可以使用 `size` 和 `from` 这对参数。\n\n<!-- intro -->\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n<!-- example maxMatches -->\n\n### 结果集窗口\n\n默认情况下，Manticore Search 使用一个包含1000个最佳排名文档的结果集窗口，这些文档可以返回在结果集中。如果结果集分页超出此值，查询将以错误结束。\n\n此限制可以通过查询选项 [max_matches](../Searching/Options.md#max_matches) 进行调整。\n\n只有在需要导航到如此深的位置时，才应将 `max_matches` 增加到非常高的值。较高的 `max_matches` 值需要更多内存，并可能增加查询响应时间。处理深度结果集的一种方法是将 `max_matches` 设置为偏移量和限制的总和。\n\n将 `max_matches` 降低到1000以下的好处是减少查询使用的内存。它也可以减少查询时间，但在大多数情况下，这种提升可能不明显。\n\n<!-- intro -->\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- request JSON -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n## 滚动搜索选项\n\n滚动搜索选项提供了一种高效且可靠的方式来分页浏览大型结果集。与传统的基于偏移量的分页不同，滚动搜索在深度分页时性能更好，并且实现分页更简单。\n\n虽然它使用与基于偏移量分页相同的 `max_matches` 窗口，但滚动搜索**可以通过使用滚动令牌在多次请求中检索结果，返回超过 `max_matches` 值的文档**。\n\n使用滚动分页时，无需同时使用 `offset` 和 `limit` —— 这是多余的，通常被认为是过度设计。只需指定 `limit` 和 `scroll` 令牌即可获取每个后续页面。\n\n#### 通过 SQL 滚动\n\n<!-- example scroll_sql_init -->\n\n**带排序条件的初始查询**\n\n首先执行带有所需排序条件的初始查询。唯一要求是 `id` 必须包含在 ORDER BY 子句中，以确保分页的一致性。查询将返回结果和用于后续页面的滚动令牌。\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\n示例：\n\n<!-- request Initial Query Example -->\n\nCODE_BLOCK_5\n\n<!-- response Initial Query Example -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n<!-- example scroll_sql_show -->\n\n**获取滚动令牌**\n\n执行初始查询后，通过执行 `SHOW SCROLL` 命令获取滚动令牌。\n\n必须在滚动序列中的**每次**查询后调用 `SHOW SCROLL`，以获取下一页的更新滚动令牌。\n\n每次查询都会生成一个反映最新滚动位置的新令牌。\n\nCODE_BLOCK_7\n\n响应：\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\n示例：\n\n<!-- request Scroll Token Example -->\n\nCODE_BLOCK_9\n\n<!-- response Scroll Token Example -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n<!-- example scroll_sql_paginated -->\n\n**使用 scroll 的分页查询**\n\n要获取下一页结果，在后续查询中将滚动令牌作为选项包含。当提供 `scroll` 选项时，指定排序条件是可选的。\n\n记得在此查询后再次调用 `SHOW SCROLL`，以获取下一页所需的新令牌。\n\nCODE_BLOCK_11\n\n这确保分页无缝继续，保持初始查询中建立的排序上下文。\n\n<!-- intro -->\n\n示例：\n\n<!-- request Paginated Query Example -->\n\nCODE_BLOCK_12\n\n<!-- response Paginated Query Example -->\n\nCODE_BLOCK_13\n\n<!-- end -->\n\n#### 通过 JSON 滚动\n\n<!-- example scroll_json_init -->\n\n**初始请求**\n\n在初始请求中，在选项中指定 `\"scroll\": true` 和所需的排序条件。注意，`id` 必须出现在 `sort` 数组中。响应将包含滚动令牌，可用于后续请求的分页。\n\nCODE_BLOCK_14\n\n示例输出：\n\nCODE_BLOCK_15\n\n<!-- request Initial Request Example -->\n\nCODE_BLOCK_16\n\n<!-- response Initial Request Example -->\n\nCODE_BLOCK_17\n\n<!-- end -->\n\n<!-- example scroll_json_paginated -->\n\n**使用 scroll 的分页请求**\n\n要继续分页，在下一次请求的选项对象中包含从上一次响应获得的滚动令牌。指定排序条件是可选的。\n\nCODE_BLOCK_18\n\n<!-- request Paginated Request Example -->\n\nCODE_BLOCK_19\n\n<!-- response Paginated Request Example -->\n\nCODE_BLOCK_20\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "# Пагинация результатов поиска\n\n<!-- example general -->\n\nManticore Search по умолчанию возвращает топ-20 совпадающих документов в наборе результатов.\n\n#### SQL\n\nВ SQL вы можете перемещаться по набору результатов с помощью оператора `LIMIT`.\n\n`LIMIT` может принимать либо одно число как размер возвращаемого набора с нулевым смещением, либо пару значений смещения и размера.\n\n#### HTTP JSON\n\nПри использовании HTTP JSON узлы `offset` и `limit` управляют смещением набора результатов и размером возвращаемого набора. В качестве альтернативы можно использовать пару `size` и `from`.\n\n<!-- intro -->\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- request JSON -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n<!-- example maxMatches -->\n\n### Окно набора результатов\n\nПо умолчанию Manticore Search использует окно набора результатов из 1000 лучших документов, которые могут быть возвращены в наборе результатов. Если пагинация набора результатов выходит за пределы этого значения, запрос завершится с ошибкой.\n\nЭто ограничение можно настроить с помощью опции запроса [max_matches](../Searching/Options.md#max_matches).\n\nУвеличение `max_matches` до очень больших значений следует делать только в случае необходимости для навигации к таким точкам. Большое значение `max_matches` требует больше памяти и может увеличить время отклика запроса. Один из способов работы с глубокими наборами результатов — установить `max_matches` как сумму смещения и лимита.\n\nУменьшение `max_matches` ниже 1000 имеет преимущество в снижении используемой запросом памяти. Это также может сократить время выполнения запроса, но в большинстве случаев это может быть незаметным улучшением.\n\n<!-- intro -->\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- request JSON -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n## Опция Scroll Search\n\nОпция scroll search предоставляет эффективный и надежный способ пагинации по большим наборам результатов. В отличие от традиционной пагинации на основе смещения, scroll search обеспечивает лучшую производительность при глубокой пагинации и упрощает реализацию пагинации.\n\nХотя она использует то же окно `max_matches`, что и пагинация на основе смещения, scroll search **может возвращать больше документов, чем значение `max_matches`**, получая результаты через несколько запросов с использованием scroll токена.\n\nПри использовании пагинации scroll нет необходимости использовать `offset` и `limit` вместе — это избыточно и обычно считается излишним усложнением. Вместо этого просто укажите `limit` вместе с токеном `scroll` для получения каждой следующей страницы.\n\n#### Прокрутка через SQL\n\n<!-- example scroll_sql_init -->\n\n**Начальный запрос с критериями сортировки**\n\nНачните с выполнения начального запроса с желаемыми критериями сортировки. Единственное требование — `id` должен быть включен в предложение ORDER BY для обеспечения последовательной пагинации. Запрос вернет как ваши результаты, так и scroll токен для последующих страниц.\n\nCODE_BLOCK_4\n\n<!-- intro -->\n\nПример:\n\n<!-- request Initial Query Example -->\n\nCODE_BLOCK_5\n\n<!-- response Initial Query Example -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n<!-- example scroll_sql_show -->\n\n**Получение scroll токена**\n\nПосле выполнения начального запроса получите scroll токен, выполнив команду `SHOW SCROLL`.\n\nВы должны вызывать `SHOW SCROLL` после **каждого** запроса в последовательности scroll, чтобы получить обновленный scroll токен для следующей страницы.\n\nКаждый запрос генерирует новый токен, отражающий последнюю позицию прокрутки.\n\nCODE_BLOCK_7\n\nОтвет:\n\nCODE_BLOCK_8\n\n<!-- intro -->\n\nПример:\n\n<!-- request Scroll Token Example -->\n\nCODE_BLOCK_9\n\n<!-- response Scroll Token Example -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n<!-- example scroll_sql_paginated -->\n\n**Пагинированный запрос с использованием scroll**\n\nДля получения следующей страницы результатов включите scroll токен в последующий запрос в качестве опции. При указании опции `scroll` указание критериев сортировки является необязательным.\n\nНе забудьте снова вызвать `SHOW SCROLL` после этого запроса, чтобы получить новый токен, необходимый для следующей страницы.\n\nCODE_BLOCK_11\n\nЭто гарантирует, что пагинация будет продолжаться беспрепятственно, сохраняя контекст сортировки, установленный в начальном запросе.\n\n<!-- intro -->\n\nПример:\n\n<!-- request Paginated Query Example -->\n\nCODE_BLOCK_12\n\n<!-- response Paginated Query Example -->\n\nCODE_BLOCK_13\n\n<!-- end -->\n\n#### Прокрутка через JSON\n\n<!-- example scroll_json_init -->\n\n**Начальный запрос**\n\nВ начальном запросе укажите `\"scroll\": true` в опциях и желаемые критерии сортировки. Обратите внимание, что `id` должен присутствовать в массиве `sort`. В ответе будет включен scroll токен, который можно использовать для пагинации в последующих запросах.\n\nCODE_BLOCK_14\n\nПример вывода:\n\nCODE_BLOCK_15\n\n<!-- request Initial Request Example -->\n\nCODE_BLOCK_16\n\n<!-- response Initial Request Example -->\n\nCODE_BLOCK_17\n\n<!-- end -->\n\n<!-- example scroll_json_paginated -->\n\n**Пагинированный запрос с использованием scroll**\n\nДля продолжения пагинации включите scroll токен, полученный из предыдущего ответа, в объект опций следующего запроса. Указание критериев сортировки является необязательным.\n\nCODE_BLOCK_18\n\n<!-- request Paginated Request Example -->\n\nCODE_BLOCK_19\n\n<!-- response Paginated Request Example -->\n\nCODE_BLOCK_20\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
