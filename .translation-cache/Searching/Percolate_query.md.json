{
  "6f4a5e8bb097f2b0e2ea116c111fbe6c2b271a5199cf9dbb662803340059ea4d": {
    "original": "In some cases, you might want to get more details about the performance of a percolate query. For that purpose, there is the option `1 as verbose`, which is only available via SQL and allows you to save more performance metrics. You can see them using the `SHOW META` query, which you can run after `CALL PQ`. See [SHOW META](../Node_info_and_management/SHOW_META.md) for more info.\n\n<!-- intro -->\n\n1 as verbose:\n\n<!-- request 1 as verbose -->\n\nCODE_BLOCK_164\n\n<!-- response 1 as verbose -->\n\nCODE_BLOCK_165\n\n<!-- intro -->\n\n0 as verbose (default):\n\n<!-- request 0 as verbose -->\n\nCODE_BLOCK_166\n\n<!-- response 0 as verbose -->\n\nCODE_BLOCK_167\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "在某些情况下，您可能想要获取有关 percolate 查询性能的更多详细信息。为此，有一个选项 `1 as verbose`，该选项仅通过 SQL 可用，允许您保存更多性能指标。您可以使用 `SHOW META` 查询查看它们，该查询可以在 `CALL PQ` 之后运行。有关更多信息，请参见 [SHOW META](../Node_info_and_management/SHOW_META.md)。\n\n<!-- intro -->\n\n1 as verbose:\n\n<!-- request 1 as verbose -->\n\nCODE_BLOCK_164\n\n<!-- response 1 as verbose -->\n\nCODE_BLOCK_165\n\n<!-- intro -->\n\n0 as verbose (default):\n\n<!-- request 0 as verbose -->\n\nCODE_BLOCK_166\n\n<!-- response 0 as verbose -->\n\nCODE_BLOCK_167\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "В некоторых случаях вы можете захотеть получить более подробную информацию о производительности запроса percolate. Для этой цели существует опция `1 as verbose`, которая доступна только через SQL и позволяет сохранять больше метрик производительности. Вы можете просмотреть их с помощью запроса `SHOW META`, который можно выполнить после `CALL PQ`. Подробнее см. в разделе [SHOW META](../Node_info_and_management/SHOW_META.md).\n\n<!-- intro -->\n\n1 as verbose:\n\n<!-- request 1 as verbose -->\n\nCODE_BLOCK_164\n\n<!-- response 1 as verbose -->\n\nCODE_BLOCK_165\n\n<!-- intro -->\n\n0 as verbose (по умолчанию):\n\n<!-- request 0 as verbose -->\n\nCODE_BLOCK_166\n\n<!-- response 0 as verbose -->\n\nCODE_BLOCK_167\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "01db7fa22da16126919c10f7ad0ebf75d100102889d1401bd415633671851972": {
    "original": "When using CALL PQ with separate JSONs, you can use the option 1 as skip_bad_json to skip any invalid JSONs in the input. In the example below, the 2nd query fails due to an invalid JSON, but the 3rd query avoids the error by using 1 as skip_bad_json. Keep in mind that this option is not available when sending JSON queries over HTTP, as the whole JSON query must be valid in that case.\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_112\n\n<!-- response SQL -->\n\nCODE_BLOCK_113\n\n<!-- end -->\n\n##### I want higher performance of a percolate query\n\nPercolate queries are designed with high throughput and large data volumes in mind. To optimize performance for lower latency and higher throughput, consider the following.\n\nThere are two modes of distribution for a percolate table and how a percolate query can work against it:\n\n* **Sparse (default).** Ideal for: many documents, mirrored PQ tables. When your document set is large but the set of queries stored in the PQ table is small, the sparse mode is beneficial. In this mode, the batch of documents you pass will be divided among the number of agents, so each node processes only a portion of the documents from your request. Manticore splits your document set and distributes chunks among the mirrors. Once the agents have finished processing the queries, Manticore collects and merges the results, returning a final query set as if it came from a single table. Use [replication](../References.md#Replication) to assist the process.\n\n* **Sharded.** Ideal for: many PQ rules, rules split among PQ tables. In this mode, the entire document set is broadcast to all tables of the distributed PQ table without initially splitting the documents. This is beneficial when pushing a relatively small set of documents, but the number of stored queries is large. In this case, it's more appropriate to store only a portion of PQ rules on each node and then merge the results returned from the nodes that process the same set of documents against different sets of PQ rules. This mode must be explicitly set, as it implies an increase in network payload and expects tables with different PQs, which [replication](../References.md#Replication) cannot do out-of-the-box.\n\nAssume you have table `pq_d2` defined as:\n\nCODE_BLOCK_114\n\n<!-- example distributed pq modes 1 -->\n\nEach of 'pq' and 'ptitle' contains:\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_115\n\n<!-- response sql -->\n\nCODE_BLOCK_116\n\n<!-- request JSON -->\n\nCODE_BLOCK_117\n\n<!-- response JSON -->\n\nCODE_BLOCK_118\n\n<!-- request PHP -->\n\nCODE_BLOCK_119\n\n<!-- response PHP -->\n\nCODE_BLOCK_120\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_121\n\n<!-- response Python -->\n\nCODE_BLOCK_122\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_123\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_124\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_125\n\n<!-- response javascript -->\n\nCODE_BLOCK_126\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_127\n\n<!-- response javascript -->\n\nCODE_BLOCK_128\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_129\n\n<!-- response Java -->\n\nCODE_BLOCK_130\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_131\n\n<!-- response C# -->\n\nCODE_BLOCK_132\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_133\n\n<!-- response Rust -->\n\nCODE_BLOCK_134\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_135\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_136\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_137\n\n<!-- response Go -->\n\nCODE_BLOCK_138\n\n<!-- end -->\n\n<!-- example call_pq_example -->\n\nAnd you execute `CALL PQ` on the distributed table with a couple of documents.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_139\n\n<!-- response sql -->\n\nCODE_BLOCK_140\n\n<!-- request JSON -->\n\nCODE_BLOCK_141\n\n<!-- response JSON -->\n\nCODE_BLOCK_142\n\n<!-- request PHP -->\n\nCODE_BLOCK_143\n\n<!-- response PHP -->\n\nCODE_BLOCK_144\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_145\n\n<!-- response Python -->\n\nCODE_BLOCK_146\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_147\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_148\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_149\n\n<!-- response javascript -->\n\nCODE_BLOCK_150\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_151\n\n<!-- response java -->\n\nCODE_BLOCK_152\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_153\n\n<!-- response C# -->\n\nCODE_BLOCK_154\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_155\n\n<!-- response Rust -->\n\nCODE_BLOCK_156\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_157\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_158\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_159\n\n<!-- response Go -->\n\nCODE_BLOCK_160\n\n<!-- end -->\n\nIn the previous example, we used the default **sparse** mode. To demonstrate the **sharded** mode, let's create a distributed PQ table consisting of 2 local PQ tables and add 2 documents to \"products1\" and 1 document to \"products2\":\n\nCODE_BLOCK_161\n\n<!-- example sharded -->\n\nNow, if you add `'sharded' as mode` to `CALL PQ`, it will send the documents to all the agent's tables (in this case, just local tables, but they can be remote to utilize external hardware). This mode is not available via the JSON interface.\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_162\n\n<!-- response SQL -->\n\nCODE_BLOCK_163\n\n<!-- end -->\n\nNote that the syntax of agent mirrors in the configuration (when several hosts are assigned to one `agent` line, separated with `|`) has nothing to do with the `CALL PQ` query mode. Each `agent` always represents **one** node, regardless of the number of HA mirrors specified for that agent.\n\n<!-- example verbose -->\n\n##### How can I learn more about performance?",
    "translations": {
      "chinese": "当使用带有独立 JSON 的 CALL PQ 时，您可以使用选项 1 作为 skip_bad_json 来跳过输入中的任何无效 JSON。在下面的示例中，第 2 个查询由于无效的 JSON 而失败，但第 3 个查询通过使用 1 作为 skip_bad_json 避免了错误。请记住，当通过 HTTP 发送 JSON 查询时，此选项不可用，因为在这种情况下整个 JSON 查询必须是有效的。\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_112\n\n<!-- response SQL -->\n\nCODE_BLOCK_113\n\n<!-- end -->\n\n##### 我想要更高性能的 percolate 查询\n\nPercolate 查询是为高吞吐量和大数据量设计的。为了优化性能以实现更低的延迟和更高的吞吐量，请考虑以下内容。\n\npercolate 表有两种分布模式，以及 percolate 查询如何针对它工作：\n\n* **稀疏（默认）。** 适用于：大量文档，镜像 PQ 表。当您的文档集很大但存储在 PQ 表中的查询集较小时，稀疏模式是有益的。在此模式下，您传递的文档批次将被分配给多个代理，因此每个节点只处理请求中文档的一部分。Manticore 会拆分您的文档集并在镜像之间分发块。一旦代理完成查询处理，Manticore 会收集并合并结果，返回一个最终的查询集，就像它来自单个表一样。使用[复制](../References.md#Replication)来辅助此过程。\n\n* **分片。** 适用于：大量 PQ 规则，规则分布在多个 PQ 表中。在此模式下，整个文档集会广播到分布式 PQ 表的所有表，而不会初始拆分文档。当推送的文档集相对较小时，但存储的查询数量很大时，这种方式是有益的。在这种情况下，更适合在每个节点上只存储部分 PQ 规则，然后合并从处理相同文档集但针对不同 PQ 规则集的节点返回的结果。此模式必须显式设置，因为它意味着网络负载增加，并且期望表具有不同的 PQ，这一点是[复制](../References.md#Replication)无法开箱即用实现的。\n\n假设您有定义为：\n\nCODE_BLOCK_114\n\n<!-- example distributed pq modes 1 -->\n\n“pq”和“ptitle”各自包含：\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_115\n\n<!-- response sql -->\n\nCODE_BLOCK_116\n\n<!-- request JSON -->\n\nCODE_BLOCK_117\n\n<!-- response JSON -->\n\nCODE_BLOCK_118\n\n<!-- request PHP -->\n\nCODE_BLOCK_119\n\n<!-- response PHP -->\n\nCODE_BLOCK_120\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_121\n\n<!-- response Python -->\n\nCODE_BLOCK_122\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_123\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_124\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_125\n\n<!-- response javascript -->\n\nCODE_BLOCK_126\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_127\n\n<!-- response javascript -->\n\nCODE_BLOCK_128\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_129\n\n<!-- response Java -->\n\nCODE_BLOCK_130\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_131\n\n<!-- response C# -->\n\nCODE_BLOCK_132\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_133\n\n<!-- response Rust -->\n\nCODE_BLOCK_134\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_135\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_136\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_137\n\n<!-- response Go -->\n\nCODE_BLOCK_138\n\n<!-- end -->\n\n<!-- example call_pq_example -->\n\n然后您在分布式表上执行 `CALL PQ`，并传入几个文档。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_139\n\n<!-- response sql -->\n\nCODE_BLOCK_140\n\n<!-- request JSON -->\n\nCODE_BLOCK_141\n\n<!-- response JSON -->\n\nCODE_BLOCK_142\n\n<!-- request PHP -->\n\nCODE_BLOCK_143\n\n<!-- response PHP -->\n\nCODE_BLOCK_144\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_145\n\n<!-- response Python -->\n\nCODE_BLOCK_146\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_147\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_148\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_149\n\n<!-- response javascript -->\n\nCODE_BLOCK_150\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_151\n\n<!-- response java -->\n\nCODE_BLOCK_152\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_153\n\n<!-- response C# -->\n\nCODE_BLOCK_154\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_155\n\n<!-- response Rust -->\n\nCODE_BLOCK_156\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_157\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_158\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_159\n\n<!-- response Go -->\n\nCODE_BLOCK_160\n\n<!-- end -->\n\n在前面的示例中，我们使用了默认的 **稀疏** 模式。为了演示 **分片** 模式，让我们创建一个由 2 个本地 PQ 表组成的分布式 PQ 表，并向 \"products1\" 添加 2 个文档，向 \"products2\" 添加 1 个文档：\n\nCODE_BLOCK_161\n\n<!-- example sharded -->\n\n现在，如果您向 `CALL PQ` 添加 `'sharded' as mode`，它将把文档发送到所有代理的表（在此情况下仅本地表，但它们可以是远程的以利用外部硬件）。此模式通过 JSON 接口不可用。\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_162\n\n<!-- response SQL -->\n\nCODE_BLOCK_163\n\n<!-- end -->\n\n请注意，配置中代理镜像的语法（当一个 `agent` 行分配了多个主机，用 `|` 分隔）与 `CALL PQ` 查询模式无关。每个 `agent` 始终代表**一个**节点，无论为该代理指定了多少 HA 镜像。\n\n<!-- example verbose -->\n\n##### 我如何了解更多关于性能的信息？",
      "russian": "При использовании CALL PQ с отдельными JSON можно использовать опцию 1 в качестве skip_bad_json, чтобы пропускать любые недопустимые JSON в вводе. В приведённом ниже примере второй запрос не выполняется из-за недопустимого JSON, но третий запрос избегает ошибки, используя 1 в качестве skip_bad_json. Имейте в виду, что эта опция недоступна при отправке JSON-запросов по HTTP, так как в этом случае весь JSON-запрос должен быть валидным.\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_112\n\n<!-- response SQL -->\n\nCODE_BLOCK_113\n\n<!-- end -->\n\n##### Я хочу повысить производительность перколяционного запроса\n\nПерколяционные запросы разработаны с учётом высокой пропускной способности и больших объёмов данных. Чтобы оптимизировать производительность для снижения задержек и увеличения пропускной способности, рассмотрите следующее.\n\nСуществует два режима распределения для перколяционной таблицы и способа работы перколяционного запроса с ней:\n\n* **Sparse (по умолчанию).** Идеально для: большого количества документов, зеркальных PQ таблиц. Когда ваш набор документов большой, но набор запросов, хранящихся в PQ таблице, мал, режим sparse будет полезен. В этом режиме пакет документов, который вы передаёте, будет разделён между количеством агентов, так что каждый узел обрабатывает только часть документов из вашего запроса. Manticore разбивает ваш набор документов и распределяет части между зеркалами. После того как агенты закончат обработку запросов, Manticore собирает и объединяет результаты, возвращая итоговый набор запросов, как если бы он пришёл из одной таблицы. Используйте [репликацию](../References.md#Replication) для поддержки процесса.\n\n* **Sharded.** Идеально для: большого количества правил PQ, правил, разделённых между PQ таблицами. В этом режиме весь набор документов транслируется всем таблицам распределённой PQ таблицы без первоначального разделения документов. Это полезно, когда вы отправляете относительно небольшой набор документов, но количество хранимых запросов велико. В этом случае более целесообразно хранить только часть правил PQ на каждом узле, а затем объединять результаты, возвращаемые узлами, которые обрабатывают один и тот же набор документов против разных наборов правил PQ. Этот режим должен быть установлен явно, так как он подразумевает увеличение сетевого трафика и ожидает таблицы с разными PQ, что [репликация](../References.md#Replication) не может сделать из коробки.\n\nПредположим, у вас есть таблица `pq_d2`, определённая как:\n\nCODE_BLOCK_114\n\n<!-- example distributed pq modes 1 -->\n\nКаждая из 'pq' и 'ptitle' содержит:\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_115\n\n<!-- response sql -->\n\nCODE_BLOCK_116\n\n<!-- request JSON -->\n\nCODE_BLOCK_117\n\n<!-- response JSON -->\n\nCODE_BLOCK_118\n\n<!-- request PHP -->\n\nCODE_BLOCK_119\n\n<!-- response PHP -->\n\nCODE_BLOCK_120\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_121\n\n<!-- response Python -->\n\nCODE_BLOCK_122\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_123\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_124\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_125\n\n<!-- response javascript -->\n\nCODE_BLOCK_126\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_127\n\n<!-- response javascript -->\n\nCODE_BLOCK_128\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_129\n\n<!-- response Java -->\n\nCODE_BLOCK_130\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_131\n\n<!-- response C# -->\n\nCODE_BLOCK_132\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_133\n\n<!-- response Rust -->\n\nCODE_BLOCK_134\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_135\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_136\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_137\n\n<!-- response Go -->\n\nCODE_BLOCK_138\n\n<!-- end -->\n\n<!-- example call_pq_example -->\n\nИ вы выполняете `CALL PQ` на распределённой таблице с несколькими документами.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_139\n\n<!-- response sql -->\n\nCODE_BLOCK_140\n\n<!-- request JSON -->\n\nCODE_BLOCK_141\n\n<!-- response JSON -->\n\nCODE_BLOCK_142\n\n<!-- request PHP -->\n\nCODE_BLOCK_143\n\n<!-- response PHP -->\n\nCODE_BLOCK_144\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_145\n\n<!-- response Python -->\n\nCODE_BLOCK_146\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_147\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_148\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_149\n\n<!-- response javascript -->\n\nCODE_BLOCK_150\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_151\n\n<!-- response java -->\n\nCODE_BLOCK_152\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_153\n\n<!-- response C# -->\n\nCODE_BLOCK_154\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_155\n\n<!-- response Rust -->\n\nCODE_BLOCK_156\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_157\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_158\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_159\n\n<!-- response Go -->\n\nCODE_BLOCK_160\n\n<!-- end -->\n\nВ предыдущем примере мы использовали режим по умолчанию — **sparse**. Чтобы продемонстрировать режим **sharded**, давайте создадим распределённую PQ таблицу, состоящую из 2 локальных PQ таблиц, и добавим 2 документа в \"products1\" и 1 документ в \"products2\":\n\nCODE_BLOCK_161\n\n<!-- example sharded -->\n\nТеперь, если вы добавите `'sharded' as mode` к `CALL PQ`, документы будут отправлены во все таблицы агента (в данном случае только локальные таблицы, но они могут быть удалёнными для использования внешнего оборудования). Этот режим недоступен через JSON-интерфейс.\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_162\n\n<!-- response SQL -->\n\nCODE_BLOCK_163\n\n<!-- end -->\n\nОбратите внимание, что синтаксис зеркал агентов в конфигурации (когда несколько хостов указаны в одной строке `agent`, разделённые `|`) не имеет никакого отношения к режиму запроса `CALL PQ`. Каждый `agent` всегда представляет **один** узел, независимо от количества HA-зеркал, указанных для этого агента.\n\n<!-- example verbose -->\n\n##### Как я могу узнать больше о производительности?"
    },
    "is_code_or_comment": false
  },
  "de77a447aabb77e7fa1b26da39705a3e60af8cbd3a06a11cc0d0af0a10ea2d8b": {
    "original": "# Percolate Query\n\nPercolate queries are also known as Persistent queries, Prospective search, document routing, search in reverse, and inverse search.\n\nThe traditional way of conducting searches involves storing documents and performing search queries against them. However, there are cases where we want to apply a query to a newly incoming document to signal a match. Some scenarios where this is desired include monitoring systems that collect data and notify users about specific events, such as reaching a certain threshold for a metric or a particular value appearing in the monitored data. Another example is news aggregation, where users may want to be notified only about certain categories or topics, or even specific \"keywords.\"\n\nIn these situations, traditional search is not the best fit, as it assumes the desired search is performed over the entire collection. This process gets multiplied by the number of users, resulting in many queries running over the entire collection, which can cause significant additional load. The alternative approach described in this section involves storing the queries instead and testing them against an incoming new document or a batch of documents.\n\nGoogle Alerts, AlertHN, Bloomberg Terminal, and other systems that allow users to subscribe to specific content utilize similar technology.\n\n> * See [percolate](../Creating_a_table/Local_tables/Percolate_table.md) for information on creating a PQ table.\n\n> * See [Adding rules to a percolate table](../Data_creation_and_modification/Adding_documents_to_a_table/Adding_rules_to_a_percolate_table.md) to learn how to add percolate rules (also known as PQ rules). Here's a quick example:\n\n### Performing a percolate query with CALL PQ\n\nThe key thing to remember about percolate queries is that your search queries are already in the table. What you need to provide are documents **to check if any of them match any of the stored rules**.\n\nYou can perform a percolate query via SQL or JSON interfaces, as well as using programming language clients. The SQL approach offers more flexibility, while the HTTP method is simpler and provides most of what you need. The table below can help you understand the differences.\n\n| Desired Behavior              | SQL                                     | HTTP                                 |\n\n| ----------------------------- | --------------------------------------- | ------------------------------------ |\n\n| Provide a single document     | `CALL PQ('tbl', '{doc1}')`              | `query.percolate.document{doc1}`     |\n\n| Provide a single document (alternative) | `CALL PQ('tbl', 'doc1', 0 as docs_json)` | - |\n\n| Provide multiple documents    | `CALL PQ('tbl', ('doc1', 'doc2'), 0 as docs_json)` | - |\n\n| Provide multiple documents (alternative) | `CALL PQ('tbl', ('{doc1}', '{doc2}'))` | - |\n\n| Provide multiple documents (alternative) | `CALL PQ('tbl', '[{doc1}, {doc2}]')` | - |\n\n| Return matching document ids  | 0/1 as docs (disabled by default)       | Enabled by default                   |\n\n| Use document's own id to show in the result | 'id field' as docs_id (disabled by default) | Not available |\n\n| Consider input documents are JSON | 1 as docs_json (1 by default) | Enabled by default |\n\n| Consider input documents are plain text | 0 as docs_json (1 by default) | Not available |\n\n| [Sparsed distribution mode](../Searching/Percolate_query.md#I-want-higher-performance-of-a-percolate-query) | default | default |\n\n| [Sharded distribution mode](../Searching/Percolate_query.md#I-want-higher-performance-of-a-percolate-query) | sharded as mode | Not available |\n\n| Return all info about matching query | 1 as query (0 by default) | Enabled by default |\n\n| Skip invalid JSON | 1 as skip_bad_json (0 by default) | Not available |\n\n| Extended info in [SHOW META](../Node_info_and_management/SHOW_META.md) | 1 as verbose (0 by default) | Not available |\n\n| Define the number which will be added to document ids if no docs_id fields provided (mostly relevant in [distributed PQ modes](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#Distributed-percolate-tables-%28DPQ-tables%29)) | 1 as shift (0 by default) | Not available |\n\n<!-- example create percolate -->\n\nTo demonstrate how this works, here are a few examples. Let's create a PQ table with two fields:\n\n* title (text)\n\n* color (string)\n\nand three rules in it:\n\n* Just full-text. Query: `@title bag`\n\n* Full-text and filtering. Query: `@title shoes`. Filters: `color='red'`\n\n* Full-text and more complex filtering. Query: `@title shoes`. Filters: `color IN('blue', 'green')`\n\n<!-- intro -->\n\n#### SQL\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- response SQL -->\n\nCODE_BLOCK_1\n\n<!-- request JSON -->\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n#### JSON\n\n<!-- response JSON -->\n\nCODE_BLOCK_3\n\n<!-- intro -->\n\n#### PHP\n\n<!-- request PHP -->\n\nCODE_BLOCK_4\n\n<!-- response PHP -->\n\nCODE_BLOCK_5\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_6\n\n<!-- response Python -->\n\nCODE_BLOCK_7\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_8\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_9\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_10\n\n<!-- response javascript -->\n\nCODE_BLOCK_11\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_12\n\n<!-- response Java -->\n\nCODE_BLOCK_13\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_14\n\n<!-- response C# -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_16\n\n<!-- response Rust -->\n\nCODE_BLOCK_17\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_18\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_19\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_20\n\n<!-- response Go -->\n\nCODE_BLOCK_21\n\n<!-- end -->\n\n<!-- example single -->\n\n##### Just tell me what PQ rules match my single document\n\nThe first document doesn't match any rules. It could match the first two, but they require additional filters.\n\nThe second document matches one rule. Note that CALL PQ by default expects a document to be a JSON, but if you use `0 as docs_json`, you can pass a plain string instead.\n\n<!-- intro -->",
    "translations": {
      "chinese": "# Percolate 查询\n\nPercolate 查询也称为持久查询、前瞻搜索、文档路由、反向搜索和逆向搜索。\n\n传统的搜索方式是存储文档并对其执行搜索查询。然而，有些情况下我们希望将查询应用于新到达的文档以标记匹配。一些需要这种方式的场景包括监控系统收集数据并通知用户特定事件，例如达到某个指标阈值或监控数据中出现特定值。另一个例子是新闻聚合，用户可能只想收到某些类别或主题，甚至特定“关键词”的通知。\n\n在这些情况下，传统搜索并不适用，因为它假设搜索是在整个集合上执行的。这个过程会随着用户数量的增加而成倍增长，导致大量查询在整个集合上运行，可能造成显著的额外负载。本节描述的替代方法是存储查询，然后将它们测试于新到达的文档或文档批次。\n\nGoogle Alerts、AlertHN、Bloomberg Terminal 以及其他允许用户订阅特定内容的系统都使用类似技术。\n\n> * 参见 [percolate](../Creating_a_table/Local_tables/Percolate_table.md) 了解如何创建 PQ 表。\n\n> * 参见 [向 percolate 表添加规则](../Data_creation_and_modification/Adding_documents_to_a_table/Adding_rules_to_a_percolate_table.md) 学习如何添加 percolate 规则（也称为 PQ 规则）。这里有一个快速示例：\n\n### 使用 CALL PQ 执行 percolate 查询\n\n关于 percolate 查询，关键是你的搜索查询已经存储在表中。你需要提供的是文档，**以检查它们是否匹配任何存储的规则**。\n\n你可以通过 SQL 或 JSON 接口执行 percolate 查询，也可以使用编程语言客户端。SQL 方法更灵活，而 HTTP 方法更简单，且提供了大部分所需功能。下表帮助你理解两者的区别。\n\n| 期望行为                      | SQL                                     | HTTP                                 |\n\n| ----------------------------- | --------------------------------------- | ------------------------------------ |\n\n| 提供单个文档                 | `CALL PQ('tbl', '{doc1}')`              | `query.percolate.document{doc1}`     |\n\n| 提供单个文档（替代）         | `CALL PQ('tbl', 'doc1', 0 as docs_json)` | - |\n\n| 提供多个文档                 | `CALL PQ('tbl', ('doc1', 'doc2'), 0 as docs_json)` | - |\n\n| 提供多个文档（替代）         | `CALL PQ('tbl', ('{doc1}', '{doc2}'))` | - |\n\n| 提供多个文档（替代）         | `CALL PQ('tbl', '[{doc1}, {doc2}]')` | - |\n\n| 返回匹配的文档 ID            | 0/1 作为 docs（默认禁用）               | 默认启用                           |\n\n| 使用文档自身 ID 显示结果     | 'id field' 作为 docs_id（默认禁用）     | 不可用                             |\n\n| 认为输入文档是 JSON          | 1 作为 docs_json（默认 1）               | 默认启用                           |\n\n| 认为输入文档是纯文本         | 0 作为 docs_json（默认 1）               | 不可用                             |\n\n| [稀疏分布模式](../Searching/Percolate_query.md#I-want-higher-performance-of-a-percolate-query) | 默认                                  | 默认                              |\n\n| [分片分布模式](../Searching/Percolate_query.md#I-want-higher-performance-of-a-percolate-query) | sharded 作为 mode                      | 不可用                             |\n\n| 返回匹配查询的所有信息       | 1 作为 query（默认 0）                   | 默认启用                           |\n\n| 跳过无效 JSON               | 1 作为 skip_bad_json（默认 0）           | 不可用                             |\n\n| 在 [SHOW META](../Node_info_and_management/SHOW_META.md) 中显示扩展信息 | 1 作为 verbose（默认 0）                 | 不可用                             |\n\n| 定义当未提供 docs_id 字段时加到文档 ID 的数值（主要用于[分布式 PQ 模式](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#Distributed-percolate-tables-%28DPQ-tables%29)） | 1 作为 shift（默认 0）                   | 不可用                             |\n\n<!-- example create percolate -->\n\n为了演示其工作原理，以下是几个示例。我们创建一个包含两个字段的 PQ 表：\n\n* title（文本）\n\n* color（字符串）\n\n以及其中的三条规则：\n\n* 仅全文。查询：`@title bag`\n\n* 全文加过滤。查询：`@title shoes`。过滤条件：`color='red'`\n\n* 全文加更复杂的过滤。查询：`@title shoes`。过滤条件：`color IN('blue', 'green')`\n\n<!-- intro -->\n\n#### SQL\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- response SQL -->\n\nCODE_BLOCK_1\n\n<!-- request JSON -->\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n#### JSON\n\n<!-- response JSON -->\n\nCODE_BLOCK_3\n\n<!-- intro -->\n\n#### PHP\n\n<!-- request PHP -->\n\nCODE_BLOCK_4\n\n<!-- response PHP -->\n\nCODE_BLOCK_5\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_6\n\n<!-- response Python -->\n\nCODE_BLOCK_7\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_8\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_9\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_10\n\n<!-- response javascript -->\n\nCODE_BLOCK_11\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_12\n\n<!-- response Java -->\n\nCODE_BLOCK_13\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_14\n\n<!-- response C# -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_16\n\n<!-- response Rust -->\n\nCODE_BLOCK_17\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_18\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_19\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_20\n\n<!-- response Go -->\n\nCODE_BLOCK_21\n\n<!-- end -->\n\n<!-- example single -->\n\n##### 只告诉我哪些 PQ 规则匹配我的单个文档\n\n第一个文档不匹配任何规则。它可能匹配前两个，但它们需要额外的过滤条件。\n\n第二个文档匹配一条规则。注意 CALL PQ 默认期望文档为 JSON，但如果使用 `0 as docs_json`，你可以传递纯字符串。\n\n<!-- intro -->",
      "russian": "# Percolate Query\n\nPercolate queries are also known as Persistent queries, Prospective search, document routing, search in reverse, and inverse search.\n\nThe traditional way of conducting searches involves storing documents and performing search queries against them. However, there are cases where we want to apply a query to a newly incoming document to signal a match. Some scenarios where this is desired include monitoring systems that collect data and notify users about specific events, such as reaching a certain threshold for a metric or a particular value appearing in the monitored data. Another example is news aggregation, where users may want to be notified only about certain categories or topics, or even specific \"keywords.\"\n\nIn these situations, traditional search is not the best fit, as it assumes the desired search is performed over the entire collection. This process gets multiplied by the number of users, resulting in many queries running over the entire collection, which can cause significant additional load. The alternative approach described in this section involves storing the queries instead and testing them against an incoming new document or a batch of documents.\n\nGoogle Alerts, AlertHN, Bloomberg Terminal, and other systems that allow users to subscribe to specific content utilize similar technology.\n\n> * See [percolate](../Creating_a_table/Local_tables/Percolate_table.md) for information on creating a PQ table.\n\n> * See [Adding rules to a percolate table](../Data_creation_and_modification/Adding_documents_to_a_table/Adding_rules_to_a_percolate_table.md) to learn how to add percolate rules (also known as PQ rules). Here's a quick example:\n\n### Performing a percolate query with CALL PQ\n\nThe key thing to remember about percolate queries is that your search queries are already in the table. What you need to provide are documents **to check if any of them match any of the stored rules**.\n\nYou can perform a percolate query via SQL or JSON interfaces, as well as using programming language clients. The SQL approach offers more flexibility, while the HTTP method is simpler and provides most of what you need. The table below can help you understand the differences.\n\n| Desired Behavior              | SQL                                     | HTTP                                 |\n\n| ----------------------------- | --------------------------------------- | ------------------------------------ |\n\n| Provide a single document     | `CALL PQ('tbl', '{doc1}')`              | `query.percolate.document{doc1}`     |\n\n| Provide a single document (alternative) | `CALL PQ('tbl', 'doc1', 0 as docs_json)` | - |\n\n| Provide multiple documents    | `CALL PQ('tbl', ('doc1', 'doc2'), 0 as docs_json)` | - |\n\n| Provide multiple documents (alternative) | `CALL PQ('tbl', ('{doc1}', '{doc2}'))` | - |\n\n| Provide multiple documents (alternative) | `CALL PQ('tbl', '[{doc1}, {doc2}]')` | - |\n\n| Return matching document ids  | 0/1 as docs (disabled by default)       | Enabled by default                   |\n\n| Use document's own id to show in the result | 'id field' as docs_id (disabled by default) | Not available |\n\n| Consider input documents are JSON | 1 as docs_json (1 by default) | Enabled by default |\n\n| Consider input documents are plain text | 0 as docs_json (1 by default) | Not available |\n\n| [Sparsed distribution mode](../Searching/Percolate_query.md#I-want-higher-performance-of-a-percolate-query) | default | default |\n\n| [Sharded distribution mode](../Searching/Percolate_query.md#I-want-higher-performance-of-a-percolate-query) | sharded as mode | Not available |\n\n| Return all info about matching query | 1 as query (0 by default) | Enabled by default |\n\n| Skip invalid JSON | 1 as skip_bad_json (0 by default) | Not available |\n\n| Extended info in [SHOW META](../Node_info_and_management/SHOW_META.md) | 1 as verbose (0 by default) | Not available |\n\n| Define the number which will be added to document ids if no docs_id fields provided (mostly relevant in [distributed PQ modes](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#Distributed-percolate-tables-%28DPQ-tables%29)) | 1 as shift (0 by default) | Not available |\n\n<!-- example create percolate -->\n\nTo demonstrate how this works, here are a few examples. Let's create a PQ table with two fields:\n\n* title (text)\n\n* color (string)\n\nand three rules in it:\n\n* Just full-text. Query: `@title bag`\n\n* Full-text and filtering. Query: `@title shoes`. Filters: `color='red'`\n\n* Full-text and more complex filtering. Query: `@title shoes`. Filters: `color IN('blue', 'green')`\n\n<!-- intro -->\n\n#### SQL\n\n<!-- request SQL -->\n\nCODE_BLOCK_0\n\n<!-- response SQL -->\n\nCODE_BLOCK_1\n\n<!-- request JSON -->\n\nCODE_BLOCK_2\n\n<!-- intro -->\n\n#### JSON\n\n<!-- response JSON -->\n\nCODE_BLOCK_3\n\n<!-- intro -->\n\n#### PHP\n\n<!-- request PHP -->\n\nCODE_BLOCK_4\n\n<!-- response PHP -->\n\nCODE_BLOCK_5\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_6\n\n<!-- response Python -->\n\nCODE_BLOCK_7\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_8\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_9\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_10\n\n<!-- response javascript -->\n\nCODE_BLOCK_11\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_12\n\n<!-- response Java -->\n\nCODE_BLOCK_13\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_14\n\n<!-- response C# -->\n\nCODE_BLOCK_15\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_16\n\n<!-- response Rust -->\n\nCODE_BLOCK_17\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_18\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_19\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_20\n\n<!-- response Go -->\n\nCODE_BLOCK_21\n\n<!-- end -->\n\n<!-- example single -->\n\n##### Just tell me what PQ rules match my single document\n\nThe first document doesn't match any rules. It could match the first two, but they require additional filters.\n\nThe second document matches one rule. Note that CALL PQ by default expects a document to be a JSON, but if you use `0 as docs_json`, you can pass a plain string instead.\n\n<!-- intro -->"
    },
    "is_code_or_comment": false
  },
  "2d460b9ccec18121e958c4c075e8fc7848396add07b64cbe9217698180694a97": {
    "original": "SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_22\n\n<!-- response SQL -->\n\nCODE_BLOCK_23\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_24\n\n<!-- response JSON -->\n\nCODE_BLOCK_25\n\n<!-- intro -->\n\nPHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_26\n\n<!-- response PHP -->\n\nCODE_BLOCK_27\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_28\n\n<!-- response Python -->\n\nCODE_BLOCK_29\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_30\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_31\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_32\n\n<!-- response javascript -->\n\nCODE_BLOCK_33\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_34\n\n<!-- response Javs -->\n\nCODE_BLOCK_35\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_36\n\n<!-- response C# -->\n\nCODE_BLOCK_37\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_38\n\n<!-- response Rust -->\n\nCODE_BLOCK_39\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_40\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_41\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_42\n\n<!-- response Go -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n<!-- example pq_rules -->\n\n##### I want to know complete PQ rules matching my document\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_44\n\n<!-- response SQL -->\n\nCODE_BLOCK_45\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_46\n\n<!-- response JSON -->\n\nCODE_BLOCK_47\n\n<!-- intro -->\n\nPHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_48\n\n<!-- response PHP -->\n\nCODE_BLOCK_49\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_50\n\n<!-- response Python -->\n\nCODE_BLOCK_51\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_52\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_53\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_54\n\n<!-- response javascript -->\n\nCODE_BLOCK_55\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_56\n\n<!-- response Java -->\n\nCODE_BLOCK_57\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_58\n\n<!-- response C# -->\n\nCODE_BLOCK_59\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_60\n\n<!-- response Rust -->\n\nCODE_BLOCK_61\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_62\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_63\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_64\n\n<!-- response Go -->\n\nCODE_BLOCK_65\n\n<!-- end -->\n\n<!-- example multiple -->\n\n##### How about multiple documents?\n\nNote that with `CALL PQ`, you can provide multiple documents in different ways:\n\n* as an array of plain documents in round brackets `('doc1', 'doc2')`. This requires `0 as docs_json`\n\n* as an array of JSONs in round brackets `('{doc1}', '{doc2}')`\n\n* or as a standard JSON array `'[{doc1}, {doc2}]'`\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_66\n\n<!-- response SQL -->\n\nCODE_BLOCK_67\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_68\n\n<!-- response JSON -->\n\nCODE_BLOCK_69\n\n<!-- intro -->\n\nPHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_70\n\n<!-- response PHP -->\n\nCODE_BLOCK_71\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_72\n\n<!-- response Python -->\n\nCODE_BLOCK_73\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_74\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_75\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_76\n\n<!-- response javascript -->\n\nCODE_BLOCK_77\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_78\n\n<!-- response Java -->\n\nCODE_BLOCK_79\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_80\n\n<!-- response C# -->\n\nCODE_BLOCK_81\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_82\n\n<!-- response Rust -->\n\nCODE_BLOCK_83\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_84\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_85\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_86\n\n<!-- response Go -->\n\nCODE_BLOCK_87\n\n<!-- end -->\n\n<!-- example docs_1 -->\n\n##### I want to know what docs match what rules\n\nUsing the option `1 as docs` allows you to see which documents of the provided ones match which rules.\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_88\n\n<!-- response SQL -->\n\nCODE_BLOCK_89\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_90\n\n<!-- response JSON -->\n\nCODE_BLOCK_91\n\n<!-- intro -->\n\nPHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_92\n\n<!-- response PHP -->\n\nCODE_BLOCK_93\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_94\n\n<!-- response Python -->\n\nCODE_BLOCK_95\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_96\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_97\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_98\n\n<!-- response javascript -->\n\nCODE_BLOCK_99\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_100\n\n<!-- response Java -->\n\nCODE_BLOCK_101\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_102\n\n<!-- response C# -->\n\nCODE_BLOCK_103\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_104\n\n<!-- response Rust -->\n\nCODE_BLOCK_105\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_106\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_107\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_108\n\n<!-- response Go -->\n\nCODE_BLOCK_109\n\n<!-- end -->\n\n<!-- example docs_id -->\n\n#### Static ids\n\nBy default, matching document ids correspond to their relative numbers in the list you provide. However, in some cases, each document already has its own id. For this case, there's an option `'id field name' as docs_id` for `CALL PQ`.\n\nNote that if the id cannot be found by the provided field name, the PQ rule will not be shown in the results.\n\nThis option is only available for `CALL PQ` via SQL.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_110\n\n<!-- response SQL -->\n\nCODE_BLOCK_111\n\n<!-- end -->\n\n<!-- example invalid_json -->\n\n##### I may have invalid JSONs, please skip them",
    "translations": {
      "chinese": "SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_22\n\n<!-- response SQL -->\n\nCODE_BLOCK_23\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_24\n\n<!-- response JSON -->\n\nCODE_BLOCK_25\n\n<!-- intro -->\n\nPHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_26\n\n<!-- response PHP -->\n\nCODE_BLOCK_27\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_28\n\n<!-- response Python -->\n\nCODE_BLOCK_29\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_30\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_31\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_32\n\n<!-- response javascript -->\n\nCODE_BLOCK_33\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_34\n\n<!-- response Javs -->\n\nCODE_BLOCK_35\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_36\n\n<!-- response C# -->\n\nCODE_BLOCK_37\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_38\n\n<!-- response Rust -->\n\nCODE_BLOCK_39\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_40\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_41\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_42\n\n<!-- response Go -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n<!-- example pq_rules -->\n\n##### 我想知道与我的文档匹配的完整 PQ 规则\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_44\n\n<!-- response SQL -->\n\nCODE_BLOCK_45\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_46\n\n<!-- response JSON -->\n\nCODE_BLOCK_47\n\n<!-- intro -->\n\nPHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_48\n\n<!-- response PHP -->\n\nCODE_BLOCK_49\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_50\n\n<!-- response Python -->\n\nCODE_BLOCK_51\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_52\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_53\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_54\n\n<!-- response javascript -->\n\nCODE_BLOCK_55\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_56\n\n<!-- response Java -->\n\nCODE_BLOCK_57\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_58\n\n<!-- response C# -->\n\nCODE_BLOCK_59\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_60\n\n<!-- response Rust -->\n\nCODE_BLOCK_61\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_62\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_63\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_64\n\n<!-- response Go -->\n\nCODE_BLOCK_65\n\n<!-- end -->\n\n<!-- example multiple -->\n\n##### 多个文档怎么样？\n\n请注意，使用 `CALL PQ`，您可以通过不同方式提供多个文档：\n\n* 作为圆括号中的普通文档数组 `('doc1', 'doc2')`。这需要 `0 as docs_json`\n\n* 作为圆括号中的 JSON 数组 `('{doc1}', '{doc2}')`\n\n* 或作为标准 JSON 数组 `'[{doc1}, {doc2}]'`\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_66\n\n<!-- response SQL -->\n\nCODE_BLOCK_67\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_68\n\n<!-- response JSON -->\n\nCODE_BLOCK_69\n\n<!-- intro -->\n\nPHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_70\n\n<!-- response PHP -->\n\nCODE_BLOCK_71\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_72\n\n<!-- response Python -->\n\nCODE_BLOCK_73\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_74\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_75\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_76\n\n<!-- response javascript -->\n\nCODE_BLOCK_77\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_78\n\n<!-- response Java -->\n\nCODE_BLOCK_79\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_80\n\n<!-- response C# -->\n\nCODE_BLOCK_81\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_82\n\n<!-- response Rust -->\n\nCODE_BLOCK_83\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_84\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_85\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_86\n\n<!-- response Go -->\n\nCODE_BLOCK_87\n\n<!-- end -->\n\n<!-- example docs_1 -->\n\n##### 我想知道哪些文档匹配哪些规则\n\n使用选项 `1 as docs` 可以让您看到提供的文档中哪些匹配哪些规则。\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_88\n\n<!-- response SQL -->\n\nCODE_BLOCK_89\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_90\n\n<!-- response JSON -->\n\nCODE_BLOCK_91\n\n<!-- intro -->\n\nPHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_92\n\n<!-- response PHP -->\n\nCODE_BLOCK_93\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_94\n\n<!-- response Python -->\n\nCODE_BLOCK_95\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_96\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_97\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_98\n\n<!-- response javascript -->\n\nCODE_BLOCK_99\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_100\n\n<!-- response Java -->\n\nCODE_BLOCK_101\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_102\n\n<!-- response C# -->\n\nCODE_BLOCK_103\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_104\n\n<!-- response Rust -->\n\nCODE_BLOCK_105\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_106\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_107\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_108\n\n<!-- response Go -->\n\nCODE_BLOCK_109\n\n<!-- end -->\n\n<!-- example docs_id -->\n\n#### 静态 id\n\n默认情况下，匹配的文档 id 对应于您提供列表中的相对编号。但是，在某些情况下，每个文档已经有自己的 id。对于这种情况，`CALL PQ` 有一个选项 `'id field name' as docs_id`。\n\n请注意，如果通过提供的字段名找不到 id，则 PQ 规则不会显示在结果中。\n\n此选项仅适用于通过 SQL 使用 `CALL PQ`。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_110\n\n<!-- response SQL -->\n\nCODE_BLOCK_111\n\n<!-- end -->\n\n<!-- example invalid_json -->\n\n##### 我可能有无效的 JSON，请跳过它们",
      "russian": "SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_22\n\n<!-- response SQL -->\n\nCODE_BLOCK_23\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_24\n\n<!-- response JSON -->\n\nCODE_BLOCK_25\n\n<!-- intro -->\n\nPHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_26\n\n<!-- response PHP -->\n\nCODE_BLOCK_27\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_28\n\n<!-- response Python -->\n\nCODE_BLOCK_29\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_30\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_31\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_32\n\n<!-- response javascript -->\n\nCODE_BLOCK_33\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_34\n\n<!-- response Javs -->\n\nCODE_BLOCK_35\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_36\n\n<!-- response C# -->\n\nCODE_BLOCK_37\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_38\n\n<!-- response Rust -->\n\nCODE_BLOCK_39\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_40\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_41\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_42\n\n<!-- response Go -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n<!-- example pq_rules -->\n\n##### Я хочу узнать полные правила PQ, соответствующие моему документу\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_44\n\n<!-- response SQL -->\n\nCODE_BLOCK_45\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_46\n\n<!-- response JSON -->\n\nCODE_BLOCK_47\n\n<!-- intro -->\n\nPHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_48\n\n<!-- response PHP -->\n\nCODE_BLOCK_49\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_50\n\n<!-- response Python -->\n\nCODE_BLOCK_51\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_52\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_53\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_54\n\n<!-- response javascript -->\n\nCODE_BLOCK_55\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_56\n\n<!-- response Java -->\n\nCODE_BLOCK_57\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_58\n\n<!-- response C# -->\n\nCODE_BLOCK_59\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_60\n\n<!-- response Rust -->\n\nCODE_BLOCK_61\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_62\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_63\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_64\n\n<!-- response Go -->\n\nCODE_BLOCK_65\n\n<!-- end -->\n\n<!-- example multiple -->\n\n##### Как насчёт нескольких документов?\n\nОбратите внимание, что с помощью `CALL PQ` вы можете предоставить несколько документов разными способами:\n\n* как массив простых документов в круглых скобках `('doc1', 'doc2')`. Для этого требуется `0 as docs_json`\n\n* как массив JSON в круглых скобках `('{doc1}', '{doc2}')`\n\n* или как стандартный JSON-массив `'[{doc1}, {doc2}]'`\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_66\n\n<!-- response SQL -->\n\nCODE_BLOCK_67\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_68\n\n<!-- response JSON -->\n\nCODE_BLOCK_69\n\n<!-- intro -->\n\nPHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_70\n\n<!-- response PHP -->\n\nCODE_BLOCK_71\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_72\n\n<!-- response Python -->\n\nCODE_BLOCK_73\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_74\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_75\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_76\n\n<!-- response javascript -->\n\nCODE_BLOCK_77\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_78\n\n<!-- response Java -->\n\nCODE_BLOCK_79\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_80\n\n<!-- response C# -->\n\nCODE_BLOCK_81\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_82\n\n<!-- response Rust -->\n\nCODE_BLOCK_83\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_84\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_85\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_86\n\n<!-- response Go -->\n\nCODE_BLOCK_87\n\n<!-- end -->\n\n<!-- example docs_1 -->\n\n##### Я хочу узнать, какие документы соответствуют каким правилам\n\nИспользование опции `1 as docs` позволяет увидеть, какие из предоставленных документов соответствуют каким правилам.\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_88\n\n<!-- response SQL -->\n\nCODE_BLOCK_89\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_90\n\n<!-- response JSON -->\n\nCODE_BLOCK_91\n\n<!-- intro -->\n\nPHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_92\n\n<!-- response PHP -->\n\nCODE_BLOCK_93\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_94\n\n<!-- response Python -->\n\nCODE_BLOCK_95\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_96\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_97\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_98\n\n<!-- response javascript -->\n\nCODE_BLOCK_99\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_100\n\n<!-- response Java -->\n\nCODE_BLOCK_101\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_102\n\n<!-- response C# -->\n\nCODE_BLOCK_103\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_104\n\n<!-- response Rust -->\n\nCODE_BLOCK_105\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_106\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_107\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_108\n\n<!-- response Go -->\n\nCODE_BLOCK_109\n\n<!-- end -->\n\n<!-- example docs_id -->\n\n#### Статические идентификаторы\n\nПо умолчанию идентификаторы совпадающих документов соответствуют их относительным номерам в списке, который вы предоставляете. Однако в некоторых случаях у каждого документа уже есть свой собственный идентификатор. Для этого случая существует опция `'id field name' as docs_id` для `CALL PQ`.\n\nОбратите внимание, что если идентификатор не может быть найден по указанному имени поля, правило PQ не будет отображено в результатах.\n\nЭта опция доступна только для `CALL PQ` через SQL.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_110\n\n<!-- response SQL -->\n\nCODE_BLOCK_111\n\n<!-- end -->\n\n<!-- example invalid_json -->\n\n##### У меня могут быть некорректные JSON, пожалуйста, пропускайте их"
    },
    "is_code_or_comment": false
  },
  "92871154250d9b5f3e6fc3ec51c73b55034763f956141bad361f25c81fccc9fd": {
    "original": "<!-- request JSON -->\n\nCODE_BLOCK_112\n\n<!-- response JSON -->\n\nCODE_BLOCK_113\n\n<!-- end -->\n\n<!-- example invalid_json -->\n\n##### I may have invalid JSONs, please skip them\n\nWhen using CALL PQ with separate JSONs, you can use the option 1 as skip_bad_json to skip any invalid JSONs in the input. In the example below, the 2nd query fails due to an invalid JSON, but the 3rd query avoids the error by using 1 as skip_bad_json. Keep in mind that this option is not available when sending JSON queries over HTTP, as the whole JSON query must be valid in that case.\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_114\n\n<!-- response SQL -->\n\nCODE_BLOCK_115\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_116\n\n<!-- response JSON -->\n\nCODE_BLOCK_117\n\n<!-- end -->\n\n##### I want higher performance of a percolate query\n\nPercolate queries are designed with high throughput and large data volumes in mind. To optimize performance for lower latency and higher throughput, consider the following.\n\nThere are two modes of distribution for a percolate table and how a percolate query can work against it:\n\n* **Sparse (default).** Ideal for: many documents, mirrored PQ tables. When your document set is large but the set of queries stored in the PQ table is small, the sparse mode is beneficial. In this mode, the batch of documents you pass will be divided among the number of agents, so each node processes only a portion of the documents from your request. Manticore splits your document set and distributes chunks among the mirrors. Once the agents have finished processing the queries, Manticore collects and merges the results, returning a final query set as if it came from a single table. Use [replication](../References.md#Replication) to assist the process.\n\n* **Sharded.** Ideal for: many PQ rules, rules split among PQ tables. In this mode, the entire document set is broadcast to all tables of the distributed PQ table without initially splitting the documents. This is beneficial when pushing a relatively small set of documents, but the number of stored queries is large. In this case, it's more appropriate to store only a portion of PQ rules on each node and then merge the results returned from the nodes that process the same set of documents against different sets of PQ rules. This mode must be explicitly set, as it implies an increase in network payload and expects tables with different PQs, which [replication](../References.md#Replication) cannot do out-of-the-box.\n\nAssume you have table `pq_d2` defined as:\n\nCODE_BLOCK_118\n\n<!-- example distributed pq modes 1 -->\n\nEach of 'pq' and 'ptitle' contains:\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_119\n\n<!-- response sql -->\n\nCODE_BLOCK_120\n\n<!-- request JSON -->\n\nCODE_BLOCK_121\n\n<!-- response JSON -->\n\nCODE_BLOCK_122\n\n<!-- request PHP -->\n\nCODE_BLOCK_123\n\n<!-- response PHP -->\n\nCODE_BLOCK_124\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_125\n\n<!-- response Python -->\n\nCODE_BLOCK_126\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_127\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_128\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_129\n\n<!-- response javascript -->\n\nCODE_BLOCK_130\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_131\n\n<!-- response javascript -->\n\nCODE_BLOCK_132\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_133\n\n<!-- response Java -->\n\nCODE_BLOCK_134\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_135\n\n<!-- response C# -->\n\nCODE_BLOCK_136\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_137\n\n<!-- response Rust -->\n\nCODE_BLOCK_138\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_139\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_140\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_141\n\n<!-- response Go -->\n\nCODE_BLOCK_142\n\n<!-- end -->\n\n<!-- example call_pq_example -->\n\nAnd you execute `CALL PQ` on the distributed table with a couple of documents.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_143\n\n<!-- response sql -->\n\nCODE_BLOCK_144\n\n<!-- request JSON -->\n\nCODE_BLOCK_145\n\n<!-- response JSON -->\n\nCODE_BLOCK_146\n\n<!-- request PHP -->\n\nCODE_BLOCK_147\n\n<!-- response PHP -->\n\nCODE_BLOCK_148\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_149\n\n<!-- response Python -->\n\nCODE_BLOCK_150\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_151\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_152\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_153\n\n<!-- response javascript -->\n\nCODE_BLOCK_154\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_155\n\n<!-- response java -->\n\nCODE_BLOCK_156\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_157\n\n<!-- response C# -->\n\nCODE_BLOCK_158\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_159\n\n<!-- response Rust -->\n\nCODE_BLOCK_160\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_161\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_162\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_163\n\n<!-- response Go -->\n\nCODE_BLOCK_164\n\n<!-- end -->\n\nIn the previous example, we used the default **sparse** mode. To demonstrate the **sharded** mode, let's create a distributed PQ table consisting of 2 local PQ tables and add 2 documents to \"products1\" and 1 document to \"products2\":\n\nCODE_BLOCK_165\n\n<!-- example sharded -->\n\nNow, if you add `'sharded' as mode` to `CALL PQ`, it will send the documents to all the agent's tables (in this case, just local tables, but they can be remote to utilize external hardware). This mode is not available via the JSON interface.\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_166\n\n<!-- response SQL -->\n\nCODE_BLOCK_167\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_168\n\n<!-- response JSON -->\n\nCODE_BLOCK_169\n\n<!-- end -->",
    "translations": {
      "chinese": "<!-- request JSON -->\n\nCODE_BLOCK_112\n\n<!-- response JSON -->\n\nCODE_BLOCK_113\n\n<!-- end -->\n\n<!-- example invalid_json -->\n\n##### I may have invalid JSONs, please skip them\n\nWhen using CALL PQ with separate JSONs, you can use the option 1 as skip_bad_json to skip any invalid JSONs in the input. In the example below, the 2nd query fails due to an invalid JSON, but the 3rd query avoids the error by using 1 as skip_bad_json. Keep in mind that this option is not available when sending JSON queries over HTTP, as the whole JSON query must be valid in that case.\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_114\n\n<!-- response SQL -->\n\nCODE_BLOCK_115\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_116\n\n<!-- response JSON -->\n\nCODE_BLOCK_117\n\n<!-- end -->\n\n##### I want higher performance of a percolate query\n\nPercolate queries are designed with high throughput and large data volumes in mind. To optimize performance for lower latency and higher throughput, consider the following.\n\nThere are two modes of distribution for a percolate table and how a percolate query can work against it:\n\n* **Sparse (default).** Ideal for: many documents, mirrored PQ tables. When your document set is large but the set of queries stored in the PQ table is small, the sparse mode is beneficial. In this mode, the batch of documents you pass will be divided among the number of agents, so each node processes only a portion of the documents from your request. Manticore splits your document set and distributes chunks among the mirrors. Once the agents have finished processing the queries, Manticore collects and merges the results, returning a final query set as if it came from a single table. Use [replication](../References.md#Replication) to assist the process.\n\n* **Sharded.** Ideal for: many PQ rules, rules split among PQ tables. In this mode, the entire document set is broadcast to all tables of the distributed PQ table without initially splitting the documents. This is beneficial when pushing a relatively small set of documents, but the number of stored queries is large. In this case, it's more appropriate to store only a portion of PQ rules on each node and then merge the results returned from the nodes that process the same set of documents against different sets of PQ rules. This mode must be explicitly set, as it implies an increase in network payload and expects tables with different PQs, which [replication](../References.md#Replication) cannot do out-of-the-box.\n\nAssume you have table `pq_d2` defined as:\n\nCODE_BLOCK_118\n\n<!-- example distributed pq modes 1 -->\n\nEach of 'pq' and 'ptitle' contains:\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_119\n\n<!-- response sql -->\n\nCODE_BLOCK_120\n\n<!-- request JSON -->\n\nCODE_BLOCK_121\n\n<!-- response JSON -->\n\nCODE_BLOCK_122\n\n<!-- request PHP -->\n\nCODE_BLOCK_123\n\n<!-- response PHP -->\n\nCODE_BLOCK_124\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_125\n\n<!-- response Python -->\n\nCODE_BLOCK_126\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_127\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_128\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_129\n\n<!-- response javascript -->\n\nCODE_BLOCK_130\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_131\n\n<!-- response javascript -->\n\nCODE_BLOCK_132\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_133\n\n<!-- response Java -->\n\nCODE_BLOCK_134\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_135\n\n<!-- response C# -->\n\nCODE_BLOCK_136\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_137\n\n<!-- response Rust -->\n\nCODE_BLOCK_138\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_139\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_140\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_141\n\n<!-- response Go -->\n\nCODE_BLOCK_142\n\n<!-- end -->\n\n<!-- example call_pq_example -->\n\nAnd you execute `CALL PQ` on the distributed table with a couple of documents.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_143\n\n<!-- response sql -->\n\nCODE_BLOCK_144\n\n<!-- request JSON -->\n\nCODE_BLOCK_145\n\n<!-- response JSON -->\n\nCODE_BLOCK_146\n\n<!-- request PHP -->\n\nCODE_BLOCK_147\n\n<!-- response PHP -->\n\nCODE_BLOCK_148\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_149\n\n<!-- response Python -->\n\nCODE_BLOCK_150\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_151\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_152\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_153\n\n<!-- response javascript -->\n\nCODE_BLOCK_154\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_155\n\n<!-- response java -->\n\nCODE_BLOCK_156\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_157\n\n<!-- response C# -->\n\nCODE_BLOCK_158\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_159\n\n<!-- response Rust -->\n\nCODE_BLOCK_160\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_161\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_162\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_163\n\n<!-- response Go -->\n\nCODE_BLOCK_164\n\n<!-- end -->\n\nIn the previous example, we used the default **sparse** mode. To demonstrate the **sharded** mode, let's create a distributed PQ table consisting of 2 local PQ tables and add 2 documents to \"products1\" and 1 document to \"products2\":\n\nCODE_BLOCK_165\n\n<!-- example sharded -->\n\nNow, if you add `'sharded' as mode` to `CALL PQ`, it will send the documents to all the agent's tables (in this case, just local tables, but they can be remote to utilize external hardware). This mode is not available via the JSON interface.\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_166\n\n<!-- response SQL -->\n\nCODE_BLOCK_167\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_168\n\n<!-- response JSON -->\n\nCODE_BLOCK_169\n\n<!-- end -->",
      "russian": "<!-- request JSON -->\n\nCODE_BLOCK_112\n\n<!-- response JSON -->\n\nCODE_BLOCK_113\n\n<!-- end -->\n\n<!-- example invalid_json -->\n\n##### I may have invalid JSONs, please skip them\n\nWhen using CALL PQ with separate JSONs, you can use the option 1 as skip_bad_json to skip any invalid JSONs in the input. In the example below, the 2nd query fails due to an invalid JSON, but the 3rd query avoids the error by using 1 as skip_bad_json. Keep in mind that this option is not available when sending JSON queries over HTTP, as the whole JSON query must be valid in that case.\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_114\n\n<!-- response SQL -->\n\nCODE_BLOCK_115\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_116\n\n<!-- response JSON -->\n\nCODE_BLOCK_117\n\n<!-- end -->\n\n##### I want higher performance of a percolate query\n\nPercolate queries are designed with high throughput and large data volumes in mind. To optimize performance for lower latency and higher throughput, consider the following.\n\nThere are two modes of distribution for a percolate table and how a percolate query can work against it:\n\n* **Sparse (default).** Ideal for: many documents, mirrored PQ tables. When your document set is large but the set of queries stored in the PQ table is small, the sparse mode is beneficial. In this mode, the batch of documents you pass will be divided among the number of agents, so each node processes only a portion of the documents from your request. Manticore splits your document set and distributes chunks among the mirrors. Once the agents have finished processing the queries, Manticore collects and merges the results, returning a final query set as if it came from a single table. Use [replication](../References.md#Replication) to assist the process.\n\n* **Sharded.** Ideal for: many PQ rules, rules split among PQ tables. In this mode, the entire document set is broadcast to all tables of the distributed PQ table without initially splitting the documents. This is beneficial when pushing a relatively small set of documents, but the number of stored queries is large. In this case, it's more appropriate to store only a portion of PQ rules on each node and then merge the results returned from the nodes that process the same set of documents against different sets of PQ rules. This mode must be explicitly set, as it implies an increase in network payload and expects tables with different PQs, which [replication](../References.md#Replication) cannot do out-of-the-box.\n\nAssume you have table `pq_d2` defined as:\n\nCODE_BLOCK_118\n\n<!-- example distributed pq modes 1 -->\n\nEach of 'pq' and 'ptitle' contains:\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_119\n\n<!-- response sql -->\n\nCODE_BLOCK_120\n\n<!-- request JSON -->\n\nCODE_BLOCK_121\n\n<!-- response JSON -->\n\nCODE_BLOCK_122\n\n<!-- request PHP -->\n\nCODE_BLOCK_123\n\n<!-- response PHP -->\n\nCODE_BLOCK_124\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_125\n\n<!-- response Python -->\n\nCODE_BLOCK_126\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_127\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_128\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_129\n\n<!-- response javascript -->\n\nCODE_BLOCK_130\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_131\n\n<!-- response javascript -->\n\nCODE_BLOCK_132\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_133\n\n<!-- response Java -->\n\nCODE_BLOCK_134\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_135\n\n<!-- response C# -->\n\nCODE_BLOCK_136\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_137\n\n<!-- response Rust -->\n\nCODE_BLOCK_138\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_139\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_140\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_141\n\n<!-- response Go -->\n\nCODE_BLOCK_142\n\n<!-- end -->\n\n<!-- example call_pq_example -->\n\nAnd you execute `CALL PQ` on the distributed table with a couple of documents.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_143\n\n<!-- response sql -->\n\nCODE_BLOCK_144\n\n<!-- request JSON -->\n\nCODE_BLOCK_145\n\n<!-- response JSON -->\n\nCODE_BLOCK_146\n\n<!-- request PHP -->\n\nCODE_BLOCK_147\n\n<!-- response PHP -->\n\nCODE_BLOCK_148\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_149\n\n<!-- response Python -->\n\nCODE_BLOCK_150\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_151\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_152\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_153\n\n<!-- response javascript -->\n\nCODE_BLOCK_154\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_155\n\n<!-- response java -->\n\nCODE_BLOCK_156\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_157\n\n<!-- response C# -->\n\nCODE_BLOCK_158\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_159\n\n<!-- response Rust -->\n\nCODE_BLOCK_160\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_161\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_162\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_163\n\n<!-- response Go -->\n\nCODE_BLOCK_164\n\n<!-- end -->\n\nIn the previous example, we used the default **sparse** mode. To demonstrate the **sharded** mode, let's create a distributed PQ table consisting of 2 local PQ tables and add 2 documents to \"products1\" and 1 document to \"products2\":\n\nCODE_BLOCK_165\n\n<!-- example sharded -->\n\nNow, if you add `'sharded' as mode` to `CALL PQ`, it will send the documents to all the agent's tables (in this case, just local tables, but they can be remote to utilize external hardware). This mode is not available via the JSON interface.\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_166\n\n<!-- response SQL -->\n\nCODE_BLOCK_167\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_168\n\n<!-- response JSON -->\n\nCODE_BLOCK_169\n\n<!-- end -->"
    },
    "is_code_or_comment": true
  },
  "ba9e61fa0605ab5e6b847f20bdb92515c92424b11f2d03a3fc99ab62805bcfe9": {
    "original": "Note that the syntax of agent mirrors in the configuration (when several hosts are assigned to one `agent` line, separated with `|`) has nothing to do with the `CALL PQ` query mode. Each `agent` always represents **one** node, regardless of the number of HA mirrors specified for that agent.\n\n<!-- example verbose -->\n\n##### How can I learn more about performance?\n\nIn some cases, you might want to get more details about the performance of a percolate query. For that purpose, there is the option `1 as verbose`, which is only available via SQL and allows you to save more performance metrics. You can see them using the `SHOW META` query, which you can run after `CALL PQ`. See [SHOW META](../Node_info_and_management/SHOW_META.md) for more info.\n\n<!-- intro -->\n\n1 as verbose:\n\n<!-- request 1 as verbose -->\n\nCODE_BLOCK_170\n\n<!-- response 1 as verbose -->\n\nCODE_BLOCK_171\n\n<!-- intro -->\n\n0 as verbose (default):\n\n<!-- request 0 as verbose -->\n\nCODE_BLOCK_172\n\n<!-- response 0 as verbose -->\n\nCODE_BLOCK_173\n\n<!-- end -->\n\n<!-- proofread -->",
    "translations": {
      "chinese": "注意，配置中 agent 镜像的语法（当多个主机指定给一个以 `agent` 开头的行，并用 `|` 分隔时）与 `CALL PQ` 查询模式无关。每个 `agent` 始终代表**一个**节点，无论该 agent 指定了多少个 HA 镜像。\n\n<!-- example verbose -->\n\n##### 如何了解更多关于性能的信息？\n\n在某些情况下，你可能希望获取关于 percolate 查询性能的更多详细信息。为此，有一个选项 `1 as verbose`，该选项仅通过 SQL 提供，允许你保存更多的性能指标。你可以使用 `SHOW META` 查询查看这些指标，该查询可在 `CALL PQ` 之后运行。有关更多信息，请参见 [SHOW META](../Node_info_and_management/SHOW_META.md)。\n\n<!-- intro -->\n\n1 as verbose:\n\n<!-- request 1 as verbose -->\n\nCODE_BLOCK_170\n\n<!-- response 1 as verbose -->\n\nCODE_BLOCK_171\n\n<!-- intro -->\n\n0 as verbose (默认):\n\n<!-- request 0 as verbose -->\n\nCODE_BLOCK_172\n\n<!-- response 0 as verbose -->\n\nCODE_BLOCK_173\n\n<!-- end -->\n\n<!-- proofread -->",
      "russian": "Обратите внимание, что синтаксис зеркал агентов в конфигурации (когда несколько хостов назначены одной строке `agent`, разделённой с помощью `|`) не имеет отношения к режиму запроса `CALL PQ`. Каждый `agent` всегда представляет **один** узел, независимо от количества HA-зеркал, указанных для этого агента.\n\n<!-- example verbose -->\n\n##### Как можно узнать больше о производительности?\n\nВ некоторых случаях вы можете захотеть получить больше информации о производительности перколяционного запроса. Для этой цели существует опция `1 as verbose`, доступная только через SQL и позволяющая сохранять больше метрик производительности. Вы можете просмотреть их с помощью запроса `SHOW META`, который можно выполнить после `CALL PQ`. Подробнее см. в [SHOW META](../Node_info_and_management/SHOW_META.md).\n\n<!-- intro -->\n\n1 as verbose:\n\n<!-- request 1 as verbose -->\n\nCODE_BLOCK_170\n\n<!-- response 1 as verbose -->\n\nCODE_BLOCK_171\n\n<!-- intro -->\n\n0 as verbose (по умолчанию):\n\n<!-- request 0 as verbose -->\n\nCODE_BLOCK_172\n\n<!-- response 0 as verbose -->\n\nCODE_BLOCK_173\n\n<!-- end -->\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "f3b2382e49cd18c5cd64f73a4515b9aa2d26b31b6b28462443c102bbd6d91026": {
    "original": "SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_22\n\n<!-- response SQL -->\n\nCODE_BLOCK_23\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_24\n\n<!-- response JSON -->\n\nCODE_BLOCK_25\n\n<!-- intro -->\n\nPHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_26\n\n<!-- response PHP -->\n\nCODE_BLOCK_27\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_28\n\n<!-- response Python -->\n\nCODE_BLOCK_29\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_30\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_31\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_32\n\n<!-- response javascript -->\n\nCODE_BLOCK_33\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_34\n\n<!-- response Javs -->\n\nCODE_BLOCK_35\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_36\n\n<!-- response C# -->\n\nCODE_BLOCK_37\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_38\n\n<!-- response Rust -->\n\nCODE_BLOCK_39\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_40\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_41\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_42\n\n<!-- response Go -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n<!-- example pq_rules -->\n\n##### I want to know complete PQ rules matching my document\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_44\n\n<!-- response SQL -->\n\nCODE_BLOCK_45\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_46\n\n<!-- response JSON -->\n\nCODE_BLOCK_47\n\n<!-- intro -->\n\nPHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_48\n\n<!-- response PHP -->\n\nCODE_BLOCK_49\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_50\n\n<!-- response Python -->\n\nCODE_BLOCK_51\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_52\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_53\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_54\n\n<!-- response javascript -->\n\nCODE_BLOCK_55\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_56\n\n<!-- response Java -->\n\nCODE_BLOCK_57\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_58\n\n<!-- response C# -->\n\nCODE_BLOCK_59\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_60\n\n<!-- response Rust -->\n\nCODE_BLOCK_61\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_62\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_63\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_64\n\n<!-- response Go -->\n\nCODE_BLOCK_65\n\n<!-- end -->\n\n<!-- example multiple -->\n\n##### How about multiple documents?\n\nNote that with `CALL PQ`, you can provide multiple documents in different ways:\n\n* as an array of plain documents in round brackets `('doc1', 'doc2')`. This requires `0 as docs_json`\n\n* as an array of JSONs in round brackets `('{doc1}', '{doc2}')`\n\n* or as a standard JSON array `'[{doc1}, {doc2}]'`\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_66\n\n<!-- response SQL -->\n\nCODE_BLOCK_67\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_68\n\n<!-- response JSON -->\n\nCODE_BLOCK_69\n\n<!-- intro -->\n\nPHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_70\n\n<!-- response PHP -->\n\nCODE_BLOCK_71\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_72\n\n<!-- response Python -->\n\nCODE_BLOCK_73\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_74\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_75\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_76\n\n<!-- response javascript -->\n\nCODE_BLOCK_77\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_78\n\n<!-- response Java -->\n\nCODE_BLOCK_79\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_80\n\n<!-- response C# -->\n\nCODE_BLOCK_81\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_82\n\n<!-- response Rust -->\n\nCODE_BLOCK_83\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_84\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_85\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_86\n\n<!-- response Go -->\n\nCODE_BLOCK_87\n\n<!-- end -->\n\n<!-- example docs_1 -->\n\n##### I want to know what docs match what rules\n\nUsing the option `1 as docs` allows you to see which documents of the provided ones match which rules.\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_88\n\n<!-- response SQL -->\n\nCODE_BLOCK_89\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_90\n\n<!-- response JSON -->\n\nCODE_BLOCK_91\n\n<!-- intro -->\n\nPHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_92\n\n<!-- response PHP -->\n\nCODE_BLOCK_93\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_94\n\n<!-- response Python -->\n\nCODE_BLOCK_95\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_96\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_97\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_98\n\n<!-- response javascript -->\n\nCODE_BLOCK_99\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_100\n\n<!-- response Java -->\n\nCODE_BLOCK_101\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_102\n\n<!-- response C# -->\n\nCODE_BLOCK_103\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_104\n\n<!-- response Rust -->\n\nCODE_BLOCK_105\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_106\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_107\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_108\n\n<!-- response Go -->\n\nCODE_BLOCK_109\n\n<!-- end -->\n\n<!-- example docs_id -->\n\n#### Static ids\n\nBy default, matching document ids correspond to their relative numbers in the list you provide. However, in some cases, each document already has its own id. For this case, there's an option `'id field name' as docs_id` for `CALL PQ`.\n\nNote that if the id cannot be found by the provided field name, the PQ rule will not be shown in the results.\n\nThis option is only available for `CALL PQ` via SQL.\n\n<!--\n\ndata for the following examples:\n\nDROP TABLE IF EXISTS products;\n\nCREATE TABLE products(title text, color string) type='pq';\n\nINSERT INTO products(query, filters) VALUES ('@title shoes', 'color IN (\"blue\", \"green\")');\n\nINSERT INTO products(query, tags) VALUES ('@title bag', 'Louis Vuitton');\n\n-->\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_110\n\n<!-- response SQL -->\n\nCODE_BLOCK_111\n\n<!-- intro -->\n\n##### JSON:",
    "translations": {
      "chinese": "SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_22\n\n<!-- response SQL -->\n\nCODE_BLOCK_23\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_24\n\n<!-- response JSON -->\n\nCODE_BLOCK_25\n\n<!-- intro -->\n\nPHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_26\n\n<!-- response PHP -->\n\nCODE_BLOCK_27\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_28\n\n<!-- response Python -->\n\nCODE_BLOCK_29\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_30\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_31\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_32\n\n<!-- response javascript -->\n\nCODE_BLOCK_33\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_34\n\n<!-- response Javs -->\n\nCODE_BLOCK_35\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_36\n\n<!-- response C# -->\n\nCODE_BLOCK_37\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_38\n\n<!-- response Rust -->\n\nCODE_BLOCK_39\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_40\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_41\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_42\n\n<!-- response Go -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n<!-- example pq_rules -->\n\n##### 我想知道我的文档完全匹配了哪些 PQ 规则\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_44\n\n<!-- response SQL -->\n\nCODE_BLOCK_45\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_46\n\n<!-- response JSON -->\n\nCODE_BLOCK_47\n\n<!-- intro -->\n\nPHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_48\n\n<!-- response PHP -->\n\nCODE_BLOCK_49\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_50\n\n<!-- response Python -->\n\nCODE_BLOCK_51\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_52\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_53\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_54\n\n<!-- response javascript -->\n\nCODE_BLOCK_55\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_56\n\n<!-- response Java -->\n\nCODE_BLOCK_57\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_58\n\n<!-- response C# -->\n\nCODE_BLOCK_59\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_60\n\n<!-- response Rust -->\n\nCODE_BLOCK_61\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_62\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_63\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_64\n\n<!-- response Go -->\n\nCODE_BLOCK_65\n\n<!-- end -->\n\n<!-- example multiple -->\n\n##### 多个文档呢？\n\n请注意，使用 `CALL PQ`，您可以通过不同方式提供多个文档：\n\n* 作为圆括号中的普通文档数组 `('doc1', 'doc2')`。这需要 `0 as docs_json`\n\n* 作为圆括号中的 JSON 数组 `('{doc1}', '{doc2}')`\n\n* 或者作为标准的 JSON 数组 `'[{doc1}, {doc2}]'`\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_66\n\n<!-- response SQL -->\n\nCODE_BLOCK_67\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_68\n\n<!-- response JSON -->\n\nCODE_BLOCK_69\n\n<!-- intro -->\n\nPHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_70\n\n<!-- response PHP -->\n\nCODE_BLOCK_71\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_72\n\n<!-- response Python -->\n\nCODE_BLOCK_73\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_74\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_75\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_76\n\n<!-- response javascript -->\n\nCODE_BLOCK_77\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_78\n\n<!-- response Java -->\n\nCODE_BLOCK_79\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_80\n\n<!-- response C# -->\n\nCODE_BLOCK_81\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_82\n\n<!-- response Rust -->\n\nCODE_BLOCK_83\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_84\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_85\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_86\n\n<!-- response Go -->\n\nCODE_BLOCK_87\n\n<!-- end -->\n\n<!-- example docs_1 -->\n\n##### 我想知道哪些文档匹配了哪些规则\n\n使用选项 `1 as docs` 可以让您查看所提供的哪些文档匹配了哪些规则。\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_88\n\n<!-- response SQL -->\n\nCODE_BLOCK_89\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_90\n\n<!-- response JSON -->\n\nCODE_BLOCK_91\n\n<!-- intro -->\n\nPHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_92\n\n<!-- response PHP -->\n\nCODE_BLOCK_93\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_94\n\n<!-- response Python -->\n\nCODE_BLOCK_95\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_96\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_97\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_98\n\n<!-- response javascript -->\n\nCODE_BLOCK_99\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_100\n\n<!-- response Java -->\n\nCODE_BLOCK_101\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_102\n\n<!-- response C# -->\n\nCODE_BLOCK_103\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_104\n\n<!-- response Rust -->\n\nCODE_BLOCK_105\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_106\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_107\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_108\n\n<!-- response Go -->\n\nCODE_BLOCK_109\n\n<!-- end -->\n\n<!-- example docs_id -->\n\n#### 静态 id\n\n默认情况下，匹配的文档 id 对应于您提供列表中的相对编号。但在某些情况下，每个文档已经有自己的 id。对于这种情况，`CALL PQ` 有一个选项 `'id field name' as docs_id`。\n\n请注意，如果无法通过提供的字段名称找到 id，则 PQ 规则不会显示在结果中。\n\n该选项仅适用于通过 SQL 使用 `CALL PQ`。\n\n<!--\n\ndata for the following examples:\n\nDROP TABLE IF EXISTS products;\n\nCREATE TABLE products(title text, color string) type='pq';\n\nINSERT INTO products(query, filters) VALUES ('@title shoes', 'color IN (\"blue\", \"green\")');\n\nINSERT INTO products(query, tags) VALUES ('@title bag', 'Louis Vuitton');\n\n-->\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_110\n\n<!-- response SQL -->\n\nCODE_BLOCK_111\n\n<!-- intro -->\n\n##### JSON:",
      "russian": "SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_22\n\n<!-- response SQL -->\n\nCODE_BLOCK_23\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_24\n\n<!-- response JSON -->\n\nCODE_BLOCK_25\n\n<!-- intro -->\n\nPHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_26\n\n<!-- response PHP -->\n\nCODE_BLOCK_27\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_28\n\n<!-- response Python -->\n\nCODE_BLOCK_29\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_30\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_31\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_32\n\n<!-- response javascript -->\n\nCODE_BLOCK_33\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_34\n\n<!-- response Javs -->\n\nCODE_BLOCK_35\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_36\n\n<!-- response C# -->\n\nCODE_BLOCK_37\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_38\n\n<!-- response Rust -->\n\nCODE_BLOCK_39\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_40\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_41\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_42\n\n<!-- response Go -->\n\nCODE_BLOCK_43\n\n<!-- end -->\n\n<!-- example pq_rules -->\n\n##### Я хочу узнать полные правила PQ, соответствующие моему документу\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_44\n\n<!-- response SQL -->\n\nCODE_BLOCK_45\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_46\n\n<!-- response JSON -->\n\nCODE_BLOCK_47\n\n<!-- intro -->\n\nPHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_48\n\n<!-- response PHP -->\n\nCODE_BLOCK_49\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_50\n\n<!-- response Python -->\n\nCODE_BLOCK_51\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_52\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_53\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_54\n\n<!-- response javascript -->\n\nCODE_BLOCK_55\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_56\n\n<!-- response Java -->\n\nCODE_BLOCK_57\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_58\n\n<!-- response C# -->\n\nCODE_BLOCK_59\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_60\n\n<!-- response Rust -->\n\nCODE_BLOCK_61\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_62\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_63\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_64\n\n<!-- response Go -->\n\nCODE_BLOCK_65\n\n<!-- end -->\n\n<!-- example multiple -->\n\n##### Как насчёт нескольких документов?\n\nОбратите внимание, что с помощью `CALL PQ` вы можете передавать несколько документов разными способами:\n\n* в виде массива простых документов в круглых скобках `('doc1', 'doc2')`. Для этого требуется `0 as docs_json`\n\n* в виде массива JSON в круглых скобках `('{doc1}', '{doc2}')`\n\n* или в виде стандартного JSON-массива `'[{doc1}, {doc2}]'`\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_66\n\n<!-- response SQL -->\n\nCODE_BLOCK_67\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_68\n\n<!-- response JSON -->\n\nCODE_BLOCK_69\n\n<!-- intro -->\n\nPHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_70\n\n<!-- response PHP -->\n\nCODE_BLOCK_71\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_72\n\n<!-- response Python -->\n\nCODE_BLOCK_73\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_74\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_75\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_76\n\n<!-- response javascript -->\n\nCODE_BLOCK_77\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_78\n\n<!-- response Java -->\n\nCODE_BLOCK_79\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_80\n\n<!-- response C# -->\n\nCODE_BLOCK_81\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_82\n\n<!-- response Rust -->\n\nCODE_BLOCK_83\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_84\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_85\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_86\n\n<!-- response Go -->\n\nCODE_BLOCK_87\n\n<!-- end -->\n\n<!-- example docs_1 -->\n\n##### Я хочу узнать, какие документы соответствуют каким правилам\n\nИспользование опции `1 as docs` позволяет увидеть, какие из предоставленных документов соответствуют каким правилам.\n\n<!-- intro -->\n\nSQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_88\n\n<!-- response SQL -->\n\nCODE_BLOCK_89\n\n<!-- intro -->\n\nJSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_90\n\n<!-- response JSON -->\n\nCODE_BLOCK_91\n\n<!-- intro -->\n\nPHP:\n\n<!-- request PHP -->\n\nCODE_BLOCK_92\n\n<!-- response PHP -->\n\nCODE_BLOCK_93\n\n<!-- intro -->\n\nPython\n\n<!-- request Python -->\n\nCODE_BLOCK_94\n\n<!-- response Python -->\n\nCODE_BLOCK_95\n\n<!-- intro -->\n\nPython-asyncio\n\n<!-- request Python-asyncio -->\n\nCODE_BLOCK_96\n\n<!-- response Python-asyncio -->\n\nCODE_BLOCK_97\n\n<!-- intro -->\n\njavascript\n\n<!-- request javascript -->\n\nCODE_BLOCK_98\n\n<!-- response javascript -->\n\nCODE_BLOCK_99\n\n<!-- intro -->\n\njava\n\n<!-- request Java -->\n\nCODE_BLOCK_100\n\n<!-- response Java -->\n\nCODE_BLOCK_101\n\n<!-- intro -->\n\nC#\n\n<!-- request C# -->\n\nCODE_BLOCK_102\n\n<!-- response C# -->\n\nCODE_BLOCK_103\n\n<!-- intro -->\n\nRust\n\n<!-- request Rust -->\n\nCODE_BLOCK_104\n\n<!-- response Rust -->\n\nCODE_BLOCK_105\n\n<!-- intro -->\n\nTypeScript\n\n<!-- request TypeScript -->\n\nCODE_BLOCK_106\n\n<!-- response TypeScript -->\n\nCODE_BLOCK_107\n\n<!-- intro -->\n\nGo\n\n<!-- request Go -->\n\nCODE_BLOCK_108\n\n<!-- response Go -->\n\nCODE_BLOCK_109\n\n<!-- end -->\n\n<!-- example docs_id -->\n\n#### Статические идентификаторы\n\nПо умолчанию идентификаторы совпадающих документов соответствуют их относительным номерам в списке, который вы предоставляете. Однако в некоторых случаях у каждого документа уже есть свой собственный идентификатор. Для этого случая есть опция `'id field name' as docs_id` для `CALL PQ`.\n\nОбратите внимание, что если идентификатор не будет найден по предоставленному имени поля, правило PQ не будет показано в результатах.\n\nЭта опция доступна только для `CALL PQ` через SQL.\n\n<!--\n\ndata for the following examples:\n\nDROP TABLE IF EXISTS products;\n\nCREATE TABLE products(title text, color string) type='pq';\n\nINSERT INTO products(query, filters) VALUES ('@title shoes', 'color IN (\"blue\", \"green\")');\n\nINSERT INTO products(query, tags) VALUES ('@title bag', 'Louis Vuitton');\n\n-->\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_110\n\n<!-- response SQL -->\n\nCODE_BLOCK_111\n\n<!-- intro -->\n\n##### JSON:"
    },
    "is_code_or_comment": false
  }
}
