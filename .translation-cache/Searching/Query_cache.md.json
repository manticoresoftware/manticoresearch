{
  "c70f30799df95a140d94647024e96657941e3d0a9e2f0f7ca033b9b962789fae": {
    "original": "# Query cache\n\nQuery cache stores compressed result sets in memory and reuses them for subsequent queries when possible. You can configure it using the following directives:\n\n* [qcache_max_bytes](../Server_settings/Searchd.md#qcache_max_bytes), a limit on the RAM usage for cached query storage. Defaults to 16 MB. Setting `qcache_max_bytes` to 0 completely disables the query cache.\n\n* [qcache_thresh_msec](../Server_settings/Searchd.md#qcache_thresh_msec), the minimum wall query time to cache. Queries that complete faster than this will *not* be cached. Defaults to 3000 msec, or 3 seconds.\n\n* [qcache_ttl_sec](../Server_settings/Searchd.md#qcache_ttl_sec), cached entry TTL, or time to live. Queries will stay cached for this duration. Defaults to 60 seconds, or 1 minute.\n\nThese settings can be changed on the fly using the `SET GLOBAL` statement:\n\nCODE_BLOCK_0\n\nThese changes are applied immediately, and cached result sets that no longer satisfy the constraints are immediately discarded. When reducing the cache size on the fly, MRU (most recently used) result sets win.\n\nQuery cache operates as follows. When enabled, every full-text search result is completely stored in memory. This occurs after full-text matching, filtering, and ranking, so essentially we store `total_found` {docid,weight} pairs. Compressed matches can consume anywhere from 2 bytes to 12 bytes per match on average, mostly depending on the deltas between subsequent docids. Once the query is complete, we check the wall time and size thresholds, and either save the compressed result set for reuse or discard it.\n\nNote that the query cache's impact on RAM is not limited by`qcache_max_bytes`! If you run, for example, 10 concurrent queries, each matching up to 1M matches (after filters), then the peak temporary RAM usage will be in the range of 40 MB to 240 MB, even if the queries are fast enough and don't get cached.\n\nQueries can use cache when the table, full-text query (i.e.,`MATCH()` contents), and ranker all match, and filters are compatible. This means:\n\n*   The full-text part within `MATCH()` must be a bytewise match. Add a single extra space, and it's now a different query as far as the query cache is concerned.\n\n*   The ranker (and its parameters, if any, for user-defined rankers) must be a bytewise match.\n\n*   The filters must be a superset of the original filters. You can add extra filters and still hit the cache. (In this case, the extra filters will be applied to the cached result.) But if you remove one, that will be a new query again.\n\nCache entries expire with TTL and also get invalidated on table rotation, or on  `TRUNCATE`, or on `ATTACH`.  Note that currently, entries are not invalidated on arbitrary RT table writes! So a cached query might return older results for the duration of its TTL.\n\nYou can inspect the current cache status with [SHOW STATUS](../Node_info_and_management/Node_status.md#SHOW-STATUS) through the `qcache_XXX` variables:\n\nCODE_BLOCK_1\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 查询缓存\n\n查询缓存将压缩的结果集存储在内存中，并在可能的情况下重用它们以响应后续查询。您可以使用以下指令进行配置：\n\n* [qcache_max_bytes](../Server_settings/Searchd.md#qcache_max_bytes)，缓存查询存储的 RAM 使用限制。默认值为 16 MB。将 `qcache_max_bytes` 设置为 0 会完全禁用查询缓存。\n\n* [qcache_thresh_msec](../Server_settings/Searchd.md#qcache_thresh_msec)，缓存的最小查询耗时。完成时间快于此值的查询将*不会*被缓存。默认值为 3000 毫秒，即 3 秒。\n\n* [qcache_ttl_sec](../Server_settings/Searchd.md#qcache_ttl_sec)，缓存条目的 TTL（存活时间）。查询结果将缓存此时长。默认值为 60 秒，即 1 分钟。\n\n这些设置可以通过 `SET GLOBAL` 语句动态更改：\n\nCODE_BLOCK_0\n\n这些更改会立即生效，不再满足约束条件的缓存结果集会立即被丢弃。在动态减少缓存大小时，最近最常使用（MRU）的结果集优先保留。\n\n查询缓存的工作原理如下。启用时，每个全文搜索结果都会完整存储在内存中。这发生在全文匹配、过滤和排序之后，基本上我们存储了 `total_found` 个 {docid,weight} 对。压缩后的匹配项平均每个占用 2 到 12 字节，主要取决于相邻 docid 之间的差值。查询完成后，我们检查耗时和大小阈值，决定是保存压缩结果集以供重用，还是丢弃它。\n\n请注意，查询缓存对 RAM 的影响不限于 `qcache_max_bytes`！例如，如果您同时运行 10 个并发查询，每个查询匹配最多 100 万条结果（过滤后），即使查询足够快且未被缓存，峰值临时 RAM 使用量也会在 40 MB 到 240 MB 之间。\n\n当表、全文查询（即 `MATCH()` 内容）和排序器完全匹配且过滤条件兼容时，查询可以使用缓存。这意味着：\n\n*   `MATCH()` 中的全文部分必须逐字节匹配。添加一个额外空格，查询缓存就会认为这是一个不同的查询。\n\n*   排序器（及其参数，如果是用户定义的排序器）必须逐字节匹配。\n\n*   过滤条件必须是原始过滤条件的超集。您可以添加额外的过滤条件仍然命中缓存。（在这种情况下，额外的过滤条件会应用于缓存结果。）但如果移除其中一个过滤条件，则会被视为新查询。\n\n缓存条目会根据 TTL 过期，并且在表轮换、`TRUNCATE` 或 `ATTACH` 时失效。请注意，目前条目不会因任意 RT 表写入而失效！因此，缓存查询可能在其 TTL 期间返回较旧的结果。\n\n您可以通过 [SHOW STATUS](../Node_info_and_management/Node_status.md#SHOW-STATUS) 查看当前缓存状态，相关变量以 `qcache_XXX` 命名：\n\nCODE_BLOCK_1\n\n<!-- proofread -->",
      "russian": "# Кэш запросов\n\nКэш запросов хранит сжатые наборы результатов в памяти и повторно использует их для последующих запросов, когда это возможно. Вы можете настроить его с помощью следующих директив:\n\n* [qcache_max_bytes](../Server_settings/Searchd.md#qcache_max_bytes) — ограничение на использование ОЗУ для хранения кэшированных запросов. По умолчанию 16 МБ. Установка `qcache_max_bytes` в 0 полностью отключает кэш запросов.\n\n* [qcache_thresh_msec](../Server_settings/Searchd.md#qcache_thresh_msec) — минимальное время выполнения запроса (в миллисекундах) для кэширования. Запросы, которые выполняются быстрее этого времени, *не* будут кэшироваться. По умолчанию 3000 мс, или 3 секунды.\n\n* [qcache_ttl_sec](../Server_settings/Searchd.md#qcache_ttl_sec) — время жизни кэшированной записи. Запросы будут храниться в кэше в течение этого времени. По умолчанию 60 секунд, или 1 минута.\n\nЭти настройки можно изменять на лету с помощью оператора `SET GLOBAL`:\n\nCODE_BLOCK_0\n\nЭти изменения применяются немедленно, и кэшированные наборы результатов, которые больше не соответствуют ограничениям, сразу же удаляются. При уменьшении размера кэша на лету выигрывают наиболее недавно использованные (MRU) наборы результатов.\n\nКэш запросов работает следующим образом. Когда он включен, каждый результат полнотекстового поиска полностью сохраняется в памяти. Это происходит после полнотекстового сопоставления, фильтрации и ранжирования, то есть по сути мы сохраняем пары {docid,weight} для `total_found`. Сжатые совпадения могут занимать в среднем от 2 до 12 байт на совпадение, в основном в зависимости от дельт между последовательными docid. После завершения запроса мы проверяем пороги времени выполнения и размера, и либо сохраняем сжатый набор результатов для повторного использования, либо отбрасываем его.\n\nОбратите внимание, что влияние кэша запросов на ОЗУ не ограничивается `qcache_max_bytes`! Если, например, выполняется 10 параллельных запросов, каждый из которых совпадает с до 1 млн совпадений (после фильтров), то пиковое временное использование ОЗУ будет в диапазоне от 40 МБ до 240 МБ, даже если запросы достаточно быстрые и не кэшируются.\n\nЗапросы могут использовать кэш, когда совпадают таблица, полнотекстовый запрос (то есть содержимое `MATCH()`) и ранжировщик, а фильтры совместимы. Это означает:\n\n*   Полнотекстовая часть внутри `MATCH()` должна совпадать посимвольно. Добавьте один дополнительный пробел — и для кэша запросов это уже другой запрос.\n\n*   Ранжировщик (и его параметры, если есть, для пользовательских ранжировщиков) должен совпадать посимвольно.\n\n*   Фильтры должны быть надмножеством исходных фильтров. Вы можете добавить дополнительные фильтры и всё равно попасть в кэш. (В этом случае дополнительные фильтры будут применены к кэшированному результату.) Но если вы уберёте какой-то фильтр, это будет уже новый запрос.\n\nЗаписи кэша истекают по TTL и также инвалидируются при ротации таблицы, или при выполнении `TRUNCATE`, или `ATTACH`. Обратите внимание, что в настоящее время записи не инвалидируются при произвольных записях в RT-таблицы! Поэтому кэшированный запрос может возвращать устаревшие результаты в течение времени жизни TTL.\n\nВы можете просмотреть текущий статус кэша с помощью [SHOW STATUS](../Node_info_and_management/Node_status.md#SHOW-STATUS) через переменные `qcache_XXX`:\n\nCODE_BLOCK_1\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
