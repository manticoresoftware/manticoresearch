{
  "ddaed2dfdfc7661031b19f72cd02f7f3c6dabfbd4675ddf197d5b38d045f334a": {
    "original": "# Spell correction\n\nSpell correction, also known as:\n\n* Auto correction\n\n* Text correction\n\n* Fixing spelling errors\n\n* Typo tolerance\n\n* \"Did you mean?\"\n\nand so on, is a software functionality that suggests alternatives to or makes automatic corrections of the text you have typed in. The concept of correcting typed text dates back to the 1960s when computer scientist Warren Teitelman, who also invented the \"undo\" command, introduced a philosophy of computing called D.W.I.M., or \"Do What I Mean.\" Instead of programming computers to accept only perfectly formatted instructions, Teitelman argued that they should be programmed to recognize obvious mistakes.\n\nThe first well-known product to provide spell correction functionality was Microsoft Word 6.0, released in 1993.\n\n### How it works\n\nThere are a few ways spell correction can be done, but it's important to note that there is no purely programmatic way to convert your mistyped \"ipone\" into \"iphone\" with decent quality. Mostly, there has to be a dataset the system is based on. The dataset can be:\n\n* A dictionary of properly spelled words, which in turn can be:\n\n  * Based on your real data. The idea here is that, for the most part, the spelling in the dictionary made up of your data is correct, and the system tries to find a word that is most similar to the typed word (we'll discuss how this can be done with Manticore shortly).\n\n  * Or it can be based on an external dictionary unrelated to your data. The issue that may arise here is that your data and the external dictionary can be too different: some words may be missing in the dictionary, while others may be missing in your data.\n\n* Not just dictionary-based, but also context-aware, e.g., \"white ber\" would be corrected to \"white bear,\" while \"dark ber\" would be corrected to \"dark beer.\" The context might not just be a neighboring word in your query, but also your location, time of day, the current sentence's grammar (to change \"there\" to \"their\" or not), your search history, and virtually any other factors that can affect your intent.\n\n* Another classic approach is to use previous search queries as the dataset for spell correction. This is even more utilized in [autocomplete](../Searching/Autocomplete.md) functionality but makes sense for autocorrect too. The idea is that users are mostly right with spelling, so we can use words from their search history as a source of truth, even if we don't have the words in our documents or use an external dictionary. Context-awareness is also possible here.\n\nManticore provides the fuzzy search option and the commands `CALL QSUGGEST` and `CALL SUGGEST` that can be used for automatic spell correction purposes.\n\n## Fuzzy Search\n\nThe Fuzzy Search feature allows for more flexible matching by accounting for slight variations or misspellings in the search query. It works similarly to a normal `SELECT` SQL statement or a `/search` JSON request but provides additional parameters to control the fuzzy matching behavior.\n\n> NOTE: The `fuzzy` option requires [Manticore Buddy](../Installation/Manticore_Buddy.md). If it doesn't work, make sure Buddy is installed.\n\n> NOTE: The `fuzzy` option is not available for [multi-queries](../Searching/Multi-queries.md).\n\n## General syntax\n\n### SQL\n\n<!-- example Fuzzy_Search_SQL -->\n\nCODE_BLOCK_0\n\nNote: When conducting a fuzzy search via SQL, the MATCH clause should not contain any full-text operators except the [phrase search operator](../Searching/Full_text_matching/Operators.md#Phrase-search-operator) and should only include the words you intend to match.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- request SQL with additional filters -->\n\nExample of a more complex Fuzzy search query with additional filters:\n\nCODE_BLOCK_2\n\n<!-- request JSON -->\n\nCODE_BLOCK_3\n\n<!-- response SQL -->\n\nCODE_BLOCK_4\n\n<!-- request SQL with preserve option -->\n\nCODE_BLOCK_5\n\n<!-- request JSON with preserve option -->\n\nCODE_BLOCK_6\n\n<!-- response SQL with preserve option -->\n\nCODE_BLOCK_7\n\n<!-- end -->\n\n### JSON\n\nCODE_BLOCK_8\n\nNote: If you use the [query_string](../Searching/Full_text_matching/Basic_usage.md#query_string), be aware that it does not support full-text operators except the [phrase search operator](../Searching/Full_text_matching/Operators.md#Phrase-search-operator). The query string should consist solely of the words you wish to match.\n\n### Options\n\n- `fuzzy`: Turn fuzzy search on or off.\n\n- `distance`: Set the Levenshtein distance for matching. The default is `2`.\n\n- `preserve`: `0` or `1` (default: `0`). When set to `1`, keeps words that don't have fuzzy matches in the search results (e.g., \"hello wrld\" returns both \"hello wrld\" and \"hello world\"). When set to `0`, only returns words with successful fuzzy matches (e.g., \"hello wrld\" returns only \"hello world\"). Particularly useful for preserving short words or proper nouns that may not exist in Manticore Search.\n\n- `layouts`: Keyboard layouts for detecting typing errors caused by keyboard layout mismatches (e.g., typing \"ghbdtn\" instead of \"привет\" when using wrong layout). Manticore compares character positions across different layouts to suggest corrections. Requires at least 2 layouts to effectively detect mismatches. No layouts are used by default. Use an empty string `''` (SQL) or array `[]` (JSON) to turn this off. Supported layouts include:\n\n  - `be` - Belgian AZERTY layout\n\n  - `bg` - Standard Bulgarian layout\n\n  - `br` - Brazilian QWERTY layout\n\n  - `ch` - Swiss QWERTZ layout\n\n  - `de` - German QWERTZ layout\n\n  - `dk` - Danish QWERTY layout\n\n  - `es` - Spanish QWERTY layout\n\n  - `fr` - French AZERTY layout\n\n  - `uk` - British QWERTY layout\n\n  - `gr` - Greek QWERTY layout\n\n  - `it` - Italian QWERTY layout\n\n  - `no` - Norwegian QWERTY layout\n\n  - `pt` - Portuguese QWERTY layout\n\n  - `ru` - Russian JCUKEN layout\n\n  - `se` - Swedish QWERTY layout\n\n  - `ua` - Ukrainian JCUKEN layout\n\n  - `us` - American QWERTY layout\n\n### Links",
    "translations": {
      "chinese": "# 拼写纠正\n\n拼写纠正，也称为：\n\n* 自动纠正\n\n* 文本纠正\n\n* 修正拼写错误\n\n* 容错拼写\n\n* “你的意思是？”\n\n等等，是一种软件功能，用于建议替代词或自动纠正您输入的文本。纠正输入文本的概念可以追溯到20世纪60年代，当时计算机科学家Warren Teitelman（他还发明了“撤销”命令）提出了一种称为D.W.I.M.（“做我意思的事”）的计算哲学。Teitelman认为，计算机不应只接受格式完全正确的指令，而应被编程为识别明显的错误。\n\n第一个提供拼写纠正功能的知名产品是1993年发布的Microsoft Word 6.0。\n\n### 工作原理\n\n拼写纠正可以通过几种方式实现，但重要的是要注意，没有纯粹的程序化方法能以较高质量将您错误输入的“ipone”转换为“iphone”。大多数情况下，系统必须基于某个数据集。该数据集可以是：\n\n* 一个正确拼写单词的词典，词典又可以是：\n\n  * 基于您的真实数据。这里的想法是，词典中由您的数据组成的拼写大部分是正确的，系统尝试找到与输入单词最相似的单词（我们稍后将讨论如何用Manticore实现）。\n\n  * 或者基于与您的数据无关的外部词典。这里可能出现的问题是您的数据和外部词典差异过大：词典中可能缺少某些单词，而您的数据中可能缺少其他单词。\n\n* 不仅基于词典，还基于上下文，例如，“white ber”会被纠正为“white bear”，而“dark ber”会被纠正为“dark beer”。上下文不仅可能是查询中的相邻单词，还可能是您的位置、时间、当前句子的语法（是否将“there”改为“their”）、您的搜索历史，以及几乎任何可能影响您意图的因素。\n\n* 另一种经典方法是使用之前的搜索查询作为拼写纠正的数据集。这在[自动补全](../Searching/Autocomplete.md)功能中使用得更多，但对自动纠正也有意义。其思想是用户大多数拼写是正确的，因此我们可以使用他们的搜索历史中的单词作为事实来源，即使我们在文档中没有这些单词或不使用外部词典。这里也可以实现上下文感知。\n\nManticore提供了模糊搜索选项以及可用于自动拼写纠正的命令`CALL QSUGGEST`和`CALL SUGGEST`。\n\n## 模糊搜索\n\n模糊搜索功能允许通过考虑搜索查询中的轻微变体或拼写错误，实现更灵活的匹配。它的工作方式类似于普通的`SELECT` SQL语句或`/search` JSON请求，但提供了额外的参数来控制模糊匹配行为。\n\n> 注意：`fuzzy`选项需要[ Manticore Buddy](../Installation/Manticore_Buddy.md)。如果不起作用，请确保已安装Buddy。\n\n> 注意：`fuzzy`选项不适用于[多查询](../Searching/Multi-queries.md)。\n\n## 通用语法\n\n### SQL\n\n<!-- example Fuzzy_Search_SQL -->\n\nCODE_BLOCK_0\n\n注意：通过SQL进行模糊搜索时，MATCH子句中不应包含除[短语搜索操作符](../Searching/Full_text_matching/Operators.md#Phrase-search-operator)之外的任何全文操作符，并且应仅包含您希望匹配的单词。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- request SQL with additional filters -->\n\n带有额外过滤条件的更复杂模糊搜索查询示例：\n\nCODE_BLOCK_2\n\n<!-- request JSON -->\n\nCODE_BLOCK_3\n\n<!-- response SQL -->\n\nCODE_BLOCK_4\n\n<!-- request SQL with preserve option -->\n\nCODE_BLOCK_5\n\n<!-- request JSON with preserve option -->\n\nCODE_BLOCK_6\n\n<!-- response SQL with preserve option -->\n\nCODE_BLOCK_7\n\n<!-- end -->\n\n### JSON\n\nCODE_BLOCK_8\n\n注意：如果您使用[query_string](../Searching/Full_text_matching/Basic_usage.md#query_string)，请注意它不支持除[短语搜索操作符](../Searching/Full_text_matching/Operators.md#Phrase-search-operator)之外的全文操作符。查询字符串应仅由您希望匹配的单词组成。\n\n### 选项\n\n- `fuzzy`：开启或关闭模糊搜索。\n\n- `distance`：设置匹配的Levenshtein距离。默认值为`2`。\n\n- `preserve`：`0`或`1`（默认：`0`）。设置为`1`时，保留搜索结果中没有模糊匹配的单词（例如，“hello wrld”返回“hello wrld”和“hello world”）。设置为`0`时，仅返回成功模糊匹配的单词（例如，“hello wrld”仅返回“hello world”）。对于保留可能不存在于Manticore Search中的短词或专有名词特别有用。\n\n- `layouts`：用于检测因键盘布局不匹配导致的输入错误的键盘布局（例如，使用错误布局时输入“ghbdtn”代替“привет”）。Manticore比较不同布局中字符的位置以建议纠正。至少需要2个布局才能有效检测不匹配。默认不使用任何布局。使用空字符串`''`（SQL）或空数组`[]`（JSON）关闭此功能。支持的布局包括：\n\n  - `be` - 比利时AZERTY布局\n\n  - `bg` - 标准保加利亚布局\n\n  - `br` - 巴西QWERTY布局\n\n  - `ch` - 瑞士QWERTZ布局\n\n  - `de` - 德国QWERTZ布局\n\n  - `dk` - 丹麦QWERTY布局\n\n  - `es` - 西班牙QWERTY布局\n\n  - `fr` - 法国AZERTY布局\n\n  - `uk` - 英国QWERTY布局\n\n  - `gr` - 希腊QWERTY布局\n\n  - `it` - 意大利QWERTY布局\n\n  - `no` - 挪威QWERTY布局\n\n  - `pt` - 葡萄牙QWERTY布局\n\n  - `ru` - 俄罗斯JCUKEN布局\n\n  - `se` - 瑞典QWERTY布局\n\n  - `ua` - 乌克兰JCUKEN布局\n\n  - `us` - 美国QWERTY布局\n\n### 链接",
      "russian": "# Исправление орфографии\n\nИсправление орфографии, также известное как:\n\n* Автоматическая коррекция\n\n* Коррекция текста\n\n* Исправление орфографических ошибок\n\n* Толерантность к опечаткам\n\n* \"Вы имели в виду?\"\n\nи так далее, — это программная функция, которая предлагает альтернативы или автоматически исправляет введённый вами текст. Концепция исправления набранного текста восходит к 1960-м годам, когда учёный-компьютерщик Уоррен Тейтельман, также изобретший команду \"отменить\", представил философию вычислений под названием D.W.I.M., или \"Do What I Mean\" (делай, что я имею в виду). Вместо того чтобы программировать компьютеры принимать только идеально отформатированные инструкции, Тейтельман утверждал, что их следует программировать на распознавание очевидных ошибок.\n\nПервым известным продуктом, предоставляющим функцию исправления орфографии, был Microsoft Word 6.0, выпущенный в 1993 году.\n\n### Как это работает\n\nСуществует несколько способов реализации исправления орфографии, но важно отметить, что не существует чисто программного способа с достойным качеством преобразовать вашу ошибочно набранную \"ipone\" в \"iphone\". В основном, должна быть база данных, на которой основана система. Эта база данных может быть:\n\n* Словарём правильно написанных слов, который, в свою очередь, может быть:\n\n  * Основан на ваших реальных данных. Идея здесь в том, что, в основном, орфография в словаре, составленном из ваших данных, правильная, и система пытается найти слово, наиболее похожее на введённое (мы вскоре обсудим, как это можно сделать с помощью Manticore).\n\n  * Или он может основываться на внешнем словаре, не связанном с вашими данными. Проблема, которая может возникнуть здесь, заключается в том, что ваши данные и внешний словарь могут слишком сильно отличаться: некоторые слова могут отсутствовать в словаре, в то время как другие могут отсутствовать в ваших данных.\n\n* Не только основанным на словаре, но и учитывающим контекст, например, \"white ber\" будет исправлено на \"white bear\", а \"dark ber\" — на \"dark beer\". Контекстом может быть не только соседнее слово в вашем запросе, но и ваше местоположение, время суток, грамматика текущего предложения (чтобы изменить \"there\" на \"their\" или нет), история ваших поисков и практически любые другие факторы, которые могут повлиять на ваш замысел.\n\n* Ещё один классический подход — использовать предыдущие поисковые запросы в качестве базы данных для исправления орфографии. Это ещё больше используется в функционале [автозаполнения](../Searching/Autocomplete.md), но также имеет смысл и для автокоррекции. Идея в том, что пользователи в основном правильно пишут слова, поэтому мы можем использовать слова из их истории поиска как источник истины, даже если у нас нет этих слов в наших документах или мы не используем внешний словарь. Здесь также возможна учёт контекста.\n\nManticore предоставляет опцию нечеткого поиска и команды `CALL QSUGGEST` и `CALL SUGGEST`, которые можно использовать для автоматического исправления орфографии.\n\n## Нечеткий поиск\n\nФункция нечеткого поиска позволяет более гибко сопоставлять, учитывая небольшие вариации или опечатки в поисковом запросе. Она работает аналогично обычному SQL-запросу `SELECT` или JSON-запросу `/search`, но предоставляет дополнительные параметры для управления поведением нечеткого сопоставления.\n\n> ПРИМЕЧАНИЕ: Опция `fuzzy` требует [Manticore Buddy](../Installation/Manticore_Buddy.md). Если она не работает, убедитесь, что Buddy установлен.\n\n> ПРИМЕЧАНИЕ: Опция `fuzzy` недоступна для [мультизапросов](../Searching/Multi-queries.md).\n\n## Общий синтаксис\n\n### SQL\n\n<!-- example Fuzzy_Search_SQL -->\n\nCODE_BLOCK_0\n\nПримечание: При выполнении нечеткого поиска через SQL, в клаузе MATCH не должно быть полнотекстовых операторов, кроме [оператора поиска фразы](../Searching/Full_text_matching/Operators.md#Phrase-search-operator), и должны быть включены только слова, которые вы хотите сопоставить.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- request SQL with additional filters -->\n\nПример более сложного запроса нечеткого поиска с дополнительными фильтрами:\n\nCODE_BLOCK_2\n\n<!-- request JSON -->\n\nCODE_BLOCK_3\n\n<!-- response SQL -->\n\nCODE_BLOCK_4\n\n<!-- request SQL with preserve option -->\n\nCODE_BLOCK_5\n\n<!-- request JSON with preserve option -->\n\nCODE_BLOCK_6\n\n<!-- response SQL with preserve option -->\n\nCODE_BLOCK_7\n\n<!-- end -->\n\n### JSON\n\nCODE_BLOCK_8\n\nПримечание: Если вы используете [query_string](../Searching/Full_text_matching/Basic_usage.md#query_string), имейте в виду, что он не поддерживает полнотекстовые операторы, кроме [оператора поиска фразы](../Searching/Full_text_matching/Operators.md#Phrase-search-operator). Строка запроса должна состоять только из слов, которые вы хотите сопоставить.\n\n### Опции\n\n- `fuzzy`: Включить или выключить нечеткий поиск.\n\n- `distance`: Установить расстояние Левенштейна для сопоставления. По умолчанию `2`.\n\n- `preserve`: `0` или `1` (по умолчанию: `0`). При установке в `1` сохраняет слова, для которых не найдено нечетких совпадений в результатах поиска (например, \"hello wrld\" возвращает и \"hello wrld\", и \"hello world\"). При установке в `0` возвращает только слова с успешными нечеткими совпадениями (например, \"hello wrld\" возвращает только \"hello world\"). Особенно полезно для сохранения коротких слов или собственных имён, которые могут отсутствовать в Manticore Search.\n\n- `layouts`: Раскладки клавиатуры для обнаружения ошибок набора, вызванных несоответствием раскладки клавиатуры (например, набор \"ghbdtn\" вместо \"привет\" при неправильной раскладке). Manticore сравнивает позиции символов в разных раскладках для предложения исправлений. Требуется минимум 2 раскладки для эффективного обнаружения несоответствий. По умолчанию раскладки не используются. Используйте пустую строку `''` (SQL) или массив `[]` (JSON), чтобы отключить эту функцию. Поддерживаемые раскладки включают:\n\n  - `be` - бельгийская раскладка AZERTY\n\n  - `bg` - стандартная болгарская раскладка\n\n  - `br` - бразильская раскладка QWERTY\n\n  - `ch` - швейцарская раскладка QWERTZ\n\n  - `de` - немецкая раскладка QWERTZ\n\n  - `dk` - датская раскладка QWERTY\n\n  - `es` - испанская раскладка QWERTY\n\n  - `fr` - французская раскладка AZERTY\n\n  - `uk` - британская раскладка QWERTY\n\n  - `gr` - греческая раскладка QWERTY\n\n  - `it` - итальянская раскладка QWERTY\n\n  - `no` - норвежская раскладка QWERTY\n\n  - `pt` - португальская раскладка QWERTY\n\n  - `ru` - русская раскладка JCUKEN\n\n  - `se` - шведская раскладка QWERTY\n\n  - `ua` - украинская раскладка JCUKEN\n\n  - `us` - американская раскладка QWERTY\n\n### Ссылки"
    },
    "is_code_or_comment": false
  },
  "17d1e4d57a8c092bd28613b35c95d33d745bce1a94ee94298b8ef87065f9795d": {
    "original": "* <a href=\"https://github.manticoresearch.com/manticoresoftware/manticoresearch?query=fature&filters%5Bcomment%5D%5B%5D=28798446&filters%5Bcommon%5D%5Brepo_id%5D%5B%5D=95614931&sort=&search=keyword-search-fuzzy-layouts\">This demo</a> demonstrates the fuzzy search functionality:\n\n  ![Fuzzy search example](fuzzysearch.png){.scale-0.7}\n\n* Blog post about Fuzzy Search and Autocomplete - https://manticoresearch.com/blog/new-fuzzy-search-and-autocomplete/\n\n## CALL QSUGGEST, CALL SUGGEST\n\nBoth commands are accessible via SQL and support querying both local (plain and real-time) and distributed tables. The syntax is as follows:\n\nCODE_BLOCK_9\n\nThese commands provide all suggestions from the dictionary for a given word. They work only on tables with [infixing](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) enabled and [dict=keywords](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict). They return the suggested keywords, Levenshtein distance between the suggested and original keywords, and the document statistics of the suggested keyword.\n\nIf the first parameter contains multiple words, then:\n\n* `CALL QSUGGEST` will return suggestions only for the **last** word, ignoring the rest.\n\n* `CALL SUGGEST` will return suggestions only for the **first** word.\n\nThat's the only difference between them. Several options are supported for customization:\n\n| Option | Description | Default |\n\n| - | - | - |\n\n| limit | Returns N top matches | 5 |\n\n| max_edits | Keeps only dictionary words with a Levenshtein distance less than or equal to N | 4 |\n\n| result_stats | Provides Levenshtein distance and document count of the found words | 1 (enabled) |\n\n| delta_len | Keeps only dictionary words with a length difference less than N | 3 |\n\n| max_matches | Number of matches to keep | 25 |\n\n| reject | Rejected words are matches that are not better than those already in the match queue. They are put in a rejected queue that gets reset in case one actually can go in the match queue. This parameter defines the size of the rejected queue (as reject*max(max_matched,limit)). If the rejected queue is filled, the engine stops looking for potential matches | 4 |\n\n| result_line | alternate mode to display the data by returning all suggests, distances and docs each per one row | 0 |\n\n| non_char | do not skip dictionary words with non alphabet symbols | 0 (skip such words) |\n\n| sentence | Returns the original sentence along with the last word replaced by the matched one. | 0 (do not return the full sentence) |\n\n| force_bigrams | Forces the use of bigrams (2-character n-grams) instead of trigrams for all word lengths, which can improve matching for words with transposition errors | 0 (use trigrams for words ≥6 characters) |\n\nTo show how it works, let's create a table and add a few documents to it.\n\nCODE_BLOCK_10\n\n<!-- example single -->\n\n##### Single word example\n\nAs you can see, the mistyped word \"crossb**U**dy\" gets corrected to \"crossbody\". By default, `CALL SUGGEST/QSUGGEST` return:\n\n* `distance` - the Levenshtein distance which means how many edits they had to make to convert the given word to the suggestion\n\n* `docs` - number of documents containing the suggested word\n\nTo disable the display of these statistics, you can use the option `0 as result_stats`.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request Example -->\n\nCODE_BLOCK_11\n\n<!-- response Example -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n<!-- example first -->\n\n##### CALL SUGGEST takes only the first word\n\nIf the first parameter is not a single word, but multiple, then `CALL SUGGEST` will return suggestions only for the first word.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request Example -->\n\nCODE_BLOCK_13\n\n<!-- response Example -->\n\nCODE_BLOCK_14\n\n<!-- end -->\n\n<!-- example last -->\n\n##### CALL QSUGGEST takes only the last word\n\nIf the first parameter is not a single word, but multiple, then `CALL SUGGEST` will return suggestions only for the last word.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request Example -->\n\nCODE_BLOCK_15\n\n<!-- response Example -->\n\nCODE_BLOCK_16\n\n<!-- end -->\n\n<!-- example last2 -->\n\nAdding `1 as sentence` makes `CALL QSUGGEST` return the entire sentence with the last word corrected.\n\n<!-- request Example -->\n\nCODE_BLOCK_17\n\n<!-- response Example -->\n\nCODE_BLOCK_18\n\n<!-- end -->\n\n##### Different display mode\n\nThe `1 as result_line` option changes the way the suggestions are displayed in the output. Instead of showing each suggestion in a separate row, it displays all suggestions, distances, and docs in a single row. Here's an example to demonstrate this:\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request Example -->\n\nCODE_BLOCK_19\n\n<!-- response Example -->\n\nCODE_BLOCK_20\n\n<!-- end -->\n\n##### Using force_bigrams for better transposition handling\n\nThe `force_bigrams` option can help with words that have transposition errors, such as \"ipohne\" vs \"iphone\". By using bigrams instead of trigrams, the algorithm can better handle character transpositions.\n\n<!-- intro -->\n\n##### Example:\n\n<!-- request Example -->\n\nCODE_BLOCK_21\n\n<!-- response Example -->\n\nCODE_BLOCK_22\n\n<!-- end -->\n\n### Demo\n\n* [This interactive course](https://play.manticoresearch.com/didyoumean/) shows how `CALL SUGGEST` works in a little web app.\n\n![CALL SUGGEST example](didyoumean.png){.scale-0.5}\n\n<!-- proofread -->",
    "translations": {
      "russian": "* <a href=\"https://github.manticoresearch.com/manticoresoftware/manticoresearch?query=fature&filters%5Bcomment%5D%5B%5D=28798446&filters%5Bcommon%5D%5Brepo_id%5D%5B%5D=95614931&sort=&search=keyword-search-fuzzy-layouts\">Эта демонстрация</a> показывает функциональность нечеткого поиска:\n\n  ![Пример нечеткого поиска](fuzzysearch.png){.scale-0.7}\n\n* Пост в блоге о нечетком поиске и автозаполнении - https://manticoresearch.com/blog/new-fuzzy-search-and-autocomplete/\n\n## CALL QSUGGEST, CALL SUGGEST\n\nОбе команды доступны через SQL и поддерживают запросы как к локальным (обычным и реального времени), так и к распределённым таблицам. Синтаксис следующий:\n\nCODE_BLOCK_9\n\nЭти команды предоставляют все предложения из словаря для заданного слова. Они работают только с таблицами, у которых включён [infixing](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) и [dict=keywords](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict). Они возвращают предложенные ключевые слова, расстояние Левенштейна между предложенным и исходным ключевым словом, а также статистику документов по предложенному ключевому слову.\n\nЕсли первый параметр содержит несколько слов, то:\n\n* `CALL QSUGGEST` вернёт предложения только для **последнего** слова, игнорируя остальные.\n\n* `CALL SUGGEST` вернёт предложения только для **первого** слова.\n\nЭто единственное различие между ними. Поддерживается несколько опций для настройки:\n\n| Опция | Описание | По умолчанию |\n\n| - | - | - |\n\n| limit | Возвращает N лучших совпадений | 5 |\n\n| max_edits | Оставляет только слова из словаря с расстоянием Левенштейна меньше или равным N | 4 |\n\n| result_stats | Предоставляет расстояние Левенштейна и количество документов для найденных слов | 1 (включено) |\n\n| delta_len | Оставляет только слова из словаря с разницей в длине меньше N | 3 |\n\n| max_matches | Количество совпадений для сохранения | 25 |\n\n| reject | Отклонённые слова — это совпадения, которые не лучше тех, что уже в очереди совпадений. Они помещаются в очередь отклонённых, которая сбрасывается, если одно из них может попасть в очередь совпадений. Этот параметр определяет размер очереди отклонённых (как reject*max(max_matched,limit)). Если очередь отклонённых заполнена, движок прекращает поиск потенциальных совпадений | 4 |\n\n| result_line | альтернативный режим отображения данных, возвращая все предложения, расстояния и документы по одной строке | 0 |\n\n| non_char | не пропускать слова из словаря с неалфавитными символами | 0 (пропускать такие слова) |\n\n| sentence | Возвращает исходное предложение с заменой последнего слова на найденное совпадение. | 0 (не возвращать полное предложение) |\n\n| force_bigrams | Принудительно использовать биграммы (2-символьные n-граммы) вместо триграмм для всех длин слов, что может улучшить совпадения для слов с ошибками перестановки | 0 (использовать триграммы для слов ≥6 символов) |\n\nЧтобы показать, как это работает, создадим таблицу и добавим в неё несколько документов.\n\nCODE_BLOCK_10\n\n<!-- example single -->\n\n##### Пример с одним словом\n\nКак видите, неправильно введённое слово \"crossb**U**dy\" исправляется на \"crossbody\". По умолчанию `CALL SUGGEST/QSUGGEST` возвращают:\n\n* `distance` - расстояние Левенштейна, показывающее, сколько изменений пришлось сделать, чтобы преобразовать заданное слово в предложение\n\n* `docs` - количество документов, содержащих предложенное слово\n\nЧтобы отключить отображение этой статистики, можно использовать опцию `0 as result_stats`.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request Example -->\n\nCODE_BLOCK_11\n\n<!-- response Example -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n<!-- example first -->\n\n##### CALL SUGGEST берёт только первое слово\n\nЕсли первый параметр содержит не одно, а несколько слов, то `CALL SUGGEST` вернёт предложения только для первого слова.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request Example -->\n\nCODE_BLOCK_13\n\n<!-- response Example -->\n\nCODE_BLOCK_14\n\n<!-- end -->\n\n<!-- example last -->\n\n##### CALL QSUGGEST берёт только последнее слово\n\nЕсли первый параметр содержит не одно, а несколько слов, то `CALL QSUGGEST` вернёт предложения только для последнего слова.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request Example -->\n\nCODE_BLOCK_15\n\n<!-- response Example -->\n\nCODE_BLOCK_16\n\n<!-- end -->\n\n<!-- example last2 -->\n\nДобавление `1 as sentence` заставляет `CALL QSUGGEST` возвращать полное предложение с исправленным последним словом.\n\n<!-- request Example -->\n\nCODE_BLOCK_17\n\n<!-- response Example -->\n\nCODE_BLOCK_18\n\n<!-- end -->\n\n##### Другой режим отображения\n\nОпция `1 as result_line` меняет способ отображения предложений в выводе. Вместо того, чтобы показывать каждое предложение в отдельной строке, она выводит все предложения, расстояния и документы в одной строке. Вот пример для демонстрации:\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request Example -->\n\nCODE_BLOCK_19\n\n<!-- response Example -->\n\nCODE_BLOCK_20\n\n<!-- end -->\n\n##### Использование force_bigrams для лучшей обработки перестановок\n\nОпция `force_bigrams` помогает с словами, в которых есть ошибки перестановки, например \"ipohne\" вместо \"iphone\". Используя биграммы вместо триграмм, алгоритм лучше справляется с перестановками символов.\n\n<!-- intro -->\n\n##### Пример:\n\n<!-- request Example -->\n\nCODE_BLOCK_21\n\n<!-- response Example -->\n\nCODE_BLOCK_22\n\n<!-- end -->\n\n### Демонстрация\n\n* [Этот интерактивный курс](https://play.manticoresearch.com/didyoumean/) показывает, как работает `CALL SUGGEST` в небольшом веб-приложении.\n\n![Пример CALL SUGGEST](didyoumean.png){.scale-0.5}\n\n<!-- proofread -->",
      "chinese": "* <a href=\"https://github.manticoresearch.com/manticoresoftware/manticoresearch?query=fature&filters%5Bcomment%5D%5B%5D=28798446&filters%5Bcommon%5D%5Brepo_id%5D%5B%5D=95614931&sort=&search=keyword-search-fuzzy-layouts\">此演示</a>展示了模糊搜索功能：\n\n  ![模糊搜索示例](fuzzysearch.png){.scale-0.7}\n\n* 关于模糊搜索和自动补全的博客文章 - https://manticoresearch.com/blog/new-fuzzy-search-and-autocomplete/\n\n## CALL QSUGGEST, CALL SUGGEST\n\n这两个命令都可以通过 SQL 访问，支持查询本地（普通和实时）以及分布式表。语法如下：\n\nCODE_BLOCK_9\n\n这些命令为给定单词提供字典中的所有建议。它们仅在启用了[infixing](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len)且设置了[dict=keywords](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)的表上工作。它们返回建议的关键词、建议关键词与原始关键词之间的 Levenshtein 距离，以及建议关键词的文档统计信息。\n\n如果第一个参数包含多个单词，则：\n\n* `CALL QSUGGEST` 只返回**最后一个**单词的建议，忽略其余部分。\n\n* `CALL SUGGEST` 只返回**第一个**单词的建议。\n\n这就是它们之间唯一的区别。支持多种选项进行自定义：\n\n| 选项 | 描述 | 默认值 |\n\n| - | - | - |\n\n| limit | 返回前 N 个匹配项 | 5 |\n\n| max_edits | 仅保留 Levenshtein 距离小于或等于 N 的字典词 | 4 |\n\n| result_stats | 提供找到词的 Levenshtein 距离和文档计数 | 1（启用） |\n\n| delta_len | 仅保留长度差小于 N 的字典词 | 3 |\n\n| max_matches | 保留的匹配数量 | 25 |\n\n| reject | 被拒绝的词是那些不比匹配队列中已有词更好的匹配。它们被放入一个拒绝队列，如果有词能进入匹配队列，拒绝队列会被重置。此参数定义拒绝队列的大小（为 reject*max(max_matched,limit)）。如果拒绝队列满了，搜索潜在匹配的过程会停止 | 4 |\n\n| result_line | 另一种显示模式，按行返回所有建议、距离和文档数 | 0 |\n\n| non_char | 不跳过包含非字母符号的字典词 | 0（跳过此类词） |\n\n| sentence | 返回原始句子，并将最后一个单词替换为匹配词 | 0（不返回完整句子） |\n\n| force_bigrams | 强制对所有单词长度使用二元组（2字符 n-gram）而非三元组，这可以改善对字符调换错误的匹配 | 0（对长度≥6的单词使用三元组） |\n\n为了展示其工作原理，我们创建一个表并添加几个文档。\n\nCODE_BLOCK_10\n\n<!-- example single -->\n\n##### 单词示例\n\n如你所见，拼写错误的单词 \"crossb**U**dy\" 被纠正为 \"crossbody\"。默认情况下，`CALL SUGGEST/QSUGGEST` 返回：\n\n* `distance` - Levenshtein 距离，表示将给定单词转换为建议词所需的编辑次数\n\n* `docs` - 包含建议词的文档数量\n\n要禁用这些统计信息的显示，可以使用选项 `0 as result_stats`。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request Example -->\n\nCODE_BLOCK_11\n\n<!-- response Example -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n<!-- example first -->\n\n##### CALL SUGGEST 只处理第一个单词\n\n如果第一个参数不是单个单词，而是多个单词，则 `CALL SUGGEST` 只返回第一个单词的建议。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request Example -->\n\nCODE_BLOCK_13\n\n<!-- response Example -->\n\nCODE_BLOCK_14\n\n<!-- end -->\n\n<!-- example last -->\n\n##### CALL QSUGGEST 只处理最后一个单词\n\n如果第一个参数不是单个单词，而是多个单词，则 `CALL QSUGGEST` 只返回最后一个单词的建议。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request Example -->\n\nCODE_BLOCK_15\n\n<!-- response Example -->\n\nCODE_BLOCK_16\n\n<!-- end -->\n\n<!-- example last2 -->\n\n添加 `1 as sentence` 使 `CALL QSUGGEST` 返回整个句子，并将最后一个单词纠正。\n\n<!-- request Example -->\n\nCODE_BLOCK_17\n\n<!-- response Example -->\n\nCODE_BLOCK_18\n\n<!-- end -->\n\n##### 不同的显示模式\n\n`1 as result_line` 选项改变了建议在输出中的显示方式。它不再将每个建议显示在单独的行中，而是将所有建议、距离和文档数显示在一行中。以下示例演示了这一点：\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request Example -->\n\nCODE_BLOCK_19\n\n<!-- response Example -->\n\nCODE_BLOCK_20\n\n<!-- end -->\n\n##### 使用 force_bigrams 改善调换错误处理\n\n`force_bigrams` 选项可以帮助处理字符调换错误的单词，例如 \"ipohne\" 与 \"iphone\"。通过使用二元组而非三元组，算法能更好地处理字符调换。\n\n<!-- intro -->\n\n##### 示例：\n\n<!-- request Example -->\n\nCODE_BLOCK_21\n\n<!-- response Example -->\n\nCODE_BLOCK_22\n\n<!-- end -->\n\n### 演示\n\n* [此交互式课程](https://play.manticoresearch.com/didyoumean/) 展示了 `CALL SUGGEST` 在一个小型网页应用中的工作方式。\n\n![CALL SUGGEST 示例](didyoumean.png){.scale-0.5}\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
