{
  "5f21ae88cbf76bc3354e6c39e583560de7aeae79845124753deb027c0b4224f7": {
    "original": "# Sub-selects\n\nManticore supports SELECT subqueries via SQL in the following format:\n\nCODE_BLOCK_0\n\nThe outer select allows only `ORDER BY` and `LIMIT` clauses. Sub-select queries currently have two use cases:\n\n1. When you have a query with two ranking UDFs, one very fast and the other slow, and perform a full-text search with a large match result set. Without subselect, the query would look like:\n\n    ```sql\n\n    SELECT id,slow_rank() as slow,fast_rank() as fast FROM index\n\n        WHERE MATCH(‘some common query terms’) ORDER BY fast DESC, slow DESC LIMIT 20\n\n        OPTION max_matches=1000;\n\n    ```\n\n    With sub-selects, the query can be rewritten as:\n\n    ```sql\n\n    SELECT * FROM\n\n        (SELECT id,slow_rank() as slow,fast_rank() as fast FROM index WHERE\n\n            MATCH(‘some common query terms’)\n\n            ORDER BY fast DESC LIMIT 100 OPTION max_matches=1000)\n\n    ORDER BY slow DESC LIMIT 20;\n\n    ```\n\n    In the initial query, the `slow_rank()` UDF is computed for the entire match result set. With SELECT sub-queries, only `fast_rank()` is computed for the entire match result set, while `slow_rank()` is computed for a limited set.\n\n2. The second case is useful for large result sets coming from a distributed table.\n\n    For this query:\n\n    ```sql\n\n    SELECT * FROM my_dist_index WHERE some_conditions LIMIT 50000;\n\n    ```\n\n    If you have 20 nodes, each node can send back to the master a maximum of 50K records, resulting in 20 x 50K = 1M records. However, since the master sends back only 50K (out of 1M), it might be good enough for the nodes to send only the top 10K records. With sub-select, you can rewrite the query as:\n\n    ```sql\n\n    SELECT * FROM\n\n         (SELECT * FROM my_dist_index WHERE some_conditions LIMIT 10000)\n\n     ORDER by some_attr LIMIT 50000;\n\n    ```\n\n    In this case, the nodes receive only the inner query and execute it. This means the master will receive only 20x10K=200K records. The master will take all the records received, reorder them by the OUTER clause, and return the best 50K records. The sub-select helps reduce the traffic between the master and the nodes, as well as reduce the master's computation time (since it processes only 200K instead of 1M records).\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 子查询\n\nManticore 支持通过 SQL 以以下格式进行 SELECT 子查询：\n\nCODE_BLOCK_0\n\n外层 select 只允许 `ORDER BY` 和 `LIMIT` 子句。子查询目前有两个使用场景：\n\n1. 当你有一个包含两个排序 UDF 的查询，一个非常快，另一个很慢，并且执行全文搜索时匹配结果集很大。没有子查询，查询看起来像：\n\n    ```sql\n\n    SELECT id,slow_rank() as slow,fast_rank() as fast FROM index\n\n        WHERE MATCH(‘some common query terms’) ORDER BY fast DESC, slow DESC LIMIT 20\n\n        OPTION max_matches=1000;\n\n    ```\n\n    使用子查询，查询可以重写为：\n\n    ```sql\n\n    SELECT * FROM\n\n        (SELECT id,slow_rank() as slow,fast_rank() as fast FROM index WHERE\n\n            MATCH(‘some common query terms’)\n\n            ORDER BY fast DESC LIMIT 100 OPTION max_matches=1000)\n\n    ORDER BY slow DESC LIMIT 20;\n\n    ```\n\n    在初始查询中，`slow_rank()` UDF 会对整个匹配结果集进行计算。使用 SELECT 子查询时，只有 `fast_rank()` 会对整个匹配结果集计算，而 `slow_rank()` 只对有限的集合计算。\n\n2. 第二种情况适用于来自分布式表的大型结果集。\n\n    对于此查询：\n\n    ```sql\n\n    SELECT * FROM my_dist_index WHERE some_conditions LIMIT 50000;\n\n    ```\n\n    如果你有 20 个节点，每个节点最多可以向主节点发送 50K 条记录，结果是 20 x 50K = 1M 条记录。然而，由于主节点只返回 50K（从 1M 中），节点只发送前 10K 条记录可能就足够了。使用子查询，你可以将查询重写为：\n\n    ```sql\n\n    SELECT * FROM\n\n         (SELECT * FROM my_dist_index WHERE some_conditions LIMIT 10000)\n\n     ORDER by some_attr LIMIT 50000;\n\n    ```\n\n    在这种情况下，节点只接收内部查询并执行它。这意味着主节点只会收到 20x10K=200K 条记录。主节点将接收的所有记录重新排序（根据外层子句），并返回最好的 50K 条记录。子查询有助于减少主节点和节点之间的流量，同时减少主节点的计算时间（因为它只处理 200K 条记录，而不是 1M 条记录）。\n\n<!-- proofread -->",
      "russian": "# Подзапросы\n\nManticore поддерживает подзапросы SELECT через SQL в следующем формате:\n\nCODE_BLOCK_0\n\nВнешний SELECT допускает только клаузы `ORDER BY` и `LIMIT`. В настоящее время подзапросы имеют два варианта использования:\n\n1. Когда у вас есть запрос с двумя ранжирующими UDF, один очень быстрый, а другой медленный, и выполняется полнотекстовый поиск с большим набором результатов. Без подзапроса запрос выглядел бы так:\n\n    ```sql\n\n    SELECT id,slow_rank() as slow,fast_rank() as fast FROM index\n\n        WHERE MATCH(‘some common query terms’) ORDER BY fast DESC, slow DESC LIMIT 20\n\n        OPTION max_matches=1000;\n\n    ```\n\n    С подзапросами запрос можно переписать так:\n\n    ```sql\n\n    SELECT * FROM\n\n        (SELECT id,slow_rank() as slow,fast_rank() as fast FROM index WHERE\n\n            MATCH(‘some common query terms’)\n\n            ORDER BY fast DESC LIMIT 100 OPTION max_matches=1000)\n\n    ORDER BY slow DESC LIMIT 20;\n\n    ```\n\n    В исходном запросе UDF `slow_rank()` вычисляется для всего набора результатов. С подзапросами SELECT `fast_rank()` вычисляется для всего набора результатов, а `slow_rank()` — только для ограниченного набора.\n\n2. Второй случай полезен для больших наборов результатов, получаемых из распределённой таблицы.\n\n    Для этого запроса:\n\n    ```sql\n\n    SELECT * FROM my_dist_index WHERE some_conditions LIMIT 50000;\n\n    ```\n\n    Если у вас 20 узлов, каждый узел может отправить мастеру максимум 50K записей, что в сумме даёт 20 x 50K = 1M записей. Однако, поскольку мастер возвращает только 50K (из 1M), может быть достаточно, чтобы узлы отправляли только топ 10K записей. С подзапросом запрос можно переписать так:\n\n    ```sql\n\n    SELECT * FROM\n\n         (SELECT * FROM my_dist_index WHERE some_conditions LIMIT 10000)\n\n     ORDER by some_attr LIMIT 50000;\n\n    ```\n\n    В этом случае узлы получают только внутренний запрос и выполняют его. Это означает, что мастер получит только 20x10K=200K записей. Мастер возьмёт все полученные записи, переупорядочит их по ВНЕШНЕМУ условию и вернёт лучшие 50K записей. Подзапрос помогает уменьшить трафик между мастером и узлами, а также сократить время обработки мастера (так как он обрабатывает только 200K вместо 1M записей).\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
