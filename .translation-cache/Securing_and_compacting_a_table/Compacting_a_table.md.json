{
  "970df9f492b7a3573c4f67e59d0d7975f0e53aa8e7f2d8f3abd277ae26d5613a": {
    "original": "# Compacting a Table\n\nOver time, RT tables may become fragmented into numerous disk chunks and/or contaminated with deleted, yet unpurged data, affecting search performance. In these cases, optimization is necessary. Essentially, the optimization process combines pairs of disk chunks, removing documents that were previously deleted using DELETE statements.\n\nBeginning with Manticore 4, this process occurs [automatically by default](../Server_settings/Searchd.md#auto_optimize). However, you can also use the following commands to manually initiate table compaction.\n\n## OPTIMIZE TABLE\n\n<!-- example optimize -->\n\nCODE_BLOCK_0\n\n`OPTIMIZE` statement adds an RT table to the optimization queue, which will be processed in a background thread.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n### Number of optimized disk chunks\n\n<!-- example optimize_cutoff -->\n\nBy default, OPTIMIZE merges the RT table's disk chunks down to a number less than or equal to the number of logical CPU cores multiplied by 2.\n\nHowever, if the table has attributes with KNN indexes, this threshold is different. In this case, it is set to the number of physical CPU cores divided by 2 to improve KNN search performance.\n\nYou can also control the number of optimized disk chunks manually using the `cutoff` option.\n\nAdditional options include:\n\n* Server setting [optimize_cutoff](../Server_settings/Searchd.md#optimize_cutoff) for overriding the default threshold\n\n* Per-table setting [optimize_cutoff](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#optimize_cutoff)\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n### Running in foreground\n\n<!-- example optimize_sync -->\n\nWhen using `OPTION sync=1` (0 by default), the command will wait for the optimization process to complete before returning. If the connection is interrupted, the optimization will continue running on the server.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n### Throttling the IO impact\n\nOptimization can be a lengthy and I/O-intensive process. To minimize the impact, all actual merge work is executed serially in a special background thread, and the `OPTIMIZE` statement simply adds a job to its queue. The optimization thread can be I/O-throttled, and you can control the maximum number of I/Os per second and the maximum I/O size with the [rt_merge_iops](../Server_settings/Searchd.md#rt_merge_iops) and [rt_merge_maxiosize](../Server_settings/Searchd.md#rt_merge_maxiosize) directives, respectively.\n\nDuring optimization, the RT table being optimized remains online and available for both searching and updates nearly all the time. It is locked for a very brief period when a pair of disk chunks is successfully merged, allowing for the renaming of old and new files and updating the table header.\n\n### Optimizing clustered tables\n\nAs long as [auto_optimize](../Server_settings/Searchd.md#auto_optimize) is not disabled, tables are optimized automatically.\n\nIf you are experiencing unexpected SSTs or want tables across all nodes of the cluster to be binary identical, you need to:\n\n1. Disable [auto_optimize](../Server_settings/Searchd.md#auto_optimize).\n\n2. Manually optimize tables:\n\n<!-- example cluster_manual_drop -->\n\nOn one of the nodes, drop the table from the cluster:\n\n<!-- request SQL -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n<!-- example cluster_manual_optimize -->\n\nOptimize the table:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- end -->\n\n<!-- example cluster_manual_add -->\n\nAdd back the table to the cluster:\n\n<!-- request SQL -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\nWhen the table is added back, the new files created by the optimization process will be replicated to the other nodes in the cluster.\n\nAny local changes made to the table on other nodes will be lost.\n\nTable data modifications (inserts, replaces, deletes, updates) should either:\n\n1. Be postponed, or\n\n2. Be directed to the node where the optimization process is running.\n\nNote that while the table is out of the cluster, insert/replace/delete/update commands should refer to it without the cluster name prefix (for SQL statements or the cluster property in case of an HTTP JSON request), otherwise they will fail.\n\nOnce the table is added back to the cluster, you must resume write operations on the table and include the cluster name prefix again, or they will fail.\n\nSearch operations are available as usual during the process on any of the nodes.\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 紧凑表\n\n随着时间的推移，RT 表可能会碎片化成多个磁盘块和/或被已删除但未清除的数据污染，影响搜索性能。在这些情况下，需要进行优化。基本上，优化过程是将成对的磁盘块合并，移除之前通过 DELETE 语句删除的文档。\n\n从 Manticore 4 开始，这个过程默认[自动进行](../Server_settings/Searchd.md#auto_optimize)。但是，你也可以使用以下命令手动启动表的紧凑。\n\n## OPTIMIZE TABLE\n\n<!-- example optimize -->\n\nCODE_BLOCK_0\n\n`OPTIMIZE` 语句将 RT 表添加到优化队列，该队列将在后台线程中处理。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n### 优化后的磁盘块数量\n\n<!-- example optimize_cutoff -->\n\n默认情况下，OPTIMIZE 会将 RT 表的磁盘块合并到不超过逻辑 CPU 核心数乘以 2 的数量。\n\n但是，如果表中有带 KNN 索引的属性，这个阈值会不同。在这种情况下，阈值设置为物理 CPU 核心数除以 2，以提升 KNN 搜索性能。\n\n你也可以使用 `cutoff` 选项手动控制优化后的磁盘块数量。\n\n其他选项包括：\n\n* 服务器设置 [optimize_cutoff](../Server_settings/Searchd.md#optimize_cutoff) 用于覆盖默认阈值\n\n* 每表设置 [optimize_cutoff](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#optimize_cutoff)\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n### 前台运行\n\n<!-- example optimize_sync -->\n\n使用 `OPTION sync=1`（默认值为 0）时，命令会等待优化过程完成后才返回。如果连接中断，优化仍会在服务器上继续运行。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n### 限制 IO 影响\n\n优化可能是一个耗时且 IO 密集的过程。为了减少影响，所有实际的合并工作都在一个特殊的后台线程中串行执行，`OPTIMIZE` 语句只是将任务添加到其队列中。优化线程可以进行 IO 限速，你可以通过 [rt_merge_iops](../Server_settings/Searchd.md#rt_merge_iops) 和 [rt_merge_maxiosize](../Server_settings/Searchd.md#rt_merge_maxiosize) 指令分别控制每秒最大 IO 数和最大 IO 大小。\n\n在优化过程中，被优化的 RT 表几乎始终在线且可用于搜索和更新。只有在成功合并一对磁盘块时，表会被短暂锁定，以便重命名旧文件和新文件并更新表头。\n\n### 优化集群表\n\n只要没有禁用 [auto_optimize](../Server_settings/Searchd.md#auto_optimize)，表会自动优化。\n\n如果你遇到意外的 SST 文件，或者希望集群中所有节点的表二进制完全一致，你需要：\n\n1. 禁用 [auto_optimize](../Server_settings/Searchd.md#auto_optimize)。\n\n2. 手动优化表：\n\n<!-- example cluster_manual_drop -->\n\n在某个节点上，从集群中删除表：\n\n<!-- request SQL -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n<!-- example cluster_manual_optimize -->\n\n优化表：\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- end -->\n\n<!-- example cluster_manual_add -->\n\n将表重新添加到集群：\n\n<!-- request SQL -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n当表被重新添加时，优化过程中创建的新文件会被复制到集群中的其他节点。\n\n其他节点上对表的任何本地更改都会丢失。\n\n表数据的修改（插入、替换、删除、更新）应当：\n\n1. 延后执行，或\n\n2. 定向到正在运行优化过程的节点。\n\n注意，在表不在集群中时，插入/替换/删除/更新命令应当不带集群名称前缀（对于 SQL 语句或 HTTP JSON 请求中的 cluster 属性），否则会失败。\n\n一旦表重新加入集群，必须恢复对表的写操作并再次包含集群名称前缀，否则操作会失败。\n\n在此过程中，任何节点上的搜索操作照常可用。\n\n<!-- proofread -->",
      "russian": "# Компактирование таблицы\n\nСо временем RT-таблицы могут фрагментироваться на множество дисковых чанков и/или загрязняться удалёнными, но ещё не очищенными данными, что влияет на производительность поиска. В таких случаях необходима оптимизация. По сути, процесс оптимизации объединяет пары дисковых чанков, удаляя документы, которые были ранее удалены с помощью операторов DELETE.\n\nНачиная с Manticore 4, этот процесс происходит [автоматически по умолчанию](../Server_settings/Searchd.md#auto_optimize). Однако вы также можете использовать следующие команды для ручного запуска компактирования таблицы.\n\n## OPTIMIZE TABLE\n\n<!-- example optimize -->\n\nCODE_BLOCK_0\n\nОператор `OPTIMIZE` добавляет RT-таблицу в очередь оптимизации, которая будет обработана в фоновом потоке.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n### Количество оптимизируемых дисковых чанков\n\n<!-- example optimize_cutoff -->\n\nПо умолчанию OPTIMIZE объединяет дисковые чанки RT-таблицы до количества, меньшего или равного числу логических ядер процессора, умноженному на 2.\n\nОднако, если в таблице есть атрибуты с KNN-индексами, этот порог отличается. В этом случае он устанавливается как количество физических ядер процессора, делённое на 2, для улучшения производительности KNN-поиска.\n\nВы также можете вручную контролировать количество оптимизируемых дисковых чанков с помощью опции `cutoff`.\n\nДополнительные опции включают:\n\n* Настройку сервера [optimize_cutoff](../Server_settings/Searchd.md#optimize_cutoff) для переопределения порога по умолчанию\n\n* Настройку на уровне таблицы [optimize_cutoff](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#optimize_cutoff)\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n### Запуск в фореграунде\n\n<!-- example optimize_sync -->\n\nПри использовании `OPTION sync=1` (по умолчанию 0) команда будет ждать завершения процесса оптимизации перед возвратом результата. Если соединение прервётся, оптимизация продолжит выполняться на сервере.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n### Ограничение влияния на ввод-вывод\n\nОптимизация может быть длительным и интенсивным по вводу-выводу процессом. Чтобы минимизировать влияние, вся фактическая работа по слиянию выполняется последовательно в специальном фоновом потоке, а оператор `OPTIMIZE` просто добавляет задачу в его очередь. Фоновый поток оптимизации может быть ограничен по вводу-выводу, и вы можете контролировать максимальное количество операций ввода-вывода в секунду и максимальный размер ввода-вывода с помощью директив [rt_merge_iops](../Server_settings/Searchd.md#rt_merge_iops) и [rt_merge_maxiosize](../Server_settings/Searchd.md#rt_merge_maxiosize) соответственно.\n\nВо время оптимизации RT-таблица остаётся онлайн и доступна для поиска и обновлений почти всё время. Она блокируется на очень короткий период, когда успешно объединяется пара дисковых чанков, что позволяет переименовать старые и новые файлы и обновить заголовок таблицы.\n\n### Оптимизация кластерных таблиц\n\nПока [auto_optimize](../Server_settings/Searchd.md#auto_optimize) не отключён, таблицы оптимизируются автоматически.\n\nЕсли вы сталкиваетесь с неожиданными SST или хотите, чтобы таблицы на всех узлах кластера были бинарно идентичны, необходимо:\n\n1. Отключить [auto_optimize](../Server_settings/Searchd.md#auto_optimize).\n\n2. Вручную оптимизировать таблицы:\n\n<!-- example cluster_manual_drop -->\n\nНа одном из узлов удалите таблицу из кластера:\n\n<!-- request SQL -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n<!-- example cluster_manual_optimize -->\n\nОптимизируйте таблицу:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- end -->\n\n<!-- example cluster_manual_add -->\n\nДобавьте таблицу обратно в кластер:\n\n<!-- request SQL -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\nКогда таблица будет добавлена обратно, новые файлы, созданные в процессе оптимизации, будут реплицированы на другие узлы кластера.\n\nЛюбые локальные изменения, сделанные в таблице на других узлах, будут потеряны.\n\nИзменения данных таблицы (вставки, замены, удаления, обновления) должны либо:\n\n1. Быть отложены, либо\n\n2. Направляться на узел, где выполняется процесс оптимизации.\n\nОбратите внимание, что пока таблица отсутствует в кластере, команды insert/replace/delete/update должны обращаться к ней без префикса имени кластера (для SQL-запросов или свойства cluster в случае HTTP JSON-запроса), иначе они завершатся с ошибкой.\n\nПосле того как таблица будет добавлена обратно в кластер, необходимо возобновить операции записи в таблицу и снова использовать префикс имени кластера, иначе они будут завершаться с ошибкой.\n\nОперации поиска доступны как обычно на любом из узлов в процессе.\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "d279a187a8b8b36518d9a87c3f9ec5c4acd2ece5f61b06e07413dfff8fa0cab5": {
    "original": "# Compacting a Table\n\nOver time, RT tables may become fragmented into numerous disk chunks and/or contaminated with deleted, yet unpurged data, affecting search performance. In these cases, optimization is necessary. Essentially, the optimization process combines pairs of disk chunks, removing documents that were previously deleted using DELETE statements.\n\nBeginning with Manticore 4, this process occurs [automatically by default](../Server_settings/Searchd.md#auto_optimize). However, you can also use the following commands to manually initiate table compaction.\n\n## OPTIMIZE TABLE\n\n<!-- example optimize -->\n\nCODE_BLOCK_0\n\n`OPTIMIZE` statement adds an RT table to the optimization queue, which will be processed in a background thread.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n### Number of optimized disk chunks\n\n<!-- example optimize_cutoff -->\n\nBy default, OPTIMIZE merges the RT table's disk chunks down to a number less than or equal to the number of logical CPU cores multiplied by 2.\n\nHowever, if the table has attributes with KNN indexes, this threshold is different. In this case, it is set to the number of physical CPU cores divided by 2 to improve KNN search performance.\n\nYou can also control the number of optimized disk chunks manually using the `cutoff` option.\n\nAdditional options include:\n\n* Server setting [optimize_cutoff](../Server_settings/Searchd.md#optimize_cutoff) for overriding the default threshold\n\n* Per-table setting [optimize_cutoff](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#optimize_cutoff)\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n### Running in foreground\n\n<!-- example optimize_sync -->\n\nWhen using `OPTION sync=1` (0 by default), the command will wait for the optimization process to complete before returning. If the connection is interrupted, the optimization will continue running on the server.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n### Throttling the IO impact\n\nOptimization can be a lengthy and I/O-intensive process. To minimize the impact, all actual merge work is executed serially in a special background thread, and the `OPTIMIZE` statement simply adds a job to its queue. The optimization thread can be I/O-throttled, and you can control the maximum number of I/Os per second and the maximum I/O size with the [rt_merge_iops](../Server_settings/Searchd.md#rt_merge_iops) and [rt_merge_maxiosize](../Server_settings/Searchd.md#rt_merge_maxiosize) directives, respectively.\n\nDuring optimization, the RT table being optimized remains online and available for both searching and updates nearly all the time. It is locked for a very brief period when a pair of disk chunks is successfully merged, allowing for the renaming of old and new files and updating the table header.\n\n### Optimizing clustered tables\n\nAs long as [auto_optimize](../Server_settings/Searchd.md#auto_optimize) is not disabled, tables are optimized automatically.\n\nIf you are experiencing unexpected SSTs or want tables across all nodes of the cluster to be binary identical, you need to:\n\n1. Disable [auto_optimize](../Server_settings/Searchd.md#auto_optimize).\n\n2. Manually optimize tables:\n\n<!-- example cluster_manual_drop -->\n\nOn one of the nodes, drop the table from the cluster:\n\n<!-- request SQL -->\n\nCODE_BLOCK_7\n\n<!-- request JSON -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!-- example cluster_manual_optimize -->\n\nOptimize the table:\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- request JSON -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n<!-- example cluster_manual_add -->\n\nAdd back the table to the cluster:\n\n<!-- request SQL -->\n\nCODE_BLOCK_11\n\n<!-- request JSON -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\nWhen the table is added back, the new files created by the optimization process will be replicated to the other nodes in the cluster.\n\nAny local changes made to the table on other nodes will be lost.\n\nTable data modifications (inserts, replaces, deletes, updates) should either:\n\n1. Be postponed, or\n\n2. Be directed to the node where the optimization process is running.\n\nNote that while the table is out of the cluster, insert/replace/delete/update commands should refer to it without the cluster name prefix (for SQL statements or the cluster property in case of an HTTP JSON request), otherwise they will fail.\n\nOnce the table is added back to the cluster, you must resume write operations on the table and include the cluster name prefix again, or they will fail.\n\nSearch operations are available as usual during the process on any of the nodes.\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 压缩表\n\n随着时间的推移，RT 表可能会分散成多个磁盘块和/或被删除但未清除的数据污染，从而影响搜索性能。在这种情况下，有必要进行优化。基本上，优化过程是将成对的磁盘块合并，移除先前通过 DELETE 语句删除的文档。\n\n从 Manticore 4 开始，这一过程[默认自动进行](../Server_settings/Searchd.md#auto_optimize)。不过，你也可以使用以下命令手动启动表压缩。\n\n## OPTIMIZE TABLE\n\n<!-- example optimize -->\n\nCODE_BLOCK_0\n\n`OPTIMIZE` 语句将 RT 表添加到优化队列，该队列将在后台线程中处理。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n### 优化后的磁盘块数量\n\n<!-- example optimize_cutoff -->\n\n默认情况下，OPTIMIZE 会将 RT 表的磁盘块合并到小于或等于逻辑 CPU 核心数乘以 2 的数量。\n\n但是，如果表中带有带有 KNN 索引的属性，则该阈值不同。在这种情况下，它设置为物理 CPU 核心数除以 2，以提升 KNN 搜索性能。\n\n你也可以使用 `cutoff` 选项手动控制优化后磁盘块的数量。\n\n其他选项包括：\n\n* 覆盖默认阈值的服务器设置 [optimize_cutoff](../Server_settings/Searchd.md#optimize_cutoff)\n\n* 每表设置 [optimize_cutoff](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#optimize_cutoff)\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n### 前台运行\n\n<!-- example optimize_sync -->\n\n使用 `OPTION sync=1`（默认值为 0）时，命令将在返回之前等待优化过程完成。如果连接中断，优化将在服务器上继续运行。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n### 限制 IO 影响\n\n优化可能是一个漫长且 I/O 密集的过程。为了减少影响，所有实际的合并工作都在一个特殊的后台线程中串行执行，而 `OPTIMIZE` 语句仅将任务加入其队列。优化线程可以进行 I/O 限速，你可以通过[rt_merge_iops](../Server_settings/Searchd.md#rt_merge_iops) 和 [rt_merge_maxiosize](../Server_settings/Searchd.md#rt_merge_maxiosize) 指令分别控制最大每秒 I/O 数和最大 I/O 大小。\n\n优化期间，被优化的 RT 表几乎始终在线且可供搜索和更新使用。只有在一对磁盘块成功合并时，会短暂锁定，以便重命名旧文件和新文件并更新表头。\n\n### 优化集群表\n\n只要未禁用[auto_optimize](../Server_settings/Searchd.md#auto_optimize)，表将自动优化。\n\n如果你遇到意外的 SSTs，或者希望所有节点上的表二进制完全一致，则需要：\n\n1. 禁用 [auto_optimize](../Server_settings/Searchd.md#auto_optimize)。\n\n2. 手动优化表：\n\n<!-- example cluster_manual_drop -->\n\n在某个节点上，从集群中删除表：\n\n<!-- request SQL -->\n\nCODE_BLOCK_7\n\n<!-- request JSON -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!-- example cluster_manual_optimize -->\n\n优化表：\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- request JSON -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n<!-- example cluster_manual_add -->\n\n将表重新添加到集群：\n\n<!-- request SQL -->\n\nCODE_BLOCK_11\n\n<!-- request JSON -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n当表被重新添加后，优化过程中产生的新文件将被复制到集群中的其他节点。\n\n在其他节点对该表做的任何本地更改将丢失。\n\n表数据的修改（插入、替换、删除、更新）应当：\n\n1. 被推迟，或者\n\n2. 定向到正在运行优化过程的节点。\n\n请注意，在表不在集群时，插入/替换/删除/更新命令应当不带集群名称前缀（对 SQL 语句或 HTTP JSON 请求中的 cluster 属性），否则将失败。\n\n一旦表被重新添加到集群，必须恢复对表的写操作并重新包含集群名称前缀，否则操作将失败。\n\n在此过程中，任一节点上的搜索操作正常可用。\n\n<!-- proofread -->",
      "russian": "# Компактизация таблицы\n\nСо временем RT-таблицы могут фрагментироваться на множество кусков на диске и/или сопровождаться удалёнными, но ещё не очищенными данными, что влияет на производительность поиска. В таких случаях необходима оптимизация. По сути, процесс оптимизации объединяет пары кусков на диске, удаляя документы, которые были ранее удалены с помощью операторов DELETE.\n\nНачиная с Manticore 4, этот процесс происходит [автоматически по умолчанию](../Server_settings/Searchd.md#auto_optimize). Однако вы также можете использовать следующие команды для ручного запуска компактизации таблицы.\n\n## OPTIMIZE TABLE\n\n<!-- example optimize -->\n\nCODE_BLOCK_0\n\nОператор `OPTIMIZE` добавляет RT-таблицу в очередь оптимизации, которая будет обрабатываться в фоновом потоке.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n### Количество оптимизируемых кусков на диске\n\n<!-- example optimize_cutoff -->\n\nПо умолчанию OPTIMIZE сливает дисковые куски RT-таблицы до количества, не превышающего число логических ядер процессора, умноженное на 2.\n\nОднако, если в таблице есть атрибуты с KNN-индексами, этот порог отличается. В этом случае он устанавливается как число физических ядер процессора, делённое на 2, для улучшения производительности KNN-поиска.\n\nВы также можете вручную контролировать количество оптимизируемых кусков на диске с помощью опции `cutoff`.\n\nДополнительные опции включают:\n\n* Параметр сервера [optimize_cutoff](../Server_settings/Searchd.md#optimize_cutoff) для переопределения порога по умолчанию\n\n* Параметр для конкретной таблицы [optimize_cutoff](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#optimize_cutoff)\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n### Запуск в фореграунд режиме\n\n<!-- example optimize_sync -->\n\nПри использовании `OPTION sync=1` (по умолчанию 0) команда дождётся завершения процесса оптимизации перед возвратом результата. Если соединение будет прервано, оптимизация продолжит выполняться на сервере.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n### Ограничение влияния на ввод-вывод\n\nОптимизация может быть продолжительным и ресурсоёмким процессом по вводу-выводу. Чтобы уменьшить влияние, вся фактическая работа по слиянию выполняется последовательно в специальном фоновом потоке, а оператор `OPTIMIZE` всего лишь добавляет задачу в его очередь. Фоновый поток оптимизации может ограничивать скорость ввода-вывода, и вы можете контролировать максимальное число операций ввода-вывода в секунду и максимальный размер ввода-вывода с помощью директив [rt_merge_iops](../Server_settings/Searchd.md#rt_merge_iops) и [rt_merge_maxiosize](../Server_settings/Searchd.md#rt_merge_maxiosize) соответственно.\n\nВо время оптимизации оптимизируемая RT-таблица остаётся онлайн и доступна для поиска и обновлений почти всё время. Она блокируется на очень короткий период, когда успешно сливается пара кусков на диске, что позволяет переименовать старые и новые файлы и обновить заголовок таблицы.\n\n### Оптимизация кластерных таблиц\n\nПока [auto_optimize](../Server_settings/Searchd.md#auto_optimize) не отключён, таблицы оптимизируются автоматически.\n\nЕсли у вас возникают неожиданные SST или вы хотите, чтобы таблицы на всех узлах кластера были бинарно идентичны, вам необходимо:\n\n1. Отключить [auto_optimize](../Server_settings/Searchd.md#auto_optimize).\n\n2. Вручную оптимизировать таблицы:\n\n<!-- example cluster_manual_drop -->\n\nНа одном из узлов удалите таблицу из кластера:\n\n<!-- request SQL -->\n\nCODE_BLOCK_7\n\n<!-- request JSON -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!-- example cluster_manual_optimize -->\n\nОптимизируйте таблицу:\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- request JSON -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n<!-- example cluster_manual_add -->\n\nДобавьте таблицу обратно в кластер:\n\n<!-- request SQL -->\n\nCODE_BLOCK_11\n\n<!-- request JSON -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\nПосле того как таблица будет добавлена обратно, новые файлы, созданные в процессе оптимизации, будут реплицированы на другие узлы кластера.\n\nЛюбые локальные изменения, произведённые в таблице на других узлах, будут потеряны.\n\nИзменения данных таблицы (вставки, замены, удаления, обновления) должны либо:\n\n1. Быть отложены, или\n\n2. Быть направлены на узел, где выполняется процесс оптимизации.\n\nОбратите внимание, что пока таблица отсутствует в кластере, команды insert/replace/delete/update должны обращаться к ней без префикса имени кластера (для SQL-запросов или свойства cluster в случае HTTP JSON-запроса), иначе они завершатся неудачей.\n\nКогда таблица добавлена обратно в кластер, необходимо возобновить операции записи в таблицу и снова включить префикс имени кластера, иначе они не будут работать.\n\nОперации поиска доступны как обычно на любом из узлов в процессе.\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
