{
  "970df9f492b7a3573c4f67e59d0d7975f0e53aa8e7f2d8f3abd277ae26d5613a": {
    "original": "# Compacting a Table\n\nOver time, RT tables may become fragmented into numerous disk chunks and/or contaminated with deleted, yet unpurged data, affecting search performance. In these cases, optimization is necessary. Essentially, the optimization process combines pairs of disk chunks, removing documents that were previously deleted using DELETE statements.\n\nBeginning with Manticore 4, this process occurs [automatically by default](../Server_settings/Searchd.md#auto_optimize). However, you can also use the following commands to manually initiate table compaction.\n\n## OPTIMIZE TABLE\n\n<!-- example optimize -->\n\nCODE_BLOCK_0\n\n`OPTIMIZE` statement adds an RT table to the optimization queue, which will be processed in a background thread.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n### Number of optimized disk chunks\n\n<!-- example optimize_cutoff -->\n\nBy default, OPTIMIZE merges the RT table's disk chunks down to a number less than or equal to the number of logical CPU cores multiplied by 2.\n\nHowever, if the table has attributes with KNN indexes, this threshold is different. In this case, it is set to the number of physical CPU cores divided by 2 to improve KNN search performance.\n\nYou can also control the number of optimized disk chunks manually using the `cutoff` option.\n\nAdditional options include:\n\n* Server setting [optimize_cutoff](../Server_settings/Searchd.md#optimize_cutoff) for overriding the default threshold\n\n* Per-table setting [optimize_cutoff](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#optimize_cutoff)\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n### Running in foreground\n\n<!-- example optimize_sync -->\n\nWhen using `OPTION sync=1` (0 by default), the command will wait for the optimization process to complete before returning. If the connection is interrupted, the optimization will continue running on the server.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n### Throttling the IO impact\n\nOptimization can be a lengthy and I/O-intensive process. To minimize the impact, all actual merge work is executed serially in a special background thread, and the `OPTIMIZE` statement simply adds a job to its queue. The optimization thread can be I/O-throttled, and you can control the maximum number of I/Os per second and the maximum I/O size with the [rt_merge_iops](../Server_settings/Searchd.md#rt_merge_iops) and [rt_merge_maxiosize](../Server_settings/Searchd.md#rt_merge_maxiosize) directives, respectively.\n\nDuring optimization, the RT table being optimized remains online and available for both searching and updates nearly all the time. It is locked for a very brief period when a pair of disk chunks is successfully merged, allowing for the renaming of old and new files and updating the table header.\n\n### Optimizing clustered tables\n\nAs long as [auto_optimize](../Server_settings/Searchd.md#auto_optimize) is not disabled, tables are optimized automatically.\n\nIf you are experiencing unexpected SSTs or want tables across all nodes of the cluster to be binary identical, you need to:\n\n1. Disable [auto_optimize](../Server_settings/Searchd.md#auto_optimize).\n\n2. Manually optimize tables:\n\n<!-- example cluster_manual_drop -->\n\nOn one of the nodes, drop the table from the cluster:\n\n<!-- request SQL -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n<!-- example cluster_manual_optimize -->\n\nOptimize the table:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- end -->\n\n<!-- example cluster_manual_add -->\n\nAdd back the table to the cluster:\n\n<!-- request SQL -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\nWhen the table is added back, the new files created by the optimization process will be replicated to the other nodes in the cluster.\n\nAny local changes made to the table on other nodes will be lost.\n\nTable data modifications (inserts, replaces, deletes, updates) should either:\n\n1. Be postponed, or\n\n2. Be directed to the node where the optimization process is running.\n\nNote that while the table is out of the cluster, insert/replace/delete/update commands should refer to it without the cluster name prefix (for SQL statements or the cluster property in case of an HTTP JSON request), otherwise they will fail.\n\nOnce the table is added back to the cluster, you must resume write operations on the table and include the cluster name prefix again, or they will fail.\n\nSearch operations are available as usual during the process on any of the nodes.\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 紧凑表\n\n随着时间的推移，RT 表可能会碎片化成多个磁盘块和/或被已删除但未清除的数据污染，影响搜索性能。在这些情况下，需要进行优化。基本上，优化过程是将成对的磁盘块合并，移除之前通过 DELETE 语句删除的文档。\n\n从 Manticore 4 开始，这个过程默认[自动进行](../Server_settings/Searchd.md#auto_optimize)。但是，你也可以使用以下命令手动启动表的紧凑。\n\n## OPTIMIZE TABLE\n\n<!-- example optimize -->\n\nCODE_BLOCK_0\n\n`OPTIMIZE` 语句将 RT 表添加到优化队列，该队列将在后台线程中处理。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n### 优化后的磁盘块数量\n\n<!-- example optimize_cutoff -->\n\n默认情况下，OPTIMIZE 会将 RT 表的磁盘块合并到不超过逻辑 CPU 核心数乘以 2 的数量。\n\n但是，如果表中有带 KNN 索引的属性，这个阈值会不同。在这种情况下，阈值设置为物理 CPU 核心数除以 2，以提升 KNN 搜索性能。\n\n你也可以使用 `cutoff` 选项手动控制优化后的磁盘块数量。\n\n其他选项包括：\n\n* 服务器设置 [optimize_cutoff](../Server_settings/Searchd.md#optimize_cutoff) 用于覆盖默认阈值\n\n* 每表设置 [optimize_cutoff](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#optimize_cutoff)\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n### 前台运行\n\n<!-- example optimize_sync -->\n\n使用 `OPTION sync=1`（默认值为 0）时，命令会等待优化过程完成后才返回。如果连接中断，优化仍会在服务器上继续运行。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n### 限制 IO 影响\n\n优化可能是一个耗时且 IO 密集的过程。为了减少影响，所有实际的合并工作都在一个特殊的后台线程中串行执行，`OPTIMIZE` 语句只是将任务添加到其队列中。优化线程可以进行 IO 限速，你可以通过 [rt_merge_iops](../Server_settings/Searchd.md#rt_merge_iops) 和 [rt_merge_maxiosize](../Server_settings/Searchd.md#rt_merge_maxiosize) 指令分别控制每秒最大 IO 数和最大 IO 大小。\n\n在优化过程中，被优化的 RT 表几乎始终在线且可用于搜索和更新。只有在成功合并一对磁盘块时，表会被短暂锁定，以便重命名旧文件和新文件并更新表头。\n\n### 优化集群表\n\n只要没有禁用 [auto_optimize](../Server_settings/Searchd.md#auto_optimize)，表会自动优化。\n\n如果你遇到意外的 SST 文件，或者希望集群中所有节点的表二进制完全一致，你需要：\n\n1. 禁用 [auto_optimize](../Server_settings/Searchd.md#auto_optimize)。\n\n2. 手动优化表：\n\n<!-- example cluster_manual_drop -->\n\n在某个节点上，从集群中删除表：\n\n<!-- request SQL -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n<!-- example cluster_manual_optimize -->\n\n优化表：\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- end -->\n\n<!-- example cluster_manual_add -->\n\n将表重新添加到集群：\n\n<!-- request SQL -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n当表被重新添加时，优化过程中创建的新文件会被复制到集群中的其他节点。\n\n其他节点上对表的任何本地更改都会丢失。\n\n表数据的修改（插入、替换、删除、更新）应当：\n\n1. 延后执行，或\n\n2. 定向到正在运行优化过程的节点。\n\n注意，在表不在集群中时，插入/替换/删除/更新命令应当不带集群名称前缀（对于 SQL 语句或 HTTP JSON 请求中的 cluster 属性），否则会失败。\n\n一旦表重新加入集群，必须恢复对表的写操作并再次包含集群名称前缀，否则操作会失败。\n\n在此过程中，任何节点上的搜索操作照常可用。\n\n<!-- proofread -->",
      "russian": "# Компактирование таблицы\n\nСо временем RT-таблицы могут фрагментироваться на множество дисковых чанков и/или загрязняться удалёнными, но ещё не очищенными данными, что влияет на производительность поиска. В таких случаях необходима оптимизация. По сути, процесс оптимизации объединяет пары дисковых чанков, удаляя документы, которые были ранее удалены с помощью операторов DELETE.\n\nНачиная с Manticore 4, этот процесс происходит [автоматически по умолчанию](../Server_settings/Searchd.md#auto_optimize). Однако вы также можете использовать следующие команды для ручного запуска компактирования таблицы.\n\n## OPTIMIZE TABLE\n\n<!-- example optimize -->\n\nCODE_BLOCK_0\n\nОператор `OPTIMIZE` добавляет RT-таблицу в очередь оптимизации, которая будет обработана в фоновом потоке.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n### Количество оптимизируемых дисковых чанков\n\n<!-- example optimize_cutoff -->\n\nПо умолчанию OPTIMIZE объединяет дисковые чанки RT-таблицы до количества, меньшего или равного числу логических ядер процессора, умноженному на 2.\n\nОднако, если в таблице есть атрибуты с KNN-индексами, этот порог отличается. В этом случае он устанавливается как количество физических ядер процессора, делённое на 2, для улучшения производительности KNN-поиска.\n\nВы также можете вручную контролировать количество оптимизируемых дисковых чанков с помощью опции `cutoff`.\n\nДополнительные опции включают:\n\n* Настройку сервера [optimize_cutoff](../Server_settings/Searchd.md#optimize_cutoff) для переопределения порога по умолчанию\n\n* Настройку на уровне таблицы [optimize_cutoff](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#optimize_cutoff)\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n### Запуск в фореграунде\n\n<!-- example optimize_sync -->\n\nПри использовании `OPTION sync=1` (по умолчанию 0) команда будет ждать завершения процесса оптимизации перед возвратом результата. Если соединение прервётся, оптимизация продолжит выполняться на сервере.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- end -->\n\n### Ограничение влияния на ввод-вывод\n\nОптимизация может быть длительным и интенсивным по вводу-выводу процессом. Чтобы минимизировать влияние, вся фактическая работа по слиянию выполняется последовательно в специальном фоновом потоке, а оператор `OPTIMIZE` просто добавляет задачу в его очередь. Фоновый поток оптимизации может быть ограничен по вводу-выводу, и вы можете контролировать максимальное количество операций ввода-вывода в секунду и максимальный размер ввода-вывода с помощью директив [rt_merge_iops](../Server_settings/Searchd.md#rt_merge_iops) и [rt_merge_maxiosize](../Server_settings/Searchd.md#rt_merge_maxiosize) соответственно.\n\nВо время оптимизации RT-таблица остаётся онлайн и доступна для поиска и обновлений почти всё время. Она блокируется на очень короткий период, когда успешно объединяется пара дисковых чанков, что позволяет переименовать старые и новые файлы и обновить заголовок таблицы.\n\n### Оптимизация кластерных таблиц\n\nПока [auto_optimize](../Server_settings/Searchd.md#auto_optimize) не отключён, таблицы оптимизируются автоматически.\n\nЕсли вы сталкиваетесь с неожиданными SST или хотите, чтобы таблицы на всех узлах кластера были бинарно идентичны, необходимо:\n\n1. Отключить [auto_optimize](../Server_settings/Searchd.md#auto_optimize).\n\n2. Вручную оптимизировать таблицы:\n\n<!-- example cluster_manual_drop -->\n\nНа одном из узлов удалите таблицу из кластера:\n\n<!-- request SQL -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n<!-- example cluster_manual_optimize -->\n\nОптимизируйте таблицу:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- end -->\n\n<!-- example cluster_manual_add -->\n\nДобавьте таблицу обратно в кластер:\n\n<!-- request SQL -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\nКогда таблица будет добавлена обратно, новые файлы, созданные в процессе оптимизации, будут реплицированы на другие узлы кластера.\n\nЛюбые локальные изменения, сделанные в таблице на других узлах, будут потеряны.\n\nИзменения данных таблицы (вставки, замены, удаления, обновления) должны либо:\n\n1. Быть отложены, либо\n\n2. Направляться на узел, где выполняется процесс оптимизации.\n\nОбратите внимание, что пока таблица отсутствует в кластере, команды insert/replace/delete/update должны обращаться к ней без префикса имени кластера (для SQL-запросов или свойства cluster в случае HTTP JSON-запроса), иначе они завершатся с ошибкой.\n\nПосле того как таблица будет добавлена обратно в кластер, необходимо возобновить операции записи в таблицу и снова использовать префикс имени кластера, иначе они будут завершаться с ошибкой.\n\nОперации поиска доступны как обычно на любом из узлов в процессе.\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "d279a187a8b8b36518d9a87c3f9ec5c4acd2ece5f61b06e07413dfff8fa0cab5": {
    "original": "# Compacting a Table\n\nOver time, RT tables may become fragmented into numerous disk chunks and/or contaminated with deleted, yet unpurged data, affecting search performance. In these cases, optimization is necessary. Essentially, the optimization process combines pairs of disk chunks, removing documents that were previously deleted using DELETE statements.\n\nBeginning with Manticore 4, this process occurs [automatically by default](../Server_settings/Searchd.md#auto_optimize). However, you can also use the following commands to manually initiate table compaction.\n\n## OPTIMIZE TABLE\n\n<!-- example optimize -->\n\nCODE_BLOCK_0\n\n`OPTIMIZE` statement adds an RT table to the optimization queue, which will be processed in a background thread.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n### Number of optimized disk chunks\n\n<!-- example optimize_cutoff -->\n\nBy default, OPTIMIZE merges the RT table's disk chunks down to a number less than or equal to the number of logical CPU cores multiplied by 2.\n\nHowever, if the table has attributes with KNN indexes, this threshold is different. In this case, it is set to the number of physical CPU cores divided by 2 to improve KNN search performance.\n\nYou can also control the number of optimized disk chunks manually using the `cutoff` option.\n\nAdditional options include:\n\n* Server setting [optimize_cutoff](../Server_settings/Searchd.md#optimize_cutoff) for overriding the default threshold\n\n* Per-table setting [optimize_cutoff](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#optimize_cutoff)\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n### Running in foreground\n\n<!-- example optimize_sync -->\n\nWhen using `OPTION sync=1` (0 by default), the command will wait for the optimization process to complete before returning. If the connection is interrupted, the optimization will continue running on the server.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n### Throttling the IO impact\n\nOptimization can be a lengthy and I/O-intensive process. To minimize the impact, all actual merge work is executed serially in a special background thread, and the `OPTIMIZE` statement simply adds a job to its queue. The optimization thread can be I/O-throttled, and you can control the maximum number of I/Os per second and the maximum I/O size with the [rt_merge_iops](../Server_settings/Searchd.md#rt_merge_iops) and [rt_merge_maxiosize](../Server_settings/Searchd.md#rt_merge_maxiosize) directives, respectively.\n\nDuring optimization, the RT table being optimized remains online and available for both searching and updates nearly all the time. It is locked for a very brief period when a pair of disk chunks is successfully merged, allowing for the renaming of old and new files and updating the table header.\n\n### Optimizing clustered tables\n\nAs long as [auto_optimize](../Server_settings/Searchd.md#auto_optimize) is not disabled, tables are optimized automatically.\n\nIf you are experiencing unexpected SSTs or want tables across all nodes of the cluster to be binary identical, you need to:\n\n1. Disable [auto_optimize](../Server_settings/Searchd.md#auto_optimize).\n\n2. Manually optimize tables:\n\n<!-- example cluster_manual_drop -->\n\nOn one of the nodes, drop the table from the cluster:\n\n<!-- request SQL -->\n\nCODE_BLOCK_7\n\n<!-- request JSON -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!-- example cluster_manual_optimize -->\n\nOptimize the table:\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- request JSON -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n<!-- example cluster_manual_add -->\n\nAdd back the table to the cluster:\n\n<!-- request SQL -->\n\nCODE_BLOCK_11\n\n<!-- request JSON -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\nWhen the table is added back, the new files created by the optimization process will be replicated to the other nodes in the cluster.\n\nAny local changes made to the table on other nodes will be lost.\n\nTable data modifications (inserts, replaces, deletes, updates) should either:\n\n1. Be postponed, or\n\n2. Be directed to the node where the optimization process is running.\n\nNote that while the table is out of the cluster, insert/replace/delete/update commands should refer to it without the cluster name prefix (for SQL statements or the cluster property in case of an HTTP JSON request), otherwise they will fail.\n\nOnce the table is added back to the cluster, you must resume write operations on the table and include the cluster name prefix again, or they will fail.\n\nSearch operations are available as usual during the process on any of the nodes.\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# 紧凑表\n\n随着时间的推移，RT表可能会碎片化成多个磁盘块和/或被已删除但未清理的数据污染，影响搜索性能。在这种情况下，需要进行优化。本质上，优化过程是将成对的磁盘块合并，移除先前通过DELETE语句删除的文档。\n\n从Manticore 4开始，此过程[默认自动进行](../Server_settings/Searchd.md#auto_optimize)。但是，您也可以使用以下命令手动启动表紧凑。\n\n## OPTIMIZE TABLE\n\n<!-- example optimize -->\n\nCODE_BLOCK_0\n\n`OPTIMIZE`语句将RT表添加到优化队列，该队列将在后台线程中处理。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n### 优化的磁盘块数量\n\n<!-- example optimize_cutoff -->\n\n默认情况下，OPTIMIZE将RT表的磁盘块合并至不超过逻辑CPU核心数乘以2的数量。\n\n但是，如果表中包含带有KNN索引的属性，则该阈值不同。在这种情况下，阈值设定为物理CPU核心数除以2，以提升KNN搜索性能。\n\n您也可以使用`cutoff`选项手动控制优化后的磁盘块数量。\n\n其他选项包括：\n\n* 服务器设置 [optimize_cutoff](../Server_settings/Searchd.md#optimize_cutoff) 用于覆盖默认阈值\n\n* 每表设置 [optimize_cutoff](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#optimize_cutoff)\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n### 在前台运行\n\n<!-- example optimize_sync -->\n\n使用`OPTION sync=1`（默认0）时，命令会等待优化过程完成后才返回。如果连接中断，优化将继续在服务器上运行。\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n### 限制IO影响\n\n优化过程可能耗时且IO密集。为了减少影响，所有实际的合并工作都在一个特殊的后台线程中串行执行，`OPTIMIZE`语句仅将任务加入其队列。优化线程可以进行IO限速，您可以通过[rt_merge_iops](../Server_settings/Searchd.md#rt_merge_iops)与[rt_merge_maxiosize](../Server_settings/Searchd.md#rt_merge_maxiosize)指令分别控制最大每秒IO次数和最大IO大小。\n\n在优化期间，被优化的RT表几乎始终在线且可用于搜索和更新。合并成功时会锁定极短时间，以便重命名旧、新文件并更新表头。\n\n### 优化集群表\n\n只要未禁用[auto_optimize](../Server_settings/Searchd.md#auto_optimize)，表会自动优化。\n\n如果您遇到意外的SST或希望集群所有节点上的表二进制完全一致，需：\n\n1. 禁用 [auto_optimize](../Server_settings/Searchd.md#auto_optimize)。\n\n2. 手动优化表：\n\n<!-- example cluster_manual_drop -->\n\n在某个节点，从集群中删除表：\n\n<!-- request SQL -->\n\nCODE_BLOCK_7\n\n<!-- request JSON -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!-- example cluster_manual_optimize -->\n\n优化该表：\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- request JSON -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n<!-- example cluster_manual_add -->\n\n将表重新添加回集群：\n\n<!-- request SQL -->\n\nCODE_BLOCK_11\n\n<!-- request JSON -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\n当表重新添加后，通过优化过程创建的新文件将被复制到集群中其他节点。\n\n其他节点上的任何本地更改将丢失。\n\n表数据修改（插入、替换、删除、更新）要么：\n\n1. 延迟执行，或\n\n2. 发送至正在执行优化的节点。\n\n注意，当表处于集群外时，插入/替换/删除/更新命令应不带集群名称前缀（针对SQL语句或HTTP JSON请求的cluster属性），否则会失败。\n\n表重新加入集群后，必须恢复写操作，并再次包含集群名称前缀，否则会失败。\n\n整个过程中，搜索操作可在任一节点照常进行。\n\n<!-- proofread -->",
      "russian": "# Уплотнение таблицы\n\nСо временем RT таблицы могут фрагментироваться на множество дисковых чанков и/или загрязняться удалёнными, но неочищенными данными, что ухудшает производительность поиска. В таких случаях требуется оптимизация. По сути, процесс оптимизации объединяет пары дисковых чанков, удаляя документы, которые ранее были удалены с помощью операторов DELETE.\n\nНачиная с Manticore 4, этот процесс происходит [автоматически по умолчанию](../Server_settings/Searchd.md#auto_optimize). Однако вы также можете использовать следующие команды для ручного запуска уплотнения таблицы.\n\n## OPTIMIZE TABLE\n\n<!-- example optimize -->\n\nCODE_BLOCK_0\n\nОператор `OPTIMIZE` добавляет RT таблицу в очередь оптимизации, которая будет обрабатываться в фоновом потоке.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_1\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n### Количество уплотняемых дисковых чанков\n\n<!-- example optimize_cutoff -->\n\nПо умолчанию OPTIMIZE объединяет дисковые чанки RT таблицы до числа, меньшего или равного количеству логических ядер процессора, умноженному на 2.\n\nОднако если в таблице есть атрибуты с KNN индексами, этот порог отличается. В этом случае он устанавливается как количество физических ядер процессора, делённое на 2, для улучшения производительности KNN поиска.\n\nТакже вы можете вручную контролировать количество уплотняемых дисковых чанков с помощью опции `cutoff`.\n\nДополнительные опции включают:\n\n* Настройку сервера [optimize_cutoff](../Server_settings/Searchd.md#optimize_cutoff) для переопределения порога по умолчанию\n\n* Настройку таблицы [optimize_cutoff](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#optimize_cutoff)\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_3\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n### Запуск в фореграунде\n\n<!-- example optimize_sync -->\n\nПри использовании `OPTION sync=1` (по умолчанию 0) команда будет ждать завершения процесса оптимизации перед возвратом результата. Если соединение прервётся, оптимизация продолжит выполняться на сервере.\n\n<!-- intro -->\n\n##### SQL:\n\n<!-- request SQL -->\n\nCODE_BLOCK_5\n\n<!-- intro -->\n\n##### JSON:\n\n<!-- request JSON -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n### Ограничение воздействия на ввод-вывод\n\nОптимизация может быть длительным и интенсивным по вводу-выводу процессом. Чтобы минимизировать нагрузку, вся реальная работа по слиянию выполняется последовательно в специальном фоновом потоке, а оператор `OPTIMIZE` лишь добавляет задачу в его очередь. Фоновый поток оптимизации может быть ограничен по ввод-выводу, и вы можете контролировать максимальное количество операций ввода-вывода в секунду и максимальный размер ввода-вывода с помощью директив [rt_merge_iops](../Server_settings/Searchd.md#rt_merge_iops) и [rt_merge_maxiosize](../Server_settings/Searchd.md#rt_merge_maxiosize) соответственно.\n\nВо время оптимизации RT таблица остаётся в сети и доступна для поиска и обновлений почти всё время. Она блокируется лишь на очень короткий период при успешном слиянии пары дисковых чанков, что позволяет переименовать старые и новые файлы и обновить заголовок таблицы.\n\n### Оптимизация кластерных таблиц\n\nПока не отключена настройка [auto_optimize](../Server_settings/Searchd.md#auto_optimize), таблицы оптимизируются автоматически.\n\nЕсли вы сталкиваетесь с неожиданными SST или хотите, чтобы таблицы на всех узлах кластера были бинарно идентичны, нужно:\n\n1. Отключить [auto_optimize](../Server_settings/Searchd.md#auto_optimize).\n\n2. Вручную оптимизировать таблицы:\n\n<!-- example cluster_manual_drop -->\n\nНа одном из узлов удалить таблицу из кластера:\n\n<!-- request SQL -->\n\nCODE_BLOCK_7\n\n<!-- request JSON -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n<!-- example cluster_manual_optimize -->\n\nОптимизировать таблицу:\n\n<!-- request SQL -->\n\nCODE_BLOCK_9\n\n<!-- request JSON -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n<!-- example cluster_manual_add -->\n\nДобавить таблицу обратно в кластер:\n\n<!-- request SQL -->\n\nCODE_BLOCK_11\n\n<!-- request JSON -->\n\nCODE_BLOCK_12\n\n<!-- end -->\n\nПри добавлении таблицы обратно новые файлы, созданные в процессе оптимизации, будут реплицированы на остальные узлы кластера.\n\nЛюбые локальные изменения, внесённые в таблицу на других узлах, будут потеряны.\n\nМодификации данных таблицы (вставки, замены, удаления, обновления) должны либо:\n\n1. Быть отложены, либо\n\n2. Направляться к узлу, где выполняется процесс оптимизации.\n\nОбратите внимание, что пока таблица находится вне кластера, команды insert/replace/delete/update должны обращаться к ней без префикса имени кластера (в SQL операторах или свойстве cluster в случае HTTP JSON запроса), иначе они завершатся с ошибкой.\n\nПосле добавления таблицы обратно в кластер необходимо возобновить операции записи в таблицу и снова использовать префикс имени кластера, иначе они завершатся с ошибкой.\n\nОперации поиска доступны как обычно на любом из узлов в процессе.\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
