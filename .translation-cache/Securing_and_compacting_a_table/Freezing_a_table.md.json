{
  "b21937b1d57f4f9abb2c918ed3b6582944a0a3b604001bc1210b52718d2c6e64": {
    "original": "# Freezing a table\n\n<!-- example freeze -->\n\nCODE_BLOCK_0\n\n`FREEZE` readies a real-time/plain table for a secure [backup](../Securing_and_compacting_a_table/Backup_and_restore.md). Specifically, it:\n\n1. Deactivates table compaction. If the table is currently being compacted, `FREEZE` will gracefully interrupt it.\n\n2. Transfers the current RAM chunk to a disk chunk.\n\n3. Flushes attributes.\n\n4. Disables implicit operations that could modify the disk files.\n\n5. Increments the table's locked counter.\n\n6. Shows the actual file list associated with the table.\n\nIf the table is already frozen (locked), `FREEZE` will:\n\n1. Increment the table's locked counter.\n\n2. Shows the actual file list associated with the table.\n\nThe built-in tool [manticore-backup](../Securing_and_compacting_a_table/Backup_and_restore.md) uses `FREEZE` to ensure data consistency. You can do the same if you want to create your own backup solution or need to freeze tables for other reasons. Just follow these steps:\n\n1. `FREEZE` a table (or a few).\n\n2. Capture the output of the `FREEZE` command and back up the specified files.\n\n3. `UNFREEZE` the table(s) once finished.\n\n<!-- request Example -->\n\nCODE_BLOCK_1\n\n<!-- response Example -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\nThe `file` column indicates the table's file paths within the [data_dir](../Server_settings/Searchd.md#data_dir) of the running instance. The `normalized` column displays the absolute paths for the same files. To back up a table, simply copy the provided files without additional preparation.\n\nWhen a table is frozen, you cannot execute `UPDATE` queries; they will wait until the table is unfrozen.\n\nAlso, `DELETE` and `REPLACE` queries have some restrictions while the table is frozen:\n\n* If `DELETE` affects a document in the current RAM chunk - it is permitted.\n\n* If `DELETE` impacts a document in a disk chunk but was previously deleted - it is allowed.\n\n* If `DELETE` would alter an actual disk chunk - it will wait until the table is unfrozen.\n\nManually `FLUSH`ing a RAM chunk of a frozen table will report 'success', but no real saving will occur.\n\n`DROP`/`TRUNCATE` of a frozen table **is** allowed since these operations are not implicit. We assume that if you truncate or drop a table, you don't need it backed up; therefore, it should not have been frozen initially.\n\n`INSERT`ing into a frozen table is supported but limited: new data will be stored in RAM (as usual) until `rt_mem_limit` is reached; then, new insertions will wait until the table is unfrozen.\n\nIf you shut down the daemon with a frozen table, it will act as if it experienced a dirty shutdown (e.g., `kill -9`): newly inserted data will **not** be saved in the RAM-chunk on disk, and upon restart, it will be restored from a binary log (if any) or lost (if binary logging is disabled).\n\n## Unfreezing a table\n\n<!-- example unfreeze -->\n\nCODE_BLOCK_3\n\n`UNFREEZE` command decreases the table's locked counter, and if it reaches zero, reactivates previously blocked operations and resumes the internal compaction service. Any operations that were waiting for the table to unfreeze will also resume and complete normally.\n\n<!-- request Example -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n## Inspecting the lock state of a table\n\n<!-- example show_table_status -->\n\nYou can use `SHOW table_name STATUS` to check if a table is frozen or not.\n\nThe locked counter is displayed in the table's status under the `locked` column. A value of zero indicates that the table is not frozen, while a non-zero value reflects the number of active locks. Each explicit `FREEZE` command and implicit locking (such as when the table is part of a cluster and a replication routine selects it as a donor for a replica) increases the counter. Each `UNFREEZE` command decreases the counter, eventually down to zero.\n\n<!-- request Example -->\n\nCODE_BLOCK_5\n\n<!-- response Example -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n## SHOW LOCKS\n\n<!-- example show_locks -->\n\nLocked tables are also displayed using the `SHOW LOCKS` command. The lock counters are shown in the `Additional Info` column.\n\n<!-- request Example -->\n\nCODE_BLOCK_7\n\n<!-- response Example -->\n\nCODE_BLOCK_8\n\n<!-- end -->",
    "translations": {
      "chinese": "# 冻结表\n\n<!-- example freeze -->\n\nCODE_BLOCK_0\n\n`FREEZE` 使实时/普通表准备好进行安全的[备份](../Securing_and_compacting_a_table/Backup_and_restore.md)。具体来说，它：\n\n1. 停用表压缩。如果表当前正在压缩，`FREEZE` 会优雅地中断它。\n\n2. 将当前的 RAM 块转移到磁盘块。\n\n3. 刷新属性。\n\n4. 禁用可能修改磁盘文件的隐式操作。\n\n5. 增加表的锁定计数器。\n\n6. 显示与表关联的实际文件列表。\n\n如果表已经被冻结（锁定），`FREEZE` 将：\n\n1. 增加表的锁定计数器。\n\n2. 显示与表关联的实际文件列表。\n\n内置工具 [manticore-backup](../Securing_and_compacting_a_table/Backup_and_restore.md) 使用 `FREEZE` 来确保数据一致性。如果你想创建自己的备份解决方案或因其他原因需要冻结表，也可以这样做。只需按照以下步骤：\n\n1. `FREEZE` 一个表（或几个表）。\n\n2. 捕获 `FREEZE` 命令的输出并备份指定的文件。\n\n3. 完成后 `UNFREEZE` 表。\n\n<!-- request Example -->\n\nCODE_BLOCK_1\n\n<!-- response Example -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n`file` 列指示运行实例的 [data_dir](../Server_settings/Searchd.md#data_dir) 中表的文件路径。`normalized` 列显示相同文件的绝对路径。备份表时，只需复制提供的文件，无需额外准备。\n\n当表被冻结时，不能执行 `UPDATE` 查询；它们将等待直到表解冻。\n\n此外，`DELETE` 和 `REPLACE` 查询在表冻结时有一些限制：\n\n* 如果 `DELETE` 影响当前 RAM 块中的文档 - 允许执行。\n\n* 如果 `DELETE` 影响磁盘块中的文档但之前已被删除 - 允许执行。\n\n* 如果 `DELETE` 会修改实际的磁盘块 - 将等待直到表解冻。\n\n手动对冻结表的 RAM 块执行 `FLUSH` 会报告“成功”，但不会真正保存。\n\n冻结表的 `DROP`/`TRUNCATE` **是**允许的，因为这些操作不是隐式的。我们假设如果你截断或删除表，就不需要备份它；因此，表本不应被冻结。\n\n向冻结表中 `INSERT` 是支持的，但有限制：新数据将存储在 RAM（如常）直到达到 `rt_mem_limit`；然后，新插入将等待直到表解冻。\n\n如果在表冻结时关闭守护进程，它将表现得像经历了脏关闭（例如，`kill -9`）：新插入的数据不会保存在磁盘上的 RAM 块中，重启时将从二进制日志（如果有）恢复，或者丢失（如果禁用二进制日志）。\n\n## 解冻表\n\n<!-- example unfreeze -->\n\nCODE_BLOCK_3\n\n`UNFREEZE` 命令减少表的锁定计数器，如果计数器降至零，则重新激活之前被阻止的操作并恢复内部压缩服务。所有等待表解冻的操作也将恢复并正常完成。\n\n<!-- request Example -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n## 检查表的锁定状态\n\n<!-- example show_table_status -->\n\n你可以使用 `SHOW table_name STATUS` 来检查表是否被冻结。\n\n锁定计数器显示在表状态的 `locked` 列中。值为零表示表未冻结，非零值表示活动锁的数量。每个显式的 `FREEZE` 命令和隐式锁定（例如表是集群的一部分且复制例程选择它作为副本的捐赠者）都会增加计数器。每个 `UNFREEZE` 命令减少计数器，最终降至零。\n\n<!-- request Example -->\n\nCODE_BLOCK_5\n\n<!-- response Example -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n## SHOW LOCKS\n\n<!-- example show_locks -->\n\n锁定的表也可以通过 `SHOW LOCKS` 命令显示。锁计数器显示在 `Additional Info` 列中。\n\n<!-- request Example -->\n\nCODE_BLOCK_7\n\n<!-- response Example -->\n\nCODE_BLOCK_8\n\n<!-- end -->",
      "russian": "# Заморозка таблицы\n\n<!-- example freeze -->\n\nCODE_BLOCK_0\n\n`FREEZE` подготавливает таблицу реального времени/простую таблицу для безопасного [резервного копирования](../Securing_and_compacting_a_table/Backup_and_restore.md). В частности, он:\n\n1. Деактивирует сжатие таблицы. Если таблица в данный момент сжимается, `FREEZE` аккуратно прервет этот процесс.\n\n2. Переносит текущий RAM-чанк на диск.\n\n3. Сбрасывает атрибуты.\n\n4. Отключает неявные операции, которые могут изменить файлы на диске.\n\n5. Увеличивает счетчик блокировок таблицы.\n\n6. Показывает актуальный список файлов, связанных с таблицей.\n\nЕсли таблица уже заморожена (заблокирована), `FREEZE`:\n\n1. Увеличит счетчик блокировок таблицы.\n\n2. Покажет актуальный список файлов, связанных с таблицей.\n\nВстроенный инструмент [manticore-backup](../Securing_and_compacting_a_table/Backup_and_restore.md) использует `FREEZE` для обеспечения согласованности данных. Вы можете сделать то же самое, если хотите создать собственное решение для резервного копирования или нужно заморозить таблицы по другим причинам. Просто выполните следующие шаги:\n\n1. `FREEZE` таблицу (или несколько).\n\n2. Сохраните вывод команды `FREEZE` и сделайте резервную копию указанных файлов.\n\n3. `UNFREEZE` таблицу(ы) после завершения.\n\n<!-- request Example -->\n\nCODE_BLOCK_1\n\n<!-- response Example -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\nСтолбец `file` указывает пути к файлам таблицы внутри [data_dir](../Server_settings/Searchd.md#data_dir) запущенного экземпляра. Столбец `normalized` отображает абсолютные пути к тем же файлам. Чтобы сделать резервную копию таблицы, просто скопируйте указанные файлы без дополнительной подготовки.\n\nКогда таблица заморожена, выполнение запросов `UPDATE` невозможно; они будут ожидать, пока таблица не будет разморожена.\n\nТакже запросы `DELETE` и `REPLACE` имеют некоторые ограничения во время заморозки таблицы:\n\n* Если `DELETE` затрагивает документ в текущем RAM-чанке — это разрешено.\n\n* Если `DELETE` влияет на документ в дисковом чанке, но он был ранее удален — это разрешено.\n\n* Если `DELETE` изменит реальный дисковый чанк — запрос будет ждать, пока таблица не будет разморожена.\n\nРучной `FLUSH` RAM-чанка замороженной таблицы сообщит об «успехе», но реального сохранения не произойдет.\n\n`DROP`/`TRUNCATE` замороженной таблицы **разрешены**, так как эти операции не являются неявными. Предполагается, что если вы удаляете или очищаете таблицу, она вам не нужна для резервного копирования; следовательно, она изначально не должна была быть заморожена.\n\n`INSERT` в замороженную таблицу поддерживается, но с ограничениями: новые данные будут храниться в RAM (как обычно) до достижения `rt_mem_limit`; затем новые вставки будут ждать, пока таблица не будет разморожена.\n\nЕсли вы завершите работу демона с замороженной таблицей, это будет эквивалентно некорректному завершению работы (например, `kill -9`): недавно вставленные данные **не** будут сохранены в RAM-чанке на диске, и при перезапуске они будут восстановлены из бинарного лога (если он есть) или потеряны (если бинарное логирование отключено).\n\n## Разморозка таблицы\n\n<!-- example unfreeze -->\n\nCODE_BLOCK_3\n\nКоманда `UNFREEZE` уменьшает счетчик блокировок таблицы, и если он достигает нуля, повторно активирует ранее заблокированные операции и возобновляет внутреннюю службу сжатия. Все операции, ожидавшие разморозки таблицы, также возобновятся и завершатся нормально.\n\n<!-- request Example -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n## Проверка состояния блокировки таблицы\n\n<!-- example show_table_status -->\n\nВы можете использовать `SHOW table_name STATUS`, чтобы проверить, заморожена таблица или нет.\n\nСчетчик блокировок отображается в статусе таблицы в столбце `locked`. Значение ноль означает, что таблица не заморожена, а ненулевое значение отражает количество активных блокировок. Каждая явная команда `FREEZE` и неявная блокировка (например, когда таблица является частью кластера и репликационная процедура выбирает ее в качестве донора для реплики) увеличивает счетчик. Каждая команда `UNFREEZE` уменьшает счетчик, в конечном итоге до нуля.\n\n<!-- request Example -->\n\nCODE_BLOCK_5\n\n<!-- response Example -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n## SHOW LOCKS\n\n<!-- example show_locks -->\n\nЗаблокированные таблицы также отображаются с помощью команды `SHOW LOCKS`. Счетчики блокировок показаны в столбце `Additional Info`.\n\n<!-- request Example -->\n\nCODE_BLOCK_7\n\n<!-- response Example -->\n\nCODE_BLOCK_8\n\n<!-- end -->"
    },
    "is_code_or_comment": false
  }
}
