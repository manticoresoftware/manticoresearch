{
  "b21937b1d57f4f9abb2c918ed3b6582944a0a3b604001bc1210b52718d2c6e64": {
    "original": "# Freezing a table\n\n<!-- example freeze -->\n\nCODE_BLOCK_0\n\n`FREEZE` readies a real-time/plain table for a secure [backup](../Securing_and_compacting_a_table/Backup_and_restore.md). Specifically, it:\n\n1. Deactivates table compaction. If the table is currently being compacted, `FREEZE` will gracefully interrupt it.\n\n2. Transfers the current RAM chunk to a disk chunk.\n\n3. Flushes attributes.\n\n4. Disables implicit operations that could modify the disk files.\n\n5. Increments the table's locked counter.\n\n6. Shows the actual file list associated with the table.\n\nIf the table is already frozen (locked), `FREEZE` will:\n\n1. Increment the table's locked counter.\n\n2. Shows the actual file list associated with the table.\n\nThe built-in tool [manticore-backup](../Securing_and_compacting_a_table/Backup_and_restore.md) uses `FREEZE` to ensure data consistency. You can do the same if you want to create your own backup solution or need to freeze tables for other reasons. Just follow these steps:\n\n1. `FREEZE` a table (or a few).\n\n2. Capture the output of the `FREEZE` command and back up the specified files.\n\n3. `UNFREEZE` the table(s) once finished.\n\n<!-- request Example -->\n\nCODE_BLOCK_1\n\n<!-- response Example -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\nThe `file` column indicates the table's file paths within the [data_dir](../Server_settings/Searchd.md#data_dir) of the running instance. The `normalized` column displays the absolute paths for the same files. To back up a table, simply copy the provided files without additional preparation.\n\nWhen a table is frozen, you cannot execute `UPDATE` queries; they will wait until the table is unfrozen.\n\nAlso, `DELETE` and `REPLACE` queries have some restrictions while the table is frozen:\n\n* If `DELETE` affects a document in the current RAM chunk - it is permitted.\n\n* If `DELETE` impacts a document in a disk chunk but was previously deleted - it is allowed.\n\n* If `DELETE` would alter an actual disk chunk - it will wait until the table is unfrozen.\n\nManually `FLUSH`ing a RAM chunk of a frozen table will report 'success', but no real saving will occur.\n\n`DROP`/`TRUNCATE` of a frozen table **is** allowed since these operations are not implicit. We assume that if you truncate or drop a table, you don't need it backed up; therefore, it should not have been frozen initially.\n\n`INSERT`ing into a frozen table is supported but limited: new data will be stored in RAM (as usual) until `rt_mem_limit` is reached; then, new insertions will wait until the table is unfrozen.\n\nIf you shut down the daemon with a frozen table, it will act as if it experienced a dirty shutdown (e.g., `kill -9`): newly inserted data will **not** be saved in the RAM-chunk on disk, and upon restart, it will be restored from a binary log (if any) or lost (if binary logging is disabled).\n\n## Unfreezing a table\n\n<!-- example unfreeze -->\n\nCODE_BLOCK_3\n\n`UNFREEZE` command decreases the table's locked counter, and if it reaches zero, reactivates previously blocked operations and resumes the internal compaction service. Any operations that were waiting for the table to unfreeze will also resume and complete normally.\n\n<!-- request Example -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n## Inspecting the lock state of a table\n\n<!-- example show_table_status -->\n\nYou can use `SHOW table_name STATUS` to check if a table is frozen or not.\n\nThe locked counter is displayed in the table's status under the `locked` column. A value of zero indicates that the table is not frozen, while a non-zero value reflects the number of active locks. Each explicit `FREEZE` command and implicit locking (such as when the table is part of a cluster and a replication routine selects it as a donor for a replica) increases the counter. Each `UNFREEZE` command decreases the counter, eventually down to zero.\n\n<!-- request Example -->\n\nCODE_BLOCK_5\n\n<!-- response Example -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n## SHOW LOCKS\n\n<!-- example show_locks -->\n\nLocked tables are also displayed using the `SHOW LOCKS` command. The lock counters are shown in the `Additional Info` column.\n\n<!-- request Example -->\n\nCODE_BLOCK_7\n\n<!-- response Example -->\n\nCODE_BLOCK_8\n\n<!-- end -->",
    "translations": {
      "chinese": "# 冻结表\n\n<!-- example freeze -->\n\nCODE_BLOCK_0\n\n`FREEZE` 使实时/普通表准备好进行安全的[备份](../Securing_and_compacting_a_table/Backup_and_restore.md)。具体来说，它：\n\n1. 停用表压缩。如果表当前正在压缩，`FREEZE` 会优雅地中断它。\n\n2. 将当前的 RAM 块转移到磁盘块。\n\n3. 刷新属性。\n\n4. 禁用可能修改磁盘文件的隐式操作。\n\n5. 增加表的锁定计数器。\n\n6. 显示与表关联的实际文件列表。\n\n如果表已经被冻结（锁定），`FREEZE` 将：\n\n1. 增加表的锁定计数器。\n\n2. 显示与表关联的实际文件列表。\n\n内置工具 [manticore-backup](../Securing_and_compacting_a_table/Backup_and_restore.md) 使用 `FREEZE` 来确保数据一致性。如果你想创建自己的备份解决方案或因其他原因需要冻结表，也可以这样做。只需按照以下步骤：\n\n1. `FREEZE` 一个表（或几个表）。\n\n2. 捕获 `FREEZE` 命令的输出并备份指定的文件。\n\n3. 完成后 `UNFREEZE` 表。\n\n<!-- request Example -->\n\nCODE_BLOCK_1\n\n<!-- response Example -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n`file` 列指示运行实例的 [data_dir](../Server_settings/Searchd.md#data_dir) 中表的文件路径。`normalized` 列显示相同文件的绝对路径。备份表时，只需复制提供的文件，无需额外准备。\n\n当表被冻结时，不能执行 `UPDATE` 查询；它们将等待直到表解冻。\n\n此外，`DELETE` 和 `REPLACE` 查询在表冻结时有一些限制：\n\n* 如果 `DELETE` 影响当前 RAM 块中的文档 - 允许执行。\n\n* 如果 `DELETE` 影响磁盘块中的文档但之前已被删除 - 允许执行。\n\n* 如果 `DELETE` 会修改实际的磁盘块 - 将等待直到表解冻。\n\n手动对冻结表的 RAM 块执行 `FLUSH` 会报告“成功”，但不会真正保存。\n\n冻结表的 `DROP`/`TRUNCATE` **是**允许的，因为这些操作不是隐式的。我们假设如果你截断或删除表，就不需要备份它；因此，表本不应被冻结。\n\n向冻结表中 `INSERT` 是支持的，但有限制：新数据将存储在 RAM（如常）直到达到 `rt_mem_limit`；然后，新插入将等待直到表解冻。\n\n如果在表冻结时关闭守护进程，它将表现得像经历了脏关闭（例如，`kill -9`）：新插入的数据不会保存在磁盘上的 RAM 块中，重启时将从二进制日志（如果有）恢复，或者丢失（如果禁用二进制日志）。\n\n## 解冻表\n\n<!-- example unfreeze -->\n\nCODE_BLOCK_3\n\n`UNFREEZE` 命令减少表的锁定计数器，如果计数器降至零，则重新激活之前被阻止的操作并恢复内部压缩服务。所有等待表解冻的操作也将恢复并正常完成。\n\n<!-- request Example -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n## 检查表的锁定状态\n\n<!-- example show_table_status -->\n\n你可以使用 `SHOW table_name STATUS` 来检查表是否被冻结。\n\n锁定计数器显示在表状态的 `locked` 列中。值为零表示表未冻结，非零值表示活动锁的数量。每个显式的 `FREEZE` 命令和隐式锁定（例如表是集群的一部分且复制例程选择它作为副本的捐赠者）都会增加计数器。每个 `UNFREEZE` 命令减少计数器，最终降至零。\n\n<!-- request Example -->\n\nCODE_BLOCK_5\n\n<!-- response Example -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n## SHOW LOCKS\n\n<!-- example show_locks -->\n\n锁定的表也可以通过 `SHOW LOCKS` 命令显示。锁计数器显示在 `Additional Info` 列中。\n\n<!-- request Example -->\n\nCODE_BLOCK_7\n\n<!-- response Example -->\n\nCODE_BLOCK_8\n\n<!-- end -->",
      "russian": "# Заморозка таблицы\n\n<!-- example freeze -->\n\nCODE_BLOCK_0\n\n`FREEZE` подготавливает таблицу реального времени/простую таблицу для безопасного [резервного копирования](../Securing_and_compacting_a_table/Backup_and_restore.md). В частности, он:\n\n1. Деактивирует сжатие таблицы. Если таблица в данный момент сжимается, `FREEZE` аккуратно прервет этот процесс.\n\n2. Переносит текущий RAM-чанк на диск.\n\n3. Сбрасывает атрибуты.\n\n4. Отключает неявные операции, которые могут изменить файлы на диске.\n\n5. Увеличивает счетчик блокировок таблицы.\n\n6. Показывает актуальный список файлов, связанных с таблицей.\n\nЕсли таблица уже заморожена (заблокирована), `FREEZE`:\n\n1. Увеличит счетчик блокировок таблицы.\n\n2. Покажет актуальный список файлов, связанных с таблицей.\n\nВстроенный инструмент [manticore-backup](../Securing_and_compacting_a_table/Backup_and_restore.md) использует `FREEZE` для обеспечения согласованности данных. Вы можете сделать то же самое, если хотите создать собственное решение для резервного копирования или нужно заморозить таблицы по другим причинам. Просто выполните следующие шаги:\n\n1. `FREEZE` таблицу (или несколько).\n\n2. Сохраните вывод команды `FREEZE` и сделайте резервную копию указанных файлов.\n\n3. `UNFREEZE` таблицу(ы) после завершения.\n\n<!-- request Example -->\n\nCODE_BLOCK_1\n\n<!-- response Example -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\nСтолбец `file` указывает пути к файлам таблицы внутри [data_dir](../Server_settings/Searchd.md#data_dir) запущенного экземпляра. Столбец `normalized` отображает абсолютные пути к тем же файлам. Чтобы сделать резервную копию таблицы, просто скопируйте указанные файлы без дополнительной подготовки.\n\nКогда таблица заморожена, выполнение запросов `UPDATE` невозможно; они будут ожидать, пока таблица не будет разморожена.\n\nТакже запросы `DELETE` и `REPLACE` имеют некоторые ограничения во время заморозки таблицы:\n\n* Если `DELETE` затрагивает документ в текущем RAM-чанке — это разрешено.\n\n* Если `DELETE` влияет на документ в дисковом чанке, но он был ранее удален — это разрешено.\n\n* Если `DELETE` изменит реальный дисковый чанк — запрос будет ждать, пока таблица не будет разморожена.\n\nРучной `FLUSH` RAM-чанка замороженной таблицы сообщит об «успехе», но реального сохранения не произойдет.\n\n`DROP`/`TRUNCATE` замороженной таблицы **разрешены**, так как эти операции не являются неявными. Предполагается, что если вы удаляете или очищаете таблицу, она вам не нужна для резервного копирования; следовательно, она изначально не должна была быть заморожена.\n\n`INSERT` в замороженную таблицу поддерживается, но с ограничениями: новые данные будут храниться в RAM (как обычно) до достижения `rt_mem_limit`; затем новые вставки будут ждать, пока таблица не будет разморожена.\n\nЕсли вы завершите работу демона с замороженной таблицей, это будет эквивалентно некорректному завершению работы (например, `kill -9`): недавно вставленные данные **не** будут сохранены в RAM-чанке на диске, и при перезапуске они будут восстановлены из бинарного лога (если он есть) или потеряны (если бинарное логирование отключено).\n\n## Разморозка таблицы\n\n<!-- example unfreeze -->\n\nCODE_BLOCK_3\n\nКоманда `UNFREEZE` уменьшает счетчик блокировок таблицы, и если он достигает нуля, повторно активирует ранее заблокированные операции и возобновляет внутреннюю службу сжатия. Все операции, ожидавшие разморозки таблицы, также возобновятся и завершатся нормально.\n\n<!-- request Example -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n## Проверка состояния блокировки таблицы\n\n<!-- example show_table_status -->\n\nВы можете использовать `SHOW table_name STATUS`, чтобы проверить, заморожена таблица или нет.\n\nСчетчик блокировок отображается в статусе таблицы в столбце `locked`. Значение ноль означает, что таблица не заморожена, а ненулевое значение отражает количество активных блокировок. Каждая явная команда `FREEZE` и неявная блокировка (например, когда таблица является частью кластера и репликационная процедура выбирает ее в качестве донора для реплики) увеличивает счетчик. Каждая команда `UNFREEZE` уменьшает счетчик, в конечном итоге до нуля.\n\n<!-- request Example -->\n\nCODE_BLOCK_5\n\n<!-- response Example -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n## SHOW LOCKS\n\n<!-- example show_locks -->\n\nЗаблокированные таблицы также отображаются с помощью команды `SHOW LOCKS`. Счетчики блокировок показаны в столбце `Additional Info`.\n\n<!-- request Example -->\n\nCODE_BLOCK_7\n\n<!-- response Example -->\n\nCODE_BLOCK_8\n\n<!-- end -->"
    },
    "is_code_or_comment": false
  },
  "d02258384bbae880781bf6c276253e722554d58e6164f11e482b112b50b0c154": {
    "original": "2. Checks if table is suitable for lock. It must be local rt or percolate table. It must not be part of a cluster.\n\n3. Implicitly releases any table locks held by the current session.\n\n4. Waits all currently running changes (inserts/replaces/updates) are finished.\n\n5. Increments the table's read locked counter.\n\nModifier statements, like insert/replace/update/delete, first check if table is read locked. In this case they will be rejected with error \"table is locked\".\n\nWrite lock:\n\n1. Checks if current connection proto is mysql.\n\n2. Does not check if table suitable, or even if it exists or not.\n\n3. Implicitly releases any table locks held by the current session.\n\n4. Fires a warning \"Write lock is not implemented.\"\n\n<!-- request Example -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n## Table lock release\n\n<!-- example unlock -->\n\nCODE_BLOCK_9\n\n`UNLOCK` command explicitly releases any table locks held by the current sphinxql session.\n\nIf the connection for a client session terminates, whether normally or abnormally, the daemon implicitly releases all\n\ntable locks held by the session. If the client reconnects, the locks are no longer in effect.\n\n<!-- request Example -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n## SHOW LOCKS\n\n<!-- example show_locks -->\n\nLocked and frozen tables are also displayed using the `SHOW LOCKS` command. The lock counters are shown in the `Additional Info` column.\n\n<!-- request Example -->\n\nCODE_BLOCK_11\n\n<!-- response Example -->\n\nCODE_BLOCK_12\n\n<!-- end -->",
    "translations": {
      "chinese": "2. 检查表是否适合加锁。它必须是本地 rt 表或 percolate 表。它不能是集群的一部分。\n\n3. 隐式释放当前会话持有的任何表锁。\n\n4. 等待所有当前运行的更改（插入/替换/更新）完成。\n\n5. 增加表的读锁计数器。\n\n修改语句，如 insert/replace/update/delete，首先检查表是否处于读锁状态。若是，将被拒绝并出现错误“table is locked”。\n\n写锁：\n\n1. 检查当前连接协议是否为 mysql。\n\n2. 不检查表是否适合，甚至不检查表是否存在。\n\n3. 隐式释放当前会话持有的任何表锁。\n\n4. 触发警告“Write lock is not implemented.”\n\n<!-- request Example -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n## 表锁释放\n\n<!-- example unlock -->\n\nCODE_BLOCK_9\n\n`UNLOCK` 命令显式释放当前 sphinxql 会话持有的任何表锁。\n\n如果客户端会话的连接终止，无论是正常还是异常，守护进程都会隐式释放该会话持有的所有\n\n表锁。如果客户端重新连接，锁将不再生效。\n\n<!-- request Example -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n## SHOW LOCKS\n\n<!-- example show_locks -->\n\n使用 `SHOW LOCKS` 命令也可以显示被锁定和冻结的表。锁计数器显示在 `Additional Info` 列。\n\n<!-- request Example -->\n\nCODE_BLOCK_11\n\n<!-- response Example -->\n\nCODE_BLOCK_12\n\n<!-- end -->",
      "russian": "2. Проверяет, подходит ли таблица для блокировки. Она должна быть локальной rt или percolate таблицей. Не должна быть частью кластера.\n\n3. Неявно освобождает любые блокировки таблиц, удерживаемые текущей сессией.\n\n4. Ожидает завершения всех текущих изменений (вставок/замен/обновлений).\n\n5. Увеличивает счетчик блокировок на чтение таблицы.\n\nОператоры изменения, такие как insert/replace/update/delete, сначала проверяют, заблокирована ли таблица на чтение. В таком случае они будут отклонены с ошибкой \"table is locked\".\n\nБлокировка на запись:\n\n1. Проверяет, что протокол текущего соединения mysql.\n\n2. Не проверяет, подходит ли таблица или даже существует ли она.\n\n3. Неявно освобождает любые блокировки таблиц, удерживаемые текущей сессией.\n\n4. Выдает предупреждение \"Write lock is not implemented.\"\n\n<!-- request Example -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n## Снятие блокировки таблицы\n\n<!-- example unlock -->\n\nCODE_BLOCK_9\n\nКоманда `UNLOCK` явно снимает любые блокировки таблиц, удерживаемые текущей сессией sphinxql.\n\nЕсли соединение клиентской сессии прерывается, независимо от того, нормально или ненормально, демон неявно снимает все\n\nблокировки таблиц, удерживаемые сессией. Если клиент повторно подключается, блокировки больше не действуют.\n\n<!-- request Example -->\n\nCODE_BLOCK_10\n\n<!-- end -->\n\n## SHOW LOCKS\n\n<!-- example show_locks -->\n\nЗаблокированные и замороженные таблицы также отображаются с помощью команды `SHOW LOCKS`. Счетчики блокировок показываются в столбце `Additional Info`.\n\n<!-- request Example -->\n\nCODE_BLOCK_11\n\n<!-- response Example -->\n\nCODE_BLOCK_12\n\n<!-- end -->"
    },
    "is_code_or_comment": false
  },
  "e923f505067ff933be63bcf1f415408a38efd388f770c34539c141a909d12119": {
    "original": "# Freezing and locking a table\n\n`Freezing` a table is useful for physical copy/backup. It 'freezes' files belonging to a table, and display where they are located. After freezing, you can safely back up files to other location. You can still insert new documents into frozen tables, up to reaching rt_mem_limit, but this data will be accumulated in RAM and will not be saved to disk, until table is unfrozen. If you exceed rt_mem_limit, changes will be paused until table is unfrozen. If daemon unexpectedly terminates, unsaved data will be restored from binlog.\n\nA complement `locking` a table is useful for logical backup. It doesn't affect any current internal reorganization, like optimize, saving ram chunk to disk, etc. Instead, it just prohibits any modifying ops. That is - you can't insert/replace/update data into locked table. That is useful for tools like mysqldump. By locking a table it ensures data is logically consistent. For example if you replace a document during dumping, it might happen, that previous version is already in the dump, and new version also appears at the end, with same document ID. By locking a table you can be sure, such case will not happen.\n\n## Freezing a table\n\n<!-- example freeze -->\n\nCODE_BLOCK_0\n\n`FREEZE` readies a real-time/plain table for a secure [backup](../Securing_and_compacting_a_table/Backup_and_restore.md). Specifically, it:\n\n1. Deactivates table compaction. If the table is currently being compacted, `FREEZE` will gracefully interrupt it.\n\n2. Transfers the current RAM chunk to a disk chunk.\n\n3. Flushes attributes.\n\n4. Disables implicit operations that could modify the disk files.\n\n5. Increments the table's locked counter.\n\n6. Shows the actual file list associated with the table.\n\nIf the table is already frozen (locked), `FREEZE` will:\n\n1. Increment the table's locked counter.\n\n2. Shows the actual file list associated with the table.\n\nThe built-in tool [manticore-backup](../Securing_and_compacting_a_table/Backup_and_restore.md) uses `FREEZE` to ensure data consistency. You can do the same if you want to create your own backup solution or need to freeze tables for other reasons. Just follow these steps:\n\n1. `FREEZE` a table (or a few).\n\n2. Capture the output of the `FREEZE` command and back up the specified files.\n\n3. `UNFREEZE` the table(s) once finished.\n\n<!-- request Example -->\n\nCODE_BLOCK_1\n\n<!-- response Example -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\nThe `file` column indicates the table's file paths within the [data_dir](../Server_settings/Searchd.md#data_dir) of the running instance. The `normalized` column displays the absolute paths for the same files. To back up a table, simply copy the provided files without additional preparation.\n\nWhen a table is frozen, you cannot execute `UPDATE` queries; they will wait until the table is unfrozen.\n\nAlso, `DELETE` and `REPLACE` queries have some restrictions while the table is frozen:\n\n* If `DELETE` affects a document in the current RAM chunk - it is permitted.\n\n* If `DELETE` impacts a document in a disk chunk but was previously deleted - it is allowed.\n\n* If `DELETE` would alter an actual disk chunk - it will wait until the table is unfrozen.\n\nManually `FLUSH`ing a RAM chunk of a frozen table will report 'success', but no real saving will occur.\n\n`DROP`/`TRUNCATE` of a frozen table **is** allowed since these operations are not implicit. We assume that if you truncate or drop a table, you don't need it backed up; therefore, it should not have been frozen initially.\n\n`INSERT`ing into a frozen table is supported but limited: new data will be stored in RAM (as usual) until `rt_mem_limit` is reached; then, new insertions will wait until the table is unfrozen.\n\nIf you shut down the daemon with a frozen table, it will act as if it experienced a dirty shutdown (e.g., `kill -9`): newly inserted data will **not** be saved in the RAM-chunk on disk, and upon restart, it will be restored from a binary log (if any) or lost (if binary logging is disabled).\n\n## Unfreezing a table\n\n<!-- example unfreeze -->\n\nCODE_BLOCK_3\n\n`UNFREEZE` command decreases the table's locked counter, and if it reaches zero, reactivates previously blocked operations and resumes the internal compaction service. Any operations that were waiting for the table to unfreeze will also resume and complete normally.\n\n<!-- request Example -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n## Inspecting the lock state of a table\n\n<!-- example show_table_status -->\n\nYou can use `SHOW table_name STATUS` to check if a table is frozen or not.\n\nThe locked counter is displayed in the table's status under the `locked` column. A value of zero indicates that the\n\ntable is not frozen, while a non-zero value reflects the number of active locks. Each explicit `FREEZE` command and\n\nimplicit locking (such as when the table is part of a cluster and a replication routine selects it as a donor for a\n\nreplica) increases the counter. Each `UNFREEZE` command decreases the counter, eventually down to zero.\n\n<!-- request Example -->\n\nCODE_BLOCK_5\n\n<!-- response Example -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n## Table Lock Acquisition\n\n<!-- example lock -->\n\nCODE_BLOCK_7\n\nManticore enables sphinxql client sessions to acquire table locks explicitly for the purpose of cooperating with other sessions for access to tables, or to prevent other sessions from modifying tables during periods when a session requires exclusive access to them. A sphinxql session can acquire or release locks only for itself. One session cannot acquire locks for another session or release locks held by another session. Locks may be acquired and released only in sphinxql sessions, connected by mysql proto, however you can't modify data in locked tables by any proto. Also, locks are not available for tables in cluster. That is because if we reject changes came from cluster to locked table, whole cluster may be stalled, or even damaged.\n\nManticore implements only read (shared) locks. Write (exclusive) locks are not implemented.\n\nRead lock:\n\n1. Checks if current connection proto is mysql.",
    "translations": {
      "chinese": "# 冻结和锁定表\n\n`冻结`表对于物理备份/复制非常有用。它“冻结”属于表的文件，并显示它们的位置。冻结后，您可以安全地备份文件到其他位置。您仍然可以向冻结表插入新文档，直到达到rt_mem_limit，但这些数据将积累在内存中，不会保存到磁盘，直到表被解冻。如果超过rt_mem_limit，更改将暂停，直到表被解冻。如果守护进程意外终止，未保存的数据将从binlog中恢复。\n\n补充的`锁定`表对逻辑备份非常有用。它不会影响当前的内部重组操作，如优化，内存块写入磁盘等。相反，它仅禁止任何修改操作。也就是说，您无法向锁定表插入/替换/更新数据。这对类似mysqldump的工具很有用。通过锁定表，可以确保数据逻辑一致。例如，如果在导出期间替换文档，可能会发生旧版本已经在导出中，而新版本也出现在末尾，且具有相同的文档ID。通过锁定表，您可以确保这种情况不会发生。\n\n## 冻结表\n\n<!-- example freeze -->\n\nCODE_BLOCK_0\n\n`FREEZE` 命令使实时/纯表为安全的[备份](../Securing_and_compacting_a_table/Backup_and_restore.md)做好准备。具体来说，它执行：\n\n1. 停用表压缩。如果表当前正在压缩，`FREEZE`会优雅地中断该过程。\n\n2. 将当前的内存块转移到磁盘块。\n\n3. 刷新属性。\n\n4. 禁用可能修改磁盘文件的隐式操作。\n\n5. 表的锁定计数器加一。\n\n6. 显示与表关联的实际文件列表。\n\n如果表已经被冻结（锁定），`FREEZE`将：\n\n1. 表的锁定计数器加一。\n\n2. 显示与表关联的实际文件列表。\n\n内置工具[manticore-backup](../Securing_and_compacting_a_table/Backup_and_restore.md)使用`FREEZE`确保数据一致性。如果您想自己创建备份解决方案或因其他原因需要冻结表，也可以这样做。只需按照以下步骤：\n\n1. 对一张（或多张）表执行`FREEZE`。\n\n2. 捕获`FREEZE`命令的输出，备份指定的文件。\n\n3. 备份完成后执行`UNFREEZE`解冻表。\n\n<!-- request Example -->\n\nCODE_BLOCK_1\n\n<!-- response Example -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n`file`列指示正在运行的实例的[data_dir](../Server_settings/Searchd.md#data_dir)中表的文件路径。`normalized`列显示相同文件的绝对路径。要备份表，只需复制提供的文件即可，无需额外准备。\n\n表冻结时，无法执行`UPDATE`查询；它们将等待直到表解冻。\n\n此外，冻结表时`DELETE`和`REPLACE`查询有一些限制：\n\n* 如果`DELETE`影响当前内存块中的文档 - 允许。\n\n* 如果`DELETE`影响磁盘块中但之前已删除的文档 - 允许。\n\n* 如果`DELETE`影响实际磁盘块 - 将等待直到表解冻。\n\n手动对冻结表的内存块执行`FLUSH`会报告“成功”，但不会进行实际保存。\n\n冻结表的`DROP`/`TRUNCATE`操作**是**允许的，因为这些操作不是隐式的。我们假设如果您截断或删除表，则不需要备份，因此表最初不应该被冻结。\n\n向冻结表中`INSERT`是支持的，但有限制：新数据将保存在内存中（如常规情况）直到达到`rt_mem_limit`；然后，新的插入将等待直到表解冻。\n\n如果您在表冻结时关闭守护进程，它将表现得像脏关闭（例如，`kill -9`）：新插入的数据**不会**保存在磁盘上的内存块中，重新启动后将从二进制日志（如果有）恢复，否则将丢失（如果禁用二进制日志）。\n\n## 解冻表\n\n<!-- example unfreeze -->\n\nCODE_BLOCK_3\n\n`UNFREEZE`命令减少表的锁定计数器，如果计数器达到零，将重新激活之前被阻止的操作，并恢复内部压缩服务。任何等待表解冻的操作也将恢复并正常完成。\n\n<!-- request Example -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n## 查看表的锁定状态\n\n<!-- example show_table_status -->\n\n您可以使用`SHOW table_name STATUS`检查表是否被冻结。\n\n锁定计数器显示在表状态的`locked`列中。值为零表示表未冻结，非零值表明有活动锁。每次显式的`FREEZE`命令以及隐式锁定（例如表是集群的一部分且复制例程选择它作为副本的捐赠者）都会增加计数器。每次`UNFREEZE`命令会减少计数器，最终降至零。\n\n<!-- request Example -->\n\nCODE_BLOCK_5\n\n<!-- response Example -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n## 表锁获取\n\n<!-- example lock -->\n\nCODE_BLOCK_7\n\nManticore允许sphinxql客户端会话显式获取表锁，以便与其他会话协作访问表，或防止其他会话在会话需要独占访问期间修改表。sphinxql会话只能为自己获取或释放锁。一个会话不能为另一个会话获取锁或释放另一个会话持有的锁。锁只能在通过mysql协议连接的sphinxql会话中获取和释放，但您无法通过任何协议修改被锁定表中的数据。此外，锁不可用于集群中的表。因为如果我们拒绝来自集群的对锁定表的修改，整个集群可能会被阻塞甚至损坏。\n\nManticore仅实现读取（共享）锁。不支持写入（排他）锁。\n\n读锁：\n\n1. 检查当前连接协议是否为mysql。",
      "russian": "# Заморозка и блокировка таблицы\n\n`Заморозка` таблицы полезна для создания физической копии/резервной копии. Она «замораживает» файлы, принадлежащие таблице, и отображает, где они расположены. После заморозки вы можете безопасно скопировать файлы в другое место. Вы все еще можете вставлять новые документы в замороженные таблицы, пока не достигнете rt_mem_limit, но эти данные будут накапливаться в оперативной памяти и не будут сохраняться на диск, пока таблица не будет разморожена. Если вы превысите rt_mem_limit, изменения будут приостановлены до разморозки таблицы. Если демон неожиданно завершит работу, несохранённые данные будут восстановлены из binlog.\n\nДополняющая `блокировка` таблицы полезна для логического резервного копирования. Она не влияет на текущую внутреннюю реорганизацию, такую как оптимизация, сохранение RAM-чанкa на диск и т.д. Вместо этого она просто запрещает любые операции модификации. То есть вы не можете вставлять/заменять/обновлять данные в заблокированной таблице. Это полезно для таких инструментов, как mysqldump. Блокируя таблицу, вы обеспечиваете логическую целостность данных. Например, если вы замените документ во время дампа, может случиться так, что предыдущая версия уже есть в дампе, а новая версия появляется в конце, с тем же ID документа. Заблокировав таблицу, вы можете быть уверены, что такого случая не произойдет.\n\n## Заморозка таблицы\n\n<!-- example freeze -->\n\nCODE_BLOCK_0\n\n`FREEZE` подготавливает таблицу real-time/plain для безопасного [резервного копирования](../Securing_and_compacting_a_table/Backup_and_restore.md). В частности, он:\n\n1. Деактивирует компактизацию таблицы. Если таблица в данный момент компактизируется, `FREEZE` корректно прервет этот процесс.\n\n2. Переносит текущий RAM-чанк в диск-чанк.\n\n3. Сбрасывает атрибуты.\n\n4. Отключает неявные операции, которые могут изменить файлы на диске.\n\n5. Увеличивает счетчик блокировок таблицы.\n\n6. Показывает текущий список файлов, связанных с таблицей.\n\nЕсли таблица уже заморожена (заблокирована), `FREEZE` выполнит:\n\n1. Увеличение счетчика блокировок таблицы.\n\n2. Показ текущего списка файлов, связанных с таблицей.\n\nВстроенный инструмент [manticore-backup](../Securing_and_compacting_a_table/Backup_and_restore.md) использует `FREEZE` для обеспечения консистентности данных. Вы можете поступать так же, если хотите создать собственное решение резервного копирования или нужно заморозить таблицы по другим причинам. Просто выполните следующие шаги:\n\n1. `FREEZE` одну или несколько таблиц.\n\n2. Захватите вывод команды `FREEZE` и сделайте резервную копию указанных файлов.\n\n3. Выполните `UNFREEZE` для таблицы(ц) после окончания.\n\n<!-- request Example -->\n\nCODE_BLOCK_1\n\n<!-- response Example -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\nСтолбец `file` указывает пути файлов таблицы в [data_dir](../Server_settings/Searchd.md#data_dir) запущенного экземпляра. Столбец `normalized` показывает абсолютные пути для тех же файлов. Чтобы создать резервную копию таблицы, просто скопируйте указанные файлы без дополнительной подготовки.\n\nКогда таблица заморожена, выполнить запросы `UPDATE` невозможно; они будут ожидать, пока таблица не будет разморожена.\n\nТакже у запросов `DELETE` и `REPLACE` есть некоторые ограничения при замороженной таблице:\n\n* Если `DELETE` затрагивает документ в текущем RAM-чанке — это разрешено.\n\n* Если `DELETE` касается документа в диск-чанке, но документ уже был удалён — это разрешено.\n\n* Если `DELETE` изменит фактический диск-чанк — запрос будет ожидать, пока таблица не будет разморожена.\n\nРучной `FLUSH` RAM-чанка замороженной таблицы вернет успех, но реального сохранения не произойдет.\n\n`DROP`/`TRUNCATE` замороженной таблицы **разрешены**, поскольку эти операции не являются неявными. Мы предполагаем, что если вы удаляете или усечете таблицу, она вам не нужна в резервной копии, и поэтому изначально она не должна была быть заморожена.\n\n`INSERT` в замороженную таблицу поддерживается, но с ограничениями: новые данные будут храниться в ОЗУ (как обычно) до достижения `rt_mem_limit`; затем новые вставки будут ждать, пока таблица не будет разморожена.\n\nЕсли вы завершите работу демона при замороженной таблице, он поведет себя, будто произошло грязное завершение (например, с помощью `kill -9`): недавно вставленные данные **не** будут сохранены в RAM-чанк на диске, и при перезапуске они будут восстановлены из binlog (если он включён) или потеряны (если бинарное логирование отключено).\n\n## Разморозка таблицы\n\n<!-- example unfreeze -->\n\nCODE_BLOCK_3\n\nКоманда `UNFREEZE` уменьшает счетчик блокировок таблицы, и если он достигает нуля, реактивирует ранее заблокированные операции и возобновляет внутреннюю службу компактации. Все операции, ожидавшие разморозки таблицы, также возобновятся и завершатся нормально.\n\n<!-- request Example -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n## Проверка состояния блокировки таблицы\n\n<!-- example show_table_status -->\n\nВы можете использовать `SHOW table_name STATUS`, чтобы проверить, заморожена таблица или нет.\n\nСчетчик блокировок отображается в статусе таблицы в столбце `locked`. Значение ноль означает, что\n\nтаблица не заморожена, а ненулевое значение отражает количество активных блокировок. Каждая явная команда `FREEZE` и\n\nнеявная блокировка (например, когда таблица входит в кластер и используется рутиной репликации как донор для\n\nреплики) увеличивает счетчик. Каждая команда `UNFREEZE` уменьшает счетчик до достижения нуля.\n\n<!-- request Example -->\n\nCODE_BLOCK_5\n\n<!-- response Example -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n## Получение блокировки таблицы\n\n<!-- example lock -->\n\nCODE_BLOCK_7\n\nManticore позволяет клиентским сессиям sphinxql явно получать блокировки таблиц, чтобы взаимодействовать с другими сессиями для доступа к таблицам или предотвращать изменение таблиц другими сессиями во время эксклюзивного доступа. Сессия sphinxql может получить или освободить блокировки только для себя. Одна сессия не может получить или освободить блокировки, принадлежащие другой сессии. Блокировки могут быть получены и освобождены только в сессиях sphinxql, подключённых по протоколу mysql, однако вы не можете изменять данные в заблокированных таблицах через любой протокол. Также блокировки недоступны для таблиц в кластере. Это связано с тем, что если мы отклоним изменения, поступающие из кластера в заблокированную таблицу, весь кластер может зависнуть или даже повредиться.\n\nManticore реализует только разделяемые блокировки (read). Исключительные блокировки (write) не реализованы.\n\nЧтение блокировки:\n\n1. Проверяет, что текущий протокол подключения — mysql."
    },
    "is_code_or_comment": false
  }
}
