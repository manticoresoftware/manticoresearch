{
  "3a903db4a6873be526f34f45a516ac74486a3f11df55505ab5b9d33107866d76": {
    "original": "4. Waits for all ongoing insert, replace, update, or delete operations on the table to finish.\n\n5. Increases the table's read-lock counter (see [SHOW LOCKS](Freezing_and_locking_a_table.md#SHOW-LOCKS)).\n\nAny modifying statement (insert/replace/update/delete) first checks if a table is read-locked. If it is, the statement fails with the error `table is locked`.\n\n<!-- request Example -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n## UNLOCK TABLES\n\n<!-- example unlock -->\n\n`UNLOCK TABLES` command explicitly releases any table locks held by the current SQL session.\n\nIf the connection for a client session terminates, whether normally or abnormally, the daemon implicitly releases all\n\ntable locks held by the session. If the client reconnects, the locks are no longer in effect.\n\n<!-- request Example -->\n\nCODE_BLOCK_9\n\n<!-- end -->\n\n## SHOW LOCKS\n\n<!-- example show_locks -->\n\nThe `SHOW LOCKS` command lists all tables that are currently locked or frozen.  \n\nEach row shows the table type, its name, the kind of lock it has, and a counter that indicates how many times that lock was applied.\n\n**Lock Type** can be:\n\n- `read` — the table is protected by a read lock. Modifying statements will fail until the lock is released.\n\n- `freeze` — the table is frozen. This stops any operation that would write data to disk until the table is unfrozen.\n\n<!-- request Example -->\n\nCODE_BLOCK_10\n\n<!-- response Example -->\n\nCODE_BLOCK_11\n\n<!-- end -->",
    "translations": {
      "chinese": "4. 等待表上所有正在进行的插入、替换、更新或删除操作完成。\n\n5. 增加表的读锁计数器（参见 [SHOW LOCKS](Freezing_and_locking_a_table.md#SHOW-LOCKS)）。\n\n任何修改语句（插入/替换/更新/删除）首先检查表是否被读锁定。如果是，语句将失败并返回错误 `table is locked`。\n\n<!-- request Example -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n## UNLOCK TABLES\n\n<!-- example unlock -->\n\n`UNLOCK TABLES` 命令显式释放当前 SQL 会话持有的任何表锁。\n\n如果客户端会话的连接终止，无论是正常还是异常，守护进程都会隐式释放该会话持有的所有表锁。如果客户端重新连接，这些锁将不再生效。\n\n<!-- request Example -->\n\nCODE_BLOCK_9\n\n<!-- end -->\n\n## SHOW LOCKS\n\n<!-- example show_locks -->\n\n`SHOW LOCKS` 命令列出当前被锁定或冻结的所有表。\n\n每行显示表类型、表名、锁的类型以及一个计数器，指示该锁被应用的次数。\n\n**锁类型** 可以是：\n\n- `read` — 表被读锁保护。在锁释放之前，修改语句将失败。\n\n- `freeze` — 表被冻结。这会阻止任何将数据写入磁盘的操作，直到表被解冻。\n\n<!-- request Example -->\n\nCODE_BLOCK_10\n\n<!-- response Example -->\n\nCODE_BLOCK_11\n\n<!-- end -->",
      "russian": "4. Ожидает завершения всех текущих операций вставки, замены, обновления или удаления в таблице.\n\n5. Увеличивает счетчик блокировок на чтение таблицы (см. [SHOW LOCKS](Freezing_and_locking_a_table.md#SHOW-LOCKS)).\n\nЛюбое изменяющее выражение (insert/replace/update/delete) сначала проверяет, заблокирована ли таблица на чтение. Если да, выражение завершается с ошибкой `table is locked`.\n\n<!-- request Example -->\n\nCODE_BLOCK_8\n\n<!-- end -->\n\n## UNLOCK TABLES\n\n<!-- example unlock -->\n\nКоманда `UNLOCK TABLES` явно снимает любые блокировки таблиц, удерживаемые текущей SQL-сессией.\n\nЕсли соединение для клиентской сессии завершается, нормально или ненормально, демон неявно снимает все\n\nблокировки таблиц, удерживаемые сессией. Если клиент переподключается, блокировки больше не действуют.\n\n<!-- request Example -->\n\nCODE_BLOCK_9\n\n<!-- end -->\n\n## SHOW LOCKS\n\n<!-- example show_locks -->\n\nКоманда `SHOW LOCKS` выводит список всех таблиц, которые в данный момент заблокированы или заморожены.  \n\nКаждая строка показывает тип таблицы, ее имя, вид блокировки и счетчик, указывающий, сколько раз эта блокировка была применена.\n\n**Тип блокировки** может быть:\n\n- `read` — таблица защищена блокировкой на чтение. Изменяющие выражения будут завершаться с ошибкой, пока блокировка не будет снята.\n\n- `freeze` — таблица заморожена. Это останавливает любые операции, которые записывают данные на диск, пока таблица не будет разморожена.\n\n<!-- request Example -->\n\nCODE_BLOCK_10\n\n<!-- response Example -->\n\nCODE_BLOCK_11\n\n<!-- end -->"
    },
    "is_code_or_comment": false
  },
  "d660c33a04c04f4add310aec65548d4091add35a35a17333eb1b9b2104d72278": {
    "original": "# Freezing and locking a table\n\n\"Freezing\" a table is useful when you want to make a physical copy or backup. It marks the table's files as frozen and shows where they are stored. After freezing, you can safely copy these files elsewhere. You can still add new documents to a frozen table until it reaches `rt_mem_limit`, but that new data stays in memory and is not written to disk until the table is unfrozen. If the table exceeds `rt_mem_limit`, all changes pause until it is unfrozen. If the daemon stops unexpectedly, any unsaved data is restored from the binlog.\n\n\"Locking\" a table is useful for logical backups. It doesn't stop internal maintenance tasks, such as disk chunk merging operations or writing a RAM chunk to disk. It only blocks write operations. This means you can’t insert, replace, or update data in a locked table. This is helpful for tools like `mysqldump`, because locking ensures the data stays logically consistent. For example, without a lock, if you replace a document during a dump, the old version might already be in the dump and the new version might also appear later, both with the same document ID. Locking a table prevents that situation.\n\n## Freezing a table\n\n<!-- example freeze -->\n\nCODE_BLOCK_0\n\n`FREEZE` readies a real-time/plain table for a secure [backup](../Securing_and_compacting_a_table/Backup_and_restore.md). Specifically, it:\n\n1. Deactivates table compaction. If the table is currently being compacted, `FREEZE` will gracefully interrupt it.\n\n2. Transfers the current RAM chunk to a disk chunk.\n\n3. Flushes attributes.\n\n4. Disables implicit operations that could modify the disk files.\n\n5. Increments the table's locked counter.\n\n6. Shows the actual file list associated with the table.\n\nIf the table is already frozen (locked), `FREEZE` will:\n\n1. Increment the table's locked counter.\n\n2. Shows the actual file list associated with the table.\n\nThe built-in tool [manticore-backup](../Securing_and_compacting_a_table/Backup_and_restore.md) uses `FREEZE` to ensure data consistency. You can do the same if you want to create your own backup solution or need to freeze tables for other reasons. Just follow these steps:\n\n1. `FREEZE` a table (or a few).\n\n2. Capture the output of the `FREEZE` command and back up the specified files.\n\n3. `UNFREEZE` the table(s) once finished.\n\n<!-- request Example -->\n\nCODE_BLOCK_1\n\n<!-- response Example -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\nThe `file` column indicates the table's file paths within the [data_dir](../Server_settings/Searchd.md#data_dir) of the running instance. The `normalized` column displays the absolute paths for the same files. To back up a table, simply copy the provided files without additional preparation.\n\nWhen a table is frozen, you cannot execute `UPDATE` queries; they will wait until the table is unfrozen.\n\nAlso, `DELETE` and `REPLACE` queries have some restrictions while the table is frozen:\n\n* If `DELETE` affects a document in the current RAM chunk - it is permitted.\n\n* If `DELETE` impacts a document in a disk chunk but was previously deleted - it is allowed.\n\n* If `DELETE` would alter an actual disk chunk - it will wait until the table is unfrozen.\n\nManually `FLUSH`ing a RAM chunk of a frozen table will report 'success', but no real saving will occur.\n\n`DROP`/`TRUNCATE` of a frozen table **is** allowed since these operations are not implicit. We assume that if you truncate or drop a table, you don't need it backed up; therefore, it should not have been frozen initially.\n\n`INSERT`ing into a frozen table is supported but limited: new data will be stored in RAM (as usual) until `rt_mem_limit` is reached; then, new insertions will wait until the table is unfrozen.\n\nIf you shut down the daemon with a frozen table, it will act as if it experienced a dirty shutdown (e.g., `kill -9`): newly inserted data will **not** be saved in the RAM-chunk on disk, and upon restart, it will be restored from a binary log (if any) or lost (if binary logging is disabled).\n\n## Unfreezing a table\n\n<!-- example unfreeze -->\n\nCODE_BLOCK_3\n\n`UNFREEZE` command decreases the table's locked counter, and if it reaches zero, reactivates previously blocked operations and resumes the internal compaction service. Any operations that were waiting for the table to unfreeze will also resume and complete normally.\n\n<!-- request Example -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n## Inspecting the lock state of a table\n\n<!-- example show_table_status -->\n\nYou can use `SHOW table_name STATUS` to check if a table is frozen or not.\n\nThe locked counter is displayed in the table's status under the `locked` column. A value of zero indicates that the table is not frozen, while a non-zero value reflects the number of active locks. Each explicit `FREEZE` command and implicit locking (such as when the table is part of a cluster and a replication routine selects it as a donor for a replica) increases the counter. Each `UNFREEZE` command decreases the counter, eventually down to zero.\n\n<!-- request Example -->\n\nCODE_BLOCK_5\n\n<!-- response Example -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n## Locking a table\n\n<!-- example lock -->\n\nCODE_BLOCK_7\n\nYou can explicitly lock tables in an SQL client session to coordinate access with other sessions or to stop other sessions from changing data while you need exclusive access. A session can only lock or unlock tables for itself. It cannot lock or unlock tables on behalf of another session. Locks can be used only in SQL sessions connected through the MySQL protocol. While a table is locked, no protocol is allowed to change its data (SQL / HTTP / binary). Locks also don't work for tables that belong to a replication cluster.\n\nManticore supports only **read (shared)** locks. **Write (exclusive)** locks are not supported.\n\nWhen a session requests a read lock, Manticore:\n\n1. Checks that the connection uses the MySQL protocol.\n\n2. Checks that the table can be locked. It must be a local real-time or percolate table and must not be part of a replication cluster.\n\n3. Automatically releases any locks the session already holds.",
    "translations": {
      "chinese": "# 冻结和锁定表\n\n“冻结”表在您想制作物理副本或备份时非常有用。它将表的文件标记为冻结状态，并显示它们的存储位置。冻结后，您可以安全地将这些文件复制到其他地方。您仍然可以向冻结的表中添加新文档，直到达到 `rt_mem_limit`，但新数据会保存在内存中，直到表被解冻之前不会写入磁盘。如果表超过了 `rt_mem_limit`，所有更改将暂停，直到表被解冻。如果守护进程意外停止，任何未保存的数据将从二进制日志中恢复。\n\n“锁定”表对逻辑备份很有用。它不会停止内部维护任务，例如磁盘块合并操作或将 RAM 块写入磁盘。它只阻止写操作。这意味着您不能在锁定的表中插入、替换或更新数据。这对像 `mysqldump` 这样的工具很有帮助，因为锁定确保数据保持逻辑一致。例如，如果没有锁定，在转储期间替换文档，旧版本可能已经在转储中，而新版本也可能稍后出现，且两者具有相同的文档 ID。锁定表可以防止这种情况。\n\n## 冻结表\n\n<!-- example freeze -->\n\nCODE_BLOCK_0\n\n`FREEZE` 使实时/普通表准备好进行安全的[备份](../Securing_and_compacting_a_table/Backup_and_restore.md)。具体来说，它：\n\n1. 停用表压缩。如果表当前正在压缩，`FREEZE` 会优雅地中断它。\n\n2. 将当前的 RAM 块转移到磁盘块。\n\n3. 刷新属性。\n\n4. 禁用可能修改磁盘文件的隐式操作。\n\n5. 增加表的锁定计数器。\n\n6. 显示与表关联的实际文件列表。\n\n如果表已经被冻结（锁定），`FREEZE` 将：\n\n1. 增加表的锁定计数器。\n\n2. 显示与表关联的实际文件列表。\n\n内置工具 [manticore-backup](../Securing_and_compacting_a_table/Backup_and_restore.md) 使用 `FREEZE` 来确保数据一致性。如果您想创建自己的备份解决方案或因其他原因需要冻结表，也可以这样做。只需按照以下步骤：\n\n1. `FREEZE` 一个或多个表。\n\n2. 捕获 `FREEZE` 命令的输出并备份指定的文件。\n\n3. 完成后 `UNFREEZE` 表。\n\n<!-- request Example -->\n\nCODE_BLOCK_1\n\n<!-- response Example -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\n`file` 列指示运行实例的 [data_dir](../Server_settings/Searchd.md#data_dir) 中表的文件路径。`normalized` 列显示相同文件的绝对路径。备份表时，只需复制提供的文件，无需额外准备。\n\n当表被冻结时，您无法执行 `UPDATE` 查询；它们将等待直到表被解冻。\n\n此外，`DELETE` 和 `REPLACE` 查询在表冻结时有一些限制：\n\n* 如果 `DELETE` 影响当前 RAM 块中的文档 - 允许执行。\n\n* 如果 `DELETE` 影响磁盘块中的文档但之前已被删除 - 允许执行。\n\n* 如果 `DELETE` 会更改实际的磁盘块 - 将等待直到表被解冻。\n\n手动对冻结表的 RAM 块执行 `FLUSH` 会报告“成功”，但不会真正保存。\n\n冻结表的 `DROP`/`TRUNCATE` 是允许的，因为这些操作不是隐式的。我们假设如果您截断或删除表，您不需要备份它；因此，表最初不应被冻结。\n\n向冻结表中 `INSERT` 是支持的，但有限制：新数据将存储在 RAM 中（如常规）直到达到 `rt_mem_limit`；然后，新的插入将等待直到表被解冻。\n\n如果您在表冻结时关闭守护进程，它将表现得像经历了脏关闭（例如，`kill -9`）：新插入的数据不会保存在磁盘上的 RAM 块中，重启时将从二进制日志（如果有）恢复，或者如果禁用二进制日志则丢失。\n\n## 解冻表\n\n<!-- example unfreeze -->\n\nCODE_BLOCK_3\n\n`UNFREEZE` 命令减少表的锁定计数器，如果计数器降至零，则重新激活之前被阻止的操作并恢复内部压缩服务。所有等待表解冻的操作也将恢复并正常完成。\n\n<!-- request Example -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n## 检查表的锁定状态\n\n<!-- example show_table_status -->\n\n您可以使用 `SHOW table_name STATUS` 来检查表是否被冻结。\n\n锁定计数器显示在表状态的 `locked` 列中。值为零表示表未被冻结，非零值表示活动锁的数量。每个显式的 `FREEZE` 命令和隐式锁定（例如当表是集群的一部分且复制例程选择它作为副本的捐赠者）都会增加计数器。每个 `UNFREEZE` 命令都会减少计数器，最终降至零。\n\n<!-- request Example -->\n\nCODE_BLOCK_5\n\n<!-- response Example -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n## 锁定表\n\n<!-- example lock -->\n\nCODE_BLOCK_7\n\n您可以在 SQL 客户端会话中显式锁定表，以协调与其他会话的访问，或在需要独占访问时阻止其他会话更改数据。会话只能为自己锁定或解锁表，不能代表其他会话锁定或解锁表。锁只能用于通过 MySQL 协议连接的 SQL 会话。表被锁定时，不允许任何协议更改其数据（SQL / HTTP / 二进制）。锁也不适用于属于复制集群的表。\n\nManticore 仅支持**读（共享）**锁。不支持**写（独占）**锁。\n\n当会话请求读锁时，Manticore：\n\n1. 检查连接是否使用 MySQL 协议。\n\n2. 检查表是否可以被锁定。它必须是本地的实时或 percolate 表，且不能是复制集群的一部分。\n\n3. 自动释放会话已持有的任何锁。",
      "russian": "# Заморозка и блокировка таблицы\n\n«Заморозка» таблицы полезна, когда вы хотите сделать физическую копию или резервную копию. Она помечает файлы таблицы как замороженные и показывает, где они хранятся. После заморозки вы можете безопасно скопировать эти файлы в другое место. Вы всё ещё можете добавлять новые документы в замороженную таблицу до тех пор, пока она не достигнет `rt_mem_limit`, но новые данные остаются в памяти и не записываются на диск, пока таблица не будет разморожена. Если таблица превысит `rt_mem_limit`, все изменения приостанавливаются до разморозки. Если демон остановится неожиданно, любые несохранённые данные восстанавливаются из binlog.\n\n«Блокировка» таблицы полезна для логических резервных копий. Она не останавливает внутренние задачи обслуживания, такие как операции слияния дисковых чанков или запись RAM-чанка на диск. Она блокирует только операции записи. Это значит, что вы не можете вставлять, заменять или обновлять данные в заблокированной таблице. Это полезно для таких инструментов, как `mysqldump`, потому что блокировка гарантирует логическую согласованность данных. Например, без блокировки, если вы замените документ во время дампа, старая версия может уже попасть в дамп, а новая версия появится позже, обе с одним и тем же ID документа. Блокировка таблицы предотвращает такую ситуацию.\n\n## Заморозка таблицы\n\n<!-- example freeze -->\n\nCODE_BLOCK_0\n\n`FREEZE` подготавливает таблицу real-time/plain для безопасного [резервного копирования](../Securing_and_compacting_a_table/Backup_and_restore.md). В частности, он:\n\n1. Деактивирует сжатие таблицы. Если таблица в данный момент сжимается, `FREEZE` аккуратно прервет этот процесс.\n\n2. Переносит текущий RAM-чанк в дисковый чанк.\n\n3. Сбрасывает атрибуты.\n\n4. Отключает неявные операции, которые могут изменить файлы на диске.\n\n5. Увеличивает счётчик блокировок таблицы.\n\n6. Показывает фактический список файлов, связанных с таблицей.\n\nЕсли таблица уже заморожена (заблокирована), `FREEZE`:\n\n1. Увеличит счётчик блокировок таблицы.\n\n2. Покажет фактический список файлов, связанных с таблицей.\n\nВстроенный инструмент [manticore-backup](../Securing_and_compacting_a_table/Backup_and_restore.md) использует `FREEZE` для обеспечения согласованности данных. Вы можете сделать то же самое, если хотите создать собственное решение для резервного копирования или нужно заморозить таблицы по другим причинам. Просто выполните следующие шаги:\n\n1. `FREEZE` одну или несколько таблиц.\n\n2. Сохраните вывод команды `FREEZE` и сделайте резервную копию указанных файлов.\n\n3. `UNFREEZE` таблицу(ы) после завершения.\n\n<!-- request Example -->\n\nCODE_BLOCK_1\n\n<!-- response Example -->\n\nCODE_BLOCK_2\n\n<!-- end -->\n\nСтолбец `file` указывает пути к файлам таблицы внутри [data_dir](../Server_settings/Searchd.md#data_dir) запущенного экземпляра. Столбец `normalized` отображает абсолютные пути к тем же файлам. Чтобы сделать резервную копию таблицы, просто скопируйте указанные файлы без дополнительной подготовки.\n\nКогда таблица заморожена, выполнение запросов `UPDATE` невозможно; они будут ждать, пока таблица не будет разморожена.\n\nТакже запросы `DELETE` и `REPLACE` имеют некоторые ограничения во время заморозки таблицы:\n\n* Если `DELETE` затрагивает документ в текущем RAM-чанке — это разрешено.\n\n* Если `DELETE` влияет на документ в дисковом чанке, но он был ранее удалён — это разрешено.\n\n* Если `DELETE` изменит фактический дисковый чанк — запрос будет ждать, пока таблица не будет разморожена.\n\nРучной `FLUSH` RAM-чанка замороженной таблицы сообщит об «успехе», но реального сохранения не произойдет.\n\n`DROP`/`TRUNCATE` замороженной таблицы **разрешены**, так как эти операции не являются неявными. Предполагается, что если вы удаляете или очищаете таблицу, вам не нужна её резервная копия; значит, её изначально не следовало замораживать.\n\n`INSERT` в замороженную таблицу поддерживается, но с ограничениями: новые данные будут храниться в RAM (как обычно) до достижения `rt_mem_limit`; затем новые вставки будут ждать, пока таблица не будет разморожена.\n\nЕсли вы завершите работу демона с замороженной таблицей, это будет эквивалентно некорректному завершению работы (например, `kill -9`): недавно вставленные данные **не** будут сохранены в RAM-чанке на диске, и при перезапуске они будут восстановлены из бинарного лога (если он есть) или потеряны (если бинарное логирование отключено).\n\n## Разморозка таблицы\n\n<!-- example unfreeze -->\n\nCODE_BLOCK_3\n\nКоманда `UNFREEZE` уменьшает счётчик блокировок таблицы, и если он достигает нуля, повторно активирует ранее заблокированные операции и возобновляет внутреннюю службу сжатия. Все операции, ожидавшие разморозки таблицы, также возобновятся и завершатся нормально.\n\n<!-- request Example -->\n\nCODE_BLOCK_4\n\n<!-- end -->\n\n## Проверка состояния блокировки таблицы\n\n<!-- example show_table_status -->\n\nВы можете использовать `SHOW table_name STATUS`, чтобы проверить, заморожена таблица или нет.\n\nСчётчик блокировок отображается в статусе таблицы в столбце `locked`. Значение ноль означает, что таблица не заморожена, а ненулевое значение отражает количество активных блокировок. Каждая явная команда `FREEZE` и неявная блокировка (например, когда таблица является частью кластера и репликационная процедура выбирает её в качестве донора для реплики) увеличивает счётчик. Каждая команда `UNFREEZE` уменьшает счётчик, в конечном итоге до нуля.\n\n<!-- request Example -->\n\nCODE_BLOCK_5\n\n<!-- response Example -->\n\nCODE_BLOCK_6\n\n<!-- end -->\n\n## Блокировка таблицы\n\n<!-- example lock -->\n\nCODE_BLOCK_7\n\nВы можете явно блокировать таблицы в сессии SQL-клиента, чтобы координировать доступ с другими сессиями или чтобы остановить другие сессии от изменения данных, пока вам нужен эксклюзивный доступ. Сессия может блокировать или разблокировать таблицы только для себя. Она не может блокировать или разблокировать таблицы от имени другой сессии. Блокировки можно использовать только в SQL-сессиях, подключённых через протокол MySQL. Пока таблица заблокирована, ни один протокол не может изменить её данные (SQL / HTTP / бинарный). Блокировки также не работают для таблиц, которые принадлежат репликационному кластеру.\n\nManticore поддерживает только **чтение (shared)** блокировки. **Запись (exclusive)** блокировки не поддерживаются.\n\nКогда сессия запрашивает блокировку на чтение, Manticore:\n\n1. Проверяет, что соединение использует протокол MySQL.\n\n2. Проверяет, что таблицу можно заблокировать. Она должна быть локальной real-time или percolate таблицей и не должна быть частью репликационного кластера.\n\n3. Автоматически снимает любые блокировки, которые сессия уже держит."
    },
    "is_code_or_comment": false
  }
}
