{
  "02eda017f22f7bfc6e72bb43b968cecd4a1ee3affa9bd206bdf3253d43f0b5bc": {
    "original": "# SSL\n\nIn many cases, you might want to encrypt traffic between your client and the server. To do that, you can specify that the server should use the [HTTPS protocol](../Server_settings/Searchd.md#listen) rather than HTTP.\n\n<!-- example CA 1 -->\n\nTo enable HTTPS, at least the following two directives should be set in the [searchd](../Server_settings/Searchd.md) section of the config, and there should be at least one [listener](../Server_settings/Searchd.md#listen) set to `https`\n\n* [ssl_cert](../Server_settings/Searchd.md#ssl_cert) certificate file\n\n* [ssl_key](../Server_settings/Searchd.md#ssl_key) key file\n\nIn addition to that, you can specify the certificate authority's certificate (aka root certificate) in:\n\n* [ssl_ca](../Server_settings/Searchd.md#ssl_ca) certificate authority's certificate file\n\n<!-- intro -->\n\n##### with CA:\n\n<!-- request with CA -->\n\nExample with CA:\n\nCODE_BLOCK_0\n\n<!-- request without CA -->\n\nExample without CA:\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n## Generating SSL files\n\nThese steps will help you generate the SSL certificates using the 'openssl' tool.\n\nThe server can use a Certificate Authority to verify the signature of certificates, but it can also work with just a private key and certificate (without the CA certificate).\n\n#### Generate the CA key\n\nCODE_BLOCK_2\n\n#### Generate the CA certificate from the CA key\n\nTo generate a self-signed CA (root) certificate from the private key (make sure to fill in at least the \"Common Name\"), use the following command:\n\nCODE_BLOCK_3\n\n#### Server Certificate\n\nThe server uses the server certificate to secure communication with the client. To generate the certificate request and server private key (ensure that you fill in at least the \"Common Name\" and that it is different from the root certificate's common name), execute the following commands:\n\nCODE_BLOCK_4\n\nOnce completed, you can verify that the key and certificate files were generated correctly by running:\n\nCODE_BLOCK_5\n\n## Secured connection behaviour\n\nWhen your SSL configuration is valid, the following features are available:\n\n * You can connect to the multi-protocol port (when no [listener type](../Server_settings/Searchd.md#listen) is specified) over HTTPS and run queries. Both the request and response will be SSL encrypted.\n\n * You can connect to the dedicated https port with HTTP and run queries. The connection will be secured (attempting to connect to this port via plain HTTP will be rejected with a 400 error code).\n\n * You can connect to the MySQL port with a MySQL client using a secured connection. The session will be secured. Note that the Linux `mysql` client tries to use SSL by default, so a typical connection to Manticore with a valid SSL configuration will most likely be secured. You can check this by running the SQL 'status' command after connecting.\n\nIf your SSL configuration is not valid for any reason (which the daemon detects by the fact that a secured connection cannot be established), apart from an invalid configuration there may be other reasons, such as the inability to load the appropriate SSL library at all. In this case, the following things will not work or will work in a non-secured manner:\n\n* You cannot connect to the multi-protocol port with HTTPS. The connection will be dropped.\n\n* You cannot connect to the dedicated `https` port. The HTTPS connections will be dropped\n\n* Connection to the `mysql` port via a MySQL client will not support SSL securing. If the client requires SSL, the connection will fail. If SSL is not required, it will use plain MySQL or compressed connections.\n\n### Caution:\n\n* Binary API connections (such as connections from old clients or inter-daemons master-agent communication) are not secured.\n\n* SSL for replication needs to be set up separately. However, since the SST stage of the replication is done through the binary API connection, it is not secured either.\n\n* You can still use any external proxies (e.g., SSH tunneling) to secure your connections.\n\n<!-- proofread -->",
    "translations": {
      "chinese": "# SSL\n\n在许多情况下，您可能希望加密客户端与服务器之间的流量。为此，您可以指定服务器应使用[HTTPS协议](../Server_settings/Searchd.md#listen)而不是HTTP。\n\n<!-- example CA 1 -->\n\n要启用HTTPS，配置的[searchd](../Server_settings/Searchd.md)部分至少应设置以下两个指令，并且应至少有一个[监听器](../Server_settings/Searchd.md#listen)设置为`https`\n\n* [ssl_cert](../Server_settings/Searchd.md#ssl_cert) 证书文件\n\n* [ssl_key](../Server_settings/Searchd.md#ssl_key) 密钥文件\n\n除此之外，您还可以指定证书颁发机构的证书（即根证书）：\n\n* [ssl_ca](../Server_settings/Searchd.md#ssl_ca) 证书颁发机构的证书文件\n\n<!-- intro -->\n\n##### 使用CA：\n\n<!-- request with CA -->\n\n带CA的示例：\n\nCODE_BLOCK_0\n\n<!-- request without CA -->\n\n无CA的示例：\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n## 生成SSL文件\n\n以下步骤将帮助您使用“openssl”工具生成SSL证书。\n\n服务器可以使用证书颁发机构来验证证书的签名，但也可以仅使用私钥和证书（不带CA证书）工作。\n\n#### 生成CA密钥\n\nCODE_BLOCK_2\n\n#### 从CA密钥生成CA证书\n\n要从私钥生成自签名CA（根）证书（确保至少填写“通用名称”），请使用以下命令：\n\nCODE_BLOCK_3\n\n#### 服务器证书\n\n服务器使用服务器证书来保护与客户端的通信。要生成证书请求和服务器私钥（确保至少填写“通用名称”，且与根证书的通用名称不同），执行以下命令：\n\nCODE_BLOCK_4\n\n完成后，您可以通过运行以下命令验证密钥和证书文件是否正确生成：\n\nCODE_BLOCK_5\n\n## 安全连接行为\n\n当您的SSL配置有效时，以下功能可用：\n\n * 您可以通过HTTPS连接到多协议端口（当未指定[监听器类型](../Server_settings/Searchd.md#listen)时）并运行查询。请求和响应都将被SSL加密。\n\n * 您可以通过HTTP连接到专用的https端口并运行查询。连接将被保护（尝试通过普通HTTP连接此端口将被拒绝，返回400错误码）。\n\n * 您可以使用MySQL客户端通过安全连接连接到MySQL端口。会话将被保护。请注意，Linux的`mysql`客户端默认尝试使用SSL，因此在有效的SSL配置下，典型的Manticore连接很可能是安全的。您可以通过连接后运行SQL的'status'命令来检查这一点。\n\n如果您的SSL配置因任何原因无效（守护进程通过无法建立安全连接来检测），除了配置无效外，可能还有其他原因，例如无法加载适当的SSL库。在这种情况下，以下功能将无法工作或以非安全方式工作：\n\n* 您无法通过HTTPS连接到多协议端口。连接将被断开。\n\n* 您无法连接到专用的`https`端口。HTTPS连接将被断开。\n\n* 通过MySQL客户端连接到`mysql`端口将不支持SSL保护。如果客户端要求SSL，连接将失败。如果不要求SSL，则使用普通MySQL或压缩连接。\n\n### 注意：\n\n* 二进制API连接（例如旧客户端连接或守护进程间的主从通信）不受保护。\n\n* 复制的SSL需要单独设置。然而，由于复制的SST阶段是通过二进制API连接完成的，因此也不受保护。\n\n* 您仍然可以使用任何外部代理（例如SSH隧道）来保护您的连接。\n\n<!-- proofread -->",
      "russian": "# SSL\n\nВо многих случаях вы можете захотеть зашифровать трафик между вашим клиентом и сервером. Для этого вы можете указать, что сервер должен использовать [протокол HTTPS](../Server_settings/Searchd.md#listen) вместо HTTP.\n\n<!-- example CA 1 -->\n\nЧтобы включить HTTPS, как минимум должны быть установлены следующие две директивы в секции [searchd](../Server_settings/Searchd.md) конфигурационного файла, и должен быть хотя бы один [listener](../Server_settings/Searchd.md#listen), настроенный на `https`\n\n* [ssl_cert](../Server_settings/Searchd.md#ssl_cert) файл сертификата\n\n* [ssl_key](../Server_settings/Searchd.md#ssl_key) файл ключа\n\nКроме того, вы можете указать сертификат центра сертификации (также известный как корневой сертификат) в:\n\n* [ssl_ca](../Server_settings/Searchd.md#ssl_ca) файл сертификата центра сертификации\n\n<!-- intro -->\n\n##### с CA:\n\n<!-- request with CA -->\n\nПример с CA:\n\nCODE_BLOCK_0\n\n<!-- request without CA -->\n\nПример без CA:\n\nCODE_BLOCK_1\n\n<!-- end -->\n\n## Генерация SSL файлов\n\nЭти шаги помогут вам сгенерировать SSL сертификаты с помощью инструмента 'openssl'.\n\nСервер может использовать Центр Сертификации для проверки подписи сертификатов, но он также может работать только с приватным ключом и сертификатом (без сертификата CA).\n\n#### Генерация ключа CA\n\nCODE_BLOCK_2\n\n#### Генерация сертификата CA из ключа CA\n\nЧтобы сгенерировать самоподписанный сертификат CA (корневой) из приватного ключа (обязательно заполните хотя бы поле \"Common Name\"), используйте следующую команду:\n\nCODE_BLOCK_3\n\n#### Сертификат сервера\n\nСервер использует сертификат сервера для защиты связи с клиентом. Чтобы сгенерировать запрос на сертификат и приватный ключ сервера (убедитесь, что вы заполнили хотя бы \"Common Name\" и что он отличается от общего имени корневого сертификата), выполните следующие команды:\n\nCODE_BLOCK_4\n\nПосле завершения вы можете проверить, что файлы ключа и сертификата были сгенерированы корректно, выполнив:\n\nCODE_BLOCK_5\n\n## Поведение защищённого соединения\n\nКогда ваша SSL конфигурация действительна, доступны следующие возможности:\n\n * Вы можете подключаться к мультипротокольному порту (когда не указан [тип listener](../Server_settings/Searchd.md#listen)) по HTTPS и выполнять запросы. И запрос, и ответ будут зашифрованы SSL.\n\n * Вы можете подключаться к выделенному https порту с помощью HTTP и выполнять запросы. Соединение будет защищено (попытка подключения к этому порту через обычный HTTP будет отклонена с кодом ошибки 400).\n\n * Вы можете подключаться к порту MySQL с помощью MySQL клиента, используя защищённое соединение. Сессия будет защищена. Обратите внимание, что Linux клиент `mysql` по умолчанию пытается использовать SSL, поэтому типичное подключение к Manticore с действительной SSL конфигурацией, скорее всего, будет защищённым. Вы можете проверить это, выполнив SQL команду 'status' после подключения.\n\nЕсли ваша SSL конфигурация по какой-либо причине недействительна (что демон обнаруживает по тому, что защищённое соединение не может быть установлено), помимо неверной конфигурации могут быть и другие причины, например, невозможность загрузить соответствующую SSL библиотеку вообще. В этом случае следующие функции не будут работать или будут работать в незашищённом режиме:\n\n* Вы не сможете подключиться к мультипротокольному порту по HTTPS. Соединение будет разорвано.\n\n* Вы не сможете подключиться к выделенному порту `https`. HTTPS соединения будут разорваны.\n\n* Подключение к порту `mysql` через MySQL клиент не будет поддерживать SSL защиту. Если клиент требует SSL, соединение не удастся. Если SSL не требуется, будет использоваться обычное MySQL или сжатое соединение.\n\n### Внимание:\n\n* Соединения Binary API (например, соединения от старых клиентов или междемонное master-agent общение) не защищены.\n\n* SSL для репликации нужно настраивать отдельно. Однако, поскольку этап SST репликации выполняется через соединение Binary API, он также не защищён.\n\n* Вы всё ещё можете использовать любые внешние прокси (например, SSH туннелирование) для защиты ваших соединений.\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  }
}
