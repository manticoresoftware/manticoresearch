{
  "5d8b637e02fd77bafe679b6dd773ec78cf11581143194323977db0846f20d307": {
    "original": "* `QCACHE_MAX_BYTES = <value>` Changes the [query_cache](../Searching/Query_cache.md) RAM use limit to a given value.\n\n* `QCACHE_THRESH_MSEC = <value>` Changes the [query_cache](../Searching/Query_cache.md) minimum wall time threshold to a given value.\n\n* `QCACHE_TTL_SEC = <value>` Changes the [query_cache](../Searching/Query_cache.md) TTL for a cached result to a given value.\n\n* `QUERY_LOG_FORMAT = {plain | sphinxql}` Changes the current log format.\n\n* `QUERY_LOG_MIN_MSEC = <value>` Changes the [query_log_min_msec](../Server_settings/Searchd.md#query_log_min_msec) searchd settings value. In this case, it expects the value exactly in milliseconds and doesn't parse time suffixes, as in config.\n\n  > Warning: this is a very specific and 'hard' variable; filtered out messages will be just dropped and not written into the log at all. Better just filter your log with something like 'grep', in this case, you'll have at least the full original log as a backup.\n\n* `RESET_NETWORK_TIMEOUT_ON_PACKET = {1|0}` changes [reset_network_timeout_on_packet](../Server_settings/Searchd.md#reset_network_timeout_on_packet) param. Only clients with VIP connections can change this variable.\n\n* `SECONDARY_INDEXES = {1|0}` Turns on/off [secondary indexes](../Server_settings/Searchd.md#secondary_indexes) for search queries.\n\n* `TIMEZONE = <value>` Specifies the timezone used by date/time-related functions. Read the doc for [timezone](../Server_settings/Searchd.md) config param for more details.\n\nExamples:\n\nCODE_BLOCK_2\n\nTo make user variables persistent, make sure [sphinxql_state](../Server_settings/Searchd.md#sphinxql_state) is enabled.\n\n<!-- proofread -->",
    "translations": {
      "chinese": "* `QCACHE_MAX_BYTES = <value>` 更改 [query_cache](../Searching/Query_cache.md) 的 RAM 使用限制为指定值。\n\n* `QCACHE_THRESH_MSEC = <value>` 更改 [query_cache](../Searching/Query_cache.md) 的最小墙时阈值为指定值。\n\n* `QCACHE_TTL_SEC = <value>` 更改 [query_cache](../Searching/Query_cache.md) 缓存结果的 TTL 为指定值。\n\n* `QUERY_LOG_FORMAT = {plain | sphinxql}` 更改当前日志格式。\n\n* `QUERY_LOG_MIN_MSEC = <value>` 更改 [query_log_min_msec](../Server_settings/Searchd.md#query_log_min_msec) searchd 设置值。在此情况下，期望值为毫秒数，不解析配置中的时间后缀。\n\n  > 警告：这是一个非常特殊且“硬性”的变量；被过滤的消息将直接丢弃，不会写入日志。最好使用类似 'grep' 的工具过滤日志，这样至少可以保留完整的原始日志作为备份。\n\n* `RESET_NETWORK_TIMEOUT_ON_PACKET = {1|0}` 更改 [reset_network_timeout_on_packet](../Server_settings/Searchd.md#reset_network_timeout_on_packet) 参数。只有具有 VIP 连接的客户端可以更改此变量。\n\n* `SECONDARY_INDEXES = {1|0}` 开启/关闭搜索查询的 [secondary indexes](../Server_settings/Searchd.md#secondary_indexes)。\n\n* `TIMEZONE = <value>` 指定日期/时间相关函数使用的时区。更多详情请参阅 [timezone](../Server_settings/Searchd.md) 配置参数文档。\n\n示例：\n\nCODE_BLOCK_2\n\n要使用户变量持久化，请确保启用 [sphinxql_state](../Server_settings/Searchd.md#sphinxql_state)。\n\n<!-- proofread -->",
      "russian": "* `QCACHE_MAX_BYTES = <value>` Изменяет лимит использования оперативной памяти [query_cache](../Searching/Query_cache.md) на заданное значение.\n\n* `QCACHE_THRESH_MSEC = <value>` Изменяет минимальный порог времени выполнения [query_cache](../Searching/Query_cache.md) на заданное значение.\n\n* `QCACHE_TTL_SEC = <value>` Изменяет TTL для кэшированного результата в [query_cache](../Searching/Query_cache.md) на заданное значение.\n\n* `QUERY_LOG_FORMAT = {plain | sphinxql}` Изменяет текущий формат журнала.\n\n* `QUERY_LOG_MIN_MSEC = <value>` Изменяет значение настройки [query_log_min_msec](../Server_settings/Searchd.md#query_log_min_msec) для searchd. В этом случае ожидается значение именно в миллисекундах, и суффиксы времени, как в конфиге, не обрабатываются.\n\n  > Внимание: это очень специфичная и «жёсткая» переменная; отфильтрованные сообщения просто не будут записаны в журнал. Лучше фильтровать журнал с помощью чего-то вроде 'grep', в этом случае у вас будет хотя бы полный оригинальный журнал в резервной копии.\n\n* `RESET_NETWORK_TIMEOUT_ON_PACKET = {1|0}` изменяет параметр [reset_network_timeout_on_packet](../Server_settings/Searchd.md#reset_network_timeout_on_packet). Изменять эту переменную могут только клиенты с VIP-подключениями.\n\n* `SECONDARY_INDEXES = {1|0}` Включает/выключает [вторичные индексы](../Server_settings/Searchd.md#secondary_indexes) для поисковых запросов.\n\n* `TIMEZONE = <value>` Указывает часовой пояс, используемый функциями, связанными с датой и временем. Подробнее см. документацию по параметру конфигурации [timezone](../Server_settings/Searchd.md).\n\nПримеры:\n\nCODE_BLOCK_2\n\nЧтобы сделать пользовательские переменные постоянными, убедитесь, что включён [sphinxql_state](../Server_settings/Searchd.md#sphinxql_state).\n\n<!-- proofread -->"
    },
    "is_code_or_comment": false
  },
  "5090e75822596eaa67e8d4dd928e6a049b2a6dbb63fbb2dd1ba4522ce0c9f740": {
    "original": "# Setting variables online\n\n## SET\n\nCODE_BLOCK_0\n\nThe `SET` statement in Manticore Search allows you to modify variable values. Variable names are case-insensitive, and no variable value changes will persist after a server restart.\n\nManticore Search supports the `SET NAMES` statement and `SET @@variable_name` syntax for compatibility with third-party MySQL client libraries, connectors, and frameworks that may require running these statements when connecting. However, these statements do not have any effect on Manticore Search itself.\n\nThere are four classes of variables in Manticore Search:\n\n1.  Per-session server variable: `set var_name = value`\n\n2.  Global server variable: `set global var_name = value`\n\n3.  Global user variable: `set global @var_name = (value)`\n\n4.  Global distributed variable: `set index dist_table_name global @var_name = (value)`\n\nGlobal user variables are shared between concurrent sessions. The only supported value type is a list of BIGINTs, and these variables can be used with the IN() operator for filtering purposes. The primary use case for this feature is to upload large lists of values to `searchd` once and reuse them multiple times later, reducing network overhead. Global user variables can be transferred to all agents of a distributed table or set locally in the case of a local table defined in a distributed table. Example:\n\nCODE_BLOCK_1\n\nManticore Search supports per-session and global server variables that affect specific server settings in their respective scopes. Below is a list of known per-session and global server variables:\n\nKnown per-session server variables:\n\n* `AUTOCOMMIT = {0 | 1}` determines if data modification statements should be implicitly wrapped by `BEGIN` and `COMMIT`.\n\n* `COLLATION_CONNECTION = collation_name` selects the collation for `ORDER BY` or `GROUP BY` on string values in subsequent queries. Refer to [Collations](../Searching/Collations.md) for a list of known collation names.\n\n* `MAX_THREADS_PER_QUERY = <POSITIVE_INT_VALUE>` redefines [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query) in the runtime. Per-session variable influences only the queries run in the same session (connection), i.e., up to disconnect. Value 0 means 'no limit'. If both per-session and the global variables are set, the per-session one has a higher priority.\n\n* `net_write_timeout = <value>`: Tunes the network timeout for write operations, i.e., sending data. The global value can be changed only with VIP privileges.\n\n* `optimize_by_id = {0 | 1}`: Internal flag used in some `debug` commands.\n\n* `PROFILING = {0 | 1}` enables query profiling in the current session. Defaults to 0. See also [show profile](../Node_info_and_management/Profiling/Query_profile.md).\n\n* `ro = {1 | 0}` switches session to read-only mode or back. In `show variables` output the variable displayed with name `session_read_only`.\n\n* `throttling_period = <INT_VALUE>`: Interval (in milliseconds) during which the current running query will reschedule. A value of 0 disables throttling, meaning the query will occupy CPU cores until it finishes. If concurrent queries come from other connections at the same time, they will be allocated to free cores or will be suspended until a core is released. Providing a negative value (-1) resets throttling to the default compiled-in value (100ms), which means the query will be rescheduled every 100ms, allowing concurrent queries a chance to be executed. The global value (set via `set global`) can only be set on a VIP connection.\n\n* `thread_stack = <value>`: Changes the default value on-the-fly, which limits the stack size provided to one task. Note that here 'thread' refers not to an OS thread, but to a userspace thread, also known as a coroutine. This can be useful if, for example, you load a percolate table with unexpectedly high requirements. In such cases, 'call pq' would fail with a message about insufficient stack size. Generally, you should stop the daemon, increase the value in the config, and then restart. However, you can also try a new value without restarting, by setting a new one with this variable. The global value can also be changed online with `set global thread_stack`, but this is available only from a VIP connection.\n\n* `threads_ex` (diagnostic): Forces Manticore to behave as if it is running on a CPU with the provided profile. As a short example, `set threads_ex='4/2+6/3'` indicates 'you have 4 free CPU cores, when scheduling multiple queries they should be batched by 2. Also, you have 6 free CPU cores for pseudo-sharding, parts should be batched by 3'. This option is diagnostic, as it is very helpful, for example, to see how your query would run on a configuration you don't have locally. For instance, on a 128-core CPU. Or, conversely, to quickly limit the daemon to behave as single-threaded, to locate a bottleneck or investigate a crash.\n\n  <details>\n\n\tBy default, Manticore starts a thread pool with a calculated number of CPU cores. All typical tasks are then distributed into this thread pool to ensure maximum CPU utilization. For instance, when a real-time table has several disk chunks, the search will be parallelized over the CPU cores. Similarly, for a single full-text search over a single index, the daemon will attempt to optimize search execution in parallel, using a technique referred to as \"pseudo-sharding\". Both features heavily depend on the total number of CPU cores and the number of free cores available for immediate use.\n\n\tThis approach enhances performance but can make incident investigation more challenging. For example, a query doing `COUNT(*)` may return an approximate result (e.g., greater than 100 matches), and a subsequent execution of the same query may yield an exact result (e.g., exactly 120 matches). This variability depends on the available cores, but since this factor is unpredictable, it generally leads to non-reproducible results. Although this is usually acceptable, it can sometimes pose a problem. The `threads_ex` option specifies a desired CPU cores configuration, making queries with this configuration reproducible.",
    "translations": {
      "chinese": "# 在线设置变量\n\n## SET\n\nCODE_BLOCK_0\n\nManticore Search 中的 `SET` 语句允许您修改变量值。变量名不区分大小写，服务器重启后变量值的更改不会保留。\n\nManticore Search 支持 `SET NAMES` 语句和 `SET @@variable_name` 语法，以兼容可能在连接时需要运行这些语句的第三方 MySQL 客户端库、连接器和框架。然而，这些语句对 Manticore Search 本身没有任何影响。\n\nManticore Search 中有四类变量：\n\n1.  会话级服务器变量：`set var_name = value`\n\n2.  全局服务器变量：`set global var_name = value`\n\n3.  全局用户变量：`set global @var_name = (value)`\n\n4.  全局分布式变量：`set index dist_table_name global @var_name = (value)`\n\n全局用户变量在并发会话之间共享。唯一支持的值类型是 BIGINT 列表，这些变量可以与 IN() 操作符一起用于过滤。此功能的主要用例是一次性将大量值列表上传到 `searchd`，然后多次重用，减少网络开销。全局用户变量可以传递给分布式表的所有代理，或者在分布式表中定义的本地表情况下本地设置。示例：\n\nCODE_BLOCK_1\n\nManticore Search 支持影响各自作用域中特定服务器设置的会话级和全局服务器变量。以下是已知的会话级和全局服务器变量列表：\n\n已知的会话级服务器变量：\n\n* `AUTOCOMMIT = {0 | 1}` 决定数据修改语句是否应隐式地由 `BEGIN` 和 `COMMIT` 包裹。\n\n* `COLLATION_CONNECTION = collation_name` 选择后续查询中字符串值的 `ORDER BY` 或 `GROUP BY` 的排序规则。已知排序规则名称列表请参见 [排序规则](../Searching/Collations.md)。\n\n* `MAX_THREADS_PER_QUERY = <POSITIVE_INT_VALUE>` 在运行时重新定义 [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query)。会话级变量仅影响同一会话（连接）中运行的查询，即直到断开连接。值为 0 表示“无限制”。如果同时设置了会话级和全局变量，会话级变量优先。\n\n* `net_write_timeout = <value>`：调整写操作（即发送数据）的网络超时。全局值只能由 VIP 权限更改。\n\n* `optimize_by_id = {0 | 1}`：某些 `debug` 命令中使用的内部标志。\n\n* `PROFILING = {0 | 1}` 启用当前会话的查询分析。默认值为 0。另见 [show profile](../Node_info_and_management/Profiling/Query_profile.md)。\n\n* `ro = {1 | 0}` 切换会话为只读模式或恢复。在 `show variables` 输出中，该变量显示为 `session_read_only`。\n\n* `throttling_period = <INT_VALUE>`：当前运行查询将重新调度的时间间隔（毫秒）。值为 0 禁用节流，意味着查询将占用 CPU 核心直到完成。如果同时有来自其他连接的并发查询，它们将被分配到空闲核心或挂起直到核心释放。提供负值（-1）将节流重置为默认编译值（100ms），意味着查询每 100ms 重新调度一次，允许并发查询有执行机会。全局值（通过 `set global` 设置）只能在 VIP 连接上设置。\n\n* `thread_stack = <value>`：动态更改默认值，限制分配给单个任务的栈大小。注意这里的“线程”指的是用户空间线程，也称为协程，而非操作系统线程。如果例如加载 percolate 表时需求异常高，这可能有用。在这种情况下，“call pq” 会因栈大小不足而失败。通常应停止守护进程，在配置中增加该值，然后重启。但也可以尝试不重启，直接用此变量设置新值。全局值也可以通过 `set global thread_stack` 在线更改，但仅限 VIP 连接。\n\n* `threads_ex`（诊断用）：强制 Manticore 表现得像运行在指定 CPU 配置上一样。简短示例，`set threads_ex='4/2+6/3'` 表示“你有 4 个空闲 CPU 核心，调度多个查询时应按 2 批处理。同时，你有 6 个空闲 CPU 核心用于伪分片，部分应按 3 批处理”。此选项用于诊断，非常有用，例如查看查询在本地没有的配置（如 128 核 CPU）上的运行情况。或者快速限制守护进程表现为单线程，以定位瓶颈或调查崩溃。\n\n  <details>\n\n\t默认情况下，Manticore 启动一个线程池，线程数基于计算的 CPU 核心数。所有典型任务随后分配到该线程池，以确保最大 CPU 利用率。例如，当实时表有多个磁盘块时，搜索将在 CPU 核心上并行化。同样，对于单个索引的全文搜索，守护进程将尝试使用称为“伪分片”的技术优化并行搜索执行。这两个功能都高度依赖于 CPU 核心总数和可立即使用的空闲核心数。\n\n\t这种方法提升了性能，但可能使事件调查更具挑战性。例如，执行 `COUNT(*)` 的查询可能返回近似结果（如大于 100 个匹配），而同一查询的后续执行可能返回精确结果（如正好 120 个匹配）。这种差异取决于可用核心数，但由于该因素不可预测，通常导致结果不可复现。虽然这通常可以接受，但有时可能成为问题。`threads_ex` 选项指定期望的 CPU 核心配置，使得使用该配置的查询结果可复现。",
      "russian": "# Установка переменных онлайн\n\n## SET\n\nCODE_BLOCK_0\n\nОператор `SET` в Manticore Search позволяет изменять значения переменных. Имена переменных не чувствительны к регистру, и изменения значений переменных не сохраняются после перезапуска сервера.\n\nManticore Search поддерживает оператор `SET NAMES` и синтаксис `SET @@variable_name` для совместимости с клиентскими библиотеками MySQL, коннекторами и фреймворками сторонних разработчиков, которые могут требовать выполнения этих операторов при подключении. Однако эти операторы не влияют на сам Manticore Search.\n\nВ Manticore Search существует четыре класса переменных:\n\n1.  Переменная сервера на сессию: `set var_name = value`\n\n2.  Глобальная переменная сервера: `set global var_name = value`\n\n3.  Глобальная пользовательская переменная: `set global @var_name = (value)`\n\n4.  Глобальная распределённая переменная: `set index dist_table_name global @var_name = (value)`\n\nГлобальные пользовательские переменные разделяются между параллельными сессиями. Единственный поддерживаемый тип значения — список BIGINT, и эти переменные можно использовать с оператором IN() для фильтрации. Основное применение этой функции — загрузка больших списков значений в `searchd` один раз с последующим многократным использованием, что снижает сетевые накладные расходы. Глобальные пользовательские переменные могут передаваться всем агентам распределённой таблицы или устанавливаться локально в случае локальной таблицы, определённой в распределённой таблице. Пример:\n\nCODE_BLOCK_1\n\nManticore Search поддерживает переменные сервера на сессию и глобальные переменные сервера, которые влияют на определённые настройки сервера в соответствующих областях видимости. Ниже приведён список известных переменных сервера на сессию и глобальных переменных сервера:\n\nИзвестные переменные сервера на сессию:\n\n* `AUTOCOMMIT = {0 | 1}` определяет, должны ли операторы изменения данных автоматически оборачиваться в `BEGIN` и `COMMIT`.\n\n* `COLLATION_CONNECTION = collation_name` выбирает сортировку для `ORDER BY` или `GROUP BY` по строковым значениям в последующих запросах. Список известных имён сортировок см. в разделе [Collations](../Searching/Collations.md).\n\n* `MAX_THREADS_PER_QUERY = <POSITIVE_INT_VALUE>` переопределяет [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query) во время выполнения. Переменная на сессию влияет только на запросы, выполняемые в той же сессии (подключении), то есть до отключения. Значение 0 означает «без ограничений». Если установлены обе переменные — на сессию и глобальная, приоритет выше у переменной на сессию.\n\n* `net_write_timeout = <value>`: Настраивает сетевой таймаут для операций записи, то есть отправки данных. Глобальное значение можно изменить только с привилегиями VIP.\n\n* `optimize_by_id = {0 | 1}`: Внутренний флаг, используемый в некоторых командах `debug`.\n\n* `PROFILING = {0 | 1}` включает профилирование запросов в текущей сессии. По умолчанию 0. См. также [show profile](../Node_info_and_management/Profiling/Query_profile.md).\n\n* `ro = {1 | 0}` переключает сессию в режим только для чтения или обратно. В выводе `show variables` переменная отображается под именем `session_read_only`.\n\n* `throttling_period = <INT_VALUE>`: Интервал (в миллисекундах), через который текущий выполняющийся запрос будет перепланирован. Значение 0 отключает ограничение, то есть запрос будет занимать CPU до завершения. Если в это время поступают параллельные запросы из других подключений, они будут распределены на свободные ядра или приостановлены до освобождения ядра. Указание отрицательного значения (-1) сбрасывает ограничение до значения по умолчанию, заданного при компиляции (100 мс), что означает перепланирование запроса каждые 100 мс, давая возможность выполнять параллельные запросы. Глобальное значение (устанавливаемое через `set global`) можно задать только с VIP-подключения.\n\n* `thread_stack = <value>`: Изменяет значение по умолчанию на лету, ограничивающее размер стека, выделяемого одной задаче. Обратите внимание, что здесь «поток» — это не поток ОС, а поток в пространстве пользователя, также известный как корутина. Это может быть полезно, например, если вы загружаете таблицу percolate с неожиданно высокими требованиями. В таких случаях 'call pq' может завершиться с сообщением о недостаточном размере стека. Обычно следует остановить демон, увеличить значение в конфиге и перезапустить. Однако можно попробовать новое значение без перезапуска, установив его через эту переменную. Глобальное значение также можно изменить онлайн с помощью `set global thread_stack`, но это доступно только с VIP-подключения.\n\n* `threads_ex` (диагностическая): Заставляет Manticore вести себя так, как если бы он работал на CPU с указанным профилем. Краткий пример: `set threads_ex='4/2+6/3'` означает «у вас 4 свободных ядра CPU, при планировании нескольких запросов их следует группировать по 2. Также у вас есть 6 свободных ядер для псевдо-шардинга, части следует группировать по 3». Эта опция диагностическая, так как очень полезна, например, чтобы увидеть, как ваш запрос будет выполняться на конфигурации, которой у вас нет локально. Например, на 128-ядерном CPU. Или, наоборот, быстро ограничить демон однопоточным режимом, чтобы найти узкое место или исследовать сбой.\n\n  <details>\n\n\tПо умолчанию Manticore запускает пул потоков с рассчитанным числом ядер CPU. Все типичные задачи затем распределяются в этот пул потоков для обеспечения максимального использования CPU. Например, если у таблицы реального времени несколько дисковых чанков, поиск будет распараллелен по ядрам CPU. Аналогично, для одного полнотекстового поиска по одному индексу демон попытается оптимизировать выполнение поиска параллельно, используя технику, называемую «псевдо-шардинг». Обе функции сильно зависят от общего числа ядер CPU и количества свободных ядер, доступных для немедленного использования.\n\n\tТакой подход повышает производительность, но может усложнить расследование инцидентов. Например, запрос с `COUNT(*)` может вернуть приблизительный результат (например, больше 100 совпадений), а последующее выполнение того же запроса — точный результат (например, ровно 120 совпадений). Эта изменчивость зависит от доступных ядер, но поскольку этот фактор непредсказуем, обычно приводит к нерепродуцируемым результатам. Хотя это обычно приемлемо, иногда может создавать проблемы. Опция `threads_ex` задаёт желаемую конфигурацию ядер CPU, делая запросы с этой конфигурацией воспроизводимыми."
    },
    "is_code_or_comment": false
  },
  "8626c45bce1a925c07c6037283ed6567e4b79bf1267e16a3e0a32d9cecceae29": {
    "original": "\t`threads_ex` sets the CPU template for standard tasks and for pseudo-sharding, as pseudo-sharding can be part of the standard parallelization process. For example, if there are several disk chunks, they will be queried in parallel, but each may be further parallelized using pseudo-sharding. Thus, to manage this situation effectively, you need a couple of templates for each task type.\n\n\tA template is a string like `10/3`, where 10 represents concurrency and 3 represents batch size. If concurrency is 0, the default concurrency will be used. If batch size is 0, the default trivial template will be used. Any zero value can be omitted or replaced with `*`. The default (trivial) template can be described as `''`, and also as `*/*`, `0/0`, `0/`, `*/`, `/0`, `*`, etc. This means the daemon uses all available CPU cores without special batching limitations.\n\n\tA trivial template with 20 threads can be expressed as `20/*`, `20/0`, `20/`, or simply `20`. A round-robin template with a batch size of 2 is `*/2`, `0/2`, or simply `/2`. A round-robin dispatcher with 20 threads and a batch size of 3 is `20/3`.\n\n\t`threads_ex` is a template for basic tasks and for pseudo-sharding, separated by `+`, like:\n\n\t* `30+3` - a trivial base of 30 threads + trivial pseudo-sharding of 3 threads\n\n\t* `+/2` - a trivial base + round-robin pseudo-sharding with default threads and batch=2\n\n\t* `10` - a trivial base of 10 threads + default trivial pseudo-sharding\n\n\t* `/1+10` - a round-robin base with default threads and batch=1 + trivial pseudo-sharding with 10 threads\n\n\t* `4/2+2/1` - a round-robin base with 4 threads and batch=2 + round-robin pseudo-sharding with 2 threads and batch=1\n\n\t* `1+1` - the most deterministic case. Exactly 1 thread + 1 pseudo-shard, i.e., no parallelization at all. With this setting, you can reproducibly repeat the same problematic query and investigate behavior details. Furthermore, if you set `throttling_period=0`, your query will 'stick' to the current thread and never be rescheduled during execution, creating an ideal environment for troubleshooting.\n\n\tThe option can be set globally from outside as an environment variable `MANTICORE_THREADS_EX`, like:\n\n\t```bash\n\n\texport MANTICORE_THREADS_EX=8\n\n\texport MANTICORE_THREADS_EX='16+8/2'\n\n  ```\n\n  Or, via the MySQL CLI, as:\n\n  ```sql\n\n  SET threads_ex='16';\n\n\tSET GLOBAL threads_ex='/2';\n\n  ```\n\n  Or, as a query parameter, like:\n\n  ```sql\n\n  SELECT ... OPTION threads_ex='1+1';\n\n  ```\n\n  The `threads_ex` configuration follows a hierarchy: environment variables first, then the global variable, and lastly, query options, allowing specific settings to override general ones.\n\n  </details>\n\n* `WAIT_TIMEOUT/net_read_timeout = <value>` sets connection timeout, either per session or global. Global can only be set on a VIP connection.\n\nKnown global server variables are:\n\n* `ACCURATE_AGGREGATION`: Sets the default value for the option [accurate_aggregation](../Searching/Options.md#accurate_aggregation) of future queries.\n\n* `AUTO_OPTIMIZE = {1|0}` Turns on/off [auto_optimize](../Server_settings/Searchd.md#auto_optimize).\n\n* `cluster_user = name` Sets the username used with `mysqldump` / `mariadb-dump` to [enable replication mode](../Securing_and_compacting_a_table/Backup_and_restore.md#Backup-and-restore-with-mysqldump).\n\n* `COREDUMP= {1|0}` Turns on/off saving a core file or a minidump of the server on crash. More details [here](../Starting_the_server/Manually.md#searchd-command-line-options).\n\n* `CPUSTATS= {1|0}` Turns on/off [CPU time tracking](../Starting_the_server/Manually.md#searchd-command-line-options).\n\n* `DISTINCT_PRECISION_THRESHOLD`: Sets the default value for the option [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) of future queries.\n\n* `ES_COMPAT = {on/off/dashboards}` When set to `on` (default), Elasticsearch-like write requests are supported; `off` disables the support; `dashboards` enables the support and also allows requests from Kibana (this functionality is experimental).\n\n* `EXPANSION_MERGE_THRESHOLD_DOCS`: Changes the value of the config's [expansion_merge_threshold_docs](../Server_settings/Searchd.md#expansion_merge_threshold_docs) setting on-the-fly.\n\n* `EXPANSION_MERGE_THRESHOLD_HITS`: Changes the value of the config's [expansion_merge_threshold_hits](../Server_settings/Searchd.md#expansion_merge_threshold_hits) setting on-the-fly.\n\n* `GROUPING_IN_UTC = {0 | 1}` When set to 1, causes timed grouping functions (day(), month(), year(), yearmonth(), yearmonthday()) to be calculated in UTC. Read the doc for [grouping_in_utc](../Server_settings/Searchd.md) config params for more details.\n\n* `IOSTATS = {0 | 1}` Enables or disables I/O operations (except for attributes) reporting in the query log.\n\n* `LOG_DEBUG_FILTER = <string value>` Filters out redundant log messages. If the value is set, then all logs with level > INFO (i.e., `DEBUG`, `DEBUGV`, etc.) will be compared with the string and output only in the case they start with the given value.\n\n* `LOG_LEVEL = {info | debug | replication | debugv | debugvv}` Changes the current log verboseness level.\n\n* `MAINTENANCE = {0 | 1}` When set to 1, puts the server in maintenance mode. Only clients with VIP connections can execute queries in this mode. All new non-VIP incoming connections are refused. Existing connections are left intact.\n\n* `MAX_THREADS_PER_QUERY = <POSITIVE_INT_VALUE>` Redefines [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query) at runtime. As global, it changes behavior for all sessions. Value 0 means 'no limit'. If both per-session and global variables are set, the per-session one has a higher priority.\n\n* `NET_WAIT = {-1 | 0 | POSITIVE_INT_VALUE}` Changes the [net_wait_tm](../Server_settings/Searchd.md#net_wait_tm) searchd settings value.\n\n* `OPTIMIZE_CUTOFF = <value>`: Changes the value of the config's [optimize_cutoff](../Server_settings/Searchd.md#optimize_cutoff) setting on-the-fly.\n\n* `PSEUDO_SHARDING = {1|0}` Turns on/off search [pseudo-sharding](../Server_settings/Searchd.md#pseudo_sharding).",
    "translations": {
      "russian": "`threads_ex` задаёт шаблон CPU для стандартных задач и для псевдо-шардинга, так как псевдо-шардинг может быть частью стандартного процесса параллелизации. Например, если есть несколько дисковых чанков, они будут опрашиваться параллельно, но каждый из них может быть дополнительно распараллелен с помощью псевдо-шардинга. Таким образом, для эффективного управления этой ситуацией нужны несколько шаблонов для каждого типа задач.\n\nШаблон — это строка вида `10/3`, где 10 обозначает параллелизм, а 3 — размер батча. Если параллелизм равен 0, будет использован параллелизм по умолчанию. Если размер батча равен 0, будет использован шаблон по умолчанию (тривиальный). Любое значение 0 можно опустить или заменить на `*`. Шаблон по умолчанию (тривиальный) можно описать как `''`, а также как `*/*`, `0/0`, `0/`, `*/`, `/0`, `*` и т. п. Это означает, что демон использует все доступные ядра CPU без специальных ограничений на батчи.\n\nТривиальный шаблон с 20 потоками можно выразить как `20/*`, `20/0`, `20/` или просто `20`. Шаблон round-robin с размером батча 2 — это `*/2`, `0/2` или просто `/2`. Диспетчер round-robin с 20 потоками и размером батча 3 — `20/3`.\n\n`threads_ex` — это шаблон для базовых задач и для псевдо-шардинга, разделённые знаком `+`, например:\n\n* `30+3` — тривиальная база из 30 потоков + тривиальный псевдо-шардинг из 3 потоков\n\n* `+/2` — тривиальная база + round-robin псевдо-шардинг с потоками по умолчанию и размером батча 2\n\n* `10` — тривиальная база из 10 потоков + тривиальный псевдо-шардинг по умолчанию\n\n* `/1+10` — round-robin база с потоками по умолчанию и размером батча 1 + тривиальный псевдо-шардинг с 10 потоками\n\n* `4/2+2/1` — round-robin база с 4 потоками и размером батча 2 + round-robin псевдо-шардинг с 2 потоками и размером батча 1\n\n* `1+1` — самый детерминированный случай. Ровно 1 поток + 1 псевдо-шард, то есть никакой параллелизации вообще. С этой настройкой можно воспроизводимо повторять один и тот же проблемный запрос и исследовать детали поведения. Более того, если установить `throttling_period=0`, ваш запрос «прилипнет» к текущему потоку и никогда не будет перепланирован во время выполнения, создавая идеальную среду для отладки.\n\nОпция может быть установлена глобально извне как переменная окружения `MANTICORE_THREADS_EX`, например:\n\n```bash\n\nexport MANTICORE_THREADS_EX=8\n\nexport MANTICORE_THREADS_EX='16+8/2'\n\n```\n\nИли через MySQL CLI, например:\n\n```sql\n\nSET threads_ex='16';\n\nSET GLOBAL threads_ex='/2';\n\n```\n\nИли как параметр запроса, например:\n\n```sql\n\nSELECT ... OPTION threads_ex='1+1';\n\n```\n\nКонфигурация `threads_ex` следует иерархии: сначала переменные окружения, затем глобальная переменная, и наконец, опции запроса, что позволяет конкретным настройкам переопределять общие.\n\n</details>\n\n* `WAIT_TIMEOUT/net_read_timeout = <value>` задаёт таймаут соединения, либо для сессии, либо глобально. Глобально можно установить только на VIP-соединении.\n\nИзвестные глобальные переменные сервера:\n\n* `ACCURATE_AGGREGATION`: задаёт значение по умолчанию для опции [accurate_aggregation](../Searching/Options.md#accurate_aggregation) будущих запросов.\n\n* `AUTO_OPTIMIZE = {1|0}` Включает/выключает [auto_optimize](../Server_settings/Searchd.md#auto_optimize).\n\n* `cluster_user = name` Задаёт имя пользователя, используемое с `mysqldump` / `mariadb-dump` для [включения режима репликации](../Securing_and_compacting_a_table/Backup_and_restore.md#Backup-and-restore-with-mysqldump).\n\n* `COREDUMP= {1|0}` Включает/выключает сохранение core-файла или минидампа сервера при сбое. Подробнее [здесь](../Starting_the_server/Manually.md#searchd-command-line-options).\n\n* `CPUSTATS= {1|0}` Включает/выключает [отслеживание времени CPU](../Starting_the_server/Manually.md#searchd-command-line-options).\n\n* `DISTINCT_PRECISION_THRESHOLD`: задаёт значение по умолчанию для опции [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) будущих запросов.\n\n* `ES_COMPAT = {on/off/dashboards}` При установке в `on` (по умолчанию) поддерживаются запросы на запись, похожие на Elasticsearch; `off` отключает поддержку; `dashboards` включает поддержку и также разрешает запросы из Kibana (эта функциональность экспериментальная).\n\n* `EXPANSION_MERGE_THRESHOLD_DOCS`: изменяет значение настройки конфигурации [expansion_merge_threshold_docs](../Server_settings/Searchd.md#expansion_merge_threshold_docs) на лету.\n\n* `EXPANSION_MERGE_THRESHOLD_HITS`: изменяет значение настройки конфигурации [expansion_merge_threshold_hits](../Server_settings/Searchd.md#expansion_merge_threshold_hits) на лету.\n\n* `GROUPING_IN_UTC = {0 | 1}` При установке в 1 функции группировки по времени (day(), month(), year(), yearmonth(), yearmonthday()) вычисляются в UTC. Подробнее см. документацию по параметрам конфигурации [grouping_in_utc](../Server_settings/Searchd.md).\n\n* `IOSTATS = {0 | 1}` Включает или отключает отчётность о I/O операциях (кроме атрибутов) в журнале запросов.\n\n* `LOG_DEBUG_FILTER = <string value>` Фильтрует избыточные сообщения журнала. Если значение установлено, то все логи с уровнем > INFO (то есть `DEBUG`, `DEBUGV` и т. п.) будут сравниваться со строкой и выводиться только если начинаются с данного значения.\n\n* `LOG_LEVEL = {info | debug | replication | debugv | debugvv}` Изменяет текущий уровень подробности журнала.\n\n* `MAINTENANCE = {0 | 1}` При установке в 1 переводит сервер в режим обслуживания. В этом режиме запросы могут выполнять только клиенты с VIP-соединениями. Все новые не-VIP соединения отклоняются. Существующие соединения остаются без изменений.\n\n* `MAX_THREADS_PER_QUERY = <POSITIVE_INT_VALUE>` Переопределяет [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query) во время работы. Как глобальная переменная, изменяет поведение для всех сессий. Значение 0 означает «без ограничений». Если установлены и переменная на сессию, и глобальная, приоритет выше у переменной на сессию.\n\n* `NET_WAIT = {-1 | 0 | POSITIVE_INT_VALUE}` Изменяет значение настройки [net_wait_tm](../Server_settings/Searchd.md#net_wait_tm) searchd.\n\n* `OPTIMIZE_CUTOFF = <value>`: изменяет значение настройки конфигурации [optimize_cutoff](../Server_settings/Searchd.md#optimize_cutoff) на лету.\n\n* `PSEUDO_SHARDING = {1|0}` Включает/выключает поиск с использованием [псевдо-шардинга](../Server_settings/Searchd.md#pseudo_sharding).",
      "chinese": "\t`threads_ex` 设置标准任务和伪分片的 CPU 模板，因为伪分片可以是标准并行化过程的一部分。例如，如果有多个磁盘块，它们将并行查询，但每个块可能进一步使用伪分片进行并行化。因此，为了有效管理这种情况，您需要为每种任务类型准备几个模板。\n\n\t模板是类似 `10/3` 的字符串，其中 10 表示并发数，3 表示批处理大小。如果并发数为 0，则使用默认并发数。如果批处理大小为 0，则使用默认的简单模板。任何为零的值都可以省略或替换为 `*`。默认（简单）模板可以描述为 `''`，也可以是 `*/*`、`0/0`、`0/`、`*/`、`/0`、`*` 等。这意味着守护进程使用所有可用的 CPU 核心，没有特殊的批处理限制。\n\n\t带有 20 线程的简单模板可以表示为 `20/*`、`20/0`、`20/`，或简单地写为 `20`。批处理大小为 2 的轮询模板是 `*/2`、`0/2`，或简单地写为 `/2`。具有 20 线程和批处理大小为 3 的轮询调度器是 `20/3`。\n\n\t`threads_ex` 是基本任务和伪分片的模板，由 `+` 分隔，如：\n\n\t* `30+3` - 30 线程的简单基础 + 3 线程的简单伪分片\n\n\t* `+/2` - 简单基础 + 轮询伪分片，使用默认线程数和批处理大小为 2\n\n\t* `10` - 10 线程的简单基础 + 默认简单伪分片\n\n\t* `/1+10` - 轮询基础，使用默认线程数和批处理大小为 1 + 10 线程的简单伪分片\n\n\t* `4/2+2/1` - 4 线程、批处理大小为 2 的轮询基础 + 2 线程、批处理大小为 1 的轮询伪分片\n\n\t* `1+1` - 最确定性的情况。恰好 1 个线程 + 1 个伪分片，即完全没有并行化。使用此设置，您可以可重复地执行相同的有问题查询并调查行为细节。此外，如果设置 `throttling_period=0`，您的查询将在当前线程“粘住”，执行期间永远不会重新调度，创造理想的故障排查环境。\n\n\t该选项可以从外部全局设置为环境变量 `MANTICORE_THREADS_EX`，例如：\n\n\t```bash\n\n\texport MANTICORE_THREADS_EX=8\n\n\texport MANTICORE_THREADS_EX='16+8/2'\n\n  ```\n\n  或通过 MySQL CLI 设置，如：\n\n  ```sql\n\n  SET threads_ex='16';\n\n\tSET GLOBAL threads_ex='/2';\n\n  ```\n\n  或作为查询参数，如：\n\n  ```sql\n\n  SELECT ... OPTION threads_ex='1+1';\n\n  ```\n\n  `threads_ex` 配置遵循层级结构：首先是环境变量，然后是全局变量，最后是查询选项，允许特定设置覆盖通用设置。\n\n  </details>\n\n* `WAIT_TIMEOUT/net_read_timeout = <value>` 设置连接超时，可以是会话级别或全局级别。全局只能在 VIP 连接上设置。\n\n已知的全局服务器变量有：\n\n* `ACCURATE_AGGREGATION`：设置未来查询选项 [accurate_aggregation](../Searching/Options.md#accurate_aggregation) 的默认值。\n\n* `AUTO_OPTIMIZE = {1|0}`：开启或关闭 [auto_optimize](../Server_settings/Searchd.md#auto_optimize)。\n\n* `cluster_user = name`：设置用于 `mysqldump` / `mariadb-dump` 的用户名，以[启用复制模式](../Securing_and_compacting_a_table/Backup_and_restore.md#Backup-and-restore-with-mysqldump)。\n\n* `COREDUMP= {1|0}`：开启或关闭服务器崩溃时保存核心文件或迷你转储。更多详情见[这里](../Starting_the_server/Manually.md#searchd-command-line-options)。\n\n* `CPUSTATS= {1|0}`：开启或关闭[CPU 时间跟踪](../Starting_the_server/Manually.md#searchd-command-line-options)。\n\n* `DISTINCT_PRECISION_THRESHOLD`：设置未来查询选项 [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) 的默认值。\n\n* `ES_COMPAT = {on/off/dashboards}`：设置为 `on`（默认）时，支持类似 Elasticsearch 的写请求；`off` 禁用支持；`dashboards` 启用支持并允许来自 Kibana 的请求（此功能为实验性）。\n\n* `EXPANSION_MERGE_THRESHOLD_DOCS`：动态更改配置中的 [expansion_merge_threshold_docs](../Server_settings/Searchd.md#expansion_merge_threshold_docs) 设置值。\n\n* `EXPANSION_MERGE_THRESHOLD_HITS`：动态更改配置中的 [expansion_merge_threshold_hits](../Server_settings/Searchd.md#expansion_merge_threshold_hits) 设置值。\n\n* `GROUPING_IN_UTC = {0 | 1}`：设置为 1 时，使定时分组函数（day(), month(), year(), yearmonth(), yearmonthday()）以 UTC 计算。更多详情请参阅 [grouping_in_utc](../Server_settings/Searchd.md) 配置参数文档。\n\n* `IOSTATS = {0 | 1}`：启用或禁用查询日志中的 I/O 操作报告（属性除外）。\n\n* `LOG_DEBUG_FILTER = <string value>`：过滤冗余日志消息。如果设置了该值，则所有级别高于 INFO（即 `DEBUG`、`DEBUGV` 等）的日志将与该字符串比较，仅当日志以该字符串开头时才输出。\n\n* `LOG_LEVEL = {info | debug | replication | debugv | debugvv}`：更改当前日志详细级别。\n\n* `MAINTENANCE = {0 | 1}`：设置为 1 时，将服务器置于维护模式。只有 VIP 连接的客户端可以在此模式下执行查询。所有新的非 VIP 连接将被拒绝。现有连接保持不变。\n\n* `MAX_THREADS_PER_QUERY = <POSITIVE_INT_VALUE>`：运行时重新定义 [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query)。作为全局变量时，改变所有会话的行为。值为 0 表示“无限制”。如果同时设置了会话级和全局变量，会话级优先。\n\n* `NET_WAIT = {-1 | 0 | POSITIVE_INT_VALUE}`：更改 [net_wait_tm](../Server_settings/Searchd.md#net_wait_tm) searchd 设置值。\n\n* `OPTIMIZE_CUTOFF = <value>`：动态更改配置中的 [optimize_cutoff](../Server_settings/Searchd.md#optimize_cutoff) 设置值。\n\n* `PSEUDO_SHARDING = {1|0}`：开启或关闭搜索[伪分片](../Server_settings/Searchd.md#pseudo_sharding)。"
    },
    "is_code_or_comment": false
  }
}
