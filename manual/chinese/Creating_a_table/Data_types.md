# 数据类型

## 全文字段和属性

Manticore 的数据类型可以分为两类：全文字段和属性。

### 字段名称语法

Manticore 中的字段名称必须遵循以下规则：

* 可以包含字母（a-z, A-Z）、数字（0-9）和连字符（-）
* 必须以字母开头
* 数字只能出现在字母之后
* 下划线（`_`）是唯一允许的特殊字符
* 字段名称不区分大小写

例如：
* 合法的字段名称：`title`、`product_id`、`user_name_2`
* 非法的字段名称：`2title`、`-price`、`user@name`

### 全文字段

全文字段：
* 可以使用自然语言处理算法建立索引，因此可以搜索关键词
* 不能用于排序或分组
* 可以检索原始文档内容
* 可以使用原始文档内容进行高亮显示

全文字段由数据类型 `text` 表示。所有其他数据类型称为“属性”。

### 属性

属性是与每个文档关联的非全文值，可用于在搜索期间执行非全文过滤、排序和分组。

通常需要不仅依据匹配的文档 ID 和其排名处理全文搜索结果，还需要基于每个文档的多个其他值进行处理。例如，可能需要按日期然后按相关性排序新闻搜索结果，或在指定价格范围内搜索产品，或限制博客搜索为特定用户发布的帖子，或按月对结果进行分组。为高效实现这些功能，Manticore 不仅支持全文字段，还允许为每个文档添加额外的属性。这些属性可用于过滤、排序或分组全文匹配项，或仅通过属性进行搜索。

与全文字段不同，属性不进行全文索引。它们存储在表中，但不能作为全文进行搜索。

<!-- example attributes or fields -->

一个属性的好例子是论坛帖子表。假设只有标题和内容字段需要全文搜索，但有时还需要限制搜索为特定作者或子论坛（即仅搜索具有某些特定 author_id 或 forum_id 值的行）；或者按照 post_date 列排序匹配项；或者按 post_date 的月份对匹配帖子进行分组并计算每组的匹配计数。

<!-- intro -->
##### SQL:
<!-- request SQL -->

```sql
CREATE TABLE forum(title text, content text, author_id int, forum_id int, post_date timestamp);
```
<!-- intro -->
##### JSON:

<!-- request JSON -->

```JSON
POST /cli -d "CREATE TABLE forum(title text, content text, author_id int, forum_id int, post_date timestamp)"
```

<!-- intro -->
##### PHP:

<!-- request PHP -->

```php
$index = new \Manticoresearch\Index($client);
$index->setName('forum');
$index->create([
    'title'=>['type'=>'text'],
	'content'=>['type'=>'text'],
	'author_id'=>['type'=>'int'],
	'forum_id'=>['type'=>'int'],
	'post_date'=>['type'=>'timestamp']
]);
```
<!-- intro -->
##### Python:

<!-- request Python -->

```python
utilsApi.sql('CREATE TABLE forum(title text, content text, author_id int, forum_id int, post_date timestamp)')
```

<!-- intro -->
##### Python-asyncio:

<!-- request Python-asyncio -->

```python
await utilsApi.sql('CREATE TABLE forum(title text, content text, author_id int, forum_id int, post_date timestamp)')
```

<!-- intro -->
##### Javascript:

<!-- request Javascript -->

```javascript
res = await utilsApi.sql('CREATE TABLE forum(title text, content text, author_id int, forum_id int, post_date timestamp)');
```

<!-- intro -->
##### Java:

<!-- request Java -->

```java
utilsApi.sql("CREATE TABLE forum(title text, content text, author_id int, forum_id int, post_date timestamp)");
```

<!-- intro -->
##### C#:

<!-- request C# -->

```java
utilsApi.Sql("CREATE TABLE forum(title text, content text, author_id int, forum_id int, post_date timestamp)");
```

<!-- intro -->
##### Rust:

<!-- request Rust -->

```rust
utils_api.sql("CREATE TABLE forum(title text, content text, author_id int, forum_id int, post_date timestamp)", Some(true)).await;
```

<!-- intro -->
##### config:

<!-- request config -->

```ini
table forum
{
	type = rt
	path = forum

	# when configuring fields via config, they are indexed (and not stored) by default
	rt_field = title
	rt_field = content

	# this option needs to be specified for the field to be stored
	stored_fields = title, content

	rt_attr_uint = author_id
	rt_attr_uint = forum_id
	rt_attr_timestamp = post_date
}
```

<!-- end -->

<!-- example filtered query -->

此示例显示了运行一个全文查询，并通过 `author_id`、`forum_id` 过滤，同时按 `post_date` 排序。

<!-- intro -->
##### SQL:
<!-- request SQL -->

```sql
select * from forum where author_id=123 and forum_id in (1,3,7) order by post_date desc
```
<!-- intro -->
##### JSON:

<!-- request JSON -->

```JSON
POST /search
{
  "table": "forum",
  "query":
  {
    "match_all": {},
    "bool":
    {
      "must":
      [
        { "equals": { "author_id": 123 } },
		{ "in": { "forum_id": [1,3,7] } }
      ]
    }
  },
  "sort": [ { "post_date": "desc" } ]
}
```

<!-- intro -->
##### PHP:

<!-- request PHP -->

```php
$client->search([
        'table' => 'forum',
        'query' =>
        [
            'match_all' => [],
            'bool' => [
                'must' => [
                    'equals' => ['author_id' => 123],
                    'in' => [
                        'forum_id' => [
                            1,3,7
                        ]
                    ]
                ]
            ]
        ],
        'sort' => [
        ['post_date' => 'desc']
    ]
]);
```


<!-- intro -->
##### Python:

<!-- request Python -->

```python
searchApi.search({"table":"forum","query":{"match_all":{},"bool":{"must":[{"equals":{"author_id":123}},{"in":{"forum_id":[1,3,7]}}]}},"sort":[{"post_date":"desc"}]})
```

<!-- intro -->
##### Python-asyncio:

<!-- request Python-asyncio -->

```python
await searchApi.search({"table":"forum","query":{"match_all":{},"bool":{"must":[{"equals":{"author_id":123}},{"in":{"forum_id":[1,3,7]}}]}},"sort":[{"post_date":"desc"}]})
```

<!-- intro -->
##### Javascript:

<!-- request javascript -->

```javascript
res = await searchApi.search({"table":"forum","query":{"match_all":{},"bool":{"must":[{"equals":{"author_id":123}},{"in":{"forum_id":[1,3,7]}}]}},"sort":[{"post_date":"desc"}]});
```
<!-- intro -->
##### java:

<!-- request java -->

```java
HashMap<String,Object> filters = new HashMap<String,Object>(){{
    put("must", new HashMap<String,Object>(){{
        put("equals",new HashMap<String,Integer>(){{
            put("author_id",123);
        }});
        put("in",
            new HashMap<String,Object>(){{
                put("forum_id",new int[] {1,3,7});
        }});
    }});
}};
Map<String,Object> query = new HashMap<String,Object>();
query.put("match_all",null);
query.put("bool",filters);
SearchRequest searchRequest = new SearchRequest();
searchRequest.setIndex("forum");
searchRequest.setQuery(query);
searchRequest.setSort(new ArrayList<Object>(){{
    add(new HashMap<String,String>(){{ put("post_date","desc");}});
}});
SearchResponse searchResponse = searchApi.search(searchRequest);
```

<!-- intro -->
##### C#:

<!-- request C# -->

```clike
object query =  new { match_all=null };
var searchRequest = new SearchRequest("forum", query);
var boolFilter = new BoolFilter();
boolFilter.Must = new List<Object> {
    new EqualsFilter("author_id", 123),
    new InFilter("forum_id", new List<Object> {1,3,7})
};
searchRequest.AttrFilter = boolFilter;
searchRequest.Sort = new List<Object> { new SortOrder("post_date", SortOrder.OrderEnum.Desc) };
var searchResponse = searchApi.Search(searchRequest);
```

<!-- intro -->
##### Rust:

<!-- request Rust -->

``` rust
let query = SearchQuery::new();
let mut sort = HashMap::new();
sort.insert("post_date".to_string(), serde_json::json!("desc"));
let search_request = SearchRequest {
    table: "forum".to_string(),
    query: Some(Box::new(query)),
    sort: serde_json::json!(sort)
    ..Default::default()
};
let search_res = search_api.search(search_req).await;
```

<!-- end -->

### 行存和列存属性存储

Manticore 支持两种类型的属性存储：
* 行存 - Manticore Search 开箱即用的传统存储
* 列存 - 由 [Manticore Columnar Library](https://github.com/manticoresoftware/columnar) 提供

从名称可以看出，它们存储数据的方式不同。传统的**行存储**：
* 存储属性时不压缩
* 同一文档的所有属性存储在一行中，彼此相邻
* 按行存储
* 访问属性基本上通过将行 ID 乘以步长（单个向量的长度），从计算出的内存位置获取请求的属性。这带来了非常低的随机访问延迟。
* 属性必须在内存中才能获得可接受的性能，否则由于行存储的特性，Manticore 可能不得不读取过多不必要的磁盘数据，在许多情况下这不是最优的。

而**列存储**：
* 每个属性独立于其他属性存储在其单独的“列”中
* 存储被分成每块 65536 条目
* 块存储为压缩格式。这通常允许只存储少量不同值，而不像行存储那样存储全部。高压缩比能加快磁盘读取速度，并大幅降低内存需求
* 在索引数据时，每块独立选择存储方案。例如，如果块内所有值相同，则采用“常量”存储，只存储一个值表示整个块。如果每块内唯一值少于 256 个，则采用“表格”存储，存储索引而非直接存储值
* 如能确定请求的值不在块中，可以提前拒绝对该块的搜索

列存储设计用来处理内存无法容纳的大量数据，使用建议如下：
* 如果你有足够内存容纳所有属性，使用行存储会更有益
* 否则，列存储仍能提供不错的性能，同时内存占用更低，这允许你在表中存储更多文档





















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































