# 基于成本的优化器

当 Manticore 执行全扫描查询时，它可以使用普通扫描来检查每个文档是否符合过滤器，或者采用额外的数据和/或算法来加速查询执行。Manticore 使用基于成本的优化器 (CBO)，也称为“查询优化器”，以确定采取哪种方法。

CBO 也可以提升全文查询的性能。具体详情见下文。

如果 CBO 判断可以通过替换一个或多个查询过滤器来提高性能，它可能会用以下实体之一进行替换：

1. **docid 索引**利用存储在 `.spt` 扩展名文件中的特殊 docid-only 二级索引。除了改善文档 ID 上的过滤器外，docid 索引还用于加速文档 ID 到行 ID 的查找，并在守护进程启动期间加速大杀伤列表的应用。
2. **列扫描**依赖于列存储，并且只能用于列属性。它扫描每个值，并测试它是否符合过滤器，但它经过了高度优化，并且通常比默认方法更快。
3. **二级索引**默认为所有属性（除了 JSON）生成。它们使用 [PGM 索引](https://pgm.di.unipi.it/) 与 Manticore 的内置倒排索引来检索与一个值或一系列值对应的行 ID 列表。二级索引存储在扩展名为 `.spidx` 和 `.spjidx` 的文件中。
有关如何在 JSON 属性上生成二级索引的信息，请参见 [json_secondary_indexes](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#json_secondary_indexes)。

优化器使用各种属性统计信息来估计每个执行路径的成本，包括：

1. 属性内部数据分布的信息（直方图，存储在 `.sphi` 文件中）。当数据被索引时，直方图会自动生成，并作为 CBO 的主要信息来源。
2. 来自 PGM（次级索引）的信息，帮助估计要读取的文档列表数量。这有助于评估文档列表合并性能，并选择合适的合并算法（优先队列合并或位图合并）。
3. 列存储编码统计信息，用于估计列数据解压缩性能。
4. 列的最小-最大树。虽然 CBO 使用直方图来估计应用过滤器后剩余的文档数量，但它还需要确定过滤器需要处理多少文档。对于列属性，最小-最大树的部分评估满足了这一目的。
5. 全文字典。CBO 利用术语统计来估计评估全文树的成本。

优化器计算查询中使用的每个过滤器的执行成本。由于某些过滤器可以用几种不同的实体进行替换（例如，对于文档 ID，Manticore 可以使用普通扫描、docid 索引查找、列扫描（如果文档 ID 是列式的）和二级索引），优化器会评估所有可用的组合。然而，最多只能有 1024 种组合。

为了估算查询执行成本，优化器计算执行查询时进行的最重要操作的估计成本。它使用预设常数来表示每个操作的成本。

优化器比较每个执行路径的成本，并选择最低成本的路径来执行查询。

在处理具有属性过滤器的全文查询时，查询优化器在两种可能的执行路径之间做出决策。一种是执行全文查询，检索匹配结果，然后使用过滤器。另一种是用上述一个或多个实体替换过滤器，从中获取行 ID，并将其注入到全文匹配树中。通过这种方式，全文搜索结果将与全扫描结果相交。查询优化器估算全文树评估的成本以及计算过滤器结果的最佳可能路径。利用这些信息，优化器选择执行路径。

另一个需要考虑的因素是多线程查询执行（当启用 `pseudo_sharding` 时）。CBO 知道一些查询可以在多个线程中执行，并考虑到这一点。CBO 优先考虑较短的查询执行时间（即延迟），而不是吞吐量。例如，如果一个使用列扫描的查询可以在多个线程中执行（并占用多个 CPU 核心），并且比使用二级索引在单线程中执行的查询更快，则将更倾向于多线程执行。

使用二级索引和 docid 索引的查询始终在单线程中运行，因为基准测试表明将其设置为多线程几乎没有收益。

目前，优化器仅使用 CPU 成本，而不考虑内存或磁盘使用情况。

<!-- proofread -->
