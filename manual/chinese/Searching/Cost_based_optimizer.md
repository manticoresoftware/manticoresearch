# 基于成本的优化器

当 Manticore 执行全扫描查询时，它可以使用普通扫描来检查每个文档是否符合过滤条件，也可以使用额外的数据和/或算法来加速查询执行。Manticore 使用基于成本的优化器（CBO），也称为“查询优化器”，来确定采取哪种方法。

CBO 还可以提升全文本查询的性能。详见下文。

如果 CBO 认为这样做能提升性能，它可能决定用以下一种或多种实体替换一个或多个查询过滤器：

1. **docid 索引** 利用一种特殊的仅包含 docid 的二级索引，存储在扩展名为 `.spt` 的文件中。除了提升文档 ID 的过滤之外，docid 索引还用于加速文档 ID 到行 ID 的查找，以及在守护进程启动时加快大规模 killlist 的应用。
2. **列式扫描** 依赖列式存储，仅能用于列式属性。它扫描每个值并根据过滤器测试该值，但该方法经过高度优化，通常比默认方法更快。
3. **二级索引** 默认为所有属性（除 JSON 外）生成。它们使用 [PGM 索引](https://pgm.di.unipi.it/) 以及 Manticore 内置的倒排索引来检索对应某个值或值范围的行 ID 列表。二级索引存储在扩展名为 `.spidx` 和 `.spjidx` 的文件中。
关于如何为 JSON 属性生成二级索引，请参见 [json_secondary_indexes](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#json_secondary_indexes)。

优化器利用各种属性统计信息来估算每条执行路径的成本，包括：

1. 属性内数据分布信息（直方图，存储在 `.sphi` 文件中）。直方图在数据索引时自动生成，是 CBO 的主要信息来源。
2. 来自 PGM（二级索引）的信息，有助于估算需要读取的文档列表数量。这有助于评估文档列表合并性能，并选择合适的合并算法（优先队列合并或位图合并）。
3. 列式编码统计信息，用于估算列式数据解压性能。
4. 列式最小-最大树。虽然 CBO 使用直方图估算应用过滤器后剩余的文档数量，但它还需要确定过滤器处理了多少文档。对于列式属性，部分评估最小-最大树满足这一需求。
5. 全文词典。CBO 利用词项统计来估算全文树的评估成本。

优化器为查询中使用的每个过滤器计算执行成本。因为某些过滤器可以被多种不同实体替代（例如，对于文档 id，Manticore 可以使用普通扫描、docid 索引查找、列式扫描（如果文档 id 是列式的）以及二级索引），优化器会评估所有可用组合。但组合数量最大限制为 1024 种。

为了估算查询执行成本，优化器计算执行查询时进行的最重要操作的预估成本。它使用预设常数来表示每项操作的成本。

优化器比较每条执行路径的成本，并选择成本最低的路径来执行查询。

处理带有属性过滤器的全文本查询时，查询优化器会在两种执行路径中做出选择：一种是执行全文查询、检索匹配项并使用过滤器；另一种是用上述一个或多个实体替换过滤器，从中获取行 ID，并将其注入全文匹配树。这样，全文搜索结果将与全扫描结果相交。查询优化器估算全文树评估成本及过滤结果计算的最佳路径，利用这些信息选择执行路径。

另一个需要考虑的因素是多线程查询执行（当启用 `pseudo_sharding` 时）。CBO 知道某些查询可以多线程执行，并将此考虑在内。CBO 优先考虑较短的查询执行时间（即延迟）而非吞吐量。例如，如果某查询使用列式扫描可以在多个线程中执行（占用多个 CPU 核心），且其速度快于在单线程中使用二级索引执行的查询，则会优先选择多线程执行。

使用二级索引和 docid 索引的查询始终在单线程中运行，因为基准测试表明对它们进行多线程处理几乎没有或完全没有性能提升。

目前优化器仅使用 CPU 成本，并未考虑内存或磁盘使用。

<!-- proofread -->

