# 实时表结构

可以使用一种称为 `indexer` 的特殊工具从外部源创建简单的表，该工具从配置中读取“配方”，连接数据源，拉取文档，并构建表文件。这是一个耗时的过程。如果您的数据发生变化，表就会过时，您需要从更新的源重新构建它。如果您的数据是增量变化的，比如博客或新闻推送，其中旧文档从不更改，只添加新文档，那么重建所花费的时间会越来越多，因为每次都需要再次处理归档源。

处理该问题的一种方法是使用多个表而不是一个整体表。例如，您可以处理以前年份产生的源并保存表。然后，只取当前年份的源，放入单独的表中，并在必要时重建。然后，您可以将这两个表作为分布式表的一部分，并用它进行查询。关键在于每次重建时，您最多只处理最近12个月的数据，而包含旧数据的表保持不变，无需重建。您还可以进一步将最近12个月的表划分为按月、按周或按天的表，依此类推。

这种方法可行，但您需要手动维护分布式表，也就是说，添加新的分片，删除旧的分片，并保持部分类表的总数不太多（如果表太多，搜索可能变慢，操作系统通常限制同时打开的文件数）。为了解决这个问题，可以通过运行 [indexer --merge](../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Merging_tables.md) 手动合并几个表。然而，这只解决了拥有太多表导致维护更困难的问题。即使是按“每小时”重建索引，您很可能仍会看到新数据到达源和表重建（为搜索填充数据）之间的明显时间差。

实时表旨在解决这个问题。它由两部分组成：

1. 一个特殊的基于内存的表（称为RAM分片），包含当前到达的数据部分。
2. 一组称为磁盘分片的普通表，这些表是在过去构建的。

这与由几个本地表组成的标准[分布式表](../Creating_a_table/Creating_a_distributed_table/Creating_a_distributed_table.md)非常相似。

您不需要通过运行 `indexer` 来构建此类表，`indexer` 会从配置读取“配方”以及表数据源。相反，实时表提供了“插入”新文档和“替换”现有文档的功能。当执行“插入”命令时，您将新文档推送到服务器。服务器随后从添加的文档构建一个小表，并立即上线。因此，就在“插入”命令完成后，您可以在所有表部分中进行搜索，包括刚添加的文档。

搜索服务器会自动维护表，因此您无需担心这一点。不过，您可能想了解一下“它是如何维护的”的一些细节。

**首先，因为索引数据存储在内存中——断电怎么办？** 我会丢失我的表吗？好吧，在完成前，服务器会将新数据保存到一个特殊的“binlog”中。它由一个或多个文件组成，存放在您的持久存储中，随着更多更改的添加而逐渐增长。您可以调整关于多少新查询（或事务）存储到binlog中以及多长时间执行一次对binlog文件的“同步”命令，让操作系统真正将数据保存到安全存储的行为。最严格的方式是在每个事务后都刷新并同步。这是最慢但也是最安全的方法。最不昂贵的方式是完全关闭binlog。这是最快的方法，但您有丢失索引数据的风险。中间选项也是有的，比如每秒刷新/同步一次。

binlog 专门用于顺序保存新到达的事务；它不是表，无法进行搜索。它仅作为保险单，确保服务器不会丢失您的数据。如果发生突发中断，服务器因软件或硬件故障崩溃，它将加载RAM分片的最新可用转储，然后重放binlog，重复存储的事务。最终，它会达到上次变更时的相同状态。

**其次，关于容量限制呢？** 如果我想处理比如10TB的数据，但数据无法全部放入内存怎么办！实时表的内存是有限的，可以配置。当索引的数据达到一定量时，服务器通过合并小事务来管理表的内存部分，保持事务数量和总体大小较小。但这个过程有时会导致插入延迟。当合并不再有效，且新插入触及[内存限制](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#rt_mem_limit)时，服务器会把基于内存的表转换为存储在磁盘上的普通表（称为磁盘分片）。此表被添加到实时表的第二部分表集合中，并可以在线访问。内存随即被清空，空间被释放。

当内存中的数据安全保存到磁盘时，发生以下情况之一：

* 服务器将收集的数据保存为磁盘表
* 服务器在正常关闭或通过[手动刷新](../Securing_and_compacting_a_table/Flushing_RAM_chunk_to_disk.md#FLUSH-TABLE)时转储内存部分

该表对应的binlog不再需要，因此会被丢弃。如果所有表都已保存，binlog将被删除。

**第三，关于磁盘集合呢？** 如果有很多磁盘分片会使搜索变慢，那我手动创建的分布式表方式和RT表自动生成的磁盘分片（或“chunk”）有什么区别呢？其实两者都可以把多个表合并成一个。例如，你可以把昨天的每小时表合并，变成一个昨天的“日”表。手动维护时，你得自己考虑模式和命令。对于RT表，服务器提供了[OPTIMIZE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE)命令，作用相同，但你不用关心内部复杂细节。

**第四，如果我的“文档”组成一个“迷你表”，不再需要它，我可以直接扔掉。但如果它已经“优化”，也就是和大量文档混合在一起，如何撤销或删除它？** 是的，索引文档是“混合”在一起的，除非重建整个表，否则没有简单的删除单个文档的方法。对于普通表，重建或合并是常规维护手段；但RT表保持了操作简便，却不能保证“实时性”。为了解决这个问题，Manticore用了一个技巧：当你删除一个以文档ID标识的文档时，服务器只是记录这个数字。所有删除文档的ID都会保存在所谓的[kill-list](../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#Table-kill-list)中。搜索时，服务器先检索所有匹配文档，然后剔除在kill-list中的文档（这只是最基本描述，实际内部更复杂）。关键是——为了实现“立即”删除，文档实际上没有被删除，只是标记为“已删除”。它们仍然占据不同表结构中的空间，属于垃圾。影响排名的词频统计也不受影响，这意味着搜索时是在所有文档里进行，然后仅从最终结果中隐藏标记为删除的文档。当文档被[替换](../Data_creation_and_modification/Updating_documents/REPLACE.md)时，意味着它在表的旧部分被kill掉，并在最新部分重新插入。“通过killlist隐藏”的所有后果在这种情况下同样适用。

当某些表部分重建时，例如RAM chunk若干事务（段）合并，或者RAM chunk转换为磁盘chunk，或者两个磁盘chunk合并时，服务器会全面遍历受影响部分，物理清除其中的已删除文档。也就是说，如果它们在某些词的文档列表中，那就被清除。如果是唯一词，则彻底删除。

总结：删除过程分两阶段：
1. 首先，实时将文档标记为“已删除”，并在搜索结果中屏蔽它们。
2. 在RT表chunk进行某些操作时，最终物理删除这些已删除文档。

**第五，如果RT表在其集合中包含普通磁盘表，我能直接把已有的老磁盘表添加进去吗？** 不能。这是为了避免不必要的复杂性和防止意外损坏。不过，如果你的RT表刚创建且没有数据，那么你可以[ATTACH TABLE](../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Attaching_one_table_to_another.md)你的磁盘表到它。你的旧表会被移入RT表中，成为它的一部分。

关于RT表结构的总结：它是一个巧妙组织的普通磁盘表集合，配以快速的内存表，旨在支持文档的实时插入和半实时删除。RT表拥有统一的模式和设置，且易于维护，无需深入细节。
<!-- proofread -->

