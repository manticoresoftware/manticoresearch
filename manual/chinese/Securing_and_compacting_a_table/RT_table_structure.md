# 实时表结构

可以使用一种名为 `indexer` 的特殊工具从外部源创建简单表，该工具从配置中读取“配方”，连接到数据源，拉取文档并构建表文件。这是一个漫长的过程。如果您的数据发生变化，表就会过时，您需要从更新后的源重新构建它。如果您的数据是增量变化的，例如博客或新闻源，其中旧文档永远不会改变，只会添加新文档，重建将需要越来越多的时间，因为您需要一次又一次地处理归档源。

对付这个问题的一种方法是使用多个表而不是一个整表。例如，您可以处理前几年生成的源并保存该表。然后，仅从当前年份获取源并将它们放入单独的表中，必要时进行重建。然后，您可以将两个表放置为分布式表的一部分并使用它进行查询。这一点在于每次重建时，您最多只处理过去12个月的数据，而旧数据的表保持不变，无需重建。您还可以进一步将最近12个月的表分为按月、按周或按日的表，等等。

这种方法是有效的，但您需要手动维护分布式表。也就是说，添加新块，删除旧块，并保持部分表的总数不太大（表太多可能会导致搜索变慢，而且操作系统通常限制同时打开的文件数量）。为此，您可以通过运行 [indexer --merge](../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Merging_tables.md) 手动将几个表合并在一起。然而，这只解决了表过多的问题，使维护变得更具挑战性。即使是每小时重新索引，您也很可能会在新数据到达源与重建表之间出现明显的时间差，而这个表用以填充搜索数据。

实时表旨在解决此问题。它由两个部分组成：

1. 一个基于RAM的特殊表（称为RAM块），包含当前到达的数据部分。
2. 一组称为磁盘块的简单表，这些表是在过去构建的。

这与由几个本地表组成的标准 [分布式表](../Creating_a_table/Creating_a_distributed_table/Creating_a_distributed_table.md) 非常相似。

您无需通过运行 `indexer` 来构建这样的表，它从配置和表数据源读取“配方”。相反，实时表提供了“插入”新文档和“替换”现有文档的能力。当执行“插入”命令时，您将新文档推送到服务器。然后，它会从添加的文档构建一个小表并立即上线。因此，就在“插入”命令完成后，您可以在所有表部分进行搜索，包括刚添加的文档。

搜索服务器会自动维护该表，因此您无需担心它。然而，您可能会对“它是如何维护的”感兴趣。

**首先，由于索引数据存储在RAM中——如果发生紧急断电怎么办？** 那我会丢失我的表吗？在完成之前，服务器会将新数据保存到一个特殊的“binlog”中。这个binlog由一个或多个文件组成，存储在您的持久化存储上，随着您添加越来越多的更改而逐步增长。您可以调整关于新查询（或事务）存储在binlog中频率的行为，以及执行“同步”命令的频率，以强制操作系统实际上将数据保存到安全存储。最谨慎的方法是在每个事务后进行刷新和同步。这是最快但也是最安全的方法。最便宜的方法是完全关闭binlog。这是最快的方法，但您有丢失索引数据的风险。中间变体，例如每秒刷新/同步，也会提供。

binlog专门设计用于顺序保存新到达的事务；它不是一个表，无法进行搜索。它只是一个保险政策，以确保服务器不会丢失您的数据。如果发生突然中断，因软件或硬件问题导致一切崩溃，服务器会加载RAM块最近可用的转储，然后重放binlog，重复存储的事务。最终，它将达到最后一次更改时的相同状态。

**第二，关于限制呢？** 如果我想处理，比如说，10TB的数据，但它根本无法适应RAM！实时表的RAM是有限的，并且可以配置。当索引到达一定数量的数据时，服务器通过合并小事务来管理表的RAM部分，保持它们的数量和总体大小较小。然而，这一过程有时会在插入时导致延迟。当合并不再有帮助，并且新的插入达到 [RAM限制](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#rt_mem_limit) 时，服务器将基于RAM的表转换为存储在磁盘上的简单表（称为磁盘块）。此表将被添加到RT表的第二部分的表集合中，并变得可以在线访问。然后，RAM被刷新，空间被释放。

当RAM中的数据安全保存到磁盘时，这发生在：

* 当服务器将收集到的数据保存为磁盘表时
* 或当它在正常关闭时转储RAM部分或通过 [手动刷新](../Securing_and_compacting_a_table/Flushing_RAM_chunk_to_disk.md#FLUSH-TABLE) 时

该表的binlog不再需要。因此，它将被丢弃。如果所有表都已保存，binlog将被删除。
**第三，关于磁盘集合呢？**  如果有许多磁盘部分使搜索变得更慢，那我以分布式表的方式手动制作它们，和通过 RT 表生成它们作为磁盘部分（或“块”）有什么区别呢？好吧，在这两种情况下，你可以将几张表合并为一张表。例如，你可以合并昨天的每小时表，而保持昨天的一张“日”表。通过手动维护，你必须自己考虑架构和命令。使用 RT 表，服务器提供了 [OPTIMIZE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE) 命令，它执行相同的操作，但让你远离不必要的内部细节。

**第四，如果我的“文档”构成一个“迷你表”，而我不再需要它，我可以直接扔掉它。但是如果它已被“优化”，即与大量其他文档混合在一起，我该如何撤销或删除它呢？** 是的，索引文档是“混合”在一起的，删除其中一个并没有简单的方法，除非重建整个表。而对于普通表来说，重建或合并只是正常的维护方式，对于实时表来说，保持了操作的简单性，但没有“实时性”。为了解决这个问题，Manticore 使用了一个技巧：当你删除一个通过文档 ID 识别的文档时，服务器只跟踪这个号码。与其他已删除的文档一起，它们的 ID 被保存在一个所谓的 [kill-list](../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#Table-kill-list) 中。当你在表中搜索时，服务器首先检索所有匹配的文档，然后抛出在 kill-list 中找到的文档（这是最基本的描述；事实上，内部更复杂）。关键是 - 为了“立即”删除，文档实际上并没有被删除，而只是被标记为“已删除”。它们仍然占据不同表结构中的空间，性质上是垃圾。影响排名的词统计数据也没有受到影响，意味着它的运作正如所声明的那样：我们在所有文档中搜索，然后只是将标记为已删除的文档从最终结果中隐藏。当一个文档被 [替换](../Data_creation_and_modification/Updating_documents/REPLACE.md) 时，这意味着它在表的旧部分中被删除，并在最新部分中再次插入。此时“通过 killlist 隐藏”的所有后果也在发挥作用。

当表的某个部分重建时，例如，当某些交易（段）被合并的 RAM 块，或当 RAM 块转换为磁盘块时，或当两个磁盘块合并在一起时，服务器会对受影响的部分进行全面迭代，并从所有部分中物理排除已删除的文档。也就是说，如果它们在某些词的文档列表中 - 它们会被彻底清除。如果这是一个独特的词 - 它将完全被移除。

总结一下：删除工作分为两个阶段：
1. 首先，我们实时标记文档为“已删除”，并在搜索结果中抑制它们。
2. 在对 RT 表块进行某些操作时，我们最终永久地清除已删除的文档。

**第五，如果一个 RT 表在其集合中包含普通磁盘表，我可以直接将我准备好的旧磁盘表添加到其中吗？** 不可以。无法避免不必要的复杂性并防止意外损坏。然而，如果你的 RT 表刚刚创建且没有数据，那么你可以 [ATTACH TABLE](../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Attaching_one_table_to_another.md) 将你的磁盘表附加到其中。你的旧表将被移动到 RT 表内部，并成为其一部分。

关于 RT 表结构的总结：它是一个巧妙组织的普通磁盘表集合，配有快速的内存表，旨在实现实时插入和半实时删除文档。RT 表具有共同的架构、共同的设置，并且可以在不深入细节的情况下轻松维护。
<!-- proofread -->

