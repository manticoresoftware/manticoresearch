# लोड संतुलन

किसी भी [वितरित तालिका](../../Creating_a_table/Creating_a_distributed_table/Creating_a_distributed_table.md) के लिए लोड संतुलन डिफ़ॉल्ट रूप से चालू होता है जो [मिररिंग](../../Creating_a_cluster/Remote_nodes/Mirroring.md) का उपयोग करता है। डिफ़ॉल्ट रूप से, प्रश्नों को मिरर के बीच यादृच्छिक रूप से बांटा जाता है। आप [ha_strategy](../../Creating_a_cluster/Remote_nodes/Load_balancing.md) का उपयोग करके इस व्यवहार को बदल सकते हैं।

## ha_strategy

```ini
ha_strategy = {random|nodeads|noerrors|roundrobin}
```

लोड संतुलन के लिए मिरर चयन रणनीति वैकल्पिक है और डिफ़ॉल्ट रूप से `random` पर सेट है।

मिरर चयन के लिए प्रयुक्त रणनीति, या दूसरे शब्दों में, वितरित तालिका में एक विशेष [एजेंट मिरर](../../Creating_a_cluster/Remote_nodes/Mirroring.md#Agent-mirrors) का चयन करने के लिए, इस निर्देश द्वारा नियंत्रित होती है। मूलतः, यह निर्देश यह नियंत्रित करता है कि मास्टर कैसे विनिर्धारित मिरर एजेंट नोड्स के बीच लोड संतुलन करता है। निम्नलिखित रणनीतियाँ लागू की जाती हैं:

### सरल यादृच्छिक संतुलन

<!-- example conf balancing 1 -->
डिफ़ॉल्ट संतुलन मोड मिरर के बीच सरल रैखिक यादृच्छिक वितरण है। इसका मतलब है कि प्रत्येक मिरर को समान चयन संभावनाएँ दी जाती हैं। यह राउंड-रॉबिन (RR) के समान है, लेकिन एक कड़ाई से चयन क्रम को लागू नहीं करता है।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->
```ini
ha_strategy = random
```
<!-- end -->

### अनुकूली यादृच्छिक संतुलन

डिफ़ॉल्ट सरल यादृच्छिक रणनीति मिरर की स्थिति, त्रुटि दरों, और सबसे महत्वपूर्ण, वास्तविक प्रतिक्रिया विलंबता को ध्यान में नहीं रखती है। एजेंट नोड लोड में विषम क्लस्टर और अस्थायी उछालों को संबोधित करने के लिए, ऐसी संतुलन रणनीतियों का समूह है जो मास्टर द्वारा देखी गई वास्तविक प्रश्न विलंबता के आधार पर संभावनाओं को गतिशील रूप से समायोजित करता है।

विलंबता-भारित संभावनाओं पर आधारित अनुकूली रणनीतियाँ इस प्रकार कार्य करती हैं:

1. विलंबता आँकड़े ha_period_karma सेकंड के ब्लॉकों में संचित होते हैं।
2. विलंबता-भारित संभावनाएँ एक बार प्रति कर्म अवधि में पुन: गणना की जाती हैं।
3. "मृत या जीवित" फ़्लैग को प्रत्येक अनुरोध में समायोजित किया जाता है, जिसमें पिंग अनुरोध भी शामिल हैं।

प्रारंभ में, संभावनाएँ समान होती हैं। हर चरण में, उन्हें पिछले कर्म अवधि के दौरान देखी गई विलंबताओं के विपरीत से स्केल किया जाता है, और फिर पुनर्नormal किया जाता है। उदाहरण के लिए, अगर मास्टर की शुरुआत के पहले 60 सेकंड के दौरान, 4 मिरर के विलंबता 10 मि.से., 5 मि.से., 30 मि.से., और 3 मि.से. क्रमशः थीं, तो पहला समायोजन चरण इस प्रकार होगा:

1. प्रारंभिक प्रतिशत: 0.25, 0.25, 0.25, 0.25।
2. देखी गई विलंबताएँ: 10 मि.से., 5 मि.से., 30 मि.से., 3 मि.से।
3. विपरीत विलंबताएँ: 0.1, 0.2, 0.0333, 0.333।
4. स्केल किए गए प्रतिशत: 0.025, 0.05, 0.008333, 0.0833।
5. पुनर्नormal किए गए प्रतिशत: 0.15, 0.30, 0.05, 0.50।

इसका मतलब है कि पहले मिरर को अगले कर्म अवधि के दौरान चुने जाने की 15% संभावना होगी, दूसरे को 30% संभावना, तीसरे को (30 मि.से. में सबसे धीमा) केवल 5% संभावना, और चौथे और सबसे तेज़ (3 मि.से. में) को 50% संभावना। इसके बाद, दूसरा समायोजन चरण उन संभावनाओं को फिर से अद्यतन करेगा, और इसी तरह।

विचार यह है कि जब *देखी गई विलंबताएँ* स्थिर हो जाएँगी, तो *विलंबता-भारित संभावनाएँ* भी स्थिर होंगी। सभी ये समायोजन पुनरावृत्तियाँ उस बिंदु पर समायोजित करने के लिए बनी होती हैं जहाँ औसत विलंबताएँ सभी मिरर में लगभग समान होती हैं।

<!-- example conf balancing 2 -->
#### nodeads
विलंबता-भारित संभावनाएँ, लेकिन मृत मिरर चयन से बाहर होती हैं। एक "मृत" मिरर को उस मिरर के रूप में परिभाषित किया गया है जिसने एक के बाद एक कई कठोर त्रुटियों (जैसे, नेटवर्क विफलता, या कोई उत्तर नहीं, आदि) का परिणाम दिया है।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->
```ini
ha_strategy = nodeads
```
<!-- end -->

<!-- example conf balancing 3 -->
#### noerrors

विलंबता-भारित संभावनाएँ, लेकिन अधिक खराब त्रुटि/सफलता अनुपात वाले मिरर चयन से बाहर होते हैं।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
ha_strategy = noerrors
```
<!-- end -->

### राउंड-रॉबिन संतुलन

<!-- example conf balancing 4 -->
सरल राउंड-रॉबिन चयन, अर्थात्, सूची में पहले मिरर का चयन करना, फिर दूसरे, फिर तीसरे, आदि, और उसके बाद प्रक्रिया को फिर से दोहराना जब सूची में अंतिम मिरर तक पहुँचा जाता है। यादृच्छिक रणनीतियों के विपरीत, RR एक कड़ाई से पूछताछ करने का आदेश लागू करता है (1, 2, 3, ..., N-1, N, 1, 2, 3, ..., और इसी तरह) और *सुनिश्चित* करता है कि कोई दो लगातार प्रश्न उसी मिरर को नहीं भेजे जाएंगे।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->
```ini
ha_strategy = roundrobin
```
<!-- end -->

## उदाहरण-व्यापी विकल्प

### ha_period_karma

```ini
ha_period_karma = 2m
```

`ha_period_karma` एजेंट मिरर आँकड़ों की खिड़की के आकार को परिभाषित करता है, सेकंड में (या एक समय प्रत्यय के साथ)। वैकल्पिक, डिफ़ॉल्ट 60 है।

एक एजेंट मिरर के साथ वितरित तालिका के लिए, सर्वर कई अलग-अलग प्रति-मिरर काउंटरों को ट्रैक करता है। इन काउंटरों का उपयोग फिर फेलओवर और संतुलन के लिए किया जाता है। (सर्वर काउंटर के आधार पर सबसे अच्छा मिरर उपयोग करने के लिए चुनता है।) काउंटर को `ha_period_karma` सेकंड के ब्लॉकों में संचित किया जाता है।

नए ब्लॉक की शुरुआत के बाद, मास्टर पहले वाले से संचित मानों का उपयोग कर सकता है जब तक नया आधा भरा ना हो जाए। इस प्रकार, कोई भी पूर्व का इतिहास अधिकतम 1.5 गुना ha_period_karma सेकंड के बाद मिरर के चयन को प्रभावित करना बंद कर देता है।

हालाँकि, सबसे अधिक 2 ब्लॉक मिरर चयन के लिए उपयोग किए जाते हैं, वास्तव में अंतिम 15 ब्लॉक को उपकरणों के लिए संग्रहीत किया जाता है। इन्हें `SHOW AGENT STATUS` कथन का उपयोग करके देखा जा सकता है।

### ha_ping_interval

```ini
ha_ping_interval = 3s
```

`ha_ping_interval` निर्देश एजेंट मिरर को भेजे गए पिंग के बीच के अंतराल को परिभाषित करता है, मिलीसेकंड में (या समय प्रत्यय के साथ)। यह विकल्प वैकल्पिक है और इसका डिफ़ॉल्ट मान 1000 है।
एक वितरित तालिका के लिए जो एजेंट मिरर के साथ है, सर्वर सभी मिरर को निष्क्रिय अवधि में उनकी वर्तमान स्थिति (चाहे वे जीवित हैं या मृत, नेटवर्क राउंडट्रिप समय, आदि) पर नज़र रखने के लिए एक पिंग कमांड भेजता है। पिंग के बीच का अंतराल ha_ping_interval सेटिंग द्वारा निर्धारित किया जाता है।

यदि आप पिंग को निष्क्रिय करना चाहते हैं, तो ha_ping_interval को 0 पर सेट करें।

<!-- proofread -->

