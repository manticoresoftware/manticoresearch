# दूरस्थ तालिकाएँ

Manticore खोज में एक दूरस्थ तालिका का प्रतिनिधित्व [एजेंट](../../Creating_a_table/Creating_a_distributed_table/Creating_a_distributed_table.md) उपसर्ग द्वारा किया जाता है, जो वितरित तालिका की परिभाषा में है। एक वितरित तालिका में स्थानीय और दूरस्थ तालिकाओं का संयोजन शामिल हो सकता है। यदि कोई स्थानीय तालिकाएँ प्रदान नहीं की गई हैं, तो वितरित तालिका पूरी तरह से दूरस्थ होगी और केवल एक प्रॉक्सी के रूप में कार्य करेगी। उदाहरण के लिए, आपके पास एक Manticore उदाहरण हो सकता है जो कई पोर्ट पर सुनता है और विभिन्न प्रोटोकॉलों की सेवा करता है, और फिर पूछताछों को बैकएंड सर्वरों की ओर अग्रेषित करता है जो केवल Manticore के आंतरिक बाइनरी प्रोटोकॉल के माध्यम से कनेक्शन स्वीकार करते हैं, कनेक्शन स्थापित करने के ओवरहेड को कम करने के लिए स्थायी कनेक्शनों का उपयोग करते हैं।
भले ही एक पूरी तरह से दूरस्थ वितरित तालिका स्वयं स्थानीय तालिकाओं की सेवा नहीं करती है, इसमें मशीन संसाधनों का उपयोग होता है, क्योंकि इसे अंतिम गणनाएँ करने की आवश्यकता होती है, जैसे परिणामों को मिलाना और अंतिम समग्र मानों की गणना करना।

## एजेंट

```ini
एजेंट = पता1 [ | पता2 [...] ][:तालिका-सूची]
एजेंट = पता1[:तालिका-सूची [ | पता2[:तालिका-सूची [...] ] ] ]
```

`एजेंट` निदेशिका उन दूरस्थ एजेंटों की घोषणा करती है जिनका खोजा जाता है प्रत्येक बार जब समावेशी वितरित तालिका की खोज की जाती है। ये एजेंट मूल रूप से नेटवर्केड तालिकाओं के लिए पॉइंटर्स होते हैं। निर्दिष्ट मान में पता शामिल होता है और पता केवल या पता और तालिका सूची दोनों के लिए कई विकल्प (एजेंट मिरर) भी शामिल कर सकता है।

पता निर्दिष्ट करने के लिए निम्नलिखित में से एक होना चाहिए:

```ini
पता = होस्टनेम[:पोर्ट] # जैसे. सर्वर2:9312
पता = /absolute/unix/socket/path # जैसे. /var/run/manticore2.sock
```

`होस्टनेम` दूरस्थ होस्ट नाम है, `पोर्ट` दूरस्थ TCP पोर्ट संख्या है, `तालिका-सूची` तालिका नामों की एक अल्पविराम-सेपरेटेड सूची है, और वर्ग ब्रैकेट [] एक वैकल्पिक क्लॉज को दर्शाते हैं।

यदि तालिका नाम छोड़ दिया गया है, तो यह मान लिया जाता है कि यह उसी तालिका का नाम है जहां यह पंक्ति परिभाषित है। दूसरे शब्दों में, जब 'mycoolindex' वितरित तालिका के लिए एजेंट परिभाषित करते हैं, तो आप बस पते की ओर इशारा कर सकते हैं, और यह माना जाएगा कि आप एजेंट के अंत बिंदुओं पर mycoolindex तालिका को क्वेरी कर रहे हैं।

यदि पोर्ट संख्या छोड़ दी गई है, तो इसे **9312** माना जाता है। यदि इसे परिभाषित किया गया है लेकिन अमान्य है (जैसे 70000), तो एजेंट को छोड़ दिया जाएगा।

आप प्रत्येक एजेंट को एक या अधिक दूरस्थ तालिकाओं की ओर इशारा कर सकते हैं जो एक या एक से अधिक नेटवर्केड सर्वरों पर स्थित हैं बिना किसी प्रतिबंध के। यह कई अलग-अलग उपयोग मोड सक्षम करता है:
* कई एजेंट सर्वरों पर शार्डिंग और एक मनचाही क्लस्टर टोपोलॉजी बनाना
* उच्च उपलब्धता और लोड संतुलन के उद्देश्यों के लिए कई एजेंट सर्वरों पर मिरर की गई शार्डिंग
* लोकलहोस्ट के भीतर शार्डिंग ताकि कई कोर का उपयोग किया जा सके (हालांकि, कई स्थानीय तालिकाएँ उपयोग करना अधिक सरल है)

सभी एजेंटों की खोज समानांतर में की जाती है। अनुक्रमणिका सूची को दूरस्थ एजेंट को शब्दशः भेजा जाता है। इस सूची को एजेंट के भीतर खोजा जाने का सटीक तरीका (यानी क्रम में या समानांतर में) पूरी तरह से एजेंट की कॉन्फ़िगरेशन पर निर्भर करता है (देखें [थ्रेड्स](../../Server_settings/Searchd.md#threads) सेटिंग)। मास्टर का इस पर कोई दूरस्थ नियंत्रण नहीं है।

यह ध्यान रखना महत्वपूर्ण है कि `LIMIT` विकल्प को एजेंट अनुरोधों में अनदेखा किया गया है। इसका कारण यह है कि प्रत्येक एजेंट में विभिन्न तालिकाएँ हो सकती हैं, इसलिए अंतिम परिणाम सेट पर सीमा लागू करना क्लाइंट की ज़िम्मेदारी है। इसी कारण से भौतिक तालिका के लिए क्वेरी, वितरित तालिका के लिए क्वेरी से भिन्न होती है जब क्वेरी लॉग में देखी जाती है। क्वेरी मूल क्वेरी की एक साधारण प्रति नहीं हो सकती, क्योंकि इससे सही परिणाम नहीं मिलेंगे।

उदाहरण के लिए, यदि एक क्लाइंट एक क्वेरी SELECT ... LIMIT 10, 10 करता है, और दो एजेंट होते हैं, जिनमें से दूसरे एजेंट में केवल 10 दस्तावेज होते हैं, तो मूल `LIMIT 10, 10` क्वेरी को प्रसारण करने पर दूसरे एजेंट से 0 दस्तावेज प्राप्त होंगे। हालाँकि, `LIMIT 10,10` को परिणाम सेट से दस्तावेज़ 10-20 वापस करना चाहिए। इसे हल करने के लिए, क्वेरी को एजेंटों को एक व्यापक सीमा के साथ भेजा जाना चाहिए, जैसे डिफ़ॉल्ट max_matches मान 1000।

उदाहरण के लिए, यदि एक वितरित तालिका dist है जो दूरस्थ तालिका user को संदर्भित करती है, तो एक क्लाइंट क्वेरी `SELECT * FROM dist LIMIT 10,10` को `SELECT * FROM user LIMIT 0,1000` में परिवर्तित किया जाएगा और दूरस्थ तालिका user को भेजा जाएगा। एक बार जब वितरित तालिका परिणाम प्राप्त करती है, तो यह LIMIT 10,10 लागू करेगी और अनुरोधित 10 दस्तावेज़ लौटाएगी।

```sql
SELECT * FROM dist LIMIT 10,10;
```

क्वेरी को निम्न रूप में परिवर्तित किया जाएगा:

```sql
SELECT * FROM user LIMIT 0,1000
```

इसके अतिरिक्त, मान यह निर्दिष्ट कर सकता है कि प्रत्येक व्यक्तिगत एजेंट के लिए विकल्प जैसे:
* [ha_strategy](../../Creating_a_cluster/Remote_nodes/Load_balancing.md#ha_strategy) - `random`, `roundrobin`, `nodeads`, `noerrors` (विशिष्ट एजेंट के लिए वैश्विक `ha_strategy` सेटिंग को ओवरराइड करता है)
* `conn` - `pconn`, स्थायी (तालिका स्तर पर `agent_persistent` सेट करने के बराबर)
* `blackhole` `0`,`1` (एजेंट के लिए [agent_blackhole](../../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_blackhole) सेटिंग के समान)
* `retry_count` एक पूर्णांक मान (जो [agent_retry_count](../../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_retry_count) से संबंधित है, लेकिन प्रदान किया गया मान मिरर की संख्या से गुणा नहीं किया जाएगा)

```ini
एजेंट = पता1:तालिका-सूची[[ha_strategy=value, conn=value, blackhole=value]]
```

उदाहरण:

```ini
# बॉक्स1 पर कॉन्फ़िगरेशन
# 3 सर्वरों पर एक तालिका को शार्द करना
एजेंट = बॉक्स2:9312:शार्द1
एजेंट = बॉक्स3:9312:शार्द2

# बॉक्स2 पर कॉन्फ़िगरेशन
# 3 सर्वरों पर एक तालिका को शार्द करना
एजेंट = बॉक्स1:9312:शार्द2
एजेंट = बॉक्स3:9312:शार्द3

# बॉक्स3 पर कॉन्फ़िगरेशन
# 3 सर्वरों पर एक तालिका को शार्द करना
एजेंट = बॉक्स1:9312:शार्द1
एजेंट = बॉक्स2:9312:शार्द3

# प्रति एजेंट विकल्प
एजेंट = बॉक्स1:9312:शार्द1[ha_strategy=nodeads]
एजेंट = बॉक्स2:9312:शार्द2[conn=pconn]
एजेंट = बॉक्स2:9312:शार्द2[conn=pconn,ha_strategy=nodeads]
एजेंट = परीक्षण:9312:कोई[blackhole=1]
एजेंट = परीक्षण:9312|बॉक्स2:9312|बॉक्स3:9312:कोई2[retry_count=2]
agent = test:9312|box2:9312:any2[retry_count=2,conn=pconn,ha_strategy=noerrors]
```

बेहतर प्रदर्शन के लिए, यह अनुशंसित है कि उन दूरस्थ तालिकाओं को एक ही रिकॉर्ड में रखा जाए जो समान सर्वर पर स्थित हैं। उदाहरण के लिए, इसके बजाय:
```ini
agent = remote:9312:idx1
agent = remote:9312:idx2
```
आपको प्राथमिकता देनी चाहिए:
```ini
agent = remote:9312:idx1,idx2
```

## agent_persistent

```ini
agent_persistent = remotebox:9312:index2
```

`agent_persistent` विकल्प आपको एक एजेंट से स्थायी रूप से कनेक्ट करने की अनुमति देता है, जिसका अर्थ है कि कनेक्शन एक क्यूरी के निष्पादित होने के बाद नहीं गिराया जाएगा। इस निदेशिका का सिंटैक्स `agent` निदेशिका के समान है। हालाँकि, हर क्यूरी के लिए एजेंट से नया कनेक्शन खोलने और फिर बंद करने के बजाय, मास्टर एक कनेक्शन को खुला रखेगा और इसे आगे की क्यूरी के लिए पुनः उपयोग करेगा। प्रत्येक एजेंट होस्ट के लिए स्थायी कनेक्शनों की अधिकतम संख्या को [persistent_connections_limit](../../Server_settings/Searchd.md#persistent_connections_limit) विकल्प द्वारा परिभाषित किया गया है जो सर्चडी सेक्शन में है।

यह नोट करना महत्वपूर्ण है कि [persistent_connections_limit](../../Server_settings/Searchd.md#persistent_connections_limit) को स्थायी एजेंट कनेक्शनों का उपयोग करने के लिए 0 से अधिक मान पर सेट किया जाना चाहिए। यदि इसे परिभाषित नहीं किया गया है, तो इसकी डिफ़ॉल्ट मान 0 है, और `agent_persistent` निदेशिका वही कार्य करेगी जो `agent` निदेशिका।

स्थायी मास्टर-एजेंट कनेक्शनों का उपयोग TCP पोर्ट दबाव को कम करता है और कनेक्शन हैंडशेक पर समय बचाता है, जिससे यह अधिक कुशल बनता है।

## agent_blackhole

```ini
agent_blackhole = testbox:9312:testindex1,testindex2
```

`agent_blackhole` निदेशिका आपको दूरस्थ एजेंटों को क्यूरी को अग्रेषित करने की अनुमति देती है बिना उनकी प्रतिक्रियाओं की प्रतीक्षा किए या उन्हें संसाधित किए। यह डिबगिंग या उत्पादन क्लस्टर का परीक्षण करने के लिए उपयोगी है, क्योंकि आप एक अलग डिबगिंग / परीक्षण instance स्थापित कर सकते हैं और इसे उत्पादन मास्टर (एग्रीगेटर) instance से अनुरोध भेज सकते हैं, बिना उत्पादन काम में हस्तक्षेप किए। मास्टर सर्चडी कालेhole एजेंट से कनेक्ट करने और सामान्य रूप से क्यूरी भेजने का प्रयास करेगा, लेकिन किसी भी प्रतिक्रिया के लिए प्रतीक्षा नहीं करेगा या उन्हें संसाधित नहीं करेगा, और कालेhole एजेंटों पर सभी नेटवर्क त्रुटियों को अनदेखा किया जाएगा। मान का स्वरूप नियमित `agent` निदेशिका के स्वरूप के समान है।

## agent_connect_timeout

```ini
agent_connect_timeout = 300
```

`agent_connect_timeout` निदेशिका दूरस्थ एजेंटों से कनेक्ट करने के लिए समयसीमा को परिभाषित करती है। डिफ़ॉल्ट रूप से, मान को मिलीसेकंड में माना जाता है, लेकिन इसमें [दूसरा उपसर्ग](../../Server_settings/Special_suffixes.md) हो सकता है। डिफ़ॉल्ट मान 1000 (1 सेकंड) है।

जब दूरस्थ एजेंटों से कनेक्ट करते हैं, `searchd` सफलतापूर्वक कनेक्शन पूरा करने के लिए इस समय तक प्रतीक्षा करेगा। यदि समयसीमा निर्धारित की जाती है लेकिन कनेक्शन स्थापित नहीं होता है, और `retries` सक्षम हैं, तो पुनः प्रयास शुरू किया जाएगा।

## agent_query_timeout

```ini
agent_query_timeout = 10000 # हमारी क्यूरी लंबी हो सकती है, 10 सेकंड तक अनुमति दें
```

`agent_query_timeout` उस समय को निर्धारित करता है जब सर्चडी दूरस्थ एजेंट से एक क्यूरी को पूरा करने के लिए प्रतीक्षा करेगा। डिफ़ॉल्ट मान 3000 मिलीसेकंड (3 सेकंड) है, लेकिन इसे एक अलग समय की इकाई को इंगित करने के लिए `suffixed` किया जा सकता है।

कनेक्शन स्थापित करने के बाद, `searchd` दूरस्थ क्यूरी को पूरा करने के लिए अधिकतम agent_query_timeout तक प्रतीक्षा करेगा। यह ध्यान दें कि यह समयसीमा `agent_connection_timeout` से अलग है और दूरस्थ एजेंट द्वारा उत्पन्न कुल संभावित विलंब दोनों मानों का योग होगा। यदि agent_query_timeout तक पहुँच जाता है, तो क्यूरी **पुनः प्रयास** नहीं की जाएगी, इसके बजाय एक चेतावनी दी जाएगी।

यह भी ध्यान दें कि व्यवहार [reset_network_timeout_on_packet](../../Server_settings/Searchd.md#reset_network_timeout_on_packet) द्वारा भी प्रभावित होता है।

## agent_retry_count

`agent_retry_count` एक पूर्णांक है जो यह निर्दिष्ट करता है कि Manticore लॉक आउट क्यूरी त्रुटि की रिपोर्ट करने से पहले वितरित तालिका में दूरस्थ एजेंटों से कनेक्ट करने और क्यूरी करने के लिए कितनी बार प्रयास करेगा। यह "searchd" सेक्शन में परिभाषित `agent_retry_count` के समान तरीके से काम करता है लेकिन विशेष रूप से तालिका पर लागू होता है।

## mirror_retry_count

`mirror_retry_count` का वही उद्देश्य है जो `agent_retry_count` का है। यदि दोनों मान दिए गए हैं, तो `mirror_retry_count` प्राथमिकता लेगा, और एक चेतावनी उत्पन्न की जाएगी।

## Instance-wide options

निम्नलिखित विकल्प दूरस्थ एजेंटों के समग्र व्यवहार का प्रबंधन करते हैं और **कॉन्फ़िगरेशन फ़ाइल के searchd सेक्शन में निर्दिष्ट हैं**। ये पूरे Manticore instance के लिए डिफ़ॉल्ट मान सेट करते हैं।

* `agent_connect_timeout` - `agent_connect_timeout` पैरामीटर के लिए डिफ़ॉल्ट मान।
* `agent_query_timeout` - `agent_query_timeout` पैरामीटर के लिए डिफ़ॉल्ट मान। इसे वितरित (नेटवर्क) तालिका में उसी सेटिंग नाम का उपयोग करके प्रति-क्यूरी आधार पर भी अधिलेखित किया जा सकता है।
* `agent_retry_count` एक पूर्णांक है जो यह निर्दिष्ट करता है कि Manticore वितरित तालिका में दूरस्थ एजेंटों से कनेक्ट करने और क्यूरी करने के लिए कितनी बार प्रयास करेगा इससे पहले कि वह एक लॉक आउट क्यूरी त्रुटि की रिपोर्ट करे। डिफ़ॉल्ट मान 0 (अर्थात कोई पुनः प्रयास नहीं) है। इस मान को भी प्रति-क्यूरी आधार पर 'OPTION retry_count=XXX' खंड का उपयोग करके निर्दिष्ट किया जा सकता है। यदि एक प्रति-क्यूरी विकल्प प्रदान किया जाता है, तो यह कॉन्फ़िगरेशन में निर्दिष्ट मान से प्राथमिकता लेगा।

ध्यान दें, कि यदि आप **एजेंट मिरर** का उपयोग करते हैं अपनी वितरित तालिका की परिभाषा में, सर्वर हर कनेक्शन प्रयास से पहले निर्दिष्ट [ha_strategy](../../Creating_a_cluster/Remote_nodes/Load_balancing.md#ha_strategy) के अनुसार एक अलग मिरर का चयन करेगा। इस मामले में [agent_retry_count](../../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_retry_count) सभी मिरर्स के लिए एकत्रित किया जाएगा।

उदाहरण के लिए, यदि आपके पास 10 मिरर हैं और `agent_retry_count=5` सेट करते हैं, तो सर्वर 50 पुनः प्रयासों तक प्रयास करेगा (मान लें कि हर 10 मिरर्स पर औसतन 5 प्रयास)। `ha_strategy = roundrobin` के विकल्प के मामले में, यह वास्तव में प्रत्येक मिरर पर ठीक 5 प्रयास करेगा।
उसी समय, `agent` परिभाषा में प्रदान की गई `[retry_count](../../Searching/Options.md#retry_count)` विकल्प के रूप में दिया गया मान एक परम सीमा के रूप में कार्य करता है। दूसरे शब्दों में, `agent` परिभाषा में `[retry_count=2]` विकल्प का मतलब है कि अधिकतम 2 बार प्रयास किया जाएगा, चाहे लाइन में 1 या 10 मिरर हों।

### agent_retry_delay

`agent_retry_delay` एक पूर्णांक मान है जो निर्धारित करता है कि Manticore Search एक दूरस्थ एजेंट को फिर से क्वेरी करने से पहले कितनी अवधि, मिलिसेकंड में, प्रतीक्षा करेगा यदि कोई विफलता होती है। इस मान को या तो खोजd कॉन्फ़िगरेशन में वैश्विक रूप से या `OPTION retry_delay=XXX` खंड का उपयोग करके प्रति-क्वेरी आधार पर निर्दिष्ट किया जा सकता है। यदि दोनों विकल्प उपलब्ध हैं, तो प्रति-क्वेरी विकल्प को वैश्विक विकल्प पर प्राथमिकता दी जाएगी। डिफ़ॉल्ट मान 500 मिलिसेकंड (0.5 सेकंड) है। यह विकल्प केवल तब प्रासंगिक है जब agent_retry_count या प्रति-क्वेरी `OPTION retry_count` शून्य से अधिक हो।

### client_timeout

`client_timeout` विकल्प स्थायी कनेक्शनों का उपयोग करते समय अनुरोधों के बीच अधिकतम प्रतीक्षा समय सेट करता है। इस मान को सेकंड में या समय उपसर्ग के साथ व्यक्त किया जाता है। डिफ़ॉल्ट मान 5 मिनट है।

उदाहरण:

```ini
client_timeout = 1h
```

### hostname_lookup

`hostname_lookup` विकल्प होस्टनाम को नवीनीकरण के लिए रणनीति को परिभाषित करता है। डिफ़ॉल्ट रूप से, DNS तक अत्यधिक पहुँच से बचने के लिए सर्वर प्रारंभ में एजेंट होस्ट नामों के आईपी पते कैश करता है। हालाँकि, कुछ मामलों में, आईपी गतिशील रूप से बदल सकता है (जैसे क्लाउड होस्टिंग) और आईपी को कैश न करना वांछनीय हो सकता है। इस विकल्प को `request` पर सेट करने से कैशिंग को निष्क्रिय कर दिया जाता है और प्रत्येक क्वेरी के लिए DNS को क्वेरी करता है। आईपी पते को मैन्युअल रूप से भी `FLUSH HOSTNAMES` कमांड का उपयोग करके नवीनीकरण किया जा सकता है।

### listen_tfo

`listen_tfo` विकल्प सभी श्रोताओं के लिए TCP_FASTOPEN ध्वज के उपयोग की अनुमति देता है। डिफ़ॉल्ट रूप से, इसे सिस्टम द्वारा प्रबंधित किया जाता है, लेकिन इसे '0' पर सेट करके स्पष्ट रूप से बंद किया जा सकता है।

TCP फास्ट ओपन एक्सटेंशन के बारे में अधिक जानकारी के लिए, कृपया [विकिपीडिया](https://en.wikipedia.org/wiki/TCP_Fast_Open) देखें। संक्षेप में, यह एक कनेक्शन स्थापित करते समय एक TCP राउंड-ट्रिप को समाप्त करने की अनुमति देता है।

व्यवहार में, TFO का उपयोग ग्राहक-एजेंट नेटवर्क दक्षता को बेहतर बना सकता है, जैसे कि जब `agent_persistent` का उपयोग किया जा रहा हो, लेकिन सक्रिय कनेक्शनों को पकड़ने और कनेक्शनों की अधिकतम संख्या पर सीमाओं के बिना।

अधिकांश आधुनिक ऑपरेटिंग सिस्टम TFO का समर्थन करते हैं। लिनक्स (जो सबसे प्रगतिशील में से एक है) ने 2011 से इसका समर्थन किया है, 3.7 से शुरू होने वाले कर्नेल के साथ (सर्वर पक्ष के लिए)। विंडोज ने विंडोज 10 के कुछ बिल्ड से इसका समर्थन किया है। अन्य सिस्टम, जैसे FreeBSD और MacOS, भी खेल में हैं।

लिनक्स सिस्टम के लिए, सर्वर वेरिएबल `/proc/sys/net/ipv4/tcp_fastopen` की जांच करता है और तदनुसार व्यवहार करता है। बिट 0 ग्राहक पक्ष का प्रबंधन करता है, जबकि बिट 1 श्रोताओं का शासन करता है। डिफ़ॉल्ट रूप से, सिस्टम में इस पैरामीटर को 1 पर सेट किया गया है, अर्थात्, ग्राहक सक्षम हैं और ग्राहक अक्षम हैं।

### persistent_connections_limit

```ini
persistent_connections_limit = 29 # मान लीजिए कि प्रत्येक एजेंट का होस्ट max_connections = 30 (या 29) है।
```

`persistent_connections_limit` विकल्प दूरस्थ स्थायी एजेंटों के लिए समानांतर स्थायी कनेक्शन की अधिकतम संख्या को परिभाषित करता है। यह एक उदाहरण-व्यापी सेटिंग है और इसे खोजd कॉन्फ़िगरेशन सेक्शन में परिभाषित किया जाना चाहिए। प्रत्येक बार जब `agent_persistent` के तहत परिभाषित एजेंट से कनेक्शन किया जाता है, तो हम (यदि कोई मौजूद है) मौजूदा कनेक्शन का पुन: उपयोग करने का प्रयास करते हैं या एक नया कनेक्शन बनाते हैं और भविष्य के उपयोग के लिए उसे सहेजते हैं। हालाँकि, कुछ मामलों में स्थायी कनेक्शनों की संख्या को सीमित करना आवश्यक हो सकता है। यह निर्देशन सीमा को परिभाषित करता है और सभी वितरित तालिकाओं में प्रत्येक एजेंट के होस्ट से कनेक्शनों की संख्या को प्रभावित करता है।

इस मान को एजेंट की कॉन्फ़िगरेशन में [max_connections](../../Server_settings/Searchd.md#max_connections) विकल्प के बराबर या उससे कम करने की सिफारिश की जाती है।

## वितरित स्निप्पेट्स निर्माण

वितरित तालिका का एक विशेष मामला एक एकल स्थानीय और कई दूरस्थ है, जिसका उपयोग विशेष रूप से [वितरित स्निप्पेट्स निर्माण](../../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#Distributed-snippets-creation) के लिए किया जाता है, जब स्निप्पेट फ़ाइलों से स्रोतित होते हैं। इस मामले में, स्थानीय तालिका "टेम्पलेट" तालिका के रूप में कार्य कर सकती है, स्निप्पेट्स बनाने के समय टोकनाइजेशन के लिए सेटिंग्स प्रदान करती है।

### snippets_file_prefix

```ini
snippets_file_prefix = /mnt/common/server1/
```

`snippets_file_prefix` एक वैकल्पिक उपसर्ग है जिसे स्निप्पेट उत्पन्न करते समय स्थानीय फ़ाइल नामों में जोड़ा जा सकता है। डिफ़ॉल्ट मान वर्तमान कार्यशील फ़ोल्डर है।

वितरित स्निप्पेट्स निर्माण के बारे में अधिक जानने के लिए, देखें [CALL SNIPPETS](../../Searching/Highlighting.md).

## वितरित पर्कोलेट तालिकाएँ (DPQ तालिकाएँ)

आप कई [पर्कोलेट](../../Creating_a_table/Local_tables/Percolate_table.md) तालिकाओं से एक वितरित तालिका बना सकते हैं। इस प्रकार की तालिका बनाने की सिंटैक्स अन्य वितरित तालिकाओं के समान है, और इसमें कई `local` तालिकाएँ और `agents` शामिल हो सकते हैं।

DPQ के लिए, संग्रहित क्वेरियों को सूचीबद्ध करने और उनके माध्यम से खोज करने (का उपयोग करके [CALL PQ](../../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ)) के संचालन पारदर्शी हैं और ऐसा होता है जैसे कि सभी तालिकाएँ एक ही स्थानीय तालिका हों। हालाँकि, डेटा हेरफेर के कथन जैसे `insert`, `replace`, `truncate` उपलब्ध नहीं हैं।

यदि आप एजेंटों की सूची में एक गैर-पर्कोलेट तालिका शामिल करते हैं, तो व्यवहार अपरिभाषित होगा। यदि गलत एजेंट की PQ तालिका के बाहरी स्कीमा (id, query, tags, filters) के समान ही स्कीमा है, तो संग्रहित PQ नियमों की सूची में त्रुटि उत्पन्न नहीं होती है, और यह अपने स्वयं के गैर-PQ स्ट्रिंग के साथ PQ तालिकाओं में संग्रहित वास्तविक PQ नियमों की सूची को प्रदूषित कर सकता है। परिणामस्वरूप, सतर्क रहें और इस से होने वाली भ्रम की जागरूकता रखें। ऐसे गलत एजेंट पर `CALL PQ` एक त्रुटि उत्पन्न करेगा।
अधिक सूचना के लिए कि कैसे एक वितरित पर्कोलेट तालिका पर प्रश्न बनाएँ, देखें [एक वितरित पर्कोलेट तालिका पर प्रश्न बनाना](../../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ).
<!-- proofread -->


