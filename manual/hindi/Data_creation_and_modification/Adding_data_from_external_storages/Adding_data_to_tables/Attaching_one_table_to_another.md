# एक तालिका को दूसरी तालिका से जोड़ना

<!-- example Example_1 -->

एक सरल तालिका को वास्तविक समय की तालिका में परिवर्तित किया जा सकता है या एक मौजूदा वास्तविक समय की तालिका में जोड़ा जा सकता है।

पहला मामला तब उपयोगी होता है जब आपको एक वास्तविक समय की तालिका को पूरी तरह से फिर से उत्पन्न करने की आवश्यकता होती है, जो आवश्यक हो सकता है, उदाहरण के लिए, यदि टोकनाईज़ेशन सेटिंग्स को अपडेट करने की आवश्यकता है। इस स्थिति में, एक साधारण तालिका तैयार करना और उसे वास्तविक समय की तालिका में परिवर्तित करना सभी डेटा को वास्तविक समय की तालिका में जोड़ने के लिए INSERT करने के लिए बैच कार्य तैयार करने की तुलना में आसान हो सकता है।

दूसरे मामले में, आप सामान्यतः एक वास्तविक समय की तालिका में बड़ी मात्रा में नए डेटा को जोड़ना चाहते हैं, और फिर एक बार फिर, उस डेटा के साथ एक साधारण तालिका बनाना मौजूदा वास्तविक समय की तालिका को भरने की तुलना में आसान है।

आप एक मौजूदा वास्तविक समय की तालिका को दूसरी तालिका से भी जोड़ सकते हैं।

##### तालिका जोड़ना - सामान्य सिंटैक्स
`ATTACH` कथन आपको एक साधारण तालिका को मौजूदा वास्तविक समय की तालिका से जोड़ने की अनुमति देता है। यह आपको एक वास्तविक समय की तालिका के सामग्री को दूसरी वास्तविक समय की तालिका से जोड़ने की सक्षम बनाता है।

```sql
ATTACH TABLE plain_or_rt_table TO TABLE rt_table [WITH TRUNCATE]
```

सफल `ATTACH` के बाद, स्रोत साधारण तालिका में मूल रूप से संग्रहीत डेटा लक्षित RT तालिका का एक हिस्सा बन जाता है, और स्रोत साधारण तालिका अनुपलब्ध हो जाती है (अगले पुनर्निर्माण तक)। यदि स्रोत तालिका एक RT तालिका है, तो इसकी सामग्री गंतव्य RT तालिका में स्थानांतरित कर दी जाती है, और स्रोत RT तालिका खाली रहती है। `ATTACH` किसी भी तालिका डेटा में बदलाव नहीं करता। मौलिक रूप से, यह केवल फाइलों का नाम बदलता है (स्रोत तालिका को लक्षित RT तालिका का एक नया डिस्क टुकड़ा बनाता है) और मेटाडेटा को अपडेट करता है। इसलिए यह सामान्यतः एक तेज़ ऑपरेशन है जो (अक्सर) एक सेकंड से भी कम समय में पूरा हो सकता है।

ध्यान दें कि जब एक तालिका को खाली RT तालिका से जोड़ा जाता है, तो *स्रोत* तालिका से फ़ील्ड, विशेषताएँ, और पाठ प्रसंस्करण सेटिंग्स (टोकनाइज़र, शब्द रूप, आदि) को कॉपी किया जाता है और प्रभाव में आते हैं। कॉन्फ़िगरेशन फ़ाइल से RT तालिका परिभाषा के संबंधित भाग को नजरअंदाज किया जाएगा।

जब `TRUNCATE` विकल्प का उपयोग किया जाता है, तो RT तालिका को स्रोत साधारण तालिका को संलग्न करने से पहले ट्रंक किया जाता है। यह इस ऑपरेशन को परमाणु बनाता है या यह सुनिश्चित करता है कि संलग्न स्रोत साधारण तालिका लक्षित RT तालिका में केवल डेटा होगी।

`ATTACH TABLE` कई प्रतिबंधों के साथ आता है। सबसे महत्वपूर्ण रूप से, लक्षित RT तालिका को वर्तमान में या तो खाली होना चाहिए या स्रोत तालिका के समान सेटिंग्स होनी चाहिए। यदि स्रोत तालिका को गैर-खाली RT तालिका से जोड़ा जाता है, तो अब तक एकत्रित RT तालिका डेटा को एक नियमित डिस्क टुकड़ा के रूप में संग्रहीत किया जाता है, और जो तालिका संलग्न की जा रही है वह नवीनतम डिस्क टुकड़ा बन जाती है, जिसमें समान IDs वाले दस्तावेज़ों को समाप्त कर दिया जाता है। प्रतिबंधों की पूर्ण सूची निम्नलिखित है:
* लक्षित RT तालिका या तो खाली होनी चाहिए या स्रोत तालिका के समान सेटिंग्स होनी चाहिए।
* स्रोत तालिका को [phrase_boundary_step](../../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#phrase_boundary_step) को 0 पर और [stopword_step](../../../Creating_a_table/NLP_and_tokenization/Ignoring_stop-words.md#stopword_step) को 1 पर सेट करना चाहिए।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->
ATTACH से पहले, RT तालिका खाली है और इसमें 3 फ़ील्ड हैं:

```sql
mysql> DESC rt;
Empty set (0.00 sec)

mysql> SELECT * FROM rt;
+-----------+---------+
| Field     | Type    |
+-----------+---------+
| id        | integer |
| testfield | field   |
| testattr  | uint    |
+-----------+---------+
3 rows in set (0.00 sec)
```

साधारण तालिका खाली नहीं है:

```sql
mysql> SELECT * FROM plain WHERE MATCH('test');
+------+--------+----------+------------+
| id   | weight | group_id | date_added |
+------+--------+----------+------------+
|    1 |   1304 |        1 | 1313643256 |
|    2 |   1304 |        1 | 1313643256 |
|    3 |   1304 |        1 | 1313643256 |
|    4 |   1304 |        1 | 1313643256 |
+------+--------+----------+------------+
4 rows in set (0.00 sec)
```

साधारण तालिका को RT तालिका से जोड़ना:
```sql
mysql> ATTACH TABLE plain TO TABLE rt;
Query OK, 0 rows affected (0.00 sec)
```

RT तालिका में अब 5 फ़ील्ड हैं:

```sql
mysql> DESC rt;
+------------+-----------+
| Field      | Type      |
+------------+-----------+
| id         | integer   |
| title      | field     |
| content    | field     |
| group_id   | uint      |
| date_added | timestamp |
+------------+-----------+
5 rows in set (0.00 sec)
```

और यह खाली नहीं है:

```sql
mysql> SELECT * FROM rt WHERE MATCH('test');
+------+--------+----------+------------+
| id   | weight | group_id | date_added |
+------+--------+----------+------------+
|    1 |   1304 |        1 | 1313643256 |
|    2 |   1304 |        1 | 1313643256 |
|    3 |   1304 |        1 | 1313643256 |
|    4 |   1304 |        1 | 1313643256 |
+------+--------+----------+------------+
4 rows in set (0.00 sec)
```

ATTACH के बाद, साधारण तालिका हटा दी जाती है और खोजने के लिए उपलब्ध नहीं होती है:

```sql
mysql> SELECT * FROM plain WHERE MATCH('test');
ERROR 1064 (42000): no enabled local indexes to search
```
<!-- end -->
<!-- proofread -->
