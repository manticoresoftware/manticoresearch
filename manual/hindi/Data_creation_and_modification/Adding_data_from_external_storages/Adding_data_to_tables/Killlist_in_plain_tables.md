# साधारण तालिकाओं में मारने की सूची

साधारण तालिकाओं का उपयोग करते समय, तालिका में डेटा को यथासंभव ताज़ा बनाए रखने की आवश्यकता से एक चुनौती उत्पन्न होती है।

इस मामले में, एक या एक से अधिक द्वितीयक (जिसे डेल्टा भी कहा जाता है) तालिकाएँ उपयोग की जाती हैं ताकि मुख्य तालिका के निर्माण के समय और वर्तमान समय के बीच संशोधित डेटा को कैप्चर किया जा सके। संशोधित डेटा में नए, अपडेट किए गए, या हटाए गए दस्तावेज़ शामिल हो सकते हैं। खोज एक खोज में बदल जाती है **मुख्य तालिका और डेल्टा तालिका** के ऊपर। यह तब सुचारु रूप से काम करता है जब आप बस **नए** दस्तावेज़ डेल्टा तालिका में जोड़ते हैं, लेकिन जब अपडेट किए गए या हटाए गए दस्तावेज़ों की बात आती है, तो यह समस्या टल जाती है। 

यदि कोई दस्तावेज़ मुख्य और डेल्टा तालिकाओं दोनों में उपस्थित है, तो यह खोज के दौरान समस्याएँ पैदा कर सकता है, क्योंकि इंजन दस्तावेज़ का दो संस्करण देखेगा और यह नहीं जान पाएगा कि सही एक को कैसे चुनना है। इसलिए, डेल्टा को किसी न किसी तरह से खोज को सूचित करना होगा कि मुख्य तालिका में हटाए गए दस्तावेज़ हैं जिन्हें नजरअंदाज किया जाना चाहिए। **यहीं पर मारने की सूचियाँ आती हैं**।

## तालिका मारने की सूची
एक तालिका दस्तावेज़ आईडी की एक सूची बनाए रख सकती है जिसका उपयोग अन्य तालिकाओं में रिकॉर्ड दबाने के लिए किया जा सकता है। यह सुविधा डेटाबेस स्रोतों का उपयोग करने वाली साधारण तालिकाओं या XML स्रोतों का उपयोग करने वाली साधारण तालिकाओं के लिए उपलब्ध है। डेटाबेस स्रोतों के मामले में, स्रोत को `sql_query_killlist` द्वारा परिभाषित एक अतिरिक्त क्वेरी प्रदान करनी होगी। यह तालिका में एक दस्तावेज़ों की सूची संग्रहीत करेगा जिसका उपयोग सर्वर अन्य साधारण तालिकाओं से दस्तावेज़ों को हटाने के लिए कर सकता है।

इस क्वेरी की अपेक्षा की जाती है कि यह 1-स्तंभ पंक्तियों की एक संख्या लौटाए, प्रत्येक में केवल दस्तावेज़ ID हो।

कई मामलों में, क्वेरी एक संयुक्त क्वेरी होती है जो अपडेट किए गए दस्तावेज़ों की सूची और हटाए गए दस्तावेज़ों की सूची प्राप्त करती है, जैसे:

```ini
sql_query_killlist = \
    SELECT id FROM documents WHERE updated_ts>=@last_reindex UNION \
    SELECT id FROM documents_deleted WHERE deleted_ts>=@last_reindex
```

## साधारण तालिका में दस्तावेज़ों को हटाना
एक साधारण तालिका में एक निर्देष हो सकता है जिसे [killlist_target](../../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#killlist_target) कहा जाता है जो सर्वर को बताएगा कि वह कुछ मौजूदा तालिकाओं से हटाए जाने वाले दस्तावेज़ आईडी की सूची प्रदान कर सकता है। तालिका इस सूची के लिए अपने दस्तावेज़ आईडी का स्रोत के रूप में उपयोग कर सकती है या एक अलग [सूचि](../../../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#Table-kill-list) प्रदान कर सकती है।

### killlist_target

<!-- example killlist_target 1 -->
उन तालिकाओं को सेट करता है जिन पर मारने की सूची लागू होगी। वैकल्पिक, डिफ़ॉल्ट मान खाली है।

जब आप [साधारण तालिकाएँ](../../../Creating_a_table/Local_tables/Plain_table.md) का उपयोग करते हैं तो आपको अक्सर केवल एक तालिका बनाए रखने की आवश्यकता नहीं होती है, बल्कि उन्हें जोड़ने/अपडेट करने/हटाने के लिए एक सेट बनाए रखने की आवश्यकता होती है ( [डेल्टा तालिका अपडेट](../../../Data_creation_and_modification/Adding_data_from_external_storages/Main_delta.md) के बारे में पढ़ें)। अगले (**डेल्टा**) तालिका में अपडेट या हटाए गए मेल को पूर्व (**मुख्य**) तालिका में दबाने के लिए, आपको:

1.  **डेल्टा** तालिका में [sql_query_killlist](../../../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#Table-kill-list) का उपयोग करके एक मारने की सूची बनानी होगी।
2.  **डेल्टा** तालिका सेटिंग्स में `killlist_target` के रूप में **मुख्य** तालिका को निर्दिष्ट करना होगा:


<!-- intro -->
##### CONFIG:

<!-- request CONFIG -->

```ini
table products {
  killlist_target = main:kl

  path = products
  source = src_base
}
```
<!-- end -->

जब `killlist_target` का मूल्य निर्दिष्ट किया जाएगा, तो मारने की सूची `searchd` स्टार्टअप पर इसमें सूचीबद्ध सभी तालिकाओं पर लागू होती है। यदि `killlist_target` से कोई भी तालिका घुमाई जाती है, तो मारने की सूची इन तालिकाओं पर फिर से लागू होती है। जब मारने की सूची लागू होती है, तो प्रभावित तालिकाओं में ये परिवर्तन डिस्क पर सहेजे जाते हैं।

`killlist_target` के 3 संचालन मोड हैं:

1.  `killlist_target = main:kl`। **डेल्टा** तालिका की मारने की सूची से दस्तावेज़ आईडी को **मुख्य** तालिका में दबाया जाता है ( `sql_query_killlist` को देखें)।
2.  `killlist_target = main:id`। **डेल्टा** तालिका से सभी दस्तावेज़ आईडी को **मुख्य** तालिका में दबाया जाता है। मारने की सूची को अनदेखा किया जाता है।
3.  `killlist_target = main`। **डेल्टा** तालिका से दस्तावेज़ आईडी और इसकी मारने की सूची दोनों को **मुख्य** तालिका में दबाया जाता है।

कई लक्ष्यों को निर्दिष्ट किया जा सकता है, जो अल्पविराम द्वारा अलग होते हैं जैसे:

```ini
killlist_target = table_one:kl,table_two:kl
```

<!-- example killlist_target 2 -->
आप `ALTER` का उपयोग करके तालिका के लिए `killlist_target` सेटिंग्स को बिना पुनर्निर्माण किए बदल सकते हैं।

हालाँकि, चूंकि 'पुरानी' मुख्य तालिका ने पहले ही परिवर्तनों को डिस्क पर लिख दिया है, इसलिए इसमें हटाए गए दस्तावेज़ **रहेंगे** हटाए गए हैं भले ही यह अब **डेल्टा** तालिका के `killlist_target` में नहीं हो।


<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
ALTER TABLE delta KILLLIST_TARGET='new_main_table:kl'
```

<!-- request HTTP -->

```http
POST /cli -d "
ALTER TABLE delta KILLLIST_TARGET='new_main_table:kl'"
```
<!-- end -->
<!-- proofread -->
