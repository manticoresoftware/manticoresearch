# XML स्ट्रीम से डेटा खींचना
`xmlpipe2` स्रोत प्रकार एक कस्टम XML प्रारूप में Manticore को कस्टम पूर्ण-पाठ और विशेषता डेटा पास करने की अनुमति देता है, जिसमें स्कीमा (यानी, फ़ील्ड और विशेषताओं का सेट) XML स्ट्रीम में या स्रोत सेटिंग्स में निर्दिष्ट किया गया है।

## XML स्ट्रीम की घोषणा
XML स्ट्रीम की घोषणा के लिए, `xmlpipe_command` निर्देश अनिवार्य है और इसमें वह शेल कमांड शामिल है जो अनुक्रमित करने के लिए XML स्ट्रीम उत्पन्न करता है। यह एक फ़ाइल हो सकता है, लेकिन यह एक कार्यक्रम भी हो सकता है जो ऑन-द-फ्लाई XML सामग्री उत्पन्न करता है।

## XML फ़ाइल प्रारूप
जब xmlpipe2 स्रोत को अनुक्रमित किया जाता है, तो अनुक्रमणक निर्दिष्ट कमांड चलाता है, इसके stdout के लिए एक पाइप खोलता है, और एक अच्छी तरह से निर्मित XML स्ट्रीम की अपेक्षा करता है। 
यहां XML स्ट्रीम डेटा का एक उदाहरण है:

```xml
<?xml version="1.0" encoding="utf-8"?>
<sphinx:docset>

<sphinx:schema>
<sphinx:field name="subject"/>
<sphinx:field name="content"/>
<sphinx:attr name="published" type="timestamp"/>
<sphinx:attr name="author_id" type="int" bits="16" default="1"/>
</sphinx:schema>

<sphinx:document id="1234">
<content>यह मुख्य सामग्री है <![CDATA[और यह <cdata> प्रविष्टि
xml पार्सर लाइब्रेरी द्वारा सही ढंग से संभाली जानी चाहिए]]></content>
<published>1012325463</published>
<subject>ध्यान दें कि field/attr टैग
<b> class="red">यादृच्छिक</b> क्रम में हो सकते हैं</subject>
<misc>कुछ अप्रकाशित तत्व</misc>
</sphinx:document>

<sphinx:document id="1235">
<subject>एक अन्य विषय</subject>
<content>यहां एक और दस्तावेज़ आता है, और मुझे समझाया गया है,
कि दस्तावेज़ में फ़ील्ड क्रम मायने नहीं रखता, सर</content>
<published>1012325467</published>
</sphinx:document>

<!-- ... यहां और भी sphinx:document प्रविष्टियाँ ... -->

<sphinx:killlist>
<id>1234</id>
<id>4567</id>
</sphinx:killlist>

</sphinx:docset>
```

मनमाने फ़ील्ड और विशेषताओं की अनुमति है। वे प्रत्येक दस्तावेज़ के अंदर मनमाने क्रम में स्ट्रीम में भी हो सकते हैं; क्रम को नजरअंदाज किया गया है। अधिकतम फ़ील्ड लंबाई पर एक प्रतिबंध है; 2 MB से अधिक लंबे फ़ील्ड को 2 MB तक छोटे किया जाएगा (यह सीमा स्रोत में बदली जा सकती है)।

स्कीमा, यानी, पूर्ण फ़ील्ड और विशेषताओं की सूची, को किसी भी दस्तावेज़ को पार्स किए जाने से पहले घोषित किया जाना चाहिए। यह `xmlpipe_field` और `xmlpipe_attr_XXX` सेटिंग्स का उपयोग करते हुए कॉन्फ़िगरेशन फ़ाइल में किया जा सकता है, या स्ट्रीम में `<sphinx:schema>` तत्व का उपयोग करके। `<sphinx:schema>` वैकल्पिक है। इसे `<sphinx:docset>` में बहुत पहले उप-तत्व के रूप में ही आने की अनुमति है। यदि स्ट्रीम में कोई स्कीमा परिभाषा नहीं है, तो कॉन्फ़िगरेशन फ़ाइल से सेटिंग्स का उपयोग किया जाएगा। अन्यथा, स्ट्रीम सेटिंग्स को प्राथमिकता दी जाएगी। ध्यान दें कि दस्तावेज़ आईडी को `<sphinx:document>` टैग की `id` संपत्ति के रूप में निर्दिष्ट किया जाना चाहिए (जैसे, `<sphinx:document id="1235">`) और इसे एक अद्वितीय-संकेत सकारात्मक शून्य-नहीं 64-बिट पूर्णांक होना चाहिए।

अज्ञात टैग (जो न तो फ़ील्ड के रूप में और न ही विशेषताओं के रूप में घोषित किए गए) को एक चेतावनी के साथ नजरअंदाज किया जाएगा। ऊपर उदाहरण में, `<misc>` को नजरअंदाज किया जाएगा। सभी संलग्न टैग और उनके विशेषताएँ (जैसे ऊपर के उदाहरण में `<subject>` में `<strong>`) चुपचाप नजरअंदाज कर दी जाएंगी।

इनकमिंग स्ट्रीम एनकोडिंग के लिए समर्थन इस पर निर्भर करता है कि क्या `iconv` सिस्टम पर स्थापित है। xmlpipe2 को `libexpat` पार्सर का उपयोग करके पार्स किया जाता है, जो स्वाभाविक रूप से US-ASCII, ISO-8859-1, UTF-8, और कुछ UTF-16 विविधताओं को समझता है। Manticore का `configure` स्क्रिप्ट `libiconv` की उपस्थिति की भी जांच करेगा और अन्य एनकोडिंग को संभालने के लिए इसका उपयोग करेगा। `libexpat` भी Manticore की ओर UTF-8 वर्णमाला का उपयोग करने की आवश्यकता को लागू करता है क्योंकि जो डेटा यह लौटाता है वह हमेशा UTF-8 में होता है।

XML तत्व (टैग) जिन्हें xmlpipe2 द्वारा पहचाना गया है (और जहाँ लागू, उनकी विशेषताएँ) हैं:

* `sphinx:docset` - अनिवार्य शीर्ष-स्तरीय तत्व, xmlpipe2 दस्तावेज़ सेट को अंकित करता है और उसे समेटता है।
* `sphinx:schema` - वैकल्पिक तत्व, या तो sphinx:docset का बहुत पहला बच्चा होना चाहिए या कभी नहीं होना चाहिए। दस्तावेज़ स्कीमा की घोषणा करता है और फ़ील्ड और विशेषता घोषणाएँ समाहित करता है। यदि मौजूद है, तो यह कॉन्फ़िगरेशन फ़ाइल से प्रति-स्रोत सेटिंग्स को अधिलेखित करता है।
* `sphinx:field` - वैकल्पिक तत्व, sphinx:schema का बच्चा। एक पूर्ण-पाठ फ़ील्ड की घोषणा करता है। ज्ञात विशेषताएँ हैं:
    *   "name", XML तत्व नाम निर्दिष्ट करता है जिसे अगले दस्तावेज़ों में पूर्ण-पाठ फ़ील्ड के रूप में माना जाएगा।
    *   "attr", यह निर्दिष्ट करता है कि क्या इस फ़ील्ड को एक स्ट्रिंग के रूप में भी अनुक्रमित किया जाना चाहिए। संभावित मान "string" है।
* `sphinx:attr` - वैकल्पिक तत्व, sphinx:schema का बच्चा। एक विशेषता की घोषणा करता है। ज्ञात विशेषताएँ हैं:
    *   "name", तत्व नाम निर्दिष्ट करता है जिसे अगले दस्तावेज़ों में एक विशेषता के रूप में माना जाना चाहिए।
    *   "type", विशेषता प्रकार को निर्दिष्ट करता है। संभावित मान "int", "bigint", "timestamp", "bool", "float", "multi" और "json" हैं।
    *   "bits", "int" विशेषता प्रकार के लिए बिट आकार निर्दिष्ट करता है। मान्य मान 1 से 32 हैं।
    *   "default", इस विशेषता के लिए डिफ़ॉल्ट मान निर्दिष्ट करता है जिसका उपयोग तब किया जाना चाहिए जब दस्तावेज़ में विशेषता का तत्व मौजूद नहीं हो।
* `sphinx:document` - अनिवार्य तत्व, sphinx:docset का बच्चा होना चाहिए। जिसमें अनुक्रमित करने के लिए फ़ील्ड और विशेषता मानों के साथ अन्य तत्व शामिल होते हैं, जिन्हें sphinx:field और sphinx:attr तत्वों या कॉन्फ़िगरेशन फ़ाइल में घोषित किया गया है। एकमात्र ज्ञात विशेषता "id" है जो अद्वितीय पूर्णांक दस्तावेज़ आईडी को समाहित करना चाहिए।
* `sphinx:killlist` - वैकल्पिक तत्व, sphinx:docset का बच्चा। जिसमें "id" तत्वों की एक संख्या शामिल होती है जिनकी सामग्री को एक हत्या-सूची में डालना होता है। हत्या-सूची का उपयोग मल्टी-टेबल खोजों में अन्य खोज तालिकाओं में पाए गए दस्तावेज़ों को दबाने के लिए किया जाता है।

## स्रोत कॉन्फ़िगरेशन में डेटा परिभाषा

यदि XML एक स्कीमा को परिभाषित नहीं करता है, तो तालिका तत्वों के डेटा प्रकारों को स्रोत कॉन्फ़िगरेशन में परिभाषित किया जाना चाहिए।

* `xmlpipe_field` -  एक `text` फ़ील्ड की घोषणा करता है।
* `xmlpipe_field_string` - एक टेक्स्ट फ़ील्ड/स्ट्रिंग विशेषता की घोषणा करता है। कॉलम को टेक्स्ट फ़ील्ड के रूप में अनुक्रमित किया जाएगा लेकिन इसे एक स्ट्रिंग विशेषता के रूप में भी संग्रहीत किया जाएगा।
* `xmlpipe_attr_uint` - एक पूर्णांक विशेषता को घोषीत करता है
* `xmlpipe_attr_timestamp` - एक टाइमस्टैम्प विशेषता को घोषीत करता है
* `xmlpipe_attr_bool` -  एक बूलियन विशेषता को घोषीत करता है
* `xmlpipe_attr_float` - एक फ्लोट विशेषता को घोषीत करता है
* `xmlpipe_attr_bigint` - एक बड़ा पूर्णांक विशेषता को घोषीत करता है
* `xmlpipe_attr_multi` - पूर्णांकों के साथ एक बहु-मूल्य विशेषता को घोषीत करता है
* `xmlpipe_attr_multi_64` - 64-बिट पूर्णांकों के साथ एक बहु-मूल्य विशेषता को घोषीत करता है
* `xmlpipe_attr_string` - एक स्ट्रिंग विशेषता को घोषीत करता है
* `xmlpipe_attr_json` - एक JSON विशेषता को घोषीत करता है

### विशिष्ट XML स्रोत सेटिंग्स

यदि `xmlpipe_fixup_utf8` सेट किया गया है, तो यह Manticore-पक्ष UTF-8 मान्यकरण और फ़िल्टरिंग को सक्षम करेगा ताकि XML पार्सर गैर-UTF-8 दस्तावेज़ों पर हिचकिचाएं न। डिफ़ॉल्ट रूप से, यह विकल्प अक्षम है।

कुछ अवसरों पर यह सुनिश्चित करना कठिन या यहां तक कि असंभव हो सकता है कि आने वाले XMLpipe2 दस्तावेज़ निकाय पूरी तरह से वैध और अनुरूप UTF-8 एन्कोडिंग में हैं। उदाहरण के लिए, राष्ट्रीय सिंगल-байट एन्कोडिंग वाले दस्तावेज़ स्ट्रीम में घुसकर आ सकते हैं। libexpat XML पार्सर नाजुक है, जिसका अर्थ है कि यह ऐसे मामलों में प्रोसेसिंग रोक देगा। UTF8 सुधार सुविधा आपको इससे बचने की अनुमति देती है। जब सुधार सक्षम होता है, तो Manticore आने वाली स्ट्रीम को XML पार्सर को पास करने से पहले पूर्व-प्रसंस्करण करेगा और अवैध UTF-8 अनुक्रमों को खाली स्थानों से बदल देगा।

```ini
xmlpipe_fixup_utf8 = 1
```

स्कीमा के बिना कॉन्फ़िगरेशन में XML स्रोत का उदाहरण:

```ini
source xml_test_1
{
    type = xmlpipe2
    xmlpipe_command = cat /tmp/products_today.xml
}
```

स्कीमा के साथ कॉन्फ़िगरेशन में XML स्रोत का उदाहरण:

```ini
source xml_test_2
{
    type = xmlpipe2
    xmlpipe_command = cat /tmp/products_today.xml
    xmlpipe_field = subject
    xmlpipe_field = content
    xmlpipe_attr_timestamp = published
    xmlpipe_attr_uint = author_id:16
}
```
<!-- proofread -->



