# प्रसंस्कृत प्राप्त डेटा

डिफ़ॉल्ट रूप से, `sql_query` के परिणाम सेट से पहला कॉलम दस्तावेज़ आईडी के रूप में अनुक्रमित होता है।

दस्तावेज़ आईडी *अनिवार्य रूप से* सबसे पहले फील्ड होनी चाहिए, और यह **अनिवार्य है** कि यह -9223372036854775808 से 9223372036854775807 तक की UNIQUE SIGNED (NON-ZERO) INTEGER संख्या हो।

आप 256 तक के फुल-टेक्स्ट क्षेत्रों और एक मनमाने मात्रा के गुण निर्दिष्ट कर सकते हैं। सभी कॉलम जो दस्तावेज़ आईडी (पहला कॉलम) या गुण नहीं हैं, उन्हें फुल-टेक्स्ट क्षेत्रों के रूप में अनुक्रमित किया जाएगा।


## गुणों की घोषणा:

### sql_attr_bigint

64-बिट *signed* पूर्णांक घोषित करता है।

### sql_attr_bool

एक बूलियन गुण घोषित करता है। यह 1-बिट की गणना वाले पूर्णांक गुण के बराबर है।

### sql_attr_float

फ्लोटिंग पॉइंट गुण घोषित करता है।

मानों को सिंगल प्रिसीजन, 32-बिट IEEE 754 प्रारूप में संग्रहीत किया जाएगा। प्रतिनिधित्वित सीमा लगभग 1e-38 से 1e+38 तक है। सटीक रूप से संग्रहीत किए जा सकने वाले दशमलव अंकों की मात्रा लगभग 7 है।

फ्लोट गुणों का एक महत्वपूर्ण उपयोग अक्षांश और देशांतर मान (रेडियन में) संग्रहीत करना है, ताकि क्वेरी-टाइम पर भूगोलीय दूरी गणनाओं के लिए उपयोग किया जा सके।

### sql_attr_json

एक JSON गुण घोषित करता है।

जब JSON गुणों को अनुक्रमित किया जाता है, Manticore JSON स्वरूपित डेटा के साथ एक पाठ क्षेत्र की अपेक्षा करता है। JSON गुणों में सीमात रहित नेस्टेड स्तरों या प्रकारों के साथ मनमाने JSON डेटा का समर्थन होता है।

### sql_attr_multi

एक मल्टी-वैल्यू गुण घोषित करता है।

साधारण गुण प्रत्येक दस्तावेज़ के लिए केवल 1 मान संलग्न करने की अनुमति देते हैं। हालांकि, कुछ मामलों में (जैसे टैग या श्रेणियाँ) जब एक ही गुण के कई मान संलग्न करना पसंद किया जाता है और मान सूचियों पर छानने या समूहबद्ध करने का आग्रह किया जाता है।

MVA कॉलम से मान ले सकता है (बाकी डेटा प्रकारों की तरह) - इस स्थिति में, परिणाम सेट में कॉलम को अल्पविराम द्वारा पृथक कई पूर्णांक मानों के साथ एक स्ट्रिंग प्रदान करनी चाहिए - या मान प्राप्त करने के लिए एक अलग क्वेरी चला सकता है।

क्वेरी निष्पादित करते समय, इंजन क्वेरी चलाता है, परिणामों को IDs के अनुसार समूहित करता है, और तालिका में उनके संबंधित दस्तावेज़ों को मान सौंपता है। जिन ID के मान तालिका में नहीं मिलते उन्हें त्याग दिया जाता है। क्वेरी निष्पादित करने से पहले, कोई भी परिभाषित `sql_query_pre_all` चलाया जाएगा।

sql_attr_multi के लिए घोषणा प्रारूप इस प्रकार है:

```ini
sql_attr_multi = ATTR-TYPE ATTR-NAME 'from' SOURCE-TYPE \
    [;QUERY] \
    [;RANGED-QUERY]
```

जहाँ

* ATTR-TYPE `uint`, `bigint` या `timestamp` है।
* SOURCE-TYPE `field`, `query`, `ranged-query`, या `ranged-main-query` है।
* QUERY एक वैकल्पिक SQL क्वेरी है जिसका उपयोग सभी (docid, attrvalue) जोड़ों को प्राप्त करने के लिए किया जाता है।
* RANGED-QUERY एक वैकल्पिक SQL क्वेरी है जिसका उपयोग न्यूनतम और अधिकतम ID मान प्राप्त करने के लिए किया जाता है, जैसा कि `sql_query_range` के साथ होता है।
* बैकस्लैश केवल स्पष्टता के लिए शामिल हैं; सब कुछ एक ही पंक्ति में भी घोषित किया जा सकता है।

यह ranged-query SOURCE-TYPE के साथ उपयोग किया जाता है। यदि `ranged-main-query` SOURCE-TYPE का उपयोग कर रहे हैं, तो RANGED-QUERY को छोड़ दें, और यह स्वचालित रूप से `sql_query_range` से वही क्वेरी उपयोग करेगा (जटिल इनहेरिटेंस सेटअप में एक ही क्वेरी को कई बार मैन्युअली डुप्लिकेट करने से बचने के लिए उपयोगी विकल्प)।

```ini
sql_attr_multi = uint tag from field
sql_attr_multi = uint tag from query; SELECT id, tag FROM tags
sql_attr_multi = bigint tag from ranged-query; \
    SELECT id, tag FROM tags WHERE id>=$start AND id<=$end; \
    SELECT MIN(id), MAX(id) FROM tags
```

### sql_attr_string

एक स्ट्रिंग गुण घोषित करता है। प्रत्येक मान का अधिकतम आकार 4GB पर निर्धारित है।

### sql_attr_timestamp

एक UNIX timestamp घोषित करता है।

UNIX timestamp जनवरी 01, 1970 से जनवरी 19, 2038 के बीच एक सेकंड की सटीकता के साथ दिनांक और समय संग्रहीत कर सकते हैं। अपेक्षित कॉलम मान UNIX प्रारूप में एक timestamp होना चाहिए, जो कि जनवरी 01, 1970, GMT को मध्यरात्रि से बीते 32-बिट बिना संकेत के पूर्णांकों में से एक है। अंदरूनी तौर पर timestamp को सभी स्थानों पर पूर्णांकों के रूप में संग्रहीत और संभाला जाता है। पूर्णांकों के रूप में timestamp के साथ काम करने के अलावा, आप उन्हें विभिन्न दिनांक-आधारित कार्यों के साथ भी उपयोग कर सकते हैं, जैसे कि time segments sorting mode या GROUP BY के लिए day/week/month/year निष्कर्षण।

ध्यान दें कि MySQL में DATE या DATETIME कॉलम प्रकारों का उपयोग सीधे तौर पर Manticore में timestamp गुण के रूप में नहीं किया जा सकता; आपको इन कॉलमों को स्पष्ट रूप से UNIX_TIMESTAMP फ़ंक्शन का उपयोग करके परिवर्तित करना होगा (यदि डेटा सीमा में है)।

ध्यान दें कि timestamp जनवरी 01, 1970 से पहले के दिनांक का प्रतिनिधित्व नहीं कर सकते, और MySQL में UNIX_TIMESTAMP() अपेक्षित कुछ भी वापस नहीं करेगा। यदि आपको केवल दिनांकों के साथ काम करना है, न कि समय के साथ, तो इसके बजाय MySQL में `TO_DAYS()` फ़ंक्शन पर विचार करें।


### sql_attr_uint

एक बिना संकेत के पूर्णांक गुण घोषित करता है।

आप पूर्णांक गुणों के लिए बिट काउंट निर्दिष्ट कर सकते हैं, गुण नाम के साथ ':BITCOUNT' जोड़कर (नीचे दिए उदाहरण को देखें)। डिफ़ॉल्ट 32-बिट आकार से कम वाले या बिटफ़ील्ड वाले गुण धीमे प्रदर्शन करते हैं।

```ini
sql_attr_uint = group_id
sql_attr_uint = forum_id:9 # forum_id के लिए 9 बिट्स
```

### sql_field_string

एक कॉम्बो स्ट्रिंग गुण/टेक्स्ट फ़ील्ड घोषित करता है। मानों को एक फुल-टेक्स्ट फ़ील्ड के रूप में अनुक्रमित किया जाएगा, लेकिन समान नाम वाले स्ट्रिंग गुण में भी संग्रहीत किया जाएगा। ध्यान दें, इसे केवल तभी उपयोग किया जाना चाहिए जब आपको यकीन हो कि आप चाहते हैं कि फ़ील्ड फुल-टेक्स्ट तरीके से खोज योग्य हो और एक गुण के रूप में (जिसके साथ इसे sort और group by करने की क्षमता हो)। यदि आप केवल फील्ड के मूल मान को पुनः प्राप्त करना चाहते हैं, तो आपको इसके लिए कुछ भी करने की आवश्यकता नहीं है जब तक कि आपने निहायत ही स्टोर की गई फ़ील्ड्स सूची से फ़ील्ड को हटा नहीं दिया हो via [stored_fields](../../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#stored_fields).

```ini
sql_field_string = name
```

### sql_file_field

फ़ाइल आधारित फ़ील्ड घोषित करता है।
यह निर्देशिका इंडेक्सर को फ़ील्ड सामग्री को फ़ाइल नाम के रूप में व्याख्या करने और संदर्भित फ़ाइल को लोड और प्रोसेस करने देती है। अधिकतम फ़ाइल फ़ील्ड बफर से बड़े फ़ाइलों को छोड़ दिया जाता है। फ़ाइल लोडिंग के दौरान कोई भी त्रुटियाँ (IO त्रुटियाँ, चूकी सीमाएँ, इत्यादि) इंडेक्सिंग चेतावनियों के रूप में रिपोर्ट की जाएँगी और इंडेक्सिंग को जल्दी समाप्त नहीं करेंगी। ऐसे फ़ाइलों के लिए कोई सामग्री इंडेक्स नहीं की जाएगी।

```ini
sql_file_field = field_name
```

### sql_joined_field

जुड़े/पेलोड फ़ील्ड फेच क्वेरी। बहु-मूल्य, विकल्पीय, डिफ़ॉल्ट एक खाली क्वेरी सूची है।

`sql_joined_field` आपको दो अलग-अलग विशेषताएँ उपयोग करने की अनुमति देता है: जुड़े फ़ील्ड और पेलोड (पेलोड फ़ील्ड)। इसका संश्लेषण इस प्रकार है:

```ini
sql_joined_field = FIELD-NAME 'from'  ( 'query' | 'payload-query' | 'ranged-query' | 'ranged-main-query' ); \
		QUERY [ ; RANGE-QUERY ]
```

जहां

* FIELD-NAME एक जुड़ा/पेलोड फ़ील्ड नाम है
* QUERY एक SQL क्वेरी है जो आगे की प्रोसेसिंग के लिए मानों को फेच करना चाहिए
* RANGE-QUERY एक वैकल्पिक SQL क्वेरी है जो प्रोसेस करने के लिए मानों की एक श्रृंखला फेच करती है

**जुड़े फ़ील्ड** आपको मुख्य दस्तावेज़ फेच क्वेरी (sql_query) में JOIN और/या GROUP_CONCAT बयानों से बचने की अनुमति देते हैं। यह तब उपयोगी हो सकता है जब SQL साइड JOIN धीमा हो, या इसे मैन्टिकोर साइड पर ऑफलोड करने की आवश्यकता हो, या सरलता से MySQL विशिष्ट `GROUP_CONCAT` कार्यक्षमता का अनुकरण करने के लिए यदि आपका डेटाबेस सर्वर इसका समर्थन नहीं करता है।

क्वेरी को सटीक रूप से 2 कॉलम लौटाने चाहिए: दस्तावेज़ आईडी, और एक जुड़े फ़ील्ड में जोड़ने के लिए पाठ। दस्तावेज़ आईडी डुप्लिकेट हो सकते हैं, लेकिन उन्हें आरोही क्रम में होना चाहिए। एक दिए गए आईडी के लिए फेच किए गए सभी पाठ पंक्तियों को एक साथ जोड़ा जाएगा, और जोड़ने का परिणाम एक जुड़े फ़ील्ड की संपूर्ण सामग्री के रूप में इंडेक्स किया जाएगा। पंक्तियाँ क्वेरी से लौटाए गए क्रम में जोड़ी जाएँगी, और उनके बीच अलग करने वाला व्हाइटस्पेस डाला जाएगा। उदाहरण के लिए, यदि जुड़े फ़ील्ड क्वेरी निम्नलिखित पंक्तियाँ लौटाती है:
```ini
( 1, 'red' )
( 1, 'right' )
( 1, 'hand' )
( 2, 'mysql' )
( 2, 'manticore' )
```

तो इंडेक्सिंग के परिणामस्वरूप दस्तावेज़ 1 के लिए 'red right hand' के मूल्य के साथ एक नया टेक्स्ट फ़ील्ड जोड़ने और दस्तावेज़ 2 के लिए 'mysql sphinx' को जोड़ना होगा, जिसमें फ़ील्ड के भीतर की कीवर्ड स्थिति उस क्रम में हैं जिसमें वे क्वेरी से आए हैं। यदि पंक्तियाँ किसी विशेष क्रम में होनी चाहिए, तो उसे क्वेरी में स्पष्ट रूप से परिभाषित करने की आवश्यकता है।

जुड़े फ़ील्ड केवल अलग तरीके से इंडेक्स किए जाते हैं। जुड़े फ़ील्ड और नियमित टेक्स्ट फ़ील्ड के बीच कोई अन्य अंतर नहीं है।

जुड़े फ़ील्ड क्वेरी को निष्पादित करने से पहले, यदि कोई सेट `sql_query_pre_all` चलाएगा। यह आपको जुड़े फ़ील्ड के संदर्भ में इच्छित एन्कोडिंग, आदि सेट करने की अनुमति देता है।

जब एकल क्वेरी कुशल नहीं होती या डेटाबेस ड्राइवर की सीमाओं के कारण काम नहीं करती है, तो रेंज क्वेरी का उपयोग किया जा सकता है। यह मुख्य इंडेक्सिंग लूप में रेंज क्वेरी के समान कार्य करता है। रेंज को एक बार अग्रिम रूप से क्वेरी किया जाएगा और फेच किया जाएगा, फिर विभिन्न `$start` और `$end` प्रतिस्थापनों के साथ कई क्वेरियाँ चलायी जाएँगी ताकि वास्तविक डेटा को फेच किया जा सके।

`ranged-main-query` क्वेरी का उपयोग करते समय, `ranged-query` को छोड़ दें, और यह स्वचालित रूप से `sql_query_range` से वही क्वेरी का उपयोग करेगा (संक्षिप्त विरासत सेटअप में एक उपयोगी विकल्प जो कई बार एक ही क्वेरी को मैन्युअल रूप से डुप्लिकेट करने की आवश्यकता को बचाता है)।

<!-- example payload -->
**पेलोड्स** आपको एक विशेष फ़ील्ड बनाने की अनुमति देते हैं जिसमें, कीवर्ड स्थितियों के बजाय, तथाकथित उपयोगकर्ता पेलोड संग्रहीत होते हैं। पेलोड प्रत्येक कीवर्ड के साथ संलग्न कस्टम पूर्णांक मान होते हैं। इन्हें खोज समय पर रैंकिंग पर प्रभाव डालने के लिए उपयोग किया जा सकता है।

पेलोड क्वेरी को सटीक रूप से 3 कॉलम लौटाने चाहिए:
- दस्तावेज़ आईडी
- कीवर्ड
- और पूर्णांक पेलोड मान।

दस्तावेज़ आईडी डुप्लिकेट हो सकते हैं, लेकिन उन्हें आरोही क्रम में होना चाहिए। पेलोड **को** 24-बिट सीमा के भीतर बिना संचित पूर्णांक होना चाहिए, यानी, 0 से 16777215।

पेलोड का ध्यान रखने वाला केवल रैंकर `proximity_bm25` है (डिफ़ॉल्ट [रैंकर](../../Searching/Sorting_and_ranking.md#Available-built-in-rankers)). पेलोड फ़ील्ड वाले तालिकाओं पर, यह स्वचालित रूप से उन फ़ील्डों में कीवर्ड मेल करने के लिए एक भिन्नता में स्विच कर देगा, मेल खाए गए पेलोडों का योग गुणांकित फ़ील्ड वजन के साथ गणना करेगा, और उस योग को अंतिम रैंक में जोड़ देगा।

कृपया ध्यान दें कि पूर्ण-पाठ क्वेरियों के लिए पेलोड फ़ील्ड की अनदेखी की जाती है जिसमें जटिल ऑपरेटर होते हैं। यह केवल सरल बैग-ऑफ़-शब्द क्वेरियों के लिए काम करता है।

<!-- intro -->
कॉन्फ़िगरेशन उदाहरण:
<!-- request Configuration file -->
```ini
source min {
    type = mysql
    sql_host = localhost
    sql_user = test
    sql_pass =
    sql_db = test
    sql_query = select 1, 'Nike bag' f \
    UNION select 2, 'Adidas bag' f \
    UNION select 3, 'Reebok bag' f \
    UNION select 4, 'Nike belt' f

    sql_joined_field = tag from payload-query; select 1 id, 'nike' tag, 10 weight \
    UNION select 4 id, 'nike' tag, 10 weight;
}

index idx {
    path = idx
    source = min
}
```

<!-- request Just SELECT -->
```sql
mysql> select * from idx;
+------+------------+------+
| id   | f          | tag  |
+------+------------+------+
|    1 | Nike bag   | nike |
|    2 | Adidas bag |      |
|    3 | Reebok bag |      |
|    4 | Nike belt  | nike |
+------+------------+------+
4 rows in set (0.00 sec)
```

<!-- request Full-text search -->

ध्यान दें कि जब आप `nike | adidas` के लिए खोज करते हैं, तो "nike" टैग के कारण परिणाम जो "nike" को शामिल करते हैं, को अधिक वजन प्राप्त होता है और इसका वजन पेलोड क्वेरी से उत्पन्न होता है।
```sql
mysql> select *, weight() from idx where match('nike|adidas');
+------+------------+------+----------+
| id   | f          | tag  | weight() |
+------+------------+------+----------+
|    1 | Nike bag   | nike |    11539 |
|    4 | Nike belt  | nike |    11539 |
|    2 | Adidas bag |      |     1597 |
+------+------------+------+----------+
3 rows in set (0.01 sec)
```

<!-- request Complex full-text search -->
ध्यान दें कि विशेष पेलोड फ़ील्ड जटिल ऑपरेटरों को शामिल करने वाले पूर्ण-पाठ क्वेरी के लिए अनदेखा किया जाता है। यह केवल सरल बैग-ऑफ-वार्ड्स क्वेरी के लिए काम करता है।

```sql
mysql> select *, weight() from idx where match('"nike bag"|"adidas bag"');
+------+------------+------+----------+
| id   | f          | tag  | weight() |
+------+------------+------+----------+
|    2 | Adidas bag |      |     2565 |
|    1 | Nike bag   | nike |     2507 |
+------+------------+------+----------+
2 rows in set (0.00 sec)
```

<!-- end -->

### sql_column_buffers

```ini
sql_column_buffers = <colname>=<size>[K|M] [, ...]
```

प्रति-कॉलम बफर आकार। वैकल्पिक, डिफ़ॉल्ट खाली है (स्वचालित रूप से आकार का अनुमान लगाएं)। `odbc`, `mssql` स्रोत प्रकारों पर लागू होता है केवल।

ODBC और MS SQL ड्राइवर कभी-कभी अपेक्षित अधिकतम वास्तविक कॉलम आकार को वापस नहीं कर सकते हैं। उदाहरण के लिए, `NVARCHAR(MAX)` कॉलम हमेशा `indexer` को अपनी लंबाई 2147483647 बाइट के रूप में रिपोर्ट करते हैं, भले ही वास्तव में प्रयुक्त लंबाई काफी कम हो। हालांकि, प्राप्त करने वाले बफर अभी भी पहले से आवंटित होने की आवश्यकता होती है, और उनके आकार का निर्धारण करना होता है। जब ड्राइवर कॉलम लंबाई की रिपोर्ट नहीं करता है, तो मैन्टिकोर प्रत्येक गैर-चर कॉलम के लिए डिफ़ॉल्ट 1 KB बफर और प्रत्येक चर कॉलम के लिए 1 MB बफर आवंटित करता है। ड्राइवर-द्वारा रिपोर्ट की गई कॉलम लंबाई को 8 MB के एक ऊपरी सीमा द्वारा भी संकुचित किया जाता है, इसलिए यदि ड्राइवर (लगभग) 2 GB कॉलम लंबाई की रिपोर्ट करता है, तो इसे संकुचित किया जाएगा और उस कॉलम के लिए 8 MB बफर आवंटित किया जाएगा। इन हार्ड-कोडेड सीमाओं को `sql_column_buffers` निर्देश का उपयोग करके ओवरराइड किया जा सकता है, चाहे वास्तव में छोटे कॉलम पर मेमोरी बचाने के लिए या वास्तव में लंबे कॉलम पर 8 MB की सीमा को पार करने के लिए। निर्देश मान चयनित कॉलम नामों और आकारों की कॉमा-सेपरेटेड सूची होनी चाहिए:

उदाहरण:

```ini
sql_query = SELECT id, mytitle, mycontent FROM documents
sql_column_buffers = mytitle=64K, mycontent=10M
```
<!-- proofread -->


