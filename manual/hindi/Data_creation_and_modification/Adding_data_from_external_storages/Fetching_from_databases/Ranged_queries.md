# रेंज्ड क्वेरीज 


मुख्य क्वेरी, जिसे सभी दस्तावेज़ लाने की आवश्यकता होती है, पूरे टेबल पर एक पढ़ने की लॉक लगा सकती है और समांतर क्वेरियों (जैसे MyISAM तालिका में INSERTs) को रोका सकती है, परिणाम सेट के लिए बहुत सारी मेमोरी बर्बाद कर सकती है, आदि। इससे बचने के लिए, मण्टिकोर तथाकथित *रेंज्ड क्वेरीज* का समर्थन करता है। रेंज्ड क्वेरीज के साथ, मण्टिकोर पहले तालिका से न्यूनतम और अधिकतम दस्तावेज़ ID लाता है, और फिर मुख्य क्वेरी टेक्स्ट में विभिन्न ID अंतराल को प्रतिस्थापित करता है और दस्तावेज़ों के एक और भाग को लाने के लिए संशोधित क्वेरी को चलाता है। यहां एक उदाहरण है।

रेंज्ड क्वेरी उपयोग का उदाहरण:

```ini
sql_query_range = SELECT MIN(id),MAX(id) FROM documents
sql_range_step = 1000
sql_query = SELECT * FROM documents WHERE id>=$start AND id<=$end
```

यदि तालिका में दस्तावेज़ IDs 1 से, कहने के लिए, 2345 तक हैं, तो sql_query तीन बार चलाया जाएगा:

1.  `$start` को 1 से और `$end` को 1000 से प्रतिस्थापित करके;
2.  `$start` को 1001 से और `$end` को 2000 से प्रतिस्थापित करके;
3.  `$start` को 2001 से और `$end` को 2345 से प्रतिस्थापित करके।

स्पष्ट रूप से, 2000-पंक्ति वाली तालिका के लिए यह कोई बड़ा अंतर नहीं है, लेकिन जब 10 मिलियन-पंक्ति वाली तालिका को अनुक्रमित करने की बात आती है, तो रेंज्ड क्वेरीज कुछ मदद कर सकती हैं।

### sql_query_range

रेंज क्वेरी को परिभाषित करता है। इस विकल्प में निर्दिष्ट क्वेरी को न्यूनतम और अधिकतम दस्तावेज़ IDs लाना चाहिए जो रेंज सीमाएँ के रूप में उपयोग किए जाएंगे। इसे बिल्कुल दो पूर्णांक फ़ील्ड लौटाना चाहिए, पहले न्यूनतम ID और दूसरे अधिकतम ID; फ़ील्ड नामों की अनदेखी की जाती है। जब सक्षम हो, तो `sql_query` में $start और $end मैक्रोज़ शामिल होना आवश्यक होगा। ध्यान दें कि $start..$end द्वारा निर्दिष्ट अंतराल आपस में ओवरलैप नहीं करेंगे, इसलिए आपको अपनी क्वेरी से $start या $end के समान दस्तावेज़ IDs को हटाना नहीं चाहिए।
 
### sql_range_step

यह निर्दिष्ट करता है कि रेंज क्वेरी कदम क्या है। डिफ़ॉल्ट मान 1024 है।

### sql_ranged_throttle

इस निर्देश का उपयोग रेंज क्वेरी को थ्रॉटल करने के लिए किया जा सकता है। डिफ़ॉल्ट रूप से, कोई थ्रॉटलिंग नहीं होती है। sql_ranged_throttle के लिए मान मिलीसेकंड में निर्दिष्ट किए जाने चाहिए।

थ्रॉटलिंग तब उपयोगी हो सकती है जब अनुक्रमक डेटाबेस सर्वर पर बहुत अधिक लोड डालता है। यह हर रेंज क्वेरी स्टेप के लिए एक निश्चित समय तक अनुक्रमक को सोने का कारण बनता है। यह नींद बिना शर्त होती है और फेच क्वेरी से पहले की जाती है।

```ini
sql_ranged_throttle = 1000 # प्रत्येक क्वेरी स्टेप से पहले 1 सेकंड के लिए सोएं
```
<!-- proofread -->
