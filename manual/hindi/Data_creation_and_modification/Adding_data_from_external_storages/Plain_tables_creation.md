# साधारण तालिकाओं का निर्माण

साधारण तालिकाएँ वे तालिकाएँ होती हैं जो एक बार बनाते समय एक या कई स्रोतों से डेटा लाकर बनाई जाती हैं। एक साधारण तालिका अपरिवर्तनीय होती है क्योंकि उसके जीवनकाल के दौरान दस्तावेज़ जोड़े या हटाए नहीं जा सकते। केवल संख्यात्मक विशेषताओं के मान (जिसमें MVA शामिल है) को अपडेट करना संभव है। डेटा को ताज़ा करना केवल पूरी तालिका को फिर से बनाने के द्वारा ही संभव है।

साधारण तालिकाएँ केवल [साधारण मोड](../../Creating_a_table/Local_tables.md#Defining-table-schema-in-config-%28Plain mode%29) में उपलब्ध हैं और इसकी परिभाषा एक तालिका घोषणा और एक या एकाधिक स्रोत घोषणाओं से बनी होती है। डेटा संग्रहण और तालिका निर्माण `searchd` सर्वर द्वारा नहीं, बल्कि सहायक उपकरण `indexer` द्वारा किया जाता है।

**Indexer** एक कमांड-लाइन उपकरण है जिसे सीधे कमांड लाइन से या शेल स्क्रिप्ट से कॉल किया जा सकता है।

इसे जब कॉल किया जाता है तो कई तर्कों को स्वीकार कर सकता है, लेकिन Manticore कॉन्फ़िगरेशन फ़ाइल में इसके अपने कुछ सेटिंग्स भी होती हैं।

सामान्य परिदृश्य में, indexer निम्नलिखित करता है:
* स्रोत से डेटा लाता है
* साधारण तालिका बनाता है
* तालिका फ़ाइलें लिखता है
* (वैकल्पिक) नई तालिका के बारे में खोज सर्वर को सूचित करता है जो तालिका रोटेशन को ट्रिगर करता है

## Indexer उपकरण
`indexer` उपकरण का उपयोग Manticore Search में साधारण तालिकाएँ बनाने के लिए किया जाता है। इसका सामान्य स्वरूप है:

```shell
indexer [OPTIONS] [table_name1 [table_name2 [...]]]
```

`indexer` के साथ तालिकाएँ बनाते समय, निर्मित तालिका फ़ाइलों को ऐसे अनुमतियों के साथ बनाया जाना चाहिए जो `searchd` को इन्हें पढ़ने, लिखने और हटाने की अनुमति दें। आधिकारिक Linux पैकेजों के मामले में, `searchd` `manticore` उपयोगकर्ता के तहत चलता है। इसलिए, `indexer` को भी `manticore` उपयोगकर्ता के तहत चलाना चाहिए:

```shell
sudo -u manticore indexer ...
```

यदि आप `searchd` को अलग से चला रहे हैं, तो आपको `sudo -u manticore` को छोड़ना पड़ सकता है। बस यह सुनिश्चित करें कि जिस उपयोगकर्ता के तहत आपका `searchd` उदाहरण चल रहा है, उसके पास `indexer` का उपयोग करके निर्मित तालिकाओं तक पढ़ने/लिखने की अनुमतियाँ हैं।

एक साधारण तालिका बनाने के लिए, आपको उन तालिकाओं की सूची बनानी होगी जिन्हें आप प्रोसेस करना चाहते हैं। उदाहरण के लिए, यदि आपकी `manticore.conf` फ़ाइल में दो तालिकाओं, `mybigindex` और `mysmallindex` का विवरण है, तो आप निम्न लिंक चला सकते हैं:

```shell
sudo -u manticore indexer mysmallindex mybigindex
```

आप तालिका नामों को मेल करने के लिए वाइल्डकार्ड टोकन का उपयोग भी कर सकते हैं:

* `?` किसी भी एकल अक्षर से मेल खाता है
* `*` किसी भी अक्षरों की किसी भी संख्या से मेल खाता है
* `%` कोई भी या एकल अक्षर से मेल खाता है

```shell
sudo -u manticore indexer indexpart*main --rotate
```

Indexer के लिए एग्ज़िट कोड निम्नलिखित हैं:

* 0: सब कुछ ठीक चला
* 1: अनुक्रमण के दौरान कोई समस्या थी (और यदि `--rotate` का निर्दिष्ट किया गया था, तो इसे छोड़ दिया गया) या कोई कार्यवाही चेतावनी उत्पन्न करती है
* 2: अनुक्रमण ठीक चला, लेकिन `--rotate` प्रयास विफल रहा

### Indexer systemd सेवा

आप निम्नलिखित systemctl इकाई फ़ाइल का उपयोग करके `indexer` शुरू कर सकते हैं:

```shell
systemctl start --no-block manticore-indexer
```

या, यदि आप एक विशिष्ट तालिका बनाना चाहते हैं:

```shell
systemctl start --no-block manticore-indexer@specific-table-name
```

कस्टम कॉन्फ़िगरेशन के साथ Indexer चलाने के लिए `systemctl set-environment INDEXER_CONFIG` कमांड का उपयोग करें, जो डिफ़ॉल्ट सेटिंग्स को प्रतिस्थापित करता है।

Indexer के लिए कस्टम स्टार्टअप विकल्प जोड़ने के लिए `systemctl set-environment INDEXER_ARGS` कमांड का उपयोग करें। कमांड-लाइन विकल्पों की पूरी सूची के लिए, [यहाँ](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#Indexer-command-line-arguments) देखें।

उदाहरण के लिए, Indexer को शांत मोड में शुरू करने के लिए, चलाएं:
```bash
systemctl set-environment INDEXER_ARGS='--quiet'
systemctl restart manticore-indexer
```

परिवर्तनों को पूर्ववत करने के लिए, चलाएं:
```bash
systemctl set-environment INDEXER_ARGS=''
systemctl restart manticore-indexer
```

### Indexer कमांड लाइन तर्क
* `--config <file>` (`-c <file>` संक्षेप में) `indexer` को दिए गए फ़ाइल का उपयोग अपने कॉन्फ़िगरेशन के रूप में बताता है। सामान्यत: यह स्थापना निर्देशिका (जैसे `/etc/manticoresearch/manticore.conf`) में `manticore.conf` को खोजेगा, उसके बाद वर्तमान निर्देशिका जो आप शेल से `indexer` को कॉल करने पर होती है। यह साझा परिवेशों में सबसे उपयोगी होता है जहाँ बाइनरी फ़ाइलें एक वैश्विक फ़ोल्डर में स्थापित होती हैं, जैसे `/usr/bin/`, लेकिन आप उपयोगकर्ताओं को अपनी कस्टम Manticore सेट-अप बनाने की क्षमता प्रदान करना चाहते हैं, या यदि आप एक ही सर्वर पर कई उदाहरण चलाना चाहते हैं। ऐसे मामलों में, आप उन्हें अपने `manticore.conf` फ़ाइल बनाने की अनुमति दे सकते हैं और इस विकल्प के साथ `indexer` को पेश कर सकते हैं। उदाहरण के लिए:

  ```shell
  sudo -u manticore indexer --config /home/myuser/manticore.conf mytable
  ```

* `--all` `indexer` को `manticore.conf` में सूचीबद्ध प्रत्येक तालिका को अपडेट करने के लिए बताता है बजाय व्यक्तिगत तालिकाओं की सूची बनाने के। यह छोटी कॉन्फ़िगरेशनों या क्रोन-प्रकार या रखरखाव कार्यों में उपयोगी होगा जहाँ पूरी तालिका सेट हर दिन या सप्ताह में या जिस किसी भी अवधि में सबसे अच्छा हो, फिर से बनाया जाएगा। कृपया ध्यान दें कि चूंकि `--all` कॉन्फ़िगरेशन में पाए गए सभी तालिकाओं को अपडेट करने का प्रयास करता है, यदि यह वर्तमान समय की तालिकाओं का सामना करता है तो यह चेतावनी जारी करेगा और आदेश का एग्ज़िट कोड `1` होगा ना कि `0`, भले ही साधारण तालिकाएँ बिना किसी समस्या के समाप्त हो जाएँ। उपयोग का उदाहरण:

  ```shell
  sudo -u manticore indexer --config /home/myuser/manticore.conf --all
  ```
* `--rotate` का उपयोग तालिकाओं को घुमाने के लिए किया जाता है। जब तक आपके पास ऐसी स्थिति न हो जहाँ आप उपयोगकर्ताओं को परेशानी में डाले बिना खोज कार्यक्षमता को ऑफ़लाइन ले जा सकते हैं, आप नए दस्तावेज़ों को अनुक्रमित करते समय खोज को चालू रखना लगभग निश्चित रूप से आवश्यक होगा। `--rotate` एक दूसरी तालिका बनाता है, पहली के समांतर (एक ही स्थान पर, बस फ़ाइल नामों में `.new` शामिल करते हुए)। पूरा होने पर, `indexer` `searchd` को `SIGHUP` सिग्नल भेजकर सूचित करता है, और `searchd` तालिकाओं का नाम बदलने का प्रयास करेगा (मौजूदा तालिकाओं का नाम बदलकर `.old` में शामिल करना और `.new` का नाम बदलकर उन्हें प्रतिस्थापित करना), और फिर नए फ़ाइलों से सेवा देना शुरू करेगा। [seamless_rotate](../../Server_settings/Searchd.md#seamless_rotate) की सेटिंग के आधार पर नए तालिकाओं की खोज करने में थोड़ा विलंब हो सकता है। यदि एक साथ कई तालिकाओं को घुमाया जाता है जो [killlist_target](../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#killlist_target) संबंधों द्वारा श्रृंखला में हैं, तो घुमाव उन तालिकाओं के साथ शुरू होगा जो लक्ष्य नहीं हैं और लक्ष्य श्रृंखला के अंत में वाले तालिकाओं के साथ समाप्त होगा। उदाहरण उपयोग:

  ```shell
  sudo -u manticore indexer --rotate --all
  ```
* `--quiet` `indexer` को कुछ भी आउटपुट न करने के लिए कहता है, जब तक कोई गलती न हो। इसका उपयोग मुख्य रूप से क्रोन-टाइप या अन्य स्क्रिप्टेड नौकरियों के लिए किया जाता है जहाँ आउटपुट अनिवार्य या अप्रासंगिक है, सिवाय किसी प्रकार की गलती के घटनाक्रम में। उदाहरण उपयोग:

  ```shell
  sudo -u manticore indexer --rotate --all --quiet
  ```
* `--noprogress` प्रगति विवरणों को जैसा वे होते हैं प्रदर्शित नहीं करता। इसके बजाय, अंतिम स्थिति विवरण (जैसे अनुक्रमित दस्तावेज़, अनुक्रमण की गति आदि) केवल अनुक्रमण के पूरा होने पर रिपोर्ट किए जाते हैं। ऐसे मामलों में जहाँ स्क्रिप्ट कंसोल (या 'tty') पर नहीं चलाई जा रही है, यह डिफ़ॉल्ट रूप से चालू रहेगा। उदाहरण उपयोग:

  ```shell
  sudo -u manticore indexer --rotate --all --noprogress
  ```
* `--buildstops <outputfile.text> <N>` तालिका स्रोत की समीक्षा करता है, जैसे कि यह डेटा को अनुक्रमित कर रहा हो, और उन शर्तों की एक सूची बनाता है जो अनुक्रमित हो रही हैं। दूसरे शब्दों में, यह सभी खोजी जाने योग्य शर्तों की एक सूची बनाता है जो तालिका का हिस्सा बन रही हैं। ध्यान दें, यह संबंधित तालिका को अपडेट नहीं करता है, यह केवल डेटा को संसाधित करता है जैसे कि यह अनुक्रमित हो रहा हो, [sql_query_pre](../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Execution_of_fetch_queries.md#sql_query_pre) या [sql_query_post](../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Execution_of_fetch_queries.md#sql_query_post) के साथ परिभाषित क्वेरी चलाने सहित। `outputfile.txt` शब्दों की सूची содержит करेगा, प्रत्येक पंक्ति पर एक, आवृत्ति द्वारा क्रमबद्ध, सबसे अधिक आवृत्ति पहले, और `N` अधिकतम शब्दों की संख्या निर्दिष्ट करता है जो सूचीबद्ध की जाएगी। यदि यह तालिका में हर शब्द को सम्मिलित करने के लिए पर्याप्त बड़ा है, तो केवल इतने ही शब्द लौटाए जाएंगे। ऐसी शब्दकोश सूची क्लाइंट एप्लिकेशन सुविधाओं के लिए "क्या आप मतलब…" कार्यक्षमता के चारों ओर उपयोग की जा सकती है, आमतौर पर `--buildfreqs`, के साथ। उदाहरण:

  ```shell
  sudo -u manticore indexer mytable --buildstops word_freq.txt 1000
  ```

  यह वर्तमान निर्देशिका में एक दस्तावेज़ उत्पन्न करेगा, `word_freq.txt`, 'mytable' में 1,000 सबसे सामान्य शब्दों के साथ, सबसे सामान्य पहले संबंधित। ध्यान दें कि फ़ाइल उन अंतिम तालिका से संबंधित होगी जो कई तालिकाओं या `--all` के साथ निर्दिष्ट करते समय अनुक्रमित की गई थी (यानी अंतिम तालिका जो कॉन्फ़िगरेशन फ़ाइल में सूचीबद्ध है)

* `--buildfreqs` `--buildstops` के साथ काम करता है (और यदि `--buildstops` निर्दिष्ट नहीं है तो इसे नजरअंदाज किया जाता है)। जैसे `--buildstops` तालिका के भीतर उपयोग किए गए शब्दों की सूची प्रदान करता है, `--buildfreqs` तालिका में उपस्थित मात्रा को जोड़ता है, जो यह निर्धारित करने में सहायक होगा कि क्या कुछ शब्दों को रोकने वाले शब्दों के रूप में माना जाना चाहिए यदि वे बहुत प्रचलित हैं। यह "क्या आप मतलब…" सुविधाओं को विकसित करने में भी मदद करेगा जहाँ आपको यह जानने की आवश्यकता होगी कि एक दिए गए शब्द की तुलना में एक अन्य, समान शब्द कितना अधिक सामान्य है। उदाहरण:

  ```shell
  sudo -u manticore indexer mytable --buildstops word_freq.txt 1000 --buildfreqs
  ```

  यह पहले जैसा `word_freq.txt` उत्पन्न करेगा, हालाँकि प्रत्येक शब्द के बाद संबंधित तालिका में इसके होने की संख्या होगी।

* `--merge <dst-table> <src-table>` तालिकाओं को भौतिक रूप से एक साथ मिलााने के लिए उपयोग किया जाता है, उदाहरण के लिए यदि आपके पास [main+delta योजना](../../Creating_a_table/Local_tables/Plain_table.md#Main+delta-scenario) है, जहाँ मुख्य तालिका शायद ही कभी बदलती है, लेकिन डेल्टा तालिका को बार-बार पुनर्निर्मित किया जाता है, और `--merge` का उपयोग दोनों को मिलाने के लिए किया जाएगा। यह ऑपरेशन दाहिने से बाएं की ओर चलता है - `src-table` की सामग्री की जांच की जाती है और इसे `dst-table` की सामग्री के साथ भौतिक रूप से जोड़ा जाता है और परिणाम `dst-table` में छोड़ दिया जाता है। псевдо-код में, यह व्यक्त किया जा सकता है: `dst-table += src-table` एक उदाहरण:

  ```shell
  sudo -u manticore indexer --merge main delta --rotate
  ```

  उपरोक्त उदाहरण में, जहाँ मुख्य मास्टर है, शायद ही संशोधित तालिका, और डेल्टा अधिक बार संशोधित होता है, आप उपरोक्त का उपयोग `indexer` को रिकॉर्ड में डालने के लिए डेल्टा के सामग्री को मुख्य तालिका में संयोजित करने और तालिकाओं को घुमाने के लिए कर सकते हैं।

* `--merge-dst-range <attr> <min> <max>` संयोजन करते समय दिए गए फ़िल्टर रेंज को चलाता है। विशेष रूप से, जैसे ही संयोजन गंतव्य तालिका पर लागू होता है (जैसे `--merge के हिस्से के रूप में, और यदि `--merge` निर्दिष्ट नहीं है तो इसे नजरअंदाज किया जाता है), `indexer` भी गंतव्य तालिका में समाप्त होने वाले दस्तावेज़ों को फ़िल्टर करेगा, और केवल उन दस्तावेज़ों को फ़िल्टर दिया जाएगा जो अंतिम तालिका का हिस्सा बनने के लिए अंत में पहुँचेंगे। इसे उदाहरण के लिए, एक तालिका में उपयोग किया जा सकता है जहाँ एक 'हटाया गया' विशेषता है, जहाँ 0 'हटाया नहीं गया' का मान है। ऐसी एक तालिका के साथ मिला सकते हैं:

  ```shell
  sudo -u manticore indexer --merge main delta --merge-dst-range deleted 0 0
  ```

  कोई भी दस्तावेज़ जो हटाए गए के रूप में चिह्नित किया गया है (मान 1) नए-मिलाए गए गंतव्य तालिका से हटा दिए जाएंगे। इसे आदेश पंक्ति में कई बार जोड़ा जा सकता है, संयोजन में अनुक्रम में आवश्यक सभी फ़िल्टर जोड़ने के लिए, जिनमें से सभी को एक दस्तावेज़ को अंतिम तालिका का हिस्सा बनने के लिए पूरा करना चाहिए।
* --`merge-killlists` (और इसका छोटा उपनाम `--merge-klists`) टेबलों को मिलाते समय किल सूचियों को संसाधित करने के तरीके को बदलता है। डिफ़ॉल्ट रूप से, दोनों किल सूचियाँ एक मर्ज के बाद नष्ट हो जाती हैं। यह सबसे सामान्य मुख्य+डेल्टा मर्ज परिदृश्य का समर्थन करता है। हालांकि, अगर इस विकल्प को सक्षम किया गया है, तो दोनों टेबलों से किल सूचियाँ जोड़ी जाती हैं और गंतव्य तालिका में संग्रहीत की जाती हैं। ध्यान दें कि एक स्रोत (डेल्टा) तालिका की किल सूची का उपयोग हमेशा गंतव्य (मुख्य) तालिका से पंक्तियों को दबाने के लिए किया जाएगा।
* `--keep-attrs` पुनः अनुक्रमण पर मौजूदा गुणों का पुनः उपयोग करने की अनुमति देता है। जब भी तालिका को फिर से बनाया जाता है, प्रत्येक नई दस्तावेज़ आईडी की "पुरानी" तालिका में उपस्थिति की जाँच की जाती है, और यदि यह पहले से मौजूद है, तो इसके गुण "नई" तालिका में स्थानांतरित कर दिए जाते हैं; यदि नहीं मिला, तो नई तालिका के गुणों का उपयोग किया जाता है। यदि उपयोगकर्ता ने तालिका में गुणों को अपडेट किया है, लेकिन तालिका के लिए उपयोग किए गए वास्तविक स्रोत में नहीं, तो पुनः अनुक्रमण करते समय सभी अपडेट खो जाएंगे; `--keep-attrs` का उपयोग पिछले तालिका से अपडेट मूल्य को बचाने की अनुमति देता है। तालिका फ़ाइलों के लिए एक पथ निर्दिष्ट करना संभव है, जिसका उपयोग कॉन्फ़िगरेशन से संदर्भ पथ के बजाय किया जाएगा:

  ```shell
  sudo -u manticore indexer mytable --keep-attrs=/path/to/index/files
  ```

* `--keep-attrs-names=<attributes list>` पुनः अनुक्रमण पर मौजूदा तालिका से पुनः उपयोग के लिए गुणों को निर्दिष्ट करने की अनुमति देता है। डिफ़ॉल्ट रूप से, मौजूदा तालिका के सभी गुण नई तालिका में पुनः उपयोग किए जाते हैं:

  ```shell
  sudo -u manticore indexer mytable --keep-attrs=/path/to/table/files --keep-attrs-names=update,state
  ```

* `--dump-rows <FILE>` SQL स्रोतों द्वारा प्राप्त पंक्तियों को निर्दिष्ट फ़ाइल में, MySQL संगत सिंटैक्स में डालता है। परिणामी डंप `indexer` द्वारा प्राप्त डेटा का सटीक प्रतिनिधित्व हैं और अनुक्रमण समय की समस्याओं को दोहराने में मदद कर सकते हैं। इस आदेश के तहत स्रोत से डेटा निकाला जाता है और टेबल फ़ाइलें और डंप फ़ाइल दोनों बनाई जाती हैं।
* `--print-rt <rt_index> <table>` स्रोत से ली गई डेटा को एक वास्तविक समय तालिका के लिए INSERTs के रूप में आउटपुट करता है। डंप की पहली पंक्तियाँ वास्तविक समय के क्षेत्रों और गुणों को शामिल करेंगी (सादा तालिका के क्षेत्रों और गुणों का एक प्रतिबिंब)। इस आदेश के तहत स्रोत से डेटा निकाला जाता है और टेबल फ़ाइलें और डंप आउटपुट दोनों बनाई जाती हैं। इस आदेश का उपयोग `sudo -u manticore indexer -c manticore.conf --print-rt indexrt indexplain > dump.sql` के रूप में किया जा सकता है। केवल SQL-आधारित स्रोतों का समर्थन किया जाता है। MVA का समर्थन नहीं किया जाता।
* `--sighup-each` तब उपयोगी है जब आप कई बड़े टेबलों का पुनर्निर्माण कर रहे हैं और चाहते हैं कि प्रत्येक एक को संभवतः जल्द से जल्द `searchd` में घुमाया जाए। `--sighup-each` के साथ, `indexer` प्रत्येक तालिका पर कार्य सफलतापूर्वक पूरा करने के बाद searchd को SIGHUP सिग्नल भेजेगा। (डिफ़ॉल्ट व्यवहार सभी तालिकाओं के निर्माण के बाद एकल SIGHUP भेजना है।)
* `--nohup` तब उपयोगी है जब आप वास्तव में वितरित करने से पहले indextool के साथ अपनी तालिका को जांचना चाहते हैं। यदि यह विकल्प चालू है, तो indexer SIGHUP नहीं भेजेगा। तालिका फ़ाइलों का नाम बदलकर .tmp कर दिया जाता है। तालिका फ़ाइलों को .new में नाम बदलने और घुमाने के लिए indextool का उपयोग करें। उदाहरण उपयोग:

  ```shell
  sudo -u manticore indexer --rotate --nohup mytable
  sudo -u manticore indextool --rotate --check mytable
  ```

* `--print-queries` SQL क्वेरी को प्रिंट करता है जो `indexer` डेटाबेस को भेजता है, साथ ही SQL कनेक्शन और डिस्कनेक्शन घटनाएँ। यह SQL स्रोतों के साथ समस्याओं का निदान और ठीक करने में सहायक है।
* `--help` (`-h` संक्षिप्त रूप में) सभी पैरामीटर की सूची बनाता है जो `indexer` में लागू किए जा सकते हैं।
* `-v` `indexer` संस्करण दिखाता है।

### Indexer कॉन्फ़िगरेशन सेटिंग्स
आप Manticore कॉन्फ़िगरेशन फ़ाइल में `indexer` अनुभाग में indexer के व्यवहार को भी कॉन्फ़िगर कर सकते हैं:

```ini
indexer {
...
}
```

#### lemmatizer_cache

```ini
lemmatizer_cache = 256M
```
Lemmatizer कैश का आकार। वैकल्पिक, डिफ़ॉल्ट 256K है।

हमारा [lemmatizer](../../Server_settings/Common.md#lemmatizer_base) कार्यान्वयन एक संकुचित शब्दकोश प्रारूप का उपयोग करता है जो स्थान/गति व्यापार का सक्षम करता है। यह या तो संकुचित डेटा से लेमाटाइजेशन कर सकता है, अधिक CPU का उपयोग करते हुए लेकिन कम RAM, या यह आंशिक या पूरी तरह से शब्दकोश को decompress और pre-cache कर सकता है, जिससे कम CPU लेकिन अधिक RAM का उपयोग होता है। lemmatizer_cache निर्देश आपको यह नियंत्रित करने की अनुमति देती है कि उस अव्यवस्थित शब्दकोश कैश के लिए वास्तव में कितना RAM खर्च किया जा सकता है।

वर्तमान में, केवल उपलब्ध शब्दकोश [ru.pak, en.pak, और de.pak](https://manticoresearch.com/install/) हैं। ये रूसी, अंग्रेजी, और जर्मन शब्दकोश हैं। संकुचित शब्दकोश आकार में लगभग 2 से 10 MB है। ध्यान दें कि शब्दकोश सभी समय में मेमोरी में रहता है। डिफ़ॉल्ट कैश का आकार 256 KB है। स्वीकार्य कैश आकार 0 से 2047 MB हैं। कैश का आकार बढ़ाना सुरक्षित है; lemmatizer केवल आवश्यक मेमोरी का उपयोग करेगा। उदाहरण के लिए, संपूर्ण रूसी शब्दकोश को लगभग 110 MB में decompress किया जाता है; इसलिए `lemmatizer_cache` को उससे अधिक सेट करने से मेमोरी उपयोग पर कोई प्रभाव नहीं पड़ेगा। यहां तक कि जब कैश के लिए 1024 MB की अनुमति दी जाती है, यदि केवल 110 MB की आवश्यकता है, तो यह केवल उन 110 MB का उपयोग करेगा।

#### max_file_field_buffer

```ini
max_file_field_buffer = 128M
```

अधिकतम फ़ाइल फ़ील्ड अनुकूली बफर आकार बाइट में। वैकल्पिक, डिफ़ॉल्ट 8MB है, न्यूनतम 1MB है।

फ़ाइल फ़ील्ड बफर का उपयोग [sql_file_field](../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Processing_fetched_data.md#sql_file_field) कॉलम से संदर्भित फ़ाइलों को लोड करने के लिए किया जाता है। यह बफर अनुकूली है, प्रारंभ में 1 MB पर आवंटित होता है, और अधिकतम बफर आकार तक पहुँचने तक 2x के चरणों में बढ़ता है, जिसे `max_file_field_buffer` निर्देश द्वारा निर्दिष्ट किया गया है, या जब फ़ाइल सामग्री लोड की जा सकती है।

इसलिए, यदि कोई फ़ाइल फ़ील्ड निर्दिष्ट नहीं हैं, तो कोई बफर आवंटित नहीं किया जाता है। यदि अनुक्रमण के दौरान लोड की गई सभी फ़ाइलें (उदाहरण के लिए) 2 MB के तहत हैं, लेकिन `max_file_field_buffer` मूल्य 128 MB है, तो शिखर बफर उपयोग केवल 2 MB होगा। हालाँकि, 128 MB से अधिक फ़ाइलें पूरी तरह से छोड़ दी जाएँगी।

#### max_iops

```ini
max_iops = 40
```

अधिकतम I/O संचालन प्रति सेकंड, I/O थ्रॉटलिंग के लिए। वैकल्पिक, डिफ़ॉल्ट 0 (असीमित) है।
I/O थ्रॉटलिंग से संबंधित विकल्प। यह प्रति किसी भी दिए गए सेकंड में अधिकतम I/O ऑपरेशनों (पढ़ने या लिखने) की संख्या को सीमित करता है। 0 का मान का मतलब है कि कोई सीमा नहीं लगाई गई है।

`indexer` एक तालिका बनाने के दौरान तीव्र डिस्क I/O का विस्फोट उत्पन्न कर सकता है, और इसके डिस्क गतिविधि को सीमित करना उचित हो सकता है (और उसी मशीन पर चल रहे अन्य कार्यक्रमों के लिए कुछ आरक्षित रखना, जैसे `searchd`)। I/O थ्रॉटलिंग इसे करने में मदद करता है। यह `indexer` द्वारा किए गए अगले डिस्क I/O ऑपरेशनों के बीच एक न्यूनतम सुनिश्चित विलंब को लागू करके काम करता है। I/O थ्रॉटलिंग खोज प्रदर्शन में कमी को कम करने में मदद कर सकता है जो निर्माण के कारण होती है। यह सेटिंग अन्य प्रकार के डेटा इनजेशन के लिए प्रभावी नहीं है, जैसे कि वास्तविक समय की तालिका में डेटा डालना।

#### max_iosize

```ini
max_iosize = 1048576
```

I/O थ्रॉटलिंग के लिए अनधिकृत I/O ऑपरेशन का अधिकतम आकार, बाइट्स में। वैकल्पिक, डिफ़ॉल्ट 0 है (असीमित)।

I/O थ्रॉटलिंग से संबंधित विकल्प। यह सभी ऑपरेशनों के लिए `indexer` द्वारा किए जाने वाले अधिकतम फ़ाइल I/O ऑपरेशन (पढ़ने या लिखने) के आकार को सीमित करता है। 0 का मान का मतलब है कि कोई सीमा नहीं लगाई गई है। जो पढ़ने या लिखने के आकार सीमा से बड़े हैं उन्हें कई छोटे ऑपरेशनों में विभाजित किया जाएगा, और [max_iops](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#max_iops) सेटिंग द्वारा कई ऑपरेशनों के रूप में गिना जाएगा। इस लेखन के समय, सभी I/O कॉल को वैसे भी 256 KB (डिफ़ॉल्ट आंतरिक बफ़र आकार) के तहत होना चाहिए, इसलिए 256 KB से उच्च max_iosize मान का कोई प्रभाव नहीं होना चाहिए।

#### max_xmlpipe2_field

```ini
max_xmlpipe2_field = 8M
```

XMLpipe2 स्रोत प्रकार के लिए अधिकतम अनुमति प्राप्त फ़ील्ड आकार, बाइट्स में। वैकल्पिक, डिफ़ॉल्ट 2 MB है।

#### mem_limit

```ini
mem_limit = 256M
# mem_limit = 262144K # समान, लेकिन KB में
# mem_limit = 268435456 # समान, लेकिन बाइट्स में
```

प्लेन तालिका निर्माण RAM उपयोग सीमा। वैकल्पिक, डिफ़ॉल्ट 128 MB है। यह एक लागू की गई मेमोरी उपयोग सीमा है जो `indexer` द्वारा नहीं बढ़ाई जाएगी। इसे बाइट्स, किलोक्लबाइट्स (K पोस्टफिक्स का उपयोग करके), या मेगाबाइट्स (M पोस्टफिक्स का उपयोग करके) में निर्दिष्ट किया जा सकता है; उदाहरण देखें। यदि इसे अत्यधिक कम मान में सेट किया जाता है जिससे I/O बफर 8 KB से कम हो जाता है, तो यह सीमा स्वत: बढ़ जाएगी; उसके लिए सटीक निचली सीमा निर्मित डेटा के आकार पर निर्भर करती है। यदि बफर 256 KB से कम हैं, तो एक चेतावनी उत्पन्न होगी।

अधिकतम संभावित सीमा 2047M है। बहुत कम मान प्लेन तालिका निर्माण की गति को नुकसान पहुंचा सकते हैं, लेकिन 256M से 1024M अधिकांश, यदि सभी डेटा सेट के लिए पर्याप्त होना चाहिए। इस मान को बहुत अधिक सेट करने से SQL सर्वर समयसीमा हो सकती है। दस्तावेज़ संग्रहण चरण के दौरान, ऐसा समय होगा जब मेमोरी बफ़र आंशिक रूप से क्रमबद्ध हो जाएगा और डेटाबेस के साथ कोई संचार नहीं किया जाएगा; और डेटाबेस सर्वर समयसीमा हो सकता है। आप इसे SQL सर्वर की ओर पर समयसीमा बढ़ाकर या `mem_limit` को कम करके हल कर सकते हैं।

#### on_file_field_error

```ini
on_file_field_error = skip_document
```

फ़ाइल फ़ील्ड में IO त्रुटियों को कैसे संभालें। वैकल्पिक, डिफ़ॉल्ट `ignore_field` है।
जब किसी फ़ाइल फ़ील्ड द्वारा संदर्भित फ़ाइल को अनुक्रमित करने में कोई समस्या होती है ([sql_file_field](../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Processing_fetched_data.md#sql_file_field)), `indexer` या तो दस्तावेज़ को संसाधित कर सकता है, इस विशिष्ट फ़ील्ड में खाली सामग्री मानते हुए, या दस्तावेज़ को छोड़ सकता है, या समग्र रूप से अनुक्रमण में असफल हो सकता है। `on_file_field_error` निर्देश इस व्यवहार को नियंत्रित करता है। यह जो मान लेता है वे हैं:
* `ignore_field`, वर्तमान दस्तावेज़ को फ़ील्ड के बिना संसाधित करें;
* `skip_document`, वर्तमान दस्तावेज़ को छोड़ें लेकिन अनुक्रमण जारी रखें;
* `fail_index`, त्रुटि संदेश के साथ अनुक्रमण में असफल।

संभावित समस्याएँ जो उत्पन्न हो सकती हैं: खोली गई त्रुटि, आकार त्रुटि (फ़ाइल बहुत बड़ी), और डेटा पढ़ने की त्रुटि। किसी भी समस्या पर चेतावनी संदेश सभी समय दिए जाएंगे, चरण और `on_file_field_error` सेटिंग की परवाह किए बिना।

ध्यान दें कि `on_file_field_error = skip_document` के साथ दस्तावेज़ केवल तब अनदेखा किए जाएंगे जब प्रारंभिक जांच चरण के दौरान समस्याएँ पहचान की जाएँ, और **नहीं** वास्तविक फ़ाइल पार्सिंग चरण के दौरान। `indexer` हर संदर्भित फ़ाइल को खोलेगा और किसी भी कार्य को करने से पहले उसका आकार चेक करेगा, और फिर वास्तविक पार्सिंग कार्य करते समय इसे फिर से खोलेगा। इसलिए यदि इन दोनों खुलने के प्रयासों के बीच कोई फ़ाइल चली जाती है, तो दस्तावेज़ का अनसुना किया जाएगा।

#### write_buffer

```ini
write_buffer = 4M
```

लिखने का बफ़र आकार, बाइट्स में। वैकल्पिक, डिफ़ॉल्ट 1MB है। लिखने के बफ़र का उपयोग अनुक्रमण के दौरान अस्थायी और अंतिम तालिका फ़ाइलों को लिखने के लिए किया जाता है। बड़े बफ़र आवश्यक डिस्क लिखने की संख्या को कम करते हैं। बफ़रों के लिए मेमोरी [mem_limit](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#mem_limit) के अलावा आवंटित की जाती है। ध्यान दें कि विभिन्न फ़ाइलों के लिए कई (वर्तमान में 4 तक) बफ़र आवंटित किए जाएंगे, जो RAM उपयोग को अनुपात में बढ़ा देगा।

#### ignore_non_plain

```ini
ignore_non_plain = 1
```

`ignore_non_plain` आपको गैर-प्लेन तालिकाओं को छोड़ने के बारे में पूरी तरह से चेतावनी को अनदेखा करने की अनुमति देता है। डिफ़ॉल्ट 0 है (अनदेखा नहीं करना)।
<!-- proofread -->


### systemd के माध्यम से indexer का कार्यक्रम बनाएं

indexer चलाने को अनुसूचित करने के दो तरीके हैं। पहला तरीका क्रॉनटैब का उपयोग करने की पारंपरिक विधि है। दूसरा तरीका उपयोगकर्ता-निर्धारित कार्यक्रम के साथ systemd टाइमर का उपयोग करना है। टाइमर यूनिट फ़ाइलें बनाने के लिए, आपको उन्हें उस उपयुक्त निर्देशिका में रखना चाहिए जहाँ systemd ऐसी यूनिट फ़ाइलों की तलाश करता है। अधिकांश लिनक्स वितरणों में, यह निर्देशिका आमतौर पर `/etc/systemd/system` होती है। इसे करने का तरीका यहाँ है:

1. अपने कस्टम कार्यक्रम के लिए एक टाइमर यूनिट फ़ाइल बनाएँ:
   ```shell
   cat << EOF > /etc/systemd/system/manticore-indexer@.timer
   [Unit]
   Description=Run Manticore Search's indexer on schedule
   [Timer]
   OnCalendar=minutely
   RandomizedDelaySec=5m
   Unit=manticore-indexer@%i.service
   [Install]
   WantedBy=timers.target
   EOF
   ```
   `OnCalendar` वाक्यविन्यास और उदाहरणों पर अधिक जानकारी [यहाँ](https://www.freedesktop.org/software/systemd/man/latest/systemd.time.html#Calendar%20Events) मिल सकती है।
2. अपने विशिष्ट आवश्यकताओं के अनुसार टाइमर इकाई संपादित करें।
3. टाइमर सक्षम करें:
   ```shell
   systemctl enable manticore-indexer@idx1.timer
   ```
4. टाइमर प्रारंभ करें:
   ```shell
   systemctl start manticore-indexer@idx1.timer
   ```
5. किसी भी अतिरिक्त टाइमरों के लिए चरण 2-4 को दोहराएं।




