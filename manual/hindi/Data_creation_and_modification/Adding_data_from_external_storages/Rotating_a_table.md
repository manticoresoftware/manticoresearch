# तालिका को घुमाना

तालिका घुमाना एक प्रक्रिया है जिसमें searchd सर्वर कॉन्फ़िगरेशन में परिभाषित तालिकाओं के नए संस्करणों की खोज करता है। रोटेशन केवल साधारण मोड में ही समर्थित होता है।

दो स्थितियाँ हो सकती हैं:

* साधारण तालिकाओं के लिए जो पहले से ही लोड की जा चुकी हैं
* तालिकाएं जो कॉन्फ़िगरेशन में जोड़ी गई हैं, पर अभी तक लोड नहीं हुई हैं

पहले मामले में, indexer तालिका के नए संस्करण को ऑनलाइन नहीं रख सकता क्योंकि चल रही प्रति को 'searchd' द्वारा लॉक और लोड किया गया है। इस मामले में `indexer` को [--rotate](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#Indexer-command-line-arguments) पैरामीटर के साथ कॉल करना आवश्यक होता है। यदि रोटेट का उपयोग किया जाता है, तो `indexer` नई तालिका फ़ाइलों को `.new.` के साथ उनके नामों में बनाता है और `searchd` को नए संस्करण के बारे में सूचित करने के लिए *HUP* सिग्नल भेजता है। `searchd` नए संस्करण को जगह पर रखेगा और पुराने को त्याग देगा। कुछ मामलों में, तालिका के नए संस्करण को बनाना वांछित हो सकता है लेकिन जल्द से जल्द रोटेट न करना वांछनीय होता है। उदाहरण के लिए, पहले नए तालिका संस्करणों की स्वास्थ्य जांच करना वांछित हो सकता है। इस मामले में, `indexer` `--nohup` पैरामीटर स्वीकार कर सकता है जो सर्वर को HUP सिग्नल भेजने से रोक देगा।

नई तालिकाएं रोटेशन द्वारा लोड की जा सकती हैं; हालांकि, HUP सिग्नल का नियमित हेंडलिंग केवल तभी नई तालिकाओं की जांच करता है जब सर्वर स्टार्टअप के बाद से कॉन्फ़िगरेशन बदल गया हो। यदि तालिका पहले ही कॉन्फ़िगरेशन में परिभाषित है, तो तालिका को पहले `indexer` को रोटेशन के बिना चलाकर बनाना चाहिए और इसके बजाय [RELOAD TABLES](../../Data_creation_and_modification/Adding_data_from_external_storages/Rotating_a_table.md#RELOAD-TABLES) स्टेटमेंट चलाना चाहिए।

तालिकाओं पर रोटेशन करने के लिए दो विशेष स्टेटमेंट भी हो सकते हैं:

## RELOAD TABLE

```sql
RELOAD TABLE tbl [ FROM '/path/to/table_files' [ OPTION switchover=1 ] ];
```

`RELOAD TABLE` कमांड SQL के माध्यम से तालिका रोटेशन को सक्षम करता है।

यह कमांड तीन मोड में काम करता है। पहले मोड में, बिना पाथ निर्दिष्ट किए, Manticore सर्वर [path](../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#path) द्वारा इंगित डिरेक्टरी में नई तालिका फ़ाइलों की जांच करता है। नई तालिका फ़ाइलें `tbl.new.sp?` के रूप में नामित होनी चाहिए।

यदि आप एक पाथ निर्दिष्ट करते हैं, तो सर्वर उस डिरेक्टरी में तालिका फ़ाइलों की खोज करता है, उन्हें तालिका [path](../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#path) पर स्थानांतरित करता है, उनके नाम `tbl.sp?` से `tbl.new.sp?` में बदलता है, और उन्हें घुमाता है।

तीसरा मोड, `OPTION switchover=1` द्वारा सक्रिय किया गया, इंडेक्स को नई पाथ पर स्विच करता है। यहां, डेमन नई पाथ से सीधे तालिका लोड करने की कोशिश करता है बिना फाइलों को स्थानांतरित किए। यदि लोडिंग सफल होती है, तो यह नया इंडेक्स पुराने को प्रतिस्थापित करता है।

इसके अलावा, डेमन [path](../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#path) द्वारा निर्दिष्ट डिरेक्टरी में एक अद्वितीय लिंक फ़ाइल (`tbl.link`) लिखता है, जिससे स्थायी रूप से पुनर्निर्देशन होता है।

यदि आप कॉन्फ़िगरेशन में निर्दिष्ट पाथ पर पुनः निर्देशित इंडेक्स को वापस करते हैं, तो डेमन इसे पहचान लेगा और लिंक फ़ाइल को हटा देगा।

एक बार पुनःनिर्देशित होने पर, डेमन तालिका को नए लिंक पाथ से प्राप्त करता है। जब रोटेट होता है, तो यह नए पुनः निदेशित पाथ पर नई तालिका संस्करणों की तलाश करता है। ध्यान रहे, डेमन सामान्य त्रुटियों के लिए कॉन्फ़िगरेशन की जांच करता है, जैसे कि विभिन्न तालिकाओं के बीच डुप्लिकेट पाथ। हालांकि, यह पहचान नहीं करेगा कि कई तालिकाएं पुनर्निर्देशन के माध्यम से एक ही पाथ की ओर इशारा करती हैं। सामान्य संचालन में, तालिकाएं `.spl` फ़ाइल के साथ लॉक की जाती हैं, लेकिन लॉक को अक्षम करने से समस्याएँ हो सकती हैं। यदि कोई त्रुटि होती है (जैसे कि किसी कारण से पाथ तक पहुँचना असंभव है), तो आपको मैन्युअल रूप से लिंक फाइल को सही (या बस हटाना) करना चाहिए।

`indextool` लिंक फ़ाइल का पालन करता है, लेकिन अन्य उपकरण (`indexer`, `index_converter`, आदि) लिंक फाइल को नहीं पहचानते हैं और कॉन्फ़िगरेशन फाइल में परिभाषित पाथ का उपयोग करते हैं, किसी भी पुनर्निर्देशन को अनदेखा करते हैं। अतः, आप `indextool` के साथ इंडेक्स का निरीक्षण कर सकते हैं, और यह नए स्थान से पढ़ेगा। हालांकि, मर्ज करने जैसी अधिक जटिल क्रियाएं किसी भी लिंक फाइल को स्वीकार नहीं करेंगी।

```sql
mysql> RELOAD TABLE plain_table;
mysql> RELOAD TABLE plain_table FROM '/home/mighty/new_table_files';
mysql> RELOAD TABLE plain_table FROM '/home/mighty/new/place/for/table/table_files' OPTION switchover=1;
```

## RELOAD TABLES

```sql
RELOAD TABLES;
```

यह कमांड HUP सिस्टम सिग्नल के समान कार्य करता है, तालिकाओं के रोटेशन को प्रेरित करता है। फिर भी, यह सामान्य HUP सिग्नल (जो `kill -HUP` कमांड या `indexer --rotate` से आ सकता है) के बिल्कुल समान नहीं होता। यह कमांड किसी भी तालिका को खोजने के लिए सक्रिय रुप से प्रयास करता है जो रोटेशन की ज़रूरत में हैं और कॉन्फ़िगरेशन को पुनः पढ़ने में सक्षम है। मान लीजिए कि आप एक कॉन्फ़िग फाइल के साथ प्लेन मोड में Manticore चलाने का प्रयास करते हैं जो किसी गैर-अस्तित्व वाली साधारण तालिका की ओर इशारा करता है। यदि आप उस तालिका को `indexer --rotate` करने का प्रयास करते हैं, तो नए तालिका को सर्वर द्वारा तब तक नहीं पहचाना जाएगा जब तक आप `RELOAD TABLES` निष्पादित नहीं करते या सर्वर को पुनः आरंभ करते।

[seamless_rotate](../../Server_settings/Searchd.md#seamless_rotate) सेटिंग के मान के आधार पर, नए प्रश्न थोड़े समय के लिए रुके हो सकते हैं, और ग्राहकों को अस्थायी त्रुटियां प्राप्त होंगी।

```sql
mysql> RELOAD TABLES;
Query OK, 0 rows affected (0.01 sec)
```

# सीमलेस रोटेट

रोटेशन मानता है कि पुराना तालिका संस्करण त्याग दिया गया है और नया तालिका संस्करण लोड किया गया है और मौजूदा वाले को प्रतिस्थापित करता है। इस अदलाबदली के दौरान, सर्वर को भी उन प्रश्नों की सेवा करनी होती है जो तालिका पर अद्यतन की जाने वाली हैं। प्रश्नों की रुकावट से बचने के लिए, सर्वर तालिका का सीमलेस रोटेट को डिफ़ॉल्ट रूप से लागू करता है, जैसा कि नीचे वर्णित है।

तालिकाएं डेटा रख सकती हैं जिसे RAM में पूर्वकैश किया जाना चाहिए। वर्तमान में, `.spa`, `.spb`, `.spi` और `.spm` फ़ाइलें पूरी तरह से पूर्वकैश की गई हैं (वे विशेषता डेटा, ब्लोब विशेषता डेटा, कीवर्ड तालिका, और रद्द पंक्ति मानचित्र, क्रमशः रखते हैं)। सीमलेस रोटेट के बिना, तालिका को घुमाते समय संभवतः कम से कम RAM का उपयोग करने का प्रयास होता है और यह इस प्रकार काम करता है:
1. नए प्रश्न अस्थायी रूप से अस्वीकृत होते हैं ( "retry" त्रुटि कोड के साथ)।
2. `searchd` सभी चल रहे प्रश्नों के पूरे होने का इंतजार करता है।
3. पुरानी तालिका को अवमुक्त किया जाता है और इसकी फ़ाइलों का नाम बदल दिया जाता है।
4. नई तालिका की फ़ाइलों का नाम बदला जाता है और आवश्यक RAM आवंटित की जाती है।
5. नई तालिका के गुण और शब्दकोश डेटा RAM में पूर्व-लोड किया जाता है।
6. `searchd` नए तालिका से प्रश्नों को सेवा देना शुरू करता है।

हालांकि, यदि बहुत सारे गुण या शब्दकोश डेटा हैं, तो पूर्व-लोडिंग चरण में ध्यान देने योग्य समय लग सकता है - 1-5+ जीबी फ़ाइलों के पूर्व-लोडिंग के मामले में कई मिनट तक।

सजीव घुमाव सक्षम होने पर, घुमाव इस प्रकार कार्य करता है:

1. नई तालिका के लिए RAM स्टोरेज आवंटित किया जाता है।
2. नई तालिका के गुण और शब्दकोश डेटा को असिंक्रोनस रूप से RAM में पूर्व-लोड किया जाता है।
3. सफलता पर, पुरानी तालिका को अवमुक्त किया जाता है और दोनों तालिकाओं की फ़ाइलों का नाम बदल दिया जाता है।
4. असफलता पर, नई तालिका को अवमुक्त किया जाता है।
5. किसी भी दिए गए क्षण में, प्रश्नों को या तो पुरानी या नई तालिका की प्रति से सेवा दी जाती है।

सजीव घुमाव का लाभ यह है कि घुमाव के दौरान उच्च **पीक** मेमोरी उपयोग की कीमत चुकानी पड़ती है (क्योंकि पुरानी और नई प्रतियों दोनों के `.spa/.spb/.spi/.spm` डेटा को नई प्रति को पूर्व-लोड करते समय RAM में होना चाहिए)। हालाँकि, औसत उपयोग समान रहता है।

उदाहरण:

```ini
seamless_rotate = 1
```
<!-- proofread -->

