# संघटित

MySQL संघटित इंजन के साथ, आप MySQL/MariaDB से एक स्थानीय या दूरस्थ Manticore उदाहरण से जुड़ सकते हैं और खोज प्रश्न कर सकते हैं।

## संघटित का उपयोग करना

एक वास्तविक Manticore प्रश्न को सीधे संघटित इंजन के साथ उपयोग नहीं किया जा सकता है और इसे "प्रॉक्सी" (एक कॉलम में स्ट्रिंग के रूप में भेजा जाता है) के माध्यम से भेजना होता है क्योंकि संघटित इंजन की सीमाएँ हैं और यह तथ्य कि Manticore कस्टम सिंटैक्स को लागू करता है जैसे [MATCH](../Searching/Full_text_matching/Basic_usage.md) अनुकृति।

`संघटित` के माध्यम से खोजने के लिए, आपको पहले एक संघटित इंजन तालिका बनानी होगी। Manticore प्रश्न को संघटित तालिका पर किए गए `SELECT` में `query` कॉलम में शामिल किया जाएगा।

<!-- example create federated -->
संघटित-संगत MySQL तालिका बनाने के लिए:


<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
CREATE TABLE t1
(
    id          INTEGER UNSIGNED NOT NULL,
    year        INTEGER NOT NULL,
    rating    	FLOAT,
    query       VARCHAR(1024) NOT NULL,
    INDEX(query)
) ENGINE=FEDERATED
DEFAULT CHARSET=utf8
CONNECTION='mysql://FEDERATED@127.0.0.1:9306/DB/movies';
```
<!-- response SQL-->

```sql
Query OK, 0 rows affected (0.00 sec)
```
<!-- end -->

<!-- example select federated -->
संघटित संगत तालिका पूछताछ करना:


<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
SELECT * FROM t1 WHERE query='SELECT * FROM movies WHERE MATCH (\'pie\')';
```

<!-- response SQL-->

```sql
+----+------+--------+------------------------------------------+
| id | year | rating | query                                    |
+----+------+--------+------------------------------------------+
|  1 | 2019 |      5 | SELECT * FROM movies WHERE MATCH ('pie') |
+----+------+--------+------------------------------------------+
1 row in set (0.04 sec)
```
<!-- end -->

केवल निश्चित मैपिंग `query` कॉलम है। यह अनिवार्य है और तालिका के साथ केवल एकमात्र कॉलम होना चाहिए।

Manticore तालिका जो `संघटित` के माध्यम से लिंक की गई है, **अवश्य** एक भौतिक तालिका होनी चाहिए (सामान्य या वास्तविक समय)।

संघटित तालिका में उन स्तंभों के नाम होने चाहिए जो दूरस्थ Manticore तालिका के गुणों के समान हैं क्योंकि वे नाम द्वारा Manticore परिणाम सेट में प्रदान किए गए गुणों से बंधे होंगे। हालाँकि, यह केवल कुछ गुणों को मैप कर सकता है, सभी को नहीं।

Manticore सर्वर एक संघटित क्लाइंट से एक प्रश्न को "FEDERATED" उपयोगकर्ता नाम द्वारा पहचानता है। `CONNECTION` स्ट्रिंग पैरामीटर का उपयोग Manticore होस्ट, SQL पोर्ट, और कनेक्शन के माध्यम से आने वाले प्रश्नों के लिए तालिकाओं को निर्दिष्ट करने के लिए किया जाता है। दूरसंचार स्ट्रिंग सिंटैक्स इस प्रकार है:

```ini
CONNECTION="mysql://FEDERATED@HOST:PORT/DB/TABLENAME"
```

चूंकि Manticore के पास डेटाबेस का कोई अवधारणा नहीं है, इसलिए `DB` स्ट्रिंग यादृच्छिक हो सकती है क्योंकि इसे Manticore द्वारा अनदेखा किया जाएगा, लेकिन MySQL को `CONNECTION` स्ट्रिंग परिभाषा में एक मान की आवश्यकता होती है। उदाहरण में देखा गया, पूर्ण `SELECT` SQL प्रश्न को `query` कॉलम के खिलाफ WHERE क्लॉज में रखा जाना चाहिए।

केवल `SELECT` कथन के लिए समर्थन है, `INSERT`, `REPLACE`, `UPDATE`, या `DELETE` के लिए नहीं।

### संघटित सुझाव

एक **बहुत महत्वपूर्ण** नोट यह है कि Manticore को परिणाम सेट को क्रमबद्ध, फ़िल्टर और स्लाइस करने देना **बहुत** अधिक प्रभावी है, बजाय इसके कि अधिकतम मिलान संख्या बढ़ाई जाए और MySQL पक्ष पर WHERE, ORDER BY, और LIMIT क्लॉज़ का उपयोग किया जाए। इसके दो कारण हैं। पहले, Manticore कई ऑप्टिमाइज़ेशन को लागू करता है और इन कार्यों के लिए MySQL की तुलना में बेहतर प्रदर्शन करता है। दूसरे, कम डेटा द्वारा searchd को पैक किया जाना चाहिए, स्थानांतरित किया जाना चाहिए, और Manticore और MySQL के बीच अनपैक किया जाना चाहिए।

<!-- example federated join -->
संघटित तालिका और अन्य MySQL तालिकाओं के बीच JOIN किया जा सकता है। इसका उपयोग जानकारी प्राप्त करने के लिए किया जा सकता है जो Manticore तालिका में नहीं संग्रहित है।


<!-- intro -->
##### SQL:

<!-- request SQL -->
##### Manticore द्वारा प्रदान की गई संघटित तालिका के साथ MySQL आधारित तालिका को JOIN करने के लिए प्रश्न:

```sql
SELECT t1.id, t1.year, comments.comment FROM t1 JOIN comments ON t1.id=comments.post_id WHERE query='SELECT * FROM movies WHERE MATCH (\'pie\')';
```

<!-- response SQL-->

```sql
+----+------+--------------+
| id | year | comment      |
+----+------+--------------+
|  1 | 2019 | was not good |
+----+------+--------------+
1 row in set (0.00 sec)
```

<!-- end -->
<!-- proofread -->
