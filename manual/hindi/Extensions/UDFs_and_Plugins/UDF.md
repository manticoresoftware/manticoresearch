# UDF

UDFs बाहरी डायनामिक लाइब्रेरीज़ (.so फाइल्स UNIX पर और .dll फाइल्स Windows सिस्टम्स पर) में संग्रहीत होते हैं। सुरक्षा कारणों से लाइब्रेरी फ़ाइलों को एक विश्वसनीय फ़ोल्डर में रखा जाना चाहिए, जिसे [plugin_dir](../../Server_settings/Common.md#plugin_dir) निर्देश द्वारा निर्दिष्ट किया गया है: एकल फ़ोल्डर को सुरक्षित करना कहीं आसान है बजाय इसके कि कोई भी `searchd` में मनमाने कोड इंस्टॉल करने की अनुमति दे। आप [CREATE FUNCTION](../../Extensions/UDFs_and_Plugins/UDF/Creating_a_function.md) और [DROP FUNCTION](../../Extensions/UDFs_and_Plugins/UDF/Deleting_a_function.md) SQL स्टेटमेंट्स का उपयोग करके क्रमशः `searchd` में UDFs को डायनेमिक रूप से लोड और अनलोड कर सकते हैं। इसके अतिरिक्त, आप [RELOAD PLUGINS](../../Extensions/UDFs_and_Plugins/Plugins/Reloading_plugins.md) स्टेटमेंट के साथ UDFs (और अन्य प्लगइन्स) को निर्बाध रूप से रीलोड कर सकते हैं। Manticore वर्तमान में लोड की गई फ़ंक्शन्स का ट्रैक रखता है; हर बार जब आप किसी UDF को बनाते या हटाते हैं, `searchd` [sphinxql_state](../../Server_settings/Searchd.md#sphinxql_state) फ़ाइल में अपनी स्थिति को एक सामान्य SQL स्क्रिप्ट के रूप में अपडेट करता है।

UDFs स्थानीय होते हैं। इन्हें क्लस्टर पर उपयोग करने के लिए, आपको सभी नोड्स पर समान लाइब्रेरी रखना होगा और प्रत्येक नोड पर CREATE स्टेटमेंट चलाना होगा। यह प्रक्रिया भविष्य के संस्करणों में बदल सकती है।

एक बार जब आप सफलतापूर्वक एक UDF लोड कर लेते हैं, तो आप इसे अपने SELECT या अन्य स्टेटमेंट्स में किसी भी बिल्ट-इन फ़ंक्शन की तरह उपयोग कर सकते हैं:

```sql
SELECT id, MYCUSTOMFUNC (groupid, authorname), ... FROM myindex
```

कई UDFs (और अन्य प्लगइन्स) एक ही लाइब्रेरी में स्थित हो सकते हैं। लाइब्रेरी केवल एक बार लोड की जाएगी और इसके भीतर के सभी UDFs और प्लगइन्स हट जाने पर स्वतः अनलोड हो जाएगी।

सैद्धांतिक रूप से, आप किसी भी भाषा में UDF लिख सकते हैं, बशर्ते कि उसका कंपाइलर मानक C हेडर्स को आयात कर सके और सही ढंग से एक्सपोर्टेड फ़ंक्शन्स के साथ मानक डायनामिक लाइब्रेरीज़ उत्पन्न कर सके। हालांकि, C++ या साधारण C में लिखना सबसे कम प्रतिरोध वाला रास्ता है। हम एक उदाहरण UDF लाइब्रेरी प्रदान करते हैं, जो साधारण C में लिखी गई है और कई फ़ंक्शन्स को लागू करती है (विभिन्न तकनीकों का प्रदर्शन करते हुए) हमारे स्रोत कोड के साथ, जो [src/udfexample.c](https://github.com/manticoresoftware/manticore/blob/master/src/udfexample.c) पर पाई जाती है। यह उदाहरण [src/sphinxudf.h](https://github.com/manticoresoftware/manticore/blob/master/src/sphinxudf.h) हेडर फ़ाइल को भी शामिल करता है, जिसमें कई UDF-संबंधित संरचनाओं और प्रकारों की परिभाषाएँ शामिल हैं। अधिकांश UDFs और प्लगइन्स के लिए, उदाहरण में दिखाए गए अनुसार केवल `#include "sphinxudf.h"` का उपयोग करना पर्याप्त होना चाहिए। हालांकि, यदि आप एक रैंकिंग फ़ंक्शन लिख रहे हैं और UDF के भीतर से रैंकिंग सिग्नल (फैक्टर्स) डेटा तक पहुंच की आवश्यकता है, तो आपको `src/sphinxudf.c` (जो हमारे स्रोत कोड में उपलब्ध है) के साथ कंपाइल और लिंक करना भी आवश्यक होगा, क्योंकि UDF के भीतर से सिग्नल डेटा तक पहुंचने देने वाले फ़ंक्शन्स के *implementations* उसी फ़ाइल में स्थित हैं।

दोनों `sphinxudf.h` हेडर और `sphinxudf.c` स्वतंत्र हैं, इसलिए आप उन फ़ाइलों को व्यक्तिगत रूप से कॉपी कर सकते हैं; वे Manticore के स्रोत कोड के किसी अन्य भाग पर निर्भर नहीं करते।

अपने UDF के भीतर, आपको **must** केवल कुछ ही फ़ंक्शन्स को इम्प्लीमेंट और एक्सपोर्ट करना आवश्यक है। सबसे पहले, UDF इंटरफेस संस्करण नियंत्रण के लिए, आपको **must** एक फ़ंक्शन `int LIBRARYNAME_ver()` परिभाषित करना चाहिए, जहाँ LIBRARYNAME आपकी लाइब्रेरी फ़ाइल का नाम है, और आपको उससे `SPH_UDF_VERSION` (एक मान जो `sphinxudf.h` में परिभाषित है) लौटाना चाहिए। यहाँ एक उदाहरण है।

```c
#include <sphinxudf.h>

// our library will be called udfexample.so, thus, so it must define
// a version function named udfexample_ver()
int udfexample_ver()
{
    return SPH_UDF_VERSION;
}
```

यह सावधानी आपको एक नई या पुरानी `searchd` में असंगत UDF इंटरफेस संस्करण वाली लाइब्रेरी को आकस्मिक रूप से लोड करने से बचाती है। दूसरी बात, आपको **must** वास्तविक फ़ंक्शन को भी इम्प्लीमेंट करना आवश्यक है।

```c
sphinx_int64_t testfunc ( SPH_UDF_INIT * init, SPH_UDF_ARGS * args, char * error_flag )
{
    return 123;
}
```

SQL में UDF फ़ंक्शन नाम केस-संवेदनशील नहीं होते। हालाँकि, संबंधित C फ़ंक्शन नाम वैसे नहीं होते; उन्हें सभी *lower-case* में होना चाहिए, वरना UDF लोड नहीं होगा। इससे भी अधिक महत्वपूर्ण है कि:

1. कॉलिंग कन्वेंशन C है (जैसे __cdecl),
2. आर्गुमेंट्स सूची प्लगइन सिस्टम की अपेक्षाओं से बिल्कुल मेल खाती हो, और
3. रिटर्न प्रकार उसी से मेल खाता हो जिसे आपने `CREATE FUNCTION` में निर्दिष्ट किया है।

दुर्भाग्य से, फ़ंक्शन लोड करते समय इन गलतियों की जांच करने का (आसान) कोई तरीका नहीं है, और इससे सर्वर क्रैश हो सकता है और/या अप्रत्याशित परिणाम हो सकते हैं। अंतिम लेकिन कम नहीं, सभी C फ़ंक्शन्स जिन्हें आप इम्प्लीमेंट करते हैं, उन्हें थ्रेड-सुरक्षित होना आवश्यक है।

पहला आर्गुमेंट, `SPH_UDF_INIT` संरचना के लिए एक पॉइंटर, मूल रूप से हमारे फ़ंक्शन की स्थिति का एक पॉइंटर है। यह वैकल्पिक है। ऊपर दिए गए उदाहरण में, फ़ंक्शन स्टेटलेस है, क्योंकि यह हर बार कॉल होने पर सिर्फ 123 लौटाता है। अतः, हमें एक इनिशियलाइज़ेशन फ़ंक्शन परिभाषित करने की आवश्यकता नहीं है, और हम उस आर्गुमेंट को सरलता से अनदेखा कर सकते हैं.

यह आर्गुमेंट एक और उद्देश्य पूरा करता है। चूंकि एकल क्वेरी को कई थ्रेड्स पर निष्पादित किया जा सकता है (देखें [pseudo-sharding](../Server_settings/Searchd.md#pseudo_sharding)), डेमन इस आर्गुमेंट की जांच करके निर्धारित करता है कि UDF स्टेटफुल है या स्टेटलेस। यदि आर्गुमेंट इनिशियलाइज़ किया गया है, तो समानांतर निष्पादन अक्षम हो जाएगा। अतः, यदि आपका UDF स्टेटफुल है लेकिन आप इस आर्गुमेंट का उपयोग नहीं करते, तो इसे कई थ्रेड्स से कॉल किया जाएगा, और आपके कोड को इसकी जानकारी होनी चाहिए।

दूसरा आर्गुमेंट, `SPH_UDF_ARGS` के लिए एक पॉइंटर, सबसे महत्वपूर्ण है। सभी वास्तविक कॉल आर्गुमेंट्स आपके UDF को इस संरचना के माध्यम से पास किए जाते हैं; इसमें कॉल आर्गुमेंट काउंट, नाम, प्रकार, आदि शामिल होते हैं। तो, चाहे आपका फ़ंक्शन `SELECT id, testfunc(1)` की तरह कॉल हो या `SELECT id, testfunc('abc', 1000*id+gid, WEIGHT())` की तरह या किसी अन्य तरीके से, यह सभी मामलों में वही `SPH_UDF_ARGS` संरचना प्राप्त करेगा। हालांकि, `args` संरचना में पास किया गया डेटा अलग होगा। पहले उदाहरण में, `args->arg_count` को 1 सेट किया जाएगा, दूसरे उदाहरण में इसे 3 सेट किया जाएगा, और `args->arg_types` एरे में विभिन्न प्रकार के डेटा होंगे, आदि।
अंत में, तीसरा तर्क एक त्रुटि ध्वज होता है। एक UDF इसे उठाकर संकेत दे सकता है कि कोई आंतरिक त्रुटि हुई है, UDF जारी नहीं रह सकता है, और क्वेरी को जल्द ही समाप्त होना चाहिए। आपको इसे तर्क प्रकार की जांच के लिए या किसी अन्य त्रुटि रिपोर्टिंग के लिए उपयोग नहीं करना चाहिए जो सामान्य उपयोग के दौरान होने की संभावना है। यह ध्वज अचानक गंभीर रनटाइम त्रुटियों की रिपोर्ट करने के लिए डिज़ाइन किया गया है, जैसे कि मेमोरी खत्म हो जाना।

अगर हम चाहते हैं कि, उदाहरण के लिए, हमारी फ़ंक्शन के उपयोग के लिए अस्थायी स्टोरेज आवंटित करें, या आगे यह जांचें कि तर्क समर्थित प्रकार के हैं या नहीं, तो हमें दो और फ़ंक्शंस जोड़ने की आवश्यकता होगी, UDF आरंभ और अनारंभ के लिए क्रमशः।

```c
int testfunc_init ( SPH_UDF_INIT * init, SPH_UDF_ARGS * args,
    char * error_message )
{
    // अस्थायी स्टोरेज का थोड़ा सा आवंटित और प्रारंभ करें
    init->func_data = malloc ( sizeof(int) );
    *(int*)init->func_data = 123;

    // एक सफल कोड वापस करें
    return 0;
}

void testfunc_deinit ( SPH_UDF_INIT * init )
{
    // हमारे अस्थायी स्टोरेज को मुक्त करें
    free ( init->func_data );
}
```

ध्यान दें कि `testfunc_init()` भी कॉल तर्क संरचना प्राप्त करता है। जब इसे बुलाया जाता है, तब इसे कोई वास्तविक मान नहीं मिलता है, इसलिए `args->arg_values` NULL होगा। लेकिन तर्क नाम और प्रकार ज्ञात हैं और पारित किए जाएंगे। आप उन्हें प्रारंभिकीकरण फ़ंक्शन में जांच सकते हैं और यदि वे किसी अप्राप्य प्रकार के हैं तो एक त्रुटि लौट सकते हैं।


## SPH_UDF_ARGS के प्रकार

UDFs काफी हद तक किसी भी वैध आंतरिक मंटिकोर प्रकार के तर्क प्राप्त कर सकते हैं। `sphinx_udf_argtype` एनोमरेशन में `sphinxudf.h` का पूरा विवरण देखें। अधिकांश प्रकार सीधे संबंधित C प्रकारों को मैप करते हैं।

सबसे उल्लेखनीय प्रकार `SPH_UDF_TYPE_FACTORS` तर्क प्रकार है। आप अपने UDF को [PACKEDFACTOR()](../../searching-and-ranking-functions#PACKEDFACTORS()) तर्क के साथ कॉल करके उस प्रकार को प्राप्त करते हैं। इसका डेटा एक विशेष आंतरिक प्रारूप में एक बाइनरी ब्लॉब है, और उस ब्लॉब से व्यक्तिगत रैंकिंग सिग्नल को निकालने के लिए, आपको दो में से किसी एक `sphinx_factors_XXX()` या `sphinx_get_YYY_factor()` फ़ंक्शन परिवारों का उपयोग करने की आवश्यकता है।

### sphinx_factors_XXX() फ़ंक्शन

यह परिवार 3 फ़ंक्शन से बना होता है।

* `sphinx_factors_init()` अनपैक किए गए `SPH_UDF_FACTORS` संरचना का प्रारंभ करता है
* `sphinx_factors_unpack()` बाइनरी ब्लॉब को `SPH_UDF_FACTORS` संरचना में अनपैक करता है
* `sphinx_factors_deinit()` को साफ करता है और `SPH_UDF_FACTORS` को डीयलोकेट करता है।

पहले, आपको `init()` और `unpack()` को कॉल करने की ज़रूरत है, फिर आप `SPH_UDF_FACTORS` फ़ील्ड का उपयोग कर सकते हैं, और अंत में, आपको `deinit()` के साथ साफ करने की ज़रूरत है।

यह दृष्टिकोण सरल है लेकिन प्रत्येक संसाधित दस्तावेज़ के लिए एक समूह मेमोरी आवंटन का परिणाम हो सकता है, जो धीमा हो सकता है।

### sphinx_get_YYY_factor() फ़ंक्शन

अन्य इंटरफेस, जो `sphinx_get_YYY_factor()` फ़ंक्शनों के एक समूह से मिलता है, उपयोग करने में थोड़ी अधिक वर्बोज़ है लेकिन ब्लॉब डेटा तक सीधे पहुँचता है और गारंटी देता है कि कोई भी आवंटन नहीं होता है। शीर्ष श्रेणी के रैंकिंग UDF प्रदर्शन के लिए, आप इस दृष्टिकोण का उपयोग करना चाहेंगे।

## UDF के रिटर्न प्रकार

जहां तक रिटर्न प्रकार की बात है, UDF वर्तमान में एकल INTEGER, BIGINT, FLOAT, या STRING मान लौट सकते हैं। C फ़ंक्शन रिटर्न प्रकार क्रमश: `sphinx_int64_t`, `sphinx_int64_t`, `double` या `char*` होना चाहिए। अंतिम मामले में, आपको लौटाए गए स्ट्रिंग मानों के लिए स्थान आवंटित करने के लिए `args->fn_malloc` फ़ंक्शन का उपयोग करना **ज़रूरी** है। आंतरिक रूप से आपके UDF में, आप जो चाहें उपयोग कर सकते हैं, इसलिए उपरोक्त `testfunc_init()` उदाहरण सही कोड है भले ही यह सीधे malloc() का उपयोग करता है: आप उस पॉइंटर को स्वयं प्रबंधित करते हैं, इसे मिलान किए गए free() कॉल का उपयोग करके मुक्त किया जाता है, और सब कुछ ठीक रहता है। हालाँकि, लौटाई गई स्ट्रिंग मान मंटिकोर द्वारा प्रबंधित होती हैं, और हमारे पास अपना आवंटक है, इसलिए विशेष रूप से रिटर्न मानों के लिए, आपको इसे भी उपयोग करने की आवश्यकता है।

यह निर्भर करता है कि आपकी UDFs का क्वेरी में कैसे उपयोग किया जाता है, मुख्य फ़ंक्शन कॉल (`testfunc()` हमारे उदाहरण में) को काफी अलग मात्रा और क्रम में बुलाया जा सकता है। विशेष रूप से,

* WHERE, ORDER BY, या GROUP BY क्लॉज में संदर्भित UDFs को प्रत्येक मिलान किए गए दस्तावेज़ के लिए मूल्यांकन किया जाना चाहिए और किया जाएगा। उन्हें प्राकृतिक मिलान क्रम में बुलाया जाएगा।
* उपचयन के बिना, UDFs जो अंतिम परिणाम सेट पर बहुत अंतिम चरण में मूल्यांकन किए जा सकते हैं, उन्हें उसी तरह से मूल्यांकन किया जाएगा, लेकिन `LIMIT` क्लॉज लागू करने से पहले। उन्हें परिणाम सेट क्रम में बुलाया जाएगा।
* उपचयन के साथ, ऐसे UDFs को आंतरिक `LIMIT` क्लॉज लागू करने के बाद भी मूल्यांकन किया जाएगा।

अन्य फ़ंक्शंस का कॉलिंग अनुक्रम तय है, हालांकि। अर्थात्,

* `testfunc_init()` को क्वेरी आरंभ करते समय एक बार बुलाया जाता है। यह विफलता को इंगित करने के लिए एक गैर-शून्य कोड लौटा सकता है; उस मामले में, क्वेरी समाप्त की जाएगी, और `error_message` बफर से त्रुटि संदेश लौटा दिया जाएगा।
* जब भी मंटिकोर को UDF मूल्य की गणना करने की आवश्यकता होती है, तब `testfunc()` को हर पात्र पंक्ति (उपरोक्त देखें) के लिए बुलाया जाता है। यह (आंतरिक) विफलता त्रुटि का संकेत भी दे सकता है `error_flag` में गैर-शून्य बाइट मान लिखकर। उस मामले में, यह गारंटी दी जाती है कि इसे बाद की पंक्तियों के लिए नहीं बुलाया जाएगा, और एक डिफ़ॉल्ट रिटर्न मान 0 प्रतिस्थापित किया जाएगा। मंटिकोर ऐसी क्वेरीज़ को जल्दबाजी में समाप्त करने का चयन कर सकता है या नहीं; वर्तमान में, किसी भी व्यवहार की गारंटी नहीं है।
* `testfunc_deinit()` को तब बुलाया जाता है जब क्वेरी प्रोसेसिंग (किसी दिए गए टेबल शार्ड में) समाप्त होती है।

<!-- proofread -->
