# UDFs और Plugins

Manticore को उपयोगकर्ता-परिभाषित कार्यों, या संक्षेप में UDFs, के साथ इस प्रकार विस्तारित किया जा सकता है:

```sql
SELECT id, attr1, myudf (attr2, attr3+attr4) ...
```

आप UDFs को `searchd` में गतिशील रूप से लोड और अनलोड कर सकते हैं बिना सर्वर को पुनः आरंभ किए, और उन्हें खोजने, रैंकिंग करने, आदि के दौरान अभिव्यक्तियों में उपयोग कर सकते हैं। UDF विशेषताओं का त्वरित सारांश इस प्रकार है:

* UDFs पूर्णांक (दोनों 32-बिट और 64-बिट), फ्लोट, स्ट्रिंग, MVA, या `PACKEDFACTORS()` तर्क ले सकते हैं।
* UDFs पूर्णांक, फ्लोट, या स्ट्रिंग मान वापस कर सकते हैं।
* UDFs प्रश्न सेटअप चरण के दौरान तर्क संख्या, प्रकार, और नामों की जांच कर सकते हैं, और त्रुटियाँ उत्पन्न कर सकते हैं।

हम अभी तक एकत्रण कार्यों का समर्थन नहीं करते हैं। दूसरे शब्दों में, आपके UDFs को केवल एक बार में एकल दस्तावेज के लिए कॉल किया जाएगा और उस दस्तावेज़ के लिए कुछ मान वापस करने की अपेक्षा की जाएगी। एक ऐसा कार्य लिखना जो AVG() जैसे संचित मान की गणना कर सके जो समान GROUP BY कुंजी साझा करने वाले सभी दस्तावेजों के समूह पर है, अभी संभव नहीं है। हालाँकि, आप UDFs का उपयोग अंतर्निहित एकत्रण कार्यों के भीतर कर सकते हैं: अर्थात्, भले ही MYCUSTOMAVG() अभी समर्थित नहीं है, AVG(MYCUSTOMFUNC()) ठीक से काम करना चाहिए!

UDFs कई प्रकार के अनुप्रयोगों की पेशकश करते हैं, जैसे कि:

* कस्टम गणितीय या स्ट्रिंग कार्यों को शामिल करना;
* Manticore के भीतर डेटाबेस या फ़ाइलों तक पहुँच बनाना;
* जटिल रैंकिंग कार्यों का निर्माण करना।

## Plugins

Plugins खोज कार्यक्षमता का विस्तार करने के लिए अतिरिक्त अवसर प्रदान करते हैं। उन्हें वर्तमान में कस्टम रैंकिंग की गणना करने और दस्तावेज़ों और प्रश्नों को टोकनाइज़ करने के लिए उपयोग किया जा सकता है।

यहाँ plugin प्रकारों की पूर्ण सूची है:

* UDF plugins (आधार रूप से UDFs, लेकिन चूंकि वे प्लग इन होते हैं, इसलिए उन्हें 'UDF plugins' के रूप में भी संदर्भित किया जाता है)
* रेंकर plugins
* इंडेक्सिंग-समय टोकन फ़िल्टर plugins
* प्रश्न-समय टोकन फ़िल्टर plugins

यह अनुभाग plugins लिखने और प्रबंधित करने की सामान्य प्रक्रिया को कवर करता है; विभिन्न प्रकार के plugins बनाने से संबंधित विशिष्टताएँ उनके संबंधित उपखंडों में चर्चा की गई हैं।

तो, आप एक plugin कैसे लिखते और उपयोग करते हैं? यहाँ एक त्वरित चार-चरणीय गाइड है:

* एक गतिशील पुस्तकालय बनाएं (या तो .so या .dll), जिसे संभवतः C या C++ का उपयोग करके बनाया गया है;
* [CREATE PLUGIN](../../Extensions/UDFs_and_Plugins/Plugins/Creating_a_plugin.md) के साथ searchd में plugin लोड करें;
* plugin का उपयोग plugin-विशिष्ट कॉल के साथ करें (आमतौर पर विशिष्ट OPTIONS के माध्यम से)।
* [DROP PLUGIN](../../Extensions/UDFs_and_Plugins/Plugins/Deleting_a_plugin.md) और [RELOAD PLUGINS](../../Extensions/UDFs_and_Plugins/Plugins/Reloading_plugins.md) के साथ क्रमशः एक plugin को अनलोड या फिर से लोड करें।

ध्यान दें कि जबकि UDFs पहली श्रेणी के plugins होते हैं, उन्हें एक अलग [CREATE FUNCTION](../../Extensions/UDFs_and_Plugins/UDF/Creating_a_function.md) कथन का उपयोग करके स्थापित किया जाता है। यह लौटने वाली प्रकार का व्यवस्थित रूप से निर्दिष्ट करने की अनुमति देता है, बिना पिछले अनुकूलता को बलिदान किए या वाक्य संरचना को बदले।

गतिशील plugins धागों और thread_pool श्रमिकों में समर्थित होते हैं। एक ही पुस्तकालय फ़ाइल में कई plugins (और/या UDFs) हो सकते हैं। आप सभी प्रोजेक्ट-विशिष्ट plugins को एक बड़े पुस्तकालय में समूहित करने या प्रत्येक UDF और plugin के लिए एक अलग पुस्तकालय बनाने का विकल्प चुन सकते हैं; यह आप पर निर्भर है।

UDFs के साथ, आपको `src/sphinxudf.h` हेडर फ़ाइल शामिल करनी चाहिए। कम से कम, आपको एक उचित संस्करण कार्य को कार्यान्वित करने के लिए `SPH_UDF_VERSION` स्थायी की आवश्यकता होगी। विशिष्ट plugin प्रकार के आधार पर, आपको अपने plugin को `src/sphinxudf.c` के साथ लिंक करने की आवश्यकता हो सकती है या नहीं। हालाँकि, `sphinxudf.c` में कार्यान्वित सभी कार्य `PACKEDFACTORS()` बॉल को अनपैक करने से संबंधित होते हैं, और कोई भी plugin प्रकार उस डेटा तक पहुँच नहीं रखता है। इसलिए वर्तमान में, केवल हेडर के साथ लिंक करना पर्याप्त होना चाहिए। (वास्तव में, यदि आप UDF संस्करण संख्या की प्रतिलिपि बनाते हैं, तो आपको कुछ plugin प्रकारों के लिए हेडर फ़ाइल की भी आवश्यकता नहीं होगी।)

औपचारिक रूप से, plugins बस C कार्यों के सेट होते हैं जो एक विशिष्ट नामकरण पैटर्न का पालन करते हैं। आपसे आमतौर पर प्राथमिक कार्य के लिए एक प्रमुख कार्य को परिभाषित करने की आवश्यकता होती है, लेकिन आप अतिरिक्त कार्यों को भी परिभाषित कर सकते हैं। उदाहरण के लिए, एक रेंकर "myrank" लागू करने के लिए, आपको `myrank_finalize()` कार्य को परिभाषित करना होगा जो रैंक मान वापस करता है। हालाँकि, आप `myrank_init()`, `myrank_update()`, और `myrank_deinit()` कार्यों को भी परिभाषित कर सकते हैं। विशेष सेटों के सुविख्यात उपसर्ग और कॉल तर्क plugin प्रकार के अनुसार भिन्न होते हैं, लेकिन _init() और _deinit() सामान्य हैं, और हर plugin में होते हैं। सूचक: ज्ञात उपसर्गों और उनके तर्क प्रकारों पर त्वरित संदर्भ के लिए, `sphinxplugin.h` का उल्लेख करें, जहाँ कॉल प्रोटोटाइप फ़ाइल की शुरुआत में परिभाषित होते हैं।

हालाँकि सार्वजनिक इंटरफ़ेस को शुद्ध C में परिभाषित किया गया है, हमारे plugins मूल रूप से एक *वस्तु-उन्मुख मॉडल* का पालन करते हैं। वास्तव में, हर `_init()` कार्य एक `void ** userdata` आउट-परामीटर प्राप्त करता है, और `(*userdata)` में संग्रहीत पॉइंटर मान सभी अन्य plugin कार्यों के लिए पहले तर्क के रूप में पास किया जाता है। इसलिए आप एक plugin को एक *क्लास* के रूप में सोच सकते हैं जो हर बार एक ऑब्जेक्ट की आवश्यकता होने पर इंस्टेंटेट किया जाता है: `userdata` पॉइंटर `this` पॉइंटर के रूप में कार्य करता है; कार्य विधियों के रूप में कार्य करते हैं, और `_init()` और `_deinit()` कार्य क्रमशः कंस्ट्रक्टर और डेस्ट्रक्टर के रूप में काम करते हैं।

यह छोटा OOP-in-C जटिलता इसलिए आती है क्योंकि plugins एक मल्टी-थ्रेडेड वातावरण में चलते हैं, और कुछ को स्थिति बनाए रखने की आवश्यकता होती है। आप अपने plugin में उस स्थिति को एक वैश्विक चर में संग्रहीत नहीं कर सकते, इसलिए हम userdata पैरामीटर का उपयोग करते हैं, जो स्वाभाविक रूप से OOP मॉडल की ओर ले जाता है। यदि आपका plugin सरल और अवस्थाहीन है, तो इंटरफ़ेस आपको `_init()`, `_deinit()`, और किसी अन्य कार्यों को छोड़ने की अनुमति देता है।

संक्षेप में, यहाँ केवल तीन लाइनों के C कोड में सबसे सरल पूर्ण रेंकर plugin है:

```c
// gcc -fPIC -shared -o myrank.so myrank.c
#include "sphinxudf.h"
int myrank_ver() { return SPH_UDF_VERSION; }
int myrank_finalize(void *u, int w) { return 123; }
```

यहाँ सरल रेंकर plugin का उपयोग कैसे करें:

```sql
mysql> CREATE PLUGIN myrank TYPE 'ranker' SONAME 'myrank.dll';
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT id, weight() FROM test1 WHERE MATCH('test') OPTION ranker=myrank('');
+------+----------+
| id   | weight() |
+------+----------+
|    1 |      123 |
|    2 |      123 |
+------+----------+
2 rows in set (0.01 sec)
```
<!-- proofread -->

