# एरे तथा शर्तों के फ़ंक्शन

### ALL()
<!-- उदाहरण all_json -->
`ALL(cond FOR var IN json.array)` JSON एरे पर लागू होता है और 1 लौटाता है यदि शर्त एरे के सभी तत्वों के लिए सच है और 0 अन्यथा। `cond` एक सामान्य व्यंजना है जो `var` का उपयोग भी कर सकता है, जो स्वयं के भीतर एक एरे तत्व का वर्तमान मान है।

<!-- JSON के साथ ALL() का अनुरोध -->
```sql
select *, ALL(x>0 AND x<4 FOR x IN j.ar) from tbl
```

<!-- JSON के साथ ALL() का उत्तर -->
```sql
+------+--------------+--------------------------------+
| id   | j            | all(x>0 and x<4 for x in j.ar) |
+------+--------------+--------------------------------+
|    1 | {"ar":[1,3]} |                              1 |
|    2 | {"ar":[3,7]} |                              0 |
+------+--------------+--------------------------------+
2 rows in set (0.00 sec)
```

<!-- JSON उदाहरण 2 के साथ ALL() का अनुरोध -->
```sql
select *, ALL(x>0 AND x<4 FOR x IN j.ar) cond from tbl where cond=1
```

<!-- JSON उदाहरण 2 के साथ ALL() का उत्तर -->
```sql
+------+--------------+------+
| id   | j            | cond |
+------+--------------+------+
|    1 | {"ar":[1,3]} |    1 |
+------+--------------+------+
1 row in set (0.00 sec)
```

<!-- समाप्त -->

<!-- उदाहरण all_mva -->
`ALL(mva)` बहु-मूल्य विशेषताओं के लिए एक विशेष कंस्ट्रक्टर है। जब तुलना ऑपरेटरों (जिसमें `IN()` के साथ तुलना शामिल है) के साथ उपयोग किया जाता है, तो यह 1 लौटाता है यदि MVA विशेषता के सभी मान तुलना किए गए मानों में मिले।

<!-- MVA के साथ ALL() का अनुरोध -->
```sql
select * from tbl where all(m) >= 1
```

<!-- MVA के साथ ALL() का उत्तर -->
```sql
+------+------+
| id   | m    |
+------+------+
|    1 | 1,3  |
|    2 | 3,7  |
+------+------+
2 rows in set (0.00 sec)
```
<!-- MVA और IN() के साथ ALL() का अनुरोध -->
```sql
select * from tbl where all(m) in (1, 3, 7, 10)
```

<!-- MVA और IN() के साथ ALL() का उत्तर -->
```sql
+------+------+
| id   | m    |
+------+------+
|    1 | 1,3  |
|    2 | 3,7  |
+------+------+
2 rows in set (0.00 sec)
```

<!-- समाप्त -->

<!-- उदाहरण all_not_in -->
एक MVA विशेषता की तुलना एक एरे से करने के लिए, `<mva> NOT ALL()` का उपयोग करने से बचें; इसके बजाय `ALL(<mva>) NOT IN()` का उपयोग करें।

<!-- MVA और NOT IN() के साथ ALL() का अनुरोध -->
```sql
select * from tbl where all(m) not in (2, 4)
```

<!-- MVA और NOT IN() के साथ ALL() का उत्तर -->
```sql
+------+------+
| id   | m    |
+------+------+
|    1 | 1,3  |
|    2 | 3,7  |
+------+------+
2 rows in set (0.00 sec)
```

<!-- समाप्त -->


<!-- उदाहरण all_string -->

`ALL(string list)` स्ट्रिंग टैग को फ़िल्टर करने के लिए एक विशेष ऑपरेशन है।

यदि `ALL()` के तर्क के रूप में सूचीबद्ध सभी शब्द विशेषता में मौजूद हैं, तो फ़िल्टर मेल खाता है। वैकल्पिक `NOT` लॉजिक को उलट देता है।

यह फ़िल्टर आंतरिक रूप से डॉक-प्रतिदोक मिलान का उपयोग करता है, इसलिए पूर्ण स्कैन क्वेरी के मामले में, यह अपेक्षा से धीमा हो सकता है। यह उन विशेषताओं के लिए अभिप्रेत है जो अनुक्रमित नहीं हैं, जैसे गणना की गई अभिव्यक्तियाँ या PQ तालिकाओं में टैग। यदि आपको ऐसी फ़िल्टरिंग की आवश्यकता है, तो स्ट्रिंग विशेषता को पूर्ण-पाठ फ़ील्ड के रूप में रखने का समाधान विचार करें, और फिर पूर्ण-पाठ ऑपरेटर `match()` का उपयोग करें, जो पूर्ण-पाठ खोज को सक्रिय करेगा।

<!-- स्ट्रिंग के साथ ALL() का अनुरोध -->
```sql
select * from tbl where tags all('bug', 'release')
```

<!-- स्ट्रिंग के साथ ALL() का उत्तर -->
```
+------+---------------------------+
| id   | tags                      |
+------+---------------------------+
|    1 | bug priority_high release |
|    2 | bug priority_low release  |
+------+---------------------------+
2 rows in set (0.00 sec)
```

<!-- स्ट्रिंग और NOT के साथ ALL() का अनुरोध -->
```sql
mysql> select * from tbl

+------+---------------------------+
| id   | tags                      |
+------+---------------------------+
|    1 | bug priority_high release |
|    2 | bug priority_low release  |
+------+---------------------------+
2 rows in set (0.00 sec)

mysql> select * from tbl where tags not all('bug')

Empty set (0.00 sec)
```
<!-- समाप्त -->

### ANY()

<!-- उदाहरण any_json -->
`ANY(cond FOR var IN json.array)` JSON एरे पर लागू होता है और 1 लौटाता है यदि शर्त किसी भी तत्व के लिए सही है और 0 अन्यथा। `cond` एक सामान्य व्यंजना है जो `var` का उपयोग भी कर सकता है, जो स्वयं के भीतर एक एरे तत्व का वर्तमान मान है।

<!-- JSON के साथ ANY() का अनुरोध -->
```sql
select *, ANY(x>5 AND x<10 FOR x IN j.ar) from tbl
```

<!-- JSON के साथ ANY() का उत्तर -->
```sql
+------+--------------+---------------------------------+
| id   | j            | any(x>5 and x<10 for x in j.ar) |
+------+--------------+---------------------------------+
|    1 | {"ar":[1,3]} |                               0 |
|    2 | {"ar":[3,7]} |                               1 |
+------+--------------+---------------------------------+
2 rows in set (0.00 sec)
```

<!-- JSON उदाहरण 2 के साथ ANY() का अनुरोध -->
```sql
select *, ANY(x>5 AND x<10 FOR x IN j.ar) cond from tbl where cond=1
```

<!-- JSON उदाहरण 2 के साथ ANY() का उत्तर -->
```sql
+------+--------------+------+
| id   | j            | cond |
+------+--------------+------+
|    2 | {"ar":[3,7]} |    1 |
+------+--------------+------+
1 row in set (0.00 sec)
```

<!-- समाप्त -->

<!-- उदाहरण any_mva -->
`ANY(mva)` बहु-मूल्य विशेषताओं के लिए एक विशेष कंस्ट्रक्टर है। जब तुलना ऑपरेटरों (जिसमें `IN()` के साथ तुलना शामिल है) के साथ उपयोग किया जाता है, तो यह 1 लौटाता है यदि MVA मानों में से कोई भी तुलना किए गए मानों में पाया जाता है।

जब एक एरे की तुलना `IN()` के साथ की जाती है, तो यदि अन्यथा निर्दिष्ट नहीं किया गया हो तो स्वचालित रूप से `ANY()` माना जाता है, लेकिन लापता कंस्ट्रक्टर के बारे में एक चेतावनी जारी की जाएगी।

<!-- MVA के साथ ANY() का अनुरोध -->
```sql
mysql> select * from tbl

+------+------+
| id   | m    |
+------+------+
|    1 | 1,3  |
|    2 | 3,7  |
+------+------+
2 पंक्तियाँ सेट में (0.01 सेकंड)

mysql> select * from tbl where any(m) > 5

+------+------+
| id   | m    |
+------+------+
|    2 | 3,7  |
+------+------+
1 पंक्ति सेट में (0.00 सेकंड)
```
<!-- request ANY() with MVA and IN() -->
```sql
select * from tbl where any(m) in (1, 7, 10)
```

<!-- response ANY() with MVA and IN() -->
```sql
+------+------+
| id   | m    |
+------+------+
|    1 | 1,3  |
|    2 | 3,7  |
+------+------+
2 पंक्तियाँ सेट में (0.00 सेकंड)
```

<!-- end -->

<!-- example any_not_in -->
एक MVA विशेषता की तुलना एक श्रेणी के साथ करते समय, `<mva> NOT ANY()` का उपयोग करने से बचें; इसके बजाय `<mva> NOT IN()` या `ANY(<mva>) NOT IN()` का उपयोग करें।

<!-- request ANY() with MVA and NOT IN() -->
```sql
mysql> select * from tbl

+------+------+
| id   | m    |
+------+------+
|    1 | 1,3  |
|    2 | 3,7  |
+------+------+
2 पंक्तियाँ सेट में (0.00 सेकंड)

mysql> select * from tbl where any(m) not in (1, 3, 5)

+------+------+
| id   | m    |
+------+------+
|    2 | 3,7  |
+------+------+
1 पंक्ति सेट में (0.00 सेकंड)
```

<!-- end -->

<!-- example any_string -->

`ANY(string list)` स्ट्रिंग टैग को छानने के लिए एक विशेष संचालन है।

यदि `ANY()` के तर्कों के रूप में निर्दिष्ट किसी भी शब्द को विशेषता में शामिल किया गया है, तो फ़िल्टर मेल खाता है। वैकल्पिक `NOT` तर्क को उलटता है।

यह फ़िल्टर आंतरिक रूप से दस्तावेज़ द्वारा दस्तावेज़ मेलिंग का उपयोग करता है, इसलिए पूर्ण स्कैन क्वेरी के मामले में, यह अपेक्षा से अधिक धीमा हो सकता है। यह उन विशेषताओं के लिए अभिप्रेत है जिन्हें अनुक्रमित नहीं किया गया है, जैसे कि गणना की गई अभिव्यक्तियाँ या PQ तालिकाओं में टैग। यदि आपको ऐसी छंटाई की आवश्यकता है, तो स्ट्रिंग विशेषता को पूर्ण-पाठ क्षेत्र के रूप में रखने का समाधान विचार करें, और फिर पूर्ण-पाठ ऑपरेटर `match()` का उपयोग करें, जो पूर्ण-पाठ खोज को सक्रिय करेगा।

<!-- request ANY() with strings -->
```sql
select * from tbl where tags any('bug', 'feature')
```

<!-- response ANY() with strings -->
```
+------+---------------------------+
| id   | tags                      |
+------+---------------------------+
|    1 | bug priority_high release |
|    2 | bug priority_low release  |
+------+---------------------------+
2 पंक्तियाँ सेट में (0.00 सेकंड)
```

<!-- request ANY() with strings and NOT -->
```sql
select * from tbl
--------------

+------+---------------------------+
| id   | tags                      |
+------+---------------------------+
|    1 | bug priority_high release |
|    2 | bug priority_low release  |
+------+---------------------------+
2 पंक्तियाँ सेट में (0.00 सेकंड)

--------------
select * from tbl where tags not any('feature', 'priority_low')
--------------

+------+---------------------------+
| id   | tags                      |
+------+---------------------------+
|    1 | bug priority_high release |
+------+---------------------------+
1 पंक्ति सेट में (0.01 सेकंड)
```


<!-- end -->

### CONTAINS()

`CONTAINS(polygon, x, y)` जांचता है कि (x,y) बिंदु निर्दिष्ट बहुभुज के भीतर है, और यदि सत्य है तो 1 लौटाता है, अन्यथा 0। बहुभुज को [POLY2D()](../Functions/Geo_spatial_functions.md#POLY2D%28%29) फ़ंक्शन का उपयोग करके निर्दिष्ट किया जाना चाहिए। पूर्ववर्ती फ़ंक्शन "छोटे" बहुभुजों के लिए अभिप्रेत है, अर्थात, 500 किमी (300 मील) की साइड से कम, और यह गति के लिए पृथ्वी की वक्रता का ध्यान नहीं रखता है। बड़े दूरी के लिए, आपको `GEOPOLY2D` का उपयोग करना चाहिए, जो दिए गए बहुभुज को छोटे भागों में विभाजित करता है, पृथ्वी की वक्रता का ध्यान रखते हुए।

### IF()

<!-- example if -->
`IF()` का व्यवहार उसके MySQL समकक्ष से थोड़ा अलग है। यह 3 तर्क लेता है, चाहे 1वां तर्क 0.0 के बराबर है या नहीं, यदि यह जीरो नहीं है तो 2वां तर्क लौटाता है, या जब यह है तो 3रा। ध्यान दें कि तुलना ऑपरेटर की तुलना में, `IF()` **नहीं** एक सीमा का उपयोग करती है! इसलिए, तुलना परिणामों को इसके 1वें तर्क के रूप में सुरक्षित रूप से उपयोग किया जा सकता है, लेकिन अंकगणितीय ऑपरेटर असामान्य परिणाम उत्पन्न कर सकते हैं। उदाहरण के लिए, निम्नलिखित दो कॉल्स *विभिन्न* परिणाम देंगे भले ही वे तार्किक रूप से समकक्ष हों:

<!-- request IF() -->
```sql
IF ( sqrt(3)*sqrt(3)-3<>0, a, b )
IF ( sqrt(3)*sqrt(3)-3, a, b )
```

<!-- end -->

पहले मामले में, तुलना ऑपरेटर <> एक सीमा के कारण 0.0 (गलत) लौटाएगा, और `IF()` हमेशा `**` के रूप में परिणाम लौटाएगा। दूसरे मामले में, वही `sqrt(3)*sqrt(3)-3` अभिव्यक्ति 0 के साथ *बिना* एक सीमा के द्वारा `IF()` फ़ंक्शन द्वारा तुलना की जाएगी। हालाँकि, इसकी मान सीमित तैरती-बिंदु गणना सटीकता के कारण शून्य से थोड़ा भिन्न होगी। इसके कारण, `IF()` द्वारा किया गया 0.0 के साथ तुलना सफल नहीं होगी, और दूसरा संस्करण 'a' के रूप में परिणाम लौटाएगा।

### HISTOGRAM()
<!-- example histogram -->
`HISTOGRAM(expr, {hist_interval=size, hist_offset=value})` एक बाल्टी के आकार को लेता है और मूल्य के लिए बाल्टी नंबर लौटाता है। कुंजी फ़ंक्शन है:
```sql
key_of_the_bucket = interval + offset * floor ( ( value - offset ) / interval )
```
हिस्टोग्राम तर्क `interval` सकारात्मक होना चाहिए। हिस्टोग्राम तर्क `offset` सकारात्मक होना चाहिए और `interval` से कम होना चाहिए। यह समुच्चय, `FACET`, और समूह बनाने में उपयोग किया जाता है।

<!-- intro -->
उदाहरण:

<!-- request HISTOGRAM() -->
```sql
SELECT COUNT(*),
HISTOGRAM(price, {hist_interval=100}) as price_range
FROM facets
GROUP BY price_range ORDER BY price_range ASC;
```
<!-- end -->

### IN()
`IN(expr,val1,val2,...)` 2 या अधिक तर्कों को लेता है और 1 लौटाता है यदि पहला तर्क (expr) अन्य तर्कों (val1..valN) में से किसी के बराबर है, या अन्यथा 0। वर्तमान में, सभी जांचे गए मान (लेकिन स्वयं अभिव्यक्ति नहीं) स्थायी होने की आवश्यकता है। स्थिरांक पहले से क्रमबद्ध होते हैं, और बाइनरी खोज का उपयोग किया जाता है, इसलिए `IN()` बड़े मनमाने स्थिरांक की सूची के खिलाफ भी बहुत तेज़ होगा। पहला तर्क एक MVA विशेषता भी हो सकता है। उस मामले में, `IN()` 1 लौटाएगा यदि कोई MVA मान अन्य तर्कों में से किसी के बराबर है। `IN()` `IN(expr,@uservar)` सिंटैक्स का समर्थन करता है यह जांचने के लिए कि क्या मान दिए गए वैश्विक उपयोगकर्ता चर में सूची में है। पहला तर्क एक JSON विशेषता हो सकता है।

### INDEXOF()
`INDEXOF(cond FOR var IN json.array)` फ़ंक्शन सरणी में सभी तत्वों के माध्यम से बहता है और पहले तत्व का अनुक्रमांक लौटाता है जिसके लिए 'cond' सत्य है, और -1 यदि 'cond' सरणी में हर तत्व के लिए असत्य है।

### INTERVAL()
`INTERVAL(expr,point1,point2,point3,...)` 2 या अधिक तर्कों को लेता है और पहले तर्क से कम के तर्क का अनुक्रमांक लौटाता है: यह 0 लौटाता है यदि `expr<point1`, 1 यदि `point1<=expr<point2`, और इसी तरह। इस फ़ंक्शन के सही ढंग से काम करने के लिए आवश्यक है कि `point1<point2<...<pointN` हो।

### LENGTH()
`LENGTH(attr_mva)` फ़ंक्शन MVA सेट में तत्वों की संख्या लौटाता है। यह 32-बिट और 64-बिट MVA विशेषताओं दोनों के साथ काम करता है। `LENGTH(attr_json)` JSON में एक फ़ील्ड की लंबाई लौटाता है। लौटने वाली मान फ़ील्ड के प्रकार पर निर्भर करती है। उदाहरण के लिए, `LENGTH(json_attr.some_int)` हमेशा 1 लौटाता है, और `LENGTH(json_attr.some_array)` सरणी में तत्वों की संख्या लौटाता है। `LENGTH(string_expr)` फ़ंक्शन एक अभिव्यक्ति से उत्पन्न स्ट्रिंग की लंबाई लौटाता है।
[TO_STRING()](../Functions/Type_casting_functions.md#TO_STRING%28%29) को अभिव्यक्ति को घेरना चाहिए, चाहे अभिव्यक्ति एक गैर-स्ट्रिंग लौटाए या यह बस एक स्ट्रिंग विशेषता हो।

### RANGE()
<!-- example range -->
`RANGE(expr, {range_from=value,range_to=value})` श्रेणियों का एक सेट लेता है और मान के लिए बकेट संख्या लौटाता है।
यह अभिव्यक्ति प्रत्येक श्रेणी के लिए `range_from` मान को शामिल करती है और `range_to` मान को बाहर करती है। एक श्रेणी खुली हो सकती है - केवल `range_from` या केवल `range_to` मान रखना। इसका उपयोग संग्रहण, `FACET`, और समूह बनाने में किया जाता है।

<!-- intro -->
उदाहरण:

<!-- request RANGE() -->
```sql
SELECT COUNT(*),
RANGE(price, {range_to=150},{range_from=150,range_to=300},{range_from=300}) price_range
FROM facets
GROUP BY price_range ORDER BY price_range ASC;
```
<!-- end -->

### REMAP()
<!-- example remap -->
`REMAP(condition, expression, (cond1, cond2, ...), (expr1, expr2, ...))` फ़ंक्शन आपको स्थिति मानों के आधार पर अभिव्यक्ति मानों में कुछ अपवाद बनाने की अनुमति देता है। स्थिति अभिव्यक्ति को हमेशा एक पूर्णांक पर परिणामित करना चाहिए, जबकि अभिव्यक्ति एक पूर्णांक या फ्लोट पर परिणामित हो सकती है।

<!-- intro -->
उदाहरण:

<!-- request REMAP() -->
```sql
SELECT id, size, REMAP(size, 15, (5,6,7,8), (1,1,2,2)) s
FROM products
ORDER BY s ASC;
```
<!-- request Another example -->
```sql
SELECT REMAP(userid, karmapoints, (1, 67), (999, 0)) FROM users;
SELECT REMAP(id%10, salary, (0), (0.0)) FROM employes;
```
<!-- end -->

यह आकार 5 और 6 वाले दस्तावेज़ों को पहले रखेगा, उसके बाद आकार 7 और 8 को। यदि कोई मूल मान जो सूची में नहीं है (जैसे आकार 10), तो इसका डिफ़ॉल्ट मान 15 होगा, और इस मामले में, इसे अंत में रखा जाएगा।


<!-- proofread -->
