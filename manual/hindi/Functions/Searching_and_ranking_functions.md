# खोजने और रैंकिंग फ़ंक्शन
### BM25A()
`BM25A(k1,b)` सही `BM25A()` मान लौटाता है। `expr` रेंकर और सक्षम `index_field_lengths` की आवश्यकता होती है। Parameters `k1` और `b` float होने चाहिए।
### BM25F()
`BM25F(k1, b, {field=weight, ...})` सही `BM25F()` मान लौटाता है और `index_field_lengths` को सक्षम होना आवश्यक है। `expr` रेंकर भी आवश्यक है। Parameters `k1` और `b` float होने चाहिए।
### EXIST()
अनुपस्थित कॉलमों को डिफॉल्ट मानों के साथ प्रतिस्थापित करता है। यह 'attr-name' द्वारा निर्दिष्ट विशेषता का मान लौटाता है, या यदि वह विशेषता मौजूद नहीं है तो 'default-value' लौटाता है। STRING या MVA विशेषताएँ समर्थित नहीं हैं। यह फ़ंक्शन विभिन्न स्कीमाओं वाले कई तालिकाओं के माध्यम से खोजते समय उपयोगी है।
```sql
SELECT *, EXIST('gid', 6) as cnd FROM i1, i2 WHERE cnd>5
```
### MIN_TOP_SORTVAL()
यदि सॉर्ट कुंजी एक float है, तो वर्तमान शीर्ष-N मिलान में सबसे खराब रैंक वाले तत्व की सॉर्ट कुंजी का मान लौटाता है, और अन्यथा 0 लौटाता है।
### MIN_TOP_WEIGHT()
वर्तमान शीर्ष-N मिलान में सबसे खराब रैंक वाले तत्व का वजन लौटाता है।
### PACKEDFACTORS()
`PACKEDFACTORS()` का उपयोग प्रश्नों में सभी गणितीय वजन कारकों को प्रदर्शित करने के लिए किया जा सकता है या कस्टम रैंकिंग UDF बनाने के लिए एक बाइनरी विशेषता प्रदान करने के लिए। यह फ़ंक्शन केवल तभी काम करता है जब एक्सप्रेशन रेंकर निर्दिष्ट किया गया हो और प्रश्न एक पूर्ण स्कैन न हो; अन्यथा, यह एक त्रुटि लौटाता है। `PACKEDFACTORS()` एक वैकल्पिक तर्क ले सकता है जो ATC रैंकिंग कारक की गणना को अक्षम करता है: `PACKEDFACTORS({no_atc=1})`। ATC की गणना करना प्रश्न प्रक्रिया को काफी धीमा कर देता है, इसलिए यह विकल्प तब उपयोगी हो सकता है जब आपको रैंकिंग कारक को देखना हो लेकिन ATC की आवश्यकता न हो। `PACKEDFACTORS()` JSON प्रारूप में भी आउटपुट कर सकता है: `PACKEDFACTORS({json=1})`। कुंजी-मूल्य जोड़ी या JSON प्रारूप में संबंधित आउटपुट नीचे दिखाए गए हैं। (नोट करें कि नीचे दिए गए उदाहरण पढ़ने में आसानी के लिए लपेटे गए हैं; वास्तव में लौटाए गए मान एकल-लाइन होंगे।)
```sql
mysql> SELECT id, PACKEDFACTORS() FROM test1
    -> WHERE MATCH('test one') OPTION ranker=expr('1') \G
*************************** 1\. row ***************************
             id: 1
packedfactors(): bm25=569, bm25a=0.617197, field_mask=2, doc_word_count=2,
    field1=(lcs=1, hit_count=2, word_count=2, tf_idf=0.152356,
        min_idf=-0.062982, max_idf=0.215338, sum_idf=0.152356, min_hit_pos=4,
        min_best_span_pos=4, exact_hit=0, max_window_hits=1, min_gaps=2,
        exact_order=1, lccs=1, wlccs=0.215338, atc=-0.003974),
    word0=(tf=1, idf=-0.062982),
    word1=(tf=1, idf=0.215338)
1 row in set (0.00 sec)
```
```sql
mysql> SELECT id, PACKEDFACTORS({json=1}) FROM test1
    -> WHERE MATCH('test one') OPTION ranker=expr('1') \G
*************************** 1\. row ***************************
                     id: 1
packedfactors({json=1}):
{
    "bm25": 569,
    "bm25a": 0.617197,
    "field_mask": 2,
    "doc_word_count": 2,
    "fields": [
        {
            "lcs": 1,
            "hit_count": 2,
            "word_count": 2,
            "tf_idf": 0.152356,
            "min_idf": -0.062982,
            "max_idf": 0.215338,
            "sum_idf": 0.152356,
            "min_hit_pos": 4,
            "min_best_span_pos": 4,
            "exact_hit": 0,
            "max_window_hits": 1,
            "min_gaps": 2,
            "exact_order": 1,
            "lccs": 1,
            "wlccs": 0.215338,
            "atc": -0.003974
        }
    ],
    "words": [
        {
            "tf": 1,
            "idf": -0.062982
        },
        {
            "tf": 1,
            "idf": 0.215338
        }
    ]
}
1 row in set (0.01 sec)
```
यह फ़ंक्शन UDFs में कस्टम रैंकिंग फ़ंक्शन लागू करने के लिए उपयोग किया जा सकता है, जैसे:
```sql
SELECT *, CUSTOM_RANK(PACKEDFACTORS()) AS r
FROM my_index
WHERE match('hello')
ORDER BY r DESC
OPTION ranker=expr('1');
```
जहाँ `CUSTOM_RANK()` एक फ़ंक्शन है जो UDF में लागू किया गया है। इसे एक `SPH_UDF_FACTORS` संरचना (जो sphinxudf.h में परिभाषित है) घोषित करनी चाहिए, इस संरचना को प्रारंभ करना चाहिए, उपयोग से पहले कारकों को इसमें अनपैक करना चाहिए, और उसके बाद इसे डीइनिशियलाइज़ करना चाहिए, जैसा कि नीचे है:
```sql
SPH_UDF_FACTORS factors;
sphinx_factors_init(&factors);
sphinx_factors_unpack((DWORD*)args->arg_values[0], &factors);
// ... यहाँ factors चर की सामग्री का उपयोग कर सकते हैं ...
sphinx_factors_deinit(&factors);
```
`PACKEDFACTORS()` डेटा सभी प्रश्न चरणों में उपलब्ध है, न कि केवल प्रारंभिक मिलान और रैंकिंग पास के दौरान। यह `PACKEDFACTORS()` के एक विशेष रूप से दिलचस्प अनुप्रयोग को सक्षम बनाता है: फिर से रैंकिंग।
उपरोक्त उदाहरण में, हमने एक एक्सप्रेशन-आधारित रेंकर का उपयोग किया है जिसमें एक डमी एक्सप्रेशन है और परिणाम सेट को हमारे UDF द्वारा गणना किए गए मान के अनुसार क्रमबद्ध किया है। दूसरे शब्दों में, हमने सभी परिणामों को रैंक करने के लिए UDF का उपयोग किया। अब, मान लेते हैं कि हमारे उदाहरण के लिए हमारा UDF अत्यधिक महंगा है, प्रति सेकंड केवल 10,000 कॉल का थ्रूपुट है। यदि हमारा प्रश्न 1,000,000 दस्तावेज़ों से मेल खाता है, तो हम समुचित प्रदर्शन बनाए रखने के लिए हमारी रैंकिंग का अधिकांश भाग करने के लिए एक बहुत सरल एक्सप्रेशन का उपयोग करना चाहेंगे। फिर, हम केवल शीर्ष 100 परिणामों पर महंगे UDF लागू करेंगे। दूसरे शब्दों में, हम एक सरल रैंकिंग फ़ंक्शन का उपयोग करके शीर्ष 100 परिणाम विकसित करेंगे और फिर उन पर एक अधिक जटिल फ़ंक्शन के साथ पुनः रैंक करेंगे। इसे सबसेलेक्ट के साथ किया जा सकता है:
```sql
SELECT * FROM (
    SELECT *, CUSTOM_RANK(PACKEDFACTORS()) AS r
    FROM my_index WHERE match('hello')
    OPTION ranker=expr('sum(lcs)*1000+bm25')
    ORDER BY WEIGHT() DESC
    LIMIT 100
) ORDER BY r DESC LIMIT 10
```
इस उदाहरण में, अभिव्यक्ति-आधारित रैंकिंग को हर मेल खाती दस्तावेज़ के लिए `WEIGHT()` की गणना करने के लिए बुलाया जाता है, इसलिए इसे 1,000,000 बार बुलाया जाता है। हालाँकि, UDF गणना को बाहरी क्रम तक स्थगित किया जा सकता है, और इसे केवल `WEIGHT()` द्वारा शीर्ष 100 मेल के लिए प्रदर्शन किया जाएगा, आंतरिक सीमा के अनुसार। इसका मतलब है कि UDF केवल 100 बार बुलाया जाएगा। अंततः, UDF मान द्वारा शीर्ष 10 मेल को चुना जाता है और अनुप्रयोग में वापस किया जाता है।

संदर्भ के लिए, एक वितरित सेटअप में, `PACKEDFACTORS()` डेटा एजेंटों से मास्टर नोड पर बाइनरी प्रारूप में भेजा जाता है। यदि आवश्यक हो, तो मास्टर नोड पर अतिरिक्त रिइंकार्नेशन पास लागू करना तकनीकी रूप से संभव बनाता है।

SQL में उपयोग किए जाने पर लेकिन किसी भी UDF द्वारा कॉल नहीं किए जाने पर, `PACKEDFACTORS()` का परिणाम साधारण पाठ के रूप में स्वरूपित होता है, जिसे रैंकिंग कारकों का मैन्युअल मूल्यांकन करने के लिए उपयोग किया जा सकता है। ध्यान दें कि यह सुविधा वर्तमान में Manticore API द्वारा समर्थन नहीं की जाती है।


### REMOVE_REPEATS()
`REMOVE_REPEATS ( result_set, column, offset, limit )` - समान 'column' मान के साथ दोहराए गए समायोजित पंक्तियों को हटाता है।

```sql
SELECT REMOVE_REPEATS((SELECT * FROM dist1), gid, 0, 10)
```
ध्यान दें कि `REMOVE_REPEATS` [खोज प्रश्न मेटा जानकारी](../../Node_info_and_management/SHOW_META.md#SHOW-META) में `total_found` को प्रभावित नहीं करता है।

### WEIGHT()
`WEIGHT()` फ़ंक्शन गणना की गई मेलिंग स्कोर लौटाता है। यदि कोई क्रम निर्दिष्ट नहीं किया गया है, तो परिणाम को `WEIGHT()` द्वारा प्रदान किए गए स्कोर के अनुसार अवरोही क्रम में क्रमबद्ध किया जाता है। इस उदाहरण में, हम सबसे पहले वजन द्वारा और फिर किसी पूर्णांक विशेषता द्वारा क्रमबद्ध करते हैं।

उपरोक्त खोज एक सरल मेलिंग करती है, जहाँ सभी शब्दों का उपस्थित होना जरूरी है। हालाँकि, हम और अधिक कर सकते हैं ( और यह बस एक साधारण उदाहरण है):

```sql
mysql> SELECT *,WEIGHT() FROM testrt WHERE MATCH('"list of business laptops"/3');
+------+------+-------------------------------------+---------------------------+----------+
| id   | gid  | title                               | content                   | weight() |
+------+------+-------------------------------------+---------------------------+----------+
|    1 |   10 | List of HP business laptops         | Elitebook Probook         |     2397 |
|    2 |   10 | List of Dell business laptops       | Latitude Precision Vostro |     2397 |
|    3 |   20 | List of Dell gaming laptops         | Inspirion Alienware       |     2375 |
|    5 |   30 | List of ASUS ultrabooks and laptops | Zenbook Vivobook          |     2375 |
+------+------+-------------------------------------+---------------------------+----------+
4 पंक्तियाँ सेट (0.00 सेकंड)


mysql> SHOW META;
+----------------+----------+
| Variable_name  | Value    |
+----------------+----------+
| total          | 4        |
| total_found    | 4        |
| total_relation | eq       |
| time           | 0.000    |
| keyword[0]     | list     |
| docs[0]        | 5        |
| hits[0]        | 5        |
| keyword[1]     | of       |
| docs[1]        | 4        |
| hits[1]        | 4        |
| keyword[2]     | business |
| docs[2]        | 2        |
| hits[2]        | 2        |
| keyword[3]     | laptops  |
| docs[3]        | 5        |
| hits[3]        | 5        |
+----------------+----------+
16 पंक्तियाँ सेट (0.00 सेकंड)
```

यहाँ, हम चार शब्दों के लिए खोज करते हैं, लेकिन मेल तब भी हो सकता है जब केवल चार में से तीन शब्द पाए जाएं। खोज उन दस्तावेजों को उच्च रैंक करेगी जिनमें सभी शब्द उपस्थित हैं।

### ZONESPANLIST()
`ZONESPANLIST()` फ़ंक्शन मेल खाते ज़ोन स्पैन के जोड़े लौटाता है। प्रत्येक जोड़े में मेल खाता हुआ ज़ोन स्पैन पहचानकर्ता, एक कॉलन और मेल खाती ज़ोन स्पैन का क्रम संख्या शामिल होती है। उदाहरण के लिए, यदि एक दस्तावेज़ पढ़ता है `<emphasis role="bold"><i>text</i> the <i>text</i></emphasis>` और आप `'ZONESPAN:(i,b) text'` के लिए क्वेरी करते हैं, तो `ZONESPANLIST()` स्ट्रिंग `"1:1 1:2 2:1"` लौटाएगा, जिसका अर्थ है कि पहला ज़ोन स्पैन "text" को स्पैन 1 और 2 में मेल खाता है, और दूसरा ज़ोन स्पैन केवल स्पैन 1 में।

### QUERY()
`QUERY()` वर्तमान खोज प्रश्न लौटाता है। `QUERY()` एक पोस्टलिमिट अभिव्यक्ति है और इसे [SNIPPET()](../Functions/String_functions.md#SNIPPET%28%29) के साथ उपयोग के लिए अभिप्रेत है।

तालिका कार्य एक पोस्ट-प्रश्न परिणाम सेट प्रसंस्करण का एक तंत्र है। तालिका कार्य किसी मनमाने परिणाम सेट को इनपुट के रूप में लेते हैं और एक नया, संसाधित सेट आउटपुट के रूप में लौटाते हैं। पहला तर्क इनपुट परिणाम सेट होना चाहिए, लेकिन तालिका कार्य वैकल्पिक रूप से अधिक तर्क ले सकते हैं और हैंडल कर सकते हैं। तालिका कार्य पूरी तरह से परिणाम सेट को बदल सकते हैं, जिसमें स्कीमा भी शामिल है। वर्तमान में, केवल अंतर्निर्मित तालिका कार्यों को समर्थन किया जाता है। तालिका कार्य बाहरी `SELECT` और [नैस्टेड SELECT](../Searching/Sub-selects.md) दोनों के लिए कार्य करते हैं।

<!-- proofread -->



















