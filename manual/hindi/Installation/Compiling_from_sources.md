# Manticore को स्रोत से संकलित करना

Manticore Search को स्रोतों से संकलित करने से कस्टम बिल्ड कॉन्फ़िगरेशन सक्षम होता है, जैसे कि कुछ सुविधाओं को निष्क्रिय करना या परीक्षण के लिए नए पैच जोड़ना। उदाहरण के लिए, आप स्रोतों से संकलित करना चाह सकते हैं और एम्बेडेड ICU को निष्क्रिय करना चाह सकते हैं ताकि आप एक अलग संस्करण का उपयोग कर सकें जो आपके सिस्टम पर स्वायत्त रूप से अपडेट किया जा सके। यदि आप Manticore Search प्रोजेक्ट में योगदान देने में रुचि रखते हैं, तो यह भी उपयोगी है।

## CI Docker का उपयोग करके निर्माण
[आधिकारिक रिलीज़ और विकास पैकेज](https://repo.manticoresearch.com/) तैयार करने के लिए, हम Docker और एक विशेष बिल्डिंग इमेज का उपयोग करते हैं। यह इमेज आवश्यक उपकरणों को शामिल करती है और इसे बाहरी सिस्टम रूट्स के साथ उपयोग के लिए डिज़ाइन किया गया है, इसलिए एक कंटेनर सभी ऑपरेटिंग सिस्टम के लिए पैकेज बना सकता है। आप [Dockerfile](https://github.com/manticoresoftware/manticoresearch/blob/master/dist/build_dockers/cross/external_toolchain/Dockerfile) और [README](https://github.com/manticoresoftware/manticoresearch/blob/master/dist/build_dockers/README.md) का उपयोग करके इमेज बना सकते हैं या [Docker Hub](https://hub.docker.com/r/manticoresearch/external_toolchain/tags) से इमेज का उपयोग कर सकते हैं। यह किसी भी समर्थित ऑपरेटिंग सिस्टम और आर्किटेक्चर के लिए बाइनरी बनाने का सबसे आसान तरीका है। कंटेनर चलाते समय आपको निम्नलिखित पर्यावरण चर निर्दिष्ट करने की भी आवश्यकता होगी:

* `DISTR`: लक्षित प्लेटफ़ॉर्म: `bionic`, `focal`, `jammy`, `buster`, `bullseye`, `bookworm`, `rhel7`, `rhel8`, `rhel9`, `macos`, `windows`, `freebsd13`
* `arch`: आर्किटेक्चर: `x86_64`, `x64` (Windows के लिए), `aarch64`, `arm64` (Macos के लिए)
* `SYSROOT_URL`: सिस्टम रूट्स आर्काइव के लिए URL। आप https://repo.manticoresearch.com/repository/sysroots का उपयोग कर सकते हैं जब तक कि आप स्वयं सिस्टम रूट्स का निर्माण नहीं कर रहे हैं (निर्देश [यहां](https://github.com/manticoresoftware/manticoresearch/tree/master/dist/build_dockers/cross/sysroots) पाए जा सकते हैं)।
* अन्य पर्यावरण चर खोजने के लिए CI वर्कफ़्लो फ़ाइलों का संदर्भ के रूप में उपयोग करें जो आपको उपयोग करने की आवश्यकता हो सकती है:
  - https://github.com/manticoresoftware/manticoresearch/blob/master/.github/workflows/pack_publish.yml
  - https://github.com/manticoresoftware/manticoresearch/blob/master/.github/workflows/build_template.yml

`DISTR` और `arch` के लिए संभावित मानों को खोजने के लिए, आप निर्देशिका https://repo.manticoresearch.com/repository/sysroots/roots_with_zstd/ का उपयोग कर सकते हैं, क्योंकि इसमें सभी समर्थित संयोजनों के लिए सिस्टम रूट्स शामिल हैं।

इसके बाद, Docker कंटेनर के अंदर पैकेज बनाना बस ऐसा कहने जितना आसान है:

```bash
cmake -DPACK=1 /path/to/sources
cmake --build .
```

उदाहरण के लिए, Ubuntu Jammy के लिए एक पैकेज बनाने के लिए जो आधिकारिक संस्करण Manticore Core Team प्रदान करता है, आपको Manticore Search स्रोतों वाली निर्देशिका में निम्नलिखित कमांड निष्पादित करना चाहिए। यह निर्देशिका https://github.com/manticoresoftware/manticoresearch से क्लोन किए गए रिपॉजिटरी की जड़ है:

```bash
docker run -it --rm \
-e CACHEB="../cache" \
-e DIAGNOSTIC=1 \
-e PACK_ICUDATA=0 \
-e NO_TESTS=1 \
-e DISTR=jammy \
-e boost=boost_nov22 \
-e sysroot=roots_nov22 \
-e arch=x86_64 \
-e CTEST_CMAKE_GENERATOR=Ninja \
-e CTEST_CONFIGURATION_TYPE=RelWithDebInfo \
-e WITH_COVERAGE=0 \
-e SYSROOT_URL="https://repo.manticoresearch.com/repository/sysroots" \
-e HOMEBREW_PREFIX="" \
-e PACK_GALERA=0 \
-e UNITY_BUILD=1 \
-v $(pwd):/manticore_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \
manticoresearch/external_toolchain:vcpkg331_20250114 bash

# following is to be run inside docker shell
cd /manticore_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/
mkdir build && cd build
cmake -DPACK=1 ..
export CMAKE_TOOLCHAIN_FILE=$(pwd)/dist/build_dockers/cross/linux.cmake
cmake --build .
# or if you want to build packages:
# cmake --build . --target package
```
लंबा स्रोत निर्देशिका पथ आवश्यक है अन्यथा यह कुछ मामलों (जैसे Centos) में स्रोतों का निर्माण करने में असफल हो सकता है।

समान प्रक्रिया का उपयोग बाइनरी/पैकेज बनाने के लिए किया जा सकता है केवल लोकप्रिय लिनक्स वितरणों के लिए नहीं, बल्कि FreeBSD, Windows और macOS के लिए भी।

## मैन्युअल रूप से निर्माण

बिल्डिंग Docker का उपयोग किए बिना Manticore को संकलित करना **सिफारिश की जाती है नहीं**, लेकिन यदि आपको इसे करना है, तो यहाँ वह जानकारी है जो आपको जानना हो सकता है:

### आवश्यक उपकरण

* C++ कंपाइलर
  * लिनक्स में - GNU (4.7.2 और ऊपर) या Clang का उपयोग किया जा सकता है
  * विंडोज में - Microsoft Visual Studio 2019 और ऊपर (कम्युनिटी संस्करण काफी है)
  * macOS पर - Clang (XCode के कमांड लाइन टूल से, इंस्टॉल करने के लिए `xcode-select --install` का उपयोग करें)।
* Bison, Flex - अधिकांश सिस्टम पर, ये पैकेज के रूप में उपलब्ध हैं, विंडोज पर ये cygwin फ्रेमवर्क में उपलब्ध हैं।
* Cmake - सभी प्लेटफार्मों पर उपयोग किया जाता है (संकरण 3.19 या ऊपर आवश्यक है)

### स्रोत प्राप्त करना

#### गिट से

Manticore स्रोत कोड [GitHub पर होस्ट किया गया है](https://github.com/manticoresoftware/manticoresearch).   
स्रोत कोड प्राप्त करने के लिए, रिपॉजिटरी को क्लोन करें और फिर इच्छित शाखा या टैग चेकआउट करें। शाखा `master` मुख्य विकास शाखा का प्रतिनिधित्व करती है। रिलीज़ पर, एक संस्करणित टैग बनाया जाता है, जैसे `3.6.0` और वर्तमान रिलीज़ के लिए एक नई शाखा शुरू की जाती है, इस मामले में `manticore-3.6.0`। सभी परिवर्तनों के बाद संस्करणित शाखा का हेड सभी बाइनरी रिलीज़ बनाने के लिए स्रोत के रूप में उपयोग किया जाता है। उदाहरण के लिए, संस्करण 3.6.0 के स्रोत लेने के लिए आप निम्नलिखित चला सकते हैं:

```bash
git clone https://github.com/manticoresoftware/manticoresearch.git
cd manticoresearch
git checkout manticore-3.6.0
```

#### आर्काइव से

आप GitHub से "Download ZIP" बटन का उपयोग करके इच्छित कोड डाउनलोड कर सकते हैं। दोनों .zip और .tar.gz प्रारूप उपयुक्त हैं।

```bash
wget -c https://github.com/manticoresoftware/manticoresearch/archive/refs/tags/3.6.0.tar.gz
tar -zxf 3.6.0.tar.gz
cd manticoresearch-3.6.0
```

### कॉन्फ़िगर करना

Manticore CMake का उपयोग करता है। मान लीजिए कि आप क्लोन की गई रिपॉजिटरी के रूट निदेशिका में हैं:

```bash
mkdir build && cd build
cmake ..
```

CMake उपलब्ध सुविधाओं की जांच करेगा और उनके अनुसार निर्माण को कॉन्फ़िगर करेगा। डिफ़ॉल्ट रूप से, सभी सुविधाएँ सक्षम मानी जाती हैं यदि वे उपलब्ध हैं। स्क्रिप्ट कुछ बाहरी पुस्तकालयों को डाउनलोड और निर्माण भी करती है, यह मानते हुए कि आप उनका उपयोग करना चाहते हैं। अचेतन रूप से, आपको अधिकतम संख्या में सुविधाओं के लिए समर्थन मिलता है।

आप फ्लैग और विकल्पों के साथ निर्माण को स्पष्ट रूप से भी कॉन्फ़िगर कर सकते हैं। सुविधा `FOO` को सक्षम करने के लिए CMake कॉल में `-DFOO=1` जोड़ें।
इसे निष्क्रिय करने के लिए, `-DFOO=0` का उपयोग करें। यदि विशेष रूप से नोट नहीं किया गया है, तो किसी ऐसी सुविधा को सक्षम करना जो उपलब्ध नहीं है (जैसे MS Windows बिल्ड पर `WITH_GALERA`) कॉन्फ़िगरेशन को एक त्रुटि के साथ विफल करेगा। किसी सुविधा को निष्क्रिय करना, न केवल इसे निर्माण से बाहर करने से राहत देता है, बल्कि सिस्टम पर इसकी जांच को भी निष्क्रिय करता है और किसी भी संबंधित बाहरी पुस्तकालयों के डाउनलोड/निर्माण को निष्क्रिय करता है।

#### कॉन्फ़िगरेशन फ्लैग और विकल्प

- **USE_SYSLOG** - [प्रश्न लॉगिंग](Logging/Query_logging.md) में `syslog` के उपयोग की अनुमति देता है।
- **WITH_GALERA** - खोज डेमन पर प्रतिकृति के लिए समर्थन सक्षम करता है। निर्माण के लिए समर्थन कॉन्फ़िगर किया जाएगा, और गैलेरा लाइब्रेरी के स्रोत डाउनलोड किए जाएंगे, बनाए जाएंगे और वितरण/स्थापना में शामिल किए जाएंगे। आमतौर पर, गैलेरा के साथ बनाना सुरक्षित होता है, लेकिन लाइब्रेरी को खुद वितरित नहीं करना (इसलिए कोई गैलेरा मॉड्यूल, कोई प्रतिकृति नहीं)। हालांकि, कभी-कभी आपको इसे स्पष्ट रूप से निष्क्रिय करने की आवश्यकता हो सकती है, जैसे कि यदि आप एक स्थिर बाइनरी बनाना चाहते हैं जो डिज़ाइन के अनुसार कोई लाइब्रेरी लोड नहीं कर सकती है, ताकि डेमन के अंदर 'dlopen' फ़ंक्शन को बुलाने की उपस्थिति भी लिंक त्रुटि का कारण बने।
- **WITH_RE2** - RE2 नियमित अभिव्यक्ति लाइब्रेरी के उपयोग के साथ निर्माण करता है। यह [REGEX()](../Functions/String_functions.md#REGEX%28%29) जैसी फ़ंक्शन के लिए आवश्यक है, और [regexp_filter](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#regexp_filter)
  सुविधा के लिए।
- **WITH_RE2_FORCE_STATIC** - RE2 के स्रोत डाउनलोड करता है, उन्हें संकलित करता है, और उन्हें स्थैतिक रूप से लिंक करता है, ताकि अंतिम बाइनरी आपके सिस्टम में साझा `RE2` लाइब्रेरी की उपस्थिति पर निर्भर न हो।
- **WITH_STEMMER** - स्नोबॉल स्टेमिंग लाइब्रेरी के उपयोग के साथ निर्माण करता है।
- **WITH_STEMMER_FORCE_STATIC** - स्नोबॉल स्रोतों को डाउनलोड करता है, उन्हें संकलित करता है, और उन्हें स्थैतिक रूप से लिंक करता है, ताकि अंतिम बाइनरी आपके सिस्टम में साझा `libstemmer` लाइब्रेरी की उपस्थिति पर निर्भर न हो।
- **WITH_ICU** - ICU (अंतर्राष्ट्रीय यूनिकोड के लिए घटक) लाइब्रेरी के साथ निर्माण करता है। इसका उपयोग चीनी पाठ को विभाजित करने के लिए किया जाता है। इसका उपयोग किया जाता है जब morphology=`icu_chinese` का उपयोग किया जाता है।
- **WITH_JIEBA** - जिएबा चीनी पाठ विभाजन उपकरण के साथ निर्माण करता है। इसका उपयोग चीनी पाठ को विभाजित करने के लिए किया जाता है। इसका उपयोग किया जाता है जब morphology=`jieba_chinese` का उपयोग किया जाता है।
- **WITH_ICU_FORCE_STATIC** - ICU के स्रोत डाउनलोड करता है, उन्हें संकलित करता है, और उन्हें स्थैतिक रूप से लिंक करता है, ताकि अंतिम बाइनरी आपके सिस्टम में साझा `icu` लाइब्रेरी की उपस्थिति पर निर्भर न हो। स्थापना/वितरण में ICU डेटा फ़ाइल भी शामिल होती है। एक स्थैतिक रूप से लिंक किया गया ICU का उद्देश्य ज्ञात संस्करण की एक लाइब्रेरी होना है, ताकि व्यवहार निर्धारित हो और किसी भी सिस्टम लाइब्रेरी पर निर्भर न हो। आप शायद इसके बजाय सिस्टम ICU का उपयोग करना पसंद करेंगे, क्योंकि इसे समय-समय पर अपडेट किया जा सकता है बिना Manticore डेमन को फिर से संकलित किए। इस मामले में, आपको स्पष्ट रूप से इस विकल्प को अनिष्क्रिय करना होगा। इससे ICU डेटा फ़ाइल द्वारा कब्जा की गई कुछ जगह भी बचाई जा सकती है (लगभग 30M), क्योंकि यह वितरण में शामिल नहीं होगी।
- **WITH_SSL** - HTTPS के लिए समर्थन और डेमन के लिए एन्क्रिप्टेड MySQL कनेक्शन के लिए उपयोग किया जाता है। सिस्टम OpenSSL लाइब्रेरी को डेमन से लिंक किया जाएगा। इसका अर्थ है कि डेमन को शुरू करने के लिए OpenSSL की आवश्यकता होगी। यह HTTPS के लिए समर्थन के लिए अनिवार्य है, लेकिन सर्वर के लिए सख्ती से अनिवार्य नहीं है (अर्थात, कोई SSL का अर्थ HTTPS के माध्यम से कनेक्ट करने की संभावना नहीं है, लेकिन अन्य प्रोटोकॉल काम करेंगे)। SSL लाइब्रेरी के संस्करण 1.0.2 से 1.1.1 का उपयोग Manticore द्वारा किया जा सकता है, हालांकि ध्यान दें कि **सुरक्षा के दृष्टिकोण से, नवीनतम संभव SSL 
  लाइब्रेरी का उपयोग करने की अत्यधिक अनुशंसा की जाती है**। फिलहाल केवल v1.1.1 समर्थित है, बाकी पुराने हैं (
  देखें [openssl release strategy](https://www.openssl.org/policies/releasestrat.html)
- **WITH_ZLIB** - इन्क्सर द्वारा MySQL से संविवर्धित कॉलम के साथ काम करने के लिए उपयोग किया जाता है। डेमन द्वारा संविवर्धित MySQL प्रोटोकॉल के लिए समर्थन प्रदान करने के लिए उपयोग किया जाता है।
- **WITH_ODBC** - ODBC प्रदाताओं (जो आमतौर पर UnixODBC और iODBC होते हैं) से इंडेक्सिंग स्रोतों का समर्थन करने के लिए इन्क्सर द्वारा उपयोग किया जाता है। MS Windows पर, ODBC MS SQL स्रोतों के साथ काम करने का सही तरीका है, इसलिए `MSSQL` की इंडेक्सिंग भी इस ध्वज का संकेत देती है।
- **DL_ODBC** - ODBC लाइब्रेरी के साथ लिंक न करें। यदि ODBC लिंक किया गया है, लेकिन उपलब्ध नहीं है, तो आप इन्क्सर टूल को शुरू नहीं कर सकते, भले ही आप कुछ ऐसा संसाधित करना चाहते हों जो ODBC से संबंधित न हो। यह विकल्प इन्क्सर से अनुरोध करता है कि वह केवल तभी लाइब्रेरी को चलाने के समय लोड करे जब आप ODBC स्रोत से निपटना चाहते हों।
- **ODBC_LIB** - ODBC लाइब्रेरी फ़ाइल का नाम। इंडेक्सर उस फ़ाइल को लोड करने की कोशिश करेगा जब आप ODBC स्रोत को संसाधित करना चाहते हैं। यह विकल्प उपलब्ध ODBC साझा लाइब्रेरी की जांच से स्वचालित रूप से लिखा जाता है। आप रन टाइम पर वैकल्पिक लाइब्रेरी के लिए सही पथ के साथ पर्यावरण चर `ODBC_LIB` प्रदान करके उस नाम को ओवरराइट भी कर सकते हैं।
- **WITH_EXPAT** - XMLPipe स्रोतों की इंडेक्सिंग का समर्थन करने के लिए इन्क्सर द्वारा उपयोग किया जाता है।
- **DL_EXPAT** - EXPAT लाइब्रेरी के साथ लिंक न करें। यदि EXPAT लिंक किया गया है, लेकिन उपलब्ध नहीं है, तो आप `indexer` टूल को शुरू नहीं कर सकते, भले ही आप कुछ ऐसा संसाधित करना चाहते हों जो XMLPipe से संबंधित न हो। यह विकल्प इन्क्सर से अनुरोध करता है कि वह केवल तभी लाइब्रेरी को चलाने के समय लोड करे जब आप XMLPipe स्रोत से निपटना चाहते हों।
- **EXPAT_LIB** - EXPAT लाइब्रेरी फ़ाइल का नाम। इंडेक्सर उस फ़ाइल को लोड करने की कोशिश करेगा जब आप XMLPipe स्रोत को संसाधित करना चाहते हैं। यह विकल्प उपलब्ध EXPAT साझा लाइब्रेरी की जांच से स्वचालित रूप से लिखा जाता है। आप रन टाइम पर वैकल्पिक लाइब्रेरी के लिए सही पथ के साथ पर्यावरण चर `EXPAT_LIB` प्रदान करके उस नाम को ओवरराइट भी कर सकते हैं।
- **WITH_ICONV** - XMLPipe स्रोतों की इंडेक्सिंग करते समय विभिन्न एन्कोडिंग का समर्थन करने के लिए।
- **DL_ICONV** - iconv लाइब्रेरी के साथ लिंक न करें। यदि iconv लिंक किया गया है, लेकिन उपलब्ध नहीं है, तो आप `indexer` टूल को शुरू नहीं कर सकते, भले ही आप कुछ ऐसा संसाधित करना चाहते हों जो XMLPipe से संबंधित न हो। यह विकल्प इन्क्सर से अनुरोध करता है कि वह केवल तभी लाइब्रेरी को चलाने के समय लोड करे जब आप XMLPipe स्रोत से निपटना चाहते हों।
- **ICONV_LIB** - iconv लाइब्रेरी फ़ाइल का नाम। इंडेक्सर उस फ़ाइल को लोड करने की कोशिश करेगा जब आप XMLPipe स्रोत को संसाधित करना चाहते हैं। यह विकल्प उपलब्ध iconv साझा लाइब्रेरी की जांच से स्वचालित रूप से लिखा जाता है। आप रन टाइम पर वैकल्पिक लाइब्रेरी के लिए सही पथ के साथ पर्यावरण चर `ICONV_LIB` प्रदान करके उस नाम को ओवरराइट भी कर सकते हैं।
- **WITH_MYSQL** - MySQL स्रोतों की इंडेक्सिंग का समर्थन करने के लिए इन्क्सर द्वारा उपयोग किया जाता है।
- **DL_MYSQL** - MySQL पुस्तकालय से लिंक न करें। यदि MySQL लिंक किया गया है, लेकिन उपलब्ध नहीं है, तो आप`indexer` उपकरण शुरू नहीं कर सकते, भले ही आप कुछ ऐसा प्रोसेस करना चाहते हों जो MySQL से संबंधित न हो। यह विकल्प indexer से runtime पर पुस्तकालय को लोड करने के लिए कहता है केवल जब आप MySQL स्रोत से निपटना चाहते हैं।
- **MYSQL_LIB** -- MySQL पुस्तकालय फ़ाइल का नाम। जब आप MySQL स्रोत को प्रोसेस करना चाहते हैं, तो indexer उस फ़ाइल को लोड करने की कोशिश करेगा। यह विकल्प उपलब्ध MySQL साझा पुस्तकालय जांच से स्वचालित रूप से लिखा जाता है। आप indexer चलाने से पहले वैकल्पिक पुस्तकालय के लिए सही पथ प्रदान करके runtime पर उस नाम को ओवरराइड भी कर सकते हैं।
- **WITH_POSTGRESQL** - PostgreSQL स्रोतों का अनुक्रमण समर्थन करने के लिए indexer द्वारा उपयोग किया जाता है।
- **DL_POSTGRESQL** - PostgreSQL पुस्तकालय से लिंक न करें। यदि PostgreSQL लिंक किया गया है, लेकिन उपलब्ध नहीं है, तो आप`indexer` उपकरण शुरू नहीं कर सकते, भले ही आप कुछ ऐसा प्रोसेस करना चाहते हों जो PostgreSQL से संबंधित न हो। यह विकल्प indexer से runtime पर पुस्तकालय को लोड करने के लिए कहता है केवल जब आप PostgreSQL स्रोत से निपटना चाहते हैं।
- **POSTGRESQL_LIB** - PostgreSQL पुस्तकालय फ़ाइल का नाम। PostgreSQL स्रोत को प्रोसेस करते समय indexer निर्दिष्ट PostgreSQL पुस्तकालय फ़ाइल को लोड करने का प्रयास करेगा। यह विकल्प उपलब्ध PostgreSQL साझा पुस्तकालय जांच से स्वचालित रूप से निर्धारित किया जाता है। आप indexer चलाने से पहले वैकल्पिक पुस्तकालय के लिए सही पथ प्रदान करके runtime पर नाम को ओवरराइड भी कर सकते हैं।
- **LOCALDATADIR** - डिफ़ॉल्ट पथ जहां डेमॉन बिनलॉग को संग्रहीत करता है। यदि यह पथ प्रदान नहीं किया गया है या डेमॉन की runtime कॉन्फ़िगरेशन में स्पष्ट रूप से अक्षम किया गया है (जैसे `manticore.conf` फ़ाइल, जो इस निर्माण कॉन्फ़िगरेशन से संबंधित नहीं है), तो बिनलॉग इस पथ में रखे जाएंगे। यह आमतौर पर एक पूर्ण पथ होता है, हालांकि, यह आवश्यक नहीं है और सापेक्ष पथ भी उपयोग किए जा सकते हैं। आप शायद कॉन्फ़िगरेशन द्वारा निर्धारित डिफ़ॉल्ट मान को बदलने की आवश्यकता नहीं महसूस करेंगे, जो लक्ष्य प्रणाली के आधार पर, कुछ ऐसा हो सकता है जैसे `/var/data`, `/var/lib/manticore/data`, या `/usr/local/var/lib/manticore/data`।
- **FULL_SHARE_DIR** - डिफ़ॉल्ट पथ जहां सभी संपत्तियाँ संग्रहीत होती हैं। इसे किसी भी उपकरण को आरंभ करने से पहले पर्यावरण चर `FULL_SHARE_DIR` द्वारा ओवरराइड किया जा सकता है जो उस फ़ोल्डर से फ़ाइलों का उपयोग करता है। यह एक महत्वपूर्ण पथ है क्योंकि वहाँ डिफ़ॉल्ट रूप से कई चीजों की अपेक्षा की जाती है। इनमें पूर्वनिर्धारित कैरेक्टर सेट तालिकाएँ, स्टॉपवर्ड, manticore मॉड्यूल, और icu डेटा फ़ाइलें शामिल हैं, जो सभी उस फ़ोल्डर में रखी जाती हैं। कॉन्फ़िगरेशन स्क्रिप्ट आमतौर पर इस पथ को कुछ ऐसे निर्धारित करती है जैसे `/usr/share/manticore`, या `/usr/local/share/manticore`।
- **DISTR_BUILD** - पैकेज जारी करने के विकल्पों के लिए एक शोर्टकट। यह लक्ष्य प्लेटफ़ॉर्म के नाम के साथ एक स्ट्रिंग वैल्यू है। इसका उपयोग सभी विकल्पों को मैन्युअल रूप से कॉन्फ़िगर करने के बजाय किया जा सकता है। डेबियन और रेडहैट लिनक्स पर, डिफ़ॉल्ट मान हल्के अंतरदृष्टि द्वारा निर्धारित किया जा सकता है और इसे सामान्य 'Debian' या 'RHEL' पर सेट किया जा सकता है। अन्यथा, मान परिभाषित नहीं है।
- **PACK** - एक और अधिक सुविधाजनक शोर्टकट। यह `DISTR` पर्यावरण चर को पढ़ता है, इसे **DISTR_BUILD** पैरामीटर में असाइन करता है, और फिर सामान्य रूप से कार्य करता है। यह तैयार निर्माण प्रणालियों में निर्माण करते समय, जैसे Docker कंटेनरों में, बहुत उपयोगी है, जहां `DISTR` चर सिस्टम स्तर पर सेट होता है और उस कंटेनर के लिए लक्षित प्रणाली को दर्शाता है जिसके लिए इसे डिजाइन किया गया है।
- **CMAKE_INSTALL_PREFIX** (पथ) - जहाँ Manticore स्थापित होने की अपेक्षा की जाती है। निर्माण कोई स्थापना नहीं करता है, लेकिन यह स्थापना नियमों को तैयार करता है जो आप जब `cmake --install` कमांड चलाते हैं या पैकेज बनाते हैं और फिर उसे स्थापित करते हैं, तब कार्यान्वित किए जाते हैं। पूर्वनिर्धारण को किसी भी समय बदला जा सकता है, यहां तक कि स्थापना के दौरान भी, निम्नलिखित द्वारा
  `cmake --install . --prefix /path/to/installation`। हालांकि, कॉन्फ़िगरेशन समय पर, इस चर का उपयोग `LOCALDATADIR` और `FULL_SHARE_DIR` के डिफ़ॉल्ट मानों को प्रारंभ करने के लिए किया जाता है। उदाहरण के लिए, यदि आप इसे कॉन्फ़िगर करते समय `/my/custom` पर सेट करते हैं
  तो यह `LOCALDATADIR` को `/my/custom/var/lib/manticore/data` के रूप में हार्डकोड करेगा, और `FULL_SHARE_DIR` को
  `/my/custom/usr/share/manticore` के रूप में।
- **BUILD_TESTING** (bool) परीक्षण समर्थन के लिए। यदि सक्षम किया गया है, तो निर्माण के बाद आप 'ctest' चला सकते हैं और निर्माण का परीक्षण कर सकते हैं। ध्यान दें कि परीक्षण का अर्थ है अतिरिक्त निर्भरता, जैसे कि PHP cli, Python, और एक परीक्षण डेटाबेस के साथ उपलब्ध MySQL सर्वर। डिफ़ॉल्ट रूप से, यह पैरामीटर चालू होता है। इसलिए, 'केवल निर्माण' के लिए, आप विकल्प को 'off' मान को स्पष्ट रूप से निर्दिष्ट करके अक्षम करना चाह सकते हैं।
- **LIBS_BUNDLE** - विभिन्न पुस्तकालयों के साथ फ़ोल्डर का पथ। यह ज्यादातर Windows निर्माण के लिए प्रासंगिक है, लेकिन यदि आपको अक्सर निर्माण करना है कि हर बार तृतीय-पार्टी स्रोतों को डाउनलोड करने से बचने के लिए यह भी सहायक हो सकता है। डिफ़ॉल्ट रूप से, यह पथ कॉन्फ़िगरेशन स्क्रिप्ट द्वारा कभी संशोधित नहीं किया जाता है; आपको वहां मैन्युअल रूप से सब कुछ रखना चाहिए। जब, मान लीजिए, हम एक स्टेमर के लिए समर्थन चाहते हैं - स्रोत Snowball होमपेज से डाउनलोड किए जाएंगे, फिर निकाले जाएंगे, कॉन्फ़िगर किए जाएंगे, बनाए जाएंगे, आदि। इसके बजाय, आप इस फ़ोल्डर में मूल स्रोत टैर्बॉल (जो `libstemmer_c.tgz` है) को संग्रहीत कर सकते हैं। अगली बार जब आप प्रारंभ से निर्माण करना चाहते हैं, तो कॉन्फ़िगरेशन स्क्रिप्ट पहले बंडल में देखेगी, और यदि यह वहां स्टेमर पाती है, तो यह फिर से इंटरनेट से डाउनलोड नहीं करेगी।
- **CACHEB** - 3-रे पार्टी पुस्तकालयों के संग्रहीत निर्माणों के साथ फ़ोल्डर का पथ। आमतौर पर, जैसे galera, re2, icu आदि जैसी विशेषताएँ पहले डाउनलोड की जाती हैं या बंडल से प्राप्त की जाती हैं, फिर निकाली जाती हैं, बनाई जाती हैं, और एक अस्थायी आंतरिक फ़ोल्डर में स्थापित की जाती हैं। जब manticore का निर्माण करते समय, वह फ़ोल्डर तब आवश्यक चीज़ों के लिए उपयोग किया जाता है जो अनुरोध किए गए विशेषता का समर्थन करते हैं। अंततः, वे या तो manticore के साथ लिंक करते हैं, यदि यह एक पुस्तकालय है; या सीधे वितरण/स्थापना के लिए जाते हैं (जैसे galera या icu डेटा)। जब **CACHEB** को या तो cmake कॉन्फ़िग पैरामीटर के रूप में परिभाषित किया जाता है, या एक प्रणाली पर्यावरण चर के रूप में, इसे उस निर्माणों के लक्ष्य फ़ोल्डर के रूप में उपयोग किया जाता है। यह फ़ोल्डर निर्माणों के बीच बनाए रखा जा सकता है, ताकि वहां संग्रहीत पुस्तकालय फिर से निर्मित न हों, जिससे पूरे निर्माण प्रक्रिया को बहुत छोटा बनाया जा सके।


नोट करें कि कुछ विकल्प त्रिक में व्यवस्थित हैं: `WITH_XXX`, `DL_XXX` और `XXX_LIB` - जैसे mysql, odbc आदि का समर्थन। `WITH_XXX` निर्धारित करता है कि अगले दो का प्रभाव होगा या नहीं। यानी, यदि आप `WITH_ODBC` को `0` पर सेट करते हैं - तो `DL_ODBC` और `ODBC_LIB` प्रदान करने का कोई अर्थ नहीं है, और ये दोनों कोई प्रभाव नहीं डालेंगे यदि पूरी सुविधा अक्षम है। साथ ही, `XXX_LIB` का कोई अर्थ नहीं है बिना `DL_XXX` के, क्योंकि यदि आप `DL_XXX` विकल्प नहीं चाहते, तो डायनेमिक लोडिंग का उपयोग नहीं किया जाएगा, और `XXX_LIB` द्वारा प्रदान किया गया नाम बेकार होगा। यह डिफ़ॉल्ट अंतर्निरीक्षण द्वारा उपयोग किया जाता है।

साथ ही, `iconv` लाइब्रेरी का उपयोग `expat` को मानता है और बेकार है यदि अंतिम अक्षम है।

इसके अलावा, कुछ लाइब्रेरियां हमेशा उपलब्ध हो सकती हैं, और इसलिए, उनके साथ लिंकेज से बचने का कोई अर्थ नहीं है। उदाहरण के लिए, Windows में वह ODBC है। macOS में वह Expat, iconv, और हो सकता है अन्य। डिफ़ॉल्ट अंतर्निरीक्षण ऐसी लाइब्रेरियों को निर्धारित करता है और प्रभावी रूप से केवल `WITH_XXX` को उत्सर्जित करता है, बिना `DL_XXX` और `XXX_LIB` के, जो चीजों को सरल बनाता है।

कुछ विकल्पों के साथ गेम कॉन्फ़िगरेशन इस प्रकार दिख सकता है:

```bash
mkdir build && cd build
cmake -DWITH_MYSQL=1 -DWITH_RE2=1 ..
```

सामान्य कॉन्फ़िगरेशन मूल्यों के अलावा, आप `CMakeCache.txt` फ़ाइल की भी जांच कर सकते हैं जो बिल्ड फ़ोल्डर में कॉन्फ़िगरेशन चलाने के तुरंत बाद छोड़ दी जाती है। वहां परिभाषित कोई भी मान को स्पष्ट रूप से पुनर्परिभाषित किया जा सकता है जब cmake चलाया जाता है। उदाहरण के लिए, आप `cmake -DHAVE_GETADDRINFO_A=FALSE ...` चला सकते हैं, और वह कॉन्फ़िग रन उस चर के जांचे गए मान को नहीं मानेगा, बल्कि आपके द्वारा प्रदान किए गए मान का उपयोग करेगा।

#### विशिष्ट पर्यावरण चर

पर्यावरण चर बिल्ड कॉन्फ़िगरेशन से अलग संग्रहीत किए जाने वाले किसी प्रकार के वैश्विक सेटिंग्स प्रदान करने के लिए उपयोगी होते हैं। स्थायित्व के लिए, उन्हें विभिन्न तरीकों से सिस्टम पर वैश्विक रूप से सेट किया जा सकता है - जैसे `.bashrc` फ़ाइल में जोड़ना, या Dockerfile में एम्बेड करना यदि आप Docker-आधारित बिल्ड सिस्टम तैयार कर रहे हैं, या Windows में सिस्टम प्राथमिकताओं के पर्यावरण चर लिखना। साथ ही, आप उन्हें शेल में `export VAR=value` का उपयोग करके अल्पकालिक रूप से सेट कर सकते हैं। या और भी छोटा, cmake कॉल से पहले मूल्य जोड़कर, जैसे `CACHEB=/my/cache cmake ...` - इस तरह यह केवल इस कॉल पर काम करेगा और अगली बार दिखाई नहीं देगा।

कुछ ऐसे चर हैं जिन्हें सामान्य रूप से cmake और कुछ अन्य टूल्स द्वारा उपयोग किया जाता है। ये ऐसी चीजें हैं जैसे `CXX` जो वर्तमान C++ कंपाइलर को निर्धारित करता है, या कंपाइलर फ्लैग्स प्रदान करने के लिए `CXX_FLAGS`, आदि।

हालांकि, हमारे पास कुछ चर हैं जो विशेष रूप से मंटिकोर कॉन्फ़िगरेशन के लिए हैं, जो केवल हमारी बिल्ड के लिए बनाए गए हैं।

- **CACHEB** - कॉन्फ़िग **CACHEB** विकल्प के समान
- **LIBS_BUNDLE** - कॉन्फ़िग **LIBS_BUNDLE** विकल्प के समान
- **DISTR** - `-DPACK=1` का उपयोग किए जाने पर `DISTR_BUILD` विकल्प को आरंभ करने के लिए उपयोग किया जाता है।
- **DIAGNOSTIC** - cmake कॉन्फ़िगरेशन के आउटपुट को बहुत अधिक विस्तृत बनाता है, जो सब कुछ समझाता है
- **WRITEB** - **LIBS_BUNDLE** को मान लेता है और, यदि सेट किया जाता है, तो विभिन्न टूल्स के लिए स्रोत संग्रह फ़ाइलों को LIBS_BUNDLE फ़ोल्डर में डाउनलोड करेगा। यानी, यदि स्टेमर का ताजा संस्करण आता है - तो आप मैन्युअल रूप से libstemmer_c.tgz को बंडल से हटा सकते हैं और फिर एक बार के लिए `WRITEB=1 cmake ...` चला सकते हैं - यह स्टेमर के स्रोतों को बंडल में नहीं ढूंढेगा और फिर उन्हें विक्रेता की साइट से बंडल में डाउनलोड करेगा (WRITEB के बिना यह उन्हें बिल्ड फ़ोल्डर के अंदर अस्थायी फ़ोल्डर में डाउनलोड करेगा और जब आप बिल्ड फ़ोल्डर को मिटाएंगे तो वे गायब हो जाएंगे)।

कॉन्फ़िगरेशन के अंत में, आप इस तरह की सूची में देख सकते हैं कि क्या उपलब्ध है और उपयोग किया जाएगा:

```
-- Enabled features compiled in:
* Galera, replication of tables
* re2, a regular expression library
* stemmer, stemming library (Snowball)
* icu, International Components for Unicode
* OpenSSL, for encrypted networking
* ZLIB, for compressed data and networking
* ODBC, for indexing MSSQL (windows) and generic ODBC sources with indexer
* EXPAT, for indexing xmlpipe sources with indexer
* Iconv, for support of different encodings when indexing xmlpipe sources with indexer
* MySQL, for indexing MySQL sources with indexer
* PostgreSQL, for indexing PostgreSQL sources with indexer
```

### बिल्डिंग

```bash
cmake --build . --config RelWithDebInfo
```

### इंस्टॉलेशन

इंस्टॉल करने के लिए चलाएं:

```bash
cmake --install . --config RelWithDebInfo
```

कस्टम (डिफ़ॉल्ट से अलग) फ़ोल्डर में इंस्टॉल करने के लिए, चलाएं

```bash
cmake --install . --prefix path/to/build --config RelWithDebInfo
```

### पैकेज बनाना

पैकेज बनाने के लिए, `package` टारगेट का उपयोग करें। यह `-DDISTR_BUILD` विकल्प द्वारा प्रदान किए गए चयन के अनुसार पैकेज बनाएगा। डिफ़ॉल्ट रूप से, यह सभी बाइनरी और पूरक फ़ाइलों के साथ एक सरल .zip या .tgz संग्रह होगा।

```bash
cmake --build . --target package --config RelWithDebInfo
```

## बिल्डिंग के बारे में कुछ उन्नत चीजें

### पुनर्संकलन (अपडेट) एकल-कॉन्फ़िग पर

यदि आपने स्रोतों और बिल्ड के लिए पथ नहीं बदला है, तो बस अपने बिल्ड फ़ोल्डर में जाएं और चलाएं:

```bash
cmake .
cmake --build . --clean-first --config RelWithDebInfo
```

यदि किसी कारण से यह काम नहीं करता है, तो आप बिल्ड फ़ोल्डर में स्थित `CMakeCache.txt` फ़ाइल को हटा सकते हैं। इस चरण के बाद आपको
फिर से cmake चलाना होगा, स्रोत फ़ोल्डर की ओर इंगित करते हुए और विकल्पों को कॉन्फ़िगर करते हुए।

यदि यह भी मदद नहीं करता है, तो बस अपना बिल्ड फ़ोल्डर साफ़ कर दें और शुरू से शुरू करें।

### बिल्ड प्रकार

संक्षेप में - बस ऊपर लिखे अनुसार `--config RelWithDebInfo` का उपयोग करें। यह कोई गलती नहीं करेगा।

हम दो बिल्ड प्रकारों का उपयोग करते हैं। विकास के लिए, यह `Debug` है - यह कंपाइलर फ्लैग्स को इस तरह से असाइन करता है कि वह विकास के लिए बहुत अनुकूल हो, जिसका अर्थ है कि डीबग रन क्रम-दर-क्रम निष्पादन के साथ होता है। हालांकि, उत्पादित बाइनरी उत्पादन के लिए काफी बड़े और धीमे होते हैं।

रिलीज के लिए, हम एक और प्रकार का उपयोग करते हैं - `RelWithDebInfo` - जिसका अर्थ है 'डीबग जानकारी के साथ रिलीज बिल्ड'। यह डीबग जानकारी के साथ उत्पादन बाइनरी उत्पन्न करता है। बाद में इसे अलग डीबगइन्फो पैकेजों में विभाजित किया जाता है जो रिलीज पैकेजों के साथ संग्रहीत होते हैं और किसी प्रकार की समस्याओं जैसे क्रैश के मामले में जांच और बग-फिक्सिंग के लिए उपयोग किए जा सकते हैं। Cmake `Release` और `MinSizeRel` भी प्रदान करता है, लेकिन हम उनका उपयोग नहीं करते। यदि बिल्ड प्रकार उपलब्ध नहीं है, तो cmake एक `noconfig` बिल्ड बनाएगा।

#### बिल्ड सिस्टम जेनरेटर

दो प्रकार के जेनरेटर होते हैं: एकल-कॉन्फ़िग और बहु-कॉन्फ़िग।

- एकल-कॉन्फ़िग को कॉन्फ़िगरेशन के दौरान बिल्ड प्रकार प्रदान करने की आवश्यकता होती है, `CMAKE_BUILD_TYPE` पैरामीटर के माध्यम से। यदि यह परिभाषित नहीं है, तो बिल्ड `RelWithDebInfo` प्रकार में गिर जाएगा जो उपयुक्त है यदि आप बस स्रोतों से मंटिकोर बनाना चाहते हैं और विकास में भाग नहीं लेना चाहते। स्पष्ट बिल्ड के लिए, आपको एक बिल्ड प्रकार प्रदान करना चाहिए, जैसे `-DCMAKE_BUILD_TYPE=Debug`।
- बहु-कॉन्फ़िग बिल्ड के दौरान बिल्ड प्रकार का चयन करता है। इसे `--config` विकल्प के साथ प्रदान किया जाना चाहिए, अन्यथा यह एक प्रकार के `noconfig` का निर्माण करेगा, जो वांछनीय नहीं है। इसलिए, आपको हमेशा बिल्ड प्रकार निर्दिष्ट करना चाहिए, जैसे `--config Debug`।

यदि आप निर्माण प्रकार निर्दिष्ट करना चाहते हैं लेकिन इस बात की परवाह नहीं करते कि यह 'सिंगल' है या 'मल्टी' कॉन्फ़िग जेनरेटर है - तो बस दोनों स्थानों पर आवश्यक कुंजी प्रदान करें। उदाहरण के लिए, `-DCMAKE_BUILD_TYPE=Debug` के साथ कॉन्फ़िगर करें, और फिर `--config Debug` के साथ निर्माण करें। बस यह सुनिश्चित करें कि दोनों मान समान हैं। यदि टार्गेट बिल्डर एक सिंगल-कॉन्फ़िग है, तो यह कॉन्फ़िगरेशन पैराम खपत करेगा। यदि यह मल्टी-कॉन्फ़िग है, तो कॉन्फिगरेशन पैराम को नज़रअंदाज कर दिया जाएगा, लेकिन सही निर्माण कॉन्फ़िगरेशन का चयन `--config` कुंजी द्वारा किया जाएगा।

यदि आप `RelWithDebInfo` चाहते हैं (अर्थात सिर्फ उत्पादन के लिए निर्माण करना) और जानते हैं कि आप एक सिंगल-कॉन्फ़िग प्लेटफ़ॉर्म पर हैं (यह सब कुछ, सिवाय विंडोज़ के) - आप cmake अनुक्रमण पर `--config` फ्लैग छोड़ सकते हैं। फिर डिफॉल्ट `CMAKE_BUILD_TYPE=RelWithDebInfo` कॉन्फ़िगर और उपयोग किया जाएगा। 'निर्माण', 'संस्थापन' और 'निर्माण पैकेज' के सभी आदेश तब छोटे बन जाएंगे।

#### निर्माण प्रणाली जेनरेटर को स्पष्ट रूप से चुनें

Cmake वह उपकरण है जो खुद निर्माण नहीं करता, बल्कि यह स्थानीय निर्माण प्रणाली के लिए नियम उत्पन्न करता है।
आमतौर पर, यह उपलब्ध निर्माण प्रणाली को अच्छी तरह से निर्धारित करता है, लेकिन कभी-कभी आपको एक जेनरेटर स्पष्ट रूप से प्रदान करने की आवश्यकता हो सकती है। आप
`cmake -G` चला सकते हैं और उपलब्ध जेनरेटर की सूची की समीक्षा कर सकते हैं।

- विंडोज़ पर, यदि आपने एक से अधिक संस्करण के विजुअल स्टूडियो स्थापित किए हैं, तो आपको यह निर्दिष्ट करने की आवश्यकता हो सकती है कि कौन सा उपयोग करना है,
जैसे:
```bash
cmake -G "Visual Studio 16 2019" ....
  ```
- On all other platforms - usually Unix Makefiles are used, but you can specify another one, such as Ninja, or Ninja Multi-Config, as:
  Multi-Config`, as:
```bash
  cmake -GNinja ...
  ```
  या
```bash
  cmake -G"Ninja Multi-Config" ...
```
निंजा मल्टी-कॉन्फ़िग काफी उपयोगी है क्योंकि यह वास्तव में 'मल्टी-कॉन्फ़िग' है और यह Linux/macOS/BSD पर उपलब्ध है। इस जेनरेटर के साथ, आप कॉन्फिगरेशन प्रकार का चयन निर्माण समय पर कर सकते हैं, और इसके अलावा आप एक ही निर्माण फ़ोल्डर में कई कॉन्फ़िगरेशनों का निर्माण कर सकते हैं, केवल `--config` पैराम बदलकर।

### चेतावनियाँ

1. यदि आप अंततः एक पूर्ण विशेषता वाला RPM पैकेज बनाना चाहते हैं, तो निर्माण निर्देशिका का पथ पर्याप्त लंबा होना चाहिए ताकि सही तरीके से डीबग प्रतीक बन सके।
जैसे `/manticore012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789`, उदाहरण के लिए। ऐसा इसलिए है क्योंकि RPM उपकरण डीबग जानकारी बनाते समय संकलित बाइनरी पर पथ को संशोधित करते हैं, और यह केवल मौजूदा कमरे पर लिख सकता है और अधिक आवंटित नहीं करेगा। उपरोक्त लंबा पथ 100 अक्षर है और यह ऐसे मामले के लिए पर्याप्त है।

## बाहरी निर्भरताएँ

कुछ पुस्तकालय उपलब्ध होने चाहिए यदि आप उनका उपयोग करना चाहते हैं।
- अनुक्रमण के लिए (`indexer` उपकरण): `expat`, `iconv`, `mysql`, `odbc`, `postgresql`। इनके बिना, आप केवल `tsv` और `csv` स्रोतों को संसाधित कर सकते हैं।
- प्रश्न सेवा (`searchd` डेमॉन) के लिए: `openssl` आवश्यक हो सकता है।
- सभी के लिए (आवश्यक, अनिवार्य!) हमें बूस्ट पुस्तकालय की आवश्यकता है। न्यूनतम संस्करण 1.61.0 है, हालांकि, हम अधिक ताज़े संस्करण 1.75.0 के साथ बाइनरी बनाते हैं। और भी नए संस्करण (जैसे 1.76) भी ठीक होने चाहिए। विंडोज़ पर, आप प्री-बिल्ट बूस्ट उनकी साइट (boost.org) से डाउनलोड कर सकते हैं और इसे डिफॉल्ट सुझाए गए पथ में स्थापित कर सकते हैं (उदाहरण के लिए `C:\\boost...`)। MacOs पर, ब्रू में प्रदान किया गया ठीक है। Linux पर, आप आधिकारिक भंडारों में उपलब्ध संस्करण की जांच कर सकते हैं, और यदि यह आवश्यकताओं से मेल नहीं खाता, तो आप स्रोतों से निर्माण कर सकते हैं। हमें 'context' घटक की आवश्यकता है, आप 'system' और 'program_options' घटकों का भी निर्माण कर सकते हैं, वे आवश्यक होंगे यदि आप गलेरा लाइब्रेरी को स्रोतों से भी निर्माण करना चाहते हैं। `dist/build_dockers/xxx/boost_175/Dockerfile` में एक छोटा आत्म-दस्तावेज़ित स्क्रिप्ट/निर्देश देखें कि इसे कैसे करना है।

निर्माण प्रणाली पर, आपको 'dev' या 'devel' संस्करण की इन पैकेजों को स्थापित करने की आवश्यकता है (उदाहरण के लिए - libmysqlclient-devel, unixodbc-devel, आदि। हमारे डोकरफाइल में विशेष पैकेजों के नाम देखें)।

सिस्टम चलाने पर, ये पैकेज कम से कम अंतिम (गैर-विकास) वेरिएंट में मौजूद होने चाहिए। (विकास वेरिएंट आमतौर पर बड़े होते हैं, क्योंकि वे केवल लक्ष्य बाइनरी को ही नहीं, बल्कि विभिन्न विकास सामग्री जैसे हेडर शामिल, आदि को भी शामिल करते हैं)।

### विंडोज़ पर निर्माण

आवश्यक पूर्व आवश्यकताओं के अलावा, आपको प्रीबिल्ट `expat`, `iconv`, `mysql`, और `postgresql` क्लाइंट लाइब्रेरी की आवश्यकता हो सकती है। आपको या तो उन्हें स्वयं निर्माण करना होगा या हमारे निर्माण बंडल को प्राप्त करने के लिए हमसे संपर्क करना होगा (एक साधारण ज़िप आर्काइव जिसमें लक्ष्यों के साथ फोल्डर स्थित है)।

- ODBC आवश्यक नहीं है क्योंकि यह एक system लाइब्रेरी है।
- OpenSSL स्रोतों से निर्मित किया जा सकता है या https://slproweb.com/products/Win32OpenSSL.html से प्रीबिल्ट डाउनलोड किया जा सकता है (जैसा कि cmake आंतरिक स्क्रिप्ट FindOpenSSL में उल्लिखित है)।
- बूस्ट को https://www.boost.org/ रिलीज़ से प्री-बिल्ट डाउनलोड किया जा सकता है।

### देखें कि क्या संकलित है

`indexer -h` चलाएँ। यह दिखाएगा कि कौन सी विशेषताएँ कॉन्फ़िगर और संकलित की गईं (चाहे वे स्पष्ट हों या जांची गई हों, इससे फर्क नहीं पड़ता):

```
Built on Linux x86_64 by GNU 8.3.1 compiler.

Configured with these definitions: -DDISTR_BUILD=rhel8 -DUSE_SYSLOG=1 -DWITH_GALERA=1 -DWITH_RE2=1 -DWITH_RE2_FORCE_STATIC=1
-DWITH_STEMMER=1 -DWITH_STEMMER_FORCE_STATIC=1 -DWITH_ICU=1 -DWITH_ICU_FORCE_STATIC=1 -DWITH_SSL=1 -DWITH_ZLIB=1 -DWITH_ODBC=1 -DDL_ODBC=1
-DODBC_LIB=libodbc.so.2 -DWITH_EXPAT=1 -DDL_EXPAT=1 -DEXPAT_LIB=libexpat.so.1 -DWITH_ICONV=1 -DWITH_MYSQL=1 -DDL_MYSQL=1
-DMYSQL_LIB=libmariadb.so.3 -DWITH_POSTGRESQL=1 -DDL_POSTGRESQL=1 -DPOSTGRESQL_LIB=libpq.so.5 -DLOCALDATADIR=/var/lib/manticore/data
-DFULL_SHARE_DIR=/usr/share/manticore
```
<!-- proofread -->
