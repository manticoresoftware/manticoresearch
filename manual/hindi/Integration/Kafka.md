# Kafka से समन्वय करना

> नोट: इस कार्यक्षमता के लिए [Manticore Buddy](../Installation/Manticore_Buddy.md) की आवश्यकता होती है। यदि यह काम नहीं करता है, तो सुनिश्चित करें कि Buddy स्थापित है।

Manticore Search सहजता से Kafka ब्रोकर से संदेशों का उपभोग कर सकता है, जिससे वास्तविक समय में डेटा अनुक्रमण और खोज की अनुमति मिलती है।

शुरू करने के लिए, आपको यह करने की आवश्यकता है:
1. **स्रोत को परिभाषित करें:** उस Kafka विषय को निर्दिष्ट करें जिससे Manticore Search संदेश पढ़ेगा। इस सेटअप में ब्रोकर के होस्ट, पोर्ट, और विषय नाम जैसे विवरण शामिल हैं।
2. **गंतव्य तालिका सेट करें:** आने वाले Kafka डेटा को स्टोर करने के लिए Manticore वास्तविक समय तालिका चुनें।
3. **एक भौतिकीकृत दृश्य बनाएँ:** डेटा परिवर्तन और Kafka से Manticore Search में गंतव्य तालिका के लिए मैपिंग को संभालने के लिए एक भौतिकीकृत दृश्य (`mv`) सेट करें। यहाँ, आप फ़ील्ड मैपिंग, डेटा परिवर्तन, और आने वाले डेटा स्ट्रीम के लिए किसी भी फ़िल्टर या शर्तों को परिभाषित करेंगे।

## स्रोत

<!-- example kafka_source -->

`source` कॉन्फ़िगरेशन आपको `broker`, `topic list`, `consumer group`, और संदेश संरचना को परिभाषित करने की अनुमति देता है।

#### स्कीमा

Manticore फ़ील्ड प्रकारों जैसे `int`, `float`, `text`, `json`, आदि का उपयोग करके स्कीमा को परिभाषित करें।

```sql
CREATE SOURCE <source name> [(column type, ...)] [source_options]
```

सभी स्कीमा की कुंजी केस-संवेदनशीलता के बिना होती है, अर्थात् `Products`, `products`, और `PrOdUcTs` एक समान होती हैं। सभी छोटे अक्षरों में परिवर्तित होते हैं।

यदि आपके फ़ील्ड नाम Manticore Search में अनुमत [फ़ील्ड नाम सिंटैक्स](../../Creating_a_table/Data_types.md#Field-name-syntax) से मेल नहीं खाते हैं (उदाहरण के लिए, यदि उनमें विशेष वर्ण हैं या संख्या से शुरू होते हैं), तो आपको एक स्कीमा मैपिंग परिभाषित करनी होगी। उदाहरण के लिए, `$keyName` या `123field` JSON में मान्य कुंजी हैं लेकिन Manticore Search में मान्य फ़ील्ड नाम नहीं हैं। यदि आप उचित मैपिंग के बिना अमान्य फ़ील्ड नामों का उपयोग करने का प्रयास करते हैं, तो Manticore एक त्रुटि लौटाएगा और स्रोत निर्माण विफल हो जाएगा।

ऐसी स्थितियों को संभालने के लिए, अमान्य फ़ील्ड नामों को मान्य नामों पर मैप करने के लिए निम्नलिखित स्कीमा सिंटैक्स का उपयोग करें:

```
allowed_field_name 'original JSON key name with special symbols' type
```

उदाहरण के लिए:
```sql
price_field '$price' float    -- JSON कुंजी '$price' को फ़ील्ड 'price_field' पर मैप करता है
field_123 '123field' text     -- JSON कुंजी '123field' को फ़ील्ड 'field_123' पर मैप करता है
```
<!-- intro -->

##### SQL:

<!-- request SQL -->

```sql
CREATE SOURCE kafka
(id bigint, term text, abbrev '$abbrev' text, GlossDef json)
type='kafka'
broker_list='kafka:9092'
topic_list='my-data'
consumer_group='manticore'
num_consumers='2'
batch=50
```

<!-- response -->

```
Query OK, 2 rows affected (0.02 sec)
```

<!-- end -->

#### विकल्प

| विकल्प | स्वीकार्य मान | विवरण |
|-|-|-|
| `type` | `kafka` | स्रोत प्रकार सेट करता है। वर्तमान में, केवल `kafka` का समर्थन किया गया है |
| `broker_list` | `host:port [, ...]` | Kafka ब्रोकर URLs निर्दिष्ट करता है |
| `topic_list` | `string [, ...]` | उपभोग के लिए Kafka विषयों की सूची बनाता है |
| `consumer_group`| `string` | Kafka उपभोक्ता समूह को परिभाषित करता है, जिसका माप deault पर `manticore` होता है। |
| `num_consumers` | `int` | संदेशों को संभालने के लिए उपभोक्ताओं की संख्या। |
| `batch` | `int` | आगे बढ़ने से पहले संसाधित करने के लिए संदेशों की संख्या। डिफ़ॉल्ट `100` है; अन्यथा समय समाप्त होने पर शेष संदेशों को संसाधित करता है |

### गंतव्य तालिका

<!-- example kafka_destination -->

गंतव्य तालिका एक नियमित वास्तविक समय तालिका है जहाँ Kafka संदेश प्रसंस्करण के परिणामों को संग्रहित किया जाता है। इस तालिका को आने वाले डेटा की स्कीमा आवश्यकताओं के अनुसार परिभाषित किया जाना चाहिए और आपके एप्लिकेशन की क्वेरी प्रदर्शन आवश्यकताओं के लिए अनुकूलित किया जाना चाहिए। वास्तविक समय तालिकाओं को बनाने के बारे में और अधिक पढ़ें [यहाँ](../Creating_a_table/Local_tables/Real-time_table.md#Creating-a-real-time-table:)।

<!-- intro -->

##### SQL:

<!-- request SQL -->

```sql
CREATE TABLE destination_kafka
(id bigint, name text, short_name text, received_at text, size multi);
```

<!-- response -->

```
Query OK, 0 rows affected (0.02 sec)
```

<!-- end -->

### भौतिकीकृत दृश्य

<!-- example kafka_mv -->

एक भौतिकीकृत दृश्य Kafka संदेशों से डेटा परिवर्तन की सुविधा प्रदान करता है। आप फ़ील्ड के नाम बदल सकते हैं, Manticore Search कार्यों को लागू कर सकते हैं, और क्रमबद्ध, समूहबद्ध, और अन्य डेटा संचालन कर सकते हैं।

एक भौतिकीकृत दृश्य एक क्वेरी के रूप में कार्य करता है जो डेटा को Kafka स्रोत से गंतव्य तालिका में स्थानांतरित करता है, जिससे आप इन क्वेरियों को अनुकूलित करने के लिए Manticore Search सिंटैक्स का उपयोग कर सकते हैं। सुनिश्चित करें कि `select` में फ़ील्ड स्रोत में उन से मेल खाते हैं।

```
CREATE MATERIALIZED VIEW <materialized view name>
TO <destination table name> AS
SELECT [column|function [as <new name>], ...] FROM <source name>
```

<!-- intro -->

##### SQL:

<!-- request SQL -->

```sql
CREATE MATERIALIZED VIEW view_table
TO destination_kafka AS
SELECT id, term as name, abbrev as short_name,
       UTC_TIMESTAMP() as received_at, GlossDef.size as size FROM kafka

```

<!-- response -->

```sql
Query OK, 2 rows affected (0.02 sec)
```

<!-- end -->

डेटा Kafka से Manticore Search में बैचों में स्थानांतरित किया जाता है, जो प्रत्येक चलन के बाद साफ़ किए जाते हैं। बैचों के बीच गणनाओं के लिए, जैसे AVG, सतर्क रहें, क्योंकि ये बैच-दर-बैच प्रसंस्करण के कारण अपेक्षा के अनुसार काम नहीं कर सकते हैं।


### फ़ील्ड मैपिंग

यहाँ उदाहरणों के आधार पर एक मैपिंग तालिका है:

| Kafka           | स्रोत   | बफ़र   | एमवी                                | गंतव्य |
|-----------------|----------|----------|-----------------------------------|-------------|
| `id`              | `id`       | `id`       | `id`                                | `id`          |
| `term`            | `term`     | `term`     | `term as name`                      | `name`        |
| `unnecessary_key` which we're not interested in | -        | -        |                                   |             |
| `$abbrev`         | `abbrev`   | `abbrev`   | `abbrev` as `short_name`              | `short_name`  |
| -                 | -        | -         | `UTC_TIMESTAMP() as received_at`  | `received_at` |
| `GlossDef`        | `glossdef` | `glossdef` | `glossdef.size as size`             | `size`        |

### सूचीकरण

<!-- example kafka_listing -->

Manticore Search में स्रोतों और मेटेरियलाइज्ड व्यूज़ को देखने के लिए, इन कमांड्स का उपयोग करें:
- `SHOW SOURCES`: सभी कॉन्फ़िगर किए गए स्रोतों की सूची बनाता है।
- `SHOW MVS`: सभी मेटेरियलाइज्ड व्यूज़ की सूची बनाता है।
- `SHOW MV view_table`: एक विशेष मेटेरियलाइज्ड व्यू पर विस्तृत जानकारी दिखाता है।

<!-- intro -->

##### SQL:

<!-- request SQL -->

```sql
SHOW SOURCES
```

<!-- response -->

```
+-------+
| नाम   |
+-------+
| kafka |
+-------+
```

<!-- end -->

<!-- example kafka_create_source -->

<!-- intro -->

##### SQL:

<!-- request SQL -->

```sql
SHOW SOURCE kafka;
```

<!-- response -->

```
+--------+-------------------------------------------------------------------+
| स्रोत  | टेबल बनाएँ                                                        |
+--------+-------------------------------------------------------------------+
| kafka  | CREATE SOURCE kafka                                               |
|        | (id bigint, term text, abbrev '$abbrev' text, GlossDef json)      |
|        | type='kafka'                                                      |
|        | broker_list='kafka:9092'                                          |
|        | topic_list='my-data'                                              |
|        | consumer_group='manticore'                                        |
|        | num_consumers='2'                                                 |
|        | batch=50                                                          |
+--------+-------------------------------------------------------------------+
```

<!-- end -->

<!-- example kafka_view -->

<!-- intro -->

##### SQL:

<!-- request SQL -->

```sql
SHOW MVS
```

<!-- response -->

```
+------------+
| नाम        |
+------------+
| view_table |
+------------+
```

<!-- end -->

<!-- example kafka_show -->

<!-- intro -->

##### SQL:

<!-- request SQL -->

```sql
SHOW MV view_table
```

<!-- response -->

```
+------------+--------------------------------------------------------------------------------------------------------+-----------+
| व्यू       | टेबल बनाएँ                                                                                           | निलंबित  |
+------------+--------------------------------------------------------------------------------------------------------+-----------+
| view_table | CREATE MATERIALIZED VIEW view_table TO destination_kafka AS                                            | 0         |
|            | SELECT id, term as name, abbrev as short_name, UTC_TIMESTAMP() as received_at, GlossDef.size as size   |           |
|            | FROM kafka                                                                                             |           |
+------------+--------------------------------------------------------------------------------------------------------+-----------+
```

<!-- end -->

### मेटेरियलाइज्ड व्यूज़ को परिवर्तित करना

<!-- example mv_suspend -->

आप मेटेरियलाइज्ड व्यूज़ को परिवर्तित करके डेटा खपत को निलंबित कर सकते हैं।

यदि आप `source` को हटा देते हैं बिना MV को हटाए, तो यह स्वतः निलंबित हो जाता है। स्रोत को फिर से बनाने के बाद, `ALTER` कमांड का उपयोग करके MV को मैन्युअल रूप से निलंबन解除 करें।

वर्तमान में, केवल मेटेरियलाइज्ड व्यूज़ को ही परिवर्तित किया जा सकता है। `source` पैरामीटर को बदलने के लिए, स्रोत को गिराएँ और फिर से बनाएं।

<!-- intro -->

##### SQL:

<!-- request SQL -->

```sql
ALTER MATERIALIZED VIEW view_table suspended=1
```

<!-- response -->

```sql
Query OK (0.02 sec)
```

<!-- end -->

### समस्या निवारण

#### अविवेकी प्रविष्टियाँ

Kafka ऑफ़सेट प्रत्येक बैच के बाद या जब प्रोसेसिंग टाइम आउट होती है, तब कमिट होता है। यदि प्रक्रिया एक मेटेरियलाइज्ड व्यू क्वेरी के दौरान अप्रत्याशित रूप से रुक जाती है, तो आप अविवेकी प्रविष्टियाँ देख सकते हैं। इसे रोकने के लिए, अपने स्कीमा में एक `id` फ़ील्ड शामिल करें, जिससे Manticore Search को तालिका में अविवेकी प्रविष्टियों को रोकने में मदद मिले।

### यह आंतरिक रूप से कैसे काम करता है

- **कार्यकर्ता प्रारंभिककरण:** एक स्रोत और मेटेरियलाइज्ड व्यू को कॉन्फ़िगर करने के बाद, Manticore Search डेटा अधिग्रहण के लिए एक समर्पित कार्यकर्ता को सेट करता है।
- **संदेश मानचित्रण:** संदेशों को स्रोत कॉन्फ़िगरेशन स्कीमा के अनुसार मानचित्रित किया जाता है, उन्हें संरचित प्रारूप में बदलते हुए।
- **बैचिंग:** संदेशों को कुशल प्रोसेसिंग के लिए बैचों में समूहित किया जाता है। बैच का आकार आपके प्रदर्शन और विलंबता की आवश्यकताओं के अनुसार समायोजित किया जा सकता है।
- **बफरिंग:** मानचित्रित डेटा बैचों को कुशल थोक संचालन के लिए एक बफर तालिका में संग्रहित किया जाता है।
- **मेटेरियलाइज्ड व्यू प्रोसेसिंग:** बफर तालिका में डेटा पर व्यू लॉजिक लागू किया जाता है, किसी भी परिवर्तनों या छानने के निष्पादन के लिए।
- **डेटा स्थानांतरण:** प्रोसेस किए गए डेटा को फिर वास्तविक समय की तालिका में स्थानांतरित किया जाता है।
- **सफाई:** प्रत्येक बैच के बाद बफर तालिका को साफ किया जाता है, यह सुनिश्चित करते हुए कि यह अगली सेट डेटा के लिए तैयार है।

<!-- proofread -->
