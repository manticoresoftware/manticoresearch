# बाइनरी लॉगिंग

बाइनरी लॉगिंग [रीयल-टाइम](../Creating_a_table/Local_tables/Real-time_table.md) तालिका डेटा के लिए एक पुनर्प्राप्ति तंत्र के रूप में कार्य करता है। जब बाइनरी लॉग सक्षम होते हैं, तो `searchd` प्रत्येक लेनदेन को बिनलॉग फ़ाइल में रिकॉर्ड करता है और अस्वच्छ शटडाउन के बाद पुनर्प्राप्ति के लिए इसका उपयोग करता है। एक साफ शटडाउन के दौरान, RAM चंक्स को डिस्क पर सुरक्षित किया जाता है, और बाद में सभी बिनलॉग फ़ाइलें हटा दी जाती हैं।

## बाइनरी लॉगिंग को सक्षम और अक्षम करना

डिफ़ॉल्ट रूप से, डेटा इंटीग्रिटी को सुरक्षित रखने के लिए बाइनरी लॉगिंग सक्षम होती है। लिनक्स सिस्टम पर, [सादा मोड](../Creating_a_table/Local_tables.md#Defining-table-schema-in-config-%28Plain-mode%29) में `binlog.*` फ़ाइलों के लिए डिफ़ॉल्ट स्थान `/var/lib/manticore/data/` है। [आरटी मोड](../Creating_a_table/Local_tables.md#Online-schema-management-%28RT-mode%29) में, बाइनरी लॉग `<data_dir>/binlog/` फ़ोल्डर में संग्रहीत होते हैं, जब तक कि अन्यथा निर्दिष्ट न किया गया हो।

### वैश्विक बाइनरी लॉगिंग कॉन्फ़िगरेशन

<!-- example binlog_path -->
बाइनरी लॉगिंग को वैश्विक रूप से अक्षम करने के लिए, `searchd` कॉन्फ़िगरेशन में `binlog_path` को एक खाली मान पर सेट करें।
वैश्विक रूप से बाइनरी लॉगिंग को अक्षम करने के लिए डेमन का पुनरारंभ करना आवश्यक है और यदि सिस्टम अप्रत्याशित रूप से बंद होता है तो डेटा जोखिम में पड़ सकता है।

<!-- request Example -->
```ini
searchd {
...
    binlog_path = # लॉगिंग अक्षम करें
...
```
<!-- end -->

<!-- example binlog_path2 -->
आप कस्टम पथ सेट करने के लिए निम्नलिखित निर्देश का उपयोग कर सकते हैं:

<!-- request Example -->
```ini
searchd {
...
    binlog_path = /var/data
...
```
<!-- end -->

### प्रति-तालिका बाइनरी लॉगिंग कॉन्फ़िगरेशन

<!-- Example binlog0 -->
अधिक विस्तार नियंत्रण के लिए, बाइनरी लॉगिंग को रीयल-टाइम तालिकाओं के लिए तालिका स्तर पर अक्षम किया जा सकता है, `binlog` तालिका पैरामीटर को `0` पर सेट करके। यह विकल्प पर्कोलेट तालिकाओं के लिए उपलब्ध नहीं है।

<!-- request Example -->
```sql
create table a (id bigint, s string attribute) binlog='0';
```
<!-- end -->

<!-- Example binlog_alter -->
मौजूदा आरटी तालिकाओं के लिए, `binlog` पैरामीटर को संशोधित करके बाइनरी लॉगिंग को भी अक्षम किया जा सकता है।

<!-- request Example -->
```sql
alter table FOO binlog='0';
```
<!-- end -->

<!-- Example binlog_alter2 -->
यदि बाइनरी लॉगिंग पहले से अक्षम थी, तो इसे `binlog` पैरामीटर को फिर से `1` पर सेट करके पुनः सक्षम किया जा सकता है:

<!-- request Example -->
```sql
alter table FOO binlog='1';
```
<!-- end -->

#### महत्वपूर्ण विचार:
* **वैश्विक सेटिंग्स पर निर्भरता**: प्रति-तालिका बाइनरी लॉगिंग सेटिंग्स केवल तभी प्रभावी होती हैं जब बाइनरी लॉगिंग खोजद कॉन्फ़िगरेशन में वैश्विक रूप से सक्षम हो (`binlog_path` खाली नहीं होना चाहिए)।
* **बाइनरी लॉगिंग स्थिति और लेनदेन आईडी अंतर्दृष्टि**: एक तालिका की बाइनरी लॉगिंग स्थिति को संशोधित करने से तालिका का तत्काल [फ्लश](../Securing_and_compacting_a_table/Flushing_RAM_chunk_to_disk.md#FLUSH-TABLE) होता है। यदि आप किसी तालिका के लिए बाइनरी लॉगिंग बंद करते हैं, तो इसका लेनदेन आईडी (TID) `-1` में बदल जाता है। यह इंगित करता है कि बाइनरी लॉगिंग सक्रिय नहीं है, और कोई परिवर्तन ट्रैक नहीं किया जा रहा है। इसके विपरीत, यदि आप किसी तालिका के लिए बाइनरी लॉगिंग शुरू करते हैं, तो इसका लेनदेन आईडी एक गैर-ऋणात्मक संख्या (शून्य या अधिक) हो जाता है। यह इंगित करता है कि तालिका के परिवर्तन अब रिकॉर्ड किए जा रहे हैं। आप कमांड का उपयोग करके लेनदेन आईडी की जांच कर सकते हैं: `SHOW TABLE <name> STATUS`. लेनदेन आईडी दर्शाता है कि तालिका के परिवर्तन रिकॉर्ड किए जा रहे हैं (गैर-ऋणात्मक संख्या) या नहीं (`-1`)।

## संचालन

जब बाइनरी लॉगिंग चालू होती है, तो आरटी तालिका में किए गए हर परिवर्तन को लॉग फ़ाइल में सहेजा जाता है। यदि सिस्टम अप्रत्याशित रूप से बंद होता है, तो जब सिस्टम फिर से शुरू होता है, तब इन लॉगों का स्वचालित रूप से उपयोग किया जाता है ताकि सभी लॉग किए गए परिवर्तनों को वापस लाया जा सके।

### लॉग आकार

<!-- Example binlog_max_log_size -->
सामान्य संचालन के दौरान, जब लॉग किए गए डेटा की मात्रा एक निश्चित सीमा (जो `binlog_max_log_size` द्वारा सेट की गई है) तक पहुँच जाती है, तो एक नया लॉग फ़ाइल शुरू होता है। पुराने लॉग फ़ाइलें तब तक रखी जाती हैं जब तक कि उनमें सभी परिवर्तन पूरी तरह से संसाधित और डिस्क पर एक डिस्क चंके के रूप में सुरक्षित नहीं हो जाते। यदि यह सीमा `0` पर सेट की गई है, तो लॉग फ़ाइलें तब तक रखी जाती हैं जब तक कि सिस्टम को ठीक से बंद नहीं किया जाता। डिफ़ॉल्ट रूप से, इन फ़ाइलों के कितना बड़ा बढ़ने का कोई सीमा नहीं है।

<!-- request Example -->

```ini
searchd {
...
    binlog_max_log_size = 16M
....
```

<!-- end -->

### लॉग फ़ाइलें

<!-- example binlog_filename_digits -->

प्रत्येक बिनलॉग फ़ाइल को एक जीरो-पैडेड संख्या के साथ नामित किया जाता है, जैसे `binlog.0000`, `binlog.0001`, आदि, आमतौर पर चार अंकों को दिखाते हैं। आप सेटिंग `binlog_filename_digits` के साथ संख्या के कितने अंकों के पास होना चाहिए, उसे बदल सकते हैं। यदि आपके पास बिनलॉग फ़ाइलें अधिक हैं जितनी संख्या के अंकों में समायोजित किया जा सकता है, तो सभी फ़ाइलों में समायोजित करने के लिए अंकों की संख्या को स्वचालित रूप से बढ़ा दिया जाएगा।

**महत्वपूर्ण**: अंकों की संख्या बदलने के लिए, आपको पहले सभी तालिका डेटा को सुरक्षित करना होगा और सिस्टम को ठीक से बंद करना होगा। फिर, पुराने लॉग फ़ाइलों को हटाएं और सिस्टम को पुनः प्रारंभ करें।

<!-- request Example -->
```ini
searchd {
...
    binlog_filename_digits = 6
...
```
<!-- end -->

### बाइनरी लॉगिंग रणनीतियाँ

<!-- Example binlog_common -->
आप बाइनरी लॉग फ़ाइलों का प्रबंधन करने के लिए दो तरीकों में से एक चुन सकते हैं, जिसे `binlog_common` निर्देश के साथ सेट किया जा सकता है:
* प्रत्येक तालिका के लिए अलग फ़ाइल (डिफ़ॉल्ट, `0`): प्रत्येक तालिका अपने परिवर्तनों को अपनी स्वयं की लॉग फ़ाइल में सहेजती है। यह सेटअप अच्छा है यदि आपके पास कई तालिकाएँ हैं जो विभिन्न समयों पर अपडेट होती हैं। यह तालिकाओं को अन्य का इंतजार किए बिना अपडेट करने की अनुमति देता है। इसके अलावा, यदि एक तालिका के लॉग फ़ाइल में कोई समस्या होती है, तो यह अन्य को प्रभावित नहीं करता है।
* सभी तालिकाओं के लिए एकल फ़ाइल (`1`): सभी तालिकाएँ एक ही बाइनरी लॉग फ़ाइल का उपयोग करती हैं। यह विधि फ़ाइलों को संभालना आसान बनाती है क्योंकि उनकी संख्या कम होती है। हालाँकि, इससे फ़ाइलें लंबे समय तक रह सकती हैं यदि एक तालिका को अभी भी अपने अपडेट को सहेजने की आवश्यकता हो। यदि कई तालिकाएँ एक ही समय में अपडेट करने की आवश्यकता रखती हैं तो यह सेटिंग चीज़ों को धीमा कर सकती है, क्योंकि सभी परिवर्तनों को एक फ़ाइल में लिखने के लिए इंतज़ार करना पड़ेगा।

<!-- request binlog_common -->

```ini
searchd {
...
    binlog_common = 1
...
```
<!-- end -->
### बाइनरी फ्लशिंग रणनीतियाँ

<!-- उदाहरण binlog_flush -->
बाइनलॉग फ्लशिंग रणनीतियाँ चार प्रकार की होती हैं, जो `binlog_flush` निर्देशिका द्वारा नियंत्रित होती हैं:

* `0` - डेटा हर सेकंड में डिस्क पर लिखा जाता है (फ्लश किया जाता है), और मैन्टिकोरे इसे डिस्क पर सुरक्षित बनाने की प्रक्रिया ([syncing](https://linux.die.net/man/8/sync)) फ्लशिंग के तुरंत बाद शुरू करता है। यह विधि सबसे तेज़ है, लेकिन यदि सर्वर या कंप्यूटर अचानक क्रैश हो जाता है, तो कुछ हाल ही में लिखा गया डेटा जो सुरक्षित नहीं है, खो सकता है।
* `1` - डेटा बाइनलॉग में लिखा जाता है और प्रत्येक लेन-देन के तुरंत बाद समन्वयित किया जाता है। यह विधि सबसे सुरक्षित है क्योंकि यह सुनिश्चित करती है कि प्रत्येक परिवर्तन तुरंत संरक्षित हो, लेकिन यह लिखने की गति को धीमा कर देती है।
* `2` - डेटा प्रत्येक लेन-देन के बाद लिखा जाता है, और हर सेकंड में एक समन्वय शुरू होता है। यह दृष्टिकोण संतुलन प्रदान करता है, डेटा को नियमित और तेज़ी से लिखता है। हालाँकि, यदि कंप्यूटर विफल होता है, तो कुछ डेटा जो सुरक्षित किया जा रहा था वह सहेजने में पूरा नहीं हो सकता। इसके अलावा, डिस्क के आधार पर समन्वय में एक सेकंड से अधिक समय लग सकता है।
* `3` - `2` के समान, लेकिन यह सुनिश्चित भी करता है कि बाइनलॉग फ़ाइल को `binlog_max_log_size` के अधिक होने के कारण बंद होने से पहले समन्वयित किया जाए।

डिफ़ॉल्ट मोड `2` है, जो प्रत्येक लेन-देन के बाद डेटा लिखता है और हर सेकंड इसे समन्वयित करना शुरू करता है, गति और सुरक्षा के बीच संतुलन बनाते हुए।

<!-- अनुरोध उदाहरण -->
```ini
searchd {
...
    binlog_flush = 1 # अंतिम सुरक्षा, कम लिखने की गति
...
}
```
<!-- अंत -->

### पुनर्प्राप्ति

अस्वच्छ शटडाउन के बाद की पुनर्प्राप्ति के दौरान, बाइनलॉग फिर से चलाए जाते हैं, और अंतिम अच्छे ऑन-डिस्क स्थिति के बाद से सभी लॉग की गई लेन-देन को पुनर्स्थापित किया जाता है। लेन-देन के लिए चेकसम होता है, इसलिए बाइनलॉग फ़ाइल भ्रष्टाचार के मामले में, गंदे डेटा को **फिर से नहीं** चलाया जाएगा; इस प्रकार एक टूटी हुई लेन-देन का पता लगाया जाएगा और पुनरावृत्ति को रोक दिया जाएगा।

### RT RAM चंक्स का फ्लशिंग

<!-- उदाहरण rt_flush_period -->
एक छोटे RT टेबल के लिए तीव्र अपडेट जो पूरी तरह से RAM चंक्स में फिट होती है, एक ऐसा बाइनलॉग उत्पन्न कर सकता है जो कभी भी एक साफ शटडाउन के बिना unlink नहीं हो सकता। बाइनलॉग मूलतः डिस्क पर अंतिम ज्ञात अच्छे सहेज़ित स्थिति के खिलाफ केवल जोड़ने के लिए डेल्टास के रूप में कार्य करते हैं, और इन्हें unlink नहीं किया जा सकता जब तक कि RAM चंक को सहेजा नहीं जाता। एक लगातार बढ़ता बाइनलॉग डिस्क के उपयोग और क्रैश रिकवरी समय के लिए आदर्श नहीं है। इस समस्या को संबोधित करने के लिए, आप `searchd` को `rt_flush_period` निर्देशिका का उपयोग करके आवृत्तियों के अनुसार RAM चंक फ्लश करने के लिए कॉन्फ़िगर कर सकते हैं। आवधिक फ्लशेस सक्षम होने पर, `searchd` एक अलग थ्रेड बनाएगा जो जांचता है कि क्या RT टेबल के RAM चंक्स को डिस्क पर वापस लिखने की आवश्यकता है। जब ऐसा होता है, तो संबंधित बाइनलॉग सुरक्षित रूप से unlink किए जा सकते हैं (और हैं)।

डिफ़ॉल्ट RT फ्लशिंग अवधि 10 घंटे पर सेट की गई है।

<!-- अनुरोध उदाहरण -->
```ini
searchd {
...
    rt_flush_period = 3600 # 1 घंटा
...
}
```
<!-- अंत -->

यह ध्यान देने योग्य है कि `rt_flush_period` केवल उस दर को नियंत्रित करता है जिस पर चेक होते हैं। यह कोई गारंटी नहीं देता है कि एक विशिष्ट RAM चंक को सहेजा जाएगा। उदाहरण के लिए, नियमित रूप से पुनः सहेजना एक बड़े RAM चंक का आयारंभिक नहीं होता है जो केवल कुछ पंक्तियों के अद्यतन प्राप्त करता है। मैन्टिकोरे स्वचालित रूप से यह निर्धारित करता है कि फ्लश करना है या नहीं कुछ ही ह्यूरिस्टिक्स का उपयोग करके।

<!-- प्रूफरीड -->

