# ऑटोकोम्प्लीट

ऑटोकोम्प्लीट, या शब्द पूर्णता, एक शब्द या वाक्यांश के अंत का अनुमान लगाता है और सुझाव देता है जब आप टाइप करते हैं। इसका सामान्यत: उपयोग किया जाता है:
- वेबसाइटों पर खोज बॉक्स
- खोज इंजन में सुझाव
- ऐप्स में टेक्स्ट फ़ील्ड

मंटिकोरे एक उन्नत ऑटोकोम्प्लीट सुविधा प्रदान करता है जो आपको टाइप करते समय सुझाव देता है, जैसे कि प्रसिद्ध खोज इंजनों में होता है। यह खोजों को तेज करने में मदद करता है और उपयोगकर्ताओं को तेजी से वह जानकारी खोजने देता है जो उन्हें चाहिए।

मूल ऑटोकोम्प्लीट कार्यक्षमता के अलावा, मंटिकोरे उपयोगकर्ता अनुभव को बेहतर बनाने के लिए उन्नत सुविधाओं का समावेश करता है:

1. **स्पेल सुधार (फजिनेस):** मंटिकोरे का ऑटोकोम्प्लीट सामान्य त्रुटियों को पहचानने और ठीक करने के लिए एल्गोरिदम का उपयोग करके वर्तनी की गलतियों को सुधारने में मदद करता है। इसका मतलब है कि अगर आप कुछ गलत टाइप करते हैं, तो भी आप वह जानकारी प्राप्त कर सकते हैं जिसे आप ढूंढ रहे थे।
2. **कीबोर्ड लेआउट ऑटोडिटेक्शन:** मंटिकोरे यह पहचान सकता है कि आप कौन सा कीबोर्ड लेआउट उपयोग कर रहे हैं। यह ऐसे स्थानों में वास्तव में उपयोगी है जहां कई भाषाएं उपयोग की जाती हैं, या यदि आप गलती से गलत भाषा में टाइप कर देते हैं। उदाहरण के लिए, अगर आप गलती से "ghbdtn" टाइप करते हैं, तो मंटिकोरे जानता है कि आप "привет" (रूसी में यानी हेल्लो) कहना चाहते थे और सही शब्द का सुझाव देता है।

मंटिकोरे का ऑटोकोम्प्लीट विभिन्न आवश्यकताओं और सेटिंग्स के साथ मेल खाने के लिए तैयार किया जा सकता है, जिससे यह कई अनुप्रयोगों के लिए एक लचीला उपकरण बनता है।

![ऑटोकोम्प्लीट](autocomplete.png)

## कॉल ऑटोकोम्प्लीट

> नोट: `CALL AUTOCOMPLETE` और `/autocomplete` [मंटिकोरे बडी](../Installation/Manticore_Buddy.md) की आवश्यकता होती है। यदि यह काम नहीं करता है, तो सुनिश्चित करें कि बडी स्थापित है।

<!-- उदाहरण कॉल_ऑटोकोम्प्लीट -->
मंटिकोरे में ऑटोकोम्प्लीट का उपयोग करने के लिए, `CALL AUTOCOMPLETE` SQL स्टेटमेंट या इसके JSON समकक्ष `/autocomplete` का उपयोग करें। यह सुविधा आपके इंडेक्स किए गए डेटा के आधार पर शब्द पूर्णता सुझाव प्रदान करती है।

आगे बढ़ने से पहले, सुनिश्चित करें कि आप जिस टेबल का उपयोग ऑटोकोम्प्लीट के लिए करने की योजना बना रहे हैं, उसमें [इनफिक्सेस](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) सक्षम हैं।

**नोट:** टेबल सेटिंग्स में `min_infix_len` के लिए एक स्वचालित जांच होती है, जो `CALL AUTOCOMPLETE` के प्रदर्शन को सुधारने के लिए 30-सेकंड का कैश का उपयोग करती है। अपनी टेबल में परिवर्तन करने के बाद, जब आप पहले बार `CALL AUTOCOMPLETE` का उपयोग करेंगे तो थोड़ी देरी हो सकती है (हालांकि यह आमतौर पर ध्यान देने योग्य नहीं होती)। केवल सफल परिणामों को कैश किया जाता है, इसलिए यदि आप टेबल को हटा देते हैं या `min_infix_len` को अक्षम कर देते हैं, तो `CALL AUTOCOMPLETE` अस्थायी रूप से गलत परिणाम लौटा सकता है जब तक कि यह अंततः `min_infix_len` से संबंधित एक त्रुटि दिखाना शुरू नहीं कर देता।

### सामान्य सिंटैक्स

#### SQL
```sql
CALL AUTOCOMPLETE('query_beginning', 'table', [...options]);
```

#### JSON
```json
POST /autocomplete
{
	"table":"table_name",
	"query":"query_beginning"
	[,"options": {<autocomplete options>}]
}
```

#### विकल्प
- `layouts`: वर्तनी सुधार के लिए सत्यापन और जांच करने के लिए कीबोर्ड लेआउट कोड का अल्पविराम से पृथक स्ट्रिंग। उपलब्ध विकल्प: us, ru, ua, se, pt, no, it, gr, uk, fr, es, dk, de, ch, br, bg, be (ज्यादा विवरण [यहां](../../Searching/Spell_correction.md#Options) देखें)। डिफ़ॉल्ट: सभी सक्षम
- `fuzziness`: `0`, `1`, या `2` (डिफ़ॉल्ट: `2`)। टाइपो खोजने के लिए अधिकतम लेवेनस्टीन दूरी। फजी मिलान को अक्षम करने के लिए `0` पर सेट करें
- `prepend`: बूलियन (SQL में 0/1)। अगर सत्य(1) है, तो यह अंतिम शब्द के पहले एक तारा जोड़ता है ताकि उपसर्ग विस्तार हो सके (उदाहरण, `*word`)
- `append`: बूलियन (SQL में 0/1)। अगर सत्य(1) है, तो यह अंतिम शब्द के बाद एक तारा जोड़ता है ताकि प्रत्यय विस्तार हो सके (उदाहरण, `word*`)
- `expansion_len`: अंतिम शब्द में विस्तारित करने के लिए वर्णों की संख्या। डिफ़ॉल्ट: `10`

<!-- अनुरोध SQL -->

```sql
mysql> CALL AUTOCOMPLETE('hello', 'comment');
+------------+
| query      |
+------------+
| hello      |
| helio      |
| hell       |
| shell      |
| nushell    |
| powershell |
| well       |
| help       |
+------------+
```

<!-- अनुरोध SQL बिना फजी खोज -->

```sql
mysql> CALL AUTOCOMPLETE('hello', 'comment', 0 as fuzziness);
+-------+
| query |
+-------+
| hello |
+-------+
```

<!-- अनुरोध JSON -->

```json
POST /autocomplete
{
	"table":"comment",
	"query":"hello"
}
```

<!-- प्रतिक्रिया JSON -->
```json
[
  {
    "total": 8,
    "error": "",
    "warning": "",
    "columns": [
      {
        "query": {
          "type": "string"
        }
      }
    ],
    "data": [
      {
        "query": "hello"
      },
      {
        "query": "helio"
      },
      {
        "query": "hell"
      },
      {
        "query": "shell"
      },
      {
        "query": "nushell"
      },
      {
        "query": "powershell"
      },
      {
        "query": "well"
      },
      {
        "query": "help"
      }
    ]
  }
]
```

<!-- अंत -->

#### लिंक्स
* [यह डेमो](https://github.manticoresearch.com/manticoresoftware/manticoresearch) ऑटोकोम्प्लीट कार्यक्षमता को प्रदर्शित करता है:
  ![ऑटोकोम्प्लीट उदाहरण](autocomplete_github_demo.png){.scale-0.7}
* फजी खोज और ऑटोकोम्प्लीट के बारे में ब्लॉग पोस्ट - https://manticoresearch.com/blog/new-fuzzy-search-and-autocomplete/

## वैकल्पिक ऑटोकोम्प्लीट विधियाँ

जबकि `CALL AUTOCOMPLETE` अधिकांश उपयोग के मामलों के लिए अनुशंसित विधि है, मंटिकोरे ऑटोकोम्प्लीट कार्यक्षमता को लागू करने के लिए अन्य नियंत्रित और अनुकूलन योग्य दृष्टिकोणों का भी समर्थन करता है:

##### एक वाक्य को ऑटोकोम्प्लीट करना
एक वाक्य को ऑटोकोम्प्लीट करने के लिए, आप [इनफिक्स खोज](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) का उपयोग कर सकते हैं। आप इसके प्रारंभ को प्रदान करके एक दस्तावेज़ फ़ील्ड के अंत को ढूंढ सकते हैं और:
* किसी भी वर्ण का मेल खाने के लिए [पूर्ण-टेक्स्ट वाइल्डकार्ड ऑपरेटर](../Searching/Full_text_matching/Operators.md) `*` का उपयोग करें
* वैकल्पिक रूप से फ़ील्ड की शुरुआत से शुरू करने के लिए `^` का उपयोग करें
* वैकल्पिक रूप से वाक्यांश मिलान के लिए `""` का उपयोग करें
* और [परिणाम हाइलाइटिंग](../Searching/Highlighting.md) का उपयोग करें
There is an [article about it in our blog](https://manticoresearch.com/blog/simple-autocomplete-with-manticore/) and an [interactive course](https://play.manticoresearch.com/simpleautocomplete/). A quick example is:
* मान लीजिए आपके पास एक दस्तावेज है: `My cat loves my dog. The cat (Felis catus) is a domestic species of small carnivorous mammal.`
* फिर आप `^`, `""`, और `*` का उपयोग कर सकते हैं ताकि उपयोगकर्ता टाइप करते समय, आप प्रश्न कर सकें जैसे: `^"m*"`, `^"my *"`, `^"my c*"`, `^"my ca*"` और इसी प्रकार
* यह दस्तावेज़ को खोज निकालेगा, और यदि आप [हाइलाइटिंग](../Searching/Highlighting.md) भी करते हैं, तो आपको कुछ ऐसा मिलेगा: `<b>My cat</b> loves my dog. The cat ( ...`

##### एक शब्द का ऑटो-पूर्ण करें
कुछ मामलों में, आपको केवल एक शब्द या कुछ शब्दों को ऑटो-पूर्ण करने की आवश्यकता होती है। इस मामले में, आप `CALL KEYWORDS` का उपयोग कर सकते हैं।

### CALL KEYWORDS
`CALL KEYWORDS` SQL इंटरफ़ेस के माध्यम से उपलब्ध है और यह यह देखने का एक तरीका प्रदान करता है कि कीवर्ड कैसे टोकनाइज होते हैं या विशिष्ट कीवर्ड के लिए टोकनाइज्ड रूप प्राप्त करने का एक तरीका प्रदान करता है। यदि तालिका [इनफिक्स](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) को सक्षम करती है, तो यह आपको दिए गए कीवर्ड के संभावित समाप्तियों को जल्दी से खोजने की अनुमति देती है, जिससे यह ऑटोपूर्ण कार्यक्षमता के लिए उपयुक्त बन जाती है।

यह सामान्य इनफिक्स खोज का एक शानदार विकल्प है, क्योंकि यह अधिक प्रदर्शन प्रदान करता है क्योंकि इसे केवल तालिका के शब्दकोश की आवश्यकता होती है, न कि दस्तावेज़ों की।

### सामान्य सिंटैक्स
<!-- example keywords -->
```sql
CALL KEYWORDS(text, table [, options])
```
`CALL KEYWORDS` कथन पाठ को कीवर्ड में विभाजित करता है। यह कीवर्ड के टोकनाइज्ड और सामान्यीकृत रूप लौटाता है, और यदि आवश्यक हो, तो कीवर्ड सांख्यिकी। इसके अतिरिक्त, यह प्रश्न में प्रत्येक कीवर्ड की स्थिति और सभी टोकनाइज्ड कीवर्ड के रूप प्रदान करता है जब तालिका [लेम्माटाइजर्स](../Creating_a_table/NLP_and_tokenization/Morphology.md) को सक्षम करती है।

| Parameter | Description |
| - | - |
| text | कीवर्ड में तोड़ने के लिए पाठ |
| table | उस तालिका का नाम जिससे पाठ प्रसंस्करण सेटिंग्स ली जा रही हैं |
| 0/1 as stats | कीवर्ड की सांख्यिकी दिखाएं, डिफ़ॉल्ट 0 है |
| 0/1 as fold_wildcards | वाइल्डकार्ड को फोल्ड करें, डिफ़ॉल्ट 0 है |
| 0/1 as fold_lemmas | रूपात्मक लेम्माट्स को फोल्ड करें, डिफ़ॉल्ट 0 है |
| 0/1 as fold_blended | मिश्रित शब्दों को फोल्ड करें, डिफ़ॉल्ट 0 है |
| N as expansion_limit | सर्वर कॉन्फ़िगरेशन में परिभाषित [expansion_limit](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expansion_limit) को ओवरराइड करें, डिफ़ॉल्ट 0 है (कॉन्फ़िगरेशन से मान का उपयोग करें) |
| docs/hits as sort_mode | आउटपुट परिणामों को 'docs' या 'hits' द्वारा क्रमबद्ध करता है। डिफ़ॉल्ट रूप से कोई क्रमबद्धता लागू नहीं होती है। |
| jieba_mode | प्रश्न के लिए जियाबा विभाजन मोड। अधिक जानकारी के लिए [jieba_mode](Creating_a_table/NLP_and_tokenization/Morphology.md#jieba_mode) देखें |

उदाहरण दिखाते हैं कि यदि मान लिया जाए कि उपयोगकर्ता "my cat ..." के लिए ऑटो-पूर्ण पाने की कोशिश कर रहा है तो यह कैसे काम करता है। इसलिए अनुप्रयोग पक्ष पर आपको केवल नए शब्द के लिए "normalized" कॉलम से उपयोगकर्ता को अंत सुझाव देने की आवश्यकता है। अक्सर 'hits' या 'docs' द्वारा क्रमबद्ध करना समझ में आता है जिसका उपयोग `'hits' as sort_mode` या `'docs' as sort_mode` के रूप में किया गया है।

<!-- intro -->
##### उदाहरण:

<!-- request Examples -->

```sql
MySQL [(none)]> CALL KEYWORDS('m*', 't', 1 as stats);
+------+-----------+------------+------+------+
| qpos | tokenized | normalized | docs | hits |
+------+-----------+------------+------+------+
| 1    | m*        | my         | 1    | 2    |
| 1    | m*        | mammal     | 1    | 1    |
+------+-----------+------------+------+------+

MySQL [(none)]> CALL KEYWORDS('my*', 't', 1 as stats);
+------+-----------+------------+------+------+
| qpos | tokenized | normalized | docs | hits |
+------+-----------+------------+------+------+
| 1    | my*       | my         | 1    | 2    |
+------+-----------+------------+------+------+

MySQL [(none)]> CALL KEYWORDS('c*', 't', 1 as stats, 'hits' as sort_mode);
+------+-----------+-------------+------+------+
| qpos | tokenized | normalized  | docs | hits |
+------+-----------+-------------+------+------+
| 1    | c*        | cat         | 1    | 2    |
| 1    | c*        | carnivorous | 1    | 1    |
| 1    | c*        | catus       | 1    | 1    |
+------+-----------+-------------+------+------+

MySQL [(none)]> CALL KEYWORDS('ca*', 't', 1 as stats, 'hits' as sort_mode);
+------+-----------+-------------+------+------+
| qpos | tokenized | normalized  | docs | hits |
+------+-----------+-------------+------+------+
| 1    | ca*       | cat         | 1    | 2    |
| 1    | ca*       | carnivorous | 1    | 1    |
| 1    | ca*       | catus       | 1    | 1    |
+------+-----------+-------------+------+------+

MySQL [(none)]> CALL KEYWORDS('cat*', 't', 1 as stats, 'hits' as sort_mode);
+------+-----------+------------+------+------+
| qpos | tokenized | normalized | docs | hits |
+------+-----------+------------+------+------+
| 1    | cat*      | cat        | 1    | 2    |
| 1    | cat*      | catus      | 1    | 1    |
+------+-----------+------------+------+------+
```
<!-- end -->
<!-- example bigram -->
There is a nice trick how you can improve the above algorithm - use [bigram_index](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#bigram_index). When you have it enabled for the table what you get in it is not just a single word, but each pair of words standing one after another indexed as a separate token.

This allows to predict not just the current word's ending, but the next word too which is especially beneficial for the purpose of autocomplete.

<!-- intro -->
##### उदाहरण:

<!-- request Examples -->

```sql
MySQL [(none)]> CALL KEYWORDS('m*', 't', 1 as stats, 'hits' as sort_mode);
+------+-----------+------------+------+------+
| qpos | tokenized | normalized | docs | hits |
+------+-----------+------------+------+------+
| 1    | m*        | my         | 1    | 2    |
| 1    | m*        | स्तनधारी     | 1    | 1    |
| 1    | m*        | मेरी बिल्ली     | 1    | 1    |
| 1    | m*        | मेरा कुत्ता     | 1    | 1    |
+------+-----------+------------+------+------+

MySQL [(none)]> CALL KEYWORDS('my*', 't', 1 as stats, 'hits' as sort_mode);
+------+-----------+------------+------+------+
| qpos | tokenized | normalized | docs | hits |
+------+-----------+------------+------+------+
| 1    | my*       | my         | 1    | 2    |
| 1    | my*       | मेरी बिल्ली     | 1    | 1    |
| 1    | my*       | मेरा कुत्ता     | 1    | 1    |
+------+-----------+------------+------+------+

MySQL [(none)]> CALL KEYWORDS('c*', 't', 1 as stats, 'hits' as sort_mode);
+------+-----------+--------------------+------+------+
| qpos | tokenized | normalized         | docs | hits |
+------+-----------+--------------------+------+------+
| 1    | c*        | बिल्ली                | 1    | 2    |
| 1    | c*        | मांसाहारी        | 1    | 1    |
| 1    | c*        | मांसाहारी स्तनधारी | 1    | 1    |
| 1    | c*        | बिल्ली felis          | 1    | 1    |
| 1    | c*        | बिल्ली loves          | 1    | 1    |
| 1    | c*        | कातुस              | 1    | 1    |
| 1    | c*        | कातुस है           | 1    | 1    |
+------+-----------+--------------------+------+------+

MySQL [(none)]> CALL KEYWORDS('ca*', 't', 1 as stats, 'hits' as sort_mode);
+------+-----------+--------------------+------+------+
| qpos | tokenized | normalized         | docs | hits |
+------+-----------+--------------------+------+------+
| 1    | ca*       | बिल्ली                | 1    | 2    |
| 1    | ca*       | मांसाहारी        | 1    | 1    |
| 1    | ca*       | मांसाहारी स्तनधारी | 1    | 1    |
| 1    | ca*       | बिल्ली felis          | 1    | 1    |
| 1    | ca*       | बिल्ली loves          | 1    | 1    |
| 1    | ca*       | कातुस              | 1    | 1    |
| 1    | ca*       | कातुस है           | 1    | 1    |
+------+-----------+--------------------+------+------+

MySQL [(none)]> CALL KEYWORDS('cat*', 't', 1 as stats, 'hits' as sort_mode);
+------+-----------+------------+------+------+
| qpos | tokenized | normalized | docs | hits |
+------+-----------+------------+------+------+
| 1    | cat*      | बिल्ली        | 1    | 2    |
| 1    | cat*      | बिल्ली felis  | 1    | 1    |
| 1    | cat*      | बिल्ली loves  | 1    | 1    |
| 1    | cat*      | कातुस      | 1    | 1    |
| 1    | cat*      | कातुस है   | 1    | 1    |
+------+-----------+------------+------+------+
```
<!-- end -->

`CALL KEYWORDS` वितरित तालिकाओं का समर्थन करता है इसलिए कोई फर्क नहीं पड़ता कि आपका डेटा सेट कितना बड़ा है, आप इसका उपयोग करके लाभ उठा सकते हैं।
<!-- proofread -->

