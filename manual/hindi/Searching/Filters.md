# फ़िल्टर
## WHERE
`WHERE` एक SQL धारा है जो पूर्ण-पाठ मिलान और अतिरिक्त फ़िल्टरिंग के लिए काम करती है। निम्नलिखित ऑपरेटर उपलब्ध हैं:
* [तुलना ऑपरेटर](../Searching/Expressions.md#Comparison-operators) `<, >, <=, >=, =, <>, BETWEEN, IN, IS NULL`
* [बूलियन ऑपरेटर](../Searching/Full_text_matching/Operators.md#Boolean-operators) `AND, OR, NOT`
`MATCH('query')` का समर्थन किया जाता है और यह [पूर्ण-पाठ क्वेरी](../Searching/Full_text_matching/Operators.md) के लिए मैप करता है।
`{col_name | expr_alias} [NOT] IN @uservar` स्थिति का सिंटैक्स समर्थित है। वैश्विक उपयोगकर्ता चर के विवरण के लिए [SET](../Server_settings/Setting_variables_online.md#SET) सिंटैक्स को देखें।
## HTTP JSON
यदि आप HTTP JSON इंटरफेस को प्राथमिकता देते हैं, तो आप फ़िल्टरिंग भी लागू कर सकते हैं। यह SQL की तुलना में अधिक जटिल प्रतीत हो सकता है, लेकिन जब आपको प्रोग्रामेटिक रूप से क्वेरी तैयार करने की आवश्यकता होती है, जैसे कि जब उपयोगकर्ता आपकी एप्लिकेशन में एक फॉर्म भरता है, तब इसकी सिफारिश की जाती है।
<!-- example json1 -->
यहाँ एक `bool` क्वेरी में कई फ़िल्टर का उदाहरण है।
यह पूर्ण-पाठ क्वेरी सभी दस्तावेज़ों से मेल खाती है जिनमें किसी भी फ़ील्ड में `product` है। इन दस्तावेज़ों की कीमत 500 (`gte`) से अधिक या उसके बराबर होनी चाहिए और 1000 (`lte`) से कम या उसके बराबर होनी चाहिए। इन सभी दस्तावेज़ों का पुनरीक्षण 15 (`lt`) से कम नहीं होना चाहिए।
<!-- request JSON -->
```json
POST /search
{
  "table": "test1",
  "query": {
    "bool": {
      "must": [
        { "match" : { "_all" : "product" } },
        { "range": { "price": { "gte": 500, "lte": 1000 } } }
      ],
      "must_not": {
        "range": { "revision": { "lt": 15 } }
      }
    }
  }
}
```
<!-- end -->
### bool क्वेरी
<!-- example bool -->
`bool` क्वेरी अन्य क्वेरियों और/या फ़िल्टरों के बूलियन संयोजनों के आधार पर दस्तावेज़ों से मेल खाती है। क्वेरी और फ़िल्टरों को `must`, `should`, या `must_not` अनुभागों में निर्दिष्ट किया जाना चाहिए और [नैस्टेड](../Searching/Filters.md#Nested-bool-query) हो सकते हैं।
<!-- request JSON -->
```json
POST /search
{
  "table":"test1",
  "query": {
    "bool": {
      "must": [
        { "match": {"_all":"keyword"} },
        { "range": { "revision": { "gte": 14 } } }
      ]
    }
  }
}
```
<!-- end -->
<!-- example must_not -->
### must
`must` अनुभाग में निर्दिष्ट क्वेरियों और फ़िल्टरों को दस्तावेज़ों से मेल खाना अनिवार्य है। यदि कई पूर्ण-पाठ क्वेरियाँ या फ़िल्टर निर्दिष्ट किए जाते हैं, तो उन सभी को मेल खाना चाहिए। यह SQL में `AND` क्वेरियों के समान है। ध्यान दें कि यदि आप एक ऐरे ([बहु-मूल्य विशेषता](../../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29)) के खिलाफ मेल खाना चाहते हैं, तो आप विशेषता को कई बार निर्दिष्ट कर सकते हैं। परिणाम सकारात्मक होगा केवल यदि सभी पूछे गए मूल्यों को ऐरे में पाया जाता है, जैसे:
```json
"must": [
  {"equals" : { "product_codes": 5 }},
  {"equals" : { "product_codes": 6 }}
]
```
ध्यान दें, प्रदर्शन की दृष्टि से यह बेहतर हो सकता है का उपयोग करना:
```json
  {"in" : { "all(product_codes)": [5,6] }}
```
(नीचे विवरण देखें)।
### should
`should` अनुभाग में निर्दिष्ट क्वेरियों और फ़िल्टरों को दस्तावेज़ों से मेल खाना चाहिए। यदि कुछ क्वेरियाँ `must` या `must_not` में निर्दिष्ट की गई हैं, तो `should` क्वेरियां अनदेखी की जाती हैं। दूसरी ओर, यदि `should` के अलावा कोई क्वेरियां नहीं हैं, तो इन क्वेरियों में से कम से कम एक को दस्तावेज़ से मेल खाना चाहिए ताकि यह bool क्वेरी से मेल खा सके। यह `OR` क्वेरियों के समान है। ध्यान दें, यदि आप एक ऐरे ([बहु-मूल्य विशेषता](../../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29)) के खिलाफ मेल खाना चाहते हैं, तो आप विशेषता को कई बार निर्दिष्ट कर सकते हैं, जैसे:
```json
"should": [
  {"equals" : { "product_codes": 7 }},
  {"equals" : { "product_codes": 8 }}
]
```
ध्यान दें, प्रदर्शन की दृष्टि से यह बेहतर हो सकता है का उपयोग करना:
```json
  {"in" : { "any(product_codes)": [7,8] }}
```
(नीचे विवरण देखें)।
### must_not
`must_not` अनुभाग में निर्दिष्ट क्वेरियों और फ़िल्टरों को दस्तावेज़ों से मेल नहीं खाना चाहिए। यदि `must_not` के तहत कई क्वेरियाँ निर्दिष्ट की गई हैं, तो दस्तावेज़ तब मेल खाता है जब उनमें से कोई भी मेल नहीं खाता है।
<!-- request JSON -->
```json
POST /search
{
  "table":"t",
  "query": {
    "bool": {
      "should": [
        {
          "equals": {
            "b": 1
          }
        },
        {
          "equals": {
            "b": 3
          }
        }
      ],
      "must": [
        {
          "equals": {
            "a": 1
          }
        }
      ],
      "must_not": {
        "equals": {
          "b": 2
        }
      }
    }
  }
}
```
<!-- end -->
### नैस्टेड bool क्वेरी
<!-- example eq_and_or -->
एक bool क्वेरी को दूसरी bool के अंदर नैस्टेड किया जा सकता है ताकि आप अधिक जटिल क्वेरियाँ बना सकें। एक नैस्टेड बूलियन क्वेरी बनाने के लिए बस `must`, `should` या `must_not` के बजाय एक और `bool` का उपयोग करें। यहाँ यह क्वेरी है:
```
a = 2 और (a = 10 या b = 0)
```
इसे JSON में इस प्रकार प्रस्तुत किया जाना चाहिए।
<!-- request JSON -->
a = 2 और (a = 10 या b = 0)
```json
POST /search
{
  "table":"t",
  "query": {
    "bool": {
      "must": [
        {
          "equals": {
            "a": 2
          }
        },
        {
          "bool": {
            "should": [
              {
                "equals": {
                  "a": 10
                }
              },
              {
                "equals": {
                  "b": 0
                }
              }
            ]
          }
        }
      ]
    }
  }
}
```
<!-- end -->
<!-- example complex -->
अधिक जटिल क्वेरी:
```
(a = 1 और b = 1) या (a = 10 और b = 2) या (b = 0)
```
<!-- request JSON -->
(a = 1 और b = 1) या (a = 10 और b = 2) या (b = 0)
```json
POST /search
{
  "table":"t",
  "query": {
    "bool": {
      "should": [
        {
          "bool": {
            "must": [
              {
                "equals": {
                  "a": 1
                }
              },
              {
                "equals": {
                  "b": 1
                }
              }
            ]
          }
        },
        {
          "bool": {
            "must": [
              {
                "equals": {
                  "a": 10
                }
              },
              {
                "equals": {
                  "b": 2
                }
              }
            ]
          }
        },
        {
          "bool": {
            "must": [
              {
                "equals": {
                  "b": 0
                }
              }
            ]
          }

        }
      ]
    }
  }
}
```
<!-- end -->

### SQL फ़ॉर्मेट में प्रश्न
<!-- example query_string -->
SQL फ़ॉर्मेट में प्रश्न (`query_string`) को bool प्रश्नों में भी उपयोग किया जा सकता है.

<!-- request JSON -->
```json
POST /search
{
  "table": "test1",
  "query": {
    "bool": {
      "must": [
        { "query_string" : "product" },
        { "query_string" : "good" }
      ]
    }
  }
}
```
<!-- end -->

## विभिन्न फ़िल्टर

### समानता फ़िल्टर
<!-- example equals -->
समानता फ़िल्टर सबसे साधारण फ़िल्टर होते हैं जो पूर्णांक, फ्लोट और स्ट्रिंग गुणों के साथ काम करते हैं.

<!-- request JSON -->
```json
POST /search
{
  "table":"test1",
  "query": {
    "equals": { "price": 500 }
  }
}
```
<!-- end -->

<!-- example equals_any -->
फ़िल्टर `equals` को [मल्टी-वैल्यू एट्रिब्यूट](../../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29) पर लागू किया जा सकता है और आप उपयोग कर सकते हैं:
* `any()` जो सकारात्मक होगा यदि गुण के पास कम से कम एक मान है जो क्वेरी किए गए मान के बराबर है;
* `all()` जो सकारात्मक होगा यदि गुण के पास एकल मान है और वह क्वेरी किए गए मान के बराबर है

<!-- request JSON -->
```json
POST /search
{
  "table":"test1",
  "query": {
    "equals": { "any(price)": 100 }
  }
}
```
<!-- end -->


### सेट फ़िल्टर
<!-- example set -->
सेट फ़िल्टर यह जांचते हैं कि गुण का मान निर्दिष्ट सेट में किसी भी मान के बराबर है या नहीं.

सेट फ़िल्टर पूर्णांक, स्ट्रिंग और मल्टी-वैल्यू गुणों का समर्थन करते हैं.

<!-- request JSON -->
```json
POST /search
{
  "table":"test1",
  "query": {
    "in": {
      "price": [1,10,100]
    }
  }
}
```
<!-- end -->

<!-- example set_any -->
जब इसे [मल्टी-वैल्यू एट्रिब्यूट](../../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29) पर लागू किया जाता है तो आप उपयोग कर सकते हैं:
* `any()` (कोई फ़ंक्शन नहीं लगाने के बराबर) जो सकारात्मक होगा यदि गुण मानों और क्वेरी किए गए मानों के बीच कम से कम एक मेल है;
* `all()` जो सकारात्मक होगा यदि सभी गुण मान क्वेरी किए गए सेट में हैं

<!-- request JSON -->
```json
POST /search
{
  "table":"test1",
  "query": {
    "in": {
      "all(price)": [1,10]
    }
  }
}
```
<!-- end -->

### रेंज फ़िल्टर
<!-- example range -->
रेंज फ़िल्टर उन दस्तावेजों से मेल खाते हैं जिनके गुण मान निर्दिष्ट रेंज के भीतर हैं.

रेंज फ़िल्टर नीचे दिए गए गुणों का समर्थन करते हैं:
* `gte`: से अधिक या के बराबर
* `gt`: से अधिक
* `lte`: से कम या के बराबर
* `lt`: से कम

<!-- request JSON -->
```json
POST /search
{
  "table":"test1",
  "query": {
    "range": {
      "price": {
        "gte": 500,
        "lte": 1000
      }
    }
  }
}
```
<!-- end -->

### भू-दूरी फ़िल्टर

<!-- example geo -->
`geo_distance` फ़िल्टर उन दस्तावेजों को फ़िल्टर करने के लिए उपयोग किए जाते हैं जो किसी भू स्थान से विशेष दूरी के भीतर होते हैं.

##### location_anchor
निर्दिष्ट पिन स्थान, डिग्री में. इस बिंदु से दूरियाँ मापी जाती हैं.

##### location_source
उन गुणों को निर्दिष्ट करता है जो अक्षांश और देशांतर रखते हैं.

##### distance_type
दूरी की गणना करने का फ़ंक्शन निर्दिष्ट करता है. यह अनुकूली या हावर्साइन हो सकता है. अनुकूली तेज और अधिक सटीक है, अधिक जानकारी के लिए `GEODIST()` देखें. वैकल्पिक, डिफ़ॉल्ट अनुकूली है.

##### दूरी
पिन स्थानों से अधिकतम दूरी निर्दिष्ट करता है. इस दूरी के भीतर सभी दस्तावेज़ मेल खाते हैं. दूरी विभिन्न इकाइयों में निर्धारित की जा सकती है. यदि कोई इकाई निर्दिष्ट नहीं की गई है, तो दूरी को मीटर में माना जाता है. समर्थित दूरी इकाइयों की एक सूची यहाँ है:

* मीटर: `m` या `meters`
* किलोमीटर: `km` या `kilometers`
* सेंटिमीटर: `cm` या `centimeters`
* मिलीमीटर: `mm` या `millimeters`
* मील: `mi` या `miles`
* गज: `yd` या `yards`
* फीट: `ft` या `feet`
* इंच: `in` या `inch`
* समुद्री मील: `NM`, `nmi` या `nauticalmiles`

`location_anchor` और `location_source` गुण निम्नलिखित अक्षांश/देशांतर प्रारूपों को स्वीकार करते हैं:

* एक ऑब्जेक्ट जिसमें lat और lon कुंजियाँ हैं: `{ "lat": "attr_lat", "lon": "attr_lon" }`
* निम्नलिखित संरचना का एक स्ट्रिंग: `"attr_lat, attr_lon"`
* अक्षांश और देशांतर को निम्नलिखित क्रम में एक सरणी: `[attr_lon, attr_lat]` में

अक्षांश और देशांतर डिग्री में निर्दिष्ट होते हैं.


<!-- request Basic example -->
```json
POST /search
{
  "table":"test",
  "query": {
    "geo_distance": {
      "location_anchor": {"lat":49, "lon":15},
      "location_source": {"attr_lat, attr_lon"},
      "distance_type": "adaptive",
      "distance":"100 km"
    }
  }
}
```

<!-- request Advanced example -->
`geo_distance` को बूल प्रश्नों में फ़िल्टर के रूप में उपयोग किया जा सकता है जो मैच या अन्य गुण फ़िल्टर के साथ होता है.

```json
POST /search
{
  "table": "geodemo",
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "*": "station"
          }
        },
        {
          "equals": {
            "state_code": "ENG"
          }
        },
        {
          "geo_distance": {
            "distance_type": "adaptive",
            "location_anchor": {
              "lat": 52.396,
              "lon": -1.774
            },
            "location_source": "latitude_deg,longitude_deg",
            "distance": "10000 m"
          }
        }
      ]
    }
  }
}
```

<!-- end -->
<!-- proofread -->































