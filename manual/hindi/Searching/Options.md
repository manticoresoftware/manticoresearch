# खोज विकल्प

SQL [SELECT](../Searching/Full_text_matching/Basic_usage.md#SQL) खंड और HTTP [/search](../Searching/Full_text_matching/Basic_usage.md#HTTP-JSON) अंतर्ग्रहण कुछ विकल्पों का समर्थन करते हैं जिन्हें खोज व्यवहार को सूक्ष्म बनाने के लिए उपयोग किया जा सकता है।

## विकल्प

### सामान्य व्याकरण

<!-- उदाहरण विकल्प -->

**SQL**:

```sql
SELECT ... [OPTION <optionname>=<value> [ , ... ]] [/*+ [NO_][ColumnarScan|DocidIndex|SecondaryIndex(<attribute>[,...])]] /*]
```

**HTTP**:
```json
POST /search
{   
    "table" : "table_name",
    "options":   
    {
        "optionname": "value",
        "optionname2": <value2>
    }
}
```


<!-- परिचय -->
SQL:
<!-- अनुरोध SQL -->
```sql
SELECT * FROM test WHERE MATCH('@title hello @body world')
OPTION ranker=bm25, max_matches=3000,
field_weights=(title=10, body=3), agent_query_timeout=10000
```

<!-- प्रतिक्रिया SQL -->
```sql
+------+-------+-------+
| id   | title | body  |
+------+-------+-------+
|    1 | hello | world |
+------+-------+-------+
1 row in set (0.00 sec)
```

<!-- परिचय -->
JSON:
<!-- अनुरोध JSON -->

```json
POST /search
{   
    "table" : "test",
    "query": {
      "match": {
        "title": "hello"
      },
      "match": {
        "body": "world"     
      }
    },
    "options":   
    {
        "ranker": "bm25",
        "max_matches": 3000,
        "field_weights": {
            "title": 10,
            "body": 3
        },
        "agent_query_timeout": 10000
    }
}
```

<!-- प्रतिक्रिया JSON -->

```json
{
  "took": 0,
  "timed_out": false,
  "hits": {
    "total": 1,
    "total_relation": "eq",
    "hits": [
      {
        "_id": 1,
        "_score": 10500,
        "_source": {
          "title": "hello",
          "body": "world"
        }
      }
    ]
  }
}
```

<!-- अंत -->

समर्थित विकल्प हैं:

### accurate_aggregation
पूर्णांक। कई थ्रेड्स में groupby प्रश्न चलाते समय सुनिश्चित कुल सटीकता को सक्षम या असक्षम करता है। डिफ़ॉल्ट मान 0 है।

जब groupby प्रश्न चलाया जाता है, तो इसे कई नकली शार्डों के साथ एक साधारण तालिका पर समानांतर रूप से चलाया जा सकता है (यदि `pseudo_sharding` चालू है)। एक समान दृष्टिकोण RT तालिकाओं पर भी काम करता है। प्रत्येक शार्ड/भाग प्रश्न को निष्पादित करता है, लेकिन समूहों की संख्या `max_matches` द्वारा सीमित है। यदि विभिन्न शार्डों/भागों से परिणाम समूह भिन्न होते हैं, तो समूह गणनाएं और जोड़ असमर्थित हो सकते हैं। ध्यान दें कि Manticore समूहबाय विशेषताओं के अद्वितीय मूल्यों की संख्या के आधार पर `max_matches` को [`max_matches_increase_threshold`](../Searching/Options.md#max_matches_increase_threshold) तक बढ़ाने का प्रयास करता है (जो द्वितीयक सूचियों से प्राप्त होता है)। यदि यह सफल होता है, तो सटीकता में कोई हानि नहीं होगी।

हालाँकि, यदि समूहबाय विशेषता के अद्वितीय मूल्यों की संख्या अधिक है, तो `max_matches` को और बढ़ाना एक अच्छी रणनीति नहीं हो सकती है क्योंकि इससे प्रदर्शन में हानि और अधिक मेमोरी उपयोग हो सकता है। `accurate_aggregation` को 1 पर सेट करने से groupby खोजों को एकल थ्रेड में चलाने के लिए मजबूर करता है, जो सटीकता की समस्या को ठीक करता है। ध्यान दें कि एकल थ्रेड में चलाना केवल तब लागू किया जाता है जब `max_matches` को पर्याप्त ऊँचा नहीं सेट किया जा सके; अन्यथा, `accurate_aggregation=1` के साथ खोजें अभी भी कई थ्रेड्स में चलेंगी।

कुल मिलाकर, `accurate_aggregation` को 1 पर सेट करने से RT तालिकाओं और `pseudo_sharding=1` के साथ साधारण तालिकाओं में समूह गणना और जोड़ की सटीकता सुनिश्चित होती है। हानि यह है कि खोजें धीमी चलेंगी क्योंकि उन्हें एकल थ्रेड में संचालन करने के लिए मजबूर किया जाएगा।

हालाँकि, यदि हमारे पास एक RT तालिका और एक साधारण तालिका है जिसमें समान डेटा है, और हम `accurate_aggregation=1` के साथ एक प्रश्न चलाते हैं, तो हमें अभी भी भिन्न परिणाम मिल सकते हैं। यह इसलिए होता है क्योंकि डेमन RT और साधारण तालिका के लिए विभिन्न `max_matches` सेटिंग चुन सकता है, जो [`max_matches_increase_threshold`](../Searching/Options.md#max_matches_increase_threshold) सेटिंग के कारण होता है।

### agent_query_timeout
पूर्णांक। दूरस्थ प्रश्नों को पूरा करने के लिए प्रतीक्षा करने का अधिकतम समय मिलीसेकंड में, [इस अनुच्छेद](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_query_timeout) को देखें।

### boolean_simplify
`0` या `1` (`1` डिफ़ॉल्ट रूप से)। `boolean_simplify=1` प्रश्न को [सरल बनाने](../Searching/Full_text_matching/Boolean_optimization.md) को सक्षम करता है जिससे इसे तेज किया जा सके।

### टिप्पणी
स्ट्रिंग, उपयोगकर्ता टिप्पणी जो एक प्रश्न लॉग फ़ाइल में कॉपी की जाती है।

### cutoff
पूर्णांक। प्रक्रियाओं के लिए अधिकतम मिलान की संख्या को निर्दिष्ट करता है। यदि सेट नहीं किया गया है, तो Manticore एक उपयुक्त मान का चयन करेगा स्वचालित रूप से।

<!-- उदाहरण cutoff_aggregation -->

* `N = 0`: मिलानों की संख्या पर सीमा को अक्षम करता है।
* `N > 0`: Manticore को निर्देशित करता है कि वह जैसे ही उसे `N` मिलान दस्तावेज़ मिलते हैं, परिणामों को संसाधित करना बंद कर दे।
* सेट नहीं किया गया: Manticore स्वचालित रूप से सीमा निर्धारित करता है।

जब Manticore मिलान दस्तावेजों की सटीक संख्या निर्धारित नहीं कर सकता है, तो प्रश्न [मेटा सूचना](../Node_info_and_management/SHOW_META.md#SHOW-META) में `total_relation` फ़ील्ड `gte` दिखाएगा, जिसका अर्थ है **बड़ा या समान**। यह यह इंगित करता है कि मिलानों की वास्तविक संख्या कम से कम रिपोर्ट की गई `total_found` (SQL में) या `hits.total` (JSON में) है। जब संख्या सटीक होती है, `total_relation` `eq` प्रदर्शित करेगा।

नोट: समेकन प्रश्नों में `cutoff` का उपयोग करना अनुशंसित नहीं है क्योंकि यह असत्य या अधूरी परिणाम उत्पन्न कर सकता है।

<!-- अनुरोध उदाहरण -->

समेकन प्रश्नों में `cutoff` का उपयोग करना गलत या भ्रामक परिणामों की ओर ले जा सकता है, जैसा कि निम्नलिखित उदाहरण में दिखाया गया है:
```
drop table if exists t
--------------

Query OK, 0 rows affected (0.02 sec)

--------------
create table t(a int)
--------------

Query OK, 0 rows affected (0.04 sec)

--------------
insert into t(a) values(1),(2),(3),(1),(2),(3)
--------------

Query OK, 6 rows affected (0.00 sec)

--------------
select avg(a) from t option cutoff=1 facet a
--------------

+----------+
| avg(a)   |
+----------+
| 1.000000 |
+----------+
1 row in set (0.00 sec)
--- 1 out of 1 results in 0ms ---

+------+----------+
| a    | count(*) |
+------+----------+
|    1 |        1 |
+------+----------+
1 row in set (0.00 sec)
--- 1 out of 1 results in 0ms ---
```

Compare it with the same query without `cutoff`:
```
--------------
select avg(a) from t facet a
--------------

+----------+
| avg(a)   |
+----------+
| 2.000000 |
+----------+
1 row in set (0.00 sec)
--- 1 out of 1 results in 0ms ---

+------+----------+
| a    | count(*) |
+------+----------+
|    1 |        2 |
|    2 |        2 |
|    3 |        2 |
+------+----------+
3 rows in set (0.00 sec)
--- 3 out of 3 results in 0ms ---
```

<!-- end -->

### distinct_precision_threshold
पूर्णांक। डिफ़ॉल्ट `3500` है। यह विकल्प उस सीमा को सेट करता है जिसके नीचे `count distinct` द्वारा लौटाए गए गणनाएँ एक साधारण तालिका के भीतर सटीक होने की गारंटी होती है।

स्वीकृत मान `500` से `15500` के बीच होते हैं। इस सीमा के बाहर वाले मानों को रोका जाएगा।

जब इस विकल्प को 0 पर सेट किया जाता है, तो यह एक एल्गोरिदम को सक्षम करता है जो सटीक गणनाओं की सुनिश्चितता करता है। यह एल्गोरिदम `{group, value}` जोड़े एकत्र करता है, उन्हें क्रमबद्ध करता है, और आवधिक रूप से डुप्लिकेट को समाप्त करता है। परिणाम एक साधारण तालिका के भीतर सटीक गणनाएँ होती हैं। हालाँकि, यह दृष्टिकोण उच्च-कार्डिनालिटी डेटा सेट के लिए उपयुक्त नहीं है क्योंकि इसकी उच्च मेमोरी खपत और धीमी क्वेरी निष्पादन होती है।

जब `distinct_precision_threshold` को `0` से अधिक मान पर सेट किया जाता है, तो Manticore एक अलग एल्गोरिदम का उपयोग करता है। यह गणनाओं को एक हैश तालिका में लोड करता है और तालिका के आकार को लौटाता है। यदि हैश तालिका बहुत बड़ी हो जाती है, तो इसकी सामग्री को `HyperLogLog` डेटा संरचना में स्थानांतरित कर दिया जाता है। इस बिंदु पर, गणनाएँ लगभग हो जाती हैं क्योंकि HyperLogLog एक संभाव्य एल्गोरिदम है। यह दृष्टिकोण प्रति समूह एक निश्चित अधिकतम मेमोरी उपयोग को बनाए रखता है, लेकिन गणना की सटीकता में एक व्यापारिक समझौता होता है।

`HyperLogLog` की सटीकता और हैश तालिका से HyperLogLog में परिवर्तित करने के लिए सीमा `distinct_precision_threshold` सेटिंग से निकाली जाती है। यह विकल्प का उपयोग करते समय सावधानी बरतना महत्वपूर्ण है क्योंकि इसके मान को दो गुना करने से गणनाओं की गणना के लिए आवश्यक अधिकतम मेमोरी भी दो गुना हो जाएगी। अधिकतम मेमोरी उपयोग का मोटे तौर पर इस सूत्र का उपयोग करके अनुमान लगाया जा सकता है: `64 * max_matches * distinct_precision_threshold`, हालाँकि प्रथात्मक रूप में, गणना की गणनाएँ अक्सर सबसे खराब स्थिति के परिदृश्य की तुलना में कम मेमोरी का उपयोग करती हैं।

### expand_keywords
`0` या `1` (`0` डिफ़ॉल्ट रूप से)। उपलब्ध होने पर सही रूप और/या सितारों के साथ कीवर्ड का विस्तार करता है। अधिक विवरण के लिए [expand_keywords](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expand_keywords) देखें।

### field_weights
नामित पूर्णांक सूची (रैंकिंग के लिए प्रति-फ़ील्ड उपयोगकर्ता वजन)।

उदाहरण:
```sql
SELECT ... OPTION field_weights=(title=10, body=3)
```

### global_idf
IDF गणनाओं के लिए [global_idf](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#global_idf) फ़ाइल से वैश्विक सांख्यिकी (आवृत्तियाँ) का उपयोग करें।

### idf
उद्धृत, अल्पविराम से अलग की गई IDF गणना ध्वज की सूची। ज्ञात ध्वज हैं:

* `normalized`: BM25 प्रकार, idf = log((N-n+1)/n), जैसा कि रॉबर्टसन एट अल द्वारा
* `plain`: साधारण प्रकार, idf = log(N/n), जैसा कि स्पार्क-जोन्स द्वारा
* `tfidf_normalized`: अतिरिक्त रूप से IDF को क्वेरी शब्दों की संख्या से विभाजित करें, ताकि `TF*IDF` [0, 1] सीमा में फिट हो सके
* `tfidf_unnormalized`: N संग्रह का आकार है और n मेल खाने वाले दस्तावेजों की संख्या है, जहाँ IDF को अतिरिक्त रूप से नहीं विभाजित किया जाता है

Manticore में ऐतिहासिक डिफ़ॉल्ट IDF (Inverse Document Frequency) `OPTION idf='normalized,tfidf_normalized'` के बराबर है, और ये सामान्यीकरण कई अवांछित प्रभाव पैदा कर सकते हैं।

पहले, `idf=normalized` कीवर्ड को दंडित करता है। उदाहरण के लिए, यदि आप `the | something` के लिए खोजते हैं और `the` 50% से अधिक दस्तावेज़ों में होता है, तो `the` और `something` दोनों कीवर्ड वाले दस्तावेज़ों को केवल एक कीवर्ड `something` वाले दस्तावेज़ों की तुलना में कम वजन मिलेगा। `OPTION idf=plain` का उपयोग इससे बचता है। साधारण IDF `[0, log(N)]` सीमा में भिन्न होता है और कीवर्ड कभी दंडित नहीं होते; जबकि सामान्यीकृत IDF `[-log(N), log(N)]` सीमा में भिन्न होता है, और बहुत बार होने वाले कीवर्ड दंडित होते हैं।

दूसरे, `idf=tfidf_normalized` क्वेरियों के बीच IDF के स्थानांतरण की ओर ले जाता है। ऐतिहासिक रूप से, IDF को भी क्वेरी कीवर्ड गणना से विभाजित किया गया था, यह सुनिश्चित करते हुए कि सभी कीवर्ड्स के सभी `sum(tf*idf)` [0,1] सीमा के भीतर रहे। हालाँकि, इसका मतलब यह था कि `word1` और `word1 | nonmatchingword2` जैसे क्वेरीज समान परिणाम सेट को अलग-अलग वजन देंगे, क्योंकि `word1` और `nonmatchingword2` दोनों के लिए IDFs को 2 से विभाजित किया जा रहा था। `OPTION idf='tfidf_unnormalized'` का उपयोग इस मुद्दे को हल करता है। ध्यान दें कि जब आप इस सामान्यीकरण को अक्षम करते हैं तो BM25, BM25A, BM25F() रैंकिंग कारक को तदनुसार समायोजित किया जाएगा।

IDF ध्वजों को संयोजित किया जा सकता है; `plain` और `normalized` परस्पर असंगत हैं; `tfidf_unnormalized` और `tfidf_normalized` भी परस्पर असंगत हैं; और ऐसे परस्पर असंगत समूहों में निर्दिष्ट ध्वज उनके मौलिक सेटिंग्स पर डिफ़ॉल्ट होते हैं। इसका मतलब है कि `OPTION idf=plain` पूरी तरह से `OPTION idf='plain,tfidf_normalized'` को निर्दिष्ट करने के समान है।

### jieba_mode
क्वेरी के लिए Jieba विभाजन मोड को निर्दिष्ट करता है।

जब Jieba चीनी विभाजन का उपयोग करते हैं, तो यह कभी-कभी दस्तावेज़ों और क्वेरी के लिए विभाजन के विभिन्न मोड का उपयोग करने में मदद कर सकता है। मोड की पूर्ण सूची के लिए, [jieba_mode](Creating_a_table/NLP_and_tokenization/Morphology.md#jieba_mode) देखें।

### index_weights
नामित पूर्णांक सूची। रैंकिंग के लिए प्रति-तालिका उपयोगकर्ता वजन।

### local_df
`0` या `1`, स्थानीय तालिका के सभी स्थानीय भागों में स्वचालित रूप से DF को जोड़ें, यह सुनिश्चित करते हुए कि एक स्थानीय रूप से विभाजित तालिका के भीतर संगत (और सटीक) IDF हो। RT तालिका के डिस्क क्षणों के लिए डिफ़ॉल्ट रूप से सक्षम। वाइल्डकार्ड के साथ क्वेरी शब्दों को अनदेखा किया जाता है।

### low_priority
`0` या `1` (`0` डिफ़ॉल्ट के रूप में)। `low_priority=1` सेट करने से सामान्य प्राथमिकता वाले अन्य प्रश्नों की तुलना में इसकी नौकरियों को 10 गुना कम बार पुनर्निर्धारित करके प्रश्न को कम प्राथमिकता के साथ निष्पादित किया जाता है।

### max_matches
पूर्णांक। प्रति-प्रश्न अधिकतम मिलान मान।

अधिकतम मिलानों की संख्या जो सर्वर हर तालिका के लिए RAM में बनाए रखता है और ग्राहक को वापस कर सकता है। डिफ़ॉल्ट 1000 है।

RAM उपयोग को नियंत्रित और सीमित करने के लिए पेश किया गया, `max_matches` सेटिंग यह निर्धारित करती है कि प्रत्येक तालिका को खोजते समय RAM में कितने मिलान बनाए रखे जाएंगे। हर मिलान जो पाया जाता है, उसे अभी भी प्रोसेस किया जाता है, लेकिन उनमें से केवल सबसे अच्छे N को ही मेमोरी में बनाए रखा जाएगा और अंत में ग्राहक को वापस किया जाएगा। उदाहरण के लिए, मान लीजिए कि एक तालिका में 2,000,000 मिलान हैं। आपको शायद ही कभी उन सभी को पुनः प्राप्त करने की आवश्यकता होगी। इसके बजाय, आपको सभी का स्कैन करना है, लेकिन उदाहरण के लिए कुछ मानदंडों के आधार पर केवल "सर्वश्रेष्ठ" 500 का चयन करना है (जैसे, प्रासंगिकता, कीमत या अन्य कारकों के अनुसार क्रमबद्ध) और अंतिम उपयोगकर्ता को 20 से 100 मिलानों वाले पृष्ठों में उन 500 मिलानों को प्रदर्शित करना है। केवल सबसे अच्छे 500 मिलानों का ट्रैक रखना सभी 2,000,000 मिलानों को बनाए रखने, उन्हें क्रमबद्ध करने और फिर खोज परिणाम पृष्ठ के लिए आवश्यक पहले 20 को छोड़ने की तुलना में RAM और CPU के लिए अधिक प्रभावी है। `max_matches` उस "सर्वश्रेष्ठ N" मात्रा में N को नियंत्रित करता है।

यह पैरामीटर प्रति-प्रश्न RAM और CPU उपयोग पर महत्वपूर्ण प्रभाव डालता है। 1,000 से 10,000 के मान सामान्यतः स्वीकार्य होते हैं, लेकिन उच्चतम सीमाओं का उपयोग सावधानी से करना चाहिए। ध्यानहीनता से max_matches को 1,000,000 में बढ़ाने का अर्थ है कि `searchd` को हर प्रश्न के लिए 1-मिलियन-एंट्री मिलान बफर आवंटित और प्रारंभ करने के लिए मजबूर होना पड़ेगा। इससे अनिवार्य रूप से प्रति-प्रश्न RAM उपयोग में वृद्धि होगी और, कुछ मामलों में, प्रदर्शन को स्पष्ट रूप से प्रभावित कर सकती है।

`max_matches` विकल्प के व्यवहार को प्रभावित करने के बारे में अतिरिक्त जानकारी के लिए [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold) देखें।

### max_matches_increase_threshold

पूर्णांक। सेटिंग `max_matches` को बढ़ाने के लिए थ्रेशोल्ड निर्धारित करता है। डिफ़ॉल्ट 16384 है।

Manticore `max_matches` को बढ़ा सकता है ताकि जब `pseudo_sharding` सक्षम हो और यदि यह पहचानता है कि समूहबाय विशेषता के अद्वितीय मानों की संख्या इस थ्रेशोल्ड से कम है, तो समूहबाय और/या समग्रता सटीकता को बढ़ाया जा सके। सटीकता का ह्रास तब हो सकता है जब pseudo-sharding कई थ्रेड में प्रश्न को निष्पादित करता है या जब एक RT तालिका डिस्क के टुकड़ों में समानांतर खोजें करती है।

यदि समूहबाय विशेषता के अद्वितीय मानों की संख्या थ्रेशोल्ड से कम है, तो `max_matches` इस संख्या पर सेट किया जाएगा। अन्यथा, डिफ़ॉल्ट `max_matches` का उपयोग किया जाएगा।

यदि `max_matches` को प्रश्न विकल्पों में स्पष्ट रूप से सेट किया गया था, तो इस थ्रेशोल्ड का कोई प्रभाव नहीं है।

ध्यान दें कि यदि यह थ्रेशोल्ड बहुत ऊँचा सेट किया गया है, तो यह मेमोरी खपत और सामान्य प्रदर्शन में गिरावट का परिणाम देगा।

आप [accurate_aggregation](../Searching/Options.md#accurate_aggregation) विकल्प का उपयोग करके एक गारंटीकृत समूहबाय/एग्रीगेट सटीकता मोड भी लागू कर सकते हैं।

### max_query_time
मिलिसेकंड में अधिकतम खोज प्रश्न समय सेट करता है। इसे एक गैर- नकारात्मक पूर्णांक होना चाहिए। डिफ़ॉल्ट मान 0 है, जिसका अर्थ है "सीमा न लगाएं।" स्थानीय खोज प्रश्नों को एक बार निर्दिष्ट समय बीत जाने पर रोक दिया जाएगा। ध्यान दें कि यदि आप एक खोज कर रहे हैं जो कई स्थानीय तालिकाओं को पूछती है, तो यह सीमा प्रत्येक तालिका पर अलग से लागू होती है। यह ध्यान रखना चाहिए कि यह प्रश्न के प्रतिक्रिया समय को थोड़ा बढ़ा सकता है, क्योंकि यह लगातार ट्रैक करने के कारण ओवरहेड होता है कि क्या प्रश्न को रोकने का समय आ गया है।

### max_predicted_time
पूर्णांक। अधिकतम अनुमानित खोज समय; देखें [predicted_time_costs](../Server_settings/Searchd.md#predicted_time_costs)。

### morphology
`none` सभी प्रश्न शर्तों को उनके पूर्ण रूपों के साथ बदलने की अनुमति देता है यदि तालिका को [index_exact_words](../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words) सक्षम के साथ बनाया गया था। यह प्रश्न शर्तों के स्टेमिंग या लेम्माटाइजिंग को रोकने के लिए उपयोगी है।

### not_terms_only_allowed
<!-- example not_terms_only_allowed -->
`0` या `1` प्रश्न के लिए स्टैंडअलोन [नकारात्मक](../Searching/Full_text_matching/Operators.md#Negation-operator) की अनुमति देता है। डिफ़ॉल्ट 0 है। संबंधित [वैश्विक सेटिंग](../Server_settings/Searchd.md#not_terms_only_allowed) को भी देखें।

<!-- request SQL -->
```sql
MySQL [(none)]> select * from tbl where match('-donald');
ERROR 1064 (42000): index t: query error: query is non-computable (single NOT operator)
MySQL [(none)]> select * from t where match('-donald') option not_terms_only_allowed=1;
+---------------------+-----------+
| id                  | field     |
+---------------------+-----------+
| 1658178727135150081 | smth else |
+---------------------+-----------+
```
<!-- end -->

### ranker
निम्नलिखित विकल्पों में से चयन करें:
* `proximity_bm25`
* `bm25`
* `none`
* `wordcount`
* `proximity`
* `matchany`
* `fieldmask`
* `sph04`
* `expr`
* `export`

प्रत्येक रैंकर्स के बारे में अधिक विवरण के लिए [खोज परिणाम रैंकिंग](../Searching/Sorting_and_ranking.md#Available-built-in-rankers) देखें।

### rand_seed
आपको एक `ORDER BY RAND()` प्रश्न के लिए एक विशिष्ट पूर्णांक बीज मूल्य निर्दिष्ट करने की अनुमति देता है, उदाहरण के लिए: `... OPTION rand_seed=1234`। डिफ़ॉल्ट रूप से, हर प्रश्न के लिए एक नया और अलग बीज मूल्य स्वतः उत्पन्न होता है।

### retry_count
पूर्णांक। वितरित पुनः प्रयासों की संख्या।

### retry_delay
पूर्णांक। वितरित पुनः प्रयास में देरी, मिलिसेकंड में।

### scroll

स्ट्रिंग। [स्क्रॉल पृष्ठन दृष्टिकोण](../Searching/Pagination.md#Scroll-Search-Option) का उपयोग करके परिणामों को पृष्ठबद्ध करने के लिए एक स्क्रॉल टोकन।

### sort_method
* `pq` - प्राथमिकता कतार, डिफ़ॉल्ट द्वारा सेट
* `kbuffer` - पहले से क्रमबद्ध डेटा के लिए तेज़ क्रमबद्धता प्रदान करता है, जैसे कि पहचान के अनुसार क्रमबद्ध तालिका डेटा
परिणाम सेट दोनों मामलों में समान है; एक विकल्प या दूसरे का चयन करना केवल प्रदर्शन को बेहतर (या खराब) कर सकता है।

### threads
वर्तमान प्रश्न निष्पादन के लिए प्रयुक्त अधिकतम थ्रेड्स की संख्या सीमित करता है। डिफ़ॉल्ट - कोई सीमा नहीं (प्रश्न सभी [थ्रेड](../Server_settings/Searchd.md#threads) पर कब्जा कर सकता है जैसा कि वैश्विक रूप से परिभाषित किया गया है)।
किसी प्रश्नों के समूह के लिए, विकल्प को समूह में पहले प्रश्न के साथ संलग्न किया जाना चाहिए, और इसे तब लागू किया जाता है जब कार्यकारी कतार बनाई जाती है और यह पूरे समूह के लिए प्रभावी होता है। इस विकल्प का वही अर्थ है जैसा कि विकल्प [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query) का है, लेकिन इसे केवल वर्तमान प्रश्न या प्रश्नों के समूह पर लागू किया जाता है।

### token_filter
उद्धृत, केवल कॉलन द्वारा पृथक स्ट्रिंग `पुस्तकालय का नाम:प्लगइन नाम:वैकल्पिक सेटिंग्स की स्ट्रिंग`। प्रत्येक खोज के लिए एक प्रश्न-समय टोकन फ़िल्टर बनाया जाता है जब हर शामिल तालिका द्वारा पूर्ण-पाठ उत्तेजित किया जाता है, जिससे आप एक कस्टम टोकनाइज़र लागू कर सकते हैं जो कस्टम नियमों के अनुसार टोकन उत्पन्न करता है।
```sql
SELECT * FROM index WHERE MATCH ('yes@no') OPTION token_filter='mylib.so:blend:@'
```
### expansion_limit
एकल वाइल्डकार्ड के लिए अधिकतम विस्तारित कीवर्ड की संख्या को सीमित करता है, जिसमें डिफ़ॉल्ट मान 0 है यानी कोई सीमा नहीं है। अतिरिक्त विवरण के लिए, देखें [expansion_limit](../Server_settings/Searchd.md#expansion_limit).

## प्रश्न ऑप्टिमाइज़र सुझाव

<!-- example options_force -->

दुर्लभ मामलों में, Manticore का अंतर्निहित प्रश्न विश्लेषक एक प्रश्न को समझने और यह निर्धारित करने में गलत हो सकता है कि क्या एक डॉकिड स्थानांतर, द्वितीयक स्थानांतर, या कॉलम स्कैन का उपयोग किया जाना चाहिए। प्रश्न ऑप्टिमाइज़र के निर्णयों को ओवरराइड करने के लिए, आप अपने प्रश्न में निम्नलिखित सुझावों का उपयोग कर सकते हैं:

* `/*+ DocidIndex(id) */`  डॉकिड स्थानांतर के उपयोग को मजबूर करने के लिए, `/*+ NO_DocidIndex(id) */` ऑप्टिमाइज़र को इसे अनदेखा करने के लिए बताने के लिए
* `/*+ SecondaryIndex(<attr_name1>[, <attr_nameN>]) */` द्वितीयक स्थानांतर के उपयोग को मजबूर करने के लिए (यदि उपलब्ध है), `/*+ NO_SecondaryIndex(id) */` ऑप्टिमाइज़र को इसे अनदेखा करने के लिए बताने के लिए
* `/*+ ColumnarScan(<attr_name1>[, <attr_nameN>]) */`  कॉलम स्कैन के उपयोग को मजबूर करने के लिए (यदि विशेषता कॉलम है), `/*+ NO_ColumnarScan(id) */` ऑप्टिमाइज़र को इसे अनदेखा करने के लिए बताने के लिए

ध्यान दें कि जब फ़िल्टर के साथ पूर्ण-पाठ प्रश्न को कार्यान्वित किया जाता है, तो प्रश्न ऑप्टिमाइज़र यह तय करता है कि फ़िल्टर परिणामों के साथ पूर्ण-पाठ पेड़ के परिणामों को इंटरसेक्ट करना है या मानक मिलान-फिर-फ़िल्टर दृष्टिकोण का उपयोग करना है। *किसी भी* सुझाव को निर्दिष्ट करने से डेमन को पूर्ण-पाठ पेड़ के परिणामों और फ़िल्टर परिणामों के इंटरसेक्शन को करने वाले कोड पथ का उपयोग करने के लिए मजबूर किया जाएगा।

प्रश्न ऑप्टिमाइज़र कैसे काम करता है, इसके बारे में अधिक जानकारी के लिए, [Cost based optimizer](../Searching/Cost_based_optimizer.md) पृष्ठ पर जाएं।

<!-- request SQL -->

```sql
SELECT * FROM students where age > 21 /*+ SecondaryIndex(age) */
```

<!-- end -->

<!-- example comments -->
MySQL/MariaDB क्लाइंट का उपयोग करते समय, अपने प्रश्नों में सुझावों को सक्षम करने के लिए `--comments` ध्वज को शामिल करना सुनिश्चित करें।

<!-- request mysql -->
```bash
mysql -P9306 -h0 --comments
```
<!-- end -->

<!-- proofread -->
