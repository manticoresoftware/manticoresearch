# क्वेरी कैश

क्वेरी कैश संकुचित परिणाम सेट को मेमोरी में संग्रहित करता है और आवश्यकतानुसार इसे अगले प्रश्नों के लिए पुन: उपयोग करता है। आप इसे निम्नलिखित आदेशों का उपयोग करके कॉन्फ़िगर कर सकते हैं:

* [qcache_max_bytes](../Server_settings/Searchd.md#qcache_max_bytes), कैश किए गए क्वेरी स्टोरेज के लिए RAM उपयोग पर सीमा। डिफ़ॉल्ट रूप से 16 MB है। `qcache_max_bytes` को 0 सेट करने से क्वेरी कैश पूरी तरह से अक्षम हो जाती है।
* [qcache_thresh_msec](../Server_settings/Searchd.md#qcache_thresh_msec), कैश करने के लिए न्यूनतम दीवार क्वेरी समय। ऐसे क्वेरी जो इससे अधिक तेज़ी से पूरा होते हैं *कैश* नहीं किए जाएंगे। डिफ़ॉल्ट रूप से 3000 मिलीसेकेंड, या 3 सेकंड है।
* [qcache_ttl_sec](../Server_settings/Searchd.md#qcache_ttl_sec), कैश किए गए प्रविष्टि TTL, या जीवनकाल। क्वेरी इस अवधि के लिए कैश में रहेंगी। डिफ़ॉल्ट रूप से 60 सेकंड, या 1 मिनट है।

इन सेटिंग्स को `SET GLOBAL` बयान का उपयोग करके विस्तारित रूप से बदला जा सकता है:

```sql
mysql> SET GLOBAL qcache_max_bytes=128000000;
```

ये परिवर्तन तुरंत लागू होते हैं, और कैश किए गए परिणाम सेट जो अब बाधाओं को पूरा नहीं करते हैं तुरंत हटा दिए जाते हैं। फ्लाई पर कैश के आकार को कम करने पर, MRU (सबसे हाल में उपयोग किए गए) परिणाम सेट जीतते हैं।

क्वेरी कैश इस प्रकार संचालित होता है। जब सक्षम होता है, तो हर पूर्ण-पाठ खोज का परिणाम पूरी तरह से मेमोरी में संग्रहीत होता है। यह पूर्ण-टेक्स्ट मिलान, छानबीन, और रैंकिंग के बाद होता है, इसलिए मूल रूप से हम `total_found` {docid,weight} जोड़े संग्रहित करते हैं। संकुचित मिलान औसतन प्रत्येक मिलान पर 2 बाइट से 12 बाइट तक ले सकते हैं, ज्यादातर शर्तों के बीच अंतर के आधार पर। क्वेरी समाप्त होने के बाद, हम दीवार का समय और आकार सीमा जांचते हैं, और या तो पुनः उपयोग के लिए संकुचित परिणाम सेट को बचाते हैं या इसे हटा देते हैं।

ध्यान दें कि क्वेरी कैश का RAM पर प्रभाव `qcache_max_bytes` द्वारा सीमित नहीं है! यदि आप, उदाहरण के लिए, 10 समवर्ती प्रश्न चलाते हैं, प्रत्येक में 1M मिलान (फिल्टर के बाद) होते हैं, तो अधिकतम अस्थायी RAM उपयोग 40 MB से 240 MB के बीच होगा, भले ही प्रश्न पर्याप्त तेज़ हों और कैश न हों।

क्वेरी कैश का उपयोग कर सकती है जब तालिका, पूर्ण-शब्द प्रश्न (यानी, `MATCH()` सामग्री), और रेंकर सभी मेल खाते हैं, और फ़िल्टर संगत होते हैं। इसका मतलब है:

*   `MATCH()` के भीतर पूर्ण-टेक्स्ट भाग को बाइटवार मिलान होना चाहिए। एक अतिरिक्त स्थान जोड़ें, और यह अब क्वेरी कैश के दृष्टिकोण से एक अलग प्रश्न है।
*   रेंकर (और इसके पैरामीटर, यदि कोई हो, उपयोगकर्ता-परिभाषित रेंकरों के लिए) को बाइटवार मिलान होना चाहिए।
*   फ़िल्टरों को मूल फ़िल्टरों का सुपरसेट होना चाहिए। आप अतिरिक्त फ़िल्टर जोड़ सकते हैं और फिर भी कैश को हिट कर सकते हैं। (इस मामले में, अतिरिक्त फ़िल्टर कैश किए गए परिणाम पर लागू होंगे।) लेकिन यदि आप एक को हटा देते हैं, तो वह फिर से एक नई क्वेरी होगी।

कैश प्रविष्टियाँ TTL के साथ समाप्त होती हैं और तालिका घुमाने पर, या `TRUNCATE`, या `ATTACH` पर भी अमान्य कर दी जाती हैं। वर्तमान में, ध्यान दें कि प्रविष्टियाँ मनमानी RT तालिका लेखन पर अमान्य नहीं होती हैं! इसलिए एक कैश की गई क्वेरी अपनी TTL के दौरान पुराने परिणाम लौटा सकती है।

आप [SHOW STATUS](../Node_info_and_management/Node_status.md#SHOW-STATUS) के माध्यम से वर्तमान कैश स्थिति का निरीक्षण कर सकते हैं `qcache_XXX` वेरिएबल्स के साथ:

```sql
mysql> SHOW STATUS LIKE 'qcache%';
+-----------------------+----------+
| काउंटर                | मान      |
+-----------------------+----------+
| qcache_max_bytes      | 16777216 |
| qcache_thresh_msec    | 3000     |
| qcache_ttl_sec        | 60       |
| qcache_cached_queries | 0        |
| qcache_used_bytes     | 0        |
| qcache_hits           | 0        |
+-----------------------+----------+
6 पंक्तियाँ सेट में (0.00 सेकंड)
```
<!-- proofread -->
