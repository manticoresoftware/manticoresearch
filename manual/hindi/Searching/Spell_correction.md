# वर्तनी सुधार

वर्तनी सुधार, जिसे निम्नलिखित के रूप में भी जाना जाता है:

* स्वचालित सुधार
* पाठ सुधार
* वर्तनी त्रुटियों को ठीक करना
* टाइपो सहिष्णुता
* "क्या आप इसका मतलब समझते हैं?"

और इसी तरह, एक ऐसा सॉफ़्टवेयर कार्यक्षमता है जो आपके द्वारा टाइप किए गए पाठ के लिए विकल्पों का सुझाव देती है या स्वचालित रूप से सुधार करती है। टाइप किए गए पाठ को सुधारने की अवधारणा 1960 के दशक तक जाती है जब कंप्यूटर विज्ञान के विशेषज्ञ वॉरेन टेइटलमैन, जिन्होंने "पूर्ववत" कमांड को भी बनाया, ने "D.W.I.M." नामक कंप्यूटिंग की एक दार्शनिकता पेश की, या "जो मैं मतलब करता हूँ।" कंप्यूटरों को केवल बुनियादी सामान्य निर्देश स्वीकार करने के लिए प्रोग्राम करने के बजाय, टेइटलमैन ने argued किया कि उन्हें स्पष्ट गलतियों को पहचानने के लिए प्रोग्राम किया जाना चाहिए।

वर्तनी सुधार कार्यक्षमता प्रदान करने वाला पहला प्रसिद्ध उत्पाद Microsoft Word 6.0 था, जो 1993 में जारी किया गया था।

### यह कैसे काम करता है

वर्तनी सुधार करने के कुछ तरीके हैं, लेकिन यह नोट करना महत्वपूर्ण है कि आपके गलत टाइप किए गए "ipone" को "iphone" में अच्छे गुणवत्ता के साथ परिवर्तित करने का कोई शुद्ध प्रोग्रामेटिक तरीका नहीं है। ज्यादातर, इसके लिए एक डेटासेट होना आवश्यक है जिस पर सिस्टम आधारित होता है। डेटासेट हो सकता है:

* सही वर्तनी वाले शब्दों का एक शब्दकोश, जो खुद में हो सकता है:
  * आपके वास्तविक डेटा पर आधारित। यहाँ विचार यह है कि, ज्यादातर मामलों में, आपके डेटा से बनता शब्दकोश में सही वर्तनी होती है, और सिस्टम उस शब्द को खोजने की कोशिश करता है जो टाइप किए गए शब्द के सबसे समान हो (हम अभी थोड़ी देर में मैन्टिकोरे के साथ यह कैसे किया जा सकता है इस पर चर्चा करेंगे)।
  * या यह आपके डेटा से अप्रासंगिक एक बाहरी शब्दकोश पर आधारित हो सकता है। यहाँ एक समस्या उत्पन्न हो सकती है कि आपके डेटा और बाहरी शब्दकोश बहुत भिन्न हो सकते हैं: कुछ शब्द शब्दकोश में गायब हो सकते हैं, जबकि अन्य आपके डेटा में गायब हो सकते हैं।
* केवल शब्दकोश आधारित नहीं, बल्कि संदर्भ-सचेत भी, जैसे, "white ber" को "white bear" में ठीक किया जाएगा, जबकि "dark ber" को "dark beer" में ठीक किया जाएगा। संदर्भ केवल आपके प्रश्न में एक पड़ोसी शब्द नहीं हो सकता है, बल्कि आपका स्थान, दिन का समय, वर्तमान वाक्य का व्याकरण (यह बदलने के लिए "there" से "their" या नहीं), आपका खोज इतिहास, और वास्तव में आपके इरादे को प्रभावित करने वाले किसी अन्य कारक हो सकते हैं।
* एक और पारंपरिक दृष्टिकोण यह है कि पिछले खोज प्रश्नों का उपयोग वर्तनी सुधार के लिए डेटासेट के रूप में किया जाए। इसका उपयोग [स्वनिर्धारण](../Searching/Autocomplete.md) कार्यक्षमता में और अधिक किया जाता है लेकिन यह स्वचालित सुधार के लिए भी समझ में आता है। विचार यह है कि उपयोगकर्ता ज्यादातर मामलों में वर्तनी के साथ सही होते हैं, इसलिए हम उनके खोज इतिहास से शब्दों का उपयोग सत्य के स्रोत के रूप में कर सकते हैं, भले ही हमारे दस्तावेज़ों में उन शब्दों की कमी हो या हम बाहरी शब्दकोश का उपयोग करें। संदर्भ-सचेतता यहाँ भी संभव है।

मैन्टिकोर फज़ी खोज विकल्प और `CALL QSUGGEST` और `CALL SUGGEST` कमांड प्रदान करता है, जिन्हें स्वचालित वर्तनी सुधार उद्देश्यों के लिए उपयोग किया जा सकता है।

## फज़ी खोज

फज़ी खोज सुविधा हल्की भिन्नताओं या गलत वर्तनी के लिए अधिक लचीला मिलान करने की अनुमति देती है। यह सामान्य `SELECT` SQL कथन या `/search` JSON अनुरोध के समान काम करता है लेकिन फज़ी मिलान व्यवहार को नियंत्रित करने के लिए अतिरिक्त पैरामीटर प्रदान करता है।

> नोट: `fuzzy` विकल्प की आवश्यकता है [Manticore Buddy](../Installation/Manticore_Buddy.md)। यदि यह काम नहीं करता है, तो सुनिश्चित करें कि बडी स्थापित है।

## सामान्य व्याकरण

### SQL

<!-- example Fuzzy_Search_SQL -->

```sql
SELECT
  ...
  MATCH('...')
  ...
  OPTION fuzzy={0|1}
  [, distance=N]
  [, layouts='{be,bg,br,ch,de,dk,es,fr,uk,gr,it,no,pt,ru,se,ua,us}']
}
```

नोट: जब SQL के माध्यम से फज़ी खोज करते हैं तो MATCH_clause कोई भी पूर्ण-ग्रंथ ऑपरेटर नहीं होना चाहिए, अपितु केवल वही शब्द शामिल किए जाने चाहिए जिनसे आप मेल करना चाहते हैं।

<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
SELECT * FROM mytable WHERE MATCH('someting') OPTION fuzzy=1, layouts='us,ua', distance=2;
```

<!-- request SQL with additional filters -->
अतिरिक्त फ़िल्टर के साथ एक अधिक जटिल फज़ी खोज अनुरोध का उदाहरण:

```sql
SELECT * FROM mytable WHERE MATCH('someting') OPTION fuzzy=1 AND (category='books' AND price < 20);
```

<!-- request JSON -->

```json
POST /search
{
  "table": "test",
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "*": "ghbdtn"
          }
        }
      ]
    }
  },
  "options": {
    "fuzzy": true,
    "layouts": ["us", "ru"],
    "distance": 2
  }
}
```

<!-- response SQL -->

```sql
+------+-------------+
| id   | content     |
+------+-------------+
|    1 | something   |
|    2 | some thing  |
+------+-------------+
2 rows in set (0.00 sec)
```

<!-- end -->

### JSON

```json
POST /search
{
  "table": "table_name",
  "query": {
    <full-text query>
  },
  "options": {
    "fuzzy": {true|false}
    [,"layouts": ["be","bg","br","ch","de","dk","es","fr","uk","gr","it","no","pt","ru","se","ua","us"]]
    [,"distance": N]
  }
}
```

नोट: यदि आप [query_string](../../Searching/Full_text_matching/Basic_usage.md#query_string) का उपयोग करते हैं, तो जान लें कि यह पूर्ण-ग्रंथ ऑपरेटरों का समर्थन नहीं करता है सिवाय [phrase search operator](../Searching/Full_text_matching/Operators.md#Phrase-search-operator)। क्वेरी स्ट्रिंग केवल उन्हीं शब्दों से मिलकर होनी चाहिए जिन्हें आप मेल करना चाहते हैं।

### विकल्प

- `fuzzy`: फज़ी खोज को चालू या बंद करें।
- `distance`: मेल करने के लिए लेवन्स्टरियन दूरी सेट करें। डिफ़ॉल्ट `2` है।
- `layouts`: टाइपिंग त्रुटियों की जांच के लिए कीबोर्ड लेआउट। सभी लेआउट डिफ़ॉल्ट रूप से उपयोग किए जाते हैं। इसे बंद करने के लिए खाली स्ट्रिंग `''` (SQL) या ऐरे `[]` (JSON) का उपयोग करें। समर्थित लेआउट में शामिल हैं:
  - `be` - बेल्जियन AZERTY लेआउट
  - `bg` - मानक बुल्गेरियाई लेआउट
  - `br` - ब्राज़ीलियाई QWERTY लेआउट
  - `ch` - स्विस QWERTZ लेआउट
  - `de` - जर्मन QWERTZ लेआउट
  - `dk` - डेनिश QWERTY लेआउट
  - `es` - स्पेनिश QWERTY लेआउट
  - `fr` - फ्रेंच AZERTY लेआउट
  - `uk` - ब्रिटिश QWERTY लेआउट
  - `gr` - ग्रीक QWERTY लेआउट
  - `it` - इटालियन QWERTY लेआउट
  - `no` - नॉर्वेजियन QWERTY लेआउट
  - `pt` - पुर्तगाली QWERTY लेआउट
  - `ru` - रूसी JCUKEN लेआउट
  - `se` - स्वीडिश QWERTY लेआउट
  - `ua` - यूक्रेनियन JCUKEN लेआउट
  - `us` - अमेरिकी QWERTY लेआउट
  ### लिंक
  * <a href="https://github.manticoresearch.com/manticoresoftware/manticoresearch?query=fature&filters%5Bcomment%5D%5B%5D=28798446&filters%5Bcommon%5D%5Brepo_id%5D%5B%5D=95614931&sort=&search=keyword-search-fuzzy-layouts">यह डेमो</a> फजी सर्च कार्यक्षमता को प्रदर्शित करता है:
  ![फजी सर्च उदाहरण](fuzzysearch.png){.scale-0.7}
  * फजी सर्च और ऑटो-कंप्लीट के बारे में ब्लॉग पोस्ट - https://manticoresearch.com/blog/new-fuzzy-search-and-autocomplete/
  ## CALL QSUGGEST, CALL SUGGEST
  दोनों कमांड SQL के माध्यम से पहुंच योग्य हैं और स्थानीय (सादा और वास्तविक समय) और वितरणिक तालिकाओं पर क्वेरी करने का समर्थन करते हैं। वाक्यविन्यास इस प्रकार है:
  ```sql
  CALL QSUGGEST(<शब्द या शब्द>, <तालिका नाम> [,विकल्प])
  CALL SUGGEST(<शब्द या शब्द>, <तालिका नाम> [,विकल्प])
  विकल्प: N के रूप में option_name[, M के रूप में another_option, ...]
  ```
  ये कमांड किसी दिए गए शब्द के लिए शब्दकोश से सभी सुझाव प्रदान करते हैं। वे केवल उन तालिकाओं पर कार्य करते हैं जिनमें [infixing](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) सक्षम है और [dict=keywords](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict) है। वे सुझावित कीवर्ड, सुझावित और मूल कीवर्ड के बीच लेवेंसटाइन दूरी, और सुझावित कीवर्ड के दस्तावेज़ आँकड़े लौटाते हैं।
  यदि पहला पैरामीटर कई शब्दों को शामिल करता है, तो:
  * `CALL QSUGGEST` केवल **अंतिम** शब्द के लिए सुझाव लौटाएगा, बाकी की अनदेखी करेगा।
  * `CALL SUGGEST` केवल **पहले** शब्द के लिए सुझाव लौटाएगा।
  यही उनके बीच का एकमात्र अंतर है। कस्टमाइज़ेशन के लिए कई विकल्प समर्थित हैं:
  | विकल्प | विवरण | डिफ़ॉल्ट |
  | - | - | - |
  | limit | N शीर्ष मिलान लौटाता है | 5 |
  | max_edits | केवल शब्दकोश के शब्दों को रखता है जिनकी लेवेंसटाइन दूरी N या उससे कम है | 4 |
  | result_stats | पाए गए शब्दों की लेवेंसटाइन दूरी और दस्तावेज़ की संख्या प्रदान करता है | 1 (सक्षम) |
  | delta_len | केवल उन शब्दकोश के शब्दों को रखता है जिनकी लंबाई का अंतर N से कम है | 3 |
  | max_matches | रखे जाने वाले मिलानों की संख्या | 25 |
  | reject | अस्वीकृत शब्द वे मिलान हैं जो पहले से ही मिलान कतार में मौजूद शब्दों से बेहतर नहीं हैं। उन्हें एक अस्वीकृत कतार में रखा जाता है जो तब रीसेट हो जाती है जब कोई वास्तव में मिलान कतार में जा सकता है। यह पैरामीटर अस्वीकृत कतार के आकार को परिभाषित करता है (जैसे reject*max(max_matched,limit))। यदि अस्वीकृत कतार भर जाती है, तो इंजन संभावित मिलानों की खोज करना बंद कर देता है | 4 |
  | result_line | डेटा को प्रदर्शित करने का वैकल्पिक मोड सभी सुझाव, दूरी और दस्तावेज़ों को प्रत्येक एक पंक्ति में लौटाता है | 0 |
  | non_char | ऐसे शब्दकोश के शब्दों को छोड़ें जिनमें गैर-अक्षर प्रतीक हों | 0 (ऐसे शब्दों को छोड़ना) |
  | sentence | मूल वाक्य लौटाता है जिसमें अंतिम शब्द का प्रतिस्थापन मिलाए गए शब्द के द्वारा किया गया है। | 0 (पूरे वाक्य को वापस न दें) |
  यह दिखाने के लिए कि यह कैसे काम करता है, एक तालिका बनाते हैं और इसमें कुछ दस्तावेज़ जोड़ते हैं।
  ```sql
  create table products(title text) min_infix_len='2';
  insert into products values (0,'क्रॉसबॉडी बैग विद टैसल'), (0,'माइक्रोफाइबर शीट सेट'), (0,'पेट हेयर रेमूवर ग्लव');
  ```
  <!-- उदाहरण एकल -->
  ##### एकल शब्द उदाहरण
  जैसा कि आप देख सकते हैं, गलत टाइप किया हुआ शब्द "क्रॉसब**U**डी" को "क्रॉसबॉडी" में सुधार किया गया है। डिफ़ॉल्ट रूप से, `CALL SUGGEST/QSUGGEST` लौटाता है:
  * `distance` - लेवेंसटाइन दूरी जिसका मतलब है कि दिए गए शब्द को सुझाव में परिवर्तित करने के लिए उन्हें कितने संपादन करने पड़े
  * `docs` - सुझावित शब्द को शामिल करने वाले दस्तावेजों की संख्या
  यदि आप इन आँकड़ों के प्रदर्शन को असक्रिय करना चाहते हैं, तो आप विकल्प `0 as result_stats` का उपयोग कर सकते हैं।
  <!-- परिचय -->
  ##### उदाहरण:
  <!-- अनुरोध उदाहरण -->
  ```sql
  call suggest('क्रॉसबडी', 'products');
  ```
  <!-- प्रतिक्रिया उदाहरण -->
  ```sql
  +-----------+----------+------+
  | सुझाव     | दूरी     | दस्तावेज़ |
  +-----------+----------+------+
  | क्रॉसबॉडी | 1        | 1    |
  +-----------+----------+------+
  ```
  <!-- अंत -->
  <!-- उदाहरण पहला -->
  ##### CALL SUGGEST केवल पहले शब्द को लेता है
  यदि पहला पैरामीटर एकल शब्द नहीं है, बल्कि कई हैं, तो `CALL SUGGEST` केवल पहले शब्द के लिए सुझाव लौटाएगा।
  <!-- परिचय -->
  ##### उदाहरण:
  <!-- अनुरोध उदाहरण -->
  ```sql
  call suggest('बैग विद टैसल', 'products');
  ```
  <!-- प्रतिक्रिया उदाहरण -->
  ```sql
  +---------+----------+------+
  | सुझाव   | दूरी     | दस्तावेज़ |
  +---------+----------+------+
  | बैग     | 1        | 1    |
  +---------+----------+------+
  ```
  <!-- अंत -->
  <!-- उदाहरण अंतिम -->
  ##### CALL QSUGGEST केवल अंतिम शब्द को लेता है
  यदि पहला पैरामीटर एकल शब्द नहीं है, बल्कि कई हैं, तो `CALL SUGGEST` केवल अंतिम शब्द के लिए सुझाव लौटाएगा।
  <!-- परिचय -->
  ##### उदाहरण:
  <!-- अनुरोध उदाहरण -->
  ```sql
  CALL QSUGGEST('बैग विद टैसल', 'products');
  ```
  <!-- प्रतिक्रिया उदाहरण -->
  ```sql
  +---------+----------+------+
  | सुझाव   | दूरी     | दस्तावेज़ |
  +---------+----------+------+
  | टैसल    | 1        | 1    |
  +---------+----------+------+
  ```
  <!-- अंत -->
  <!-- उदाहरण अंतिम2 -->
  `1 as sentence` जोड़ने से `CALL QSUGGEST` को अंतिम शब्द के सुधार के साथ पूरे वाक्य को वापस करने के लिए बनाता है। 
  <!-- अनुरोध उदाहरण -->
  ```sql
  CALL QSUGGEST('बैग विद टैसल', 'products', 1 as sentence);
  ```
  <!-- प्रतिक्रिया उदाहरण -->
  ```sql
  +-------------------+----------+------+
  | सुझाव             | दूरी     | दस्तावेज़ |
  +-------------------+----------+------+
  | बैग विद टैसल     | 1        | 1    |
  +-------------------+----------+------+
  ```
  <!-- अंत -->
  ##### विभिन्न प्रदर्शन मोड
`1 as result_line` विकल्प आउटपुट में सुझावों को प्रदर्शित करने के तरीके को बदलता है। प्रत्येक सुझाव को अलग पंक्तियों में दिखाने के बजाय, यह सभी सुझावों, दूरी और दस्तावेजों को एक ही पंक्ति में प्रदर्शित करता है। इसका प्रदर्शन करने के लिए एक उदाहरण यहां है:

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```sql
CALL QSUGGEST('bagg with tasel', 'products', 1 as result_line);
```
<!-- response Example -->

```sql
+----------+--------+
| name     | value  |
+----------+--------+
| suggests | tassel |
| distance | 1      |
| docs     | 1      |
+----------+--------+
```
<!-- end -->

### डेमो

* [यह इंटरएक्टिव कोर्स](https://play.manticoresearch.com/didyoumean/) दिखाता है कि `CALL SUGGEST` एक छोटे वेब ऐप में कैसे काम करता है।

![CALL SUGGEST उदाहरण](didyoumean.png){.scale-0.5}

<!-- proofread -->


































# वर्तनी सही करना

वर्तनी सही करना, जिसे के रूप में भी जाना जाता है:

* स्वचालित सुधार
* पाठ सुधार
* वर्तनी त्रुटियों को ठीक करना
* टाइपो सहिष्णुता
* "क्या आप चाहते थे?"

और इसी प्रकार, एक सॉफ़्टवेयर कार्यक्षमता है जो उस पाठ के विकल्प सुझाती है जिसे आपने टाइप किया है या अपने आप सुधार करती है। टाइप किए गए पाठ को ठीक करने का सिद्धांत 1960 के दशक में वापस जाता है जब कंप्यूटर वैज्ञानिक वॉरेन टेitelमैन, जिन्होंने "पूर्ववत" कमांड का भी आविष्कार किया, ने D.W.I.M. नामक कंप्यूटिंग का एक सिद्धांत पेश किया, या "जो मैं मतलब है उसे करो।" टेitelमैन ने तर्क किया कि कंप्यूटरों को केवल पूरी तरह से फ़ॉर्मेट किए गए निर्देशों को स्वीकार करने के लिए प्रोग्राम बनाने के बजाय, उन्हें स्पष्ट गलतियों को पहचानने के लिए प्रोग्राम करना चाहिए।

वर्तनी सुधार कार्यक्षमता प्रदान करने वाला पहला प्रसिद्ध उत्पाद माइक्रोसॉफ्ट वर्ड 6.0 था, जो 1993 में जारी किया गया था।

### यह कैसे काम करता है

वर्तनी सुधार करने के कुछ तरीके हैं, लेकिन यह ध्यान रखना महत्वपूर्ण है कि आपके गलत टाइप किए गए "ipone" को "iphone" में उचित गुणवत्ता के साथ परिवर्तित करने का कोई पूरी तरह से प्रोग्रामेटिक तरीका नहीं है। ज्यादातर, इसके लिए एक डेटासेट होना चाहिए जिस पर प्रणाली आधारित हो। डेटासेट हो सकता है:

* सही वर्तनी वाले शब्दों की एक डिक्शनरी, जो बदले में हो सकती है:
  * आपके वास्तविक डेटा पर आधारित। यहाँ विचार यह है कि, अधिकांश भाग के लिए, आपके डेटा से बने शब्दकोश में वर्तनी सही है, और प्रणाली उस शब्द को खोजने की कोशिश करती है जो टाइप किए गए शब्द के सबसे समान है (हम जल्द ही चर्चा करेंगे कि यह Manticore के साथ कैसे किया जा सकता है)।
  * या यह आपके डेटा से अप्रभिन्न एक बाहरी डिक्शनरी पर आधारित हो सकता है। यहां जो समस्या उत्पन्न हो सकती है वह यह है कि आपका डेटा और बाहरी डिक्शनरी बहुत विभिन्न हो सकते हैं: कुछ शब्द डिक्शनरी में अनुपस्थित हो सकते हैं, जबकि अन्य आपके डेटा में अनुपस्थित हो सकते हैं।
* न केवल शब्दकोश पर आधारित, बल्कि संदर्भ- जागरूक भी, जैसे, "white ber" को "white bear" में ठीक किया जाएगा, जबकि "dark ber" को "dark beer" में ठीक किया जाएगा। संदर्भ केवल आपके प्रश्न में एक पड़ोसी शब्द नहीं हो सकता, बल्कि आपकी स्थिति, दिन का समय, वर्तमान वाक्य की व्याकरण (यह तय करने के लिए कि "there" को "their" में बदलना है या नहीं), आपका खोज इतिहास, और वास्तव में किसी भी अन्य कारक जो आपकी अनुमति को प्रभावित कर सकते हैं।
* एक और पारंपरिक दृष्टिकोण पिछले खोज प्रश्नों का उपयोग करना है जो वर्तनी सुधार के लिए डेटासेट के रूप में कार्य करते हैं। इसका उपयोग [स्वतः पूर्ण](../Searching/Autocomplete.md) कार्यक्षमता में और भी अधिक किया जाता है, लेकिन यह स्वचालित सुधार के लिए भी सही है। विचार यह है कि उपयोगकर्ताओं के अधिकांश सही होते हैं वर्तनी में, इसलिए हम उनके खोज इतिहास से शब्दों का उपयोग सत्य के स्रोत के रूप में कर सकते हैं, भले ही हमारे दस्तावेज़ों में शब्द नहीं हों या बाहरी डिक्शनरी का उपयोग न करें। संदर्भ-जागरूकता यहाँ भी संभव है।

Manticore फजी सर्च विकल्प और स्वचालित वर्तनी सुधार उद्देश्यों के लिए उपयोग किए जा सकने वाले `CALL QSUGGEST` और `CALL SUGGEST` आदेश प्रदान करता है।

# फजी सर्च

फजी सर्च फ़ीचर थोड़ा भिन्नता या गलत स्पेलिंग के लिए खोज प्रश्न में अधिक लचीले मिलान की अनुमति देता है। यह सामान्य `SELECT` SQL कथन या एक `/search` JSON अनुरोध के समान काम करता है लेकिन फजी मिलान व्यवहार को नियंत्रित करने के लिए अतिरिक्त पैरामीटर प्रदान करता है।

> नोट: `fuzzy` विकल्प की आवश्यकता होती है [Manticore Buddy](../Installation/Manticore_Buddy.md)। यदि यह काम नहीं करता है, तो सुनिश्चित करें कि बडी स्थापित है।

## सामान्य सिंटैक्स

### SQL

<!-- example Fuzzy_Search_SQL -->

```sql
SELECT
  ...
  MATCH('...')
  ...
  OPTION fuzzy={0|1}
  [, distance=N]
  [, layouts='{be,bg,br,ch,de,dk,es,fr,uk,gr,it,no,pt,ru,se,ua,us}']
}
```

नोट: जब SQL के माध्यम से फजी खोज की जा रही है, तो MATCH क्लॉज़ में कोई पूर्ण-टेक्स्ट ऑपरेटर नहीं होना चाहिए, केवल [वाक्यांश खोज ऑपरेटर](../Searching/Full_text_matching/Operators.md#Phrase-search-operator) शामिल होनी चाहिए और केवल उन शब्दों को शामिल करना चाहिए जिन्हें आप मिलान करना चाहते हैं।

<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
SELECT * FROM mytable WHERE MATCH('someting') OPTION fuzzy=1, layouts='us,ua', distance=2;
```

<!-- request SQL with additional filters -->
अतिरिक्त फ़िल्टर के साथ अधिक जटिल फजी खोज प्रश्न का उदाहरण:

```sql
SELECT * FROM mytable WHERE MATCH('someting') OPTION fuzzy=1 AND (category='books' AND price < 20);
```

<!-- request JSON -->

```json
POST /search
{
  "table": "test",
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "*": "ghbdtn"
          }
        }
      ]
    }
  },
  "options": {
    "fuzzy": true,
    "layouts": ["us", "ru"],
    "distance": 2
  }
}
```

<!-- response SQL -->

```sql
+------+-------------+
| id   | content     |
+------+-------------+
|    1 | something   |
|    2 | some thing  |
+------+-------------+
2 rows in set (0.00 sec)
```

<!-- end -->

### JSON

```json
POST /search
{
  "table": "table_name",
  "query": {
    <full-text query>
  },
  "options": {
    "fuzzy": {true|false}
    [,"layouts": ["be","bg","br","ch","de","dk","es","fr","uk","gr","it","no","pt","ru","se","ua","us"]]
    [,"distance": N]
  }
}
```

नोट: यदि आप [query_string](../../Searching/Full_text_matching/Basic_usage.md#query_string) का उपयोग करते हैं, तो ध्यान दें कि यह पूर्ण-टेक्स्ट ऑपरेटर का समर्थन नहीं करता है सिवाय [वाक्यांश खोज ऑपरेटर](../Searching/Full_text_matching/Operators.md#Phrase-search-operator)। क्वेरी स्ट्रिंग में केवल वही शब्द शामिल होना चाहिए जिन्हें आप मिलान करना चाहते हैं।

### विकल्प

- `fuzzy`: फजी सर्च को चालू या बंद करें।
- `distance`: मिलान के लिए लेवेंसस्टाइन दूरी सेट करें। डिफ़ॉल्ट `2` है।
- `layouts`: टाइपिंग त्रुटियों के लिए जांच करने के लिए कीबोर्ड लेआउट। सभी लेआउट डिफ़ॉल्ट रूप से उपयोग किए जाते हैं। इसे बंद करने के लिए एक खाली स्ट्रिंग `''` (SQL) या ऐरे `[]` (JSON) का उपयोग करें। समर्थित लेआउट में शामिल हैं:
  - `be` - बेल्जियम AZERTY लेआउट
  - `bg` - मानक बुल्गारियाई लेआउट
  - `br` - ब्राज़ीलियाई QWERTY लेआउट
  - `ch` - स्विस QWERTZ लेआउट
  - `de` - जर्मन QWERTZ लेआउट
  - `dk` - डेनिश QWERTY लेआउट
  - `es` - स्पेनिश QWERTY लेआउट
  - `fr` - फ्रेंच AZERTY लेआउट
  - `uk` - ब्रिटिश QWERTY लेआउट
  - `gr` - ग्रीक QWERTY लेआउट
  - `it` - इटालियन QWERTY लेआउट
  - `no` - नॉर्वेजियन QWERTY लेआउट
  - `pt` - पुर्तगाली QWERTY लेआउट
  - `ru` - रूसी JCUKEN लेआउट
  - `se` - स्वीडिश QWERTY लेआउट
  - `ua` - यूक्रेनी JCUKEN लेआउट
  - `us` - अमेरिकी QWERTY लेआउट


### लिंक

* <a href="https://github.manticoresearch.com/manticoresoftware/manticoresearch?query=fature&filters%5Bcomment%5D%5B%5D=28798446&filters%5Bcommon%5D%5Brepo_id%5D%5B%5D=95614931&sort=&search=keyword-search-fuzzy-layouts">यह डेमो</a> फ़ज़ी सर्च कार्यक्षमता का प्रदर्शन करता है:
  ![फज़ी सर्च उदाहरण](fuzzysearch.png){.scale-0.7}
* फ़ज़ी सर्च और ऑटो-कम्प्लीट के बारे में ब्लॉग पोस्ट - https://manticoresearch.com/blog/new-fuzzy-search-and-autocomplete/

## CALL QSUGGEST, CALL SUGGEST

दोनों कमांड SQL के माध्यम से सुलभ हैं और स्थानीय (सादा और वास्तविक समय) तथा वितरित तालिकाओं पर प्रश्न पूछने का समर्थन करते हैं। वाक्यांश इस प्रकार है:
```sql
CALL QSUGGEST(<शब्द या शब्द>, <तालिका का नाम> [,विकल्प])
CALL SUGGEST(<शब्द या शब्द>, <तालिका का नाम> [,विकल्प])

विकल्प: N को विकल्प_नाम[, M को अन्य_विकल्प, ...]
```

ये कमांड एक दिए गए शब्द के लिए शब्दकोश से सभी सुझाव प्रदान करते हैं। ये केवल [infixing](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) सक्षम तालिकाओं और [dict=keywords](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict) पर काम करते हैं। ये सुझावित कीवर्ड, सुझावित और मूल कीवर्ड के बीच की लेवेनस्टेन दूरी, और सुझावित कीवर्ड के दस्तावेज़ सांख्यिकी लौटाते हैं।

यदि पहले पैरामीटर में कई शब्द हैं, तो:
* `CALL QSUGGEST` केवल **अंतिम** शब्द के लिए सुझाव लौटाएगा, बाकी को नकारते हुए।
* `CALL SUGGEST` केवल **पहले** शब्द के लिए सुझाव लौटाएगा।

यही उनके बीच की एकमात्र भिन्नता है। अनुकूलन के लिए कई विकल्प समर्थित हैं:

| विकल्प | विवरण | डिफ़ॉल्ट |
| - | - | - |
| सीमा | N शीर्ष मेल लौटाता है | 5 |
| अधिकतम संपादन | केवल उन शब्दकोश के शब्दों को रखता है जिनकी लेवेनस्टेन दूरी N के बराबर या उससे कम है | 4 |
| परिणाम सांख्यिकी | प्राप्त शब्दों की लेवेनस्टेन दूरी और दस्तावेज़ संख्या प्रदान करता है | 1 (सक्षम) |
| डेल्टा लंबाई | केवल उन शब्दकोश के शब्दों को रखता है जिनकी लंबाई का अंतर N से कम है | 3 |
| अधिकतम मेल | रखने के लिए मेल की संख्या | 25 |
| अस्वीकृत | अस्वीकृत शब्द वे मेल होते हैं जो पहले से मेल में मौजूद शब्दों से बेहतर नहीं होते हैं। इन्हें एक अस्वीकृत कतार में रखा जाता है जो तब रीसेट होती है जब कोई वास्तव में मेल के कतार में जा सकता है। यह पैरामीटर अस्वीकृत कतार के आकार को परिभाषित करता है (जैसे reject*max(max_matched,limit)). यदि अस्वीकृत कतार भरी होती है, तो इंजन संभावित मेल खोजना बंद कर देता है | 4 |
| परिणाम पंक्ति | डेटा को प्रदर्शित करने का वैकल्पिक मोड सभी सुझाव, दूरियाँ और दस्तावेज़ को प्रत्येक एक पंक्ति में लौटाता है | 0 |
| गैर वर्ण | गैर वर्णात्मक प्रतीकों वाले शब्दकोश के शब्दों को छोड़ता नहीं है | 0 (ऐसे शब्दों को छोड़ें) |
| वाक्य | मूल वाक्य को लौटाता है जिससे अंतिम शब्द मेल खाने वाले से बदला गया है। | 0 (पूरे वाक्य को न लौटाएं) |

यह दिखाने के लिए कि यह कैसे काम करता है, आइए एक तालिका बनाते हैं और उसमें कुछ दस्तावेज़ जोड़ते हैं।

```sql
create table products(title text) min_infix_len='2';
insert into products values (0,'Crossbody Bag with Tassel'), (0,'microfiber sheet set'), (0,'Pet Hair Remover Glove');
```
<!-- उदाहरण एकल -->
##### एकल शब्द उदाहरण
जैसा कि आप देख सकते हैं, गलत टाइप किया गया शब्द "crossb**U**dy" को "crossbody" में सही किया जाता है। डिफ़ॉल्ट रूप से, `CALL SUGGEST/QSUGGEST` लौटाता है:

* `दूरी` - लेवेनस्टेन दूरी जिसका मतलब है कि उन्होंने दिए गए शब्द को सुझाव में परिवर्तित करने के लिए कितने संपादन किए
* `दस्तावेज़` - सुझाए गए शब्द को含 करने वाले दस्तावेज़ों की संख्या

इन सांख्यिकीय जानकारी को दिखाने को बंद करने के लिए, आप विकल्प का उपयोग कर सकते हैं `0 as result_stats`.


<!-- परिचय -->
##### उदाहरण:

<!-- अनुरोध उदाहरण -->

```sql
call suggest('crossbudy', 'products');
```
<!-- प्रतिक्रिया उदाहरण -->

```sql
+-----------+----------+------+
| सुझाव    | दूरी     | दस्तावेज़ |
+-----------+----------+------+
| crossbody | 1        | 1    |
+-----------+----------+------+
```
<!-- अंत -->
<!-- उदाहरण पहले -->
##### CALL SUGGEST केवल पहले शब्द को लेता है
यदि पहला पैरामीटर एक एकल शब्द नहीं है, बल्कि कई है, तो `CALL SUGGEST` केवल पहले शब्द के लिए सुझाव लौटाएगा।


<!-- परिचय -->
##### उदाहरण:

<!-- अनुरोध उदाहरण -->

```sql
call suggest('bagg with tasel', 'products');
```
<!-- प्रतिक्रिया उदाहरण -->

```sql
+---------+----------+------+
| सुझाव   | दूरी     | दस्तावेज़ |
+---------+----------+------+
| bag     | 1        | 1    |
+---------+----------+------+
```
<!-- अंत -->
<!-- उदाहरण अंतिम -->
##### CALL QSUGGEST केवल अंतिम शब्द को लेता है
यदि पहला पैरामीटर एक एकल शब्द नहीं है, बल्कि कई है, तो `CALL SUGGEST` केवल अंतिम शब्द के लिए सुझाव लौटाएगा।


<!-- परिचय -->
##### उदाहरण:

<!-- अनुरोध उदाहरण -->

```sql
CALL QSUGGEST('bagg with tasel', 'products');
```
<!-- प्रतिक्रिया उदाहरण -->

```sql
+---------+----------+------+
| सुझाव   | दूरी     | दस्तावेज़ |
+---------+----------+------+
| tassel  | 1        | 1    |
+---------+----------+------+
```
<!-- अंत -->

<!-- उदाहरण अंतिम2 -->

`1 as sentence` जोड़ने से `CALL QSUGGEST` पूरे वाक्य को लौटाता है जिसमें अंतिम शब्द सही किया गया है।

<!-- अनुरोध उदाहरण -->
```sql
CALL QSUGGEST('bag with tasel', 'products', 1 as sentence);
```
<!-- प्रतिक्रिया उदाहरण -->
```sql
+-------------------+----------+------+
| सुझाव             | दूरी     | दस्तावेज़ |
+-------------------+----------+------+
| bag with tassel   | 1        | 1    |
+-------------------+----------+------+
```
<!-- अंत -->

##### विभिन्न डिस्प्ले मोड
`1 as result_line` विकल्प परिणामों में सुझावों के प्रदर्शित होने के तरीके को बदलता है। यह प्रत्येक सुझाव को एक अलग पंक्ति में दिखाने के बजाय सभी सुझावों, दूरी और दस्तावेज़ों को एक ही पंक्ति में दिखाता है। इसे प्रदर्शित करने के लिए एक उदाहरण यहाँ है:

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```sql
CALL QSUGGEST('bagg with tasel', 'products', 1 as result_line);
```
<!-- response Example -->

```sql
+----------+--------+
| name     | value  |
+----------+--------+
| suggests | tassel |
| distance | 1      |
| docs     | 1      |
+----------+--------+
```
<!-- end -->

### डेमो

* [यह इंटरएक्टिव कोर्स](https://play.manticoresearch.com/didyoumean/) दिखाता है कि `CALL SUGGEST` एक छोटे वेब एप्लिकेशन में कैसे काम करता है।

![CALL SUGGEST example](didyoumean.png){.scale-0.5}


<!-- proofread -->
