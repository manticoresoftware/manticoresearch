# वर्तनी सही करना

वर्तनी सही करना, जिसे के रूप में भी जाना जाता है:

* स्वचालित सुधार
* पाठ सुधार
* वर्तनी त्रुटियों को ठीक करना
* टाइपो सहिष्णुता
* "क्या आप चाहते थे?"

और इसी प्रकार, एक सॉफ़्टवेयर कार्यक्षमता है जो उस पाठ के विकल्प सुझाती है जिसे आपने टाइप किया है या अपने आप सुधार करती है। टाइप किए गए पाठ को ठीक करने का सिद्धांत 1960 के दशक में वापस जाता है जब कंप्यूटर वैज्ञानिक वॉरेन टेitelमैन, जिन्होंने "पूर्ववत" कमांड का भी आविष्कार किया, ने D.W.I.M. नामक कंप्यूटिंग का एक सिद्धांत पेश किया, या "जो मैं मतलब है उसे करो।" टेitelमैन ने तर्क किया कि कंप्यूटरों को केवल पूरी तरह से फ़ॉर्मेट किए गए निर्देशों को स्वीकार करने के लिए प्रोग्राम बनाने के बजाय, उन्हें स्पष्ट गलतियों को पहचानने के लिए प्रोग्राम करना चाहिए।

वर्तनी सुधार कार्यक्षमता प्रदान करने वाला पहला प्रसिद्ध उत्पाद माइक्रोसॉफ्ट वर्ड 6.0 था, जो 1993 में जारी किया गया था।

### यह कैसे काम करता है

वर्तनी सुधार करने के कुछ तरीके हैं, लेकिन यह ध्यान रखना महत्वपूर्ण है कि आपके गलत टाइप किए गए "ipone" को "iphone" में उचित गुणवत्ता के साथ परिवर्तित करने का कोई पूरी तरह से प्रोग्रामेटिक तरीका नहीं है। ज्यादातर, इसके लिए एक डेटासेट होना चाहिए जिस पर प्रणाली आधारित हो। डेटासेट हो सकता है:

* सही वर्तनी वाले शब्दों की एक डिक्शनरी, जो बदले में हो सकती है:
  * आपके वास्तविक डेटा पर आधारित। यहाँ विचार यह है कि, अधिकांश भाग के लिए, आपके डेटा से बने शब्दकोश में वर्तनी सही है, और प्रणाली उस शब्द को खोजने की कोशिश करती है जो टाइप किए गए शब्द के सबसे समान है (हम जल्द ही चर्चा करेंगे कि यह Manticore के साथ कैसे किया जा सकता है)।
  * या यह आपके डेटा से अप्रभिन्न एक बाहरी डिक्शनरी पर आधारित हो सकता है। यहां जो समस्या उत्पन्न हो सकती है वह यह है कि आपका डेटा और बाहरी डिक्शनरी बहुत विभिन्न हो सकते हैं: कुछ शब्द डिक्शनरी में अनुपस्थित हो सकते हैं, जबकि अन्य आपके डेटा में अनुपस्थित हो सकते हैं।
* न केवल शब्दकोश पर आधारित, बल्कि संदर्भ- जागरूक भी, जैसे, "white ber" को "white bear" में ठीक किया जाएगा, जबकि "dark ber" को "dark beer" में ठीक किया जाएगा। संदर्भ केवल आपके प्रश्न में एक पड़ोसी शब्द नहीं हो सकता, बल्कि आपकी स्थिति, दिन का समय, वर्तमान वाक्य की व्याकरण (यह तय करने के लिए कि "there" को "their" में बदलना है या नहीं), आपका खोज इतिहास, और वास्तव में किसी भी अन्य कारक जो आपकी अनुमति को प्रभावित कर सकते हैं।
* एक और पारंपरिक दृष्टिकोण पिछले खोज प्रश्नों का उपयोग करना है जो वर्तनी सुधार के लिए डेटासेट के रूप में कार्य करते हैं। इसका उपयोग [स्वतः पूर्ण](../Searching/Autocomplete.md) कार्यक्षमता में और भी अधिक किया जाता है, लेकिन यह स्वचालित सुधार के लिए भी सही है। विचार यह है कि उपयोगकर्ताओं के अधिकांश सही होते हैं वर्तनी में, इसलिए हम उनके खोज इतिहास से शब्दों का उपयोग सत्य के स्रोत के रूप में कर सकते हैं, भले ही हमारे दस्तावेज़ों में शब्द नहीं हों या बाहरी डिक्शनरी का उपयोग न करें। संदर्भ-जागरूकता यहाँ भी संभव है।

Manticore फजी सर्च विकल्प और स्वचालित वर्तनी सुधार उद्देश्यों के लिए उपयोग किए जा सकने वाले `CALL QSUGGEST` और `CALL SUGGEST` आदेश प्रदान करता है।

# फजी सर्च

फजी सर्च फ़ीचर थोड़ा भिन्नता या गलत स्पेलिंग के लिए खोज प्रश्न में अधिक लचीले मिलान की अनुमति देता है। यह सामान्य `SELECT` SQL कथन या एक `/search` JSON अनुरोध के समान काम करता है लेकिन फजी मिलान व्यवहार को नियंत्रित करने के लिए अतिरिक्त पैरामीटर प्रदान करता है।

> नोट: `fuzzy` विकल्प की आवश्यकता होती है [Manticore Buddy](../Installation/Manticore_Buddy.md)। यदि यह काम नहीं करता है, तो सुनिश्चित करें कि बडी स्थापित है।

## सामान्य सिंटैक्स

### SQL

<!-- example Fuzzy_Search_SQL -->

```sql
SELECT
  ...
  MATCH('...')
  ...
  OPTION fuzzy={0|1}
  [, distance=N]
  [, layouts='{be,bg,br,ch,de,dk,es,fr,uk,gr,it,no,pt,ru,se,ua,us}']
}
```

नोट: जब SQL के माध्यम से फजी खोज की जा रही है, तो MATCH क्लॉज़ में कोई पूर्ण-टेक्स्ट ऑपरेटर नहीं होना चाहिए, केवल [वाक्यांश खोज ऑपरेटर](../Searching/Full_text_matching/Operators.md#Phrase-search-operator) शामिल होनी चाहिए और केवल उन शब्दों को शामिल करना चाहिए जिन्हें आप मिलान करना चाहते हैं।

<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
SELECT * FROM mytable WHERE MATCH('someting') OPTION fuzzy=1, layouts='us,ua', distance=2;
```

<!-- request SQL with additional filters -->
अतिरिक्त फ़िल्टर के साथ अधिक जटिल फजी खोज प्रश्न का उदाहरण:

```sql
SELECT * FROM mytable WHERE MATCH('someting') OPTION fuzzy=1 AND (category='books' AND price < 20);
```

<!-- request JSON -->

```json
POST /search
{
  "table": "test",
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "*": "ghbdtn"
          }
        }
      ]
    }
  },
  "options": {
    "fuzzy": true,
    "layouts": ["us", "ru"],
    "distance": 2
  }
}
```

<!-- response SQL -->

```sql
+------+-------------+
| id   | content     |
+------+-------------+
|    1 | something   |
|    2 | some thing  |
+------+-------------+
2 rows in set (0.00 sec)
```

<!-- end -->

### JSON

```json
POST /search
{
  "table": "table_name",
  "query": {
    <full-text query>
  },
  "options": {
    "fuzzy": {true|false}
    [,"layouts": ["be","bg","br","ch","de","dk","es","fr","uk","gr","it","no","pt","ru","se","ua","us"]]
    [,"distance": N]
  }
}
```

नोट: यदि आप [query_string](../../Searching/Full_text_matching/Basic_usage.md#query_string) का उपयोग करते हैं, तो ध्यान दें कि यह पूर्ण-टेक्स्ट ऑपरेटर का समर्थन नहीं करता है सिवाय [वाक्यांश खोज ऑपरेटर](../Searching/Full_text_matching/Operators.md#Phrase-search-operator)। क्वेरी स्ट्रिंग में केवल वही शब्द शामिल होना चाहिए जिन्हें आप मिलान करना चाहते हैं।

### विकल्प

- `fuzzy`: फजी सर्च को चालू या बंद करें।
- `distance`: मिलान के लिए लेवेंसस्टाइन दूरी सेट करें। डिफ़ॉल्ट `2` है।
- `layouts`: टाइपिंग त्रुटियों के लिए जांच करने के लिए कीबोर्ड लेआउट। सभी लेआउट डिफ़ॉल्ट रूप से उपयोग किए जाते हैं। इसे बंद करने के लिए एक खाली स्ट्रिंग `''` (SQL) या ऐरे `[]` (JSON) का उपयोग करें। समर्थित लेआउट में शामिल हैं:
  - `be` - बेल्जियम AZERTY लेआउट
  - `bg` - मानक बुल्गारियाई लेआउट
  - `br` - ब्राज़ीलियाई QWERTY लेआउट
  - `ch` - स्विस QWERTZ लेआउट
  - `de` - जर्मन QWERTZ लेआउट
  - `dk` - डेनिश QWERTY लेआउट
  - `es` - स्पेनिश QWERTY लेआउट
  - `fr` - फ्रेंच AZERTY लेआउट
  - `uk` - ब्रिटिश QWERTY लेआउट
  - `gr` - ग्रीक QWERTY लेआउट
  - `it` - इटालियन QWERTY लेआउट
  - `no` - नॉर्वेजियन QWERTY लेआउट
  - `pt` - पुर्तगाली QWERTY लेआउट
  - `ru` - रूसी JCUKEN लेआउट
  - `se` - स्वीडिश QWERTY लेआउट
  - `ua` - यूक्रेनी JCUKEN लेआउट
  - `us` - अमेरिकी QWERTY लेआउट


### लिंक

* <a href="https://github.manticoresearch.com/manticoresoftware/manticoresearch?query=fature&filters%5Bcomment%5D%5B%5D=28798446&filters%5Bcommon%5D%5Brepo_id%5D%5B%5D=95614931&sort=&search=keyword-search-fuzzy-layouts">यह डेमो</a> फ़ज़ी सर्च कार्यक्षमता का प्रदर्शन करता है:
  ![फज़ी सर्च उदाहरण](fuzzysearch.png){.scale-0.7}
* फ़ज़ी सर्च और ऑटो-कम्प्लीट के बारे में ब्लॉग पोस्ट - https://manticoresearch.com/blog/new-fuzzy-search-and-autocomplete/

## CALL QSUGGEST, CALL SUGGEST

दोनों कमांड SQL के माध्यम से सुलभ हैं और स्थानीय (सादा और वास्तविक समय) तथा वितरित तालिकाओं पर प्रश्न पूछने का समर्थन करते हैं। वाक्यांश इस प्रकार है:
```sql
CALL QSUGGEST(<शब्द या शब्द>, <तालिका का नाम> [,विकल्प])
CALL SUGGEST(<शब्द या शब्द>, <तालिका का नाम> [,विकल्प])

विकल्प: N को विकल्प_नाम[, M को अन्य_विकल्प, ...]
```

ये कमांड एक दिए गए शब्द के लिए शब्दकोश से सभी सुझाव प्रदान करते हैं। ये केवल [infixing](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) सक्षम तालिकाओं और [dict=keywords](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict) पर काम करते हैं। ये सुझावित कीवर्ड, सुझावित और मूल कीवर्ड के बीच की लेवेनस्टेन दूरी, और सुझावित कीवर्ड के दस्तावेज़ सांख्यिकी लौटाते हैं।

यदि पहले पैरामीटर में कई शब्द हैं, तो:
* `CALL QSUGGEST` केवल **अंतिम** शब्द के लिए सुझाव लौटाएगा, बाकी को नकारते हुए।
* `CALL SUGGEST` केवल **पहले** शब्द के लिए सुझाव लौटाएगा।

यही उनके बीच की एकमात्र भिन्नता है। अनुकूलन के लिए कई विकल्प समर्थित हैं:

| विकल्प | विवरण | डिफ़ॉल्ट |
| - | - | - |
| सीमा | N शीर्ष मेल लौटाता है | 5 |
| अधिकतम संपादन | केवल उन शब्दकोश के शब्दों को रखता है जिनकी लेवेनस्टेन दूरी N के बराबर या उससे कम है | 4 |
| परिणाम सांख्यिकी | प्राप्त शब्दों की लेवेनस्टेन दूरी और दस्तावेज़ संख्या प्रदान करता है | 1 (सक्षम) |
| डेल्टा लंबाई | केवल उन शब्दकोश के शब्दों को रखता है जिनकी लंबाई का अंतर N से कम है | 3 |
| अधिकतम मेल | रखने के लिए मेल की संख्या | 25 |
| अस्वीकृत | अस्वीकृत शब्द वे मेल होते हैं जो पहले से मेल में मौजूद शब्दों से बेहतर नहीं होते हैं। इन्हें एक अस्वीकृत कतार में रखा जाता है जो तब रीसेट होती है जब कोई वास्तव में मेल के कतार में जा सकता है। यह पैरामीटर अस्वीकृत कतार के आकार को परिभाषित करता है (जैसे reject*max(max_matched,limit)). यदि अस्वीकृत कतार भरी होती है, तो इंजन संभावित मेल खोजना बंद कर देता है | 4 |
| परिणाम पंक्ति | डेटा को प्रदर्शित करने का वैकल्पिक मोड सभी सुझाव, दूरियाँ और दस्तावेज़ को प्रत्येक एक पंक्ति में लौटाता है | 0 |
| गैर वर्ण | गैर वर्णात्मक प्रतीकों वाले शब्दकोश के शब्दों को छोड़ता नहीं है | 0 (ऐसे शब्दों को छोड़ें) |
| वाक्य | मूल वाक्य को लौटाता है जिससे अंतिम शब्द मेल खाने वाले से बदला गया है। | 0 (पूरे वाक्य को न लौटाएं) |

यह दिखाने के लिए कि यह कैसे काम करता है, आइए एक तालिका बनाते हैं और उसमें कुछ दस्तावेज़ जोड़ते हैं।

```sql
create table products(title text) min_infix_len='2';
insert into products values (0,'Crossbody Bag with Tassel'), (0,'microfiber sheet set'), (0,'Pet Hair Remover Glove');
```
<!-- उदाहरण एकल -->
##### एकल शब्द उदाहरण
जैसा कि आप देख सकते हैं, गलत टाइप किया गया शब्द "crossb**U**dy" को "crossbody" में सही किया जाता है। डिफ़ॉल्ट रूप से, `CALL SUGGEST/QSUGGEST` लौटाता है:

* `दूरी` - लेवेनस्टेन दूरी जिसका मतलब है कि उन्होंने दिए गए शब्द को सुझाव में परिवर्तित करने के लिए कितने संपादन किए
* `दस्तावेज़` - सुझाए गए शब्द को含 करने वाले दस्तावेज़ों की संख्या

इन सांख्यिकीय जानकारी को दिखाने को बंद करने के लिए, आप विकल्प का उपयोग कर सकते हैं `0 as result_stats`.


<!-- परिचय -->
##### उदाहरण:

<!-- अनुरोध उदाहरण -->

```sql
call suggest('crossbudy', 'products');
```
<!-- प्रतिक्रिया उदाहरण -->

```sql
+-----------+----------+------+
| सुझाव    | दूरी     | दस्तावेज़ |
+-----------+----------+------+
| crossbody | 1        | 1    |
+-----------+----------+------+
```
<!-- अंत -->
<!-- उदाहरण पहले -->
##### CALL SUGGEST केवल पहले शब्द को लेता है
यदि पहला पैरामीटर एक एकल शब्द नहीं है, बल्कि कई है, तो `CALL SUGGEST` केवल पहले शब्द के लिए सुझाव लौटाएगा।


<!-- परिचय -->
##### उदाहरण:

<!-- अनुरोध उदाहरण -->

```sql
call suggest('bagg with tasel', 'products');
```
<!-- प्रतिक्रिया उदाहरण -->

```sql
+---------+----------+------+
| सुझाव   | दूरी     | दस्तावेज़ |
+---------+----------+------+
| bag     | 1        | 1    |
+---------+----------+------+
```
<!-- अंत -->
<!-- उदाहरण अंतिम -->
##### CALL QSUGGEST केवल अंतिम शब्द को लेता है
यदि पहला पैरामीटर एक एकल शब्द नहीं है, बल्कि कई है, तो `CALL SUGGEST` केवल अंतिम शब्द के लिए सुझाव लौटाएगा।


<!-- परिचय -->
##### उदाहरण:

<!-- अनुरोध उदाहरण -->

```sql
CALL QSUGGEST('bagg with tasel', 'products');
```
<!-- प्रतिक्रिया उदाहरण -->

```sql
+---------+----------+------+
| सुझाव   | दूरी     | दस्तावेज़ |
+---------+----------+------+
| tassel  | 1        | 1    |
+---------+----------+------+
```
<!-- अंत -->

<!-- उदाहरण अंतिम2 -->

`1 as sentence` जोड़ने से `CALL QSUGGEST` पूरे वाक्य को लौटाता है जिसमें अंतिम शब्द सही किया गया है।

<!-- अनुरोध उदाहरण -->
```sql
CALL QSUGGEST('bag with tasel', 'products', 1 as sentence);
```
<!-- प्रतिक्रिया उदाहरण -->
```sql
+-------------------+----------+------+
| सुझाव             | दूरी     | दस्तावेज़ |
+-------------------+----------+------+
| bag with tassel   | 1        | 1    |
+-------------------+----------+------+
```
<!-- अंत -->

##### विभिन्न डिस्प्ले मोड
`1 as result_line` विकल्प परिणामों में सुझावों के प्रदर्शित होने के तरीके को बदलता है। यह प्रत्येक सुझाव को एक अलग पंक्ति में दिखाने के बजाय सभी सुझावों, दूरी और दस्तावेज़ों को एक ही पंक्ति में दिखाता है। इसे प्रदर्शित करने के लिए एक उदाहरण यहाँ है:

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```sql
CALL QSUGGEST('bagg with tasel', 'products', 1 as result_line);
```
<!-- response Example -->

```sql
+----------+--------+
| name     | value  |
+----------+--------+
| suggests | tassel |
| distance | 1      |
| docs     | 1      |
+----------+--------+
```
<!-- end -->

### डेमो

* [यह इंटरएक्टिव कोर्स](https://play.manticoresearch.com/didyoumean/) दिखाता है कि `CALL SUGGEST` एक छोटे वेब एप्लिकेशन में कैसे काम करता है।

![CALL SUGGEST example](didyoumean.png){.scale-0.5}


<!-- proofread -->
