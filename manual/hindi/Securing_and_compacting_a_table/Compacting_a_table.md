# एक तालिका को संकुचित करना

समय के साथ, RT तालिकाएँ कई डिस्क टुकड़ों में विभाजित हो सकती हैं और/या हटाए गए, फिर भी अप्रकाशित डेटा के साथ संदूषित हो सकती हैं, जिससे खोज प्रदर्शन प्रभावित होता है। इन मामलों में, अनुकूलन आवश्यक है। मूल रूप से, अनुकूलन प्रक्रिया डिस्क टुकड़ों के जोड़ों को मिलाकर उन दस्तावेज़ों को हटा देती है जिन्हें पहले DELETE कथनों का उपयोग करके हटाया गया था।

Manticore 4 से शुरू होकर, यह प्रक्रिया [डिफ़ॉल्ट रूप से स्वचालित रूप से](../Server_settings/Searchd.md#auto_optimize) होती है। हालाँकि, आप तालिका संकुचन को मैन्युअल रूप से आरंभ करने के लिए निम्नलिखित आदेशों का भी उपयोग कर सकते हैं।

## तालिका का अनुकूलन करें

<!-- example optimize -->
```sql
OPTIMIZE TABLE table_name [OPTION opt_name = opt_value [,...]]
```

`OPTIMIZE` कथन एक RT तालिका को अनुकूलन कतार में जोड़ता है, जिसे एक बैकग्राउंड थ्रेड में संसाधित किया जाएगा।

<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
OPTIMIZE TABLE rt;
```
<!-- end -->

### अनुकूलित डिस्क टुकड़ों की संख्या

<!-- example optimize_cutoff -->

डिफ़ॉल्ट रूप से, OPTIMIZE RT तालिका के डिस्क टुकड़ों को एक संख्या में विलय करता है जो तार्किक CPU कोर की संख्या के 2 से गुणा करने के बराबर या उससे कम होती है।

हालाँकि, यदि तालिका में KNN अनुक्रमणिका वाले गुण हैं, तो यह सीमा अलग होती है। इस मामले में, इसे भौतिक CPU कोर की संख्या को 2 से विभाजित करके सेट किया जाता है ताकि KNN खोज प्रदर्शन में सुधार हो सके।

आप `cutoff` विकल्प का उपयोग करके अनुकूलित डिस्क टुकड़ों की संख्या को मैन्युअल रूप से भी नियंत्रित कर सकते हैं।

अतिरिक्त विकल्पों में शामिल हैं:
* सर्वर सेटिंग [optimize_cutoff](../Server_settings/Searchd.md#optimize_cutoff) जो डिफ़ॉल्ट सीमा कोOverride करता है
* प्रति तालिका सेटिंग [optimize_cutoff](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#optimize_cutoff)

<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
OPTIMIZE TABLE rt OPTION cutoff=4;
```
<!-- end -->

### अग्रभूमि में चलता है

<!-- example optimize_sync -->

जब `OPTION sync=1` (डिफ़ॉल्ट रूप से 0) का उपयोग करते हैं, तो कमांड प्रक्रिया के पूरा होने की प्रतीक्षा करेगी। यदि कनेक्शन बाधित हो जाता है, तो अनुकूलन सर्वर पर चलता रहेगा।

<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
OPTIMIZE TABLE rt OPTION sync=1;
```
<!-- end -->

### IO प्रभाव को सीमित करना

अनुकूलन एक लंबी और I/O-गहन प्रक्रिया हो सकती है। प्रभाव को कम करने के लिए, सभी वास्तविक विलय कार्य एक विशेष बैकग्राउंड थ्रेड में क्रमिक रूप से निष्पादित होते हैं, और `OPTIMIZE` कथन बस अपनी कतार में एक कार्य जोड़ता है। अनुकूलन थ्रेड को I/O-सीमित किया जा सकता है, और आप अधिकतम I/Os प्रति सेकंड और अधिकतम I/O आकार को [rt_merge_iops](../Server_settings/Searchd.md#rt_merge_iops) और [rt_merge_maxiosize](../Server_settings/Searchd.md#rt_merge_maxiosize) निदेशों के माध्यम से नियंत्रित कर सकते हैं।

अनुकूलन के दौरान, अनुकूलित हो रही RT तालिका ऑनलाइन और खोजने तथा अद्यतनों के लिए लगभग सभी समय उपलब्ध रहती है। जब एक जोड़ी डिस्क टुकड़े सफलतापूर्वक विलय हो जाते हैं, तो इसे बहुत संक्षिप्त समय के लिए लॉक किया जाता है, पुरानी और नई फ़ाइलों के नामकरण की अनुमति देता है और तालिका शीर्षक को अपडेट करता है।

### क्लस्टर तालिकाओं का अनुकूलन करना

जब तक [auto_optimize](../Server_settings/Searchd.md#auto_optimize) अक्षम नहीं किया गया है, तालिकाएँ स्वचालित रूप से अनुकूलित होती हैं।

यदि आप अप्रत्याशित SSTs का अनुभव कर रहे हैं या क्लस्टर के सभी नोड्स में तालिकाएँ द्विआधारी समान हों, तो आपको:
1. [auto_optimize](../Server_settings/Searchd.md#auto_optimize) को अक्षम करें।
2. तालिकाओं को मैन्युअल रूप से अनुकूलित करें:
<!-- example cluster_manual_drop -->
क्लस्टर में से एक नोड पर, तालिका को निकालें:
<!-- request SQL -->
```sql
ALTER CLUSTER mycluster DROP myindex;
```
<!-- end -->
<!-- example cluster_manual_optimize -->
तालिका का अनुकूलन करें:
<!-- request SQL -->
```sql
OPTIMIZE TABLE myindex;
```
<!-- end -->
<!-- example cluster_manual_add -->
तालिका को क्लस्टर में वापस जोड़ें:
<!-- request SQL -->
```sql
ALTER CLUSTER mycluster ADD myindex;
```
<!-- end -->
जब तालिका वापस जोड़ी जाती है, तो अनुकूलन प्रक्रिया द्वारा बनाई गई नई फ़ाइलें क्लस्टर के अन्य नोड्स में पुनरुत्पादित की जाएंगी।
अन्य नोड्स पर तालिका में किए गए किसी भी स्थानीय परिवर्तनों को खो दिया जाएगा।

तालिका डेटा संशोधन (डाला गया, प्रतिस्थापित, हटाए गए, अपडेट किए गए) को या तो:

1. स्थगित किया जाना चाहिए, या
2. उस नोड की ओर निर्देशित किया जाना चाहिए जहाँ अनुकूलन प्रक्रिया चल रही है।

ध्यान दें कि जबकि तालिका क्लस्टर से बाहर है, डालने/प्रतिस्थापित/हटाने/अपडेट करने के आदेशों को इसके संदर्भ में क्लस्टर नाम उपसर्ग के बिना संदर्भित करना चाहिए (SQL कथनों के लिए या HTTP JSON अनुरोध के मामले में क्लस्टर गुण), अन्यथा वे विफल हो जाएंगे।
जब तालिका को क्लस्टर में वापस जोड़ा जाता है, तो आपको तालिका पर लेखन संचालन फिर से शुरू करना चाहिए और क्लस्टर नाम उपसर्ग को फिर से शामिल करना चाहिए, अन्यथा वे विफल हो जाएंगे।

प्रक्रिया के दौरान, किसी भी नोड्स पर खोज संचालन सामान्य रूप से उपलब्ध रहते हैं।

<!-- proofread -->
