# तालिका को फ्रीज़ करना

<!-- example freeze -->

```sql
FREEZE tbl1[, tbl2, ...]
```

`FREEZE` एक वास्तविक समय/plain तालिका को सुरक्षित [बैकअप](../Securing_and_compacting_a_table/Backup_and_restore.md) के लिए तैयार करता है। विशेष रूप से, यह:
1. तालिका संकुचन को निष्क्रिय करता है। यदि तालिका वर्तमान में संकुचित हो रही है, तो `FREEZE` इसे सुचारू रूप से बाधित कर देगा।
2. वर्तमान RAM भाग को एक डिस्क भाग में स्थानांतरित करता है।
3. गुण विशेषताओं को फ्लश करता है।
4. उन निहित क्रियाओं को अक्षम करता है जो डिस्क फाइलों को संशोधित कर सकती हैं।
5. तालिका की लॉक की गई काउंटर में वृद्धि करता है।
6. तालिका से संबंधित वास्तविक फ़ाइल सूची दर्शाता है।

यदि तालिका पहले से ही फ्रीज़ (लॉक) है, तो `FREEZE`:
1. तालिका की लॉक की गई काउंटर में वृद्धि करेगा।
2. तालिका से संबंधित वास्तविक फ़ाइल सूची दर्शाएगा।

अंतर्निर्मित उपकरण [manticore-backup](../Securing_and_compacting_a_table/Backup_and_restore.md) `FREEZE` का उपयोग डेटा स्थिरता सुनिश्चित करने के लिए करता है। यदि आप अपना खुद का बैकअप समाधान बनाना चाहते हैं या अन्य कारणों से तालिकाएँ फ्रीज़ करने की आवश्यकता है, तो बस इन चरणों का पालन करें:
1. एक तालिका (या कुछ) को `FREEZE` करें।
2. `FREEZE` कमांड का आउटपुट कैप्चर करें और निर्दिष्ट फ़ाइलों का बैकअप लें।
3. काम खत्म होने पर तालिका(ओं) को `UNFREEZE` करें।

<!-- request Example -->
```sql
FREEZE t;
```

<!-- response Example -->
```sql
+-------------------+---------------------------------+
| file              | normalized                      |
+-------------------+---------------------------------+
| data/t/t.0.spa    | /work/anytest/data/t/t.0.spa    |
| data/t/t.0.spd    | /work/anytest/data/t/t.0.spd    |
| data/t/t.0.spds   | /work/anytest/data/t/t.0.spds   |
| data/t/t.0.spe    | /work/anytest/data/t/t.0.spe    |
| data/t/t.0.sph    | /work/anytest/data/t/t.0.sph    |
| data/t/t.0.sphi   | /work/anytest/data/t/t.0.sphi   |
| data/t/t.0.spi    | /work/anytest/data/t/t.0.spi    |
| data/t/t.0.spm    | /work/anytest/data/t/t.0.spm    |
| data/t/t.0.spp    | /work/anytest/data/t/t.0.spp    |
| data/t/t.0.spt    | /work/anytest/data/t/t.0.spt    |
| data/t/t.meta     | /work/anytest/data/t/t.meta     |
| data/t/t.ram      | /work/anytest/data/t/t.ram      |
| data/t/t.settings | /work/anytest/data/t/t.settings |
+-------------------+---------------------------------+
13 rows in set (0.01 sec)
```

<!-- end -->

`file` कॉलम तालिका के फ़ाइल पथों को चल रहे उदाहरण की [data_dir](../Server_settings/Searchd.md#data_dir) के भीतर दर्शाता है। `normalized` कॉलम उन फ़ाइलों के लिए पूर्ण पथ प्रदर्शित करता है। एक तालिका का बैकअप लेने के लिए, बस बिना अतिरिक्त तैयारी के प्रदान की गई फ़ाइलों की नकल करें।

जब एक तालिका फ्रीज़ हो जाती है, तो आप `UPDATE` क्वेरीज़ निष्पादित नहीं कर सकते; वे तब तक इंतजार करेंगी जब तक तालिका अनफ्रीज़ नहीं हो जाती।

इसके अलावा, `DELETE` और `REPLACE` क्वेरीज़ कोटे की पहचान के कुछ प्रतिबंध हैं जब तालिका फ्रीज़ होती है:
* यदि `DELETE` वर्तमान RAM भाग में एक दस्तावेज़ को प्रभावित करता है - तो यह अनुमति है।
* यदि `DELETE` किसी डिस्क भाग में एक दस्तावेज़ को प्रभावित करता है लेकिन पहले ही हटा दिया गया था - तो यह अनुमति है।
* यदि `DELETE` किसी वास्तविक डिस्क भाग को परिवर्तित करेगा - तो यह तब तक इंतजार करेगा जब तक तालिका अनफ्रीज़ नहीं हो जाती।

मैन्युअल रूप से एक फ्रीज़ तालिका के RAM भाग को `FLUSH` करना 'सफलता' की सूचना देगा, लेकिन कोई वास्तविक बचत नहीं होगी।

एक फ्रीज़ तालिका का `DROP`/`TRUNCATE` **अनुमति** है क्योंकि ये क्रियाएँ निहित नहीं होती हैं। हम मानते हैं कि यदि आप एक तालिका को कट करते हैं या गिराते हैं, तो आपको इसका बैकअप लेने की आवश्यकता नहीं है; इसलिए, इसे प्रारंभ में फ्रीज़ नहीं किया जाना चाहिए।

एक फ्रीज़ तालिका में `INSERT` करना समर्थित है लेकिन सीमित है: नई डेटा RAM में (जैसे सामान्य) संग्रहित होगी जब तक `rt_mem_limit` तक पहुँच नहीं जाती; फिर, नई सम्मिलन तालिका के अनफ्रीज़ होने की प्रतीक्षा करेंगी।

यदि आप एक फ्रीज़ तालिका के साथ डेमॉन को बंद कर देते हैं, तो यह ऐसा व्यवहार करेगा मानो इसे एक गंदा शटडाउन experienced किया हो (जैसे, `kill -9`): नए डाले गए डेटा डिस्क पर RAM-भाग में **नहीं** बचाए जाएंगे, और पुनः आरंभ होने पर, इसे एक बाइनरी लॉग (यदि कोई हो) से पुनर्स्थापित किया जाएगा या खो जाएगा (यदि बाइनरी लॉगिंग बंद है)।

## तालिका को अनफ्रीज़ करना

<!-- example unfreeze -->

```sql
UNFREEZE tbl1[, tbl2, ...]
```

`UNFREEZE` कमांड तालिका की लॉक की गई काउंटर को घटाता है, और यदि यह शून्य तक पहुँचता है, तो पहले से ब्लॉक किए गए क्रियाओं को पुनः सक्रिय करता है और आंतरिक संकुचन सेवा को फिर से शुरू करता है। कोई भी क्रियाएँ जो तालिका के अनफ्रीज़ होने की प्रतीक्षा कर रही थीं, वे भी सुचारू रूप से फिर से शुरू होंगी और पूरी होंगी।

<!-- request Example -->
```sql
UNFREEZE tbl;
```

<!-- end -->

## तालिका की लॉक स्थिति का निरीक्षण करना

<!-- example show_table_status -->

आप यह जांचने के लिए `SHOW table_name STATUS` का उपयोग कर सकते हैं कि तालिका फ्रीज़ है या नहीं।

तालिका के स्थिति में लॉक की गई काउंटर `locked` कॉलम के तहत प्रदर्शित होती है। शून्य का मान यह संकेत करता है कि तालिका फ्रीज़ नहीं है, जबकि गैर-शून्य मान सक्रिय लॉक की संख्या को दर्शाता है। प्रत्येक स्पष्ट `FREEZE` कमांड और निहित लॉकिंग (जैसे जब तालिका एक क्लस्टर का हिस्सा है और एक प्रतिकृति प्रक्रिया इसे एक प्रतिकृति के लिए दाता के रूप में चयनित करती है) काउंटर को बढ़ाता है। प्रत्येक `UNFREEZE` कमांड काउंटर को घटाता है, अंततः शून्य तक।

<!-- request Example -->

```sql
SHOW TABLE `foo` STATUS LIKE 'locked';
```

<!-- response Example -->

```sql
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| locked        | 2     |
+---------------+-------+
1 row in set (0,00 sec)
```

<!-- end -->

## SHOW LOCKS

<!-- example show_locks -->

लॉक की गई तालिकाएँ `SHOW LOCKS` कमांड का उपयोग करके भी प्रदर्शित की जाती हैं। लॉक काउंटर `Additional Info` कॉलम में दिखाए जाते हैं।

<!-- request Example -->

```sql
SHOW LOCKS;
```

<!-- response Example -->

```sql
+-----------+------+-----------+-----------------+
| Type      | Name | Lock Type | Additional Info |
+-----------+------+-----------+-----------------+
| rt        | a    | freeze    | Count: 1        |
| percolate | bar  | freeze    | Count: 3        |
| rt        | foo  | freeze    | Count: 2        |
+-----------+------+------+-----------+-----------------+
3 पंक्तियाँ सेट में (0,01 सेकंड)
```

<!-- end -->
# एक तालिका को फ्रीज करना

<!-- example freeze -->

```sql
FREEZE tbl1[, tbl2, ...]
```

`FREEZE` एक वास्तविक समय / साधारण तालिका को सुरक्षित [बैकअप](../Securing_and_compacting_a_table/Backup_and_restore.md) के लिए तैयार करता है। विशेष रूप से, यह:
1. तालिका संकुचन को निष्क्रिय करता है। यदि तालिका वर्तमान में संकुचित हो रही है, तो `FREEZE` इसे सौम्य तरीके से बाधित करेगा।
2. वर्तमान RAM चंक को एक डिस्क चंक में स्थानांतरित करता है।
3. विशेषताएँ फ्लश करता है।
4. आंतरिक संचालन को अक्षम करता है जो डिस्क फाइलों को संशोधित कर सकते हैं।
5. तालिका के लॉक किया गया घटक बढ़ाता है।
6. तालिका से संबंधित वास्तविक फ़ाइल सूची दिखाता है।

यदि तालिका पहले से ही फ्रीज (लॉक) है, तो `FREEZE` करेगा:
1. तालिका के लॉक किया गया घटक को बढ़ाएगा।
2. तालिका से संबंधित वास्तविक फ़ाइल सूची दिखाएगा।

अंतर्निर्मित उपकरण [manticore-backup](../Securing_and_compacting_a_table/Backup_and_restore.md) `FREEZE` का उपयोग डेटा संगति सुनिश्चित करने के लिए करता है। यदि आप अपने खुद के बैकअप समाधान बनाना चाहते हैं या अन्य कारणों से तालिकाओं को फ्रीज करने की आवश्यकता है, तो बस इन चरणों का पालन करें:
1. एक तालिका (या कुछ) को `FREEZE` करें।
2. `FREEZE` कमांड का आउटपुट कैप्चर करें और निर्दिष्ट फ़ाइलों का बैकअप लें।
3. काम पूरा होने पर तालिका(ओं) को `UNFREEZE` करें।

<!-- request Example -->
```sql
FREEZE t;
```

<!-- response Example -->
```sql
+-------------------+---------------------------------+
| file              | normalized                      |
+-------------------+---------------------------------+
| data/t/t.0.spa    | /work/anytest/data/t/t.0.spa    |
| data/t/t.0.spd    | /work/anytest/data/t/t.0.spd    |
| data/t/t.0.spds   | /work/anytest/data/t/t.0.spds   |
| data/t/t.0.spe    | /work/anytest/data/t/t.0.spe    |
| data/t/t.0.sph    | /work/anytest/data/t/t.0.sph    |
| data/t/t.0.sphi   | /work/anytest/data/t/t.0.sphi   |
| data/t/t.0.spi    | /work/anytest/data/t/t.0.spi    |
| data/t/t.0.spm    | /work/anytest/data/t/t.0.spm    |
| data/t/t.0.spp    | /work/anytest/data/t/t.0.spp    |
| data/t/t.0.spt    | /work/anytest/data/t/t.0.spt    |
| data/t/t.meta     | /work/anytest/data/t/t.meta     |
| data/t/t.ram      | /work/anytest/data/t/t.ram      |
| data/t/t.settings | /work/anytest/data/t/t.settings |
+-------------------+---------------------------------+
13 rows in set (0.01 sec)
```

<!-- end -->

`file` कॉलम तालिका की फ़ाइल पथों को [data_dir](../Server_settings/Searchd.md#data_dir) में चल रही इंस्टेंस के भीतर दर्शाता है। `normalized` कॉलम उन फ़ाइलों के लिए पूर्ण पथ प्रदर्शित करता है। एक तालिका का बैकअप लेने के लिए, बस प्रदान की गई फ़ाइलों की नकल करें बिना अतिरिक्त तैयारी के।

जब एक तालिका फ्रीज होती है, तो आप `UPDATE` क्वेरी नहीं चला सकते; वे तब तक इंतजार करेंगे जब तक तालिका अनफ्रीज न हो जाए।

इसके अलावा, `DELETE` और `REPLACE` क्वेरियों पर कुछ प्रतिबंध हैं जब तालिका फ्रीज होती है:
* यदि `DELETE` वर्तमान RAM चंक में किसी दस्तावेज़ को प्रभावित करता है - तो यह अनुमति है।
* यदि `DELETE` एक डिस्क चंक में किसी दस्तावेज़ को प्रभावित करता है लेकिन पहले से हटा दिया गया था - तो यह अनुमत है।
* यदि `DELETE` किसी वास्तविक डिस्क चंक को संशोधित करेगा - तो यह तब तक इंतजार करेगा जब तक तालिका अनफ्रीज न हो जाए।

एक फ्रीज तालिका का RAM चंक को मैन्युअल रूप से `FLUSH` करना 'सफलता' की रिपोर्ट करेगा, लेकिन कोई वास्तविक बचत नहीं होगी।

एक फ्रीज तालिका का `DROP`/`TRUNCATE` **अनुमत** है क्योंकि ये संचालन प्रतिक्रियाशील नहीं होते हैं। हम यह मानते हैं कि यदि आप एक तालिका को ट्रंक करते हैं या ड्रॉप करते हैं, तो आपको इसका बैकअप लेने की आवश्यकता नहीं है; इसलिए, इसे शुरू में फ्रीज नहीं किया जाना चाहिए।

एक फ्रीज तालिका में `INSERT` करना समर्थित है लेकिन सीमित है: नया डेटा RAM में (जैसे आमतौर पर) संग्रहित होगा जब तक कि `rt_mem_limit` तक नहीं पहुँच जाता; फिर, नए डालने तब तक इंतजार करेंगे जब तक तालिका अनफ्रीज न हो जाए।

यदि आप एक फ्रीज तालिका के साथ डेमॉन को बंद कर देते हैं, तो यह ऐसा कार्य करेगा जैसे कि इसे एक गंदा शटडाउन का अनुभव हुआ हो (जैसे, `kill -9`): हाल ही में डाले गए डेटा को डिस्क पर RAM-चंक में **नहीं** बचाया जाएगा, और पुनः आरंभ होने पर, इसे एक बाइनरी लॉग (यदि कोई हो) से पुनर्स्थापित किया जाएगा या खो जाएगा (यदि बाइनरी लॉगिंग निष्क्रिय है)।

# एक तालिका को अनफ्रीज़ करना

<!-- example unfreeze -->

```sql
UNFREEZE tbl1[, tbl2, ...]
```

`UNFREEZE` कमांड तालिका के लॉक किया गया घटक को कम करता है, और यदि यह शून्य पर पहुँच जाता है, तो पहले से अवरोधित संचालन को फिर से सक्रिय करता है और आंतरिक संकूचन सेवा को फिर से शुरू करता है। किसी भी संचालन जो तालिका के अनफ्रीज होने का इंतजार कर रहे थे, वे भी फिर से शुरू होंगे और सामान्य रूप से पूर्ण होंगे।

<!-- request Example -->
```sql
UNFREEZE tbl;
```

<!-- end -->

# तालिका की लॉक स्थिति का निरीक्षण करना

<!-- example show_table_status -->

आप जांचने के लिए `SHOW table_name STATUS` का उपयोग कर सकते हैं कि क्या एक तालिका फ्रीज है या नहीं।

तालिका की स्थिति में लॉक किया गया घटक `locked` कॉलम के तहत प्रदर्शित होता है। शून्य का मान दर्शाता है कि तालिका फ्रीज नहीं है, जबकि एक गैर-शून्य मान सक्रिय लॉक की संख्या को दर्शाता है। प्रत्येक स्पष्ट `FREEZE` कमांड और निहित लॉकिंग (जैसे जब तालिका एक क्लस्टर का हिस्सा होती है और एक प्रतिकृति दिनचर्या इसे प्रतिकृत के लिए दाता के रूप में चुनती है) घटक को बढ़ाते हैं। प्रत्येक `UNFREEZE` कमांड घटक को कम करता है, अंततः शून्य तक।

<!-- request Example -->

```sql
SHOW TABLE `foo` STATUS LIKE 'locked';
```

<!-- response Example -->

```sql
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| locked        | 2     |
+---------------+-------+
1 row in set (0,00 sec)
```

<!-- end -->

# SHOW LOCKS

<!-- example show_locks -->

लॉक की गई तालिकाओं को `SHOW LOCKS` कमांड का उपयोग करके भी प्रदर्शित किया जाता है। लॉक घटक `Additional Info` कॉलम में दिखाए जाते हैं।

<!-- request Example -->

```sql
SHOW LOCKS;
```

<!-- response Example -->

```sql
+-----------+------+-----------+-----------------+
| Type      | Name | Lock Type | Additional Info |
+-----------+------+-----------+-----------------+
| rt        | a    | freeze    | Count: 1        |
| percolate | bar  | freeze    | Count: 3        |
| rt        | foo  | freeze    | Count: 2        |
+-----------+------+-----------+-----------------+
3 पंक्तियाँ सेट में (0.01 सेकंड)
```

<!-- end -->
