# सेक्शन "Searchd" कॉन्फ़िगरेशन में
नीचे दिए गए सेटिंग्स `searchd` अनुभाग में Manticore खोज कॉन्फ़िगरेशन फ़ाइल में सर्वर के व्यवहार को नियंत्रित करने के लिए उपयोग की जाने वाली हैं। प्रत्येक सेटिंग का सारांश नीचे दिया गया है:
### access_plain_attrs
यह सेटिंग [access_plain_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) के लिए पूरे इंस्टेंस-व्यापी डिफ़ॉल्ट्स को सेट करती है। यह वैकल्पिक है, जिसका डिफ़ॉल्ट मान `mmap_preread` है।
`access_plain_attrs` निर्देश आपको इस खोजd इंस्टेंस द्वारा प्रबंधित सभी तालिकाओं के लिए [access_plain_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) का डिफ़ॉल्ट मान परिभाषित करने की अनुमति देता है। प्रति-तालिका निर्देशों की उच्च प्राथमिकता होती है और ये इस इंस्टेंस-व्यापी डिफ़ॉल्ट को ओवरराइड करेंगे, जिससे अधिक सूक्ष्म नियंत्रण प्रदान होगा।
### access_blob_attrs
यह सेटिंग [access_blob_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) के लिए पूरे इंस्टेंस-व्यापी डिफ़ॉल्ट्स को सेट करती है। यह वैकल्पिक है, जिसका डिफ़ॉल्ट मान `mmap_preread` है।
`access_blob_attrs` निर्देश आपको इस खोजd इंस्टेंस द्वारा प्रबंधित सभी तालिकाओं के लिए [access_blob_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) का डिफ़ॉल्ट मान परिभाषित करने की अनुमति देता है। प्रति-तालिका निर्देशों की उच्च प्राथमिकता होती है और ये इस इंस्टेंस-व्यापी डिफ़ॉल्ट को ओवरराइड करेंगे, जिससे अधिक सूक्ष्म नियंत्रण प्रदान होगा।
### access_doclists
यह सेटिंग [access_doclists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) के लिए पूरे इंस्टेंस-व्यापी डिफ़ॉल्ट्स को सेट करती है। यह वैकल्पिक है, जिसका डिफ़ॉल्ट मान `file` है।
`access_doclists` निर्देश आपको इस खोजd इंस्टेंस द्वारा प्रबंधित सभी तालिकाओं के लिए [access_doclists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) का डिफ़ॉल्ट मान परिभाषित करने की अनुमति देता है। प्रति-तालिका निर्देशों की उच्च प्राथमिकता होती है और ये इस इंस्टेंस-व्यापी डिफ़ॉल्ट को ओवरराइड करेंगे, जिससे अधिक सूक्ष्म नियंत्रण प्रदान होगा।
### access_hitlists
यह सेटिंग [access_hitlists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) के लिए पूरे इंस्टेंस-व्यापी डिफ़ॉल्ट्स को सेट करती है। यह वैकल्पिक है, जिसका डिफ़ॉल्ट मान `file` है।
`access_hitlists` निर्देश आपको इस खोजd इंस्टेंस द्वारा प्रबंधित सभी तालिकाओं के लिए [access_hitlists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) का डिफ़ॉल्ट मान परिभाषित करने की अनुमति देता है। प्रति-तालिका निर्देशों की उच्च प्राथमिकता होती है और ये इस इंस्टेंस-व्यापी डिफ़ॉल्ट को ओवरराइड करेंगे, जिससे अधिक सूक्ष्म नियंत्रण प्रदान होगा।
### access_dict
यह सेटिंग [access_dict](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) के लिए पूरे इंस्टेंस-व्यापी डिफ़ॉल्ट्स को सेट करती है। यह वैकल्पिक है, जिसका डिफ़ॉल्ट मान `mmap_preread` है।
`access_dict` निर्देश आपको इस खोजd इंस्टेंस द्वारा प्रबंधित सभी तालिकाओं के लिए [access_dict](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) का डिफ़ॉल्ट मान परिभाषित करने की अनुमति देता है। प्रति-तालिका निर्देशों की उच्च प्राथमिकता होती है और ये इस इंस्टेंस-व्यापी डिफ़ॉल्ट को ओवरराइड करेंगे, जिससे अधिक सूक्ष्म नियंत्रण प्रदान होगा।
### agent_connect_timeout
यह सेटिंग [agent_connect_timeout](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_connect_timeout) पैरामीटर के लिए पूरे इंस्टेंस-व्यापी डिफ़ॉल्ट्स को सेट करती है।
### agent_query_timeout
यह सेटिंग [agent_query_timeout](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_query_timeout) पैरामीटर के लिए पूरे इंस्टेंस-व्यापी डिफ़ॉल्ट्स को सेट करती है। इसे `OPTION agent_query_timeout=XXX` धारा का उपयोग करके प्रति-पूछताछ आधार पर ओवरराइड किया जा सकता है।
### agent_retry_count
यह सेटिंग एक पूर्णांक है जो निर्दिष्ट करता है कि Manticore कितनी बार कनेक्ट करने और वितरित तालिका के माध्यम से दूरस्थ एजेंटों से पूछताछ करने का प्रयास करेगा इससे पहले कि यह एक गंभीर पूछताछ त्रुटि की रिपोर्ट करे। इसका डिफ़ॉल्ट मान 0 (अर्थात, कोई पुनः प्रयास नहीं) है। आप इस मान को `OPTION retry_count=XXX` धारा का उपयोग करके प्रति-पूछताछ आधार पर भी सेट कर सकते हैं। यदि एक प्रति-पूछताछ विकल्प प्रदान किया गया है, तो यह कॉन्फ़िगरेशन में निर्दिष्ट मान को ओवरराइड करेगा।
ध्यान दें कि यदि आप [एजेंट मिरर्स](../Creating_a_cluster/Remote_nodes/Mirroring.md#Agent-mirrors) का उपयोग करते हैं अपने वितरित तालिका की परिभाषा में, सर्वर प्रत्येक कनेक्शन प्रयास के लिए चुने हुए [ha_strategy](../Creating_a_cluster/Remote_nodes/Load_balancing.md#ha_strategy) के अनुसार एक अलग मिरर का चयन करेगा। इस मामले में, `agent_retry_count` सभी मिरर्स के लिए एकत्र होगा।
उदाहरण के लिए, यदि आपके पास 10 मिरर्स हैं और आप `agent_retry_count=5` सेट करते हैं, तो सर्वर संभवतः 50 बार पुनः प्रयास करेगा, प्रत्येक 10 मिरर्स के लिए औसतन 5 प्रयास मानते हुए (यदि `ha_strategy = roundrobin` विकल्प है, तो यह मामला होगा)।
हालाँकि, [एजेंट](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent) पर `retry_count` विकल्प के रूप में प्रदान किया गया मान एक निरपेक्ष सीमा के रूप में कार्य करता है। दूसरे शब्दों में, एजेंट परिभाषा में `[retry_count=2]` विकल्प हमेशा अधिकतम 2 प्रयासों का मतलब होता है, भले ही आप एजेंट के लिए 1 या 10 मिरर्स निर्दिष्ट करें।
### agent_retry_delay
यह सेटिंग एक पूर्णांक है जो मिलीसेकंड में (या [special_suffixes](../Server_settings/Special_suffixes.md)) है जो निर्दिष्ट करता है कि Manticore कितनी देर तक दूरस्थ एजेंट से पूछताछ करने का प्रयास करने से पहले विलंब होगा। यह मान केवल तब प्रासंगिक है जब शून्य [agent_retry_count](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md) या गैर-शून्य प्रति-पूछताछ `retry_count` निर्दिष्ट किया गया हो। डिफ़ॉल्ट मान 500 है। आप इस मान को `OPTION retry_delay=XXX` धारा का उपयोग करके प्रति-पूछताछ आधार पर भी सेट कर सकते हैं। यदि एक प्रति-पूछताछ विकल्प प्रदान किया गया है, तो यह कॉन्फ़िगरेशन में निर्दिष्ट मान को ओवरराइड करेगा।
### attr_flush_period
<!-- example conf attr_flush_period -->
जब [Update](../Data_creation_and_modification/Updating_documents/UPDATE.md) का उपयोग करके दस्तावेज़ विशेषताओं को वास्तविक समय में संशोधित किया जाता है, तो परिवर्तन पहले विशेषताओं की एक इन-मेहज़री प्रति में लिखे जाते हैं। ये अपडेट एक मेमोरी-मैप्ड फ़ाइल में होते हैं, जिसका मतलब है कि OS यह तय करता है कि परिवर्तन कब डिस्क पर लिखे जाएं। `searchd` के सामान्य शटडाउन पर (`SIGTERM` संकेत द्वारा सक्रिय किया गया), सभी परिवर्तनों को डिस्क पर लिखने के लिए मजबूर किया जाता है।

आप `searchd` को यह निर्देश भी दे सकते हैं कि वह डेटा हानि को रोकने के लिए एक निश्चित समयांतराल पर इन परिवर्तनों को वापस डिस्क पर लिखे। इन फ्लशों के बीच का अंतराल `attr_flush_period` द्वारा निर्धारित किया जाता है, जिसे सेकंड में निर्दिष्ट किया जाता है (या [special_suffixes](../Server_settings/Special_suffixes.md))।

डिफ़ॉल्ट रूप से, मान 0 होता है, जो आवर्ती फ्लशिंग को बंद कर देता है। हालाँकि, सामान्य शटडाउन के दौरान फ्लशिंग अभी भी होगी।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
attr_flush_period = 900 # हर 15 मिनट में डिस्क पर अपडेट स्थायी करें
```
<!-- end -->

### auto_optimize

<!-- example conf auto_optimize -->
यह सेटिंग तालिका संकुचन के लिए स्वचालित [OPTIMIZE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE) प्रक्रिया को नियंत्रित करती है।

डिफ़ॉल्ट रूप से तालिका संकुचन स्वचालित रूप से होता है। आप इस व्यवहार को `auto_optimize` सेटिंग के साथ संशोधित कर सकते हैं:
* 0 स्वचालित तालिका संकुचन को बंद करने के लिए (आप अभी भी मैन्युअल रूप से `OPTIMIZE` का कॉल कर सकते हैं)
* 1 इसे स्पष्ट रूप से सक्षम करने के लिए
* इसे 2 से गुणा करते समय सक्षम करने के लिए।

डिफ़ॉल्ट रूप से, OPTIMIZE तब तक चलता है जब तक डिस्क के टुकड़ों की संख्या तर्कसंगत CPU कोर की संख्या से कम या समान न हो जाए जो 2 से गुणा की गई हो।

हालाँकि, यदि तालिका में KNN अनुक्रमणिका के साथ विशेषताएँ हैं, तो यह सीमा अलग होती है। इस मामले में, इसे भौतिक CPU कोर की संख्या को 2 से विभाजित करके सेट किया जाता है ताकि KNN खोज के प्रदर्शन में सुधार हो सके।

ध्यान दें कि `auto_optimize` को चालू या बंद करने से आपको मैन्युअल रूप से [OPTIMIZE TABLE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE) चलाने से नहीं रोका जाता है।

<!-- intro -->
##### उदाहरण:

<!-- request Disable -->
```ini
auto_optimize = 0 # स्वचालित OPTIMIZE को बंद करें
```

<!-- request Throttle -->
```ini
auto_optimize = 2 # OPTIMIZE 16 टुकड़ों (4 CPU कोर सर्वर पर) पर शुरू होता है
```

<!-- end -->

### auto_schema

<!-- example conf auto_schema -->
Manticore उन तालिकाओं के स्वचालित निर्माण का समर्थन करता है जो अभी तक मौजूद नहीं हैं लेकिन INSERT बयानों में निर्दिष्ट हैं। यह सुविधा डिफ़ॉल्ट रूप से सक्षम होती है। इसे बंद करने के लिए, अपनी कॉन्फ़िगरेशन में स्पष्ट रूप से `auto_schema = 0` सेट करें। इसे फिर से सक्षम करने के लिए, `auto_schema = 1` सेट करें या कॉन्फ़िगरेशन से `auto_schema` सेटिंग को हटा दें।

ध्यान रखें कि `/bulk` HTTP एंडपॉइंट स्वचालित तालिका निर्माण का समर्थन नहीं करता है।

> नोट: [ऑटो स्कीमा कार्यक्षमता](../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md#Auto-schema) के लिए [Manticore Buddy](../Installation/Manticore_Buddy.md) की आवश्यकता है। यदि यह काम नहीं करता है, तो सुनिश्चित करें कि Buddy स्थापित है।

<!-- request Disable -->
```ini
auto_schema = 0 # स्वचालित तालिका निर्माण को बंद करें
```

<!-- request Enable -->
```ini
auto_schema = 1 # स्वचालित तालिका निर्माण को सक्षम करें
```

<!-- end -->

### binlog_flush

<!-- example conf binlog_flush -->
यह सेटिंग बाइनरी लॉग लेनदेन फ्लश/सिंक मोड को नियंत्रित करती है। यह वैकल्पिक है, जिसका डिफ़ॉल्ट मान 2 है (हर लेनदेन को फ्लश करें, हर सेकंड को सिंक करें)।

यह निर्देशा निर्धारित करता है कि बाइनरी लॉग कितनी बार OS को फ्लश किया जाएगा और डिस्क पर सिंक किया जाएगा। तीन समर्थित मोड हैं:

*  0, हर सेकंड फ्लश और सिंक करें। यह सर्वश्रेष्ठ प्रदर्शन प्रदान करता है, लेकिन यदि सर्वर क्रैश या OS/हार्डवेयर क्रैश होता है तो 1 सेकंड के committed लेनदेन को खोया जा सकता है।
*  1, हर लेनदेन को फ्लश और सिंक करें। यह मोड सबसे खराब प्रदर्शन प्रदान करता है लेकिन प्रत्येक committed लेनदेन के डेटा को सुरक्षित करने की गारंटी देता है।
*  2, हर लेनदेन को फ्लश करें, हर सेकंड सिंक करें। यह मोड अच्छा प्रदर्शन प्रदान करता है और सुनिश्चित करता है कि हर committed लेनदेन सर्वर क्रैश की स्थिति में सुरक्षित है। हालाँकि, OS/हार्डवेयर क्रैश के मामले में, 1 सेकंड के भीतर committed लेनदेन खोए जा सकते हैं।

जो लोग MySQL और InnoDB से परिचित हैं, उनके लिए, यह निर्देशा `innodb_flush_log_at_trx_commit` के समान है। अधिकांश मामलों में, डिफ़ॉल्ट हाइब्रिड मोड 2 तेजी और सुरक्षा का अच्छा संतुलन प्रदान करता है, जिसमें सर्वर क्रैश के खिलाफ पूर्ण RT तालिका डेटा सुरक्षा और कुछ हार्डवेयर क्रैश के खिलाफ सुरक्षा होती है।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
binlog_flush = 1 # अंतिम सुरक्षा, कम गति
```
<!-- end -->


### binlog_max_log_size

<!-- example conf binlog_max_log_size -->
यह सेटिंग अधिकतम बाइनरी लॉग फ़ाइल आकार को नियंत्रित करती है। यह वैकल्पिक है, जिसका डिफ़ॉल्ट मान 256 MB है।

एक नया बाइनरी लॉग फ़ाइल तब ज़बरदस्ती खोला जाएगा जब वर्तमान बाइनरी लॉग फ़ाइल इस आकार सीमा तक पहुँच जाएगी। इससे लॉग का अधिक बारीकी से विनियमन होता है और कुछ सीमावर्ती कार्यभारों के तहत अधिक कुशल बाइनरी लॉग डिस्क उपयोग को प्रेरित किया जा सकता है। 0 का मान इंगित करता है कि बाइनरी लॉग फ़ाइल को आकार के आधार पर फिर से नहीं खोला जाना चाहिए।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
binlog_max_log_size = 16M
```
<!-- end -->


### binlog_path

<!-- example conf binlog_path -->
यह सेटिंग बाइनरी लॉग (जिसे लेनदेन लॉग भी कहा जाता है) फ़ाइलों के लिए पथ को निर्धारित करती है। यह वैकल्पिक है, जिसका डिफ़ॉल्ट मान निर्माण समय की कॉन्फ़िगर की गई डेटा डायरेक्टरी है (जैसे, `/var/lib/manticore/data/binlog.*` Linux में)।

बाइनरी लॉग का उपयोग RT तालिका डेटा के क्रैश वसूली और उन विशेषताओं के अपडेट के लिए किया जाता है जो अन्यथा केवल RAM में स्टोर किए जाते जब तक फ्लश नहीं किया जाता। जब लॉगिंग सक्षम होती है, तो RT तालिका में हर लेनदेन को COMMIT किया जाता है और इसे लॉग फ़ाइल में लिखा जाता है। लॉग को फिर अनक्लीन शटडाउन के बाद स्टार्टअप पर स्वचालित रूप से पुन: पेश किया जाता है, लॉग किए गए परिवर्तनों को पुनर्प्राप्त करते हुए।
`binlog_path` निर्देश बाइनरी लॉग फ़ाइलों के स्थान को निर्दिष्ट करता है। इसमें केवल पथ होना चाहिए; `searchd` आवश्यकतानुसार निर्देशिका में कई `binlog.*` फ़ाइलें बनाएगा और हटाएगा (बाइनलॉग डेटा, मेटाडेटा और लॉक फ़ाइलों सहित)।

एक खाली मान बाइनरी लॉगिंग को अक्षम करता है, जो प्रदर्शन में सुधार करता है लेकिन RT तालिका के डेटा को जोखिम में डालता है।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
binlog_path = # लॉगिंग अक्षम करें
binlog_path = /var/lib/manticore/data # /var/lib/manticore/data/binlog.001 आदि बनाए जाएंगे
```
<!-- end -->


### buddy_path

<!-- example conf buddy_path -->
यह सेटिंग Manticore Buddy बाइनरी के पथ को निर्धारित करती है। यह वैकल्पिक है, जिसका डिफ़ॉल्ट मान बिल्ड-टाइम कॉन्फ़िगर किया गया पथ है, जो विभिन्न ऑपरेटिंग सिस्टम में भिन्न होता है। आमतौर पर, आपको इस सेटिंग को संशोधित करने की आवश्यकता नहीं होती। हालांकि, यह तब उपयोगी हो सकता है जब आप Manticore Buddy को डीबग मोड में चलाना चाहते हैं, Manticore Buddy में बदलाव करना चाहते हैं, या एक नया प्लगइन लागू करना चाहते हैं। अंतिम मामले में, आप https://github.com/manticoresoftware/manticoresearch-buddy से Buddy को `git clone` कर सकते हैं, `./plugins/` निर्देशिका में एक नया प्लगइन जोड़ सकते हैं, और Buddy स्रोत निर्देशिका में बदलाव करने के बाद `composer install --prefer-source` चला सकते हैं।

यह सुनिश्चित करने के लिए कि आप `composer` चला सकते हैं, आपके मशीन पर निम्न एक्सटेंशन के साथ PHP 8.2 या उच्च संस्करण स्थापित होना चाहिए:

```
--enable-dom
--with-libxml
--enable-tokenizer
--enable-xml
--enable-xmlwriter
--enable-xmlreader
--enable-simplexml
--enable-phar
--enable-bcmath
--with-gmp
--enable-debug
--with-mysqli
--enable-mysqlnd
```

आप Linux amd64 के लिए विशेष `manticore-executor-dev` संस्करण का भी विकल्प चुन सकते हैं जो रिलीज़ में उपलब्ध है, उदाहरण के लिए: https://github.com/manticoresoftware/executor/releases/tag/v1.0.13

यदि आप इस मार्ग का अनुसरण करते हैं, तो manticore एक्सीक्यूटर के डेव संस्करण को `/usr/bin/php` से जोड़ना याद रखें।

Manticore Buddy को अक्षम करने के लिए, मान को खाली पर सेट करें जैसा कि उदाहरण में दिखाया गया है।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
buddy_path = manticore-executor -n /usr/share/manticore/modules/manticore-buddy/src/main.php --debug # Linux में डिफ़ॉल्ट Manticore Buddy का उपयोग करें, लेकिन इसे डीबग मोड में चलाएं
buddy_path = manticore-executor -n /opt/homebrew/share/manticore/modules/manticore-buddy/bin/manticore-buddy/src/main.php --debug # MacOS arm64 में डिफ़ॉल्ट Manticore Buddy का उपयोग करें, लेकिन इसे डीबग मोड में चलाएं
buddy_path = manticore-executor -n /Users/username/manticoresearch-buddy/src/main.php --debug # गैर-डिफ़ॉल्ट स्थान से Manticore Buddy का उपयोग करें
buddy_path = # Manticore Buddy को अक्षम करता है
buddy_path = manticore-executor -n /Users/username/manticoresearch-buddy/src/main.php --debugv --skip=manticoresoftware/buddy-plugin-replace # debugv - अधिक विस्तृत लॉगिंग को सक्षम करता है, --skip - प्लगइन को छोड़ता है
```
<!-- end -->

### client_timeout

<!-- example conf client_timeout -->
यह सेटिंग स्थायी कनेक्शन का उपयोग करते समय अनुरोधों के बीच प्रतीक्षा करने के लिए अधिकतम समय (सेकंड या [विशेष_सफिक्स](../Server_settings/Special_suffixes.md)) को निर्धारित करती है। यह वैकल्पिक है, जिसका डिफ़ॉल्ट मान पांच मिनट है।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
client_timeout = 1h
```
<!-- end -->


### collation_libc_locale

<!-- example conf collation_libc_locale -->
सर्वर libc लोकेल। वैकल्पिक, डिफ़ॉल्ट C है।

libc-आधारित कोलेशन को प्रभावित करने वाला libc लोकेल निर्दिष्ट करता है। विवरण के लिए [कोलेशन](../Searching/Collations.md) अनुभाग देखें।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
collation_libc_locale = fr_FR
```
<!-- end -->


### collation_server

<!-- example conf collation_server -->
डिफ़ॉल्ट सर्वर कोलेशन। वैकल्पिक, डिफ़ॉल्ट libc_ci है।

आने वाले अनुरोधों के लिए उपयोग किए जाने वाले डिफ़ॉल्ट कोलेशन को निर्दिष्ट करता है। कोलेशन को प्रति-क्वेरी आधार पर ओवरराइड किया जा सकता है। उपलब्ध कोलेशन और अन्य विवरण के लिए [कोलेशन](../Searching/Collations.md) अनुभाग देखें।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
collation_server = utf8_ci
```
<!-- end -->


### data_dir

<!-- example conf data_dir -->
जब निर्दिष्ट किया जाता है, यह सेटिंग [रीयल-टाइम मोड](../Creating_a_table/Local_tables.md#Online-schema-management-%28RT-mode%29) को सक्षम करती है, जो डेटा योजना को प्रबंधित करने का एक महत्वपूर्ण तरीका है। मान वह पथ होना चाहिए जहां आप अपनी सभी तालिकाएं, बाइनरी लॉग और Manticore Search को इस मोड में सही ढंग से काम करने के लिए आवश्यक सभी चीजें संग्रहित करना चाहते हैं।
जब `data_dir` निर्दिष्ट किया जाता है तो [सामान्य तालिकाओं](../Creating_a_table/Local_tables/Plain_table.md) को सूचीबद्ध करने की अनुमति नहीं है। RT मोड और सामान्य मोड के बीच अंतर के बारे में अधिक जानकारी के लिए [इस अनुभाग](../Read_this_first.md#Real-time-table-vs-plain-table) को पढ़ें।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
data_dir = /var/lib/manticore
```
<!-- end -->

### diskchunk_flush_search_timeout

<!-- example conf diskchunk_flush_search_timeout -->
किसी तालिका में खोजों न होने पर स्वचालित रूप से RAM चंक को फ्लश करने से रोकने के लिए समय सीमा। वैकल्पिक, डिफ़ॉल्ट 30 सेकंड है।

खोजों की जांच करने के लिए समय, यह निर्धारित करने से पहले कि स्वचालित रूप से फ्लश किया जाए या नहीं।
स्वचालित फ्लशिंग तभी होगी जब अंतिम `diskchunk_flush_search_timeout` सेकंड में तालिका में कम से कम एक खोज हुई हो। [diskchunk_flush_write_timeout](../../Server_settings/Searchd.md#diskchunk_flush_write_timeout) के साथ काम करता है। संबंधित [प्रति-तालिका सेटिंग](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#diskchunk_flush_search_timeout) का उच्च प्राथमिकता होता है और इस उदाहरण-व्यापी डिफ़ॉल्ट को ओवरराइड कर देगा, जो अधिक बारीक नियंत्रण प्रदान करता है।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
diskchunk_flush_search_timeout = 120s
```
<!-- end -->

### diskchunk_flush_write_timeout

<!-- example conf diskchunk_flush_write_timeout -->
ऐसा समय जो बिना लिखे RAM चंक को डिस्क पर ऑटो-फ्लश करने से पहले इंतज़ार करने के लिए सेकंड में होता है। वैकल्पिक, डिफ़ॉल्ट 1 सेकंड है।

यदि `diskchunk_flush_write_timeout` सेकंड के भीतर RAM चंक में कोई लिखाई नहीं होती है, तो चंक को डिस्क पर फ्लश कर दिया जाएगा। यह [diskchunk_flush_search_timeout](../../Server_settings/Searchd.md#diskchunk_flush_search_timeout) के साथ काम करता है। ऑटो-फ्लश को निष्क्रिय करने के लिए, अपनी कॉन्फ़िगरेशन में स्पष्ट रूप से `diskchunk_flush_write_timeout = -1` सेट करें। संबंधित [प्रति-तालिका सेटिंग](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#diskchunk_flush_write_timeout) की उच्च प्राथमिकता है और यह इस इंस्‍टेंस-व्यापी डिफ़ॉल्ट को ओवरराइड कर देगी, अधिक बारीक नियंत्रण प्रदान करते हुए।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
diskchunk_flush_write_timeout = 60s
```
<!-- end -->

### docstore_cache_size

<!-- example conf docstore_cache_size -->
यह सेटिंग यह निर्दिष्ट करती है कि मेमोरी में रखे जाने वाले डॉक्यूमेंट स्टोरेज से डॉक्यूमेंट ब्लॉकों का अधिकतम आकार क्या होगा। यह वैकल्पिक है, जिसमें डिफ़ॉल्ट मान 16m (16 मेगाबाइट) है।

जब `stored_fields` का उपयोग किया जाता है, डॉक्यूमेंट ब्लॉकों को डिस्क से पढ़ा जाता है और अनकंप्रेस किया जाता है। चूंकि हर ब्लॉक आमतौर पर कई दस्तावेज़ रखता है, इसे अगले दस्तावेज़ को संसाधित करते समय पुनः उपयोग किया जा सकता है। इसके लिए, ब्लॉक को सर्वर-व्यापी कैश में रखा जाता है। कैश में अनकंप्रेस ब्लॉक होते हैं।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
docstore_cache_size = 8m
```
<!-- end -->

### engine

<!-- example conf engine -->
RT मोड में तालिकाएँ बनाते समय उपयोग किया जाने वाला डिफ़ॉल्ट एट्रिब्यूट स्टोरेज इंजन। इसे `rowwise` (डिफ़ॉल्ट) या `columnar` होना चाहिए।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
engine = columnar
```
<!-- end -->


### expansion_limit

<!-- example conf expansion_limit -->
यह सेटिंग एकल वाइल्डकार्ड के लिए अधिकतम विस्तारित कीवर्ड की संख्या को निर्धारित करती है। यह वैकल्पिक है, जिसमें डिफ़ॉल्ट मान 0 (कोई सीमा नहीं) है।

जब `dict = keywords` सक्षम किया जाता है, तब तालिकाओं पर उपस्ट्रिंग खोज करते समय, एक एकल वाइल्डकार्ड संभवतः हजारों या यहाँ तक कि लाखों मिलते कीवर्ड पैदा कर सकता है (पूरे ऑक्सफोर्ड शब्दकोश के खिलाफ `a*` मिलाने के बारे में सोचें)। यह निर्देश आपको ऐसे विस्तार के प्रभाव को सीमित करने की अनुमति देता है। `expansion_limit = N` सेट करने से विस्तार को अधिकतम N सबसे सामान्य मिलते कीवर्ड तक सीमित कर देता है (प्रत्येक वाइल्डकार्ड के लिए क्वेरी में)।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
expansion_limit = 16
```
<!-- end -->

### expansion_merge_threshold_docs

<!-- example conf expansion_merge_threshold_docs -->
यह सेटिंग विस्तारित कीवर्ड में दस्तावेज़ों की अधिकतम संख्या निर्धारित करती है जो सभी ऐसे कीवर्ड को एक साथ विलय करने की अनुमति देती है। यह वैकल्पिक है, जिसमें डिफ़ॉल्ट मान 32 है।

जब `dict = keywords` सक्षम किया जाता है, तब तालिकाओं पर उपस्ट्रिंग खोज करते समय, एक एकल वाइल्डकार्ड संभवतः हजारों या यहाँ तक कि लाखों मिलते कीवर्ड पैदा कर सकता है। यह निर्देश आपको कहता है कि कितने कीवर्ड एक साथ विलय कर सकते हैं ताकि मिलान को तेज किया जा सके लेकिन खोज में अधिक मेमोरी का उपयोग करते हैं।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
expansion_merge_threshold_docs = 1024
```
<!-- end -->

### expansion_merge_threshold_hits

<!-- example conf expansion_merge_threshold_hits -->
यह सेटिंग विस्तारित कीवर्ड में हिट्स की अधिकतम संख्या निर्धारित करती है जो सभी ऐसे कीवर्ड को एक साथ विलय करने की अनुमति देती है। यह वैकल्पिक है, जिसमें डिफ़ॉल्ट मान 256 है।

जब `dict = keywords` सक्षम किया जाता है, तब तालिकाओं पर उपस्ट्रिंग खोज करते समय, एक एकल वाइल्डकार्ड संभवतः हजारों या यहाँ तक कि लाखों मिलते कीवर्ड पैदा कर सकता है। यह निर्देश आपको कहता है कि कितने कीवर्ड एक साथ विलय कर सकते हैं ताकि मिलान को तेज किया जा सके लेकिन खोज में अधिक मेमोरी का उपयोग करते हैं।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
expansion_merge_threshold_hits = 512
```
<!-- end -->

### grouping_in_utc

यह सेटिंग यह निर्दिष्ट करती है कि API और SQL में टाइम ग्रुपिंग स्थानीय टाइमज़ोन में या UTC में गणना की जाएगी। यह वैकल्पिक है, जिसमें डिफ़ॉल्ट मान 0 (जिसका अर्थ 'स्थानीय टाइमज़ोन') है।

डिफ़ॉल्ट रूप से, सभी 'समय द्वारा समूह' एक्सप्रेशन (जैसे API में दिन, सप्ताह, महीने और वर्ष के द्वारा समूह, SQL में भी दिन, महीने, वर्ष, वर्षमहीना, वर्षमहिनादिन के द्वारा समूह) स्थानीय समय का उपयोग करके किए जाते हैं। उदाहरण के लिए, यदि आपके पास ऐसे दस्तावेज़ हैं जिनके एट्रिब्यूट टाइमड `13:00 utc` और `15:00 utc` हैं, तो समूह बनाने की स्थिति में, वे दोनों आपके स्थानीय टाइमज़ोन सेटिंग के अनुसार सुविधा समूहों में पड़ेंगे। यदि आप `utc` में रहते हैं, तो यह एक दिन होगा, लेकिन यदि आप `utc+10` में रहते हैं, तो ये दस्तावेज़ अलग-अलग `समूह द्वारा दिन` सुविधा समूहों में रखे जाएंगे (चूंकि `utc+10` टाइमज़ोन में `13:00 utc` स्थानीय समय में 23:00 है, लेकिन `15:00` अगले दिन की 01:00 है)। कभी-कभी ऐसा व्यवहार अस्वीकार्य होता है, और समय समूह बनाने को टाइमज़ोन पर निर्भर नहीं बनाने की इच्छा होती है। आप सर्वर को एक परिभाषित वैश्विक TZ पर्यावरण वेरिएबल के साथ चला सकते हैं, लेकिन यह न केवल समूह बनाने को प्रभावित करेगा बल्कि लॉग में टाइमस्टैम्पिंग को भी प्रभावित करेगा, जो शायद अवांछनीय भी हो। इस विकल्प को 'ऑन' करने (या तो कॉन्फ़िग में या SQL में [SET global](../Server_settings/Setting_variables_online.md#SET) कथन का उपयोग करके) से सभी समय समूह बनाने वाले एक्सप्रेशनों को UTC में गणना की जाएगी, शेष समय-निर्भर कार्यों (अर्थात सर्वर के लॉगिंग) को स्थानीय TZ में छोड़ते हुए।


### timezone

यह सेटिंग उन दिनांक/समय से संबंधित कार्यों द्वारा उपयोग की जाने वाली टाइमज़ोन को निर्दिष्ट करती है। डिफ़ॉल्ट रूप से स्थानीय टाइमज़ोन का उपयोग किया जाता है, लेकिन आप IANA प्रारूप (जैसे, `Europe/Amsterdam`) में एक अलग टाइमज़ोन निर्दिष्ट कर सकते हैं।

ध्यान दें कि यह सेटिंग लॉगिंग पर कोई प्रभाव नहीं डालती, जो हमेशा स्थानीय टाइमज़ोन में संचालित होती है।
इसके अलावा, ध्यान दें कि यदि `grouping_in_utc` का उपयोग किया गया है, तो 'समय के अनुसार समूह' कार्य अभी भी UTC का उपयोग करेगा, जबकि अन्य दिनांक/समय से संबंधित कार्य निर्दिष्ट टाइमजोन का उपयोग करेंगे। कुल मिलाकर, `grouping_in_utc` और `timezone` को मिलाना अनुशंसित नहीं है।

आप इस विकल्प को कॉन्फ़िगर कर सकते हैं या तो कॉन्फ़िग में या SQL में [SET global](../Server_settings/Setting_variables_online.md#SET) कथन का उपयोग करके।


### ha_period_karma

<!-- example conf ha_period_karma -->
यह सेटिंग एजेंट मिरर सांख्यिकी विंडो आकार को निर्दिष्ट करती है, जो कि सेकंड में होती है (या [special_suffixes](../Server_settings/Special_suffixes.md))। यह वैकल्पिक है, जिसका डिफ़ॉल्ट मान 60 सेकंड है।

जिस वितरित तालिका में एजेंट मिरर होते हैं (और अधिक जानकारी के लिए [एजेंट](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md) देखें), मास्टर कई विभिन्न प्रति-मिरर काउंटरों का ट्रैक रखता है। इन काउंटरों का उपयोग फेलओवर और संतुलन के लिए किया जाता है (मास्टर काउंटरों के आधार पर उपयोग के लिए सर्वश्रेष्ठ मिरर का चयन करता है)। काउंटर `ha_period_karma` सेकंड के ब्लॉकों में संचित होते हैं।

एक नए ब्लॉक की शुरुआत के बाद, मास्टर अभी भी पिछले ब्लॉक से संचित मानों का उपयोग कर सकता है जब तक नया ब्लॉक आधा भरा न हो। इसके परिणामस्वरूप, कोई भी पूर्ववर्ती इतिहास मिरर चयन को अधिकतम 1.5 गुना `ha_period_karma` सेकंड के बाद प्रभावित करना बंद कर देता है।

भले ही अधिकतम दो ब्लॉकों का उपयोग मिरर चयन के लिए किया जाता है, हाल के 15 ब्लॉकों कोInstrumentation उद्देश्यों के लिए संग्रहीत किया जाता है। इन ब्लॉकों की जांच [SHOW AGENT STATUS](../Node_info_and_management/Node_status.md#SHOW-AGENT-STATUS) कथन का उपयोग करके की जा सकती है।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
ha_period_karma = 2m
```
<!-- end -->


### ha_ping_interval

<!-- example conf ha_ping_interval -->
यह सेटिंग एजेंट मिरर पिंग के बीच का अंतराल निर्दिष्ट करती है, जो कि मिलीसेकंड में (या [special_suffixes](../Server_settings/Special_suffixes.md)) होती है। यह वैकल्पिक है, जिसका डिफ़ॉल्ट मान 1000 मिलीसेकंड है।

जिस वितरित तालिका में एजेंट मिरर होते हैं (और अधिक जानकारी के लिए [एजेंट](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md) देखें), मास्टर सभी मिररों को निष्क्रिय अवधि के दौरान एक पिंग कमांड भेजता है। इसका उद्देश्य वर्तमान एजेंट स्थिति (जीवित या मृत, नेटवर्क राउंडट्रिप आदि) को ट्रैक करना है। ऐसे पिंग के बीच का अंतराल इस निर्देश द्वारा परिभाषित किया जाता है। पिंग को अक्षम करने के लिए, `ha_ping_interval` को 0 पर सेट करें।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
ha_ping_interval = 3s
```
<!-- end -->


### hostname_lookup

`hostname_lookup` विकल्प होस्टनेम नवीनीकरण की रणनीति को परिभाषित करता है। डिफ़ॉल्ट रूप से, एजेंट होस्ट नामों के IP पते सर्वर प्रारंभ पर कैश किए जाते हैं ताकि DNS तक अत्यधिक पहुँच से बचा जा सके। हालाँकि, कुछ मामलों में, IP गतिशील रूप से बदल सकता है (जैसे क्लाउड होस्टिंग) और इसे कैश नहीं करना बेहतर हो सकता है। इस विकल्प को `request` पर सेट करने से कैशिंग बंद हो जाती है और प्रत्येक क्वेरी के लिए DNS को प्रश्न किया जाता है। IP पतों को `FLUSH HOSTNAMES` कमांड का उपयोग करके भी मैन्युअल रूप से नवीनीकरण किया जा सकता है।

### jobs_queue_size

`jobs_queue_size` सेटिंग यह परिभाषित करती है कि "जॉब" कितने एक ही समय में कतार में हो सकते हैं। डिफ़ॉल्ट रूप से, यह अनिश्चित है।

अधिकांश मामलों में, "जॉब" का अर्थ है एक क्वेरी एक एकल स्थानीय तालिका (सादा तालिका या वास्तविक समय तालिका के एक डिस्क क्लिप) तक। उदाहरण के लिए, यदि आपकी एक वितरित तालिका है जिसमें 2 स्थानीय तालिकाएँ या एक वास्तविक समय तालिका है जिसमें 2 डिस्क क्लिप हैं, तो इनके लिए खोज क्वेरी अधिकांशतः 2 जॉब कतार में डाल देगी। इसके बाद, थ्रेड पूल (जिसका आकार [threads](../Server_settings/Searchd.md#threads) द्वारा परिभाषित किया गया है) उन्हें संसाधित करेगा। हालाँकि, कुछ मामलों में, यदि क्वेरी बहुत जटिल है, तो अधिक जॉब्स बनाए जा सकते हैं। जब [max_connections](../Server_settings/Searchd.md#max_connections) और [threads](../Server_settings/Searchd.md#threads) संतुलन बनाने के लिए पर्याप्त नहीं होते हैं, तो इस सेटिंग को बदलने की सिफारिश की जाती है।

### join_batch_size

तालिका जोड़ों का कार्य मिलान का एक बैच एकत्र करके किया जाता है, जो बाईं तालिका पर निष्पादित क्वेरी के परिणाम होते हैं। फिर इस बैच को दाईं तालिका पर एकल क्वेरी के रूप में संसाधित किया जाता है।

यह विकल्प आपको बैच का आकार समायोजित करने की अनुमति देता है। डिफ़ॉल्ट मान `1000` है, और इस विकल्प को `0` पर सेट करने से बैचिंग बंद हो जाती है।

बड़ा बैच आकार प्रदर्शन को सुधार सकता है; हालाँकि, कुछ क्वेरियों के लिए, यह अत्यधिक मेमोरी खपत का कारण बन सकता है।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
join_batch_size = 2000
```
<!-- end -->

### join_cache_size

प्रत्येक क्वेरी जो दाईं तालिका पर निष्पादित होती है, विशेष JOIN ON शर्तों द्वारा परिभाषित होती है, जो दाईं तालिका से पुनर्प्राप्त परिणाम सेट को निर्धारित करती हैं।

यदि केवल कुछ अद्वितीय JOIN ON शर्तें हैं, तो परिणामों का पुन: उपयोग करना बार-बार दाईं तालिका पर क्वेरियों को निष्पादित करने की तुलना में अधिक कुशल हो सकता है। इसे सक्षम करने के लिए, परिणाम सेट को एक कैश में संग्रहीत किया जाता है।

यह विकल्प आपको इस कैश का आकार कॉन्फ़िगर करने की अनुमति देता है। डिफ़ॉल्ट मान `20 MB` है, और इस विकल्प को 0 पर सेट करने से कैशिंग बंद हो जाती है।

ध्यान दें कि प्रत्येक थ्रेड अपना खुद का कैश बनाए रखता है, इसलिए कुल मेमोरी उपयोग का अनुमान करते समय क्वेरियों को निष्पादित करने वाले थ्रेड्स की संख्या को ध्यान में रखना चाहिए।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
join_cache_size = 10M
```
<!-- end -->

### listen_backlog

<!-- example conf listen_backlog -->
`listen_backlog` सेटिंग इनकमिंग कनेक्शनों के लिए TCP सुनने की बैक्लॉग की लंबाई को निर्धारित करती है। यह विशेष रूप से विंडोज़ बिल्ड के लिए प्रासंगिक है जो अनुरोधों को एक-एक करके संसाधित करते हैं। जब कनेक्शन कतार अपनी सीमा तक पहुँच जाती है, तो नए इनकमिंग कनेक्शनों को अस्वीकार कर दिया जाएगा।
गैर-विंडोज़ बिल्ड के लिए, डिफ़ॉल्ट मान ठीक काम करेगा, और सामान्यतया इस सेटिंग को समायोजित करने की कोई आवश्यकता नहीं होती है।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
listen_backlog = 20
```
<!-- end -->

### kibana_version_string

<!-- example conf kibana_version_string -->
Kibana या OpenSearch डैशबोर्ड पर लौटाने के लिए एक सर्वर संस्करण स्ट्रिंग। वैकल्पिक — डिफ़ॉल्ट रूप से, इसे `7.6.0` पर सेट किया गया है।

Kibana और OpenSearch डैशबोर्ड के कुछ संस्करणों को सर्वर से एक विशिष्ट संस्करण संख्या रिपोर्ट करने की अपेक्षा होती है, और इसके आधार पर भिन्न व्यवहार कर सकते हैं। ऐसे मुद्दों का समाधान करने के लिए, आप इस सेटिंग का उपयोग कर सकते हैं, जो Manticore को Kibana या OpenSearch डैशबोर्ड को एक कस्टम संस्करण रिपोर्ट करने देता है।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
kibana_version_string = 1.2.3
```
<!-- end -->

### सुनें

<!-- example conf listen -->
यह सेटिंग आपको एक IP पता और पोर्ट, या यूनिक्स-डोमेन सॉकेट पथ निर्दिष्ट करने देती है, जिस पर Manticore कनेक्शन स्वीकार करेगा।

`listen` के लिए सामान्य वाक्यSyntax है:

```ini
listen = ( address ":" port | port | path | address ":" port start - port end ) [ ":" protocol [ "_vip" ] [ "_readonly" ] ]
```

आप इस तरह से निर्दिष्ट कर सकते हैं:
* या तो एक IP पता (या होस्टनाम) और एक पोर्ट संख्या
* या केवल एक पोर्ट संख्या
* या एक यूनिक्स सॉकेट पथ (Windows पर समर्थित नहीं)
* या एक IP पता और पोर्ट रेंज

यदि आप एक पोर्ट संख्या निर्दिष्ट करते हैं लेकिन एक पता नहीं, तो `searchd` सभी नेटवर्क इंटरफेस पर सुनता है। यूनिक्स पथ को एक अग्रणी स्लैश द्वारा पहचाना जाता है। पोर्ट रेंज केवल रिप्लिकेशन प्रोटोकॉल के लिए सेट की जा सकती है।

आप इस सॉकेट पर कनेक्शन के लिए उपयोग किए जाने वाले प्रोटोकॉल हैंडलर (श्रोता) को भी निर्दिष्ट कर सकते हैं। श्रोतागण हैं:

* **निर्दिष्ट नहीं** - Manticore इस पोर्ट पर कनेक्शन स्वीकार करेगा:
  - अन्य Manticore एजेंटों से (जैसे, एक दूरस्थ वितरित तालिका)
  - HTTP और HTTPS के माध्यम से क्लाइंट
  - [Manticore Buddy](https://manticoresearch.com/blog/manticoresearch-buddy-intro/). **मल्टीपल अनुप्रयोगों में सीमाओं से बचने के लिए इस प्रकार का एक श्रोता (या नीचे बताए गए `http` श्रोता) होना सुनिश्चित करें।**
* `mysql` MySQL क्लाइंट से कनेक्शन के लिए MySQL प्रोटोकॉल। नोट:
  - संकुचित प्रोटोकॉल भी समर्थित है।
  - यदि [SSL](../Security/SSL.md#SSL) सक्षम है, तो आप एक एन्क्रिप्टेड कनेक्शन बना सकते हैं।
* `replication` - नोड संचार के लिए उपयोग किया जाने वाला रिप्लिकेशन प्रोटोकॉल। अधिक जानकारी [replication](../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md) अनुभाग में पाई जा सकती है। आप कई रिप्लिकेशन श्रोताओं को निर्दिष्ट कर सकते हैं, लेकिन सभी को एक ही IP पर सुनना चाहिए; केवल पोर्ट भिन्न हो सकते हैं। जब आप एक पोर्ट रेंज के साथ एक रिप्लिकेशन श्रोता परिभाषित करते हैं (जैसे, `listen = 192.168.0.1:9320-9328:replication`), तो Manticore तुरंत इन पोर्ट पर सुनना शुरू नहीं करता है। इसके बजाय, यह केवल तब निर्दिष्ट रेंज से यादृच्छिक मुक्त पोर्ट लेगा जब आप रिप्लिकेशन का उपयोग करना शुरू करते हैं। काम करने के लिए कम से कम 2 पोर्ट रेंज में आवश्यक हैं।
* `http` - **निर्दिष्ट नहीं** जैसा। Manticore इस पोर्ट पर दूरस्थ एजेंटों और ग्राहकों से HTTP और HTTPS के माध्यम से कनेक्शन स्वीकार करेगा।
* `https` - HTTPS प्रोटोकॉल। Manticore इस पोर्ट पर **केवल** HTTPS कनेक्शन स्वीकार करेगा। अधिक जानकारी अनुभाग [SSL](../Security/SSL.md) में पाई जा सकती है।
* `sphinx` - पुरानी बाइनरी प्रोटोकॉल। दूरस्थ [SphinxSE](../Extensions/SphinxSE.md) क्लाइंट से कनेक्शन के लिए उपयोग किया जाता है। कुछ Sphinx API क्लाइंट कार्यान्वयन (एक उदाहरण Java वाला है) श्रोता की स्पष्ट घोषणा की आवश्यकता है।

क्लाइंट प्रोटोकॉल (यानी, सभी `replication` के अपवाद के लिए, उदाहरण के लिए `mysql_vip` या `http_vip` या बस `_vip`) के लिए उपसर्ग `_vip` जोड़ना कनेक्शन के लिए एक समर्पित थ्रेड बनाने को मजबूर करता है जो विभिन्न सीमाओं को दरकिनार करने में मदद करता है। यह गंभीर ओवरलोड की स्थिति में नोड रखरखाव के लिए उपयोगी है जब सर्वर या तो रुक सकता है या अन्यथा सामान्य पोर्ट के माध्यम से कनेक्ट करने नहीं देगा।

उपसर्ग `_readonly` श्रोता के लिए [पढ़ने के लिए केवल मोड](../Security/Read_only.md) सेट करता है और इसे केवल पढ़ने की क्वेरी स्वीकार करने के लिए सीमित करता है।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
listen = localhost
listen = localhost:5000 # दूरस्थ एजेंटों (बाइनरी API) और http/https अनुरोधों के लिए localhost पर पोर्ट 5000 पर सुनें
listen = 192.168.0.1:5000 # दूरस्थ एजेंटों (बाइनरी API) और http/https अनुरोधों के लिए 192.168.0.1 पर पोर्ट 5000 पर सुनें
listen = /var/run/manticore/manticore.s # यूनिक्स सॉकेट पर बाइनरी API अनुरोधों के लिए सुनें
listen = /var/run/manticore/manticore.s:mysql # यूनिक्स सॉकेट पर mysql अनुरोधों के लिए सुनें
listen = 9312 # किसी भी इंटरफ़ेस पर पोर्ट 9312 पर दूरस्थ एजेंटों (बाइनरी API) और http/https अनुरोधों के लिए सुनें
listen = localhost:9306:mysql # localhost पर पोर्ट 9306 पर mysql अनुरोधों के लिए सुनें
listen = localhost:9307:mysql_readonly # localhost पर पोर्ट 9307 पर mysql अनुरोधों के लिए सुनें और केवल पढ़ने की क्वेरी स्वीकार करें
listen = 127.0.0.1:9308:http # localhost पर पोर्ट 9308 पर http अनुरोधों और दूरस्थ एजेंटों (और बाइनरी API) से कनेक्शन के लिए सुनें
listen = 192.168.0.1:9320-9328:replication # 192.168.0.1 पर पोर्ट 9320-9328 पर रिप्लिकेशन कनेक्शन के लिए सुनें
listen = 127.0.0.1:9443:https # 127.0.0.1 पर पोर्ट 9443 पर https अनुरोधों (http नहीं) के लिए सुनें
listen = 127.0.0.1:9312:sphinx # 127.0.0.1 पर पोर्ट 9312 पर पुरानी Sphinx अनुरोधों (जैसे SphinxSE से) के लिए सुनें
```
<!-- end -->

कई `listen` निर्देश हो सकते हैं। `searchd` सभी निर्दिष्ट पोर्तों और सॉकेट पर क्लाइंट कनेक्शनों के लिए सुनता है। Manticore पैकेज में प्रदान की गई डिफ़ॉल्ट कॉन्फ़िगरेशन निम्नलिखित पोर्ट पर सुनने का निर्धारण करती है:
* दूरस्थ एजेंटों और गैर-MySQL आधारित क्लाइंट से कनेक्शन के लिए `9308` और `9312`
* और MySQL कनेक्शनों के लिए पोर्ट `9306` पर।

यदि आप कॉन्फ़िगरेशन में कोई `listen` निर्दिष्ट नहीं करते हैं, तो Manticore कनेक्शनों की प्रतीक्षा करेगा:
* MySQL क्लाइंट के लिए `127.0.0.1:9306`
* 127.0.0.1:9312 पर HTTP/HTTPS और अन्य Manticore नोड्स और Manticore बाइनरी API पर आधारित क्लाइंट से कनेक्शन।

#### विशेषाधिकार प्राप्त पोर्ट पर सुनना
डिफ़ॉल्ट रूप से, Linux आपको Manticore को 1024 के नीचे के पोर्ट पर सुनने की अनुमति नहीं देगा (जैसे `listen = 127.0.0.1:80:http` या `listen = 127.0.0.1:443:https`) जब तक आप searchd को root के तहत नहीं चलाते। यदि आप अभी भी Manticore शुरू करने में सक्षम होना चाहते हैं, ताकि वह नॉन-रूट उपयोगकर्ता के तहत 1024 के नीचे के पोर्ट पर सुने, तो निम्नलिखित में से एक करने पर विचार करें (इनमें से कोई भी काम करेगा):
* आदेश `setcap CAP_NET_BIND_SERVICE=+eip /usr/bin/searchd` चलाएँ
* Manticore के systemd यूनिट में `AmbientCapabilities=CAP_NET_BIND_SERVICE` जोड़ें और डेमन को रीलोड करें (`systemctl daemon-reload`).

#### Sphinx API प्रोटोकॉल और TFO के बारे में तकनीकी विवरण
<details>
विरासती Sphinx प्रोटोकॉल में 2 चरण होते हैं: हैंडशेक एक्सचेंज और डेटा प्रवाह। हैंडशेक में क्लाइंट से 4 बाइट्स का एक पैकेट और डेमन से 4 बाइट्स का एक पैकेट होता है, जिसका एक ही उद्देश्य होता है - क्लाइंट यह तय करता है कि रिमोट एक असली Sphinx डेमन है, डेमन यह तय करता है कि रिमोट एक असली Sphinx क्लाइंट है। मुख्य डेटा प्रवाह काफी सरल है: चलिए दोनों पक्ष अपने हैंडशेक की घोषणा करते हैं, और विपरीत उन्हें चेक करता है। वह एक्सचेंज छोटे पैकेट के साथ विशेष `TCP_NODELAY` फ्लैग का उपयोग करता है, जो Nagle के TCP एल्गोरिदम को बंद कर देता है और यह घोषित करता है कि TCP कनेक्शन छोटे पैकेजों के संवाद के रूप में किया जाएगा।
हालांकि, यह इस बातचीत में पहले कौन बोलता है, यह सख्ती से परिभाषित नहीं है। ऐतिहासिक रूप से, सभी क्लाइंट जो बाइनरी API का उपयोग करते हैं, पहले बोलते हैं: हैंडशेक भेजें, फिर डेमन से 4 बाइट्स पढ़ें, फिर एक अनुरोध भेजें और डेमन से उत्तर पढ़ें।
जब हमने Sphinx प्रोटोकॉल संगतता में सुधार किया, तो हमने इन बातों पर विचार किया:

1. आमतौर पर, मास्टर-एजेंट संचार एक ज्ञात क्लाइंट से एक ज्ञात होस्ट पर एक ज्ञात पोर्ट से स्थापित किया जाता है। तो, यह संभव नहीं है कि एंडपॉइंट गलत हैंडशेक प्रदान करेगा। इसलिए, हम अनुमान लगा सकते हैं कि दोनों पक्ष मान्य हैं और वास्तव में Sphinx پروटो में बात कर रहे हैं।
2. इस अनुमान के तहत, हम एक हैंडशेक को असली अनुरोध से 'जोड़' सकते हैं और इसे एक ही पैकेट में भेज सकते हैं। यदि बैकएंड एक विरासती Sphinx डेमन है, तो यह इस जोड़े गए पैकेट को 4 बाइट्स के हैंडशेक के रूप में पढ़ेगा, फिर अनुरोध का शरीर। चूंकि वे एक ही पैकेट में आए, बैकएंड सॉकेट में -1 RTT है, और फ्रंटेंड बफ़र अभी भी इस तथ्य के बावजूद सामान्य तरीके से काम करता है।
3. अनुमान को जारी रखते हुए: चूंकि 'क्वेरी' पैकेट काफी छोटा है, और हैंडशेक और भी छोटा है, चलिए दोनों को प्रारंभिक 'SYN' TCP पैकेज में आधुनिक TFO (tcp-fast-open) तकनीक का उपयोग करके भेजते हैं। अर्थात: हम एक रिमोट नोड से जुड़े हैं जिसमें जोड़े गए हैंडशेक + शरीर का पैकेज है। डेमन कनेक्शन स्वीकार करता है और तुरंत उसके पास हैंडशेक और शरीर दोनों सॉकेट बफर में होते हैं, जैसे कि वे पहले TCP 'SYN' पैकेट में आए। यह एक और RTT को समाप्त कर देता है।
4. अंततः, डेमन को इस सुधार को स्वीकार करने के लिए सिखाएँ। वास्तव में, एप्लिकेशन से, इसका मतलब है कि `TCP_NODELAY` का उपयोग न करें। और, सिस्टम पक्ष से, इसका मतलब है कि यह सुनिश्चित करना कि डेमन पक्ष पर, TFO को सक्रियित करना आवश्यक है, और क्लाइंट पक्ष पर, TFO को भेजना भी सक्रिय है। आधुनिक सिस्टम में, डिफ़ॉल्ट रूप से, क्लाइंट TFO पहले से ही सक्रिय है, इसलिए आपको सभी चीजों को काम करने के लिए सर्वर TFO को ट्यून करने की आवश्यकता है।

बिना वास्तव में प्रोटोकॉल को स्वयं बदले, इन सभी सुधारों ने हमें कनेक्शन से TCP प्रोटोकॉल के 1.5 RTT को समाप्त करने की अनुमति दी। जो कि, यदि क्वेरी और उत्तर एक ही TCP पैकेज में रखे जा सकते हैं, तो पूरे बाइनरी API सत्र को 3.5 RTT से 2 RTT तक कम करता है - जो नेटवर्क बातचीत को लगभग 2 गुना तेज़ बनाता है।

तो, हमारे सभी सुधार एक प्रारंभिक अनिर्धारित कथन के चारों ओर बताए गए हैं: 'पहले कौन बोलता है।' यदि एक क्लाइंट पहले बोलता है, तो हम इन सभी अनुकूलन को लागू कर सकते हैं और प्रभावी रूप से कनेक्ट + हैंडशेक + क्वेरी को एक ही TFO पैकेज में संसाधित कर सकते हैं। इसके अलावा, हम प्राप्त पैकेट की शुरुआत पर देख सकते हैं और वास्तविक प्रोटोकॉल का निर्धारण कर सकते हैं। यही कारण है कि आप API/http/https के माध्यम से एक ही पोर्ट से कनेक्ट कर सकते हैं। यदि डेमन को पहले बोलना होता है, तो ये सभी अनुकूलन असंभव हैं, और बहुप्रोटोकॉल भी असंभव है। यही कारण है कि हमारे पास MySQL के लिए एक समर्पित पोर्ट है और इसे सभी अन्य प्रोटोकॉल के साथ एक ही पोर्ट में एकीकृत नहीं किया गया है। अचानक, सभी क्लाइंट के बीच, एक ऐसा लिखा गया था जिसका अर्थ था कि डेमन को पहले हैंडशेक भेजना चाहिए। अर्थात - सभी वर्णित सुधारों की कोई संभावना नहीं है। वह SphinxSE प्लगइन mysql/mariadb के लिए है। इसलिए, विशेष रूप से इस एकल क्लाइंट के लिए हमने `sphinx` प्रोटोकॉल परिभाषा को सबसे विरासत तरीके से काम करने के लिए समर्पित किया। अर्थात्: दोनों पक्ष `TCP_NODELAY` को सक्रिय करते हैं और छोटे पैकेजों के साथ एक्सचेंज करते हैं। डेमन कनेक्ट पर अपना हैंडशेक भेजता है, फिर क्लाइंट अपना भेजता है, और फिर सब कुछ सामान्य तरीके से काम करता है। यह बहुत अनुकूल नहीं है, लेकिन बस काम करता है। यदि आप Manticore से कनेक्ट करने के लिए SphinxSE का उपयोग करते हैं - तो आपको स्पष्ट रूप से घोषित `sphinx` प्रोटोकॉल के साथ एक श्रोता समर्पित करना होगा। अन्य क्लाइंट के लिए - इस श्रोता का उपयोग करने से बचें क्योंकि यह धीमा है। यदि आप अन्य विरासती Sphinx API क्लाइंट्स का उपयोग करते हैं - पहले यह जांचें कि क्या वे गैर-समर्पित बहुप्रोटोकॉल पोर्ट के साथ काम करने में सक्षम हैं। मास्टर-एजेंट लिंक के लिए गैर-समर्पित (बहु-प्रोटोकॉल) पोर्ट का उपयोग करना और क्लाइंट और सर्वर TFO को सक्षम करना अच्छी तरह से काम करता है और निश्चित रूप से नेटवर्क बैकएंड के काम करने को तेज करेगा, विशेष रूप से यदि आपके पास बहुत हल्की और तेज़ क्वेरी हैं।
</details>

### listen_tfo

यह सेटिंग सभी श्रोताओं के लिए TCP_FASTOPEN फ्लैग को अनुमति देती है। डिफ़ॉल्ट रूप से, इसे सिस्टम द्वारा प्रबंधित किया जाता है लेकिन इसे '0' पर सेट करके स्पष्ट रूप से बंद किया जा सकता है।

TCP फास्ट ओपन एक्सटेंशन के बारे में सामान्य ज्ञान के लिए, कृपया [Wikipedia](https://en.wikipedia.org/wiki/TCP_Fast_Open) पर सलाह लें। संक्षेप में, यह एक कनेक्शन स्थापित करते समय एक TCP राउंड-ट्रिप का उन्मूलन करने की अनुमति देता है।

प्रैक्टिस में, कई स्थितियों में TFO का उपयोग क्लाइंट-एजेंट नेटवर्क दक्षता को अनुकूलित कर सकता है, जैसे कि अगर [स्थायी एजेंट](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md) खेल में हैं, लेकिन सक्रिय कनेक्शन नहीं रख रहे हैं, और अधिकतम कनेक्शन की संख्या के लिए भी कोई सीमा नहीं है।

आधुनिक OS पर, TFO समर्थन आमतौर पर सिस्टम स्तर पर 'चालू' होता है, लेकिन यह केवल एक 'क्षमता' है, नियम नहीं। लिनक्स (जैसा कि सबसे प्रगतिशील) ने 2011 से इसका समर्थन किया है, कर्नेल 3.7 से शुरू होकर (सर्वर पक्ष के लिए)। विंडोज ने इसे विंडोज 10 के कुछ बिल्ड से समर्थन किया है। अन्य ऑपरेटिंग सिस्टम (FreeBSD, MacOS) भी इस खेल में हैं।

लिनक्स सिस्टम सर्वर चर `/proc/sys/net/ipv4/tcp_fastopen` की जांच करता है और इसके अनुसार व्यवहार करता है। बिट 0 क्लाइंट पक्ष को प्रबंधित करता है, बिट 1 सुनने वालों का संचालन करता है। डिफ़ॉल्ट रूप से, सिस्टम ने इस पैरामीटर को 1 पर सेट किया है, अर्थात्, क्लाइंट सक्षम हैं, सुनने वाले असक्षम हैं।

### लॉग

<!-- example conf log -->
लॉग सेटिंग उस लॉग फ़ाइल का नाम निर्दिष्ट करती है जहाँ सभी `searchd` रन समय घटनाएँ लॉग की जाएँगी। यदि निर्दिष्ट नहीं किया गया, तो डिफ़ॉल्ट नाम 'searchd.log' है।

वैकल्पिक रूप से, आप फ़ाइल नाम के रूप में 'syslog' का उपयोग कर सकते हैं। इस मामले में, घटनाएँ syslog डेमोन को भेजी जाएंगी। syslog विकल्प का उपयोग करने के लिए, आपको निर्माण के दौरान Manticore को `-–with-syslog` विकल्प के साथ कॉन्फ़िगर करना होगा।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
log = /var/log/searchd.log
```
<!-- end -->


### max_batch_queries

<!-- example conf max_batch_queries -->
प्रति बैच प्रश्नों की मात्रा सीमा। वैकल्पिक, डिफ़ॉल्ट 32 है।

यह सुनिश्चित करता है कि searchd एकल बैच में सबमिट किए गए प्रश्नों की मात्रा की एक स्थिरता जांच करता है जब [मल्टी-प्रश्नों](../Searching/Multi-queries.md) का उपयोग किया जाता है। जांच छोड़ने के लिए इसे 0 पर सेट करें।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
max_batch_queries = 256
```
<!-- end -->

### max_connections

<!-- example max_connections -->
समानांतर क्लाइंट कनेक्शनों की अधिकतम संख्या। डिफ़ॉल्ट द्वारा अनुत्कृष्ट। यह सामान्यतः केवल किसी भी प्रकार के निरंतर कनेक्शनों का उपयोग करते समय, जैसे कि cli mysql सत्र या दूरस्थ वितरित तालिकाओं से स्थायी दूरस्थ कनेक्शनों का उपयोग करते समय देखा जाता है। जब सीमा पार हो जाती है, तो आप [VIP कनेक्शन](../Connecting_to_the_server/MySQL_protocol.md#VIP-connection) का उपयोग करके सर्वर से कनेक्ट कर सकते हैं। VIP कनेक्शन सीमा में नहीं गिने जाते हैं।

<!-- request Example -->
```ini
max_connections = 10
```

<!-- end -->

### max_threads_per_query

<!-- example max_threads_per_query -->
एक संचालन के लिए उपयोग किए जाने वाले थ्रेड्स की उदाहरण स्तर पर सीमा। डिफ़ॉल्ट रूप से, उचित संचालन सभी CPU कोर पर कब्जा कर सकते हैं, अन्य संचालन के लिए कोई स्थान नहीं छोड़ते हैं। उदाहरण के लिए, एक काफी बड़े पर्कोलेट तालिका के खिलाफ `call pq` सभी थ्रेड्स का उपयोग कर सकता है कई सेकंड के लिए। `max_threads_per_query` को, कहें, [threads](../Server_settings/Searchd.md#threads) का आधा सेट करने से यह सुनिश्चित होगा कि आप समानांतर में ऐसे कुछ `call pq` संचालन चला सकें।

आप इस सेटिंग को रनटाइम के दौरान एक सत्र या वैश्विक चर के रूप में भी सेट कर सकते हैं।

इसके अलावा, आप [threads OPTION](../Searching/Options.md#threads) की सहायता से प्रति-प्रश्न आधार पर व्यवहार को नियंत्रित कर सकते हैं।

<!-- intro -->
##### उदाहरण:
<!-- request Example -->

```ini
max_threads_per_query = 4
```

<!-- end -->

### max_filters

<!-- example conf max_filters -->
प्रति-प्रश्न फ़िल्टर संख्या की अधिकतम अनुमति। यह सेटिंग केवल आंतरिक स्थिरता जांच के लिए उपयोग की जाती है और सीधे RAM उपयोग या प्रदर्शन को प्रभावित नहीं करती है। वैकल्पिक, डिफ़ॉल्ट 256 है।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
max_filters = 1024
```
<!-- end -->


### max_filter_values

<!-- example conf max_filter_values -->
प्रति-फिल्टर मानों की अधिकतम अनुमति संख्या। यह सेटिंग केवल आंतरिक स्थिरता जांच के लिए उपयोग की जाती है और सीधे RAM उपयोग या प्रदर्शन को प्रभावित नहीं करती है। वैकल्पिक, डिफ़ॉल्ट 4096 है।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
max_filter_values = 16384
```
<!-- end -->


### max_open_files

<!-- example conf max_open_files -->
अधिकतम संख्या जो फ़ाइलें हैं जिनको सर्वर खोलने की अनुमति है उसे "सॉफ़्ट लिमिट" कहा जाता है। ध्यान दें कि बड़े फ़्रैगमेंटेड रियल-टाइम तालिकाओं की सेवा देने के लिए इस सीमा को उच्च सेट करने की आवश्यकता हो सकती है, क्योंकि प्रत्येक डिस्क चंक में दर्जन या उससे अधिक फ़ाइलें हो सकती हैं। उदाहरण के लिए, 1000 चंक के साथ एक वास्तविक समय तालिका को एक साथ हजारों फ़ाइलें खोलने की आवश्यकता हो सकती है। यदि आप लॉग में 'बहुत अधिक खुली फ़ाइलें' त्रुटि का सामना करते हैं, तो इस विकल्प को समायोजित करने का प्रयास करें, क्योंकि इससे समस्या का समाधान करने में मदद मिल सकती है।

इसके अलावा एक "हार्ड लिमिट" भी है जिसे विकल्प द्वारा पार नहीं किया जा सकता। यह सीमा प्रणाली द्वारा परिभाषित की जाती है और लिनक्स पर फ़ाइल `/etc/security/limits.conf` में बदली जा सकती है। अन्य ऑपरेटिंग सिस्टम के अलग-अलग दृष्टिकोण हो सकते हैं, इसलिए अधिक जानकारी के लिए अपने मैनुअल की जांच करें।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
max_open_files = 10000
```
<!-- end -->

<!-- example conf max_open_files max -->
सीधे संख्या वाले मानों के अलावा, आप उपलब्ध वर्तमान हार्ड लिमिट के बराबर सीमा को सेट करने के लिए 'max' जादुई शब्द का उपयोग कर सकते हैं।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
max_open_files = max
```
<!-- end -->


### max_packet_size

<!-- example conf max_packet_size -->
अधिकतम अनुमति नेटवर्क पैकेट आकार। यह सेटिंग क्लाइंट से प्रश्न पैकेट और वितरित वातावरण में दूरस्थ एजेंटों से प्रतिक्रिया पैकेट दोनों को सीमित करती है। केवल आंतरिक स्थिरता जांच के लिए उपयोग किया जाता है, यह सीधे RAM उपयोग या प्रदर्शन को प्रभावित नहीं करता है। वैकल्पिक, डिफ़ॉल्ट 128M है।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
max_packet_size = 32M
```
<!-- end -->


### mysql_version_string

<!-- example conf mysql_version_string -->
MySQL प्रोटोकॉल के माध्यम से लौटाने के लिए एक सर्वर संस्करण स्ट्रिंग। वैकल्पिक, डिफ़ॉल्ट खाली है (Manticore संस्करण लौटाता है)।
कई नाज़ुक MySQL क्लाइंट लाइब्रेरी एक विशेष संस्करण संख्या प्रारूप पर निर्भर करती हैं जो MySQL द्वारा उपयोग किया जाता है, और इसके अलावा, कभी-कभी रिपोर्ट की गई संस्करण संख्या के आधार पर एक अलग निष्पादन पथ चुनती हैं (भले ही निर्दिष्ट क्षमताएँ ध्वज न हों)। उदाहरण के लिए, Python MySQLdb 1.2.2 एक अपवाद फेंकता है जब संस्करण संख्या X.Y.ZZ प्रारूप में नहीं होती; MySQL .NET कनेक्टर 6.3.x आंतरिक रूप से संस्करण नंबर 1.x पर कुछ ध्वजों के संयोजन के साथ विफल रहता है, इत्यादि। इससे निपटने के लिए, आप `mysql_version_string` निर्देशिका का उपयोग कर सकते हैं और `searchd` को MySQL प्रोटोकॉल के माध्यम से कनेक्ट होते क्लाइंट्स को एक अलग संस्करण रिपोर्ट करने के लिए कह सकते हैं। (डिफ़ॉल्ट रूप से, यह अपना स्वयं का संस्करण रिपोर्ट करता है।)


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
mysql_version_string = 5.0.37
```
<!-- end -->


### net_workers

नेटवर्क थ्रेड की संख्या, डिफ़ॉल्ट 1 है।

यह सेटिंग अत्यधिक उच्च क्वेरी दरों के लिए उपयोगी है जब बस एक थ्रेड सभी आने वाली क्वेरीज़ को प्रबंधित करने के लिए पर्याप्त नहीं है।


### net_wait_tm

नेटवर्क थ्रेड के व्यस्त लूप अंतराल को नियंत्रित करता है। डिफ़ॉल्ट -1 है, और इसे -1, 0, या एक सकारात्मक पूर्णांक पर सेट किया जा सकता है।

उन मामलों में जहां सर्वर को एक शुद्ध मास्टर के रूप में कॉन्फ़िगर किया गया है और केवल एजेंटों को अनुरोध रूट करता है, यह महत्वपूर्ण है कि अनुरोधों को बिना किसी देरी के संभाला जाए और नेटवर्क थ्रेड को सोने की अनुमति न दी जाए। इसके लिए एक व्यस्त लूप है। एक आने वाले अनुरोध के बाद, नेटवर्क थ्रेड `net_wait_tm` मिलिसेकंड के लिए CPU पोल का उपयोग करता है यदि `net_wait_tm` एक सकारात्मक संख्या है या केवल CPU के साथ पोल करता है यदि `net_wait_tm` `0` है। इसके अलावा, व्यस्त लूप को `net_wait_tm = -1` के साथ निष्क्रिय किया जा सकता है - इस मामले में, पोलर सिस्टम पोलिंग कॉल पर वास्तविक एजेंट के समयसीमाओं के लिए समय सीमा निर्धारित करता है।

> **WARNING:** एक CPU व्यस्त लूप वास्तव में CPU कोर को लोड करता है, इसलिए इस मूल्य को किसी भी गैर-डिफ़ॉल्ट मूल्य पर सेट करने से निष्क्रिय सर्वर के बावजूद ध्यान देने योग्य CPU उपयोग होगा।


### net_throttle_accept

प्रत्येक नेटवर्क लूप के पुनरावृत्ति पर कितने क्लाइंट स्वीकार किए जाते हैं, इसे परिभाषित करता है। डिफ़ॉल्ट 0 (असीमित) है, जो अधिकांश उपयोगकर्ताओं के लिए ठीक होना चाहिए। यह उच्च लोड परिदृश्यों में नेटवर्क लूप के थ्रूपुट को नियंत्रित करने के लिए एक फ़ाइन-ट्यूनिंग विकल्प है।


### net_throttle_action

प्रत्येक नेटवर्क लूप के पुनरावृत्ति पर कितने अनुरोध संसाधित किए जाते हैं, इसे परिभाषित करता है। डिफ़ॉल्ट 0 (असीमित) है, जो अधिकांश उपयोगकर्ताओं के लिए ठीक होना चाहिए। यह उच्च लोड परिदृश्यों में नेटवर्क लूप के थ्रूपुट को नियंत्रित करने के लिए एक फ़ाइन-ट्यूनिंग विकल्प है।

### network_timeout

<!-- example conf network_timeout -->
नेटवर्क क्लाइंट अनुरोध पढ़ने/लिखने का समय-सीमा, सेकंड में (या  [विशेष_suffixes](../Server_settings/Special_suffixes.md)). वैकल्पिक, डिफ़ॉल्ट 5 सेकंड है। `searchd` एक क्लाइंट कनेक्शन को मजबूरन बंद करेगा जो इस समय-सीमा के भीतर एक क्वेरी भेजने या परिणाम पढ़ने में विफल रहता है।

यह भी ध्यान दें [reset_network_timeout_on_packet](../Server_settings/Searchd.md#reset_network_timeout_on_packet) पैरामीटर। यह पैरामीटर `network_timeout` के व्यवहार को संशोधित करता है कि यह पूरी `query` या `result` पर लागू होने के बजाय व्यक्तिगत पैकेट पर लागू होता है। सामान्यतः, एक क्वेरी/परिणाम एक या दो पैकेट में फिट होती है। हालाँकि, मामलों में जब बड़ी मात्रा में डेटा की आवश्यकता होती है, यह पैरामीटर सक्रिय संचालन बनाए रखने में अत्यधिक महत्वपूर्ण हो सकता है।

<!-- request Example -->

```ini
network_timeout = 10s
```
<!-- end -->

### node_address

<!-- example conf node_address -->
यह सेटिंग आपको नोड का नेटवर्क पता निर्दिष्ट करने की अनुमति देती है। डिफ़ॉल्ट रूप से, इसे पुनरुत्पादन [listen](../Server_settings/Searchd.md#listen) पते पर सेट किया गया है। यह अधिकांश मामलों में सही है; हालाँकि, ऐसे हालात हैं जहाँ आपको इसे मैन्युअल रूप से निर्दिष्ट करना होगा:

* फ़ायरवॉल के पीछे नोड
* नेटवर्क पता अनुवाद सक्षम (NAT)
* कंटेनर तैनाती, जैसे Docker या क्लाउड तैनाती
* अनेक क्षेत्रों में नोड के साथ क्लस्टर


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
node_address = 10.101.0.10
```
<!-- end -->

### not_terms_only_allowed

<!-- example conf not_terms_only_allowed -->
यह सेटिंग यह निर्धारित करती है कि केवल [नकार](../Searching/Full_text_matching/Operators.md#Negation-operator) पूर्ण-पाठ ऑपरेटर के साथ क्वेरीज़ की अनुमति दी जाए या नहीं। वैकल्पिक, डिफ़ॉल्ट 0 है (केवल NOT ऑपरेटर के साथ क्वेरीज़ को विफल करें)।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
not_terms_only_allowed = 1
```
<!-- end -->

### optimize_cutoff

<!-- example conf optimize_cutoff -->
डिफ़ॉल्ट तालिका समकक्ष सीमा निर्धारित करता है। अधिक जानकारी पढ़ें - [संक्षिप्त डिस्क खंडों की संख्या](../Securing_and_compacting_a_table/Compacting_a_table.md#Number-of-optimized-disk-chunks). इस सेटिंग को प्रति-क्वेरी विकल्प [cutoff](../Securing_and_compacting_a_table/Compacting_a_table.md#Number-of-optimized-disk-chunks) द्वारा ओवरराइड किया जा सकता है। इसे [SET GLOBAL](../Server_settings/Setting_variables_online.md#SET) के माध्यम से गतिशील रूप से भी बदला जा सकता है।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
optimize_cutoff = 4
```
<!-- end -->

### persistent_connections_limit

<!-- example conf persistent_connections_limit -->
यह सेटिंग निर्धारित करती है कि दूरस्थ [स्थायी एजेंटों](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md) के लिए अधिकतम संख्या कितनी होगी। प्रत्येक बार जब `agent_persistent` के तहत परिभाषित एजेंट कनेक्ट होता है, हम मौजूदा कनेक्शन (अगर कोई हो) को पुन: उपयोग करने का प्रयास करते हैं, या कनेक्ट करते हैं और भविष्य के उपयोग के लिए कनेक्शन को सहेजते हैं। हालाँकि, कुछ मामलों में, ऐसे स्थायी कनेक्शनों की संख्या को सीमित करना समझदारी है। यह निर्देश सीमा परिभाषित करता है। यह सभी वितरण तालिकाओं में प्रत्येक एजेंट के होस्ट के लिए कनेक्शनों की संख्या को प्रभावित करता है।

यह मान `max_connections` के बराबर या उससे कम सेट करना समझदारी है [agent's config](../Server_settings/Searchd.md#max_connections) में।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
persistent_connections_limit = 29 # मान लें कि प्रत्येक एजेंट के होस्ट के लिए max_connections = 30 (या 29) है।
```
<!-- end -->


### pid_file

<!-- example conf pid_file -->
pid_file Manticore खोज में एक अनिवार्य कॉन्फ़िगरेशन विकल्प है जो उस फ़ाइल के पथ को निर्दिष्ट करता है जहाँ `searchd` सर्वर की प्रोसेस आईडी संग्रहीत होती है।

searchd प्रोसेस आईडी फ़ाइल को स्टार्टअप पर फिर से बनाया जाता है और लॉक किया जाता है, और इसमें सर्वर चलने के दौरान मुख्य सर्वर प्रोसेस आईडी होती है। इसे सर्वर बंद होने पर अनलिंक कर दिया जाता है।
इस फ़ाइल का उद्देश्य Manticore को विभिन्न आंतरिक कार्यों को करने में सक्षम बनाना है, जैसे कि यह जांचना कि क्या पहले से ही `searchd` का एक रनिंग उदाहरण है, `searchd` को रोकना, और इसे सूचित करना कि इसे तालिकाएँ घुमानी चाहिए। इस फ़ाइल का उपयोग बाहरी स्वचालन स्क्रिप्ट के लिए भी किया जा सकता है।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
pid_file = /var/run/manticore/searchd.pid
```
<!-- end -->


### predicted_time_costs

<!-- example conf predicted_time_costs -->
प्रश्न समय भविष्यवाणी मॉडल के लिए लागत, नैनोसेकंड में। वैकल्पिक, डिफ़ॉल्ट `doc=64, hit=48, skip=2048, match=64` है।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
predicted_time_costs = doc=128, hit=96, skip=4096, match=128
```
<!-- end -->

<!-- example conf predicted_time_costs 1 -->
उनके निष्पादन समय के आधार पर प्रश्नों को पूर्णता से पहले समाप्त करना (मैक्स प्रश्न समय सेटिंग के साथ) एक अच्छा सुरक्षा जाल है, लेकिन इसमें एक अंतर्निहित कमी है: असंगत (अस्थिर) परिणाम। अर्थात, यदि आप समय सीमा के साथ बिल्कुल समान (जटिल) खोज प्रश्न को कई बार दोहराते हैं, तो समय सीमा विभिन्न चरणों में जुड़ जाएगी, और आपको *विभिन्न* परिणाम सेट मिलेंगे।

<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
SELECT … OPTION max_query_time
```
<!-- request API -->

```api
SetMaxQueryTime()
```
<!-- end -->

एक नया विकल्प है, [SELECT … OPTION max_predicted_time](../Searching/Options.md#max_predicted_time), जिससे आप प्रश्न समय को सीमित कर सकते हैं *और* स्थिर, दोहराए जाने वाले परिणाम प्राप्त कर सकते हैं। प्रश्न का मूल्यांकन करते समय वास्तविक वर्तमान समय को नियमित रूप से जांचने के बजाय, जो असंगत है, यह एक सरल रैखिक मॉडल का उपयोग करके वर्तमान चलने वाले समय का अनुमान लगाता है:

```ini
predicted_time =
    doc_cost * processed_documents +
    hit_cost * processed_hits +
    skip_cost * skiplist_jumps +
    match_cost * found_matches
```

तब प्रश्न को जल्दी समाप्त कर दिया जाता है जब `predicted_time` एक निर्धारित सीमा तक पहुँचता है।

बेशक, यह वास्तविक समय में बिताए गए समय पर एक कठिन सीमा नहीं है (हालांकि, यह *प्रोसेसिंग* कार्य के किए गए मात्रा पर एक कठोर सीमा है), और एक सरल रैखिक मॉडल किसी भी तरह से आदर्श रूप से सटीक नहीं है। इसलिए, घड़ी के समय *कम* या लक्ष्य सीमा के ऊपर हो सकता है। हालांकि, त्रुटि के मार्जिन काफी स्वीकार्य हैं: उदाहरण के लिए, हमारे 100 मिलीसेकंड लक्ष्य सीमा के साथ प्रयोगों में, परीक्षण प्रश्नों की अधिकांश संख्या 95 से 105 मिलीसेकंड के बीच थी, और *सभी* प्रश्न 80 से 120 मिलीसेकंड के बीच थे। साथ ही, एक अच्छे साइड इफेक्ट के रूप में, मापित प्रश्न समय का उपयोग करने के बजाय वास्तविक रन समय को मापने से थोड़े कम gettimeofday() कॉल भी किए जाते हैं।

कोई भी दो सर्वर निर्माताओं और मॉडल समान नहीं हैं, इसलिए `predicted_time_costs` निर्देशन आपको ऊपर दिए गए मॉडल के लिए लागत कन्फ़िगर करने की अनुमति देता है। सुविधा के लिए, ये पूर्णांक हैं, नैनोसेकंड में गिनती की जाती हैं। (max_predicted_time में सीमा मिलीसेकंड में होती है, और लागत मानों को 0.000128 मिलीसेकंड के रूप में निर्दिष्ट करना आमतौर पर अधिक त्रुटि-प्रवण होता है।) एक बार में सभी चार लागतों को निर्दिष्ट करना आवश्यक नहीं है, क्योंकि जो छूटे हुए हैं वे डिफ़ॉल्ट मान लेंगे। हालांकि, हम सभी को पठनीयता के लिए निर्दिष्ट करने की दृढ़ता से सलाह देते हैं।


### preopen_tables

<!-- example conf preopen_tables -->
preopen_tables कॉन्फ़िगरेशन निर्देशन यह निर्धारित करता है कि क्या स्टार्टअप पर सभी तालिकाओं को मजबूर से प्रीओपन करना है। डिफ़ॉल्ट मान 1 है, जो अर्थ है कि सभी तालिकाएँ प्रीओपन की जाएंगी चाहे प्रतेक तालिका की [preopen](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Other-performance-related-settings) सेटिंग के बावजूद। यदि इसे 0 पर सेट किया गया है, तो प्रति-तालिका सेटिंग प्रभाव में आ सकती है, और वे 0 पर डिफ़ॉल्ट होंगी।

तालिकाओं का प्री-ओपन करना खोज प्रश्नों और प्रक्रियाओं के बीच दौड़ को रोक सकता है जिसके कारण प्रश्न कभी-कभी विफल हो जाते हैं। हालाँकि, यह अधिक फ़ाइल हैंडल भी उपयोग करता है। अधिकांश परिदृश्यों में, तालिकाओं को प्रीओपन करना अनुशंसित है।

यहाँ एक उदाहरण कॉन्फ़िगरेशन है:

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
preopen_tables = 1
```
<!-- end -->

### pseudo_sharding

<!-- example conf pseudo_sharding -->
pseudo_sharding कॉन्फ़िगरेशन विकल्प स्थानीय प्लेन और रियल-टाइम तालिकाओं में खोज प्रश्नों की समानांतरता को सक्षम करता है, चाहे उन्हें सीधे या वितरित तालिका के माध्यम से प्रश्नित किया जाए। यह सुविधा स्वतः `searchd.threads` # थ्रेड्स में निर्दिष्ट की गई संख्या तक प्रश्नों को समानांतरित कर देगी।

ध्यान दें कि यदि आपके कार्यकर्ता थ्रेड पहले से ही व्यस्त हैं, क्योंकि आपके पास है:
* उच्च प्रश्न समवर्तीता
* किसी भी प्रकार का भौतिक विभाजन:
  - कई प्लेन/रियल-टाइम तालिकाओं का वितरित तालिका
  - बहुत से डिस्क टुकड़ों से मिलकर बनी रियल-टाइम तालिका

तो pseudo_sharding को सक्षम करने से कोई लाभ नहीं होगा और संभवतः थ्रूपुट में थोड़ी कमी आएगी। यदि आप कम विलंबता की तुलना में उच्च थ्रूपुट को प्राथमिकता देते हैं, तो यह विकल्प बंद करने की सिफारिश की गई है।

डिफ़ॉल्ट रूप से सक्षम किया गया है।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
pseudo_sharding = 0
```
<!-- end -->


### replication_connect_timeout

`replication_connect_timeout` निर्देशन दूरस्थ नोड से कनेक्ट करने के लिए समय सीमा को परिभाषित करता है। डिफ़ॉल्ट रूप से, यह मान मिलीसेकंड में माना जाता है, लेकिन इसमें [एक अन्य उपसर्ग](../../Server_settings/Special_suffixes.md) हो सकता है। डिफ़ॉल्ट मान 1000 (1 सेकंड) है।
जब एक दूरस्थ नोड से कनेक्ट होते हैं, तो Manticore इस अधिकतम समय की प्रतीक्षा करेगा ताकि कनेक्शन सफलतापूर्वक पूरा हो सके। यदि टाइमआउट पूरा हो जाता है लेकिन कनेक्शन स्थापित नहीं हुआ है, और `retries` सक्षम हैं, तो एक पुनः प्रयास शुरू किया जाएगा।


### replication_query_timeout

`replication_query_timeout` उस समय की मात्रा को सेट करता है जो searchd एक दूरस्थ नोड से प्रश्न पूरा करने का इंतजार करेगा। डिफ़ॉल्ट मान 3000 मिलीसेकंड (3 सेकंड) है, लेकिन इसे एक अलग समय इकाई इंगित करने के लिए `suffixed` किया जा सकता है।

एक कनेक्शन स्थापित करने के बाद, Manticore दूरस्थ नोड को पूरा करने के लिए अधिकतम `replication_query_timeout` की प्रतीक्षा करेगा। ध्यान दें कि यह टाइमआउट `replication_connect_timeout` से अलग है, और एक दूरस्थ नोड द्वारा उत्पन्न समग्र संभावित देरी दोनों मानों का योग होगी।


### replication_retry_count

यह सेटिंग एक पूर्णांक है जो निर्दिष्ट करती है कि Manticore कितनी बार पुनरुत्पादन के दौरान एक दूरस्थ नोड से कनेक्ट और पूछताछ करने का प्रयास करेगा, इससे पहले कि यह एक घातक प्रश्न त्रुटि की रिपोर्ट करे। डिफ़ॉल्ट मान 3 है।


### replication_retry_delay

यह सेटिंग एक पूर्णांक है मिलीसेकंड में (या [special_suffixes](../Server_settings/Special_suffixes.md)) जो निर्दिष्ट करती है कि Manticore पुनरुत्पादन के दौरान विफलता के मामले में एक दूरस्थ नोड से पूछताछ करने में पुनः प्रयास करने से पहले कितना विलंब करेगा। यह मान केवल तभी प्रासंगिक है जब एक गैर-शून्य मान निर्दिष्ट किया जाए। डिफ़ॉल्ट मान 500 है।

### qcache_max_bytes

<!-- example conf qcache_max_bytes -->
यह कॉन्फ़िगरेशन.cached परिणाम सेट के लिए आवंटित अधिकतम RAM मात्रा को बाइट्स में सेट करता है। डिफ़ॉल्ट मान 16777216 है, जो 16 मेगाबाइट के बराबर है। यदि मान 0 पर सेट किया जाता है, तो प्रश्न कैश अक्षम हो जाता है। प्रश्न कैश के बारे में अधिक जानकारी के लिए, कृपया [query cache](../Searching/Query_cache.md) देखें।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
qcache_max_bytes = 16777216
```
<!-- end -->


### qcache_THRESH_msec

पूर्णांक, मिलीसेकंड में। एक प्रश्न परिणाम को कैश करने के लिए न्यूनतम दीवार समय सीमा। डिफ़ॉल्ट 3000 है, या 3 सेकंड। 0 का मतलब है सब कुछ कैश करना। विवरण के लिए [query cache](../Searching/Query_cache.md) देखें। यह मान समय [special_suffixes](../Server_settings/Special_suffixes.md) के साथ भी व्यक्त किया जा सकता है, लेकिन इसका उपयोग सावधानी से करें और इसके नाम के साथ भ्रमित न हों, जिसमें '_msec' शामिल है।


### qcache_ttl_sec

पूर्णांक, सेकंड में। कैश किए गए परिणाम सेट के लिए समाप्ति अवधि। डिफ़ॉल्ट 60 है, या 1 मिनट। न्यूनतम संभव मान 1 सेकंड है। विवरण के लिए [query cache](../Searching/Query_cache.md) देखें। यह मान समय [special_suffixes](../Server_settings/Special_suffixes.md) के साथ भी व्यक्त किया जा सकता है, लेकिन इसका उपयोग सावधानी से करें और इसके नाम के साथ भ्रमित न हों, जिसमें '_sec' शामिल है।


### query_log_format

<!-- example conf query_log_format -->
प्रश्न लॉग प्रारूप। वैकल्पिक, अनुमत मान `plain` और `sphinxql` हैं, डिफ़ॉल्ट `sphinxql` है।

`sphinxql` मोड मान्य SQL विधान लॉग करता है। `plain` मोड प्रश्नों को एक साधारण पाठ प्रारूप में लॉग करता है (आम तौर पर पूर्ण-पाठ उपयोग मामलों के लिए उपयुक्त)। यह निर्देश आपको खोज सर्वर के प्रारंभ में दोनों प्रारूपों के बीच स्विच करने की अनुमति देता है। लॉग प्रारूप को `SET GLOBAL query_log_format=sphinxql` वाक्यविन्यास का उपयोग करके भी तत्काळ बदला जा सकता है। अधिक विवरण के लिए [Query logging](../Logging/Query_logging.md) देखें।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
query_log_format = sphinxql
```
<!-- end -->

### query_log_min_msec

सीमा (मिलीसेकंड में) जो प्रश्न को प्रश्न लॉग में लिखने से रोकती है। वैकल्पिक, डिफ़ॉल्ट 0 है (सभी प्रश्न प्रश्न लॉग में लिखे जाते हैं)। यह निर्देश निर्दिष्ट करता है कि केवल वे प्रश्न जिनकी निष्पादन समय निर्दिष्ट सीमा को पार करता है, लॉग किए जाएंगे (इस मान को समय [special_suffixes](../Server_settings/Special_suffixes.md) के साथ भी व्यक्त किया जा सकता है, लेकिन इसका उपयोग सावधानी से करें और इसके नाम के साथ भ्रमित न हों, जिसमें `_msec` शामिल है)।

### query_log

<!-- example conf query_log -->
प्रश्न लॉग फ़ाइल का नाम। वैकल्पिक, डिफ़ॉल्ट खाली है (प्रश्न लॉग न करें)। सभी खोज प्रश्न (जैसे SELECT ... लेकिन INSERT/REPLACE/UPDATE प्रश्न नहीं) इस फ़ाइल में लॉग किए जाएंगे। प्रारूप का वर्णन [Query logging](../Logging/Query_logging.md) में किया गया है। 'plain' प्रारूप के मामले में, आप लॉग फ़ाइल के पथ के रूप में 'syslog' का उपयोग कर सकते हैं। इस मामले में, सभी खोज प्रश्न syslog डेमन को `LOG_INFO` प्राथमिकता के साथ भेजे जाएंगे, '[query]' के साथ समय मोहर के बजाय। syslog विकल्प का उपयोग करने के लिए, Manticore को निर्माण पर `-–with-syslog` के साथ कॉन्फ़िगर किया जाना चाहिए।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
query_log = /var/log/query.log
```
<!-- end -->


### query_log_mode

<!-- example conf query_log_mode -->
query_log_mode निर्देश आपको searchd और प्रश्न लॉग फ़ाइलों के लिए एक अलग अनुमति सेट करने की अनुमति देती है। डिफ़ॉल्ट रूप से, ये लॉग फ़ाइलें 600 अनुमति के साथ बनाई जाती हैं, जिसका अर्थ है कि केवल उस उपयोगकर्ता के तहत जो सर्वर चलता है और रूट उपयोगकर्ता लॉग फ़ाइलों को पढ़ सकते हैं।
यह निर्देश तब सहायक हो सकता है जब आप अन्य उपयोगकर्ताओं को लॉग फ़ाइलों को पढ़ने की अनुमति देना चाहते हैं, जैसे कि गैर-रूट उपयोगकर्ताओं पर चलने वाले निगरानी समाधानों के लिए।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
query_log_mode  = 666
```
<!-- end -->

### read_buffer_docs

<!-- example conf read_buffer_docs -->
read_buffer_docs निर्देश डॉक्यूमेंट सूचियों के लिए प्रति-कीवर्ड पढ़ने की बफर आकार को नियंत्रित करता है। प्रत्येक कीवर्ड की उपस्थिति के लिए प्रत्येक खोज प्रश्न में दो संबंधित पढ़ने की बफर होती हैं: एक दस्तावेज़ सूची के लिए और एक हिट सूची के लिए। यह सेटिंग आपको दस्तावेज़ सूची बफर का आकार नियंत्रित करने की अनुमति देती है।

एक बड़ा बफर आकार प्रति-प्रश्न RAM उपयोग को बढ़ा सकता है, लेकिन यह I/O समय को कम कर सकता है। धीमी स्टोरेज के लिए बड़े मान सेट करना समझ में आता है, लेकिन उच्च IOPS वाले स्टोरेज के लिए, कम मानों के क्षेत्र में प्रयोग करना चाहिए।
डिफ़ॉल्ट मान 256K है, और न्यूनतम मान 8K है। आप [read_buffer_docs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#read_buffer_docs) को प्रति-तालिका आधार पर भी सेट कर सकते हैं, जो सर्वर के कॉन्फ़िगरेशन स्तर पर सेट किसी भी चीज़ को अधिलेखित करेगा।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
read_buffer_docs = 128K
```
<!-- end -->


### read_buffer_hits

<!-- example conf read_buffer_hits -->
read_buffer_hits निर्देशिका खोज क्वेरियों में हिट सूचियों के लिए प्रति-किवर्ड रीड बफर आकार को निर्दिष्ट करती है। डिफ़ॉल्ट रूप से, आकार 256K है और न्यूनतम मान 8K है। खोज क्वेरी में प्रत्येक किवर्ड उपस्थिति के लिए, दस्तावेज़ सूची के लिए और हिट सूची के लिए दो संबंधित रीड बफर्स होते हैं। बफर के आकार को बढ़ाने से प्रति-क्वेरी RAM उपयोग बढ़ सकता है लेकिन I/O समय कम हो सकता है। धीमी स्टोरेज के लिए, बड़े बफर आकार समझ में आते हैं, जबकि उच्च IOPS सक्षम स्टोरेज के लिए, कम मान क्षेत्र में प्रयोग किया जाना चाहिए।

इस सेटिंग को भी [read_buffer_hits](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#read_buffer_hits) में read_buffer_hits विकल्प का उपयोग करके प्रति-तालिका आधार पर निर्दिष्ट किया जा सकता है, जो सर्वर-स्तरीय सेटिंग को अधिलेखित करेगा।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
read_buffer_hits = 128K
```
<!-- end -->

### read_unhinted

<!-- example conf read_unhinted -->
अनहिन्टेड रीड आकार। वैकल्पिक, डिफ़ॉल्ट 32K, न्यूनतम 1K

जब क्वेरी लगाई जाती है, कुछ रीड्स पहले से ही जानते हैं कि कितने डेटा को पढ़ा जाना है, लेकिन कुछ इस समय नहीं जानते। सबसे प्रमुख, हिट सूची का आकार वर्तमान में पहले से ज्ञात नहीं है। यह सेटिंग आपको ऐसे मामलों में पढ़े जाने वाले डेटा की मात्रा को नियंत्रित करने की अनुमति देती है। इसका हिट सूची I/O समय पर प्रभाव पड़ता है, जो अनहिन्टेड रीड आकार से बड़े सूचियों के लिए इसे कम करता है, लेकिन छोटे सूचियों के लिए इसे बढ़ाता है। यह RAM उपयोग को प्रभावित नहीं करता है क्योंकि रीड बफर पहले से ही आवंटित होगा। तो यह read_buffer से बड़ा नहीं होना चाहिए।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
read_unhinted = 32K
```
<!-- end -->

### reset_network_timeout_on_packet

<!-- example conf reset_network_timeout_on_packet -->
नेटवर्क टाइमआउट्स (जैसे `network_timeout`, `read_timeout`, और `agent_query_timeout`) के व्यवहार को परिष्कृत करता है।

जब 0 पर सेट किया जाता है, टाइमआउट्स पूरे अनुरोध/क्वेरी को भेजने के लिए अधिकतम समय सीमित करते हैं।
जब 1 (डिफ़ॉल्ट) पर सेट किया जाता है, टाइमआउट्स नेटवर्क गतिविधियों के बीच अधिकतम समय को सीमित करते हैं।

प्रतिकृति के साथ, एक नोड को एक बड़े फ़ाइल (उदाहरण के लिए, 100GB) को दूसरे नोड को भेजने की आवश्यकता हो सकती है। मान लीजिए कि नेटवर्क डेटा को 1GB/s की गति से स्थानांतरित कर सकता है, जिसमें 4-5MB के प्रत्येक पैकेट की एक श्रृंखला है। पूरे फ़ाइल को स्थानांतरित करने के लिए, आपको 100 सेकंड की आवश्यकता होगी। 5 सेकंड का डिफ़ॉल्ट टाइमआउट केवल 5GB के स्थानांतरण की अनुमति देगा इससे पहले कि कनेक्शन बंद हो जाए। टाइमआउट बढ़ाना एक समाधान हो सकता है, लेकिन यह स्केलेबल नहीं है (उदाहरण के लिए, अगली फ़ाइल 150GB हो सकती है, जिससे फिर से विफलता होती है)। हालाँकि, डिफ़ॉल्ट `reset_network_timeout_on_packet` को 1 पर सेट करने के साथ, टाइमआउट पूरे स्थानांतरण पर नहीं बल्कि व्यक्तिगत पैकेटों पर लागू होता है। जब तक स्थानांतरण प्रगति में है (और डेटा वास्तव में टाइमआउट अवधि के दौरान नेटवर्क के माध्यम से प्राप्त हो रहा है), इसे जीवित रखा जाता है। यदि स्थानांतरण अटक जाता है, तो ऐसा कि पैकेट के बीच टाइमआउट होता है, इसे छोड़ दिया जाएगा।

ध्यान दें कि यदि आप एक वितरित तालिका सेट करते हैं, तो प्रत्येक नोड - दोनों मास्टर और एजेंट - को ट्यून किया जाना चाहिए। मास्टर पक्ष पर, `agent_query_timeout` प्रभावित होता है; एजेंट पर, `network_timeout` प्रासंगिक है।

<!-- intro -->

##### उदाहरण:

<!-- request Example -->

```ini
reset_network_timeout_on_packet = 0
```

<!-- end -->


### rt_flush_period

<!-- example conf rt_flush_period -->
RT तालिकाओं का RAM चंक फ्लश चेक अवधि, सेकंड में (या [special_suffixes](../Server_settings/Special_suffixes.md))। वैकल्पिक, डिफ़ॉल्ट 10 घंटे है।

सक्रिय रूप से अपडेट की गई RT तालिकाएँ जो पूरी तरह से RAM चंक्स में फिट होती हैं, फिर भी कभी-कभी बढ़ते बिनलॉग का परिणाम दे सकती हैं, जो डिस्क उपयोग और क्रैश पुनर्प्राप्ति समय को प्रभावित करती हैं। इस निर्देशिका के साथ, खोज सर्वर आवधिक फ्लश चेक करता है, और योग्य RAM चंक्स को सहेजा जा सकता है, जिससे संबंधित बिनलॉग सफाई संभव हो सके। अधिक जानकारी के लिए [Binary logging](../Logging/Binary_logging.md) देखें।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
rt_flush_period = 3600 # 1 hour
```
<!-- end -->


### rt_merge_iops

<!-- example conf rt_merge_iops -->
अधिकतम I/O संचालन (प्रति सेकंड) की संख्या जो RT चंक मर्ज थ्रेड को शुरू करने की अनुमति है। वैकल्पिक, डिफ़ॉल्ट 0 (कोई सीमा नहीं) है।

यह निर्देशिका आपको `OPTIMIZE` बयानों से उत्पन्न होने वाले I/O प्रभाव को कम करने की अनुमति देती है। यह सुनिश्चित किया जाता है कि सभी RT ऑप्टिमाइजेशन गतिविधियाँ कॉन्फ़िगर की गई सीमा से अधिक डिस्क IOPS (प्रति सेकंड I/O) उत्पन्न नहीं करेंगी। rt_merge_iops को सीमित करना मर्जिंग के कारण खोज प्रदर्शन को गिराने को कम कर सकता है।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
rt_merge_iops = 40
```
<!-- end -->

### rt_merge_maxiosize

<!-- example conf rt_merge_maxiosize -->
एक I/O ऑपरेशन का अधिकतम आकार जिसे RT चंक मर्ज थ्रेड को शुरू करने की अनुमति है। वैकल्पिक, डिफ़ॉल्ट 0 (कोई सीमा नहीं) है।

यह निर्देशिका आपको `OPTIMIZE` बयानों से उत्पन्न होने वाले I/O प्रभाव को कम करने की अनुमति देती है। इस सीमा से बड़े I/O को दो या अधिक I/O में तोड़ा जाएगा, जिसे फिर [rt_merge_iops](../Server_settings/Searchd.md#rt_merge_iops) सीमा के संबंध में अलग-अलग I/O के रूप में माना जाएगा। इस प्रकार, यह सुनिश्चित किया जाता है कि सभी ऑप्टिमाइजेशन गतिविधियाँ प्रति सेकंड डिस्क I/O में (rt_merge_iops * rt_merge_maxiosize) से अधिक उत्पन्न नहीं करेंगी।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
rt_merge_maxiosize = 1M
```
<!-- end -->


### seamless_rotate

<!-- example conf seamless_rotate -->
`searchd` के ठहराव को रोकता है जबकि तालिकाओं को बड़ी मात्रा में डेटा के साथ घुमाते समय पूर्वकैश करने के लिए। वैकल्पिक, डिफ़ॉल्ट 1 है (संपूर्ण घुमाव को सक्षम करें)। विंडोज सिस्टम पर, सम्पूर्ण घुमाव डिफ़ॉल्ट रूप से निष्क्रिय है।

तालिकाओं में कुछ डेटा हो सकता है जिसे RAM में पूर्वकैश करने की आवश्यकता होती है। इस समय, `.spa`, `.spb`, `.spi`, और `.spm` फ़ाइलें पूरी तरह से पूर्वकैश की जाती हैं (ये क्रमशः विशेषता डेटा, बाइनरी विशेषता डेटा, कीवर्ड तालिका, और खत्म की गई पंक्ति मानचित्र को शामिल करती हैं।) बिना सम्पूर्ण घुमाव के, एक तालिका को घुमाने का प्रयास कम से कम RAM का उपयोग करके किया जाता है और यह निम्नलिखित प्रकार से काम करता है:

1. नए प्रश्न अस्थाई रूप से अस्वीकृत होते हैं ( "retry" त्रुटि कोड के साथ) ;
2. `searchd` वर्तमान में चल रहे सभी प्रश्नों को समाप्त होने की प्रतीक्षा करता है;
3. पुरानी तालिका को अवमुक्त किया जाता है, और इसकी फ़ाइलों का नाम बदल दिया जाता है;
4. नई तालिका फ़ाइलों का नाम बदल दिया जाता है, और आवश्यक RAM आवंटित किया जाता है;
5. नई तालिका की विशेषता और शब्दकोश डेटा RAM में पूर्व लोड किया जाता है;
6. `searchd` नए तालिका से प्रश्नों को सेवा देना फिर से शुरू करता है।

हालांकि, यदि बहुत सारे विशेषता या शब्दकोश डेटा हैं, तो पूर्व लोडिंग चरण में ध्यान देने योग्य समय लग सकता है - 1-5+ GB फ़ाइलों की पूर्व लोडिंग के मामले में कई मिनट तक।

यदि सम्पूर्ण घुमाव सक्षम है, तो घुमाव इस प्रकार काम करता है:

1. नई तालिका के लिए RAM भंडारण आवंटित किया जाता है;
2. नई तालिका की विशेषता और शब्दकोश डेटा RAM में असिंक्रोनस रूप से पूर्व लोड किया जाता है;
3. सफलता पर, पुरानी तालिका को अवमुक्त किया जाता है, और दोनों तालिका की फ़ाइलों का नाम बदल दिया जाता है;
4. असफलता पर, नई तालिका को अवमुक्त किया जाता है;
5. किसी भी क्षण में, प्रश्नों को पुरानी या नई तालिका की प्रति से सेवा दी जाती है।

सम्पूर्ण घुमाव घुमाव के दौरान उच्चतम पीक मेमोरी उपयोग की कीमत पर आता है (क्योंकि `.spa/.spb/.spi/.spm` डेटा की पुरानी और नई प्रतियों को RAM में रहना आवश्यक है जबकि नई प्रति लोड हो रही है)। औसत उपयोग समान रहता है।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
seamless_rotate = 1
```
<!-- end -->

### secondary_indexes
<!-- example conf secondary_indexes -->

यह विकल्प खोज प्रश्नों के लिए माध्यमिक संकेतांक के उपयोग को सक्षम/निष्क्रिय करता है। यह वैकल्पिक है, और डिफ़ॉल्ट 1 है (सक्षम)। ध्यान दें कि आपको इसे अनुक्रमण के लिए सक्षम करने की आवश्यकता नहीं है क्योंकि यह हमेशा सक्षम है जब तक कि [Manticore Columnar Library](https://github.com/manticoresoftware/columnar) स्थापित है। अंतिम उपयोग करते समय संकेतांकों के उपयोग के लिए भी इसकी आवश्यकता होती है। तीन मोड उपलब्ध हैं:

* `0`: खोज पर माध्यमिक संकेतांकों के उपयोग को निष्क्रिय करें। इन्हें व्यक्तिगत प्रश्नों के लिए [analyzer hints](../Searching/Options.md#Query-optimizer-hints) का उपयोग करके सक्षम किया जा सकता है।
* `1`: खोज पर माध्यमिक संकेतांकों के उपयोग को सक्षम करें। इन्हें व्यक्तिगत प्रश्नों के लिए [analyzer hints](../Searching/Options.md#Query-optimizer-hints) का उपयोग करके निष्क्रिय किया जा सकता है।
* `force`: सक्षम की तरह, लेकिन माध्यमिक संकेतांकों के लोडिंग के दौरान किसी भी त्रुटियों की रिपोर्ट की जाएगी, और पूरा संकेतांक डेमन में लोड नहीं किया जाएगा।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
secondary_indexes = 1
```

<!-- end -->

### server_id

<!-- example conf server_id -->
एक पूर्णांक संख्या जो एक सर्वर पहचानकर्ता के रूप में कार्य करती है जो एक अनूठा संक्षिप्त UUID उत्पन्न करने के लिए बीज के रूप में उपयोग की जाती है जो कि एक पुनरावृत्ति क्लस्टर का हिस्सा होते हैं। server_id क्‍लस्‍टर के नोड्स के बीच अद्वितीय होना चाहिए और 0 से 127 के बीच होना चाहिए। यदि server_id सेट नहीं है, तो यह MAC पते और PID फ़ाइल के पथ के हैश के रूप में या संक्षिप्त UUID के लिए बीज के रूप में एक यादृच्छिक संख्या के रूप में गणना की जाती है।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
server_id = 1
```
<!-- end -->


### shutdown_timeout

<!-- example conf shutdown_timeout -->
`searchd --stopwait` प्रतीक्षा समय, सेकंड में (या [special_suffixes](../Server_settings/Special_suffixes.md))। वैकल्पिक, डिफ़ॉल्ट 60 सेकंड है।

जब आप `searchd --stopwait` चलाते हैं, तो आपके सर्वर को रुकने से पहले कुछ गतिविधियाँ करनी पड़ती हैं, जैसे कि प्रश्नों को समाप्त करना, RT RAM भागों को फ्लश करना, विशेषताएँ फ्लश करना, और बिनलॉग को अपडेट करना। इन कार्यों को कुछ समय की आवश्यकता होती है। `searchd --stopwait` सर्वर को अपने कार्यों को समाप्त करने के लिए `shutdown_time` सेकंड तक प्रतीक्षा करेगा। उपयुक्त समय आपकी तालिका के आकार और लोड पर निर्भर करता है।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
shutdown_timeout = 3m # 3 मिनट तक प्रतीक्षा करें
```
<!-- end -->


### shutdown_token

VIP Manticore SQL कनेक्शन से 'shutdown' कमांड को सक्रिय करने के लिए आवश्यक पासवर्ड का SHA1 हैश। इसके बिना, [debug](../Reporting_bugs.md#DEBUG) 'shutdown' उपकमांड कभी भी सर्वर को रोकने का कारण नहीं बनेगा। ध्यान दें कि इस तरह का सरल हैशिंग मजबूत सुरक्षा के रूप में नहीं माना जाना चाहिए, क्योंकि हम एक सॉल्टेड हैश या किसी प्रकार के आधुनिक हैश फ़ंक्शन का उपयोग नहीं करते हैं। यह एक स्थानीय नेटवर्क में हाउसकीपिंग डेमन्स के लिए एक अनुशासनात्मक उपाय के रूप में अभिप्रेत है।

### snippets_file_prefix

<!-- example conf snippets_file_prefix -->
स्निप्पेट्स उत्पन्न करते समय स्थानीय फ़ाइल नामों के लिए prepend करने के लिए एक प्रीफ़िक्स। वैकल्पिक, डिफ़ॉल्ट वर्तमान कार्यशील फ़ोल्डर है।

इस प्रीफ़िक्स का उपयोग वितरित स्निप्पेट्स उत्पन्न करने में `load_files` या `load_files_scattered` विकल्पों के साथ किया जा सकता है।

ध्यान दें कि यह एक प्रीफ़िक्स है और **नहीं** एक पथ! इसका अर्थ है कि यदि एक प्रीफ़िक्स "server1" पर सेट किया गया है और अनुरोध "file23" को संदर्भित करता है, तो `searchd` "server1file23" (" इसके बिना सभी") खोलने का प्रयास करेगा। तो, यदि आपको इसे एक पथ बनाना है, तो आपको अंतिम स्लैश शामिल करना होगा।

अंतिम फ़ाइल पथ का निर्माण करने के बाद, सर्वर सभी सापेक्ष डायरेक्टरियों को समाप्त करता है और अंतिम परिणाम की तुलना `snippet_file_prefix` के मान से करता है। यदि परिणाम प्रीफ़िक्स से शुरू नहीं होता है, तो ऐसी फ़ाइल को एक त्रुटि संदेश के साथ अस्वीकृत कर दिया जाएगा।

उदाहरण के लिए, यदि आप इसे `/mnt/data` पर सेट करते हैं और कोई स्निप्पेट जनरेशन के लिए फ़ाइल `../../../etc/passwd` के रूप में स्रोत बनाता है, तो उन्हें त्रुटि संदेश प्राप्त होगा:

`File '/mnt/data/../../../etc/passwd' escapes '/mnt/data/' scope`

फ़ाइल की सामग्री के बजाय।
इसके अलावा, एक गैर-सेट पैरामीटर के साथ और `/etc/passwd` पढ़ने पर, यह वास्तव में /daemon/working/folder/etc/passwd को पढ़ेगा क्योंकि पैरामीटर का डिफ़ॉल्ट सर्वर का कार्यशील फ़ोल्डर है।

यह भी ध्यान दें कि यह एक स्थानीय विकल्प है; यह एजेंटों को किसी भी तरह से प्रभावित नहीं करता है। इसलिए आप एक मास्टर सर्वर पर एक उपसर्ग को सुरक्षित रूप से सेट कर सकते हैं। एजेंटों को भेजे गए अनुरोधों पर मास्टर की सेटिंग का कोई प्रभाव नहीं पड़ेगा। हालाँकि, वे एजेंट की अपनी सेटिंग्स से प्रभावित होंगे।

यह उपयोगी हो सकता है, उदाहरण के लिए, जब दस्तावेज़ संग्रह स्थान (चाहे वह स्थानीय संग्रहण हो या NAS माउंटपॉइंट्स) सर्वरों के बीच असंगत हों।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
snippets_file_prefix = /mnt/common/server1/
```
<!-- end -->

> **चेतावनी:** यदि आप अभी भी FS रूट से फ़ाइलों तक पहुंचना चाहते हैं, तो आपको `snippets_file_prefix` को खाली मान (द्वारा `snippets_file_prefix=` पंक्ति) में या रूट (द्वारा `snippets_file_prefix=/`) में स्पष्ट रूप से सेट करना होगा।


### sphinxql_state

<!-- example conf sphinxql_state -->
उस फ़ाइल का पथ जहां वर्तमान SQL स्थिति अनुक्रमित की जाएगी।

सर्वर के स्टार्टअप पर, इस फ़ाइल को दोबारा चलाया जाता है। पात्र स्थिति परिवर्तनों पर (जैसे, SET GLOBAL), इस फ़ाइल को स्वचालित रूप से फिर से लिखा जाता है। यह एक कठिन-से-पहचानने वाली समस्या को रोक सकता है: यदि आप UDF फ़ंक्शंस लोड करते हैं लेकिन Manticore क्रैश हो जाता है, जब इसे (स्वचालित रूप से) पुनः आरंभ किया जाता है, तो आपका UDF और वैश्विक चर अब उपलब्ध नहीं होंगे। निरंतर स्थिति का उपयोग यह सुनिश्चित करने में मदद करता है कि बिना किसी आश्चर्य के एक सुचारू पुनर्प्राप्ति हो।

`sphinxql_state` को मनमाने आदेशों को निष्पादित करने के लिए उपयोग नहीं किया जा सकता है, जैसे `CREATE TABLE`।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
sphinxql_state = uservars.sql
```
<!-- end -->


### sphinxql_timeout

<!-- example conf sphinxql_timeout -->
अनुरोधों के बीच प्रतीक्षा करने के लिए अधिकतम समय (सेकंड में, या [विशेष_suffixes](../Server_settings/Special_suffixes.md)) जब SQL इंटरफ़ेस का उपयोग कर रहे हों। वैकल्पिक, डिफ़ॉल्ट 15 मिनट है।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
sphinxql_timeout = 15m
```
<!-- end -->


### ssl_ca

<!-- example conf ssl_ca -->
SSL सर्टिफिकेट प्राधिकरण (CA) सर्टिफिकेट फ़ाइल (जिसे रूट सर्टिफिकेट के रूप में भी जाना जाता है) का पथ। वैकल्पिक, डिफ़ॉल्ट खाली है। जब यह खाली नहीं होता है, तो `ssl_cert` में सर्टिफिकेट को इस रूट सर्टिफिकेट द्वारा हस्ताक्षरित किया जाना चाहिए।

सर्वर सर्टिफिकेट पर हस्ताक्षर की पुष्टि करने के लिए CA फ़ाइल का उपयोग करता है। फ़ाइल को PEM प्रारूप में होना चाहिए।

<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
ssl_ca = keys/ca-cert.pem
```
<!-- end -->


### ssl_cert

<!-- example conf ssl_cert -->
सर्वर के SSL सर्टिफिकेट का पथ। वैकल्पिक, डिफ़ॉल्ट खाली है।

सर्वर इस सर्टिफिकेट का उपयोग SSL के माध्यम से HTTP ट्रैफ़िक को एन्क्रिप्ट करने के लिए एक स्वयं-हस्ताक्षरित सार्वजनिक कुंजी के रूप में करता है। फ़ाइल को PEM प्रारूप में होना चाहिए।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
ssl_cert = keys/server-cert.pem
```
<!-- end -->


### ssl_key

<!-- example conf ssl_key -->
SSL सर्टिफिकेट कुंजी का पथ। वैकल्पिक, डिफ़ॉल्ट खाली है।

सर्वर इस निजी कुंजी का उपयोग SSL के माध्यम से HTTP ट्रैफ़िक को एन्क्रिप्ट करने के लिए करता है। फ़ाइल को PEM प्रारूप में होना चाहिए।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
ssl_key = keys/server-key.pem
```
<!-- end -->


### subtree_docs_cache

<!-- example conf subtree_docs_cache -->
प्रति-प्रश्न अधिकतम सामान्य उपवृत्त दस्तावेज़ कैश आकार। वैकल्पिक, डिफ़ॉल्ट 0 (अक्षम) है।

यह सेटिंग एक सामान्य उपवृत्त ऑप्टिमाइज़र के RAM उपयोग को सीमित करती है (देखें [multi-queries](../Searching/Multi-queries.md))। अधिकतम, इस Much RAM को प्रत्येक प्रश्न के लिए दस्तावेज़ प्रविष्टियों को कैश करने के लिए खर्च किया जाएगा। सीमा को 0 पर सेट करने से ऑप्टिमाइज़र को अक्षम कर देता है।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
subtree_docs_cache = 8M
```
<!-- end -->


### subtree_hits_cache

<!-- example conf subtree_hits_cache -->
प्रति-प्रश्न अधिकतम सामान्य उपवृत्त हिट कैश आकार। वैकल्पिक, डिफ़ॉल्ट 0 (अक्षम) है।

यह सेटिंग एक सामान्य उपवृत्त ऑप्टिमाइज़र के RAM उपयोग को सीमित करती है (देखें [multi-queries](../Searching/Multi-queries.md))। अधिकतम, इस Much RAM को प्रत्येक प्रश्न के लिए कीवर्ड घटनाओं (हिट) को कैश करने के लिए खर्च किया जाएगा। सीमा को 0 पर सेट करने से ऑप्टिमाइज़र को अक्षम कर देता है।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
subtree_hits_cache = 16M
```
<!-- end -->

### threads

<!-- example threads -->
Manticore डेमन के लिए कार्यशील थ्रेड्स की संख्या (या, थ्रेड पूल का आकार)। Manticore शुरू होने पर इस संख्या के OS थ्रेड्स बनाता है, और वे डेमन के भीतर सभी काम करते हैं, जैसे प्रश्न निष्पादित करना, स्निप्पेट बनाना, आदि। कुछ संचालन को उप-कार्य में विभाजित किया जा सकता है और समानांतर में निष्पादित किया जा सकता है, उदाहरण के लिए:

* वास्तविक समय तालिका में खोजें
* स्थानीय तालिकाओं से मिलकर बनी वितरित तालिका में खोजें
* पर्कोलेट क्वेरी कॉल
* और अन्य

डिफ़ॉल्ट रूप से, इसे सर्वर पर CPU कोर की संख्या पर सेट किया जाता है। Manticore शुरू होने पर थ्रेड्स बनाता है और जब तक इसे रोका नहीं जाता, तब तक इन्हें रखता है। प्रत्येक उप-कार्य तब एक थ्रेड का उपयोग कर सकता है जब उसे इसकी आवश्यकता होती है। जब उप-कार्य समाप्त होता है, तो वह थ्रेड को छोड़ देता है ताकि दूसरा उप-कार्य इसका उपयोग कर सके।

यदि लोड I/O प्रकार के लिए तीव्र है, तो यह CPU कोर की संख्या से अधिक मान सेट करना समझदारी हो सकती है।

<!-- request Example -->
```ini
threads = 10
```

<!-- end -->

### thread_stack

<!-- example conf thread_stack -->
एक कार्य के लिए अधिकतम स्टैक आकार (कोरूटीन, एक खोज प्रश्न कई कार्यों/कोरूटीन का कारण बन सकता है)। वैकल्पिक, डिफ़ॉल्ट 128K है।

प्रत्येक कार्य का अपना 128K का स्टैक होता है। जब आप एक प्रश्न चलाते हैं, तो यह जांचा जाता है कि इसे कितने स्टैक की आवश्यकता है। यदि डिफ़ॉल्ट 128K पर्याप्त है, तो इसे केवल संसाधित किया जाता है। अगर अधिक की आवश्यकता है, तो एक अन्य कार्य के साथ एक बढ़ी हुई स्टैक की योजना बनाई जाती है, जो प्रक्रिया को जारी रखता है। ऐसे उन्नत स्टैक का अधिकतम आकार इस सेटिंग द्वारा सीमित होता है।

किसी उच्च दर को सेट करना गहरे प्रश्नों को बिना यह इशारा किए हुए प्रोसेस करने में मदद करेगा कि कुल RAM खपत बहुत अधिक बढ़ेगी। उदाहरण के लिए, इसे 1G पर सेट करना यह नहीं दर्शाता कि प्रत्येक नया काम 1G RAM लेगा, लेकिन यदि हम देखते हैं कि इसके लिए, चलो कहते हैं, 100M स्टैक की आवश्यकता होती है, तो हम बस काम के लिए 100M आवंटित करते हैं। उसी समय अन्य काम अपने डिफ़ॉल्ट 128K स्टैक के साथ चल रहे होंगे। इसी तरह, हम उन और अधिक जटिल प्रश्नों को चला सकते हैं जिन्हें 500M की आवश्यकता होती है। और केवल तभी यदि हम **देखते** हैं कि काम को 1G से अधिक स्टैक की आवश्यकता है, तो हम विफल हो जाएंगे और बहुत कम thread_stack के बारे में रिपोर्ट करेंगे।

हालांकि, व्यवहार में, 16M स्टैक की आवश्यकता वाले प्रश्न अक्सर पार्सिंग के लिए बहुत जटिल होते हैं और प्रोसेस करने के लिए बहुत समय और संसाधन लेते हैं। इसलिए, डेमन इसे प्रोसेस करेगा, लेकिन `thread_stack` सेटिंग द्वारा ऐसे प्रश्नों को सीमित करना काफी उचित प्रतीत होता है।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
thread_stack = 8M
```
<!-- end -->


### unlink_old

<!-- example conf unlink_old -->
सफल रोटेशन पर `.old` तालिका प्रतियों को अनलिंक करने की जांच करता है। वैकल्पिक, डिफ़ॉल्ट 1 है (अनलिंक करें)।


<!-- intro -->
##### उदाहरण:

<!-- request Example -->

```ini
unlink_old = 0
```
<!-- end -->


### watchdog

<!-- example conf watchdog -->
थ्रेडेड सर्वर वॉचडॉग। वैकल्पिक, डिफ़ॉल्ट 1 है (वॉचडॉग सक्षम)।

जब एक Manticore प्रश्न क्रैश होता है, तो यह पूरे सर्वर को डाउन कर सकता है। वॉचडॉग सुविधा सक्षम होने पर, `searchd` एक अलग हल्के प्रक्रिया को बनाए रखता है जो मुख्य सर्वर प्रक्रिया की निगरानी करता है और असामान्य परिवर्तन के मामले में इसे स्वचालित रूप से पुनः प्रारंभ करता है। वॉचडॉग डिफ़ॉल्ट रूप से सक्षम है।

<!-- request Example -->

```ini
watchdog = 0 # वॉचडॉग को डिसेबल करें
```
<!-- end -->
<!-- proofread -->







































