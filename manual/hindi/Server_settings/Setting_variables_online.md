# ऑनलाइन वेरिएबल्स सेट करना

## सेट करें
```sql
SET [GLOBAL] server_variable_name = value
SET [INDEX table_name] GLOBAL @user_variable_name = (int_val1 [, int_val2, ...])
SET NAMES value [COLLATE value]
SET @@dummy_variable = ignored_value
```

Manticore Search में `SET` स्टेटमेंट आपको वेरिएबल मूल्यों को संशोधित करने की अनुमति देता है। वेरिएबल नाम केस-संवेदनशील नहीं होते हैं, और कोई भी वेरिएबल मूल्य परिवर्तन सर्वर पुनःStar t के बाद स्थायी नहीं रहेगा।

Manticore Search `SET NAMES` स्टेटमेंट और `SET @@variable_name` सिंटेक्स का समर्थन करता है ताकि तीसरे पक्ष के MySQL क्लाइंट लाइब्रेरी, कनेक्टर्स और ढांचे के साथ संगतता सुनिश्चित की जा सके, जिन्हें कनेक्ट करते समय ये स्टेटमेंट चलाने की आवश्यकता हो सकती है। हालाँकि, ये स्टेटमेंट Manticore Search पर कोई प्रभाव नहीं डालते हैं।

Manticore Search में चार प्रकार के वेरिएबल होते हैं:

1.  प्रति-सेशन सर्वर वेरिएबल: `set var_name = value`
2.  वैश्विक सर्वर वेरिएबल: `set global var_name = value`
3.  वैश्विक उपयोगकर्ता वेरिएबल: `set global @var_name = (value)`
4.  वैश्विक वितरित वेरिएबल: `set index dist_table_name global @var_name = (value)`

वैश्विक उपयोगकर्ता वेरिएबल्स समानांतर सत्रों के बीच साझा किए जाते हैं। केवल समर्थित मूल्य प्रकार BIGINTs की एक सूची है, और इन वेरिएबल्स का उपयोग फ़िल्टरिंग उद्देश्यों के लिए IN() ऑपरेटर के साथ किया जा सकता है। इस सुविधा का प्राथमिक उपयोग केस बड़ी मूल्य सूचियों को एक बार `searchd` में अपलोड करना और उन्हें कई बार बाद में फिर से उपयोग करना है, जिससे नेटवर्क ओवरहेड कम होता है। वैश्विक उपयोगकर्ता वेरिएबल्स को एक वितरित तालिका के सभी एजेंटों को स्थानांतरित किया जा सकता है या एक वितरित तालिका में परिभाषित स्थानीय तालिका के मामले में स्थानीय रूप से सेट किया जा सकता है। उदाहरण:

```sql
// सत्र 1 में
mysql> SET GLOBAL @myfilter=(2,3,5,7,11,13);
Query OK, 0 rows affected (0.00 sec)

// बाद में सत्र 2 में
mysql> SELECT * FROM test1 WHERE group_id IN @myfilter;
+------+--------+----------+------------+-----------------+------+
| id   | weight | group_id | date_added | title           | tag  |
+------+--------+----------+------------+-----------------+------+
|    3 |      1 |        2 | 1299338153 | another doc     | 15   |
|    4 |      1 |        2 | 1299338153 | doc number four | 7,40 |
+------+--------+----------+------------+-----------------+------+
2 rows in set (0.02 sec)
```

Manticore Search प्रति-सेशन और वैश्विक सर्वर वेरिएबल्स का समर्थन करता है जो उनके संबंधित स्कोप में विशिष्ट सर्वर सेटिंग्स को प्रभावित करते हैं। नीचे ज्ञात प्रति-सेशन और वैश्विक सर्वर वेरिएबल्स की एक सूची है:

ज्ञात प्रति-सेशन सर्वर वेरिएबल्स:

* `AUTOCOMMIT = {0 | 1}` निर्धारित करता है कि डेटा संशोधन स्टेटमेंट्स को स्वचालित रूप से `BEGIN` और `COMMIT` द्वारा लिपटाया जाना चाहिए या नहीं।
* `COLLATION_CONNECTION = collation_name` आगे की क्वेरीज में स्ट्रिंग मूल्यों पर `ORDER BY` या `GROUP BY` के लिए क्रमबद्धता का चयन करता है। ज्ञात क्रमबद्धता नामों की सूची के लिए [Collations](../Searching/Collations.md) को देखें।
* `MAX_THREADS_PER_QUERY = <POSITIVE_INT_VALUE>` रनटाइम में [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query) को फिर से परिभाषित करता है। प्रति-सेशन वेरिएबल केवल उसी सत्र (कनेक्शन) में चलने वाली क्वेरीज को प्रभावित करता है, यानी, डिस्कनेक्ट होने तक। मूल्य 0 का अर्थ है 'कोई सीमा नहीं'। यदि दोनों प्रति-सेशन और वैश्विक वेरिएबल सेट हैं, तो प्रति-सेशन वाला उच्च प्राथमिकता रखता है।
* `net_write_timeout = <value>`: लेखन संचालन, यानी डेटा भेजने के लिए नेटवर्क टाइमआउट को समायोजित करता है। वैश्विक मान केवल VIP विशेषाधिकार के साथ बदला जा सकता है।
* `optimize_by_id = {0 | 1}`: कुछ `debug` आदेशों में उपयोग किया जाने वाला आंतरिक संकेत।
* `PROFILING = {0 | 1}` वर्तमान सत्र में क्वेरी प्रोफाइलिंग सक्षम करता है। डिफ़ॉल्ट 0 है। [show profile](../Node_info_and_management/Profiling/Query_profile.md) भी देखें।
* `ro = {1 | 0}` सत्र को केवल-पढ़ने के मोड में स्विच करता है या वापस। `show variables` आउटपुट में वेरिएबल को `session_read_only` नाम से प्रदर्शित किया गया है।
* `throttling_period = <INT_VALUE>`: उस अवधि (मिलीसेकंड में) के लिए जिसमें वर्तमान चल रही क्वेरी फिर से शेड्यूल होगी। 0 का मान थ्रॉटलिंग को निष्क्रिय करता है, जिसका अर्थ है कि क्वेरी CPU कोर पर तब तक कब्जा करेगी जब तक कि यह समाप्त नहीं हो जाती। यदि समांतर क्वेरीज एक ही समय में अन्य कनेक्शनों से आती हैं, तो उन्हें मुक्त कोर आवंटित किए जाएंगे या तब तक निलंबित किया जाएगा जब तक कि एक कोर मुक्त नहीं होता। नकारात्मक मान प्रदान करने (-1) थ्रॉटलिंग को डिफ़ॉल्ट संकलित मान (100ms) पर रीसेट कर देता है, जिसका अर्थ है कि क्वेरी हर 100ms में फिर से शेड्यूल की जाएगी, जिससे समांतर क्वेरीज को निष्पादित होने का अवसर मिलेगा। वैश्विक मान (जो `set global` के माध्यम से सेट किया गया है) केवल VIP कनेक्शन पर ही सेट किया जा सकता है।
* `thread_stack = <value>`: एक टास्क को प्रदान की गई स्टैक आकार को सीमित करने के लिए, डिफ़ॉल्ट मान को तुरंत बदलता है। ध्यान दें कि यहाँ 'थ्रेड' का अर्थ एक OS थ्रेड नहीं है, बल्कि एक उपयोगकर्ता स्थान थ्रेड, जिसे कोरूटीन के रूप में भी जाना जाता है। यह उपयोगी हो सकता है यदि, उदाहरण के लिए, आप एक परकल्ट टेबल को अप्रत्याशित रूप से उच्च आवश्यकताओं के साथ लोड करते हैं। ऐसे मामलों में, 'call pq' एक असंयमित स्टैक आकार की सूचना के साथ विफल हो जाएगा। सामान्यतः, आपको डेमॉन को रोकना चाहिए, कॉन्फ़िगरेशन में मान बढ़ाना चाहिए, और फिर पुनरारंभ करना चाहिए। हालाँकि, आप इस वेरिएबल के साथ एक नई मान सेट करके बिना पुनरारंभ किए भी नए मान का प्रयास कर सकते हैं। वैश्विक मान को `set global thread_stack` के साथ ऑनलाइन भी बदला जा सकता है, लेकिन यह केवल VIP कनेक्शन से उपलब्ध है।
* `threads_ex` (diagnostic): Manticore को इस प्रकार के प्रोफ़ाइल के साथ CPU पर काम करने के लिए मजबूर करता है। एक संक्षिप्त उदाहरण, `set threads_ex='4/2+6/3'` इंगित करता है 'आपके पास 4 मुक्त CPU कोर हैं, जब कई क्वेरीज की शेड्यूलिंग की जानी चाहिए तो उन्हें 2 द्वारा बैच किया जाना चाहिए। इसके अलावा, आपके पास 6 मुफ्त CPU कोर हैं pseudo-sharding के लिए, भागों को 3 द्वारा बैच किया जाना चाहिए'। यह विकल्प Diagnostic है, जैसे आपकी क्वेरी उस कॉन्फ़िगरेशन पर कैसे चलेगी जो आपके पास स्थानीय रूप में नहीं है, इसे देखने में बहुत मददगार है। उदाहरण के लिए, 128-कोर CPU पर। या, इसके विपरीत, डेमॉन को त्वरित रूप से एकल-धागे के रूप में व्यवहार करने के लिए सीमित करने के लिए, एक बॉटलनेक्स की पहचान करने या एक क्रैश की जांच करने के लिए।

  <details>
	डिफॉल्ट के तौर पर, मैन्टिकोर एक थ्रेड पूल शुरू करता है जिसमें CPU कोर की एक गणना की गई संख्या होती है। सभी सामान्य कार्य तब इस थ्रेड पूल में वितरित किए जाते हैं ताकि CPU उपयोग क्षमता अधिकतम हो सके। उदाहरण के लिए, जब एक रियल-टाइम टेबल में कई डिस्क_chunks होते हैं, तो खोज CPU कोरों पर समानांतर किया जाएगा। इसी तरह, एक एकल पूर्ण-त Texto खोज के लिए एकल इंडेक्स पर, डेमन खोज निष्पादन को समानांतर में अनुकूलित करने का प्रयास करेगा, इसे "pseudo-sharding" तकनीक के रूप में संदर्भित किया जाता है। ये दोनों विशेषताएँ कुल CPU कोरों की संख्या और उपलब्ध मुक्त कोरों की संख्या पर भारी निर्भर करती हैं।

	यह दृष्टिकोण प्रदर्शन में सुधार करता है लेकिन घटना जांच को और मुश्किल बना सकता है। उदाहरण के लिए, एक क्वेरी जो `COUNT(*)` कर रही है, एक अनुमानित परिणाम (जैसे, 100 से अधिक मेल) वापस कर सकती है, और उसी क्वेरी के एक बाद के निष्पादन में एक सटीक परिणाम मिल सकता है (जैसे, ठीक 120 मेल)। यह भिन्नता उपलब्ध कोरों पर निर्भर करती है, लेकिन चूंकि यह कारक अप्रत्याशित है, यह आमतौर पर गैर-प्रतिकृति परिणामों की ओर ले जाती है। हालांकि यह सामान्यतः स्वीकार्य है, लेकिन कभी-कभी यह एक समस्या पैदा कर सकता है। `threads_ex` विकल्प एक इच्छित CPU कोर कॉन्फ़िगरेशन निर्दिष्ट करता है, जिससे इस कॉन्फ़िगरेशन के साथ क्वेरियाँ पुन: उत्पन्न हो सकती हैं।

	`threads_ex` मानक कार्यों और pseudo-sharding के लिए CPU टेम्पलेट सेट करता है, क्योंकि pseudo-sharding मानक समानांतरकरण प्रक्रिया का एक हिस्सा हो सकता है। उदाहरण के लिए, यदि कई डिस्क_chunks हैं, तो उन्हें समानांतर में क्वेरी किया जाएगा, लेकिन प्रत्येक को pseudo-sharding का उपयोग करके आगे और समानांतरित किया जा सकता है। इस प्रकार, इस स्थिति को प्रभावी ढंग से प्रबंधित करने के लिए, आपको प्रत्येक कार्य प्रकार के लिए कुछ टेम्पलेट की आवश्यकता है।

	एक टेम्पलेट एक स्ट्रिंग है जैसे `10/3`, जहाँ 10 समवर्तीता को दर्शाता है और 3 बैच का आकार दर्शाता है। यदि समवर्तीता 0 है, तो डिफॉल्ट समवर्तीता का उपयोग किया जाएगा। यदि बैच का आकार 0 है, तो डिफॉल्ट तुच्छ टेम्पलेट का उपयोग किया जाएगा। किसी भी शून्य मान को छोड़ दिया जा सकता है या `*` से बदला जा सकता है। डिफॉल्ट (तुच्छ) टेम्पलेट को `''` के रूप में वर्णित किया जा सकता है, और `*/*`, `0/0`, `0/`, `*/`, `/0`, `*`, आदि के रूप में भी। इसका मतलब है कि डेमन बिना किसी विशेष बैचिंग सीमाओं के सभी उपलब्ध CPU कोरों का उपयोग करता है।

	एक तुच्छ टेम्पलेट जिसमें 20 थ्रेड होते हैं, उसे `20/*`, `20/0`, `20/`, या बस `20` के रूप में व्यक्त किया जा सकता है। 2 के बैच के आकार के साथ एक राउंड-रॉबिन टेम्पलेट `*/2`, `0/2`, या बस `/2` है। 20 थ्रेड और 3 के बैच के आकार के साथ एक राउंड-रॉबिन डिस्पैचर `20/3` है।

	`threads_ex` बुनियादी कार्यों और pseudo-sharding के लिए एक टेम्पलेट है, जिसे `+` से अलग किया गया है, जैसे:

	* `30+3` - 30 थ्रेड का एक तुच्छ आधार + 3 थ्रेड का तुच्छ pseudo-sharding
	* `+/2` - एक तुच्छ आधार + डिफॉल्ट थ्रेड के साथ राउंड-रॉबिन pseudo-sharding और बैच=2
	* `10` - 10 थ्रेड का एक तुच्छ आधार + डिफॉल्ट तुच्छ pseudo-sharding
	* `/1+10` - डिफॉल्ट थ्रेड के साथ एक राउंड-रॉबिन आधार और बैच=1 + 10 थ्रेड के साथ तुच्छ pseudo-sharding
	* `4/2+2/1` - 4 थ्रेड और बैच=2 के साथ एक राउंड-रॉबिन आधार + 2 थ्रेड और बैच=1 के साथ राउंड-रॉबिन pseudo-sharding
	* `1+1` - सबसे सुनिश्चित मामला। ठीक 1 थ्रेड + 1 pseudo-shard, यानी, बिल्कुल कोई समानांतरकरण नहीं। इस सेटिंग के साथ, आप उस ही समस्या क्वेरी को पुनरुत्पादित रूप से दोहरा सकते हैं और व्यवहार विवरणों की जांच कर सकते हैं। इसके अलावा, यदि आप `throttling_period=0` सेट करते हैं, तो आपकी क्वेरी वर्तमान थ्रेड पर 'चिपक' जाएगी और निष्पादन के दौरान कभी भी पुनर्निर्धारित नहीं होगी, जो समस्या निवारण के लिए एक आदर्श वातावरण बनाता है।

	विकल्प को बाहरी रूप से एक वातावरणीय चर `MANTICORE_THREADS_EX` के रूप में वैश्विक रूप से सेट किया जा सकता है, जैसे:

	```bash
	export MANTICORE_THREADS_EX=8
	export MANTICORE_THREADS_EX='16+8/2'
  ```

  या, MySQL CLI के माध्यम से, जैसे:
  ```sql
  SET threads_ex='16';
	SET GLOBAL threads_ex='/2';
  ```

  या, एक क्वेरी पैरामीटर के रूप में, जैसे:
  ```sql
  SELECT ... OPTION threads_ex='1+1';
  ```

  `threads_ex` कॉन्फ़िगरेशन एक पदानुक्रम का पालन करता है: पहले वातावरणीय चर, फिर वैश्विक चर, और अंततः, क्वेरी विकल्प, विशेष सेटिंग्स को सामान्य सेटिंग्स को अधिलेखित करने की अनुमति देती है।

  </details>
* `WAIT_TIMEOUT/net_read_timeout = <value>` कनेक्शन टाइमआउट सेट करता है, या तो प्रति सत्र या वैश्विक। वैश्विक केवल VIP कनेक्शन पर सेट किया जा सकता है।

ज्ञात वैश्विक सर्वर चर हैं:

* `ACCURATE_AGGREGATION`: भविष्य की क्वेरियों के लिए विकल्प [accurate_aggregation](../Searching/Options.md#accurate_aggregation) का डिफॉल्ट मान सेट करता है।
* `AUTO_OPTIMIZE = {1|0}` [auto_optimize](../Server_settings/Searchd.md#auto_optimize) को चालू/बंद करता है।
* `cluster_user = name` `mysqldump` / `mariadb-dump` के साथ उपयोग किए जाने वाले उपयोगकर्ता नाम को सेट करता है ताकि [प्रतिनिधित्व मोड सक्षम करें](../Securing_and_compacting_a_table/Backup_and_restore.md#Backup-and-restore-with-mysqldump)।
* `COREDUMP= {1|0}` क्रैश होने पर सर्वर का कोर फ़ाइल या मिनिडंप को सहेजने को चालू/बंद करता है। अधिक विवरण [यहाँ](../Starting_the_server/Manually.md#searchd-command-line-options)।
* `CPUSTATS= {1|0}` [CPU समय ट्रैकिंग](../Starting_the_server/Manually.md#searchd-command-line-options) को चालू/बंद करता है।
* `DISTINCT_PRECISION_THRESHOLD`: भविष्य की क्वेरियों के लिए विकल्प [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) का डिफॉल्ट मान सेट करता है।
* `ES_COMPAT = {on/off/dashboards}` जब `on` (डिफॉल्ट) पर सेट किया गया हो, Elasticsearch-जैसे लिखने के अनुरोधों का समर्थन किया जाता है; `off` समर्थन को बंद करता है; `dashboards` समर्थन को सक्षम करता है और Kibana से अनुरोधों की अनुमति भी देता है (यह कार्यक्षमता प्रयोगात्मक है)।
* `EXPANSION_MERGE_THRESHOLD_DOCS`: सीधे सेटिंग के [expansion_merge_threshold_docs](Server_settings/Searchd.md#expansion_merge_threshold_docs) के मान को बदलता है।
* `EXPANSION_MERGE_THRESHOLD_HITS`: सीधे सेटिंग के [expansion_merge_threshold_hits](Server_settings/Searchd.md#expansion_merge_threshold_hits) के मान को बदलता है।
* `GROUPING_IN_UTC = {0 | 1}` जब 1 पर सेट किया जाता है, तो समयबद्ध समूहण कार्यों (day(), month(), year(), yearmonth(), yearmonthday()) को UTC में गणना करने का कारण बनता है। अधिक विवरण के लिए [grouping_in_utc](../Server_settings/Searchd.md) कॉन्फ़िग पैरामीटर दस्तावेज़ पढ़ें।
* `IOSTATS = {0 | 1}` क्वेरी लॉग में I/O संचालन (विशेषता को छोड़कर) रिपोर्टिंग को सक्षम या अक्षम करता है।
* `LOG_DEBUG_FILTER = <string value>` अनावश्यक लॉग संदेशों को फ़िल्टर करता है। यदि मान सेट किया गया है, तो सभी लॉग जिनका स्तर > INFO है (i.e., `DEBUG`, `DEBUGV`, आदि) दिए गए मान से तुलना की जाएगी और केवल उसी स्थिति में आउटपुट किया जाएगा जब वे दिए गए मान से शुरू होते हैं।
* `LOG_LEVEL = {info | debug | replication | debugv | debugvv}` वर्तमान लॉग विस्तृतता स्तर को बदलता है।
* `MAINTENANCE = {0 | 1}` जब 1 पर सेट किया जाता है, तो सर्वर को रखरखाव मोड में डालता है। केवल VIP कनेक्शन वाले क्लाइंट इस मोड में प्रश्नों को निष्पादित कर सकते हैं। सभी नए गैर-VIP आने वाले कनेक्शन अस्वीकार कर दिए जाते हैं। मौजूदा कनेक्शन बिना किसी परिवर्तन के बने रहते हैं।
* `MAX_THREADS_PER_QUERY = <POSITIVE_INT_VALUE>` रनटाइम पर [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query) को पुनर्परिभाषित करता है। यह वैश्विक स्तर पर सभी सत्रों के लिए व्यवहार को बदलता है। मान 0 का अर्थ है 'कोई सीमा नहीं'। यदि सत्र-विशिष्ट और वैश्विक दोनों मान सेट किए गए हैं, तो सत्र-विशिष्ट वाला उच्च प्राथमिकता रखता है।
* `NET_WAIT = {-1 | 0 | POSITIVE_INT_VALUE}` [net_wait_tm](../Server_settings/Searchd.md#net_wait_tm) खोजद सेटिंग्स मान को बदलता है।
* `OPTIMIZE_CUTOFF = <value>`: बिना रुकावट के [optimize_cutoff](../Server_settings/Searchd.md#optimize_cutoff) सेटिंग के मान को बदलता है।
* `PSEUDO_SHARDING = {1|0}` खोज [pseudo-sharding](../Server_settings/Searchd.md#pseudo_sharding) को चालू/बंद करता है।
* `QCACHE_MAX_BYTES = <value>` [query_cache](../Searching/Query_cache.md) RAM उपयोग सीमा को दिए गए मान में बदलता है।
* `QCACHE_THRESH_MSEC = <value>` [query_cache](../Searching/Query_cache.md) न्यूनतम दीवार समय थ्रेशोल्ड को दिए गए मान में बदलता है।
* `QCACHE_TTL_SEC = <value>` [query_cache](../Searching/Query_cache.md) में कैश किए गए परिणाम के लिए TTL को दिए गए मान में बदलता है।
* `QUERY_LOG_FORMAT = {plain | sphinxql}` वर्तमान लॉग प्रारूप को बदलता है।
* `QUERY_LOG_MIN_MSEC = <value>` [query_log_min_msec](../Server_settings/Searchd.md#query_log_min_msec) खोजद सेटिंग्स मान को बदलता है। इस मामले में, यह मान को ठीक ठीक मिलीसेकंड में अपेक्षित करता है और समय प्रमाणों को पार्स नहीं करता है, जैसे कि कॉन्फ़िग में।
  > चेतावनी: यह एक बहुत विशिष्ट और 'कठिन' मान है; फ़िल्टर किए गए संदेश बस हटा दिए जाएंगे और लॉग में बिल्कुल नहीं लिखे जाएंगे। बेहतर है कि आप अपने लॉग को कुछ 'grep' जैसा फ़िल्टर करें, इस मामले में, आपके पास कम से कम एक बैकअप के रूप में पूर्ण मूल लॉग होगा।
* `RESET_NETWORK_TIMEOUT_ON_PACKET = {1|0}` [reset_network_timeout_on_packet](../Server_settings/Searchd.md#reset_network_timeout_on_packet) पैरामीटर को बदलता है। केवल VIP कनेक्शन वाले क्लाइंट इस चर को बदल सकते हैं।
* `SECONDARY_INDEXES = {1|0}` खोज प्रश्नों के लिए [secondary indexes](../Server_settings/Searchd.md#secondary_indexes) को चालू/बंद करता है।
* `TIMEZONE = <value>` दिनांक/समय-संबंधित कार्यों द्वारा उपयोग की जाने वाली पार्लिकता को निर्दिष्ट करता है। अधिक विवरण के लिए [timezone](../Server_settings/Searchd.md) डेटा के लिए दस्तावेज़ पढ़ें।

उदाहरण:

```sql
mysql> SET autocommit=0;
Query OK, 0 rows affected (0.00 sec)

mysql> SET GLOBAL query_log_format=sphinxql;
Query OK, 0 rows affected (0.00 sec)

mysql> SET GLOBAL @banned=(1,2,3);
Query OK, 0 rows affected (0.01 sec)

mysql> SET INDEX users GLOBAL @banned=(1,2,3);
Query OK, 0 rows affected (0.01 sec)
```

उपयोगकर्ता वेरिएबल को स्थायी बनाने के लिए, सुनिश्चित करें कि [sphinxql_state](../Server_settings/Searchd.md#sphinxql_state) सक्षम है।
<!-- proofread -->

