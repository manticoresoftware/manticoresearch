# Балансировка нагрузки

Балансировка нагрузки включена по умолчанию для любой [распределенной таблицы](../../Creating_a_table/Creating_a_distributed_table/Creating_a_distributed_table.md), использующей [зеркалирование](../../Creating_a_cluster/Remote_nodes/Mirroring.md). По умолчанию запросы распределяются случайным образом между зеркалами. Вы можете изменить это поведение, используя [ha_strategy](../../Creating_a_cluster/Remote_nodes/Load_balancing.md).

## ha_strategy

```ini
ha_strategy = {random|nodeads|noerrors|roundrobin}
```

Стратегия выбора зеркал для балансировки нагрузки является необязательной и по умолчанию установлена на `random`.

Стратегия, используемая для выбора зеркала, или, другими словами, выбора конкретного [агента-зеркала](../../Creating_a_cluster/Remote_nodes/Mirroring.md#Agent-mirrors) в распределенной таблице, контролируется этой директивой. По сути, эта директива управляет тем, как мастер выполняет балансировку нагрузки между настроенными узлами-агентами зеркал. Реализованы следующие стратегии:

### Простой случайный баланс

<!-- example conf balancing 1 -->
Режим балансировки по умолчанию — это простое линейное случайное распределение между зеркалами. Это означает, что каждому зеркалу присваиваются равные вероятности выбора. Это похоже на round-robin (RR), но не накладывает строгого порядка выбора.

<!-- intro -->
##### Пример:

<!-- request Example -->
```ini
ha_strategy = random
```
<!-- end -->

### Адаптивный случайный баланс

Простая случайная стратегия по умолчанию не учитывает статус зеркал, уровень ошибок и, что наиболее важно, фактические задержки ответа. Чтобы решить проблемы с гетерогенными кластерами и временными всплесками нагрузки на узлы-агенты, существует группа стратегий балансировки, которые динамически регулируют вероятности на основе фактических задержек запросов, наблюдаемых мастером.

Адаптивные стратегии на основе **вероятностей с учетом задержки** работают следующим образом:

1. Статистика задержки накапливается в блоках по ha_period_karma секунд.
2. Вероятности с учетом задержки пересчитываются один раз за период кармы.
3. Флаг "мертв или жив" корректируется один раз за запрос, включая пинг-запросы.

Изначально вероятности равны. На каждом шаге они масштабируются на обратное значение задержек, наблюдаемых в течение последнего периода кармы, а затем повторно нормализуются. Например, если в течение первых 60 секунд после запуска мастера 4 зеркала имели задержки 10 мс, 5 мс, 30 мс и 3 мс соответственно, первый шаг корректировки будет следующим:

1. Исходные проценты: 0.25, 0.25, 0.25, 0.25.
2. Наблюдаемые задержки: 10 мс, 5 мс, 30 мс, 3 мс.
3. Обратные задержки: 0.1, 0.2, 0.0333, 0.333.
4. Масштабированные проценты: 0.025, 0.05, 0.008333, 0.0833.
5. Повторно нормализованные проценты: 0.15, 0.30, 0.05, 0.50.

Это означает, что первое зеркало будет иметь 15% шанс быть выбранным в следующем периоде кармы, второе — 30% шанс, третье (самое медленное с задержкой 30 мс) только 5% шанс, а четвертое и самое быстрое (с задержкой 3 мс) — 50% шанс. После этого периода второй шаг корректировки вновь обновит эти шансы и так далее.

Идея заключается в том, что как только **наблюдаемые задержки** стабилизируются, **вероятности с учетом задержки** также стабилизируются. Все эти итерации корректировки направлены на сходимость к точке, где средние задержки примерно равны для всех зеркал.

<!-- example conf balancing 2 -->
#### nodeads
Вероятности с учетом задержки, но "мертвые" зеркала исключаются из выбора. "Мертвое" зеркало определяется как зеркало, которое в результате вызвало несколько серьезных ошибок (например, сбой сети или отсутствие ответа и т.д.) подряд.

<!-- intro -->
##### Пример:

<!-- request Example -->
```ini
ha_strategy = nodeads
```
<!-- end -->

<!-- example conf balancing 3 -->
#### noerrors

Вероятности с учетом задержки, но зеркала с худшим соотношением ошибок/успехов исключаются из выбора.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ha_strategy = noerrors
```
<!-- end -->

### Кратный баланс

<!-- example conf balancing 4 -->
Простая выборка по кругу, то есть сначала выбирается первое зеркало в списке, затем второе, потом третье и т.д., и процесс повторяется после достижения последнего зеркала в списке. В отличие от рандомизированных стратегий, RR накладывает строгий порядок запросов (1, 2, 3, ..., N-1, N, 1, 2, 3, ... и так далее) и *гарантирует*, что ни два последовательных запроса не будут отправлены на одно и то же зеркало.

<!-- intro -->
##### Пример:

<!-- request Example -->
```ini
ha_strategy = roundrobin
```
<!-- end -->

## Параметры на уровне экземпляра

### ha_period_karma

```ini
ha_period_karma = 2m
```

`ha_period_karma` определяет размер окна статистики узлов-агентов зеркал, в секундах (или с суффиксом времени). Опционально, по умолчанию — 60.

Для распределенной таблицы с узловыми зеркалами сервер отслеживает несколько различных счетчиков по каждому зеркалу. Эти счетчики затем используются для переключения на резервирование и балансировку. (Сервер выбирает лучшее зеркало для использования на основе счетчиков.) Счетчики накапливаются в блоках по `ha_period_karma` секунд.

После начала нового блока мастер может продолжать использовать накопленные значения из предыдущего до тех пор, пока новый не заполнится наполовину. Таким образом, любая предыдущая история перестает влиять на выбор зеркала не более чем через 1.5 раза за секунды ha_period_karma.

Хотя для выбора зеркал используется максимум 2 блока, на самом деле сохраняется до 15 последних блоков для целей инструментирования. Их можно просматривать с помощью оператора `SHOW AGENT STATUS`.

### ha_ping_interval

```ini
ha_ping_interval = 3s
```

Директива `ha_ping_interval` определяет интервал между пингами, отправляемыми на узлы-агенты зеркал, в миллисекундах (или с суффиксом времени). Эта опция является необязательной, и ее значение по умолчанию — 1000.
Для распределенной таблицы с агентскими зеркалами сервер отправляет всем зеркалам команду ping в период простоя для отслеживания их текущего состояния (живы они или мертвы, время кругового прохождения сети и т. д.). Интервал между ping-запросами определяется настройкой ha_ping_interval.

Если вы хотите отключить pings, установите ha_ping_interval в 0.

<!-- proofread -->

