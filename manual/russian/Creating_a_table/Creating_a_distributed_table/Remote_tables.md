# Удалённые таблицы

Удалённая таблица в Manticore Search представлена префиксом [agent](../../Creating_a_table/Creating_a_distributed_table/Creating_a_distributed_table.md) в определении распределённой таблицы. Распределённая таблица может включать комбинацию локальных и удалённых таблиц. Если локальные таблицы не указаны, распределённая таблица будет полностью удалённой и будет служить только как прокси. Например, у вас может быть экземпляр Manticore, который прослушивает несколько портов и обслуживает разные протоколы, а затем перенаправляет запросы на бэкэнд-серверы, которые принимают соединения только через внутренний двоичный протокол Manticore, используя постоянные соединения для уменьшения накладных расходов при установлении соединений.
Хотя полностью удалённая распределённая таблица сама не обслуживает локальные таблицы, она всё равно потребляет ресурсы машины, поскольку необходимо выполнять финальные вычисления, такие как слияние результатов и вычисление окончательных агрегированных значений.

## agent

```ini
agent = address1 [ | address2 [...] ][:table-list]
agent = address1[:table-list [ | address2[:table-list [...] ] ] ]
```

Директива `agent` объявляет удалённых агентов, которые опрашиваются каждый раз при поиске по окружающей распределённой таблице. Эти агенты фактически являются указателями на сетевые таблицы. Указанное значение включает адрес и может также содержать несколько альтернатив (зеркал агентов) как для адреса, так и для адреса и списка таблиц.

Спецификация адреса должна быть одной из следующих:

```ini
address = hostname[:port] # eg. server2:9312
address = /absolute/unix/socket/path # eg. /var/run/manticore2.sock
```

`hostname` — имя удалённого хоста, `port` — удалённый TCP-порт, `table-list` — список имён таблиц через запятую, а квадратные скобки [] обозначают необязательное условие.

Если имя таблицы опущено, считается, что это та же таблица, в которой определена эта строка. Другими словами, при определении агентов для распределённой таблицы 'mycoolindex' можно просто указать адрес, и будет считаться, что вы запрашиваете таблицу mycoolindex на конце агента.

Если номер порта опущен, считается, что он равен **9312**. Если он задан, но недопустим (например, 70000), агент будет пропущен.

Вы можете указать каждому агенту одну или несколько удалённых таблиц, находящихся на одном или нескольких сетевых серверах без ограничений. Это позволяет использовать несколько различных режимов:
* Шардирование по множеству серверов агентов и создание произвольной топологии кластера
* Шардирование по множеству серверов агентов с зеркалированием для высокой доступности и балансировки нагрузки
* Шардирование на localhost для использования нескольких ядер (однако проще просто использовать несколько локальных таблиц)

Все агенты опрашиваются параллельно. Список индексов передаётся удалённому агенту дословно. Точный способ поиска в списке у агента (последовательно или параллельно) зависит исключительно от конфигурации агента (см. настройку [threads](../../Server_settings/Searchd.md#threads)). Мастер не контролирует это удалённо.

Важно отметить, что параметр `LIMIT` игнорируется в запросах к агентам. Это связано с тем, что каждый агент может содержать разные таблицы, поэтому применение лимита к итоговому набору результатов — ответственность клиента. Именно поэтому запрос к физической таблице отличается от запроса к распределённой таблице при просмотре логов запросов. Запрос не может быть простой копией оригинального, так как это не даст правильных результатов.

Например, если клиент выполняет запрос SELECT ... LIMIT 10, 10, и есть два агента, при этом у второго агента только 10 документов, то рассылка оригинального запроса с `LIMIT 10, 10` приведёт к тому, что со второго агента придёт 0 документов. Однако `LIMIT 10,10` должен вернуть документы с 10 по 20 из итогового набора. Чтобы решить это, запрос должен быть отправлен агентам с более широким лимитом, например, со значением max_matches по умолчанию, равным 1000.

Например, если есть распределённая таблица dist, которая ссылается на удалённую таблицу user, запрос клиента `SELECT * FROM dist LIMIT 10,10` будет преобразован в `SELECT * FROM user LIMIT 0,1000` и отправлен в удалённую таблицу user. Когда распределённая таблица получит результат, она применит LIMIT 10,10 и вернёт запрошенные 10 документов.

```sql
SELECT * FROM dist LIMIT 10,10;
```

запрос будет преобразован в:

```sql
SELECT * FROM user LIMIT 0,1000
```

Кроме того, значение может указывать опции для каждого отдельного агента, такие как:
* [ha_strategy](../../Creating_a_cluster/Remote_nodes/Load_balancing.md#ha_strategy) — `random`, `roundrobin`, `nodeads`, `noerrors` (переопределяет глобальную настройку `ha_strategy` для данного агента)
* `conn` — `pconn`, persistent (эквивалентно установке `agent_persistent` на уровне таблицы)
* `blackhole` `0`,`1` (идентично настройке [agent_blackhole](../../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_blackhole) для агента)
* `retry_count` целочисленное значение (соответствует [agent_retry_count](../../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_retry_count), но переданное значение не умножается на количество зеркал)

```ini
agent = address1:table-list[[ha_strategy=value, conn=value, blackhole=value]]
```

Пример:

```ini
# config on box1
# sharding a table over 3 servers
agent = box2:9312:shard1
agent = box3:9312:shard2

# config on box2
# sharding a table over 3 servers
agent = box1:9312:shard2
agent = box3:9312:shard3

# config on box3
# sharding a table over 3 servers
agent = box1:9312:shard1
agent = box2:9312:shard3

# per agent options
agent = box1:9312:shard1[ha_strategy=nodeads]
agent = box2:9312:shard2[conn=pconn]
agent = box2:9312:shard2[conn=pconn,ha_strategy=nodeads]
agent = test:9312:any[blackhole=1]
agent = test:9312|box2:9312|box3:9312:any2[retry_count=2]
agent = test:9312|box2:9312:any2[retry_count=2,conn=pconn,ha_strategy=noerrors]
```

Для оптимальной производительности рекомендуется группировать удалённые таблицы, расположенные на одном сервере, в одну запись. Например, вместо:
```ini
agent = remote:9312:idx1
agent = remote:9312:idx2
```
следует предпочесть:
```ini
agent = remote:9312:idx1,idx2
```

## agent_persistent

```ini
agent_persistent = remotebox:9312:index2
```

Опция `agent_persistent` позволяет устанавливать постоянное соединение с агентом, то есть соединение не закрывается после выполнения запроса. Синтаксис этой директивы такой же, как у `agent`. Однако вместо открытия нового соединения с агентом для каждого запроса и последующего закрытия мастер будет поддерживать открытое соединение и повторно использовать его для последующих запросов. Максимальное число постоянных соединений на один хост агента определяется опцией [persistent_connections_limit](../../Server_settings/Searchd.md#persistent_connections_limit) в разделе searchd.

Важно отметить, что [persistent_connections_limit](../../Server_settings/Searchd.md#persistent_connections_limit) должен быть установлен в значение больше 0 для использования постоянных соединений с агентом. Если он не задан, по умолчанию равно 0, и директива `agent_persistent` будет работать так же, как `agent`.

Использование постоянных соединений master-agent снижает нагрузку на TCP-порты и экономит время на рукопожатиях соединений, делая процесс более эффективным.

## agent_blackhole

```ini
agent_blackhole = testbox:9312:testindex1,testindex2
````

Директива `agent_blackhole` позволяет перенаправлять запросы к удалённым агентам без ожидания или обработки их ответов. Это полезно для отладки или тестирования производственных кластеров, так как можно настроить отдельный экземпляр для отладки/тестирования и перенаправлять запросы к нему с производственного экземпляра мастера (агрегатора), не вмешиваясь в работу производства. Мастер searchd будет пытаться подключиться к агенту blackhole и отправлять запросы как обычно, но не будет ждать или обрабатывать ответы, а все сетевые ошибки на агентах blackhole будут игнорироваться. Формат значения идентичен формату обычной директивы `agent`.

## agent_connect_timeout

```ini
agent_connect_timeout = 300
````

Директива `agent_connect_timeout` определяет таймаут подключения к удалённым агентам. По умолчанию значение предполагается в миллисекундах, но может иметь [другой суффикс](../../Server_settings/Special_suffixes.md)). Значение по умолчанию — 1000 (1 секунда).

При подключении к удалённым агентам `searchd` будет ждать не дольше этого времени для успешного установления соединения. Если истекает таймаут, но соединение не установлено и включены `retries`, будет предпринята повторная попытка.

## agent_query_timeout

```ini
agent_query_timeout = 10000 # our query can be long, allow up to 10 sec
```

Директива `agent_query_timeout` задаёт время, которое searchd будет ждать выполнения запроса от удалённого агента. Значение по умолчанию — 3000 миллисекунд (3 секунды), но оно может иметь суффикс, указывающий другую единицу времени.

После установления соединения `searchd` будет ждать максимум agent_query_timeout для завершения удалённых запросов. Обратите внимание, что этот таймаут отдельный от `agent_connection_timeout`, и общая возможная задержка из-за удалённого агента будет суммой обоих значений. Если таймаут agent_query_timeout достигается, запрос **не будет** повторяться, вместо этого будет выведено предупреждение.

Обратите внимание, что поведение также влияет [reset_network_timeout_on_packet](../../Server_settings/Searchd.md#reset_network_timeout_on_packet)

## agent_retry_count

Директива `agent_retry_count` — целое число, задающее, сколько раз Manticore будет пытаться подключиться и выполнить запросы к удалённым агентам в распределённой таблице перед тем, как сообщить об ошибке запроса с фатальным исходом. Работает подобно `agent_retry_count`, определённому в секции "searchd" конфигурационного файла, но применяется конкретно для таблицы.

## mirror_retry_count

`mirror_retry_count` служит той же цели, что и `agent_retry_count`. Если указаны оба значения, приоритет будет у `mirror_retry_count`, и будет выдано предупреждение.

## Параметры на уровне экземпляра

Следующие опции управляют общим поведением удалённых агентов и задаются в **секции searchd конфигурационного файла**. Они устанавливают значения по умолчанию для всего экземпляра Manticore.

* `agent_connect_timeout` - значение по умолчанию для параметра `agent_connect_timeout`.
* `agent_query_timeout` - значение по умолчанию для параметра `agent_query_timeout`. Также может быть переопределено для каждого запроса с использованием того же имени параметра в распределённой (сетевой) таблице.
* `agent_retry_count` — целое число, задающее количество попыток подключения и выполнения запросов к удалённым агентам в распределённой таблице до сообщения об ошибке с фатальным исходом. Значение по умолчанию — 0 (т.е. без повторных попыток). Можно также задать для каждого запроса отдельно с помощью опции 'OPTION retry_count=XXX'. Значение для конкретного запроса имеет приоритет над значением из конфига.

Обратите внимание, что если в определении распределённой таблицы вы используете **зеркала агентов**, сервер будет выбирать другое зеркало перед каждой попыткой подключения в соответствии со стратегией [ha_strategy](../../Creating_a_cluster/Remote_nodes/Load_balancing.md#ha_strategy). В этом случае значение [agent_retry_count](../../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_retry_count) будет суммироваться для всех зеркал в наборе.

Например, если у вас 10 зеркал и задано `agent_retry_count=5`, сервер попытается выполнить до 50 попыток (в среднем 5 попыток на каждое из 10 зеркал). При опции `ha_strategy = roundrobin` будет ровно 5 попыток на зеркало.

При этом значение, заданное как опция [retry_count](../../Searching/Options.md#retry_count) в объявлении `agent`, служит абсолютным лимитом. Другими словами, опция `[retry_count=2]` в объявлении агента означает максимум 2 попытки, вне зависимости от того, есть ли 1 или 10 зеркал в строке.

### agent_retry_delay

Директива `agent_retry_delay` — целочисленное значение, определяющее время в миллисекундах, которое Manticore Search будет ждать перед повторной попыткой запроса к удалённому агенту в случае ошибки. Это значение может быть задано глобально в конфигурации searchd или отдельно для конкретного запроса через опцию `OPTION retry_delay=XXX`. Если заданы обе опции, приоритет имеет опция для конкретного запроса. Значение по умолчанию — 500 миллисекунд (0,5 секунды). Эта опция актуальна только если `agent_retry_count` или опция для конкретного запроса `OPTION retry_count` ненулевые.

### client_timeout

Опция `client_timeout` задаёт максимальное время ожидания между запросами при использовании постоянных соединений. Значение указывается в секундах или с суффиксом времени. Значение по умолчанию — 5 минут.

Пример:

```ini
client_timeout = 1h
```

### hostname_lookup

Опция `hostname_lookup` определяет стратегию обновления имён хостов. По умолчанию IP-адреса имён агентов кэшируются при запуске сервера, чтобы избежать чрезмерных обращений к DNS. Однако в некоторых случаях IP может меняться динамически (например, облачный хостинг), и может потребоваться не кэшировать IP. Установка этой опции в значение `request` отключает кэширование и вызывает запрос к DNS при каждом запросе. IP-адреса также можно обновить вручную с помощью команды `FLUSH HOSTNAMES`.

### listen_tfo

Опция `listen_tfo` позволяет использовать флаг TCP_FASTOPEN для всех слушателей. По умолчанию управление осуществляется системой, но её можно явно отключить, установив значение '0'.

Для получения дополнительной информации о расширении TCP Fast Open, пожалуйста, обратитесь к [Wikipedia](https://en.wikipedia.org/wiki/TCP_Fast_Open). Короче говоря, это позволяет устранить один обход TCP при установлении соединения.

На практике использование TFO может оптимизировать сетевую эффективность клиента-агента, аналогично работе с `agent_persistent`, но без удержания активных соединений и без ограничений на максимальное количество соединений.

Большинство современных операционных систем поддерживают TFO. Linux (одна из самых прогрессивных) поддерживает его с 2011 года, начиная с ядра 3.7 (со стороны сервера). Windows поддерживает его с некоторых сборок Windows 10. Другие системы, такие как FreeBSD и MacOS, также поддерживают эту функцию.

Для систем Linux сервер проверяет переменную `/proc/sys/net/ipv4/tcp_fastopen` и ведёт себя соответствующим образом. Бит 0 управляет клиентской стороной, а бит 1 — слушателями. По умолчанию в системе этот параметр установлен в 1, то есть клиентская сторона включена, а слушатели — выключены.

### persistent_connections_limit

```ini
persistent_connections_limit = 29 # assume that each host of agents has max_connections = 30 (or 29).
```

Опция `persistent_connections_limit` определяет максимальное количество одновременных постоянных соединений с удалёнными постоянными агентами. Это настройка для всего экземпляра и должна быть определена в конфигурационном разделе searchd. Каждый раз при установлении соединения с агентом, определённым в `agent_persistent`, система пытается повторно использовать существующее соединение (если оно есть) или создаёт новое соединение и сохраняет его для будущего использования. Однако в некоторых случаях требуется ограничить количество постоянных соединений. Эта директива устанавливает лимит и влияет на количество соединений с хостом каждого агента во всех распределённых таблицах.

Рекомендуется устанавливать это значение равным или меньшим, чем параметр [max_connections](../../Server_settings/Searchd.md#max_connections) в конфигурации агента.

## Создание распределённых сниппетов

Особым случаем распределённой таблицы является одна локальная и несколько удалённых, которая используется исключительно для [создания распределённых сниппетов](../../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#Distributed-snippets-creation), когда сниппеты берутся из файлов. В этом случае локальная таблица может выступать как «шаблонная» таблица, предоставляя настройки для токенизации при построении сниппетов.

### snippets_file_prefix

```ini
snippets_file_prefix = /mnt/common/server1/
```

`snippets_file_prefix` — это необязательный префикс, который можно добавить к именам локальных файлов при генерации сниппетов. Значение по умолчанию — текущая рабочая папка.

Чтобы узнать больше о создании распределённых сниппетов, смотрите [CALL SNIPPETS](../../Searching/Highlighting.md).

## Распределённые таблицы перколяции (DPQ таблицы)

Вы можете создать распределённую таблицу из нескольких [перколяторных](../../Creating_a_table/Local_tables/Percolate_table.md) таблиц. Синтаксис создания такого типа таблиц такой же, как и для других распределённых таблиц, и может включать несколько `local` таблиц, а также `агентов`.

Для DPQ операции по списку сохранённых запросов и поиску по ним (с использованием [CALL PQ](../../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ)) являются прозрачными и работают так, как если бы все таблицы были одной локальной таблицей. Однако операции изменения данных, такие как `insert`, `replace`, `truncate`, не доступны.

Если в список агентов включить не перколяторную таблицу, поведение будет неопределённым. Если неправильный агент имеет ту же схему, что и внешняя схема PQ таблицы (id, query, tags, filters), это не вызовет ошибку при перечислении сохранённых правил PQ и может загрязнить список фактических правил PQ, хранящихся в PQ таблицах, своими неперколяторными строками. В результате будьте осторожны и осознавайте возможную путаницу. `CALL PQ` к такому неправильному агенту вызовет ошибку.

Для получения дополнительной информации о выполнении запросов к распределённой таблице перколяции смотрите [выполнение запросов к распределённой таблице перколяции](../../Searching/Percolate_query.md#Performing-a-percolate-query-with-CALL-PQ).
<!-- proofread -->

