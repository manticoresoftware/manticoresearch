# Типы данных

## Полнотекстовые поля и атрибуты

Типы данных Manticore можно разделить на две категории: полнотекстовые поля и атрибуты.

### Синтаксис имени поля

Имена полей в Manticore должны соответствовать следующим правилам:

* Могут содержать буквы (a-z, A-Z), цифры (0-9) и дефисы (-)
* Должны начинаться с буквы
* Цифры могут появляться только после букв
* Подчеркивание (`_`) — единственный разрешённый специальный символ
* Имена полей не чувствительны к регистру

Например:
* Корректные имена полей: `title`, `product_id`, `user_name_2`
* Некорректные имена полей: `2title`, `-price`, `user@name`

### Полнотекстовые поля

Полнотекстовые поля:
* могут индексироваться с использованием алгоритмов обработки естественного языка, следовательно, могут использоваться для поиска по ключевым словам
* не могут использоваться для сортировки или группировки
* содержимое исходного документа может быть извлечено
* содержимое исходного документа может использоваться для подсветки

Полнотекстовые поля представлены типом данных `text`. Все остальные типы данных называются "атрибутами".

### Атрибуты

Атрибуты — это значения без полнотекстового индекса, связанные с каждым документом, которые могут использоваться для фильтрации, сортировки и группировки, не связанных с полнотекстовым поиском, во время поиска.

Часто требуется обрабатывать результаты полнотекстового поиска, основываясь не только на совпадении идентификатора документа и его рейтинга, но и на ряде других значений для каждого документа. Например, может понадобиться отсортировать результаты поиска новостей по дате, а затем по релевантности, или искать товары в заданном ценовом диапазоне, или ограничить поиск по блогу постами выбранных пользователей, или сгруппировать результаты по месяцам. Для эффективного выполнения таких задач Manticore позволяет не только добавлять полнотекстовые поля, но и дополнительные атрибуты к каждому документу. Эти атрибуты можно использовать для фильтрации, сортировки или группировки полнотекстовых совпадений, либо для поиска только по атрибутам.

Атрибуты, в отличие от полнотекстовых полей, не индексируются как полнотекст. Они хранятся в таблице, но нельзя выполнять по ним полнотекстовый поиск.

<!-- example attributes or fields -->

Хорошим примером атрибутов будет таблица постов форума. Предположим, что только поля title и content должны быть полнотекстово индексируемыми — но иногда требуется ограничить поиск определённым автором или подразделом форума (т.е. искать только строки с определёнными значениями author_id или forum_id); или сортировать совпадения по столбцу post_date; или группировать найденные посты по месяцу из post_date и считать количество совпадений в каждой группе.

<!-- intro -->
##### SQL:
<!-- request SQL -->

```sql
CREATE TABLE forum(title text, content text, author_id int, forum_id int, post_date timestamp);
```
<!-- intro -->
##### JSON:

<!-- request JSON -->

```JSON
POST /cli -d "CREATE TABLE forum(title text, content text, author_id int, forum_id int, post_date timestamp)"
```

<!-- intro -->
##### PHP:

<!-- request PHP -->

```php
$index = new \Manticoresearch\Index($client);
$index->setName('forum');
$index->create([
    'title'=>['type'=>'text'],
	'content'=>['type'=>'text'],
	'author_id'=>['type'=>'int'],
	'forum_id'=>['type'=>'int'],
	'post_date'=>['type'=>'timestamp']
]);
```
<!-- intro -->
##### Python:

<!-- request Python -->

```python
utilsApi.sql('CREATE TABLE forum(title text, content text, author_id int, forum_id int, post_date timestamp)')
```

<!-- intro -->
##### Python-asyncio:

<!-- request Python-asyncio -->

```python
await utilsApi.sql('CREATE TABLE forum(title text, content text, author_id int, forum_id int, post_date timestamp)')
```

<!-- intro -->
##### Javascript:

<!-- request Javascript -->

```javascript
res = await utilsApi.sql('CREATE TABLE forum(title text, content text, author_id int, forum_id int, post_date timestamp)');
```

<!-- intro -->
##### Java:

<!-- request Java -->

```java
utilsApi.sql("CREATE TABLE forum(title text, content text, author_id int, forum_id int, post_date timestamp)");
```

<!-- intro -->
##### C#:

<!-- request C# -->

```java
utilsApi.Sql("CREATE TABLE forum(title text, content text, author_id int, forum_id int, post_date timestamp)");
```

<!-- intro -->
##### Rust:

<!-- request Rust -->

```rust
utils_api.sql("CREATE TABLE forum(title text, content text, author_id int, forum_id int, post_date timestamp)", Some(true)).await;
```

<!-- intro -->
##### config:

<!-- request config -->

```ini
table forum
{
	type = rt
	path = forum

	# when configuring fields via config, they are indexed (and not stored) by default
	rt_field = title
	rt_field = content

	# this option needs to be specified for the field to be stored
	stored_fields = title, content

	rt_attr_uint = author_id
	rt_attr_uint = forum_id
	rt_attr_timestamp = post_date
}
```

<!-- end -->

<!-- example filtered query -->

Этот пример показывает выполнение полнотекстового запроса с фильтрацией по `author_id`, `forum_id` и сортировкой по `post_date`.

<!-- intro -->
##### SQL:
<!-- request SQL -->

```sql
select * from forum where author_id=123 and forum_id in (1,3,7) order by post_date desc
```
<!-- intro -->
##### JSON:

<!-- request JSON -->

```JSON
POST /search
{
  "table": "forum",
  "query":
  {
    "match_all": {},
    "bool":
    {
      "must":
      [
        { "equals": { "author_id": 123 } },
		{ "in": { "forum_id": [1,3,7] } }
      ]
    }
  },
  "sort": [ { "post_date": "desc" } ]
}
```

<!-- intro -->
##### PHP:

<!-- request PHP -->

```php
$client->search([
        'table' => 'forum',
        'query' =>
        [
            'match_all' => [],
            'bool' => [
                'must' => [
                    'equals' => ['author_id' => 123],
                    'in' => [
                        'forum_id' => [
                            1,3,7
                        ]
                    ]
                ]
            ]
        ],
        'sort' => [
        ['post_date' => 'desc']
    ]
]);
```


<!-- intro -->
##### Python:

<!-- request Python -->

```python
searchApi.search({"table":"forum","query":{"match_all":{},"bool":{"must":[{"equals":{"author_id":123}},{"in":{"forum_id":[1,3,7]}}]}},"sort":[{"post_date":"desc"}]})
```

<!-- intro -->
##### Python-asyncio:

<!-- request Python-asyncio -->

```python
await searchApi.search({"table":"forum","query":{"match_all":{},"bool":{"must":[{"equals":{"author_id":123}},{"in":{"forum_id":[1,3,7]}}]}},"sort":[{"post_date":"desc"}]})
```

<!-- intro -->
##### Javascript:

<!-- request javascript -->

```javascript
res = await searchApi.search({"table":"forum","query":{"match_all":{},"bool":{"must":[{"equals":{"author_id":123}},{"in":{"forum_id":[1,3,7]}}]}},"sort":[{"post_date":"desc"}]});
```
<!-- intro -->
##### java:

<!-- request java -->

```java
HashMap<String,Object> filters = new HashMap<String,Object>(){{
    put("must", new HashMap<String,Object>(){{
        put("equals",new HashMap<String,Integer>(){{
            put("author_id",123);
        }});
        put("in",
            new HashMap<String,Object>(){{
                put("forum_id",new int[] {1,3,7});
        }});
    }});
}};
Map<String,Object> query = new HashMap<String,Object>();
query.put("match_all",null);
query.put("bool",filters);
SearchRequest searchRequest = new SearchRequest();
searchRequest.setIndex("forum");
searchRequest.setQuery(query);
searchRequest.setSort(new ArrayList<Object>(){{
    add(new HashMap<String,String>(){{ put("post_date","desc");}});
}});
SearchResponse searchResponse = searchApi.search(searchRequest);
```

<!-- intro -->
##### C#:

<!-- request C# -->

```clike
object query =  new { match_all=null };
var searchRequest = new SearchRequest("forum", query);
var boolFilter = new BoolFilter();
boolFilter.Must = new List<Object> {
    new EqualsFilter("author_id", 123),
    new InFilter("forum_id", new List<Object> {1,3,7})
};
searchRequest.AttrFilter = boolFilter;
searchRequest.Sort = new List<Object> { new SortOrder("post_date", SortOrder.OrderEnum.Desc) };
var searchResponse = searchApi.Search(searchRequest);
```

<!-- intro -->
##### Rust:

<!-- request Rust -->

``` rust
let query = SearchQuery::new();
let mut sort = HashMap::new();
sort.insert("post_date".to_string(), serde_json::json!("desc"));
let search_request = SearchRequest {
    table: "forum".to_string(),
    query: Some(Box::new(query)),
    sort: serde_json::json!(sort)
    ..Default::default()
};
let search_res = search_api.search(search_req).await;
```

<!-- end -->

### Структуры хранения атрибутов по строкам и по столбцам

Manticore поддерживает два типа структур хранения атрибутов:
* по строкам — традиционное хранение, доступное в Manticore Search из коробки
* колонковое — предоставляется библиотекой [Manticore Columnar Library](https://github.com/manticoresoftware/columnar)

Как можно понять из названий, они хранят данные по-разному. Традиционное **хранение по строкам**:
* хранит атрибуты без сжатия
* все атрибуты одного документа хранятся в одной строке рядом друг с другом
* строки хранятся одна за другой
* доступ к атрибутам осуществляется просто путём умножения ID строки на смещение (длину вектора) и получения нужного атрибута из вычисленного адреса в памяти. Это обеспечивает очень низкую задержку случайного доступа.
* атрибуты должны находиться в памяти для получения приемлемой производительности, иначе из-за особенностей хранения по строкам Manticore может читать с диска слишком много ненужных данных, что во многих случаях ухудшает производительность.

В случае **колонкового хранения**:
* каждый атрибут хранится независимо от других атрибутов в своей отдельной "колонке"
* хранение разбито на блоки по 65536 записей
* блоки хранятся сжатые. Это часто позволяет хранить лишь несколько уникальных значений вместо всех, как в хранении по строкам. Высокий уровень сжатия позволяет быстрее читать с диска и снижает требования к памяти
* при индексировании данных схема хранения выбирается отдельно для каждого блока. Например, если все значения в блоке одинаковые, используется схема "const" и в блоке хранится только одно значение. Если уникальных значений в блоке меньше 256, выбирается схема "table", и хранятся индексы на таблицу значений вместо самих значений
* поиск по блоку может быть досрочно отклонён, если ясно, что искомое значение в блоке отсутствует.

Колонковое хранение было разработано для обработки больших объёмов данных, которые не помещаются в ОЗУ, поэтому рекомендации таковы:
* если у вас достаточно памяти для всех атрибутов, вы выиграете на хранении по строкам
* в противном случае колонковое хранение все равно обеспечит достойную производительность с гораздо меньшим требованием к памяти, что позволит хранить гораздо больше документов в таблице





















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































