# Присоединение одной таблицы к другой

<!-- example Example_1 -->

Обычная таблица может быть преобразована в таблицу реального времени или добавлена к существующей таблице реального времени.

Первый случай полезен, когда необходимо полностью регенерировать таблицу реального времени, что может потребоваться, например, если настройки токенизации нуждаются в обновлении. В этой ситуации подготовка обычной таблицы и преобразование ее в таблицу реального времени может быть проще, чем подготовка пакетной работы для выполнения INSERT-ов для добавления всех данных в таблицу реального времени.

Во втором случае вы обычно хотите добавить большой объем новых данных в таблицу реального времени, и снова, создание обычной таблицы с этими данными проще, чем заполнение существующей таблицы реального времени.

Вы также можете присоединить существующую таблицу реального времени к другой.

##### Присоединение таблицы - общий синтаксис
Оператор `ATTACH` позволяет вам преобразовать обычную таблицу для присоединения к существующей таблице реального времени. Он также позволяет вам присоединить содержимое одной таблицы реального времени к другой таблице реального времени.

```sql
ATTACH TABLE plain_or_rt_table TO TABLE rt_table [WITH TRUNCATE]
```

После успешного выполнения `ATTACH` данные, ранее хранившиеся в исходной обычной таблице, становятся частью целевой таблицы RT, а исходная обычная таблица становится недоступной (до следующей перестройки). Если исходная таблица является таблицей RT, ее содержимое перемещается в целевую таблицу RT, а исходная таблица RT остается пустой. `ATTACH` не приводит к изменениям в данных таблицы. По сути, он просто переименовывает файлы (делая исходную таблицу новым дисковым чанком целевой таблицы RT) и обновляет метаданные. Таким образом, это, как правило, быстрая операция, которая может (часто) завершиться так же быстро, как менее чем за секунду.

Обратите внимание, что когда таблица присоединяется к пустой таблице RT, поля, атрибуты и настройки текстовой обработки (токенизатор, формы слов и т. д.) из *исходной* таблицы копируются и начинают действовать. Соответствующие части определения таблицы RT из конфигурационного файла будут проигнорированы.

Когда используется опция `TRUNCATE`, таблица RT очищается перед присоединением исходной обычной таблицы. Это позволяет операции быть атомарной или гарантирует, что присоединенная исходная обычная таблица будет единственными данными в целевой таблице RT.

`ATTACH TABLE` имеет ряд ограничений. В частности, целевая таблица RT в настоящее время должна быть либо пустой, либо иметь те же настройки, что и исходная таблица. В случае, если исходная таблица присоединяется к непустой таблице RT, данные таблицы RT, собранные до сих пор, хранятся как обычный дисковый чанк, и присоединяемая таблица становится самым новым дисковым чанком, при этом документы с одинаковыми идентификаторами уничтожаются. Полный список ограничений выглядит следующим образом:
* Целевая таблица RT должна быть либо пустой, либо иметь те же настройки, что и исходная таблица.
* Исходная таблица должна иметь [phrase_boundary_step](../../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#phrase_boundary_step) установленный на 0 и [stopword_step](../../../Creating_a_table/NLP_and_tokenization/Ignoring_stop-words.md#stopword_step) установленный на 1.


<!-- intro -->
##### Пример:

<!-- request Example -->
Перед присоединением ATTACH таблица RT пуста и имеет 3 поля:

```sql
mysql> DESC rt;
Empty set (0.00 sec)

mysql> SELECT * FROM rt;
+-----------+---------+
| Field     | Type    |
+-----------+---------+
| id        | integer |
| testfield | field   |
| testattr  | uint    |
+-----------+---------+
3 rows in set (0.00 sec)
```

Обычная таблица не пуста:

```sql
mysql> SELECT * FROM plain WHERE MATCH('test');
+------+--------+----------+------------+
| id   | weight | group_id | date_added |
+------+--------+----------+------------+
|    1 |   1304 |        1 | 1313643256 |
|    2 |   1304 |        1 | 1313643256 |
|    3 |   1304 |        1 | 1313643256 |
|    4 |   1304 |        1 | 1313643256 |
+------+--------+----------+------------+
4 rows in set (0.00 sec)
```

Присоединение обычной таблицы к таблице RT:
```sql
mysql> ATTACH TABLE plain TO TABLE rt;
Query OK, 0 rows affected (0.00 sec)
```

Теперь таблица RT имеет 5 полей:

```sql
mysql> DESC rt;
+------------+-----------+
| Field      | Type      |
+------------+-----------+
| id         | integer   |
| title      | field     |
| content    | field     |
| group_id   | uint      |
| date_added | timestamp |
+------------+-----------+
5 rows in set (0.00 sec)
```

И она не пуста:

```sql
mysql> SELECT * FROM rt WHERE MATCH('test');
+------+--------+----------+------------+
| id   | weight | group_id | date_added |
+------+--------+----------+------------+
|    1 |   1304 |        1 | 1313643256 |
|    2 |   1304 |        1 | 1313643256 |
|    3 |   1304 |        1 | 1313643256 |
|    4 |   1304 |        1 | 1313643256 |
+------+--------+----------+------------+
4 rows in set (0.00 sec)
```

После присоединения обычная таблица удаляется и больше не доступна для поиска:

```sql
mysql> SELECT * FROM plain WHERE MATCH('test');
ERROR 1064 (42000): no enabled local indexes to search
```
<!-- end -->
<!-- proofread -->
