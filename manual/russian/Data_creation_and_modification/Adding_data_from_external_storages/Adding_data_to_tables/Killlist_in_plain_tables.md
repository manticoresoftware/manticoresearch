# Список для удаления в простых таблицах

При использовании простых таблиц возникает проблема, связанная с необходимостью иметь данные в таблице как можно более актуальными.

В этом случае используются одна или несколько вторичных (также известных как дельта) таблиц для захвата измененных данных между моментом создания основной таблицы и текущим временем. Измененные данные могут включать новые, обновленные или удаленные документы. Поиск становится поиском по **основной таблице и дельта таблице**. Это работает без проблем, когда вы просто добавляете **новые** документы в дельта таблицу, но когда речь идет об обновленных или удаленных документах, остается следующая проблема.

Если документ присутствует как в основной, так и в дельта таблицах, это может вызвать проблемы во время поиска, так как движок увидит две версии документа и не будет знать, как выбрать правильную. Таким образом, дельта должна каким-то образом информировать поиск о том, что есть удаленные документы в основной таблице, которые следует игнорировать. **Вот здесь и появляются списки для удаления**.

## Таблица списка для удаления
Таблица может содержать список ID документов, который может использоваться для подавления записей в других таблицах. Эта функция доступна для простых таблиц, использующих источники данных или простые таблицы, использующие XML источники. В случае источников данных источник должен предоставить дополнительный запрос, определяемый `sql_query_killlist`. Он будет хранить в таблице список документов, которые могут использоваться сервером для удаления документов из других простых таблиц.

Ожидается, что этот запрос вернет количество строк с одной колонкой, каждая из которых содержит только ID документа.

В многих случаях этот запрос является объединением между запросом, который извлекает список обновленных документов, и списком удаленных документов, например:

```ini
sql_query_killlist = \
    SELECT id FROM documents WHERE updated_ts>=@last_reindex UNION \
    SELECT id FROM documents_deleted WHERE deleted_ts>=@last_reindex
```

## Удаление документов в простой таблице
Простая таблица может содержать директиву под названием [killlist_target](../../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#killlist_target), которая сообщит серверу, что он может предоставить список ID документов, которые должны быть удалены из определенных существующих таблиц. Таблица может использовать либо свои ID документов в качестве источника для этого списка, либо предоставить отдельный [список](../../../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#Table-kill-list).

### killlist_target

<!-- example killlist_target 1 -->
Устанавливает таблицы, к которым будет применяться список для удаления. Необязательно, значение по умолчанию пустое.

Когда вы используете [простые таблицы](../../../Creating_a_table/Local_tables/Plain_table.md), вам часто необходимо поддерживать не только одну таблицу, но и набор из них, чтобы иметь возможность быстрее добавлять/обновлять/удалять новые документы (читайте о [обновлениях дельта таблицы](../../../Data_creation_and_modification/Adding_data_from_external_storages/Main_delta.md)). Чтобы подавить совпадения в предыдущей (**основной**) таблице, которые были обновлены или удалены в следующей (**дельта**) таблице, вам необходимо:

1. Создать список для удаления в **дельта** таблице с использованием [sql_query_killlist](../../../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#Table-kill-list)
2. Указать **основную** таблицу как `killlist_target` в настройках **дельта** таблицы:


<!-- intro -->
##### КОНФИГУРАЦИЯ:

<!-- request CONFIG -->

```ini
table products {
  killlist_target = main:kl

  path = products
  source = src_base
}
```
<!-- end -->

Когда `killlist_target` указан, список для удаления применяется ко всем таблицам, перечисленным в нем, при запуске `searchd`. Если какая-либо из таблиц из `killlist_target` обновляется, список для удаления повторно применяется к этим таблицам. Когда список для удаления применяется, затронутые таблицы сохраняют эти изменения на диск.

`killlist_target` имеет 3 режима работы:

1. `killlist_target = main:kl`. ID документов из списка для удаления **дельта** таблицы подавляются в **основной** таблице (см. `sql_query_killlist`).
2. `killlist_target = main:id`. Все ID документов из **дельта** таблицы подавляются в **основной** таблице. Список для удаления игнорируется.
3. `killlist_target = main`. Оба ID документов из **дельта** таблицы и его список для удаления подавляются в **основной** таблице.

Можно указать несколько целей, разделяя их запятыми, например:

```ini
killlist_target = table_one:kl,table_two:kl
```

<!-- example killlist_target 2 -->
Вы можете изменить настройки `killlist_target` для таблицы, не перестраивая ее, с помощью `ALTER`.

Однако, поскольку 'старая' основная таблица уже записала изменения на диск, документы, которые были удалены в ней, **останутся** удаленными, даже если они больше не находятся в `killlist_target` **дельта** таблицы.


<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
ALTER TABLE delta KILLLIST_TARGET='new_main_table:kl'
```

<!-- request HTTP -->

```http
POST /cli -d "
ALTER TABLE delta KILLLIST_TARGET='new_main_table:kl'"
```
<!-- end -->
<!-- proofread -->
