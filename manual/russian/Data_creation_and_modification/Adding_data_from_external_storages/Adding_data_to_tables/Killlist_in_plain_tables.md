# Killlist в простых таблицах

При использовании простых таблиц возникает проблема, связанная с необходимостью иметь данные в таблице как можно более свежими.

В этом случае используются одна или несколько вторичных (также известных как дельта) таблиц для захвата измененных данных между временем создания основной таблицы и текущим временем. Измененные данные могут включать новые, обновленные или удаленные документы. Поиск становится поиском по **основной таблице и дельта-таблице**. Это работает бесшовно, когда вы просто добавляете **новые** документы в дельта-таблицу, но когда дело доходит до обновленных или удаленных документов, остается следующая проблема.

Если документ присутствует как в основной, так и в дельта-таблице, это может вызвать проблемы во время поиска, так как движок увидит две версии документа и не будет знать, как выбрать правильную. Таким образом, дельта-таблица должна каким-то образом сообщить поиску, что в основной таблице есть удаленные документы, которые следует игнорировать. **Для этого и нужны kill-листы**.

## Kill-лист таблицы
Таблица может поддерживать список идентификаторов документов, который можно использовать для подавления записей в других таблицах. Эта функция доступна для простых таблиц, использующих источники из базы данных, или простых таблиц, использующих XML-источники. В случае источников из базы данных, источник должен предоставить дополнительный запрос, определенный с помощью `sql_query_killlist`. Он будет хранить в таблице список документов, который сервер может использовать для удаления документов из других простых таблиц.

Ожидается, что этот запрос вернет ряд строк с одним столбцом, каждая из которых содержит только идентификатор документа.

Во многих случаях запрос представляет собой объединение запроса, который извлекает список обновленных документов, и списка удаленных документов, например:

```ini
sql_query_killlist = \
    SELECT id FROM documents WHERE updated_ts>=@last_reindex UNION \
    SELECT id FROM documents_deleted WHERE deleted_ts>=@last_reindex
```

## Удаление документов в простой таблице
Простая таблица может содержать директиву [killlist_target](../../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#killlist_target), которая сообщит серверу, что она может предоставить список идентификаторов документов, которые следует удалить из определенных существующих таблиц. Таблица может использовать либо свои собственные идентификаторы документов в качестве источника для этого списка, либо предоставить отдельный [список](../../../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#Table-kill-list).

### killlist_target

<!-- example killlist_target 1 -->
Устанавливает таблицу (таблицы), к которой будет применен kill-лист. Необязательный параметр, значение по умолчанию пустое.

Когда вы используете [простые таблицы](../../../Creating_a_table/Local_tables/Plain_table.md), вам часто нужно поддерживать не одну таблицу, а набор таблиц, чтобы иметь возможность быстрее добавлять/обновлять/удалять новые документы (читайте о [дельта-обновлениях таблиц](../../../Data_creation_and_modification/Adding_data_from_external_storages/Main_delta.md)). Чтобы подавить совпадения в предыдущей (**основной**) таблице, которые были обновлены или удалены в следующей (**дельта**) таблице, вам необходимо:

1.  Создать kill-лист в **дельта**-таблице с помощью [sql_query_killlist](../../../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#Table-kill-list)
2.  Указать **основную** таблицу как `killlist_target` в настройках **дельта**-таблицы:


<!-- intro -->
##### CONFIG:

<!-- request CONFIG -->

```ini
table products {
  killlist_target = main:kl

  path = products
  source = src_base
}
```
<!-- end -->

Когда `killlist_target` указан, kill-лист применяется ко всем перечисленным в нем таблицам при запуске `searchd`. Если любая из таблиц из `killlist_target` подвергается ротации, kill-лист повторно применяется к этим таблицам. Когда kill-лист применяется, таблицы, на которые он повлиял, сохраняют эти изменения на диск.

`killlist_target` имеет 3 режима работы:

1.  `killlist_target = main:kl`. Идентификаторы документов из kill-листа **дельта**-таблицы подавляются в **основной** таблице (см. `sql_query_killlist`).
2.  `killlist_target = main:id`. Все идентификаторы документов из **дельта**-таблицы подавляются в **основной** таблице. Kill-лист игнорируется.
3.  `killlist_target = main`. И идентификаторы документов из **дельта**-таблицы, и ее kill-лист подавляются в **основной** таблице.

Можно указать несколько целей, разделенных запятыми, например:

```ini
killlist_target = table_one:kl,table_two:kl
```

<!-- example killlist_target 2 -->
Вы можете изменить настройки `killlist_target` для таблицы без ее перестроения, используя `ALTER`.

Однако, поскольку 'старая' основная таблица уже записала изменения на диск, документы, которые были в ней удалены, **останутся** удаленными, даже если она больше не находится в `killlist_target` **дельта**-таблицы.


<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
ALTER TABLE delta KILLLIST_TARGET='new_main_table:kl'
```

<!-- request HTTP -->

```http
POST /cli -d "
ALTER TABLE delta KILLLIST_TARGET='new_main_table:kl'"
```
<!-- end -->
<!-- proofread -->

