# Killlist в простых таблицах

При использовании простых таблиц возникает проблема, связанная с необходимостью иметь максимально свежие данные в таблице.

В этом случае используется одна или несколько дополнительных (также известных как дельта) таблиц для фиксации изменённых данных между моментом создания основной таблицы и текущим временем. Изменённые данные могут включать новые, обновлённые или удалённые документы. Поиск становится поиском по **основной таблице и дельта-таблице**. Это работает без сбоев, если в дельта-таблицу добавляются только **новые** документы, но когда дело касается обновлённых или удалённых документов, остаётся следующая проблема.

Если документ присутствует как в основной, так и в дельта-таблице, это может вызывать проблемы при поиске, так как движок увидит две версии документа и не будет знать, какую выбрать. Поэтому дельта должна как-то информировать поиск о том, что в основной таблице есть удалённые документы, которые следует игнорировать. **Вот для этого нужны kill-листы**.

## Kill-лист таблицы
Таблица может хранить список идентификаторов документов, который может использоваться для подавления записей в других таблицах. Эта возможность доступна для простых таблиц, использующих источники базы данных или простых таблиц с XML-источниками. В случае с источниками базы данных источник должен предоставлять дополнительный запрос, определённый с помощью `sql_query_killlist`. Он сохранит в таблице список документов, который сервер сможет использовать для удаления документов из других простых таблиц.

Ожидается, что этот запрос вернёт несколько строк с одним столбцом, каждая из которых содержит только идентификатор документа.

Во многих случаях запрос представляет собой объединение (union) между выборкой обновлённых документов и списком удалённых, например:

```ini
sql_query_killlist = \
    SELECT id FROM documents WHERE updated_ts>=@last_reindex UNION \
    SELECT id FROM documents_deleted WHERE deleted_ts>=@last_reindex
```

## Удаление документов в простой таблице
Простая таблица может содержать директиву под названием [killlist_target](../../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#killlist_target), которая сообщает серверу, что он может предоставить список идентификаторов документов, которые следует удалить из определённых существующих таблиц. Таблица может использовать либо собственные идентификаторы документов как источник этого списка, либо предоставить отдельный [список](../../../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#Table-kill-list).

### killlist_target

<!-- example killlist_target 1 -->
Устанавливает таблицу(ы), к которой будет применён kill-лист. Необязательно, значение по умолчанию — пустое.

При использовании [простых таблиц](../../../Creating_a_table/Local_tables/Plain_table.md) часто необходимо поддерживать не только одну таблицу, а набор таблиц, чтобы иметь возможность быстрее добавлять/обновлять/удалять новые документы (см. о [обновлениях дельта-таблицы](../../../Data_creation_and_modification/Adding_data_from_external_storages/Main_delta.md)). Чтобы подавить совпадения в предыдущей (**основной**) таблице, которые были обновлены или удалены в следующей (**дельта**) таблице, необходимо:

1.  Создать kill-лист в **дельта** таблице с помощью [sql_query_killlist](../../../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#Table-kill-list)
2.  Указать **основную** таблицу как `killlist_target` в настройках **дельта** таблицы:


<!-- intro -->
##### CONFIG:

<!-- request CONFIG -->

```ini
table products {
  killlist_target = main:kl

  path = products
  source = src_base
}
```
<!-- end -->

Когда задан `killlist_target`, kill-лист применяется ко всем таблицам, указанным в нём, при запуске `searchd`. Если какая-либо из таблиц из `killlist_target` подвергается ротации, kill-лист применяется к этим таблицам заново. При применении kill-листа затронутые таблицы сохраняют эти изменения на диск.

`killlist_target` имеет 3 режима работы:

1.  `killlist_target = main:kl`. Идентификаторы документов из kill-листа **дельта** таблицы подавляются в **основной** таблице (см. `sql_query_killlist`).
2.  `killlist_target = main:id`. Все идентификаторы документов из **дельта** таблицы подавляются в **основной** таблице. Kill-лист игнорируется.
3.  `killlist_target = main`. Подавляются как идентификаторы документов из **дельта** таблицы, так и её kill-лист в **основной** таблице.

Можно указать несколько целей, разделённых запятыми, например:

```ini
killlist_target = table_one:kl,table_two:kl
```

<!-- example killlist_target 2 -->
Вы можете изменить настройки `killlist_target` для таблицы без её пересборки, используя `ALTER`.

Однако, поскольку «старая» основная таблица уже записала изменения на диск, документы, которые были удалены в ней, **останутся удалёнными**, даже если она больше не указана в `killlist_target` **дельта** таблицы.


<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
ALTER TABLE delta KILLLIST_TARGET='new_main_table:kl'
```

<!-- request HTTP -->

```http
POST /cli -d "
ALTER TABLE delta KILLLIST_TARGET='new_main_table:kl'"
```
<!-- end -->
<!-- proofread -->

