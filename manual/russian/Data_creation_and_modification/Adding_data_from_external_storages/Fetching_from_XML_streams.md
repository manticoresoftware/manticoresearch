# Получение данных из XML-потоков

Тип источника `xmlpipe2` позволяет передавать в Manticore пользовательские полнотекстовые и атрибутные данные в пользовательском XML-формате, при этом схема (т.е. набор полей и атрибутов) задаётся либо в самом XML-потоке, либо в настройках источника.

## Объявление XML-потока
Для объявления XML-потока обязательна директива `xmlpipe_command`, которая содержит shell-команду, генерирующую XML-поток для индексирования. Это может быть файл, а может быть и программа, которая генерирует XML-содержимое на лету.

## Формат XML-файла

При индексировании источника xmlpipe2 индексатор запускает указанную команду, открывает канал к её stdout и ожидает корректно сформированный XML-поток.

Вот пример того, как может выглядеть XML-поток данных:

```xml
<?xml version="1.0" encoding="utf-8"?>
<sphinx:docset>

<sphinx:schema>
<sphinx:field name="subject"/>
<sphinx:field name="content"/>
<sphinx:attr name="published" type="timestamp"/>
<sphinx:attr name="author_id" type="int" bits="16" default="1"/>
</sphinx:schema>

<sphinx:document id="1234">
<content>this is the main content <![CDATA[and this <cdata> entry
must be handled properly by xml parser lib]]></content>
<published>1012325463</published>
<subject>note how field/attr tags can be
in <b> class="red">randomized</b> order</subject>
<misc>some undeclared element</misc>
</sphinx:document>

<sphinx:document id="1235">
<subject>another subject</subject>
<content>here comes another document, and i am given to understand,
that in-document field order must not matter, sir</content>
<published>1012325467</published>
</sphinx:document>

<!-- ... even more sphinx:document entries here ... -->

<sphinx:killlist>
<id>1234</id>
<id>4567</id>
</sphinx:killlist>

</sphinx:docset>
```

Разрешены произвольные поля и атрибуты. Они также могут встречаться в потоке в произвольном порядке внутри каждого документа; порядок игнорируется. Существует ограничение на максимальную длину поля; поля длиной более 2 МБ будут усечены до 2 МБ (этот лимит можно изменить в настройках источника).

Схема, т.е. полный список полей и атрибутов, должна быть объявлена до того, как можно будет разобрать какой-либо документ. Это можно сделать либо в конфигурационном файле с помощью настроек `xmlpipe_field` и `xmlpipe_attr_XXX`, либо прямо в потоке с помощью элемента `<sphinx:schema>`. Элемент `<sphinx:schema>` является необязательным. Он допускается только как самый первый дочерний элемент в `<sphinx:docset>`. Если определение схемы в потоке отсутствует, будут использованы настройки из конфигурационного файла. В противном случае приоритет имеют настройки из потока. Обратите внимание, что идентификатор документа должен быть указан как свойство `id` тега `<sphinx:document>` (например, `<sphinx:document id="1235">`) и должен быть уникальным положительным 64-битным целым числом, не равным нулю.

Неизвестные теги (которые не были объявлены ни как поля, ни как атрибуты) будут проигнорированы с предупреждением. В приведённом выше примере тег `<misc>` будет проигнорирован. Все вложенные теги и их атрибуты (например, `<strong>` в `<subject>` в примере выше) будут молча проигнорированы.

Поддержка кодировок входящего потока зависит от наличия `iconv` в системе. xmlpipe2 парсится с помощью парсера `libexpat`, который нативно понимает US-ASCII, ISO-8859-1, UTF-8 и несколько вариантов UTF-16. Скрипт `configure` Manticore также проверит наличие `libiconv` и использует его для обработки других кодировок. `libexpat` также накладывает требование использовать кодировку UTF-8 на стороне Manticore, поскольку возвращаемые им данные всегда в UTF-8.

XML-элементы (теги), распознаваемые xmlpipe2 (и их атрибуты, где применимо):

* `sphinx:docset` — обязательный элемент верхнего уровня, обозначает и содержит набор документов xmlpipe2.
* `sphinx:schema` — необязательный элемент, должен либо быть самым первым дочерним элементом sphinx:docset, либо отсутствовать вовсе. Объявляет схему документа и содержит объявления полей и атрибутов. Если присутствует, переопределяет настройки источника из конфигурационного файла.
* `sphinx:field` — необязательный элемент, дочерний для sphinx:schema. Объявляет полнотекстовое поле. Известные атрибуты:
    * "name" — задаёт имя XML-элемента, который будет рассматриваться как полнотекстовое поле в последующих документах.
    * "attr" — указывает, индексировать ли это поле также как строку. Возможное значение — "string".
* `sphinx:attr` — необязательный элемент, дочерний для sphinx:schema. Объявляет атрибут. Известные атрибуты:
    * "name" — задаёт имя элемента, который должен рассматриваться как атрибут в последующих документах.
    * "type" — задаёт тип атрибута. Возможные значения: "int", "bigint", "timestamp", "bool", "float", "multi" и "json".
    * "bits" — задаёт размер в битах для атрибута типа "int". Допустимые значения — от 1 до 32.
    * "default" — задаёт значение по умолчанию для этого атрибута, которое будет использоваться, если элемент атрибута отсутствует в документе.
* `sphinx:document` — обязательный элемент, должен быть дочерним для sphinx:docset. Содержит произвольные другие элементы с значениями полей и атрибутов для индексирования, объявленных либо с помощью элементов sphinx:field и sphinx:attr, либо в конфигурационном файле. Единственный известный атрибут — "id", который должен содержать уникальный целочисленный идентификатор документа.
* `sphinx:killlist` — необязательный элемент, дочерний для sphinx:docset. Содержит несколько элементов "id", содержимое которых — идентификаторы документов, которые должны быть помещены в kill-лист таблицы. Kill-лист используется в поисках по нескольким таблицам для подавления документов, найденных в других таблицах поиска.

## Определение данных в конфигурации источника

Если XML не определяет схему, типы данных элементов таблиц должны быть определены в конфигурации источника.

* `xmlpipe_field` — объявляет поле типа `text`.
* `xmlpipe_field_string` — объявляет текстовое поле/строковый атрибут. Колонка будет индексироваться как текстовое поле и одновременно храниться как строковый атрибут.
* `xmlpipe_attr_uint` — объявляет целочисленный атрибут
* `xmlpipe_attr_timestamp` — объявляет атрибут временной метки
* `xmlpipe_attr_bool` — объявляет булев атрибут
* `xmlpipe_attr_float` — объявляет атрибут с плавающей точкой
* `xmlpipe_attr_bigint` — объявляет атрибут большого целого числа
* `xmlpipe_attr_multi` — объявляет мульти-значный атрибут с целыми числами
* `xmlpipe_attr_multi_64` — объявляет мульти-значный атрибут с 64-битными целыми числами
* `xmlpipe_attr_string` — объявляет строковый атрибут
* `xmlpipe_attr_json` — объявляет JSON-атрибут

### Специфические настройки XML-источника

Если установлено `xmlpipe_fixup_utf8`, будет включена проверка и фильтрация UTF-8 на стороне Manticore, чтобы предотвратить сбои XML-парсера при обработке документов, не являющихся UTF-8. По умолчанию эта опция отключена.

В определённых случаях может быть сложно или даже невозможно гарантировать, что входящие тела документов XMLpipe2 имеют идеально корректное и соответствующее кодирование UTF-8. Например, в поток могут попасть документы с национальными однобайтовыми кодировками. XML-парсер libexpat является хрупким, что означает, что он прекратит обработку в таких случаях. Функция исправления UTF8 позволяет избежать этого. Когда исправление включено, Manticore будет предварительно обрабатывать входящий поток перед передачей его XML-парсеру и заменять некорректные последовательности UTF-8 пробелами.

```ini
xmlpipe_fixup_utf8 = 1
```

Пример XML-источника без схемы в конфигурации:

```ini
source xml_test_1
{
    type = xmlpipe2
    xmlpipe_command = cat /tmp/products_today.xml
}
```

Пример XML-источника со схемой в конфигурации:

```ini
source xml_test_2
{
    type = xmlpipe2
    xmlpipe_command = cat /tmp/products_today.xml
    xmlpipe_field = subject
    xmlpipe_field = content
    xmlpipe_attr_timestamp = published
    xmlpipe_attr_uint = author_id:16
}
```
<!-- proofread -->

