# Извлечение из XML потоков

Тип источника `xmlpipe2` позволяет передавать индивидуальные данные полной обработки и атрибуты в Manticore в настраиваемом XML формате, с указанной схемой (т.е. набором полей и атрибутов), которая определена либо в самом XML потоке, либо в настройках источника.

## Объявление XML потока
Чтобы объявить XML поток, директива `xmlpipe_command` является обязательной и содержит команду оболочки, которая создает XML поток для индексирования. Это может быть файл, но также это может быть программа, генерирующая XML содержимое в режиме реального времени.

## Формат XML файла

При индексировании источника xmlpipe2 индексатор выполняет указанную команду, открывает канал для ее stdout и ожидает правильно сформированный XML поток. 

Вот пример того, как могут выглядеть данные XML потока:

```xml
<?xml version="1.0" encoding="utf-8"?>
<sphinx:docset>

<sphinx:schema>
<sphinx:field name="subject"/>
<sphinx:field name="content"/>
<sphinx:attr name="published" type="timestamp"/>
<sphinx:attr name="author_id" type="int" bits="16" default="1"/>
</sphinx:schema>

<sphinx:document id="1234">
<content>это главное содержимое <![CDATA[и этот <cdata> элемент
должен обрабатываться правильно библиотекой xml парсера]]></content>
<published>1012325463</published>
<subject>обратите внимание, как теги поля/атрибута могут быть
в <b> class="red">случайном</b> порядке</subject>
<misc>некоторый недекларированный элемент</misc>
</sphinx:document>

<sphinx:document id="1235">
<subject>другой предмет</subject>
<content>вот приходит другой документ, и мне доводится понимать,
что порядок полей в документе не имеет значения, сэр</content>
<published>1012325467</published>
</sphinx:document>

<!-- ... еще больше записей sphinx:document здесь ... -->

<sphinx:killlist>
<id>1234</id>
<id>4567</id>
</sphinx:killlist>

</sphinx:docset>
```

Произвольные поля и атрибуты разрешены. Они также могут встречаться в потоке в произвольном порядке в каждом документе; порядок игнорируется. Существует ограничение на максимальную длину поля; поля длиной более 2 МБ будут усечены до 2 МБ (это ограничение может быть изменено в источнике).

Схема, т.е. полный список полей и атрибутов, должна быть объявлена перед тем, как может быть разобран любой документ. Это можно сделать либо в конфигурационном файле, используя настройки `xmlpipe_field` и `xmlpipe_attr_XXX`, либо прямо в потоке, используя элемент `<sphinx:schema>`. `<sphinx:schema>` является необязательным. Он может встречаться только как первый подэлемент в `<sphinx:docset>`. Если в потоке нет определения схемы, будут использованы настройки из конфигурационного файла. В противном случае настройки потока имеют приоритет. Обратите внимание, что идентификатор документа должен быть указан как свойство `id` тега `<sphinx:document>` (например, `<sphinx:document id="1235">`) и предполагается, что он является уникальным положительным 64-битным целым числом, не равным нулю.

Неизвестные теги (которые не были объявлены ни как поля, ни как атрибуты) будут проигнорированы с предупреждением. В приведенном выше примере тег `<misc>` будет проигнорирован. Все встроенные теги и их атрибуты (такие как `<strong>` в `<subject>` в приведенном выше примере) будут тихо проигнорированы.

Поддержка входящих кодировок потока зависит от того, установлена ли `iconv` на системе. xmlpipe2 разбирается с использованием парсера `libexpat`, который нативно понимает US-ASCII, ISO-8859-1, UTF-8 и несколько вариантов UTF-16. Скрипт `configure` Manticore также проверит наличие `libiconv` и использует его для обработки других кодировок. `libexpat` также накладывает требование использовать кодировку UTF-8 на стороне Manticore, поскольку разобранные данные, которые он возвращает, всегда находятся в UTF-8.

Элементы XML (теги), распознаваемые xmlpipe2 (и их атрибуты, где это уместно), это:

* `sphinx:docset` - Обязательный верхний элемент, обозначает и содержит набор документов xmlpipe2.
* `sphinx:schema` -  Необязательный элемент, должен встречаться либо как самый первый дочерний элемент sphinx:docset, либо не встречаться вообще. Объявляет схему документа и содержит декларации полей и атрибутов. Если присутствует, он переопределяет настройки по умолчанию из конфигурационного файла.
* `sphinx:field` - Необязательный элемент, дочерний элемент sphinx:schema. Объявляет поле полного текста. Известные атрибуты:
    *   "name", указывает имя XML элемента, который будет рассматриваться как поле полного текста в последующих документах.
    *   "attr", указывает, следует ли также индексировать это поле как строку. Возможное значение: "string".
* `sphinx:attr` - Необязательный элемент, дочерний элемент sphinx:schema. Объявляет атрибут. Известные атрибуты:
    *   "name", указывает имя элемента, который должен рассматриваться как атрибут в последующих документах.
    *   "type", указывает тип атрибута. Возможные значения: "int", "bigint", "timestamp", "bool", "float", "multi" и "json".
    *   "bits", указывает размер в битах для типа атрибута "int". Допустимые значения: от 1 до 32.
    *   "default", указывает значение по умолчанию для этого атрибута, которое должно использоваться, если элемент атрибута отсутствует в документе.
* `sphinx:document` - Обязательный элемент, должен быть дочерним элементом sphinx:docset. Содержит произвольные другие элементы с полями и значениями атрибутов для индексирования, как было объявлено либо с использованием элементов sphinx:field и sphinx:attr, либо в конфигурационном файле. Единственный известный атрибут - "id", который должен содержать уникальный идентификатор документа в виде целого числа.
* `sphinx:killlist` - Необязательный элемент, дочерний элемент sphinx:docset. Содержит ряд элементов "id", содержимое которых является идентификаторами документов, которые должны быть помещены в список на уничтожение таблицы. Список уничтожения используется в многостолбцовых поисках для подавления документов, найденных в других таблицах поиска.

## Определение данных в конфигурации источника

Если XML не определяет схему, типы данных элементов таблиц должны быть определены в конфигурации источника.

* `xmlpipe_field` -  объявляет поле `text`.
* `xmlpipe_field_string` - объявляет текстовое поле/строковый атрибут. Столбец будет индексироваться как текстовое поле, а также храниться как строковый атрибут.
* `xmlpipe_attr_uint` - объявляет атрибут целого числа
* `xmlpipe_attr_timestamp` - объявляет атрибут временной метки
* `xmlpipe_attr_bool` -  объявляет булев атрибут
* `xmlpipe_attr_float` - объявляет атрибут с плавающей запятой
* `xmlpipe_attr_bigint` - объявляет атрибут большого целого числа
* `xmlpipe_attr_multi` - объявляет многофункциональный атрибут с целыми числами
* `xmlpipe_attr_multi_64` - объявляет многофункциональный атрибут с 64-битными целыми числами
* `xmlpipe_attr_string` - объявляет строковый атрибут
* `xmlpipe_attr_json` - объявляет атрибут JSON

### Специфические настройки XML-источника

Если `xmlpipe_fixup_utf8` установлено, это позволит включить проверку и фильтрацию UTF-8 на стороне Manticore, чтобы предотвратить сбой XML парсера при работе с документами не в UTF-8. По умолчанию эта опция отключена.

В определенных случаях может быть сложно или даже невозможно гарантировать, что входные тела документов XMLpipe2 находятся в совершенно действительном и соответствующем кодировке UTF-8. Например, документы с национальными однобайтовыми кодировками могут попасть в поток. Парсер XML libexpat хрупок, что означает, что он остановит обработку в таких случаях. Функция исправления UTF8 позволяет избежать этого. Когда исправление включено, Manticore будет предобрабатывать входной поток перед передачей его парсеру XML и заменять недопустимые последовательности UTF-8 на пробелы.

```ini
xmlpipe_fixup_utf8 = 1
```

Пример XML-источника без схемы в конфигурации:

```ini
source xml_test_1
{
    type = xmlpipe2
    xmlpipe_command = cat /tmp/products_today.xml
}
```

Пример XML-источника со схемой в конфигурации:

```ini
source xml_test_2
{
    type = xmlpipe2
    xmlpipe_command = cat /tmp/products_today.xml
    xmlpipe_field = subject
    xmlpipe_field = content
    xmlpipe_attr_timestamp = published
    xmlpipe_attr_uint = author_id:16
}
```
<!-- proofread -->
