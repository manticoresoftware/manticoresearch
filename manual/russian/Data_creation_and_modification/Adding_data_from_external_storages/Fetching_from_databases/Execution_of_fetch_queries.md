# Выполнение запросов fetch

Со всеми SQL-драйверами построение обычной таблицы обычно работает следующим образом.

* Устанавливается соединение с базой данных.
* Выполняются запросы `sql_query_pre_all` для выполнения необходимой начальной настройки, такой как установка кодировки для каждого соединения в MySQL. Эти запросы выполняются перед всем процессом индексирования, а также после переподключения при индексировании атрибутов MVA и объединённых полей.
* Выполняется предварительный запрос `sql_query_pre` для выполнения необходимой начальной настройки, такой как настройка временных таблиц или поддержание таблиц счётчиков. Эти запросы выполняются один раз для всего процесса индексирования.
* Предварительные запросы, такие как `sql_query_pre`, выполняются для выполнения необходимой начальной настройки, такой как настройка временных
  таблиц или поддержание таблиц счётчиков. Эти запросы выполняются один раз для всего индексирования.
* Выполняется основной запрос `sql_query`, и обрабатываются возвращаемые им строки.
* Выполняется пост-запрос `sql_query_post` для выполнения некоторых необходимых действий по очистке.
* Соединение с базой данных закрывается.
* Индексатор выполняет фазу сортировки (если быть педантичным, специфическую для типа таблицы пост-обработку).
* Соединение с базой данных устанавливается снова.
* Выполняется запрос для пост-обработки `sql_query_post_index` для выполнения окончательной очистки.
* Соединение с базой данных снова закрывается.

Пример источника, получающего данные из MYSQL:

```ini
source mysource {
  type             = mysql
  path             = /path/to/realtime
  sql_host         = localhost
  sql_user         = myuser
  sql_pass         = mypass
  sql_db           = mydb
  sql_query_pre    = SET CHARACTER_SET_RESULTS=utf8
  sql_query_pre    = SET NAMES utf8
  sql_query        =  SELECT id, title, description, category_id  FROM mytable
  sql_query_post   = DROP TABLE view_table
  sql_query_post_index = REPLACE INTO counters ( id, val ) \
    VALUES ( 'max_indexed_id', $maxid )
  sql_attr_uint    = category_id
  sql_field_string = title
 }

table mytable {
  type   = plain
  source = mysource
  path   = /path/to/mytable
  ...
 }
```

## sql_query

Это запрос, используемый для извлечения документов из SQL-сервера. Может быть объявлен только один sql_query, и он обязателен. См. также [Обработка полученных данных](../../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Processing_fetched_data.md#Processing-fetched-data)

## sql_query_pre

Предварительный запрос или pre-запрос. Это множественная, необязательная настройка, по умолчанию — пустой список запросов. Предварительные запросы выполняются перед sql_query в порядке их появления в конфигурационном файле. Результаты предварительных запросов игнорируются.

Предварительные запросы полезны во многих случаях. Их можно использовать для установки кодировки, пометки записей, которые будут индексироваться, обновления внутренних счётчиков, установки различных параметров и переменных SQL-сервера для каждого соединения и т.д.

Возможно, самым частым применением предварительного запроса является указание кодировки, которую сервер будет использовать для возвращаемых строк. Отметим, что Manticore принимает только текст в кодировке UTF-8. Два специфичных для MySQL примера установки кодировки:

```ini
sql_query_pre = SET CHARACTER_SET_RESULTS=utf8
sql_query_pre = SET NAMES utf8
```

Также, специфично для источников MySQL, полезно в предзапросе отключить кэширование запросов (только для соединения индексатора), потому что запросы индексирования всё равно не будут часто повторяться, и нет смысла кэшировать их результаты.
Это можно сделать с помощью:

```ini
sql_query_pre = SET SESSION query_cache_type=OFF
```

## sql_query_post

Пост-запрос после выборки. Это необязательная настройка, значение по умолчанию — пусто.

Этот запрос выполняется сразу после успешного завершения sql_query. Если пост-запрос вызывает ошибки, они регистрируются как предупреждения, но индексирование не прекращается. Его результирующий набор игнорируется. Обратите внимание, что индексирование еще не завершено в момент выполнения этого запроса, и дальнейшее индексирование всё ещё может завершиться неудачей. Поэтому постоянные обновления не должны выполняться здесь. Например, обновления в вспомогательной таблице, которые постоянно изменяют последний успешно проиндексированный ID, не должны запускаться из `sql_query_post`; вместо этого их следует выполнять из `sql_query_post_index`.

## sql_query_post_index

Запрос для пост-обработки. Это необязательная настройка, значение по умолчанию — пусто.

Этот запрос выполняется, когда индексирование полностью и успешно завершено. Если он вызывает ошибки, они регистрируются как предупреждения, но индексирование не прекращается. Его результирующий набор игнорируется. В тексте запроса можно использовать макрос `$maxid`; он будет развернут до максимального ID документа, который был фактически извлечён из базы данных во время индексирования. Если документы не индексировались, `$maxid` будет развернут в 0.

Пример:
```ini
sql_query_post_index = REPLACE INTO counters ( id, val ) \
    VALUES ( 'max_indexed_id', $maxid )
```

Разница между `sql_query_post` и `sql_query_post_index` в том, что `sql_query_post` выполняется сразу, когда Manticore получает все документы, но дальнейшее индексирование всё ещё может завершиться неудачей по другой причине. Напротив, когда выполняется `sql_query_post_index`, гарантируется, что таблица была успешно создана. Подключение к базе данных разрывается и устанавливается заново, потому что фаза сортировки может занять очень много времени и в противном случае привела бы к тайм-ауту.

<!-- proofread -->

