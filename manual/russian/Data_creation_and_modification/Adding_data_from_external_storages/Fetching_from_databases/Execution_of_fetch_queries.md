# Выполнение запросов выборки

Со всеми SQL-драйверами построение простой таблицы обычно происходит следующим образом.

* Устанавливается соединение с базой данных.
* Выполняются запросы `sql_query_pre_all` для выполнения необходимой начальной настройки, например, установки кодировки на соединение в MySQL. Эти запросы выполняются перед всем процессом индексирования, а также после переподключения для индексирования атрибутов MVA и объединённых полей.
* Выполняется предварительный запрос `sql_query_pre` для выполнения необходимой начальной настройки, например, создания временных таблиц или поддержки таблиц счётчиков. Эти запросы выполняются один раз за весь процесс индексирования.
* Предварительные запросы, такие как `sql_query_pre`, выполняются для выполнения необходимой начальной настройки, например, создания временных
  таблиц или поддержки таблиц счётчиков. Эти запросы выполняются один раз за весь процесс индексирования.
* Выполняется основной запрос `sql_query`, и обрабатываются возвращённые им строки.
* Выполняется пост-запрос `sql_query_post` для выполнения необходимой очистки.
* Соединение с базой данных закрывается.
* Индексатор выполняет фазу сортировки (если быть точным, специфическую для типа таблицы постобработку).
* Соединение с базой данных устанавливается снова.
* Выполняется запрос постобработки `sql_query_post_index` для выполнения необходимой финальной очистки.
* Соединение с базой данных закрывается снова.

Пример источника, извлекающего данные из MYSQL:

```ini
source mysource {
  type             = mysql
  path             = /path/to/realtime
  sql_host         = localhost
  sql_user         = myuser
  sql_pass         = mypass
  sql_db           = mydb
  sql_query_pre    = SET CHARACTER_SET_RESULTS=utf8
  sql_query_pre    = SET NAMES utf8
  sql_query        =  SELECT id, title, description, category_id  FROM mytable
  sql_query_post   = DROP TABLE view_table
  sql_query_post_index = REPLACE INTO counters ( id, val ) \
    VALUES ( 'max_indexed_id', $maxid )
  sql_attr_uint    = category_id
  sql_field_string = title
 }

table mytable {
  type   = plain
  source = mysource
  path   = /path/to/mytable
  ...
 }
```

## sql_query

Это запрос, используемый для извлечения документов с SQL-сервера. Может быть объявлен только один sql_query, и он обязателен. См. также [Обработка извлечённых данных](../../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Processing_fetched_data.md#Processing-fetched-data)

## sql_query_pre

Предварительный запрос выборки или предзапрос. Это многозначная, необязательная настройка, по умолчанию — пустой список запросов. Предварительные запросы выполняются перед sql_query в порядке их появления в конфигурационном файле. Результаты предварительных запросов игнорируются.

Предварительные запросы полезны во многих случаях. Их можно использовать для установки кодировки, пометки записей, которые будут индексироваться, обновления внутренних счётчиков, установки различных опций и переменных SQL-сервера на соединение и так далее.

Возможно, наиболее частое использование предзапроса — указание кодировки, которую сервер будет использовать для возвращаемых строк. Обратите внимание, что Manticore принимает только текст в UTF-8. Два специфичных для MySQL примера установки кодировки:

```ini
sql_query_pre = SET CHARACTER_SET_RESULTS=utf8
sql_query_pre = SET NAMES utf8
```

Также, специфично для источников MySQL, полезно отключить кэш запросов (только для соединения индексатора) в предзапросе, потому что индексирующие запросы всё равно не будут часто повторяться, и нет смысла кэшировать их результаты.
Это можно сделать так:

```ini
sql_query_pre = SET SESSION query_cache_type=OFF
```

## sql_query_post

Пост-запрос выборки. Это необязательная настройка, по умолчанию пустая.

Этот запрос выполняется сразу после успешного завершения sql_query. Если пост-запрос выборки вызывает ошибки, они регистрируются как предупреждения, но индексирование не прерывается. Его результирующий набор игнорируется. Обратите внимание, что индексирование ещё не завершено в момент выполнения этого запроса, и дальнейшее индексирование может завершиться неудачей. Поэтому любые постоянные обновления не должны выполняться здесь. Например, обновления вспомогательной таблицы, которые навсегда изменяют последний успешно проиндексированный ID, не должны выполняться из запроса `sql_query_post`; их следует выполнять из запроса `sql_query_post_index`.

## sql_query_post_index

Запрос постобработки. Это необязательная настройка, по умолчанию пустая.

Этот запрос выполняется, когда индексирование полностью и успешно завершено. Если этот запрос вызывает ошибки, они регистрируются как предупреждения, но индексирование не прерывается. Его результирующий набор игнорируется. В его тексте можно использовать макрос `$maxid`; он будет заменён на максимальный ID документа, фактически извлечённого из базы данных во время индексирования. Если документы не были проиндексированы, `$maxid` будет заменён на 0.

Пример:
```ini
sql_query_post_index = REPLACE INTO counters ( id, val ) \
    VALUES ( 'max_indexed_id', $maxid )
```

Разница между `sql_query_post` и `sql_query_post_index` в том, что `sql_query_post` выполняется сразу, когда Manticore получает все документы, но дальнейшее индексирование всё ещё может завершиться неудачей по другой причине. Напротив, к моменту выполнения запроса `sql_query_post_index` гарантируется, что таблица была успешно создана. Соединение с базой данных разрывается и устанавливается заново, потому что фаза сортировки может быть очень длительной и в противном случае просто прервётся по таймауту.

<!-- proofread -->

