# Выполнение запросов выборки

При использовании всех SQL-драйверов создание простой таблицы обычно происходит следующим образом.

* Устанавливается соединение с базой данных.
* Запускаются запросы `sql_query_pre_all` для выполнения необходимой начальной настройки, например, установки кодировки для каждого соединения в MySQL. Эти запросы выполняются до начала процесса индексирования, а также после переподключения для индексирования MVA-атрибутов и объединённых полей.
* Выполняется предварительный запрос `sql_query_pre` для выполнения необходимой начальной настройки, такой как создание временных таблиц или обслуживание таблиц счетчиков. Эти запросы выполняются один раз за весь процесс индексирования.
* Предварительные запросы, такие как `sql_query_pre`, выполняются для осуществления необходимой начальной настройки, например, создания временных
  таблиц или обслуживания счетной таблицы. Эти запросы выполняются один раз за весь процесс индексирования.
* Выполняется основной запрос `sql_query`, и возвращаемые им строки обрабатываются.
* Выполняется пост-запрос `sql_query_post` для проведения необходимой очистки.
* Соединение с базой данных закрывается.
* Индексатор выполняет фазу сортировки (если быть точным, специфическую для типа таблицы пост-обработку).
* Соединение с базой данных устанавливается снова.
* Выполняется запрос пост-обработки `sql_query_post_index` для проведения необходимой окончательной очистки.
* Соединение с базой данных снова закрывается.

Пример источника, получающего данные из MYSQL:

```ini
source mysource {
  type             = mysql
  path             = /path/to/realtime
  sql_host         = localhost
  sql_user         = myuser
  sql_pass         = mypass
  sql_db           = mydb
  sql_query_pre    = SET CHARACTER_SET_RESULTS=utf8
  sql_query_pre    = SET NAMES utf8
  sql_query        =  SELECT id, title, description, category_id  FROM mytable
  sql_query_post   = DROP TABLE view_table
  sql_query_post_index = REPLACE INTO counters ( id, val ) \
    VALUES ( 'max_indexed_id', $maxid )
  sql_attr_uint    = category_id
  sql_field_string = title
 }

table mytable {
  type   = plain
  source = mysource
  path   = /path/to/mytable
  ...
 }
```

## sql_query

Это запрос, используемый для извлечения документов из SQL-сервера. Может быть объявлен только один sql_query, и его наличие является обязательным. См. также [Обработка полученных данных](../../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Processing_fetched_data.md#Processing-fetched-data)

## sql_query_pre

Предварительный запрос выборки или предварительный запрос. Это параметр с множественными значениями, необязательный, по умолчанию представляющий собой пустой список запросов. Предварительные запросы выполняются перед sql_query в том порядке, в котором они указаны в файле конфигурации. Результаты предварительных запросов игнорируются.

Предварительные запросы полезны во многих отношениях. Их можно использовать для задания кодировки, пометки записей, которые будут индексироваться, обновления внутренних счетчиков, настройки различных параметров и переменных SQL-сервера для каждого соединения и т.д.

Возможно, наиболее частое использование предварительного запроса — указание кодировки, которую сервер будет использовать для возвращаемых строк. Обратите внимание, что Manticore принимает только текст в кодировке UTF-8. Два специфичных для MySQL примера установки кодировки:

```ini
sql_query_pre = SET CHARACTER_SET_RESULTS=utf8
sql_query_pre = SET NAMES utf8
```

Кроме того, для источников MySQL полезно отключить кэш запросов (только для соединения индексатора) в предварительном запросе, поскольку запросы индексирования все равно не будут часто повторяться, и нет смысла кэшировать их результаты.
Это можно сделать следующим образом:

```ini
sql_query_pre = SET SESSION query_cache_type=OFF
```

## sql_query_post

Запрос после выборки. Это необязательный параметр, со значением по умолчанию пустой.

Этот запрос выполняется сразу после успешного завершения sql_query. Если запрос после выборки вызывает ошибки, они регистрируются как предупреждения, но индексирование не прерывается. Его результирующий набор данных игнорируется. Обратите внимание, что индексирование на момент его выполнения еще не завершено, и последующее индексирование может завершиться с ошибкой. Поэтому любые постоянные обновления здесь не выполняются. Например, обновления в вспомогательной таблице, которые постоянно изменяют последний успешно проиндексированный идентификатор, не должны выполняться через запрос `sql_query_post`; их следует выполнять через запрос `sql_query_post_index`.

## sql_query_post_index

Запрос пост-обработки. Это необязательный параметр, по умолчанию пустой.

Этот запрос выполняется, когда индексирование полностью и успешно завершено. Если этот запрос вызывает ошибки, они регистрируются как предупреждения, но индексирование не прерывается. Его результирующий набор данных игнорируется. В его текст можно включать макрос `$maxid`; он будет заменён на максимальный идентификатор документа, который фактически был получен из базы данных во время индексирования. Если документов не было проиндексировано, `$maxid` будет заменён на 0.

Пример:
```ini
sql_query_post_index = REPLACE INTO counters ( id, val ) \
    VALUES ( 'max_indexed_id', $maxid )
```

Разница между `sql_query_post` и `sql_query_post_index` заключается в том, что `sql_query_post` выполняется сразу после того, как Manticore получает все документы, но дальнейшее индексирование может всё ещё завершиться с ошибкой по другой причине. Напротив, к моменту выполнения запроса `sql_query_post_index` гарантировано, что таблица была успешно создана. Соединение с базой данных разрывается и устанавливается заново, поскольку фаза сортировки может быть очень длительной и в противном случае произойдет тайм-аут.

<!-- proofread -->
