# Обработка полученных данных

По умолчанию первый столбец выборки `sql_query` индексируется как идентификатор документа.

Идентификатор документа *ДОЛЖЕН* быть самым первым полем, и он **ДОЛЖЕН БЫТЬ** УНИКАЛЬНЫМ ЗНАКОВЫМ (НЕ НУЛЕВЫМ) ЦЕЛЫМ ЧИСЛОМ от -9223372036854775808 до 9223372036854775807.

Вы можете указать до 256 полнотекстовых полей и произвольное количество атрибутов. Все столбцы, которые не являются идентификатором документа (первым) или атрибутами, будут индексированы как полнотекстовые поля.


## Объявление атрибутов:

### sql_attr_bigint

Объявляет 64-битное *знаковое* целое число.

### sql_attr_bool

Объявляет булев атрибут. Эквивалентен целочисленному атрибуту с битовой длиной 1.

### sql_attr_float

Объявляет числовой атрибут с плавающей точкой.

Значения будут храниться в одинарной точности, формате IEEE 754 с 32 битами. Представляемый диапазон примерно от 1e-38 до 1e+38. Количество значимых десятичных цифр, которое может храниться точно, примерно 7.

Одно из важных применений числовых атрибутов — хранение значений широты и долготы (в радианах) для последующих вычислений расстояний на сфере во время выполнения запросов.

### sql_attr_json

Объявляет JSON-атрибут.

При индексировании JSON-атрибутов Manticore ожидает текстовое поле с данными в формате JSON. JSON-атрибуты поддерживают произвольные JSON-данные без ограничений по уровню вложенности или типам.

### sql_attr_multi

Объявляет атрибут с множественными значениями.

Простые атрибуты позволяют прикреплять лишь 1 значение для каждого документа. Однако бывают случаи (например, теги или категории), когда нужно прикреплять несколько значений одного атрибута и иметь возможность фильтровать или группировать по спискам значений.

MVA может получать значения из колонки (как и все остальные типы данных) — в этом случае столбец результата должен содержать строку с несколькими целочисленными значениями, разделёнными запятыми — или путем выполнения отдельного запроса для получения значений.

При выполнении запроса движок выполняет запрос, группирует результаты по ID и присваивает значения соответствующим документам в таблице. Значения с ID, не найденным в таблице, отбрасываются. Перед выполнением запроса будут выполнены все определённые `sql_query_pre_all`.

Формат объявления sql_attr_multi следующий:

```ini
sql_attr_multi = ATTR-TYPE ATTR-NAME 'from' SOURCE-TYPE \
    [;QUERY] \
    [;RANGED-QUERY]
```

где

* ATTR-TYPE — это `uint`, `bigint` или `timestamp`.
* SOURCE-TYPE — это `field`, `query`, `ranged-query` или `ranged-main-query`.
* QUERY — необязательный SQL-запрос для получения всех пар (docid, attrvalue).
* RANGED-QUERY — необязательный SQL-запрос для получения минимальных и максимальных значений ID, аналогично `sql_query_range`.
* Обратные слэши добавлены для ясности; весь код можно объявить в одной строке.

Используется с типом SOURCE-TYPE ranged-query. При использовании SOURCE-TYPE `ranged-main-query` оставьте RANGED-QUERY пустым — тогда автоматически будет использоваться тот же запрос из `sql_query_range` (удобный вариант в сложных наслоениях для избежания многократного копирования одного и того же запроса).

```ini
sql_attr_multi = uint tag from field
sql_attr_multi = uint tag from query; SELECT id, tag FROM tags
sql_attr_multi = bigint tag from ranged-query; \
    SELECT id, tag FROM tags WHERE id>=$start AND id<=$end; \
    SELECT MIN(id), MAX(id) FROM tags
```

### sql_attr_string

Объявляет строковый атрибут. Максимальный размер каждого значения фиксирован и составляет 4 ГБ.

### sql_attr_timestamp

Объявляет UNIX timestamp.

Таймстампы могут хранить даты и время в диапазоне с 1 января 1970 года по 19 января 2038 года с точностью в одну секунду. Ожидаемое значение колонки — timestamp в формате UNIX, 32-битное беззнаковое целое количество секунд с полуночи 1 января 1970 года по GMT. Внутри таймстампы хранятся и обрабатываются как целые числа. Помимо обработки таймстампов как целочисленных значений, их можно использовать с различными функциями на основе даты, такими как режим сортировки по сегментам времени или извлечение дня/недели/месяца/года для GROUP BY.

Обратите внимание, что типы колонок DATE или DATETIME в MySQL не могут напрямую использоваться как атрибуты timestamp в Manticore; необходимо явно преобразовывать их с помощью функции UNIX_TIMESTAMP (если данные в диапазоне).

Учтите, что таймстампы не могут представлять даты до 1 января 1970 года, и UNIX_TIMESTAMP() в MySQL вернет некорректное значение. Если нужно работать только с датами без времени, рассмотрите использование функции `TO_DAYS()` в MySQL.


### sql_attr_uint

Объявляет беззнаковый целочисленный атрибут.

Можно задать количество бит для целочисленных атрибутов, добавив к имени атрибута `:BITCOUNT` (см. пример ниже). Атрибуты с размером меньше стандартных 32 бит или битовые поля работают медленнее.

```ini
sql_attr_uint = group_id
sql_attr_uint = forum_id:9 # 9 bits for forum_id
```

### sql_field_string

Объявляет комбинированный строковый атрибут/полнотекстовое поле. Значения будут индексироваться как полнотекстовое поле, а также храниться как строковый атрибут с тем же именем. Обратите внимание: это следует использовать только если вы уверены, что хотите, чтобы поле было доступно как полнотекстовый поиск и как атрибут с возможностью сортировки и группировки. Если вы просто хотите получить исходное значение поля, ничего делать не нужно, кроме как если вы явно не убрали поле из списка сохранённых полей через [stored_fields](../../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#stored_fields).

```ini
sql_field_string = name
```

### sql_file_field

Объявляет файловое поле.

Эта директива заставляет индексатор воспринимать содержимое поля как имя файла и загружать и обрабатывать указанный файл. Файлы, размер которых превышает max_file_field_buffer, пропускаются. Все ошибки при загрузке файла (ошибки ввода-вывода, превышение лимитов и т. п.) будут зарегистрированы как предупреждения индексации и не приведут к досрочному завершению индексации. Для таких файлов содержимое не будет проиндексировано.

```ini
sql_file_field = field_name
```

### sql_joined_field

Запрос для объединённого/пэйлоад поля. Множественные значения, опциональный, по умолчанию — пустой список запросов.

`sql_joined_field` позволяет использовать две различные функции: объединённые поля и пэйлоады (payload-поля). Его синтаксис следующий:

```ini
sql_joined_field = FIELD-NAME 'from'  ( 'query' | 'payload-query' | 'ranged-query' | 'ranged-main-query' ); \
		QUERY [ ; RANGE-QUERY ]
```

где

* FIELD-NAME — имя объединённого/пэйлоад поля
* QUERY — SQL-запрос, который должен получить значения для дальнейшей обработки
* RANGE-QUERY — необязательный SQL-запрос, который получает диапазон значений для обработки

**Объединённые поля** позволяют избежать использования операторов JOIN и/или GROUP_CONCAT в основном запросе на получение документа (sql_query). Это может быть полезно, когда соединение на стороне SQL работает медленно, или его требуется выполнить на стороне Manticore, или просто для имитации специфичной для MySQL функциональности `GROUP_CONCAT`, если ваш сервер базы данных её не поддерживает.

Запрос должен возвращать ровно 2 столбца: ID документа и текст, который нужно добавить в объединённое поле. ID документов могут повторяться, но они должны быть упорядочены по возрастанию. Все текстовые строки, полученные для данного ID, будут конкатенированы вместе, и результат конкатенации будет индексироваться как полное содержимое объединённого поля. Строки будут конкатенированы в том порядке, в каком они возвращаются запросом, между ними будет вставлен разделяющий пробел. Например, если запрос для объединённого поля возвращает следующие строки:
```ini
( 1, 'red' )
( 1, 'right' )
( 1, 'hand' )
( 2, 'mysql' )
( 2, 'manticore' )
```

то результаты индексации будут эквивалентны добавлению нового текстового поля со значением 'red right hand' к документу 1 и 'mysql sphinx' к документу 2, включая позиции ключевых слов внутри поля в порядке их получения из запроса. Если строки должны находиться в определённом порядке, это нужно явно указать в запросе.

Объединённые поля индексируются только по-другому. Других отличий между объединёнными полями и обычными текстовыми полями нет.

Перед выполнением запроса для объединённых полей запускается любой набор `sql_query_pre_all`, если он существует. Это позволяет установить нужную кодировку и другие параметры в контексте объединённых полей.

Если один запрос недостаточно эффективен или не работает из-за ограничений драйвера базы данных, можно использовать диапазонные запросы. Это работает аналогично диапазонным запросам в основном цикле индексации. Диапазон запрашивается и извлекается заранее один раз, затем выполняются несколько запросов с разными подстановками `$start` и `$end`, чтобы получить фактические данные.

При использовании запроса `ranged-main-query` опускается `ranged-query`, и автоматически используется тот же запрос из `sql_query_range` (полезная опция в сложных схемах наследования, чтобы не повторять одни и те же запросы многократно вручную).

<!-- example payload -->
**Пэйлоуды** позволяют создать специальное поле, в котором вместо позиций ключевых слов хранятся так называемые пользовательские пэйлоуды. Пэйлоуды — это специальные целочисленные значения, связанные с каждым ключевым словом. Затем они могут использоваться во время поиска для влияния на ранжирование.

Запрос на получение пэйлоудов должен возвращать ровно 3 столбца:
- ID документа
- ключевое слово
- и целочисленное значение пэйлоуда.

ID документов могут повторяться, но должны быть упорядочены по возрастанию. Пэйлоуды **должны** быть беззнаковыми целыми числами в диапазоне 24 бит, то есть от 0 до 16777215.

Единственный ранжировщик, учитывающий пэйлоуды — `proximity_bm25` (ранжировщик по умолчанию [ranker](../../../Searching/Sorting_and_ranking.md#Available-built-in-rankers)). В таблицах с пэйлоудными полями он автоматически переключается на вариант, который учитывает совпадения ключевых слов в этих полях, вычисляет сумму совпавших пэйлоудов, умноженную на вес поля, и добавляет эту сумму к итоговому рангу.

Обратите внимание, что поле с пэйлоудами игнорируется для полнотекстовых запросов, содержащих сложные операторы. Оно работает только для простых запросов-мешков слов.

<!-- intro -->
Пример конфигурации:
<!-- request Configuration file -->
```ini
source min {
    type = mysql
    sql_host = localhost
    sql_user = test
    sql_pass =
    sql_db = test
    sql_query = select 1, 'Nike bag' f \
    UNION select 2, 'Adidas bag' f \
    UNION select 3, 'Reebok bag' f \
    UNION select 4, 'Nike belt' f

    sql_joined_field = tag from payload-query; select 1 id, 'nike' tag, 10 weight \
    UNION select 4 id, 'nike' tag, 10 weight;
}

index idx {
    path = idx
    source = min
}
```

<!-- request Just SELECT -->
```sql
mysql> select * from idx;
+------+------------+------+
| id   | f          | tag  |
+------+------------+------+
|    1 | Nike bag   | nike |
|    2 | Adidas bag |      |
|    3 | Reebok bag |      |
|    4 | Nike belt  | nike |
+------+------------+------+
4 rows in set (0.00 sec)
```

<!-- request Full-text search -->

Обратите внимание, что при поиске по запросу `nike | adidas` результаты, содержащие слово "nike", получают больший вес за счёт тега "nike" и его веса, полученного из запроса пэйлоуда.
```sql
mysql> select *, weight() from idx where match('nike|adidas');
+------+------------+------+----------+
| id   | f          | tag  | weight() |
+------+------------+------+----------+
|    1 | Nike bag   | nike |    11539 |
|    4 | Nike belt  | nike |    11539 |
|    2 | Adidas bag |      |     1597 |
+------+------------+------+----------+
3 rows in set (0.01 sec)
```

<!-- request Complex full-text search -->

Обратите внимание, что специальное поле для пэйлоудов игнорируется для полнотекстовых запросов с комплексными операторами. Оно работает только для простых запросов-мешков слов.

```sql
mysql> select *, weight() from idx where match('"nike bag"|"adidas bag"');
+------+------------+------+----------+
| id   | f          | tag  | weight() |
+------+------------+------+----------+
|    2 | Adidas bag |      |     2565 |
|    1 | Nike bag   | nike |     2507 |
+------+------------+------+----------+
2 rows in set (0.00 sec)
```

<!-- end -->

### sql_column_buffers

```ini
sql_column_buffers = <colname>=<size>[K|M] [, ...]
```

Размеры буферов для каждого столбца. Опционально, по умолчанию пусто (размеры выводятся автоматически). Применимо только для источников типа `odbc`, `mssql`.

Драйверы ODBC и MS SQL иногда не могут вернуть максимальный реальный размер столбца, который стоит ожидать. Например, столбцы `NVARCHAR(MAX)` всегда возвращают длину 2147483647 байт для `indexer`, хотя фактическая длина, скорее всего, намного меньше. Однако при этом буферы приёма всё равно должны быть выделены заранее, и их размеры необходимо определить. Если драйвер вообще не сообщает длину столбца, Manticore выделяет буферы по умолчанию размером 1 КБ для каждого не-строкового столбца и 1 МБ для каждого строкового столбца. Также длина, сообщаемая драйвером, ограничивается верхним пределом в 8 МБ, поэтому если драйвер сообщает (почти) 2-гигабайтную длину столбца, она будет обрезана, и для этого столбца будет выделен 8 МБ буфер. Эти жёстко заданные лимиты можно переопределить с помощью директивы `sql_column_buffers`, чтобы либо сэкономить память на действительно более коротких столбцах, либо преодолеть ограничение в 8 МБ для действительно более длинных столбцов. Значения директивы должны быть списком через запятую с указанием имён столбцов и размеров:

Пример:

```ini
sql_query = SELECT id, mytitle, mycontent FROM documents
sql_column_buffers = mytitle=64K, mycontent=10M
```
<!-- proofread -->

