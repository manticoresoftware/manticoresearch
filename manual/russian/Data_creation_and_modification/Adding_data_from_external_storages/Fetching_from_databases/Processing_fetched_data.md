# Обработка полученных данных
По умолчанию первый столбец из результирующего набора `sql_query` индексируется как идентификатор документа.
Идентификатор документа *ДОЛЖЕН* быть полем с самым первым значением, и он **ДОЛЖЕН БЫТЬ** УНИКАЛЬНЫМ ЗНАКОВЫМ (НЕНУЛЕВЫМ) ЦЕЛЫМ ЧИСЛОМ от -9223372036854775808 до 9223372036854775807.
Вы можете указать до 256 полей с полнотекстовым поиском и произвольное количество атрибутов. Все столбцы, которые не являются идентификатором документа (первый) или атрибутами, будут индексироваться как полнотекстовые поля.
## Объявление атрибутов:
### sql_attr_bigint
Объявляет 64-битное *знаковое* целое число.
### sql_attr_bool
Объявляет булевый атрибут. Он эквивалентен целочисленному атрибуту с битовой длиной 1.
### sql_attr_float
Объявляет атрибут с плавающей запятой.
Значения будут храниться в однократной точности, в формате 32-битного IEEE 754. Представленный диапазон примерно от 1e-38 до 1e+38. Количество десятичных знаков, которые могут быть точно сохранены, составляет примерно 7.
Одно из важных применений атрибутов с плавающей запятой - хранение значений широты и долготы (в радианах) для дальнейшего использования в расчетах расстояния на геосфере во время запроса.
### sql_attr_json
Объявляет атрибут JSON.
При индексации атрибутов JSON Manticore ожидает текстовое поле с данными, отформатированными в JSON. Атрибуты JSON поддерживают произвольные данные JSON без ограничений на вложенные уровни или типы.
### sql_attr_multi
Объявляет атрибут с несколькими значениями.
Простые атрибуты могут содержать только 1 значение для каждого документа. Однако есть случаи (такие как теги или категории), когда необходимо прикрепить несколько значений одного и того же атрибута и иметь возможность применять фильтрацию или группировку к спискам значений.
MVA может брать значения из столбца (как и остальные типы данных) - в этом случае столбец в результирующем наборе должен предоставлять строку с несколькими целыми значениями, разделенными запятыми - или выполнять отдельный запрос для получения значений.
При выполнении запроса движок запускает запрос, группирует результаты по ID и присваивает значения соответствующим документам в таблице. Значения с ID, не найденным в таблице, отбрасываются. Перед выполнением запроса будет выполнен любой определенный `sql_query_pre_all`.
Формат объявления для sql_attr_multi следующий:
```ini
sql_attr_multi = ATTR-TYPE ATTR-NAME 'from' SOURCE-TYPE \
    [;QUERY] \
    [;RANGED-QUERY]
```
где
* ATTR-TYPE это `uint`, `bigint` или `timestamp`.
* SOURCE-TYPE это `field`, `query`, `ranged-query` или `ranged-main-query`.
* QUERY это необязательный SQL-запрос, используемый для получения всех пар (docid, attrvalue).
* RANGED-QUERY это необязательный SQL-запрос, используемый для получения минимальных и максимальных значений ID, подобно `sql_query_range`.
* Обратные слэши включены только для ясности; все можно объявить и в одной строке.
Это используется с SOURCE-TYPE ranged-query. Если используется SOURCE-TYPE `ranged-main-query`, то RANGED-QUERY можно опустить, и он автоматически использует тот же запрос из `sql_query_range` (полезный вариант в сложных настройках наследования, чтобы избежать необходимости многократно дублировать один и тот же запрос).
```ini
sql_attr_multi = uint tag from field
sql_attr_multi = uint tag from query; SELECT id, tag FROM tags
sql_attr_multi = bigint tag from ranged-query; \
    SELECT id, tag FROM tags WHERE id>=$start AND id<=$end; \
    SELECT MIN(id), MAX(id) FROM tags
```
### sql_attr_string
Объявляет строковый атрибут. Максимальный размер каждого значения фиксирован на уровне 4 ГБ.
### sql_attr_timestamp
Объявляет метку времени UNIX.
Метки времени могут хранить даты и время в диапазоне с 1 января 1970 года по 19 января 2038 года с точностью до одной секунды. Ожидаемое значение столбца должно быть меткой времени в формате UNIX, который представляет собой 32-битное знаковое целое число секунд, прошедших с полуночи 1 января 1970 года по Гринвичу. Метки времени внутренне хранятся и обрабатываются как целые числа повсюду. В дополнение к работе с метками времени как целыми числами, вы также можете использовать их с различными функциями, связанными с датами, такими как режим сортировки сегментов времени или извлечение дня/недели/месяца/года для GROUP BY.
Обратите внимание, что типы столбцов DATE или DATETIME в MySQL не могут быть напрямую использованы как атрибуты метки времени в Manticore; вам необходимо явным образом конвертировать такие столбцы с помощью функции UNIX_TIMESTAMP (если данные находятся в диапазоне).
Обратите внимание, что метки времени не могут представлять даты до 1 января 1970 года, и функция UNIX_TIMESTAMP() в MySQL не вернет ничего ожидаемого. Если вам нужно работать только с датами, а не с временем, рассмотрите функцию `TO_DAYS()` в MySQL.
### sql_attr_uint
Объявляет атрибут без знака.
Вы можете указать количество бит для целочисленных атрибутов, добавив ':BITCOUNT' к имени атрибута (см. пример ниже). Атрибуты с размером менее 32-бит по умолчанию или битовые поля работают медленнее.
```ini
sql_attr_uint = group_id
sql_attr_uint = forum_id:9 # 9 бит для forum_id
```
### sql_field_string
Объявляет комбинированный строковый атрибут/текстовое поле. Значения будут индексироваться как полнотекстовое поле, но также хранятся в строковом атрибуте с тем же названием. Обратите внимание, его следует использовать только когда вы уверены, что поле должно быть доступно для поиска как в полнотекстовом режиме, так и как атрибут (с возможностью сортировки и группировки по нему). Если вы просто хотите иметь возможность получить оригинальное значение поля, вам не нужно ничего делать для этого, если только вы не удалили поле из списка хранимых полей через [stored_fields](../../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#stored_fields).
```ini
sql_field_string = name
```
### sql_file_field
Объявляет поле основанное на файле.
Это директива заставляет индексатор интерпретировать содержимое поля как имя файла и загружать и обрабатывать упомянутый файл. Файлы размером больше max_file_field_buffer пропускаются. Любые ошибки во время загрузки файла (ошибки ввода-вывода, пропущенные ограничения и т.д.) будут сообщены как предупреждения индексации и не будут преждевременно завершать индексацию. Содержимое таких файлов не будет индексироваться.

```ini
sql_file_field = field_name
```

### sql_joined_field

Запрос на выборку объединенного/нагруженного поля. Многозначный, необязательный, по умолчанию — пустой список запросов.

`sql_joined_field` позволяет вам использовать две разные функции: объединенные поля и нагрузочные поля (payload fields). Его синтаксис выглядит следующим образом:

```ini
sql_joined_field = FIELD-NAME 'from'  ( 'query' | 'payload-query' | 'ranged-query' | 'ranged-main-query' ); \
		QUERY [ ; RANGE-QUERY ]
```

где

* FIELD-NAME — это имя объединенного/нагруженного поля
* QUERY — это SQL-запрос, который должен получить значения для дальнейшей обработки
* RANGE-QUERY — это необязательный SQL-запрос, который получает диапазон значений для обработки

**Объединенные поля** позволяют вам избежать операторов JOIN и/или GROUP_CONCAT в основном запросе выборки документа (sql_query). Это может быть полезно, когда SQL-оператор JOIN медленный, или его нужно перенести на сторону Manticore, или просто для имитации MySQL-специфичной функциональности `GROUP_CONCAT`, если ваш сервер базы данных не поддерживает это.

Запрос должен возвращать ровно 2 столбца: идентификатор документа и текст, чтобы добавить в объединенное поле. Идентификаторы документов могут дублироваться, но они должны быть в порядке возрастания. Все текстовые строки, извлеченные для данного идентификатора, будут объединены вместе, и результат конкатенации будет индексирован как всё содержимое объединенного поля. Строки будут объединены в порядке, возвращенном из запроса, и между ними будет вставлен разделительный пробел. Например, если запрос объединенного поля возвращает следующие строки:
```ini
( 1, 'красный' )
( 1, 'правый' )
( 1, 'рука' )
( 2, 'mysql' )
( 2, 'manticore' )
```

тогда результаты индексации будут эквивалентны добавлению нового текстового поля со значением 'красный правый рука' к документу 1 и 'mysql sphinx' к документу 2, включая позиции ключевых слов внутри поля в порядке их приходения из запроса. Если строки нужно расположить в определенном порядке, это должно быть явно определено в запросе.

Объединенные поля индексируются только по-другому. Нет других различий между объединенными полями и обычными текстовыми полями.

Перед выполнением запроса на объединенные поля будет запущен любой набор `sql_query_pre_all`, если такие существуют. Это позволяет вам установить желаемую кодировку и т.д. в контексте объединенных полей.

Когда один запрос недостаточно эффективен или не работает из-за ограничений драйвера базы данных, можно использовать диапазонные запросы. Это работает аналогично диапазонным запросам в основном цикле индексации. Диапазон будет запрашиваться и извлекаться заранее один раз, затем будет выполнено несколько запросов с разными заменами `$start` и `$end`, чтобы извлечь фактические данные.

При использовании запроса `ranged-main-query` опустите `ranged-query`, и он автоматически будет использовать тот же запрос из `sql_query_range` (полезный вариант в сложных иерархических настройках, чтобы избежать ручного дублирования одного и того же запроса много раз).

<!-- example payload -->
**Нагрузки** позволяют вам создать специальное поле, в котором, вместо позиций ключевых слов, хранятся так называемые пользовательские нагрузки. Нагрузки — это пользовательские целые значения, прикрепленные к каждому ключевому слову. Затем они могут быть использованы во время поиска для влияния на рейтинг.

Запрос на нагрузку должен возвращать ровно 3 столбца:
- идентификатор документа
- ключевое слово
- и целочисленное значение нагрузки.

Идентификаторы документов могут дублироваться, но они должны быть в порядке возрастания. Нагрузки **должны** быть беззнаковыми целыми числами в 24-битном диапазоне, т.е. от 0 до 16777215.

Единственный ранг, который учитывает нагрузки, это `proximity_bm25` (по умолчанию [рейтинговая функция](../../Searching/Sorting_and_ranking.md#Available-built-in-rankers)). В таблицах с полями нагрузок он автоматически переключится на вариант, который сопоставляет ключевые слова в этих полях, вычисляет сумму совпадающих нагрузок, умноженную на веса полей, и добавляет эту сумму к окончательному рейтингу.

Пожалуйста, обратите внимание, что поле нагрузки игнорируется для полнотекстовых запросов, содержащих сложные операторы. Оно работает только для простых запросов типа bag-of-words.

<!-- intro -->
Пример конфигурации:
<!-- request Configuration file -->
```ini
source min {
    type = mysql
    sql_host = localhost
    sql_user = test
    sql_pass =
    sql_db = test
    sql_query = select 1, 'Nike bag' f \
    UNION select 2, 'Adidas bag' f \
    UNION select 3, 'Reebok bag' f \
    UNION select 4, 'Nike belt' f

    sql_joined_field = tag from payload-query; select 1 id, 'nike' tag, 10 weight \
    UNION select 4 id, 'nike' tag, 10 weight;
}

index idx {
    path = idx
    source = min
}
```

<!-- request Just SELECT -->
```sql
mysql> select * from idx;
+------+------------+------+
| id   | f          | tag  |
+------+------------+------+
|    1 | Nike bag   | nike |
|    2 | Adidas bag |      |
|    3 | Reebok bag |      |
|    4 | Nike belt  | nike |
+------+------------+------+
4 rows in set (0.00 sec)
```

<!-- request Full-text search -->

Обратите внимание, что когда вы ищете `nike | adidas`, результаты, содержащие "nike", получают более высокий вес из-за тега "nike" и его веса, исходящего из запроса нагрузки.
```sql
mysql> select *, weight() from idx where match('nike|adidas');
+------+------------+------+----------+
| id   | f          | tag  | weight() |
+------+------------+------+----------+
|    1 | Nike bag   | nike |    11539 |
|    4 | Nike belt  | nike |    11539 |
|    2 | Adidas bag |      |     1597 |
+------+------------+------+----------+
3 rows in set (0.01 sec)
```

<!-- request Complex full-text search -->
Обратите внимание, что специальное поле полезной нагрузки игнорируется для полнотекстовых запросов, содержащих сложные операторы. Это работает только для простых запросов с мешком слов.

```sql
mysql> select *, weight() from idx where match('"nike bag"|"adidas bag"');
+------+------------+------+----------+
| id   | f          | tag  | weight() |
+------+------------+------+----------+
|    2 | Adidas bag |      |     2565 |
|    1 | Nike bag   | nike |     2507 |
+------+------------+------+----------+
2 rows in set (0.00 sec)
```

<!-- end -->

### sql_column_buffers

```ini
sql_column_buffers = <colname>=<size>[K|M] [, ...]
```

Размеры буферов для каждого столбца. Необязательный, по умолчанию пусто (размеры вычисляются автоматически). Применяется только для источников типов `odbc`, `mssql`.

Драйверы ODBC и MS SQL иногда не могут вернуть максимальный фактический размер столбца, который ожидается. Например, столбцы `NVARCHAR(MAX)` всегда сообщают о своей длине как 2147483647 байт в `indexer`, даже если фактическая использованная длина, вероятно, значительно меньше. Тем не менее, принимающие буферы все равно должны быть выделены заранее, и их размеры должны быть определены. Когда драйвер вообще не сообщает длину столбца, Manticore выделяет по умолчанию буферы размером 1 КБ для каждого некорректного столбца и 1 МБ для каждого корректного столбца. Длина столбца, сообщенная драйвером, также ограничивается верхним пределом 8 МБ, поэтому в случае, если драйвер сообщает (почти) длину столбца 2 ГБ, она будет ограничена, и вместо этого для этого столбца будет выделен буфер размером 8 МБ. Эти жестко закодированные ограничения могут быть переопределены с помощью директивы `sql_column_buffers`, либо для экономии памяти на фактически более коротких столбцах, либо чтобы преодолеть лимит в 8 МБ для фактически более длинных столбцов. Значения директивы должны быть списком имен и размеров выбранных столбцов, разделенных запятыми:

Пример:

```ini
sql_query = SELECT id, mytitle, mycontent FROM documents
sql_column_buffers = mytitle=64K, mycontent=10M
```
<!-- proofread -->














































