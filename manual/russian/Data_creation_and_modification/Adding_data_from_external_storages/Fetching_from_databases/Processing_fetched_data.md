# Обработка полученных данных

По умолчанию первый столбец из набора результатов `sql_query` индексируется как идентификатор документа.

Идентификатор документа *ДОЛЖЕН* быть самым первым полем, и он **ДОЛЖЕН БЫТЬ** УНИКАЛЬНЫМ ЗНАКОВЫМ (НЕ НУЛЕВЫМ) ЦЕЛЫМ ЧИСЛОМ от -9223372036854775808 до 9223372036854775807.

Вы можете указать до 256 полнотекстовых полей и произвольное количество атрибутов. Все столбцы, которые не являются ни идентификатором документа (первым), ни атрибутами, будут индексироваться как полнотекстовые поля.


## Объявление атрибутов:

### sql_attr_bigint

Объявляет 64-битное *знаковое* целое число.

### sql_attr_bool

Объявляет булев атрибут. Это эквивалентно целочисленному атрибуту с битовой длиной 1.

### sql_attr_float

Объявляет атрибут с плавающей точкой.

Значения будут храниться в формате одинарной точности, 32-битном IEEE 754. Представляемый диапазон примерно от 1e-38 до 1e+38. Количество десятичных знаков, которые могут быть сохранены точно, примерно равно 7.

Одно из важных применений атрибутов с плавающей точкой — хранение значений широты и долготы (в радианах) для дальнейшего использования в вычислениях геосферного расстояния во время запроса.

### sql_attr_json

Объявляет JSON-атрибут.

При индексировании JSON-атрибутов Manticore ожидает текстовое поле с данными в формате JSON. JSON-атрибуты поддерживают произвольные JSON-данные без ограничений по уровню вложенности или типам.

### sql_attr_multi

Объявляет атрибут с множественными значениями.

Обычные атрибуты позволяют прикреплять только 1 значение к каждому документу. Однако бывают случаи (например, теги или категории), когда требуется прикрепить несколько значений одного и того же атрибута и иметь возможность применять фильтрацию или группировку по спискам значений.

MVA может принимать значения из столбца (как и остальные типы данных) — в этом случае столбец в наборе результатов должен содержать строку с несколькими целочисленными значениями, разделёнными запятыми — или путем выполнения отдельного запроса для получения значений.

При выполнении запроса движок выполняет запрос, группирует результаты по ID и присваивает значения соответствующим документам в таблице. Значения с ID, не найденным в таблице, отбрасываются. Перед выполнением запроса будет выполнен любой определённый `sql_query_pre_all`.

Формат объявления sql_attr_multi следующий:

```ini
sql_attr_multi = ATTR-TYPE ATTR-NAME 'from' SOURCE-TYPE \
    [;QUERY] \
    [;RANGED-QUERY]
```

где

* ATTR-TYPE — это `uint`, `bigint` или `timestamp`.
* SOURCE-TYPE — это `field`, `query`, `ranged-query` или `ranged-main-query`.
* QUERY — необязательный SQL-запрос, используемый для получения всех пар (docid, attrvalue).
* RANGED-QUERY — необязательный SQL-запрос, используемый для получения минимальных и максимальных значений ID, аналогично `sql_query_range`.
* Обратные слэши включены только для наглядности; всё можно объявить и в одной строке.

Используется с SOURCE-TYPE типа ranged-query. Если используется SOURCE-TYPE `ranged-main-query`, то RANGED-QUERY опускается, и автоматически будет использован тот же запрос из `sql_query_range` (полезная опция в сложных настройках наследования, чтобы не дублировать один и тот же запрос много раз вручную).

```ini
sql_attr_multi = uint tag from field
sql_attr_multi = uint tag from query; SELECT id, tag FROM tags
sql_attr_multi = bigint tag from ranged-query; \
    SELECT id, tag FROM tags WHERE id>=$start AND id<=$end; \
    SELECT MIN(id), MAX(id) FROM tags
```

### sql_attr_string

Объявляет строковый атрибут. Максимальный размер каждого значения фиксирован и составляет 4 ГБ.

### sql_attr_timestamp

Объявляет UNIX timestamp.

Таймстампы могут хранить даты и время в диапазоне с 1 января 1970 года по 19 января 2038 года с точностью до одной секунды. Ожидаемое значение столбца — это timestamp в формате UNIX, который представляет собой 32-битное беззнаковое целое число секунд, прошедших с полуночи 1 января 1970 года по Гринвичу. Таймстампы внутренне хранятся и обрабатываются как целые числа повсеместно. Помимо работы с таймстампами как с целыми числами, вы также можете использовать их с различными функциями, основанными на дате, такими как режим сортировки по временным сегментам или извлечение дня/недели/месяца/года для GROUP BY.

Обратите внимание, что типы столбцов DATE или DATETIME в MySQL не могут напрямую использоваться как атрибуты timestamp в Manticore; необходимо явно преобразовывать такие столбцы с помощью функции UNIX_TIMESTAMP (если данные находятся в диапазоне).

Обратите внимание, что таймстампы не могут представлять даты до 1 января 1970 года, и UNIX_TIMESTAMP() в MySQL не вернёт ожидаемых значений. Если вам нужно работать только с датами, а не с временем, рассмотрите функцию `TO_DAYS()` в MySQL.


### sql_attr_uint

Объявляет беззнаковый целочисленный атрибут.

Вы можете указать количество бит для целочисленных атрибутов, добавив ':BITCOUNT' к имени атрибута (см. пример ниже). Атрибуты с размером меньше стандартных 32 бит или битовые поля работают медленнее.

```ini
sql_attr_uint = group_id
sql_attr_uint = forum_id:9 # 9 bits for forum_id
```

### sql_field_string

Объявляет комбинированный строковый атрибут/текстовое поле. Значения будут индексироваться как полнотекстовое поле, но также храниться в строковом атрибуте с тем же именем. Обратите внимание, что это следует использовать только если вы уверены, что хотите, чтобы поле было доступно для поиска как полнотекстово, так и как атрибут (с возможностью сортировки и группировки по нему). Если вы просто хотите иметь возможность получить исходное значение поля, вам ничего делать не нужно, если только вы явно не удалили поле из списка хранимых полей через [stored_fields](../../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#stored_fields).

```ini
sql_field_string = name
```

### sql_file_field

Объявляет поле на основе файла.

Эта директива заставляет индексатор интерпретировать содержимое поля как имя файла и загружать и обрабатывать указанный файл. Файлы, размер которых превышает max_file_field_buffer, пропускаются. Любые ошибки при загрузке файла (ошибки ввода-вывода, превышение лимитов и т. п.) будут зарегистрированы как предупреждения индексирования и не приведут к преждевременному завершению индексирования. Для таких файлов содержимое индексироваться не будет.

```ini
sql_file_field = field_name
```

### sql_joined_field

Запрос для получения объединённого/пейлоадного поля. Множественное значение, необязательное, по умолчанию пустой список запросов.

`sql_joined_field` позволяет использовать две разные функции: объединённые поля и пейлоады (payload-поля). Его синтаксис следующий:

```ini
sql_joined_field = FIELD-NAME 'from'  ( 'query' | 'payload-query' | 'ranged-query' | 'ranged-main-query' ); \
		QUERY [ ; RANGE-QUERY ]
```

где

* FIELD-NAME — имя объединённого/пейлоадного поля
* QUERY — SQL-запрос, который должен получать значения для дальнейшей обработки
* RANGE-QUERY — необязательный SQL-запрос, который получает диапазон значений для обработки

**Объединённые поля** позволяют избежать использования операторов JOIN и/или GROUP_CONCAT в основном запросе выборки документов (sql_query). Это может быть полезно, когда JOIN на стороне SQL медленный, или его нужно перенести на сторону Manticore, или просто для эмуляции специфичной для MySQL функции `GROUP_CONCAT`, если ваш сервер базы данных её не поддерживает.

Запрос должен возвращать ровно 2 столбца: ID документа и текст, который нужно добавить к объединённому полю. ID документов могут повторяться, но они должны быть в порядке возрастания. Все текстовые строки, полученные для данного ID, будут объединены вместе, и результат конкатенации будет индексироваться как полное содержимое объединённого поля. Строки будут объединяться в порядке, возвращаемом запросом, между ними будет вставлен разделяющий пробел. Например, если запрос объединённого поля возвращает следующие строки:
```ini
( 1, 'red' )
( 1, 'right' )
( 1, 'hand' )
( 2, 'mysql' )
( 2, 'manticore' )
```

то результаты индексирования будут эквивалентны добавлению нового текстового поля со значением 'red right hand' к документу 1 и 'mysql sphinx' к документу 2, включая позиции ключевых слов внутри поля в порядке их поступления из запроса. Если строки должны быть в определённом порядке, это нужно явно указать в запросе.

Объединённые поля индексируются только иначе. Других отличий между объединёнными полями и обычными текстовыми полями нет.

Перед выполнением запроса объединённых полей будут выполнены все наборы `sql_query_pre_all`, если они существуют. Это позволяет задать нужную кодировку и т. п. в контексте объединённых полей.

Если один запрос недостаточно эффективен или не работает из-за ограничений драйвера базы данных, можно использовать запросы с диапазонами. Это работает аналогично запросам с диапазонами в основном цикле индексирования. Диапазон запрашивается и извлекается заранее один раз, затем выполняется несколько запросов с разными подстановками `$start` и `$end` для получения фактических данных.

При использовании запроса `ranged-main-query` опускается `ranged-query`, и автоматически используется тот же запрос из `sql_query_range` (полезная опция в сложных схемах наследования, чтобы не дублировать один и тот же запрос много раз вручную).

<!-- example payload -->
**Payloads** позволяют создать специальное поле, в котором вместо позиций ключевых слов хранятся так называемые пользовательские полезные данные (payloads). Payloads — это пользовательские целочисленные значения, прикреплённые к каждому ключевому слову. Они могут использоваться во время поиска для влияния на ранжирование.

Запрос payload должен возвращать ровно 3 столбца:
- ID документа
- ключевое слово
- и целочисленное значение payload.

ID документов могут повторяться, но должны быть в порядке возрастания. Payloads **должны** быть беззнаковыми целыми числами в 24-битном диапазоне, то есть от 0 до 16777215.

Единственный ранжировщик, учитывающий payloads — это `proximity_bm25` (ранжировщик по умолчанию [ranker](../../../Searching/Sorting_and_ranking.md#Available-built-in-rankers)). В таблицах с полями payload он автоматически переключается на вариант, который сопоставляет ключевые слова в этих полях, вычисляет сумму совпавших payloads, умноженных на веса полей, и добавляет эту сумму к итоговому рангу.

Обратите внимание, что поле payload игнорируется для полнотекстовых запросов, содержащих сложные операторы. Оно работает только для простых запросов типа "мешок слов".

<!-- intro -->
Пример конфигурации:
<!-- request Configuration file -->
```ini
source min {
    type = mysql
    sql_host = localhost
    sql_user = test
    sql_pass =
    sql_db = test
    sql_query = select 1, 'Nike bag' f \
    UNION select 2, 'Adidas bag' f \
    UNION select 3, 'Reebok bag' f \
    UNION select 4, 'Nike belt' f

    sql_joined_field = tag from payload-query; select 1 id, 'nike' tag, 10 weight \
    UNION select 4 id, 'nike' tag, 10 weight;
}

index idx {
    path = idx
    source = min
}
```

<!-- request Just SELECT -->
```sql
mysql> select * from idx;
+------+------------+------+
| id   | f          | tag  |
+------+------------+------+
|    1 | Nike bag   | nike |
|    2 | Adidas bag |      |
|    3 | Reebok bag |      |
|    4 | Nike belt  | nike |
+------+------------+------+
4 rows in set (0.00 sec)
```

<!-- request Full-text search -->

Обратите внимание, что при поиске `nike | adidas` результаты, содержащие "nike", получают больший вес благодаря тегу "nike" и его весу, исходящему из запроса payload.
```sql
mysql> select *, weight() from idx where match('nike|adidas');
+------+------------+------+----------+
| id   | f          | tag  | weight() |
+------+------------+------+----------+
|    1 | Nike bag   | nike |    11539 |
|    4 | Nike belt  | nike |    11539 |
|    2 | Adidas bag |      |     1597 |
+------+------------+------+----------+
3 rows in set (0.01 sec)
```

<!-- request Complex full-text search -->

Обратите внимание, что специальное поле payload игнорируется для полнотекстовых запросов, содержащих сложные операторы. Оно работает только для простых запросов типа "мешок слов".

```sql
mysql> select *, weight() from idx where match('"nike bag"|"adidas bag"');
+------+------------+------+----------+
| id   | f          | tag  | weight() |
+------+------------+------+----------+
|    2 | Adidas bag |      |     2565 |
|    1 | Nike bag   | nike |     2507 |
+------+------------+------+----------+
2 rows in set (0.00 sec)
```

<!-- end -->

### sql_column_buffers

```ini
sql_column_buffers = <colname>=<size>[K|M] [, ...]
```

Размеры буферов для каждого столбца. Опционально, по умолчанию пусто (размеры определяются автоматически). Применяется только к типам источников `odbc`, `mssql`.

Драйверы ODBC и MS SQL иногда не могут вернуть максимальный фактический размер столбца. Например, столбцы `NVARCHAR(MAX)` всегда сообщают длину 2147483647 байт для `indexer`, хотя фактическая длина, скорее всего, значительно меньше. Однако буферы для приёма данных всё равно нужно выделять заранее, и их размеры должны быть определены. Если драйвер вообще не сообщает длину столбца, Manticore выделяет по умолчанию буферы размером 1 КБ для каждого несимвольного столбца и 1 МБ для каждого символьного столбца. Сообщаемая драйвером длина столбца также ограничивается верхним пределом в 8 МБ, поэтому если драйвер сообщает (почти) 2 ГБ длины столбца, она будет ограничена, и для этого столбца будет выделен буфер размером 8 МБ. Эти жёстко заданные ограничения можно переопределить с помощью директивы `sql_column_buffers`, чтобы либо сэкономить память на фактически более коротких столбцах, либо преодолеть ограничение в 8 МБ для фактически более длинных столбцов. Значения директивы должны быть списком через запятую с именами выбранных столбцов и размерами:

Пример:

```ini
sql_query = SELECT id, mytitle, mycontent FROM documents
sql_column_buffers = mytitle=64K, mycontent=10M
```
<!-- proofread -->

