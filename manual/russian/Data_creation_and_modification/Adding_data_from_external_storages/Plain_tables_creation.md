# Создание простых таблиц

Простые таблицы - это таблицы, которые создаются единожды путем извлечения данных при создании из одного или нескольких источников. Простая таблица неизменяема, так как документы не могут быть добавлены или удалены в течение ее жизненного цикла. Только значения числовых атрибутов (включая MVA) можно обновлять. Обновление данных возможно только путем воссоздания всей таблицы.

Простые таблицы доступны только в [Простом режиме](../../Creating_a_table/Local_tables.md#Defining-table-schema-in-config-%28Plain mode%29), и их определение состоит из объявления таблицы и одного или нескольких объявлений источников. Сбор данных и создание таблицы выполняются не сервером `searchd`, а вспомогательным инструментом `indexer`.

**Indexer** - это инструмент командной строки, который можно вызывать непосредственно из командной строки или из оболочки сценариев.

Он может принимать ряд аргументов при вызове, но у него также есть несколько собственных настроек в конфигурационном файле Manticore.

В типичном сценарии `indexer` выполняет следующее:
* Извлекает данные из источника
* Создает простую таблицу
* Записывает файлы таблиц
* (Опционально) Информирует сервер поиска о новой таблице, что запускает ротацию таблицы

## Инструмент Indexer
Инструмент `indexer` используется для создания простых таблиц в Manticore Search. Его общая синтаксическая структура:

```shell
indexer [OPTIONS] [table_name1 [table_name2 [...]]]
```

При создании таблиц с помощью `indexer` создаваемые файлы таблиц должны иметь такие разрешения, которые позволяют `searchd` читать, записывать и удалять их. В случае официальных пакетов для Linux `searchd` работает под пользователем `manticore`. Поэтому `indexer` также должен запускаться под пользователем `manticore`:

```shell
sudo -u manticore indexer ...
```

Если вы запускаете `searchd` иначе, вам может понадобиться опустить `sudo -u manticore`. Просто убедитесь, что у пользователя, под которым работает ваш экземпляр `searchd`, есть права на чтение/запись для таблиц, созданных с помощью `indexer`.

Чтобы создать простую таблицу, вам нужно перечислить таблицы, которые вы хотите обработать. Например, если ваш файл `manticore.conf` содержит данные о двух таблицах, `mybigindex` и `mysmallindex`, вы можете выполнить:

```shell
sudo -u manticore indexer mysmallindex mybigindex
```

Вы также можете использовать символы подстановки для сопоставления имен таблиц:

* `?` соответствует любому одному символу
* `*` соответствует любому количеству любых символов
* `%` соответствует ни одному или любому одному символу

```shell
sudo -u manticore indexer indexpart*main --rotate
```

Код выхода для `indexer` выглядит следующим образом:

* 0: все прошло ОК
* 1: возникла проблема во время индексации (и если был указан `--rotate`, он был пропущен) или операция вызвала предупреждение
* 2: индексация прошла ОК, но попытка `--rotate` провалилась

### Служба systemd Indexer

Вы также можете запустить `indexer`, используя следующий файл юнита systemctl:

```shell
systemctl start --no-block manticore-indexer
```

Или, если вы хотите построить конкретную таблицу:

```shell
systemctl start --no-block manticore-indexer@specific-table-name
```

Используйте команду `systemctl set-environment INDEXER_CONFIG`, чтобы запустить Indexer с пользовательской конфигурацией, которая заменяет настройки по умолчанию.

Команда `systemctl set-environment INDEXER_ARGS` позволяет вам добавлять пользовательские параметры запуска для Indexer. Для полного списка аргументов командной строки см. [здесь](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#Indexer-command-line-arguments).

Например, чтобы запустить Indexer в тихом режиме, выполните:
```bash
systemctl set-environment INDEXER_ARGS='--quiet'
systemctl restart manticore-indexer
```

Чтобы отменить изменения, выполните:
```bash
systemctl set-environment INDEXER_ARGS=''
systemctl restart manticore-indexer
```

### Аргументы командной строки Indexer
* `--config <file>` (`-c <file>` для короткой версии) говорит `indexer` использовать данный файл в качестве своей конфигурации. Обычно он будет искать `manticore.conf` в каталоге установки (например, `/etc/manticoresearch/manticore.conf`), а затем в текущем каталоге, в котором вы находитесь, когда вызываете `indexer` из оболочки. Это наиболее полезно в общих средах, где бинарные файлы установлены в глобальной папке, например, в `/usr/bin/`, но вы хотите предоставить пользователям возможность настраивать собственные установки Manticore, или если вы хотите запустить несколько экземпляров на одном сервере. В таких случаях вы можете разрешить им создавать собственные файлы `manticore.conf` и передавать их в `indexer` с помощью этой опции. Например:

  ```shell
  sudo -u manticore indexer --config /home/myuser/manticore.conf mytable
  ```

* `--all` говорит `indexer`, чтобы обновить каждую таблицу, указанную в `manticore.conf`, вместо перечисления отдельных таблиц. Это будет полезно в небольших конфигурациях или заданиях cron или обслуживания, когда весь набор таблиц будет пересоздан каждый день или неделю или какой-либо другой период, который наиболее актуален. Обратите внимание, что, так как `--all` пытается обновить все найденные таблицы в конфигурации, он выдаст предупреждение, если встретит таблицы RealTime, а код выхода команды будет `1`, а не `0`, даже если простые таблицы завершили работу без проблем. Пример использования:

  ```shell
  sudo -u manticore indexer --config /home/myuser/manticore.conf --all
  ```
* `--rotate` используется для вращения таблиц. Если только у вас не возникает ситуации, когда вы можете отключить функцию поиска без труда для пользователей, вы почти наверняка должны поддерживать поиск во время индексирования новых документов. `--rotate` создает вторую таблицу, параллельную первой (в том же месте, просто включая `.new` в именах файлов). После завершения `indexer` уведомляет `searchd`, отправляя сигнал `SIGHUP`, и `searchd` попытается переименовать таблицы (переименовать существующие, чтобы включить `.old`, и переименовать `.new`, чтобы заменить их), а затем начнет обслуживать новые файлы. В зависимости от настройки [seamless_rotate](../../Server_settings/Searchd.md#seamless_rotate) может быть небольшая задержка в возможности поиска по новым таблицам. В случае, если несколько таблиц вращаются одновременно, которые связаны отношениями [killlist_target](../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#killlist_target), вращение начнется с таблиц, которые не являются целевыми, и закончится таблицами в конце целевой цепочки. Пример использования:

  ```shell
  sudo -u manticore indexer --rotate --all
  ```
* `--quiet` говорит `indexer` не выводить ничего, если нет ошибки. Это в основном используется для задач типа cron или других сценариев, где вывод не имеет значения или не нужен, кроме как в случае какой-либо ошибки. Пример использования:

  ```shell
  sudo -u manticore indexer --rotate --all --quiet
  ```
* `--noprogress` не отображает детали прогресса по мере их возникновения. Вместо этого окончательные статусы (такие как количество индексируемых документов, скорость индексирования и так далее) сообщаются только по завершении индексирования. В случаях, когда скрипт не выполняется в консоли (или 'tty'), это будет включено по умолчанию. Пример использования:

  ```shell
  sudo -u manticore indexer --rotate --all --noprogress
  ```
* `--buildstops <outputfile.text> <N>` просматривает источник таблицы, как будто он индексировал данные, и создает список терминов, которые индексируются. Другими словами, он создает список всех доступных для поиска терминов, которые становятся частью таблицы. Обратите внимание, он не обновляет соответствующую таблицу, а просто обрабатывает данные, как если бы он индексировал, включая выполнение запросов, определенных с помощью [sql_query_pre](../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Execution_of_fetch_queries.md#sql_query_pre) или [sql_query_post](../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Execution_of_fetch_queries.md#sql_query_post). `outputfile.txt` будет содержать список слов, по одному на строку, отсортированный по частоте с самыми распространенными первыми, и `N` указывает максимальное количество слов, которые будут перечислены. Если он достаточно велик, чтобы охватить каждое слово в таблице, будет возвращено только столько слов. Такой словарь может использоваться для функций клиентского приложения, связанных с функциональностью "Не вы имели в виду…", обычно в сочетании с `--buildfreqs`, ниже. Пример:

  ```shell
  sudo -u manticore indexer mytable --buildstops word_freq.txt 1000
  ```

  Это создаст документ в текущем каталоге, `word_freq.txt`, с 1,000 наиболее распространенных слов в 'mytable', упорядоченных по убыванию частоты. Обратите внимание, что файл будет относиться к последней индексированной таблице, когда указаны несколько таблиц или `--all` (т.е. последней в конфигурационном файле)

* `--buildfreqs` работает с `--buildstops` (и игнорируется, если `--buildstops` не указан). Поскольку `--buildstops` предоставляет список слов, используемых в таблице, `--buildfreqs` добавляет количество, присутствующее в таблице, что было бы полезно для определения, должны ли определенные слова считаться стоп-словами, если они слишком распространены. Это также поможет в разработке функций "Не вы имели в виду…", где вам нужно знать, насколько данное слово более распространено по сравнению с другим, похожим. Например:

  ```shell
  sudo -u manticore indexer mytable --buildstops word_freq.txt 1000 --buildfreqs
  ```

  Это создаст `word_freq.txt`, как указано выше, однако после каждого слова будет указано количество раз, когда оно встречалось в соответствующей таблице.

* `--merge <dst-table> <src-table>` используется для физического объединения таблиц, например, если у вас есть схема [main+delta](../../Creating_a_table/Local_tables/Plain_table.md#Main+delta-scenario), где основная таблица редко изменяется, но таблица дельты часто пересоздается, и `--merge` будет использоваться для их объединения. Операция перемещается с правого на левое - содержимое `src-table` проверяется и физически объединяется с содержимым `dst-table`, и результат остается в `dst-table`. В псевдокоде это можно выразить как: `dst-table += src-table` Пример:

  ```shell
  sudo -u manticore indexer --merge main delta --rotate
  ```

  В приведенном выше примере, когда основная таблица является главной, редко изменяемой, а таблица дельты изменяется чаще, вы можете использовать вышеуказанное, чтобы вызвать `indexer` для объединения содержимого дельты в основную таблицу и вращения таблиц.

* `--merge-dst-range <attr> <min> <max>` выполняет фильтр диапазона, указанный при объединении. В частности, поскольку объединение применяется к целевой таблице (как часть `--merge`, и игнорируется, если `--merge` не указан), `indexer` также отфильтрует документы, попадающие в целевую таблицу, и только документы, прошедшие указанный фильтр, окажутся в финальной таблице. Это можно использовать, например, в таблице, где есть атрибут 'deleted', где 0 означает 'не удалено'. Такую таблицу можно объединить с:

  ```shell
  sudo -u manticore indexer --merge main delta --merge-dst-range deleted 0 0
  ```

  Любые документы, помеченные как удаленные (значение 1), будут удалены из вновь объединенной целевой таблицы. Это можно добавить несколько раз в командную строку, чтобы добавить последовательные фильтры к объединению, все из которых должны быть выполнены, чтобы документ стал частью финальной таблицы.
* --`merge-killlists` (и его короткий псевдоним `--merge-klists`) изменяет способ обработки килл-листов при слиянии таблиц. По умолчанию оба килл-листа отбрасываются после слияния. Это поддерживает самый типичный сценарий слияния main+delta. Однако, с включенной этой опцией, килл-листы из обеих таблиц конкатенируются и сохраняются в целевой таблице. Обратите внимание, что килл-лист из исходной (delta) таблицы будет использован для подавления строк из целевой (main) таблицы всегда.
* `--keep-attrs` позволяет повторно использовать существующие атрибуты при переиндексации. Каждый раз, когда таблица восстанавливается, каждый новый идентификатор документа проверяется на наличие в "старой" таблице, и если он уже существует, его атрибуты передаются в "новую" таблицу; если не найден, используются атрибуты из новой таблицы. Если пользователь обновил атрибуты в таблице, но не в фактическом источнике, использованном для таблицы, все обновления будут утеряны при переиндексации; использование `--keep-attrs` позволяет сохранить обновленные значения атрибутов из предыдущей таблицы. Можно указать путь к файлам таблицы, которые будут использоваться вместо ссылочного пути из конфигурации:

  ```shell
  sudo -u manticore indexer mytable --keep-attrs=/path/to/index/files
  ```

* `--keep-attrs-names=<attributes list>` позволяет указать атрибуты для повторного использования из существующей таблицы при переиндексации. По умолчанию все атрибуты из существующей таблицы повторно используются в новой таблице:

  ```shell
  sudo -u manticore indexer mytable --keep-attrs=/path/to/table/files --keep-attrs-names=update,state
  ```

* `--dump-rows <FILE>` сбрасывает строки, извлеченные из SQL источника(ов), в указанный файл в синтаксисе, совместимом с MySQL. Результирующие дампы представляют собой точное отображение данных, полученных через `indexer` и могут помочь воспроизвести проблемы во время индексации. Команда выполняет извлечение из источника и создает как файлы таблицы, так и файл дампа.
* `--print-rt <rt_index> <table>` выводит извлеченные данные из источника в виде INSERTов для таблицы реального времени. Первые строки дампа будут содержать поля и атрибуты реального времени (в отражении полей и атрибутов обычной таблицы). Команда выполняет извлечение из источника и создает как файлы таблицы, так и вывод дампа. Команда может быть использована как `sudo -u manticore indexer -c manticore.conf --print-rt indexrt indexplain > dump.sql`. Поддерживаются только источники на основе SQL. MVAs не поддерживаются.
* `--sighup-each` полезна, когда вы восстанавливаете много больших таблиц и хотите, чтобы каждая из них была передана в `searchd` как можно скорее. С помощью `--sighup-each` `indexer` будет отправлять сигнал SIGHUP в searchd после успешного завершения работы над каждой таблицей. (Поведение по умолчанию заключается в отправке единственного SIGHUP после того, как все таблицы будут построены).
* `--nohup` полезна, когда вы хотите проверить свою таблицу с помощью indextool перед фактической ротацией. indexer не отправит SIGHUP, если этот параметр включен. Файлы таблицы переименовываются в .tmp. Используйте indextool, чтобы переименовать файлы таблиц в .new и произвести ротацию. Пример использования:

  ```shell
  sudo -u manticore indexer --rotate --nohup mytable
  sudo -u manticore indextool --rotate --check mytable
  ```

* `--print-queries` выводит SQL запросы, которые `indexer` отправляет в базу данных, а также события подключения и отключения от SQL. Это полезно для диагностики и устранения проблем с SQL источниками.
* `--help` (`-h` для краткости) перечисляет все параметры, которые можно вызвать в `indexer`.
* `-v` показывает версию `indexer`.

### Настройки конфигурации индексатора
Вы также можете настроить поведение индексатора в файле конфигурации Manticore в разделе `indexer`:

```ini
indexer {
...
}
```

#### lemmatizer_cache

```ini
lemmatizer_cache = 256M
```
Размер кеша лемматизатора. Опционально, по умолчанию 256K.

Наша [лемматизация](../../Server_settings/Common.md#lemmatizer_base) использует сжатый формат словаря, который позволяет производить балансировку между пространством и скоростью. Она может либо выполнять лемматизацию на основе сжатых данных, используя больше ЦП, но меньше ОП, либо может распаковывать и кэшировать словарь частично или полностью, тем самым используя меньше ЦП, но больше ОП. Директива lemmatizer_cache позволяет контролировать, сколько ОП может быть израсходовано на этот несжатый кеш словаря.

В настоящее время доступны только [ru.pak, en.pak и de.pak](https://manticoresearch.com/install/). Это русский, английский и немецкий словари. Сжатый словарь имеет размер примерно от 2 до 10 МБ. Обратите внимание, что словарь также остается в памяти все время. Размер кеша по умолчанию составляет 256 КБ. Принятые размеры кеша составляют от 0 до 2047 МБ. Безопасно увеличивать размер кеша; лемматизатор будет использовать только необходимую память. Например, весь русский словарь распаковывается до примерно 110 МБ; таким образом установка `lemmatizer_cache` выше этого не повлияет на использование памяти. Даже когда допустимо 1024 МБ для кеша, если необходимо только 110 МБ, он будет использовать только эти 110 МБ.

#### max_file_field_buffer

```ini
max_file_field_buffer = 128M
```

Максимальный размер адаптивного буфера для полей файла в байтах. Опционально, по умолчанию 8 МБ, минимально 1 МБ.

Буфер поля файла используется для загрузки файлов, на которые ссылаются столбцы [sql_file_field](../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Processing_fetched_data.md#sql_file_field). Этот буфер является адаптивным, начиная с 1 МБ при первом выделении и увеличиваясь в 2x шагов, пока не будут загружены содержимое файла или не будет достигнут максимальный размер буфера, указанный директивой `max_file_field_buffer`.

Таким образом, если поля файла не указаны, буфер вообще не выделяется. Если все файлы, загруженные во время индексации, имеют размер менее (например) 2 МБ, но значение `max_file_field_buffer` равно 128 МБ, пиковое использование буфера все еще составит только 2 МБ. Однако файлы размером более 128 МБ будут полностью пропущены.

#### max_iops

```ini
max_iops = 40
```

Максимальное количество операций ввода-вывода в секунду для ограничения I/O. Опционально, по умолчанию 0 (неограничено).
Опция, относящаяся к ограничению I/O. Это ограничивает максимальное количество операций I/O (чтений или записей) за любую данную секунду. Значение 0 означает, что ограничение не накладывается.

`indexer` может вызывать всплески интенсивного дискового I/O во время построения таблицы, и может быть желательно ограничить его дисковую активность (и зарезервировать что-то для других программ, работающих на той же машине, таких как `searchd`). Ограничение I/O помогает в этом. Оно работает путем введения минимальной гарантированной задержки между последующими операциями дискового I/O, выполняемыми `indexer`. Ограничение I/O может помочь уменьшить ухудшение производительности поиска, вызванное построением. Эта настройка неэффективна для других видов ввода данных, например, вставки данных в таблицу в реальном времени.

#### max_iosize

```ini
max_iosize = 1048576
```

Максимально допустимый размер операции I/O в байтах для ограничения I/O. Необязательно, по умолчанию 0 (без ограничения).

Опция, относящаяся к ограничению I/O. Это ограничивает максимальный размер операции I/O (чтение или запись) для всех операций, выполняемых `indexer`. Значение 0 означает, что ограничение не накладывается. Чтения или записи, которые превышают этот лимит, будут разделены на несколько меньших операций и учтены как несколько операций по настройке [max_iops](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#max_iops). На момент написания все вызовы I/O должны быть менее 256 КБ (по умолчанию размер внутреннего буфера), так что значения max_iosize выше 256 КБ не должны оказывать никакого эффекта.

#### max_xmlpipe2_field

```ini
max_xmlpipe2_field = 8M
```

Максимально допустимый размер поля для типа источника XMLpipe2 в байтах. Необязательно, по умолчанию 2 МБ.

#### mem_limit

```ini
mem_limit = 256M
# mem_limit = 262144K # то же самое, но в КБ
# mem_limit = 268435456 # то же самое, но в байтах
```

Ограничение использования RAM при построении простой таблицы. Необязательно, по умолчанию 128 МБ. Принудительное ограничение на использование памяти, которое `indexer` не превысит. Может быть указано в байтах, килобайтах (с использованием постфикса K) или мегабайтах (с использованием постфикса M); см. пример. Это ограничение будет автоматически увеличено, если установлено на крайне низкое значение, вызывая недостаток буферов I/O меньше 8 КБ; точная нижняя граница для этого зависит от размера построенных данных. Если буферы меньше 256 КБ, будет выдано предупреждение.

Максимально возможный лимит составляет 2047M. Слишком низкие значения могут ухудшить скорость построения простой таблицы, но 256M до 1024M должно быть достаточно для большинства, если не для всех наборов данных. Установка этого значения слишком высоко может вызвать тайм-ауты SQL сервера. В течение фазы сбора документов будут периоды, когда память буфера частично отсортирована, и никакое взаимодействие с базой данных не выполняется; и сервер баз данных может превысить тайм-аут. Вы можете решить эту проблему, либо увеличив тайм-ауты на стороне SQL сервера, либо уменьшив `mem_limit`.

#### on_file_field_error

```ini
on_file_field_error = skip_document
```

Как обрабатывать ошибки ввода-вывода в полях файлов. Необязательно, по умолчанию `ignore_field`.
Когда возникает проблема с индексацией файла, на который ссылается поле файла ([sql_file_field](../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Processing_fetched_data.md#sql_file_field)), `indexer` может либо обработать документ, предполагая пустое содержимое в этом конкретном поле, либо пропустить документ, либо полностью прервать индексацию. Директива `on_file_field_error` контролирует это поведение. Значения, которые она принимает:
* `ignore_field`, обработать текущий документ без поля;
* `skip_document`, пропустить текущий документ, но продолжать индексацию;
* `fail_index`, завершить индексацию с сообщением об ошибке.

Проблемы, которые могут возникнуть: ошибка открытия, ошибка размера (файл слишком большой) и ошибка чтения данных. Предупреждающие сообщения о любой проблеме будут выдаваться в любое время, независимо от фазы и настройки `on_file_field_error`.

Обратите внимание, что с `on_file_field_error = skip_document` документы будут игнорироваться только в случае обнаружения проблем в ходе ранней фазы проверки и **не** во время фактической фазы разбора файлов. `indexer` откроет каждый упомянутый файл и проверит его размер перед выполнением какой-либо работы, а затем откроет его снова, когда будет выполняться фактическая работа по разбору. Таким образом, если файл исчезнет между этими двумя попытками открытия, документ все равно будет проиндексирован.

#### write_buffer

```ini
write_buffer = 4M
```

Размер буфера записи в байтах. Необязательно, по умолчанию 1 МБ. Буферы записи используются для записи как временных, так и окончательных файлов таблицы при индексации. Более крупные буферы уменьшают количество необходимых записей на диск. Память для буферов выделяется дополнительно к [mem_limit](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#mem_limit). Обратите внимание, что будут выделены несколько (в настоящее время до 4) буферов для различных файлов, что пропорционально увеличивает использование RAM.

#### ignore_non_plain

```ini
ignore_non_plain = 1
```

`ignore_non_plain` позволяет вам полностью игнорировать предупреждения о пропуске неплоских таблиц. По умолчанию 0 (не игнорировать).
<!-- proofread -->


### Планировщик индексации через systemd

Существуют два подхода к планированию запусков индексации. Первый способ - это классический метод с использованием crontab. Второй способ - использование таймера systemd с заданным пользователем расписанием. Чтобы создать файлы единиц таймера, вы должны поместить их в соответствующий каталог, где systemd ищет такие файлы единиц. В большинстве дистрибутивов Linux этот каталог обычно находится по адресу `/etc/systemd/system`. Вот как это сделать:

1. Создайте файл единицы таймера для вашего пользовательского расписания:
   ```shell
   cat << EOF > /etc/systemd/system/manticore-indexer@.timer
   [Unit]
   Description=Запуск индексации Manticore Search по расписанию
   [Timer]
   OnCalendar=minutely
   RandomizedDelaySec=5m
   Unit=manticore-indexer@%i.service
   [Install]
   WantedBy=timers.target
   EOF
   ```
   Подробнее о синтаксисе `OnCalendar` и примерах можно найти [здесь](https://www.freedesktop.org/software/systemd/man/latest/systemd.time.html#Calendar%20Events).
2. Отредактируйте единицу таймера в соответствии с вашими конкретными потребностями.
3. Включите таймер:
   ```shell
   systemctl enable manticore-indexer@idx1.timer
   ```
4. Запустите таймер:
   ```shell
   systemctl start manticore-indexer@idx1.timer
   ```
5. Повторите шаги 2-4 для любых дополнительных таймеров.




