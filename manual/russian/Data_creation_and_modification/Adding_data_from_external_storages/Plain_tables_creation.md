# Создание простых таблиц

Простые таблицы — это таблицы, которые создаются однократно путем получения данных при создании из одного или нескольких источников. Простая таблица неизменна, так как документы не могут быть добавлены или удалены в течение времени её существования. Возможны только обновления значений числовых атрибутов (включая MVA). Обновление данных возможно только путем полного пересоздания таблицы.

Простые таблицы доступны только в [Plain режиме](../../Creating_a_table/Local_tables.md#Defining-table-schema-in-config-%28Plain mode%29), и их определение состоит из объявления таблицы и одного или нескольких объявлений источников. Сбор данных и создание таблицы не выполняется сервером `searchd`, а выполняется вспомогательным инструментом `indexer`.

**Indexer** — это командная утилита, которую можно вызывать напрямую из командной строки или из shell-скриптов.

Она принимает ряд аргументов при вызове, но также имеет несколько собственных настроек в конфигурационном файле Manticore.

В типичном сценарии `indexer` выполняет следующие действия:
* Получает данные из источника
* Строит простую таблицу
* Записывает файлы таблицы
* (Опционально) Уведомляет поисковый сервер о новой таблице, что запускает ротацию таблиц

## Инструмент Indexer
Утилита `indexer` используется для создания простых таблиц в Manticore Search. Общий синтаксис:

```shell
indexer [OPTIONS] [table_name1 [table_name2 [...]]]
```

При создании таблиц с помощью `indexer` сгенерированные файлы таблиц должны иметь разрешения, позволяющие `searchd` читать, записывать и удалять их. В случае официальных пакетов для Linux `searchd` работает от имени пользователя `manticore`. Следовательно, `indexer` также должен запускаться от имени пользователя `manticore`:

```shell
sudo -u manticore indexer ...
```

Если вы запускаете `searchd` другим образом, возможно, потребуется опустить `sudo -u manticore`. Просто убедитесь, что пользователь, под которым работает ваша копия `searchd`, имеет права на чтение/запись для таблиц, сгенерированных с помощью `indexer`.

Чтобы создать простую таблицу, нужно перечислить таблицу(ы), которые вы хотите обработать. Например, если в вашем файле `manticore.conf` есть описания двух таблиц `mybigindex` и `mysmallindex`, можно запустить:

```shell
sudo -u manticore indexer mysmallindex mybigindex
```

Вы также можете использовать шаблоны с подстановочными знаками для сопоставления имен таблиц:

* `?` соответствует любому одному символу
* `*` соответствует любому количеству любых символов
* `%` соответствует отсутствию символа или любому одному символу

```shell
sudo -u manticore indexer indexpart*main --rotate
```

Коды выхода для indexer следующие:

* 0: всё прошло успешно
* 1: возникла проблема при индексации (а если был указан `--rotate`, то ротация была пропущена) или операция выдала предупреждение
* 2: индексация прошла успешно, но попытка `--rotate` провалилась

### systemd-сервис для Indexer

Вы также можете запускать `indexer` с помощью следующего unit-файла systemctl:

```shell
systemctl start --no-block manticore-indexer
```

Или, если хотите построить конкретную таблицу:

```shell
systemctl start --no-block manticore-indexer@specific-table-name
```

Используйте команду `systemctl set-environment INDEXER_CONFIG`, чтобы запустить Indexer с пользовательской конфигурацией, которая заменяет настройки по умолчанию.

Команда `systemctl set-environment INDEXER_ARGS` позволяет добавить пользовательские параметры запуска для Indexer. Полный список командных опций можно посмотреть [здесь](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#Indexer-command-line-arguments).

Например, чтобы запустить Indexer в тихом режиме, выполните:
```bash
systemctl set-environment INDEXER_ARGS='--quiet'
systemctl restart manticore-indexer
```

Чтобы отменить изменения, выполните:
```bash
systemctl set-environment INDEXER_ARGS=''
systemctl restart manticore-indexer
```

### Аргументы командной строки Indexer
* `--config <file>` (`-c <file>` для краткости) указывает `indexer` использовать указанный файл как конфигурацию. Обычно он ищет `manticore.conf` в каталоге установки (например, `/etc/manticoresearch/manticore.conf`), затем в текущем каталоге, из которого вызывается `indexer`. Это особенно полезно в общих средах, где бинарные файлы установлены в глобальную папку, например `/usr/bin/`, но вы хотите дать пользователям возможность создавать свои собственные настройки Manticore или запускать несколько экземпляров на одном сервере. В таких случаях можно позволить создавать собственные файлы `manticore.conf` и передавать их `indexer` с помощью этого параметра. Например:

  ```shell
  sudo -u manticore indexer --config /home/myuser/manticore.conf mytable
  ```

* `--all` говорит `indexer` обновить все таблицы, указанные в `manticore.conf`, вместо перечисления отдельных таблиц. Это полезно в небольших конфигурациях или в заданиях cron, где весь набор таблиц пересоздается ежедневно, еженедельно или с другим удобным интервалом. Обратите внимание, что поскольку `--all` пытается обновить все найденные таблицы в конфигурации, он выдаст предупреждение, если встретит RealTime таблицы, и код выхода команды будет `1`, а не `0`, даже если простые таблицы успешно обновлены. Пример использования:

  ```shell
  sudo -u manticore indexer --config /home/myuser/manticore.conf --all
  ```

* `--rotate` используется для ротации таблиц. Если вы не можете отключить функцию поиска без неудобств для пользователей, вам почти наверняка нужно будет держать поиск работающим во время индексации новых документов. `--rotate` создает вторую таблицу параллельно первой (в том же месте, просто с включением `.new` в имена файлов). По завершении `indexer` уведомляет `searchd`, посылая сигнал `SIGHUP`, и `searchd` пытается переименовать таблицы (переименовывая существующие в `.old` и `.new` в основную версию), а затем начинает обслуживать по новым файлам. В зависимости от настройки [seamless_rotate](../../Server_settings/Searchd.md#seamless_rotate) может наблюдаться небольшая задержка перед возможностью поиска в новых таблицах. Если одновременно ротация выполняется для нескольких таблиц, связанных отношениями [killlist_target](../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#killlist_target), ротация начнётся с таблиц, которые не являются целями, и закончится теми, что в конце цепочки целей. Пример использования:

  ```shell
  sudo -u manticore indexer --rotate --all
  ```
* `--quiet` говорит `indexer` не выводить ничего, кроме ошибок. В основном используется для заданий типа cron или других скриптов, где вывод не важен или нежелателен, кроме случая ошибки. Пример использования:

  ```shell
  sudo -u manticore indexer --rotate --all --quiet
  ```
* `--noprogress` не отображает детали прогресса по мере их возникновения. Вместо этого подробности итогового статуса (такие как количество проиндексированных документов, скорость индексирования и так далее) сообщаются только после завершения индексирования. В случаях, когда скрипт не запускается в консоли (или 'tty'), это включено по умолчанию. Пример использования:

  ```shell
  sudo -u manticore indexer --rotate --all --noprogress
  ```
* `--buildstops <outputfile.text> <N>` просматривает исходную таблицу, как будто индексирует данные, и создает список терминов, которые индексируются. Другими словами, он создает список всех поисковых терминов, которые становятся частью таблицы. Обратите внимание, что он не обновляет рассматриваемую таблицу, а просто обрабатывает данные, как при индексировании, включая выполнение запросов, определенных с помощью [sql_query_pre](../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Execution_of_fetch_queries.md#sql_query_pre) или [sql_query_post](../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Execution_of_fetch_queries.md#sql_query_post). В `outputfile.txt` будет содержаться список слов, по одному в строке, отсортированных по частоте с самым часто встречающимся первым, а `N` задает максимальное количество слов в списке. Если оно достаточно велико, чтобы охватить все слова в таблице, будет возвращено только столько слов. Такой список словарей может использоваться для функций клиентских приложений по типу "Вы имели в виду…", обычно в сочетании с `--buildfreqs`, ниже. Пример:

  ```shell
  sudo -u manticore indexer mytable --buildstops word_freq.txt 1000
  ```

  Это создаст документ в текущем каталоге `word_freq.txt` с 1000 наиболее распространенными словами в 'mytable', отсортированными по убыванию частоты. Обратите внимание, что файл будет относиться к последней проиндексированной таблице, если указано несколько таблиц или `--all` (то есть последняя в списке в конфигурационном файле).

* `--buildfreqs` работает вместе с `--buildstops` (и игнорируется, если `--buildstops` не указан). Поскольку `--buildstops` предоставляет список слов, используемых в таблице, `--buildfreqs` добавляет количество их появлений в таблице, что полезно для определения, следует ли считать некоторые слова стоп-словами, если они слишком частые. Также это поможет при разработке функций "Вы имели в виду…", где нужно знать, насколько одно слово встречается чаще другого похожего. Например:

  ```shell
  sudo -u manticore indexer mytable --buildstops word_freq.txt 1000 --buildfreqs
  ```

  Это создаст `word_freq.txt`, как выше, но после каждого слова будет указано количество его появлений в рассматриваемой таблице.

* `--merge <dst-table> <src-table>` используется для физического слияния таблиц, например, если у вас есть [схема main+delta](../../Creating_a_table/Local_tables/Plain_table.md#Main+delta-scenario), где основная таблица редко меняется, а таблица дельта пересоздается часто, и `--merge` используется для объединения двух. Операция движется справа налево — содержимое `src-table` изучается и физически объединяется с содержимым `dst-table`, результат сохраняется в `dst-table`. Псевдокод может выглядеть так: `dst-table += src-table` Пример:

  ```shell
  sudo -u manticore indexer --merge main delta --rotate
  ```

  В данном примере, где main — это основная редко изменяемая таблица, а delta — более часто изменяемая, вы можете вызвать `indexer`, чтобы объединить содержимое delta в основную таблицу и выполнить их ротацию.

* `--merge-dst-range <attr> <min> <max>` применяет фильтр указанного диапазона при слиянии. Конкретно, поскольку слияние применяется к таблице назначения (в рамках `--merge`, игнорируется, если `--merge` не указан), `indexer` также фильтрует документы, попадающие в таблицу назначения, и только документы, прошедшие через данный фильтр, оказываются в итоговой таблице. Это может быть использовано, например, в таблице с атрибутом 'deleted', где 0 означает 'не удален'. Такая таблица может быть объединена командой:

  ```shell
  sudo -u manticore indexer --merge main delta --merge-dst-range deleted 0 0
  ```

  Все документы, помеченные как удалённые (значение 1), будут удалены из вновь объединённой таблицы назначения. Можно добавить эту опцию несколько раз для добавления последовательных фильтров слияния, все из которых должны быть выполнены, чтобы документ стал частью итоговой таблицы.

* `--merge-killlists` (и его короткий алиас `--merge-klists`) изменяет способ обработки kill-листов при объединении таблиц. По умолчанию оба kill-листа отбрасываются после слияния. Это поддерживает наиболее типичный сценарий main+delta слияния. Однако с включенной этой опцией kill-листы обеих таблиц объединяются и сохраняются в таблице назначения. Обратите внимание, что kill-лист исходной (delta) таблицы всегда используется для подавления строк из таблицы назначения (main).
* `--keep-attrs` позволяет повторно использовать существующие атрибуты при переиндексации. Каждый новый id документа проверяется на наличие в "старой" таблице, и если он уже существует, его атрибуты переносятся в "новую" таблицу; если не найден, используются атрибуты из новой таблицы. Если пользователь обновлял атрибуты в таблице, но не в самом источнике данных для таблицы, все обновления будут потеряны при переиндексации; использование `--keep-attrs` позволяет сохранить обновленные значения атрибутов из предыдущей таблицы. Можно указать путь к файлам таблицы для использования вместо пути из конфига:

  ```shell
  sudo -u manticore indexer mytable --keep-attrs=/path/to/index/files
  ```

* `--keep-attrs-names=<attributes list>` позволяет указать атрибуты для повторного использования из существующей таблицы при переиндексации. По умолчанию повторно используются все атрибуты из существующей таблицы:

  ```shell
  sudo -u manticore indexer mytable --keep-attrs=/path/to/table/files --keep-attrs-names=update,state
  ```

* `--dump-rows <FILE>` сохраняет строки, полученные из SQL источника(ов), в указанный файл в синтаксисе, совместимом с MySQL. Полученные дампы являются точным представлением данных, как они принимаются `indexer`, и могут помочь повторить проблемы, возникающие во время индексации. Команда выполняет выборку из источника и создает как файлы таблиц, так и дамп файл.
* `--print-rt <rt_index> <table>` выводит полученные данные из источника в виде INSERT для таблицы реального времени. Первые строки дампа будут содержать поля и атрибуты реального времени (как отражение полей и атрибутов обычной таблицы). Команда выполняет выборку из источника и создает как файлы таблиц, так и вывод дампа. Команда может быть использована как `sudo -u manticore indexer -c manticore.conf --print-rt indexrt indexplain > dump.sql`. Поддерживаются только источники на основе SQL. Многозначные атрибуты (MVA) не поддерживаются.
* `--sighup-each` полезен, когда вы перестраиваете много больших таблиц и хотите, чтобы каждая из них была сразу же загружена в `searchd`. С `--sighup-each` `indexer` будет отправлять сигнал SIGHUP в searchd после успешного завершения работы над каждой таблицей. (По умолчанию отправляется один сигнал SIGHUP после создания всех таблиц).
* `--nohup` полезен, когда вы хотите проверить вашу таблицу с помощью indextool до фактической ее загрузки. indexer не будет отправлять SIGHUP, если этот параметр включен. Файлы таблиц будут переименованы в .tmp. Используйте indextool для переименования файлов таблиц в .new и их загрузки. Пример использования:

  ```shell
  sudo -u manticore indexer --rotate --nohup mytable
  sudo -u manticore indextool --rotate --check mytable
  ```

* `--print-queries` выводит SQL-запросы, которые `indexer` отправляет в базу данных, вместе с событиями подключения и отключения SQL. Это полезно для диагностики и устранения проблем с SQL-источниками.
* `--help` (`-h` для краткости) выводит список всех параметров, которые можно вызвать в `indexer`.
* `-v` показывает версию `indexer`.

### Настройки конфигурации Indexer
Вы также можете настроить поведение indexer в конфигурационном файле Manticore в разделе `indexer`:

```ini
indexer {
...
}
```

#### lemmatizer_cache

```ini
lemmatizer_cache = 256M
```
Размер кэша лемматизатора. Необязательно, по умолчанию 256K.

Наша реализация [лемматизатора](../../Server_settings/Common.md#lemmatizer_base) использует сжатый формат словаря, который обеспечивает баланс между использованием пространства и скоростью работы. Он может либо выполнять лемматизацию напрямую по сжатым данным, используя больше процессорного времени, но меньше оперативной памяти, либо распаковывать и предварительно кэшировать словарь либо частично, либо полностью, тем самым используя меньше процессорного времени, но больше оперативной памяти. Директива lemmatizer_cache позволяет контролировать, сколько именно оперативной памяти может быть выделено для этого не сжатого кэша словаря.

В настоящее время доступны только словари [ru.pak, en.pak и de.pak](https://manticoresearch.com/install/). Это русские, английские и немецкие словари. Размер сжатого словаря составляет примерно от 2 до 10 МБ. Обратите внимание, что словарь также всегда находится в оперативной памяти. Размер кэша по умолчанию — 256 КБ. Допустимые размеры кэша от 0 до 2047 МБ. Безопасно увеличивать размер кэша слишком сильно; лемматизатор использует только необходимую память. Например, весь русский словарь распаковывается примерно до 110 МБ; следовательно установка `lemmatizer_cache` выше этого значения не повлияет на использование памяти. Даже при разрешении 1024 МБ для кэша, если нужно только 110 МБ, будет использовано именно столько.

#### max_file_field_buffer

```ini
max_file_field_buffer = 128M
```

Максимальный размер адаптивного буфера для файлового поля в байтах. Необязательно, по умолчанию 8МБ, минимум 1МБ.

Буфер файлового поля используется для загрузки файлов, на которые ссылаются столбцы [sql_file_field](../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Processing_fetched_data.md#sql_file_field). Этот буфер адаптивен, начинается с 1 МБ при первом выделении и увеличивается в 2 раза до тех пор, пока содержимое файла не может быть загружено или не достигнет максимального размера буфера, указанного директивой `max_file_field_buffer`.

Таким образом, если файловые поля не указаны, буфер не выделяется вообще. Если все файлы, загружаемые во время индексации, меньше (например) 2 МБ, но значение `max_file_field_buffer` установлено в 128 МБ, пиковое использование буфера все равно будет только 2 МБ. Однако файлы размером более 128 МБ будут полностью пропущены.

#### max_iops

```ini
max_iops = 40
```

Максимальное количество операций ввода-вывода в секунду, для ограничения ввода-вывода. Необязательно, по умолчанию 0 (без ограничений).

Параметр, связанный с ограничением ввода-вывода. Ограничивает максимальное количество операций ввода-вывода (чтение или запись) в любую данную секунду. Значение 0 означает, что ограничения нет.

`indexer` может вызывать всплески интенсивной работы диска при построении таблицы, и может быть желательным ограничить его активность на диске (и резервировать ресурсы для других программ, работающих на той же машине, например `searchd`). Ограничение ввода-вывода помогает сделать это. Оно работает, обеспечивая минимальную гарантированную задержку между последовательными операциями ввода-вывода, выполняемыми `indexer`. Ограничение ввода-вывода может помочь уменьшить ухудшение производительности поиска, вызванное построением. Эта настройка не эффективна для других видов загрузки данных, например вставки данных в таблицу реального времени.

#### max_iosize

```ini
max_iosize = 1048576
```

Максимально допустимый размер операции ввода-вывода в байтах, для ограничения ввода-вывода. Необязательно, по умолчанию 0 (без ограничений).

Параметр, связанный с ограничением ввода-вывода. Ограничивает максимальный размер операции файлового ввода-вывода (чтение или запись) для всех операций, выполняемых `indexer`. Значение 0 означает, что ограничения нет. Чтения или записи больше лимита будут разделены на несколько меньших операций и учитываться как несколько операций по настройке [max_iops](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#max_iops). На момент написания все вызовы ввода-вывода должны быть меньше 256 КБ (размер внутреннего буфера по умолчанию), поэтому значения max_iosize выше 256 КБ не должны оказывать никакого эффекта.

#### max_xmlpipe2_field

```ini
max_xmlpipe2_field = 8M
```

Максимально допустимый размер поля для источника типа XMLpipe2 в байтах. Необязательно, по умолчанию 2 МБ.

#### mem_limit

```ini
mem_limit = 256M
# mem_limit = 262144K # same, but in KB
# mem_limit = 268435456 # same, but in bytes
```

Ограничение использования оперативной памяти при построении простых таблиц. Необязательно, по умолчанию 128 МБ. Принудительное ограничение использования памяти, которое `indexer` не превысит. Может быть указано в байтах, или килобайтах (с постфиксом K), или мегабайтах (с постфиксом M); см. пример. Это ограничение будет автоматически увеличено, если установлено в чрезвычайно низкое значение, из-за чего буферы ввода-вывода будут меньше 8 КБ; точная нижняя граница зависит от размера создаваемых данных. Если буферы меньше 256 КБ, будет выдаваться предупреждение.

Максимально возможное ограничение — 2047M. Слишком низкие значения могут замедлить построение простых таблиц, но от 256M до 1024M должно быть достаточно для большинства, если не всех наборов данных. Установка слишком высокого значения может вызвать тайм-ауты на SQL-сервере. Во время фазы сбора документов бывают периоды, когда буфер памяти частично отсортирован и нет обмена с базой данных; и сервер базы данных может прервать соединение по тайм-ауту. Вы можете решить эту проблему либо увеличив тайм-ауты на стороне SQL-сервера, либо уменьшая `mem_limit`.

#### on_file_field_error

```ini
on_file_field_error = skip_document
```

Как обрабатывать ошибки ввода-вывода в файловых полях. Необязательно, по умолчанию `ignore_field`.
Если при индексации файла, на который ссылается файловое поле ([sql_file_field](../../Data_creation_and_modification/Adding_data_from_external_storages/Fetching_from_databases/Processing_fetched_data.md#sql_file_field)), возникла проблема, `indexer` может либо обработать документ, предполагая пустое содержимое в данном поле, либо пропустить документ, либо полностью прекратить индексацию. Директива `on_file_field_error` управляет этим поведением. Возможные значения:
* `ignore_field` — обработать текущий документ без поля;
* `skip_document` — пропустить текущий документ, но продолжить индексацию;
* `fail_index` — прервать индексацию с сообщением об ошибке.

Возможные проблемы: ошибка открытия, ошибка размера (файл слишком большой) и ошибка чтения данных. Предупреждения при любых проблемах будут выдаваться всегда, независимо от фазы и настройки `on_file_field_error`.

Обратите внимание, что при `on_file_field_error = skip_document` документы будут игнорироваться только если проблемы обнаружены на этапе ранней проверки, и **не** во время фактического разбора файла. `indexer` откроет каждый файл и проверит его размер перед работой, а затем откроет его снова при фактическом разборе. Так что если файл исчезнет между этими двумя попытками открытия, документ всё равно будет проиндексирован.

#### write_buffer

```ini
write_buffer = 4M
```

Размер буфера записи, в байтах. Необязательно, по умолчанию 1 МБ. Буферы записи используются для записи как временных, так и конечных файлов таблиц при индексации. Большие буферы снижают количество необходимых записей на диск. Память для буферов выделяется сверх [mem_limit](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#mem_limit). Учтите, что будет выделено несколько (в настоящее время до 4) буферов для разных файлов, что пропорционально увеличивает использование ОЗУ.

#### ignore_non_plain

```ini
ignore_non_plain = 1
```

`ignore_non_plain` позволяет полностью игнорировать предупреждения о пропуске неплоских таблиц. По умолчанию 0 (не игнорировать).
<!-- proofread -->


### Планирование запуска indexer через systemd

Существует два способа планирования запусков indexer. Первый — классический метод с использованием crontab. Второй — использование таймера systemd с пользовательским расписанием. Чтобы создать файлы единиц таймера, их следует поместить в соответствующую директорию, где systemd ищет такие файлы. В большинстве дистрибутивов Linux это обычно `/etc/systemd/system`. Вот как это сделать:

1. Создайте файл единицы таймера для вашего пользовательского расписания:
   ```shell
   cat << EOF > /etc/systemd/system/manticore-indexer@.timer
   [Unit]
   Description=Run Manticore Search's indexer on schedule
   [Timer]
   OnCalendar=minutely
   RandomizedDelaySec=5m
   Unit=manticore-indexer@%i.service
   [Install]
   WantedBy=timers.target
   EOF
   ```
   Подробнее о синтаксисе и примерах `OnCalendar` можно найти [здесь](https://www.freedesktop.org/software/systemd/man/latest/systemd.time.html#Calendar%20Events).

2. Отредактируйте единицу таймера для своих конкретных нужд.
3. Включите таймер:
   ```shell
   systemctl enable manticore-indexer@idx1.timer
   ```
4. Запустите таймер:
   ```shell
   systemctl start manticore-indexer@idx1.timer
   ```
5. Повторите шаги 2-4 для любых дополнительных таймеров.

