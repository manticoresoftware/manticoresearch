# Поворот таблицы

Поворот таблицы – это процедура, в которой сервер searchd ищет новые версии определенных таблиц в конфигурации. Поворот поддерживается только в обычном режиме работы.

Существуют два случая:

* для обычных таблиц, которые уже загружены
* таблицы, добавленные в конфигурацию, но еще не загруженные

В первом случае индексатор не может выставить новую версию таблицы в сеть, поскольку работающая копия заблокирована и загружена `searchd`. В этом случае `indexer` необходимо вызывать с параметром [--rotate](../../Data_creation_and_modification/Adding_data_from_external_storages/Plain_tables_creation.md#Indexer-command-line-arguments). Если используется поворот, `indexer` создает новые файлы таблицы с `.new.` в их именах и отправляет сигнал *HUP* `searchd`, информируя его о новой версии. `searchd` выполнит поиск и заменит старую версию таблицы на новую. В некоторых случаях может быть желательно создать новую версию таблицы, но не выполнять поворот сразу. Например, сначала можно проверить состояние новых версий таблицы. В этом случае `indexer` может принять параметр `--nohup`, который запретит отправку сигнала HUP серверу.

Новые таблицы могут загружаться с помощью поворота; однако обычная обработка сигнала HUP — это проверка новых таблиц только в том случае, если конфигурация изменилась с момента запуска сервера. Если таблица уже была определена в конфигурации, таблицу следует сначала создать, запустив `indexer` без поворота, и выполнить вместо этого оператор [RELOAD TABLES](../../Data_creation_and_modification/Adding_data_from_external_storages/Rotating_a_table.md#RELOAD-TABLES).

Также существуют два специализированных оператора, которые могут использоваться для выполнения поворота таблиц:

## RELOAD TABLE

```sql
RELOAD TABLE tbl [ FROM '/path/to/table_files' [ OPTION switchover=1 ] ];
```

Команда `RELOAD TABLE` включает поворот таблицы через SQL.

Эта команда работает в трех режимах. В первом режиме, без указания пути, сервер Manticore проверяет наличие новых файлов таблиц в директории, указанной в [пути](../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#path). Новые файлы таблиц должны называться `tbl.new.sp?`.

Если вы укажете путь, сервер ищет файлы таблиц в этой директории, перемещает их в [путь](../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#path) таблицы, переименовывает их из `tbl.sp?` в `tbl.new.sp?` и выполняет поворот.

Третий режим, активируемый с помощью `OPTION switchover=1`, переключает индекс на новый путь. Здесь демона пытается загрузить таблицу напрямую с нового пути, не перемещая файлы. Если загрузка успешна, этот новый индекс заменяет старый.

Кроме того, демон записывает уникальный файл ссылки (`tbl.link`) в директории, указанной [путем](../../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#path), поддерживая постоянное перенаправление.

Если вы возвращаете перенаправленный индекс на путь, указанный в конфигурации, демон обнаружит это и удалит файл ссылки.

После перенаправления демон получает таблицу с нового связанного пути. При повороте он ищет новые версии таблиц по вновь перенаправленному пути. Имейте в виду, что демон проверяет конфигурацию на общие ошибки, такие как дублирующиеся пути между различными таблицами. Тем не менее, он не определит, если несколько таблиц указывают на один и тот же путь через перенаправление. В нормальных операциях таблицы блокируются с помощью файла `.spl`, но отключение блокировки может вызвать проблемы. Если возникнет ошибка (например, путь недоступен по какой-либо причине), вам следует вручную исправить (или просто удалить) файл ссылки.

`indextool` отслеживает файл ссылки, но другие инструменты (`indexer`, `index_converter` и т. д.) не распознают файл ссылки и постоянно используют путь, определенный в конфигурационном файле, игнорируя любое перенаправление. Таким образом, вы можете просматривать индекс с помощью `indextool`, и он будет читать из нового местоположения. Однако более сложные операции, такие как слияние, не будут учитывать файл ссылки.

```sql
mysql> RELOAD TABLE plain_table;
mysql> RELOAD TABLE plain_table FROM '/home/mighty/new_table_files';
mysql> RELOAD TABLE plain_table FROM '/home/mighty/new/place/for/table/table_files' OPTION switchover=1;
```

## RELOAD TABLES

```sql
RELOAD TABLES;
```

Эта команда функционирует аналогично системному сигналу HUP, инициируя поворот таблиц. Тем не менее, она не совсем отражает типичный сигнал HUP (который может поступать от команды `kill -HUP` или `indexer --rotate`). Эта команда активно ищет любые таблицы, нуждающиеся в повороте, и способна повторно прочитать конфигурацию. Предположим, вы запускаете Manticore в обычном режиме с конфигурационным файлом, который указывает на несуществующую простую таблицу. Если вы затем попытаетесь `indexer --rotate` таблицу, новая таблица не будет распознана сервером, пока вы не выполните `RELOAD TABLES` или не перезапустите сервер.

В зависимости от значения настройки [seamless_rotate](../../Server_settings/Searchd.md#seamless_rotate) новые запросы могут временно приостанавливаться, и клиенты будут получать временные ошибки.

```sql
mysql> RELOAD TABLES;
Query OK, 0 rows affected (0.01 sec)
```

# Бесшовный поворот

Поворот предполагает, что старая версия таблицы удаляется, а новая версия таблицы загружается и заменяет существующую. Во время этого обмена серверу также необходимо обрабатывать входящие запросы, сделанные к таблице, которую будут обновлять. Чтобы избежать задержек в запросах, сервер реализует бесшовный поворот таблицы по умолчанию, как описано ниже.

Таблицы могут содержать данные, которые необходимо предварительно кэшировать в ОЗУ. В данный момент файлы `.spa`, `.spb`, `.spi` и `.spm` полностью кэшируются (они содержат данные атрибутов, данные атрибутов блобов, таблицу ключевых слов и карту убитых строк, соответственно). Без бесшовного поворота вращение таблицы пытается использовать как можно меньше памяти и работает следующим образом:
1. Новые запросы временно отклоняются (с кодом ошибки "retry").
2. `searchd` ожидает завершения всех текущих запросов.
3. Старая таблица освобождается, и ее файлы переименовываются.
4. Файлы новой таблицы переименовываются, и выделяется необходимое количество ОЗУ.
5. Атрибут новой таблицы и данные словаря загружаются в ОЗУ.
6. `searchd` возобновляет обработку запросов из новой таблицы.

Однако, если есть много данных атрибутов или словаря, то этап предварительной загрузки может занять заметное время - до нескольких минут в случае предварительной загрузки файлов объемом 1-5+ ГБ.

При включенной бесшовной ротации ротация работает следующим образом:

1. Выделяется ОЗУ для хранения новой таблицы.
2. Данные атрибутов и словаря новой таблицы асинхронно загружаются в ОЗУ.
3. В случае успеха старая таблица освобождается, и файлы обеих таблиц переименовываются.
4. В случае неудачи новая таблица освобождается.
5. В любой момент времени запросы обрабатываются либо из старой, либо из новой копии таблицы.

Бесшовная ротация осуществляется ценой более высоких **пиковых** затрат памяти во время ротации (поскольку обе копии данных `.spa/.spb/.spi/.spm` должны находиться в ОЗУ во время предварительной загрузки новой копии). Однако среднее использование остается на том же уровне.

Пример:

```ini
seamless_rotate = 1
```
<!-- proofread -->

