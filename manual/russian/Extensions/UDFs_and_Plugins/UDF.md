# UDF

UDF хранятся во внешних динамических библиотеках (.so файлы на UNIX и .dll на Windows системах). Файлы библиотек должны быть помещены в доверенную папку, указанную директивой [plugin_dir](../../Server_settings/Common.md#plugin_dir) по соображениям безопасности: так проще защитить одну папку, чем позволять кому-либо устанавливать произвольный код в `searchd`. Вы можете динамически загружать и выгружать UDF в searchd с помощью SQL операторов [CREATE FUNCTION](../../Extensions/UDFs_and_Plugins/UDF/Creating_a_function.md) и [DROP FUNCTION](../../Extensions/UDFs_and_Plugins/UDF/Deleting_a_function.md) соответственно. Дополнительно, вы можете плавно перезагружать UDF (и другие плагины) с помощью оператора [RELOAD PLUGINS](../../Extensions/UDFs_and_Plugins/Plugins/Reloading_plugins.md). Manticore отслеживает текущие загруженные функции; каждый раз, когда вы создаёте или удаляете UDF, `searchd` обновляет свое состояние в файле [sphinxql_state](../../Server_settings/Searchd.md#sphinxql_state) в виде простого SQL скрипта.

UDF локальны. Чтобы использовать их в кластере, вы должны разместить одинаковую библиотеку на всех узлах и выполнить CREATE операторы на каждом узле. Этот процесс может измениться в будущих версиях.

После успешной загрузки UDF вы можете использовать её в SELECT или других операторах так же, как любую встроенную функцию:

```sql
SELECT id, MYCUSTOMFUNC (groupid, authorname), ... FROM myindex
```

Несколько UDF (и других плагинов) могут находиться в одной библиотеке. Библиотека загрузится только один раз и автоматически выгрузится, как только все UDF и плагины внутри неё будут удалены.

Теоретически, вы можете написать UDF на любом языке, если его компилятор может импортировать стандартные C заголовки и создавать стандартные динамические библиотеки с корректно экспортированными функциями. Однако написание на C++ или чистом C — это путь наименьшего сопротивления. Мы предоставляем пример библиотеки UDF, написанной на чистом C, реализующей несколько функций (демонстрирующих различные техники) вместе с нашим исходным кодом, который находится в [src/udfexample.c](https://github.com/manticoresoftware/manticore/blob/master/src/udfexample.c). Этот пример включает заголовочный файл [src/sphinxudf.h](https://github.com/manticoresoftware/manticore/blob/master/src/sphinxudf.h), который содержит определения нескольких структур и типов, связанных с UDF. Для большинства UDF и плагинов достаточно просто использовать `#include "sphinxudf.h"`, как показано в примере. Однако, если вы пишете функцию ранжирования и вам нужно получить доступ к данным сигналов ранжирования (факторов) из UDF, вам также потребуется скомпилировать и связать с `src/sphinxudf.c` (доступный в исходном коде), поскольку *реализации* функций, позволяющих получить доступ к данным сигналов из UDF, находятся в этом файле.

И `sphinxudf.h`, и `sphinxudf.c` являются автономными, поэтому вы можете копировать эти файлы отдельно; они не зависят от других частей исходного кода Manticore.

Внутри вашей UDF вы **должны** реализовать и экспортировать всего пару функций. Во-первых, для контроля версии интерфейса UDF вы **должны** определить функцию `int LIBRARYNAME_ver()`, где LIBRARYNAME — имя вашей библиотеки, которая должна возвращать `SPH_UDF_VERSION` (значение, определённое в `sphinxudf.h`). Вот пример.

```c
#include <sphinxudf.h>

// our library will be called udfexample.so, thus, so it must define
// a version function named udfexample_ver()
int udfexample_ver()
{
    return SPH_UDF_VERSION;
}
```

Эта мера предосторожности защищает вас от случайной загрузки библиотеки с несовпадающей версией интерфейса UDF в более новую или старую версию `searchd`. Во-вторых, вы **должны** также реализовать саму функцию.

```c
sphinx_int64_t testfunc ( SPH_UDF_INIT * init, SPH_UDF_ARGS * args, char * error_flag )
{
    return 123;
}
```

Имена функций UDF в SQL не чувствительны к регистру. Однако соответствующие имена C функций чувствительны; они должны быть обязательно *в нижнем регистре*, иначе UDF не загрузится. Ещё важнее, что:

1. соглашение о вызове должно быть C (также известное как __cdecl),
2. список аргументов должен точно соответствовать ожиданиям системы плагинов,
3. тип возвращаемого значения должен совпадать с указанным в `CREATE FUNCTION`.

К сожалению, у нас нет (простого) способа проверить эти ошибки при загрузке функции, и они могут привести к сбою сервера и/или неожиданным результатам. Наконец, все реализуемые C функции должны быть потокобезопасны.

Первый аргумент, указатель на структуру `SPH_UDF_INIT`, фактически является указателем на состояние нашей функции. Он является необязательным. В приведённом выше примере функция статeless, так как она просто возвращает 123 при каждом вызове. Поэтому мы не обязаны определять функцию инициализации и можем просто игнорировать этот аргумент.
Этот аргумент служит ещё одной цели. Поскольку один запрос может выполняться на нескольких потоках (см. [pseudo-sharding](../../Server_settings/Searchd.md#pseudo_sharding)), демон пытается определить, является ли UDF с состоянием или без состояния, проверяя этот аргумент. Если аргумент инициализирован, параллельное выполнение будет отключено. Таким образом, если ваша UDF имеет состояние, но вы не используете этот аргумент, она будет вызываться из нескольких потоков, и ваш код должен это учитывать.

Второй аргумент, указатель на `SPH_UDF_ARGS`, является самым важным. Все фактические аргументы вызова передаются в вашу UDF через эту структуру; она содержит количество аргументов, имена, типы и так далее. Поэтому, вызывается ли ваша функция как `SELECT id, testfunc(1)` или как `SELECT id, testfunc('abc', 1000*id+gid, WEIGHT())` или любым другим способом, она будет получать ту же самую структуру `SPH_UDF_ARGS` в любом случае. Однако данные, передаваемые в структуре `args`, будут различными. В первом примере `args->arg_count` будет равно 1, во втором примере — 3, и массив `args->arg_types` будет содержать данные разных типов и т.д.

Наконец, третий аргумент — это флаг ошибки. UDF может поднять его, чтобы указать на возникновение внутренней ошибки, из-за которой UDF не может продолжить работу, и запрос должен быть прерван досрочно. Вы не должны использовать этот флаг для проверок типов аргументов или для любого другого сообщения об ошибках, которые вероятны при нормальном использовании. Этот флаг предназначен для сообщений о внезапных критических ошибках выполнения, например, нехватке памяти.

Если бы мы хотели, например, выделить временное хранилище для использования функцией или проверить заранее, соответствуют ли аргументы поддерживаемым типам, нам потребовалось бы добавить ещё две функции — для инициализации и деинициализации UDF соответственно.

```c
int testfunc_init ( SPH_UDF_INIT * init, SPH_UDF_ARGS * args,
    char * error_message )
{
    // allocate and initialize a little bit of temporary storage
    init->func_data = malloc ( sizeof(int) );
    *(int*)init->func_data = 123;

    // return a success code
    return 0;
}

void testfunc_deinit ( SPH_UDF_INIT * init )
{
    // free up our temporary storage
    free ( init->func_data );
}
```

Обратите внимание, что `testfunc_init()` также получает структуру аргументов вызова. К моменту вызова оно не получает никаких фактических значений, поэтому `args->arg_values` будет NULL. Но имена и типы аргументов известны и будут переданы. Вы можете проверить их в функции инициализации и вернуть ошибку, если они имеют неподдерживаемый тип.


## Типы SPH_UDF_ARGS

UDF могут получать аргументы практически любого действительного внутреннего типа Manticore. Обратитесь к перечислению `sphinx_udf_argtype` в `sphinxudf.h` для полного списка. Большинство типов соответствует соответствующим типам C.

Наиболее заметным типом является тип аргумента `SPH_UDF_TYPE_FACTORS`. Вы получаете этот тип, вызывая свою UDF с аргументом [PACKEDFACTOR()](../../Functions/Searching_and_ranking_functions#PACKEDFACTORS()). Его данные — это бинарный блок в определенном внутреннем формате, и для извлечения отдельных сигналов ранжирования из этого блока необходимо использовать любую из двух семейств функций `sphinx_factors_XXX()` или `sphinx_get_YYY_factor()`.

### Функции sphinx_factors_XXX()

Это семейство состоит из 3 функций.

* `sphinx_factors_init()` инициализирует распакованную структуру `SPH_UDF_FACTORS`
* `sphinx_factors_unpack()` распаковывает бинарный блок в структуру `SPH_UDF_FACTORS`
* `sphinx_factors_deinit()` очищает и освобождает `SPH_UDF_FACTORS`.

Сначала нужно вызвать `init()` и `unpack()`, затем можно использовать поля `SPH_UDF_FACTORS`, и в конце необходимо очистить с помощью `deinit()`.

Этот подход простой, но может привести к множеству выделений памяти для каждого обрабатываемого документа, что может быть медленнее.

### Функции sphinx_get_YYY_factor()

Другой интерфейс, состоящий из множества функций `sphinx_get_YYY_factor()`, чуть более многословен в использовании, но обращается к данным блока напрямую и гарантирует отсутствие выделений памяти. Для обеспечения максимальной производительности UDF ранжирования желательно использовать именно этот подход.

## Возвращаемые типы UDF

Что касается возвращаемых типов, UDF в настоящее время могут возвращать одно значение типа INTEGER, BIGINT, FLOAT или STRING. Тип возвращаемого значения C-функции должен быть `sphinx_int64_t`, `sphinx_int64_t`, `double` или `char*` соответственно. В последнем случае вы **должны** использовать функцию `args->fn_malloc` для выделения памяти под возвращаемые строковые значения. Внутри вашей UDF можно использовать что угодно, поэтому пример `testfunc_init()` выше является корректным кодом, даже несмотря на прямое использование malloc(): вы сами управляете этим указателем, он освобождается с помощью соответствующего вызова free(), и все работает нормально. Однако возвращаемые строковые значения управляются Manticore, и у нас есть собственный аллокатор, поэтому для именно возвращаемых значений нужно использовать его.

В зависимости от того, как ваши UDF используются в запросе, основной вызов функции (`testfunc()` в нашем примере) может вызываться в довольно разном объеме и порядке. В частности,

* UDF, упомянутые в WHERE, ORDER BY или GROUP BY, должны и будут вычисляться для каждого совпавшего документа. Они будут вызваны в естественном порядке совпадений.
* без подзапросов UDF, которые могут быть вычислены на самом последнем этапе по итоговому набору результатов, будут вычислены именно так, но до применения клаузы `LIMIT`. Они будут вызваны в порядке набора результатов.
* с подзапросами такие UDF также будут вычисляться после применения внутреннего ограничения `LIMIT`.

Последовательность вызовов остальных функций фиксирована. А именно,

* `testfunc_init()` вызывается один раз при инициализации запроса. Она может вернуть ненулевой код для указания ошибки; в этом случае запрос будет прерван, и будет возвращено сообщение об ошибке из буфера `error_message`.
* `testfunc()` вызывается для каждой подходящей строки (см. выше), когда Manticore нужно вычислить значение UDF. Она также может указать (внутреннюю) ошибку, записав ненулевое значение в байт `error_flag`. В таком случае гарантируется, что она не будет вызвана для следующих строк, и вместо этого будет подставлено значение по умолчанию 0. Manticore может или не может прервать такие запросы досрочно; ни то, ни другое поведение сейчас не гарантируется.
* `testfunc_deinit()` вызывается один раз, когда обработка запроса (в соответствующем шарде таблицы) заканчивается.

<!-- proofread -->

