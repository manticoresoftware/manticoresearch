# UDF

UDF хранятся во внешних динамических библиотеках (.so файлы в UNIX и .dll в Windows системах). Файлы библиотек должны быть размещены в доверенной папке, указанной директивой [plugin_dir](../../Server_settings/Common.md#plugin_dir) по соображениям безопасности: проще защитить одну папку, чем разрешать кому угодно устанавливать произвольный код в `searchd`. Вы можете динамически загружать и выгружать UDF в searchd с помощью SQL операторов [CREATE FUNCTION](../../Extensions/UDFs_and_Plugins/UDF/Creating_a_function.md) и [DROP FUNCTION](../../Extensions/UDFs_and_Plugins/UDF/Deleting_a_function.md) соответственно. Кроме того, вы можете бесшовно перезагружать UDF (и другие плагины) с помощью оператора [RELOAD PLUGINS](../../Extensions/UDFs_and_Plugins/Plugins/Reloading_plugins.md). Manticore отслеживает текущие загруженные функции; каждый раз при создании или удалении UDF `searchd` обновляет своё состояние в файле [sphinxql_state](../../Server_settings/Searchd.md#sphinxql_state) в виде простого SQL скрипта.

UDF являются локальными. Чтобы использовать их в кластере, вы должны разместить одну и ту же библиотеку на всех узлах и выполнить CREATE операторы на каждом узле. Этот процесс может измениться в будущих версиях.

После успешной загрузки UDF вы можете использовать её в ваших SELECT или других операторах так же, как любую встроенную функцию:

```sql
SELECT id, MYCUSTOMFUNC (groupid, authorname), ... FROM myindex
```

Несколько UDF (и других плагинов) могут находиться в одной библиотеке. Библиотека будет загружена только один раз и автоматически выгружена, когда все UDF и плагины в ней будут удалены.

Теоретически, вы можете написать UDF на любом языке, если его компилятор может импортировать стандартные заголовки C и создавать стандартные динамические библиотеки с правильно экспортированными функциями. Однако написание на C++ или обычном C — это путь наименьшего сопротивления. Мы предоставляем пример библиотеки UDF, написанной на обычном C, которая реализует несколько функций (демонстрируя различные техники) вместе с нашим исходным кодом, который можно найти в [src/udfexample.c](https://github.com/manticoresoftware/manticore/blob/master/src/udfexample.c). Этот пример включает заголовочный файл [src/sphinxudf.h](https://github.com/manticoresoftware/manticore/blob/master/src/sphinxudf.h), который содержит определения нескольких структур и типов, связанных с UDF. Для большинства UDF и плагинов достаточно просто использовать `#include "sphinxudf.h"`, как показано в примере. Однако, если вы пишете функцию ранжирования и вам нужно получить доступ к данным сигналов ранжирования (факторов) изнутри UDF, вам также нужно скомпилировать и связать с `src/sphinxudf.c` (доступным в нашем исходном коде), так как *реализации* функций, позволяющих получить доступ к данным сигналов изнутри UDF, находятся в этом файле.

И `sphinxudf.h`, и `sphinxudf.c` являются автономными, поэтому вы можете копировать эти файлы по отдельности; они не зависят от других частей исходного кода Manticore.

Внутри вашей UDF вы **должны** реализовать и экспортировать всего пару функций. Во-первых, для контроля версии интерфейса UDF вы **должны** определить функцию `int LIBRARYNAME_ver()`, где LIBRARYNAME — это имя вашего файла библиотеки, и вы должны возвращать из неё `SPH_UDF_VERSION` (значение, определённое в `sphinxudf.h`). Вот пример.

```c
#include <sphinxudf.h>

// our library will be called udfexample.so, thus, so it must define
// a version function named udfexample_ver()
int udfexample_ver()
{
    return SPH_UDF_VERSION;
}
```

Эта мера предосторожности защищает вас от случайной загрузки библиотеки с несовпадающей версией интерфейса UDF в более новую или старую версию `searchd`. Во-вторых, вы **должны** реализовать и саму функцию.

```c
sphinx_int64_t testfunc ( SPH_UDF_INIT * init, SPH_UDF_ARGS * args, char * error_flag )
{
    return 123;
}
```

Имена функций UDF в SQL нечувствительны к регистру. Однако соответствующие имена функций на C — чувствительны; они должны быть полностью *в нижнем регистре*, иначе UDF не загрузится. Более того, крайне важно, чтобы:

1. соглашение о вызове было C (также известное как __cdecl),
2. список аргументов точно соответствовал ожиданиям системы плагинов, и
3. возвращаемый тип совпадал с тем, который вы указали в `CREATE FUNCTION`.

К сожалению, у нас нет (простого) способа проверить эти ошибки при загрузке функции, и они могут привести к сбою сервера и/или неожиданным результатам. И наконец, все реализованные вами C функции должны быть потокобезопасными.

Первый аргумент, указатель на структуру `SPH_UDF_INIT`, по сути является указателем на состояние нашей функции. Он необязателен. В примере выше функция не имеет состояния, так как просто возвращает 123 при каждом вызове. Поэтому нам не нужно определять функцию инициализации, и мы можем просто игнорировать этот аргумент.
Этот аргумент служит ещё одной цели. Поскольку один запрос может выполняться на нескольких потоках (см. [pseudo-sharding](../../Server_settings/Searchd.md#pseudo_sharding)), демон пытается определить, является ли UDF с состоянием или без, проверяя этот аргумент. Если аргумент инициализирован, параллельное выполнение будет отключено. Таким образом, если ваша UDF имеет состояние, но вы не используете этот аргумент, она будет вызываться из нескольких потоков, и ваш код должен это учитывать.

Второй аргумент, указатель на `SPH_UDF_ARGS`, является самым важным. Все фактические аргументы вызова передаются вашей UDF через эту структуру; она содержит количество аргументов вызова, имена, типы и т.д. Так что, независимо от того, вызывается ли ваша функция как `SELECT id, testfunc(1)` или как `SELECT id, testfunc('abc', 1000*id+gid, WEIGHT())` или любым другим способом, она получит ту же структуру `SPH_UDF_ARGS` во всех этих случаях. Однако данные, передаваемые в структуре `args`, будут разными. В первом примере `args->arg_count` будет равен 1, во втором — 3, и массив `args->arg_types` будет содержать разные типы данных и так далее.

Наконец, третий аргумент — это флаг ошибки. UDF может установить его, чтобы указать, что произошла внутренняя ошибка, UDF не может продолжать работу, и запрос должен быть завершён досрочно. Вы **не должны** использовать этот флаг для проверки типов аргументов или для любой другой обработки ошибок, которые могут возникать в нормальном использовании. Этот флаг предназначен для сообщения о внезапных критических ошибках во время выполнения, таких как нехватка памяти.

Если бы мы хотели, например, выделить временное хранилище для использования нашей функцией или заранее проверить, что аргументы имеют поддерживаемые типы, нам нужно было бы добавить ещё две функции — для инициализации и деинициализации UDF соответственно.

```c
int testfunc_init ( SPH_UDF_INIT * init, SPH_UDF_ARGS * args,
    char * error_message )
{
    // allocate and initialize a little bit of temporary storage
    init->func_data = malloc ( sizeof(int) );
    *(int*)init->func_data = 123;

    // return a success code
    return 0;
}

void testfunc_deinit ( SPH_UDF_INIT * init )
{
    // free up our temporary storage
    free ( init->func_data );
}
```

Обратите внимание, что `testfunc_init()` также получает структуру аргументов вызова. К моменту его вызова он не получает никаких фактических значений, поэтому `args->arg_values` будет NULL. Но имена и типы аргументов известны и будут переданы. Вы можете проверить их в функции инициализации и вернуть ошибку, если они имеют неподдерживаемый тип.


## Типы SPH_UDF_ARGS

UDF могут принимать аргументы практически любого допустимого внутреннего типа Manticore. Полный список смотрите в перечислении `sphinx_udf_argtype` в `sphinxudf.h`. Большинство типов напрямую соответствуют соответствующим типам C.

Самый примечательный тип — это тип аргумента `SPH_UDF_TYPE_FACTORS`. Вы получаете этот тип, вызывая ваш UDF с аргументом [PACKEDFACTOR()](../../Functions/Searching_and_ranking_functions#PACKEDFACTORS()). Его данные — это бинарный блок в определённом внутреннем формате, и чтобы извлечь отдельные сигналы ранжирования из этого блока, нужно использовать либо одну из двух семейств функций `sphinx_factors_XXX()` или `sphinx_get_YYY_factor()`.

### Функции sphinx_factors_XXX()

Это семейство состоит из 3 функций.

* `sphinx_factors_init()` инициализирует распакованную структуру `SPH_UDF_FACTORS`
* `sphinx_factors_unpack()` распаковывает бинарный блок в структуру `SPH_UDF_FACTORS`
* `sphinx_factors_deinit()` очищает и освобождает `SPH_UDF_FACTORS`.

Сначала нужно вызвать `init()` и `unpack()`, затем можно использовать поля `SPH_UDF_FACTORS`, и в конце нужно очистить с помощью `deinit()`.

Этот подход простой, но может привести к множеству выделений памяти для каждого обрабатываемого документа, что может быть медленно.

### Функции sphinx_get_YYY_factor()

Другой интерфейс, состоящий из множества функций `sphinx_get_YYY_factor()`, немного более многословен в использовании, но обращается к данным блока напрямую и гарантирует отсутствие выделений памяти. Для максимальной производительности ранжирования UDF рекомендуется использовать этот подход.

## Возвращаемые типы UDF

Что касается возвращаемых типов, UDF в настоящее время могут возвращать одно значение INTEGER, BIGINT, FLOAT или STRING. Тип возвращаемого значения C-функции должен быть соответственно `sphinx_int64_t`, `sphinx_int64_t`, `double` или `char*`. В последнем случае вы **должны** использовать функцию `args->fn_malloc` для выделения памяти под возвращаемые строковые значения. Внутри вашего UDF вы можете использовать что угодно, поэтому пример `testfunc_init()` выше является корректным кодом, даже если он использует malloc() напрямую: вы сами управляете этим указателем, он освобождается с помощью соответствующего вызова free(), и всё в порядке. Однако возвращаемые строковые значения управляются Manticore, и у нас есть собственный аллокатор, поэтому для возвращаемых значений нужно использовать именно его.

В зависимости от того, как ваши UDF используются в запросе, основной вызов функции (`testfunc()` в нашем примере) может вызываться в довольно разном объёме и порядке. В частности,

* UDF, используемые в WHERE, ORDER BY или GROUP BY, должны и будут вычисляться для каждого совпадающего документа. Они будут вызываться в естественном порядке совпадений.
* без подзапросов UDF, которые могут быть вычислены на самом последнем этапе по итоговому набору результатов, будут вычислены именно так, но до применения условия `LIMIT`. Они будут вызываться в порядке набора результатов.
* с подзапросами такие UDF также будут вычислены после применения внутреннего условия `LIMIT`.

Последовательность вызовов остальных функций фиксирована. А именно,

* `testfunc_init()` вызывается один раз при инициализации запроса. Она может вернуть ненулевой код для указания ошибки; в этом случае запрос будет прерван, и будет возвращено сообщение об ошибке из буфера `error_message`.
* `testfunc()` вызывается для каждой подходящей строки (см. выше), когда Manticore нужно вычислить значение UDF. Она также может указать (внутреннюю) ошибку, записав ненулевое значение байта в `error_flag`. В этом случае гарантируется, что она не будет вызвана для последующих строк, и вместо этого будет подставлено значение по умолчанию 0. Manticore может как завершить такие запросы досрочно, так и не сделать этого; в настоящее время ни одно из поведений не гарантируется.
* `testfunc_deinit()` вызывается один раз при завершении обработки запроса (в данном шарде таблицы).

<!-- proofread -->

