# UDF

UDF хранятся во внешних динамических библиотеках (.so файлы в UNIX и .dll в Windows). Файлы библиотек должны находиться в доверенной папке, указанной директивой [plugin_dir](../../Server_settings/Common.md#plugin_dir) по соображениям безопасности: проще защитить одну папку, чем разрешить кому-либо устанавливать произвольный код в `searchd`. Вы можете динамически загружать и выгружать UDF в searchd, используя SQL-операторы [CREATE FUNCTION](../../Extensions/UDFs_and_Plugins/UDF/Creating_a_function.md) и [DROP FUNCTION](../../Extensions/UDFs_and_Plugins/UDF/Deleting_a_function.md) соответственно. Кроме того, вы можете без труда перезагрузить UDF (и другие плагины) с помощью оператора [RELOAD PLUGINS](../../Extensions/UDFs_and_Plugins/Plugins/Reloading_plugins.md). Manticore отслеживает сейчас загруженные функции; каждый раз, когда вы создаете или удаляете UDF, `searchd` обновляет свое состояние в файле [sphinxql_state](../../Server_settings/Searchd.md#sphinxql_state) в виде обычного SQL-скрипта.

UDF являются локальными. Чтобы использовать их в кластере, вы должны разместить ту же библиотеку на всех узлах и выполнить операторы CREATE на каждом узле так же. Этот процесс может измениться в будущих версиях.

После успешной загрузки UDF вы можете использовать его в своем SELECT или других операторах так же, как любую встроенную функцию:

```sql
SELECT id, MYCUSTOMFUNC (groupid, authorname), ... FROM myindex
```

Несколько UDF (и других плагинов) могут находиться в одной библиотеке. Библиотека будет загружена только один раз и автоматически выгружена, как только все UDF и плагины внутри нее будут удалены.

В теории, вы можете написать UDF на любом языке, при условии, что его компилятор может импортировать стандартные заголовочные файлы C и генерировать стандартные динамические библиотеки с правильно экспортируемыми функциями. Тем не менее, написание на C++ или простом C — это путь наименьшего сопротивления. Мы предоставляем пример библиотеки UDF, написанной на простом C, которая реализует несколько функций (демонстрируя различные техники) вместе с нашим исходным кодом, который можно найти по адресу [src/udfexample.c](https://github.com/manticoresoftware/manticore/blob/master/src/udfexample.c). Этот пример включает заголовочный файл [src/sphinxudf.h](https://github.com/manticoresoftware/manticore/blob/master/src/sphinxudf.h), который содержит определения нескольких структур и типов, связанных с UDF. Для большинства UDF и плагинов достаточно просто использовать `#include "sphinxudf.h"` как показано в примере. Однако, если вы пишете функцию ранжирования и вам нужно получить доступ к данным о сигналах ранжирования (факторы) изнутри UDF, вам также потребуется скомпилировать и связать с `src/sphinxudf.c` (доступным в нашем исходном коде), так как *реализации* функций, которые позволяют вам получить доступ к данным сигналов изнутри UDF, находятся в этом файле.

Как заголовочный файл `sphinxudf.h`, так и `sphinxudf.c` являются самостоятельными, так что вы можете скопировать эти файлы индивидуально; они не зависят от каких-либо других частей исходного кода Manticore.

Внутри вашего UDF вы **должны** реализовать и экспортировать только пару функций. Во-первых, для контроля версии интерфейса UDF, вы **должны** определить функцию `int LIBRARYNAME_ver()`, где LIBRARYNAME — это имя вашего файла библиотеки, и вы должны вернуть `SPH_UDF_VERSION` (значение, определенное в `sphinxudf.h`) из нее. Вот пример.

```c
#include <sphinxudf.h>

// наша библиотека будет называться udfexample.so, следовательно, она должна определить
// функцию версии с именем udfexample_ver()
int udfexample_ver()
{
    return SPH_UDF_VERSION;
}
```

Эта мера предосторожности защищает вас от случайной загрузки библиотеки с несовместимой версией интерфейса UDF в более новую или старую `searchd`. Во-вторых, вы **должны** также реализовать саму функцию.

```c
sphinx_int64_t testfunc ( SPH_UDF_INIT * init, SPH_UDF_ARGS * args, char * error_flag )
{
    return 123;
}
```

Имена функций UDF в SQL нечувствительны к регистру. Однако соответствующие имена C-функций не таковы; они должны быть все *строчными*, или UDF не загрузится. Более важно, что:

1. соглашение о вызовах — это C (также известное как __cdecl),
2. список аргументов точно соответствует ожиданиям системы плагинов и
3. тип возвращаемого значения соответствует тому, который вы указываете в `CREATE FUNCTION`.

К сожалению, нет (простого) способа для нас проверить эти ошибки при загрузке функции, и они могут привести к сбоям сервера и/или неожиданным результатам. И наконец, все C-функции, которые вы реализуете, должны быть защищены от потоков.

Первый аргумент, указатель на структуру `SPH_UDF_INIT`, по сути, является указателем на состояние нашей функции. Он является необязательным. В приведенном выше примере функция не имеет состояния, так как она просто возвращает 123 каждый раз, когда она вызывается. Следовательно, нам не нужно определять функцию инициализации, и мы можем просто игнорировать этот аргумент.
Этот аргумент служит еще одной цели. Поскольку один запрос может выполняться на нескольких потоках (см. [псевдо-репликацию](../Server_settings/Searchd.md#pseudo_sharding)), демон пытается определить, является ли UDF состоянием или без состояния, проверяя этот аргумент. Если аргумент инициализирован, параллельное выполнение будет отключено. Следовательно, если ваш UDF является состоянием, но вы не используете этот аргумент, он будет вызываться из нескольких потоков, и ваш код должен быть об этом осведомлен.

Второй аргумент, указатель на `SPH_UDF_ARGS`, является самым важным. Все фактические аргументы вызова передаются вашему UDF через эту структуру; она содержит количество аргументов вызова, имена, типы и т. д. Так что, независимо от того, вызывается ли ваша функция как `SELECT id, testfunc(1)` или как `SELECT id, testfunc('abc', 1000*id+gid, WEIGHT())` или любым другим способом, она будет получать одну и ту же структуру `SPH_UDF_ARGS` во всех этих случаях. Однако данные, переданные в структуре `args`, будут разными. В первом примере `args->arg_count` будет равен 1, во втором примере он будет равен 3, и массив `args->arg_types` будет содержать данные о различных типах и так далее.
Наконец, третий аргумент - это флаг ошибки. UDF может вызвать его, чтобы указать, что произошла какая-то внутренняя ошибка, функция не может продолжаться, и запрос должен завершиться досрочно. Вы **не** должны использовать его для проверки типов аргументов или для какой-либо другой отчетности об ошибках, которая может произойти при нормальном использовании. Этот флаг предназначен для сообщения о внезапных критических ошибках времени выполнения, таких как нехватка памяти.

Если бы мы хотели, например, выделить временное хранилище для нашей функции или заранее проверить, являются ли аргументы поддерживаемыми типами, нам пришлось бы добавить еще две функции, для инициализации и деинициализации UDF соответственно.

```c
int testfunc_init ( SPH_UDF_INIT * init, SPH_UDF_ARGS * args,
    char * error_message )
{
    // выделить и инициализировать немного временного хранилища
    init->func_data = malloc ( sizeof(int) );
    *(int*)init->func_data = 123;

    // вернуть код успеха
    return 0;
}

void testfunc_deinit ( SPH_UDF_INIT * init )
{
    // освободить наше временное хранилище
    free ( init->func_data );
}
```

Обратите внимание, как `testfunc_init()` также получает структуру аргументов вызова. К моменту его вызова он не получает никаких фактических значений, поэтому `args->arg_values` будет NULL. Но имена и типы аргументов известны и будут переданы. Вы можете проверить их в функции инициализации и вернуть ошибку, если они имеют неподдерживаемый тип.


## Типы SPH_UDF_ARGS

UDF могут получать аргументы практически любого допустимого внутреннего типа Manticore. Обратитесь к перечислению `sphinx_udf_argtype` в `sphinxudf.h` для полного списка. Большинство типов напрямую отображаются на соответствующие типы C.

Наиболее примечательный тип - тип аргумента `SPH_UDF_TYPE_FACTORS`. Вы получаете этот тип, вызывая свой UDF с аргументом [PACKEDFACTOR()](../../searching-and-ranking-functions#PACKEDFACTORS()). Его данные представляют собой бинарный блоб в определенном внутреннем формате, и для извлечения отдельных сигналов ранжирования из этого блоба вам нужно использовать либо семейство функций `sphinx_factors_XXX()`, либо `sphinx_get_YYY_factor()`.

### Функции sphinx_factors_XXX()

Это семейство состоит из 3 функций.

* `sphinx_factors_init()` инициализирует распакованную структуру `SPH_UDF_FACTORS`
* `sphinx_factors_unpack()` распаковывает бинарный блоб в структуру `SPH_UDF_FACTORS`
* `sphinx_factors_deinit()` очищает и освобождает `SPH_UDF_FACTORS`.

Сначала вам нужно вызвать `init()` и `unpack()`, затем вы можете использовать поля `SPH_UDF_FACTORS`, и наконец, вам нужно освободить ресурсы с помощью `deinit()`.

Этот подход прост, но может привести к множеству выделений памяти для каждого обработанного документа, что может быть медленным.

### Функции sphinx_get_YYY_factor()

Другой интерфейс, состоящий из набора функций `sphinx_get_YYY_factor()`, немного более многословен в использовании, но напрямую обращается к данным блоба и гарантирует отсутствие выделений. Для высокой производительности UDF ранжирования вы захотите использовать именно этот подход.

## Возвращаемые типы UDF

Что касается возвращаемых типов, UDF в настоящее время могут возвращать одно значение типа INTEGER, BIGINT, FLOAT или STRING. Тип возвращаемой функции C должен быть `sphinx_int64_t`, `sphinx_int64_t`, `double` или `char*` соответственно. В последнем случае вы **обязаны** использовать функцию `args->fn_malloc` для выделения места для возвращаемых строковых значений. Внутри вашего UDF вы можете использовать что угодно, поэтому приведенный выше пример `testfunc_init()` является корректным кодом, даже если он напрямую использует malloc(): вы сами управляете этим указателем, он освобождается с помощью соответствующего вызова free(), и все хорошо. Однако возвращаемые строковые значения управляются Manticore, и у нас есть собственный распределитель, поэтому для возвращаемых значений вам тоже нужно его использовать.

В зависимости от того, как используются ваши UDF в запросе, основной вызов функции (`testfunc()` в нашем примере) может вызываться в совершенно разном объеме и порядке. В частности,

* UDF, указанные в предложениях WHERE, ORDER BY или GROUP BY, должны и будут вычисляться для каждого найденного документа. Они будут вызываться в естественном порядке совпадения.
* без подзапросов UDF, которые могут быть вычислены на самом последнем этапе над окончательным результирующим набором, будут вычисляться именно так, но перед применением предложения `LIMIT`. Они будут вызываться в порядке результирующего набора.
* с подзапросами такие UDF также будут вычисляться после применения внутреннего предложения `LIMIT`.

Последовательность вызова других функций, однако, фиксирована. А именно,

* `testfunc_init()` вызывается один раз при инициализации запроса. Он может вернуть ненулевой код, чтобы указать на сбой; в этом случае запрос будет завершен, и будет возвращено сообщение об ошибке из буфера `error_message`.
* `testfunc()` вызывается для каждой подходящей строки (см. выше), когда Manticore должен вычислить значение UDF. Он также может указать на (внутреннюю) ошибку, записав ненулевое значение байта в `error_flag`. В этом случае гарантируется, что он не будет вызван для последующих строк, и будет подставлено значение возврата по умолчанию 0. Manticore может или не может выбрать досрочное завершение таких запросов; текущее поведение не гарантируется.
* `testfunc_deinit()` вызывается один раз по окончании обработки запроса (в данном сегменте таблицы).

<!-- проверено -->

