# UDF и Плагины


Manticore можно расширить с помощью пользовательских функций, или UDF (от англ. User-Defined Functions), следующим образом:


```sql

SELECT id, attr1, myudf (attr2, attr3+attr4) ...

```


Вы можете динамически загружать и выгружать UDF в `searchd`, не перезапуская сервер, и использовать их в выражениях при поиске, ранжировании и т. д. Краткое резюме возможностей UDF выглядит следующим образом:


* UDF могут принимать аргументы целого числа (как 32-битного, так и 64-битного), плавающей запятой, строки, MVA или `PACKEDFACTORS()`.

* UDF могут возвращать значения целого числа, плавающей запятой или строки.

* UDF могут проверять количество аргументов, их типы и названия в фазе подготовки запроса и вызывать ошибки.


Мы пока не поддерживаем агрегатные функции. Другими словами, ваши UDF будут вызываться только для одного документа за один раз и должны возвращать некоторое значение для этого документа. Написание функции, которая может вычислить агрегатное значение, такое как AVG(), для всей группы документов с одинаковым ключом GROUP BY, пока невозможно. Однако вы можете использовать UDF в встроенных агрегатных функциях: то есть, даже если MYCUSTOMAVG() пока не поддерживается, AVG(MYCUSTOMFUNC()) должна работать отлично!


UDF предлагают широкий спектр применений, таких как:


* внедрение пользовательских математических или строковых функций;

* доступ к базам данных или файлам из Manticore;

* создание сложных функций ранжирования.


## Плагины


Плагины предлагают дополнительные возможности для расширения функциональности поиска. В настоящее время их можно использовать для вычисления пользовательских рангов и токенизации документов и запросов.


Вот полный список типов плагинов:


* плагины UDF (по сути, UDF, но так как они подключены, они также называются «плагинами UDF»)

* плагины ранжирования

* плагины фильтра токенов времени индексации

* плагины фильтра токенов времени запроса


Этот раздел охватывает общий процесс написания и управления плагинами; специфика, связанная с созданием различных типов плагинов, рассматривается в соответствующих подразделах.


Итак, как написать и использовать плагин? Вот быстрый четырехэтапный гайд:


* создайте динамическую библиотеку (либо .so, либо .dll), скорее всего, используя C или C++;

* загрузите плагин в searchd с помощью [CREATE PLUGIN](../../Extensions/UDFs_and_Plugins/Plugins/Creating_a_plugin.md);

* используйте плагин с помощью специфических для плагина вызовов (обычно через специальные OPTIONS).

* выгружайте или перезагружайте плагин с помощью [DROP PLUGIN](../../Extensions/UDFs_and_Plugins/Plugins/Deleting_a_plugin.md) и [RELOAD PLUGINS](../../Extensions/UDFs_and_Plugins/Plugins/Reloading_plugins.md) соответственно.


Обратите внимание, что хотя UDF являются полноценными плагинами, они устанавливаются с использованием отдельного оператора [CREATE FUNCTION](../../Extensions/UDFs_and_Plugins/UDF/Creating_a_function.md). Это позволяет четко указать тип возвращаемого значения, не жертвуя обратной совместимостью и не меняя синтаксис.


Динамические плагины поддерживаются в потоках и работниках пула потоков. Несколько плагинов (и/или UDF) могут быть содержимыми в одном файле библиотеки. Вы можете либо сгруппировать все специфические для проекта плагины в одной большой библиотеке, либо создать отдельную библиотеку для каждого UDF и плагина; это на ваше усмотрение.


Как и с UDF, вам следует включить заголовочный файл `src/sphinxudf.h`. По крайней мере, вам понадобится константа `SPH_UDF_VERSION`, чтобы реализовать соответствующую функцию версии. В зависимости от конкретного типа плагина вам может потребоваться или не потребоваться связывать ваш плагин с `src/sphinxudf.c`. Тем не менее, все функции, реализованные в `sphinxudf.c`, связаны с распаковкой `PACKEDFACTORS()` blob, и ни одному типу плагина не предоставлен доступ к этим данным. Поэтому в настоящее время связывание только с заголовком должно быть достаточным. (На самом деле, если вы скопируете номер версии UDF, вам даже не понадобится заголовочный файл для некоторых типов плагинов.)


Формально, плагины — это просто наборы функций C, которые соответствуют определенному шаблону именования. Обычно требуется определить одну ключевую функцию для основной задачи, но вы также можете определить дополнительные функции. Например, чтобы реализовать ранжирующий алгоритм под названием "myrank", вы должны определить функцию `myrank_finalize()`, которая возвращает значение ранга. Тем не менее, вы также можете определить функции `myrank_init()`, `myrank_update()` и `myrank_deinit()`. Конкретные наборы известных суффиксов и аргументов вызова различаются в зависимости от типа плагина, но _init() и _deinit() являются общими, и каждый плагин имеет их. Подсказка: для быстрого справочника по известным суффиксам и их типам аргументов обратитесь к `sphinxplugin.h`, где прототипы вызовов определены в начале файла.

