# UDFs and Plugins

Manticore может быть расширен с помощью пользовательских функций, или UDF (User-Defined Functions) для краткости, следующим образом:

```sql
SELECT id, attr1, myudf (attr2, attr3+attr4) ...
```

Вы можете динамически загружать и выгружать UDF в `searchd` без необходимости перезапуска сервера, и использовать их в выражениях при поиске, ранжировании и т.д. Краткое описание возможностей UDF:

* UDF могут принимать аргументы типа integer (как 32-битные, так и 64-битные), float, string, MVA или `PACKEDFACTORS()`.
* UDF могут возвращать значения типа integer, float или string.
* UDF могут проверять номер, типы и имена аргументов во время стадии настройки запроса и генерировать ошибки.

В настоящее время агрегатные функции не поддерживаются. Другими словами, ваши UDF вызываются только для одного документа за раз и должны возвращать некоторое значение для этого документа. Написать функцию, которая может вычислить агрегатное значение, например AVG() для всей группы документов, имеющих одинаковый ключ GROUP BY, пока невозможно. Однако вы можете использовать UDF внутри встроенных агрегатных функций: другими словами, хотя MYCUSTOMAVG() пока не поддерживается, AVG(MYCUSTOMFUNC()) должна работать без проблем!

UDF предоставляют широкий спектр применений, таких как:

* внедрение собственных математических или строковых функций;
* доступ к базам данных или файлам внутри Manticore;
* создание сложных функций ранжирования.

## Плагины

Плагины предоставляют дополнительные возможности для расширения функциональности поиска. В настоящий момент их можно использовать для вычисления пользовательских ранжировок и токенизации документов и запросов.

Вот полный список типов плагинов:

* UDF плагины (фактически UDF, но поскольку они подключаются как плагины, их также называют «UDF плагинами»)
* ранжировочные плагины
* плагины фильтрации токенов на этапе индексирования
* плагины фильтрации токенов на этапе запроса

В этом разделе рассматривается общий процесс написания и управления плагинами; особенности создания разных типов плагинов обсуждаются в соответствующих подразделах.

Итак, как написать и использовать плагин? Вот краткое руководство из четырёх шагов:

* создать динамическую библиотеку (.so или .dll), скорее всего, используя C или C++;
* загрузить плагин в searchd с помощью [CREATE PLUGIN](../../Extensions/UDFs_and_Plugins/Plugins/Creating_a_plugin.md);
* использовать плагин с помощью специализированных вызовов (обычно через специальные OPTIONS);
* выгрузить или перезагрузить плагин с помощью [DROP PLUGIN](../../Extensions/UDFs_and_Plugins/Plugins/Deleting_a_plugin.md) и [RELOAD PLUGINS](../../Extensions/UDFs_and_Plugins/Plugins/Reloading_plugins.md) соответственно.

Обратите внимание, что хотя UDF являются полноценными плагинами, они устанавливаются с помощью отдельного выражения [CREATE FUNCTION](../../Extensions/UDFs_and_Plugins/UDF/Creating_a_function.md). Это позволяет аккуратно указать тип возвращаемого значения, не жертвуя обратной совместимостью и не меняя синтаксис.

Динамические плагины поддерживаются в потоках и в работниках thread_pool. Несколько плагинов (и/или UDF) могут содержаться в одном файле библиотеки. Вы можете либо сгруппировать все проектные плагины в одну большую библиотеку, либо создать отдельную библиотеку для каждого UDF и плагина; выбор за вами.

Как и с UDF, вы должны включить заголовочный файл `src/sphinxudf.h`. По крайней мере, вам понадобится константа `SPH_UDF_VERSION` для реализации функции версии. В зависимости от типа плагина, возможно, не потребуется линковать плагин с `src/sphinxudf.c`. Тем не менее, все функции, реализованные в `sphinxudf.c`, связаны с распаковкой blob`а `PACKEDFACTORS()`, и ни один тип плагина не имеет доступа к этим данным. Поэтому на данный момент достаточно линковки только с заголовочным файлом. (Фактически, если вы просто скопируете номер версии UDF, в некоторых типах плагинов даже заголовочный файл не понадобится.)

Формально плагины — это просто наборы функций на C, соответствующих определённому шаблону именования. Обычно требуется определить одну ключевую функцию для основной задачи, но можно определять и дополнительные функции. Например, чтобы реализовать ранжировщик с именем "myrank", нужно определить функцию `myrank_finalize()`, возвращающую значение ранга. Также можно определить функции `myrank_init()`, `myrank_update()` и `myrank_deinit()`. Специфические наборы известных суффиксов и аргументов для вызовов зависят от типа плагина, но `_init()` и `_deinit()` являются универсальными, и каждый плагин их имеет. Подсказка: для быстрой справки о суффиксах и типах аргументов обратитесь к `sphinxplugin.h`, где прототипы вызовов определены в начале файла.

Хотя публичный интерфейс определён на чистом C, наши плагины фактически следуют *объектно-ориентированной модели*. Действительно, каждая функция `_init()` получает выходной параметр `void ** userdata`, и значение указателя, сохранённого в `(*userdata)`, далее передаётся как первый аргумент во все остальные функции плагина. Поэтому можно рассматривать плагин как *класс*, экземпляр которого создаётся каждый раз, когда требуется объект этого класса для обработки запроса: указатель `userdata` служит указателем `this`; функции — методами, а `_init()` и `_deinit()` — конструктором и деструктором соответственно.

Это небольшое осложнение OOP на C возникает потому, что плагины работают в многопоточной среде, и некоторым нужно сохранять состояние. Вы не можете хранить это состояние в глобальной переменной в вашем плагине, поэтому мы передаём параметр userdata, что естественно приводит к модели ООП. Если ваш плагин простой и без состояния, интерфейс позволяет опустить `_init()`, `_deinit()` и любые другие функции.

Подытожим, вот самый простой полный ранжировочный плагин всего в три строки кода на C:

```c
// gcc -fPIC -shared -o myrank.so myrank.c
#include "sphinxudf.h"
int myrank_ver() { return SPH_UDF_VERSION; }
int myrank_finalize(void *u, int w) { return 123; }
```

Вот как использовать простой ранжировочный плагин:

```sql
mysql> CREATE PLUGIN myrank TYPE 'ranker' SONAME 'myrank.dll';
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT id, weight() FROM test1 WHERE MATCH('test') OPTION ranker=myrank('');
+------+----------+
| id   | weight() |
+------+----------+
|    1 |      123 |
|    2 |      123 |
+------+----------+
2 rows in set (0.01 sec)
```
<!-- proofread -->


