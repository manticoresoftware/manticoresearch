# Массивы и функции условий

### ALL()
<!-- example all_json -->
`ALL(cond FOR var IN json.array)` применяется к JSON массивам и возвращает 1, если условие истинно для всех элементов в массиве, и 0 в противном случае. `cond` - это общее выражение, которое также может использовать `var` как текущее значение элемента массива внутри себя.

<!-- request ALL() with json -->
```sql
select *, ALL(x>0 AND x<4 FOR x IN j.ar) from tbl
```

<!-- response ALL() with json -->
```sql
+------+--------------+--------------------------------+
| id   | j            | all(x>0 and x<4 for x in j.ar) |
+------+--------------+--------------------------------+
|    1 | {"ar":[1,3]} |                              1 |
|    2 | {"ar":[3,7]} |                              0 |
+------+--------------+--------------------------------+
2 rows in set (0.00 sec)
```

<!-- request ALL() with json ex. 2 -->
```sql
select *, ALL(x>0 AND x<4 FOR x IN j.ar) cond from tbl where cond=1
```

<!-- response ALL() with json ex. 2 -->
```sql
+------+--------------+------+
| id   | j            | cond |
+------+--------------+------+
|    1 | {"ar":[1,3]} |    1 |
+------+--------------+------+
1 row in set (0.00 sec)
```

<!-- end -->

<!-- example all_mva -->
`ALL(mva)` - это специальный конструктор для многоценностных атрибутов. Когда он используется с операторами сравнения (включая сравнение с `IN()`), он возвращает 1, если все значения из MVA атрибута найдены среди сравниваемых значений.

<!-- request ALL() with MVA -->
```sql
select * from tbl where all(m) >= 1
```

<!-- response ALL() with MVA -->
```sql
+------+------+
| id   | m    |
+------+------+
|    1 | 1,3  |
|    2 | 3,7  |
+------+------+
2 rows in set (0.00 sec)
```
<!-- request ALL() with MVA and IN() -->
```sql
select * from tbl where all(m) in (1, 3, 7, 10)
```

<!-- response ALL() with MVA and IN() -->
```sql
+------+------+
| id   | m    |
+------+------+
|    1 | 1,3  |
|    2 | 3,7  |
+------+------+
2 rows in set (0.00 sec)
```

<!-- end -->

<!-- example all_not_in -->
Чтобы сравнить MVA атрибут с массивом, избегайте использования `<mva> NOT ALL()`; вместо этого используйте `ALL(<mva>) NOT IN()`.

<!-- request ALL() with MVA and NOT IN() -->
```sql
select * from tbl where all(m) not in (2, 4)
```

<!-- response ALL() with MVA and NOT IN() -->
```sql
+------+------+
| id   | m    |
+------+------+
|    1 | 1,3  |
|    2 | 3,7  |
+------+------+
2 rows in set (0.00 sec)
```

<!-- end -->


<!-- example all_string -->

`ALL(string list)` - это специальная операция для фильтрации строковых тегов.

Если все слова, перечисленные в качестве аргументов `ALL()`, присутствуют в атрибуте, то фильтр срабатывает. Опциональный `NOT` инвертирует логику.

Этот фильтр внутренне использует сопоставление по документам, поэтому в случае запроса полного сканирования он может быть медленнее, чем ожидалось. Он предназначен для атрибутов, которые не индексируются, таких как вычисляемые выражения или теги в PQ таблицах. Если вам нужно такое фильтрация, рассмотрите возможность использования строкового атрибута как поля полнотекстового поиска, а затем используйте оператор полнотекстового поиска `match()`, который вызовет полнотекстовый поиск.

<!-- request ALL() with strings -->
```sql
select * from tbl where tags all('bug', 'release')
```

<!-- response ALL() with strings -->
```
+------+---------------------------+
| id   | tags                      |
+------+---------------------------+
|    1 | bug priority_high release |
|    2 | bug priority_low release  |
+------+---------------------------+
2 rows in set (0.00 sec)
```

<!-- request ALL() with strings and NOT -->
```sql
mysql> select * from tbl

+------+---------------------------+
| id   | tags                      |
+------+---------------------------+
|    1 | bug priority_high release |
|    2 | bug priority_low release  |
+------+---------------------------+
2 rows in set (0.00 sec)

mysql> select * from tbl where tags not all('bug')

Empty set (0.00 sec)
```
<!-- end -->

### ANY()

<!-- example any_json -->
`ANY(cond FOR var IN json.array)` применяется к JSON массивам и возвращает 1, если условие истинно для любого элемента в массиве, и 0 в противном случае. `cond` - это общее выражение, которое также может использовать `var` как текущее значение элемента массива внутри себя.

<!-- request ANY() with json -->
```sql
select *, ANY(x>5 AND x<10 FOR x IN j.ar) from tbl
```

<!-- response ANY() with json -->
```sql
+------+--------------+---------------------------------+
| id   | j            | any(x>5 and x<10 for x in j.ar) |
+------+--------------+---------------------------------+
|    1 | {"ar":[1,3]} |                               0 |
|    2 | {"ar":[3,7]} |                               1 |
+------+--------------+---------------------------------+
2 rows in set (0.00 sec)
```

<!-- request ANY() with json ex. 2 -->
```sql
select *, ANY(x>5 AND x<10 FOR x IN j.ar) cond from tbl where cond=1
```

<!-- response ANY() with json ex. 2 -->
```sql
+------+--------------+------+
| id   | j            | cond |
+------+--------------+------+
|    2 | {"ar":[3,7]} |    1 |
+------+--------------+------+
1 row in set (0.00 sec)
```

<!-- end -->

<!-- example any_mva -->
`ANY(mva)` - это специальный конструктор для многоценностных атрибутов. Когда он используется с операторами сравнения (включая сравнение с `IN()`), он возвращает 1, если любое из значений MVA найдено среди сравниваемых значений.

Когда вы сравниваете массив, используя `IN()`, `ANY()` по умолчанию подразумевается, если не указано иное, но будет выдано предупреждение о недостающем конструкторе.

<!-- request ANY() with MVA -->
```sql
mysql> select * from tbl

+------+------+
```
|    1 | 1,3  |
|    2 | 3,7  |
+------+------+
2 строки в наборе (0,01 сек)

mysql> select * from tbl where any(m) > 5

+------+------+
| id   | m    |
+------+------+
|    2 | 3,7  |
+------+------+
1 строка в наборе (0,00 сек)
```
<!-- request ANY() with MVA and IN() -->
```sql
select * from tbl where any(m) in (1, 7, 10)
```

<!-- response ANY() with MVA and IN() -->
```sql
+------+------+
| id   | m    |
+------+------+
|    1 | 1,3  |
|    2 | 3,7  |
+------+------+
2 строки в наборе (0,00 сек)
```

<!-- end -->

<!-- example any_not_in -->
Чтобы сравнить атрибут MVA с массивом, избегайте использования `<mva> NOT ANY()`; используйте `<mva> NOT IN()` вместо или `ANY(<mva>) NOT IN()`.

<!-- request ANY() with MVA and NOT IN() -->
```sql
mysql> select * from tbl

+------+------+
| id   | m    |
+------+------+
|    1 | 1,3  |
|    2 | 3,7  |
+------+------+
2 строки в наборе (0,00 сек)

mysql> select * from tbl where any(m) not in (1, 3, 5)

+------+------+
| id   | m    |
+------+------+
|    2 | 3,7  |
+------+------+
1 строка в наборе (0,00 сек)
```

<!-- end -->

<!-- example any_string -->

`ANY(string list)` - это специальная операция для фильтрации строковых тегов.

Если какое-либо из слов, перечисленных в аргументах `ANY()`, присутствует в атрибуте, фильтр совпадает. Необязательный `NOT` инвертирует логику.

Этот фильтр внутренне использует сопоставление по документам, поэтому в случае запроса полного сканирования он может работать медленнее, чем ожидалось. Он предназначен для атрибутов, которые не индексируются, таких как вычисляемые выражения или теги в таблицах PQ. Если вам нужно такое фильтровое выражение, рассмотрите решение по помещению строкового атрибута в поле полнотекстового поиска, а затем используйте оператор полнотекстового поиска `match()`, который будет вызывать полнотекстовый поиск.

<!-- request ANY() with strings -->
```sql
select * from tbl where tags any('bug', 'feature')
```

<!-- response ANY() with strings -->
```
+------+---------------------------+
| id   | tags                      |
+------+---------------------------+
|    1 | bug priority_high release |
|    2 | bug priority_low release  |
+------+---------------------------+
2 строки в наборе (0,00 сек)
```

<!-- request ANY() with strings and NOT -->
```sql
select * from tbl
--------------

+------+---------------------------+
| id   | tags                      |
+------+---------------------------+
|    1 | bug priority_high release |
|    2 | bug priority_low release  |
+------+---------------------------+
2 строки в наборе (0,00 сек)

--------------
select * from tbl where tags not any('feature', 'priority_low')
--------------

+------+---------------------------+
| id   | tags                      |
+------+---------------------------+
|    1 | bug priority_high release |
+------+---------------------------+
1 строка в наборе (0,01 сек)
```


<!-- end -->

### CONTAINS()

`CONTAINS(polygon, x, y)` проверяет, находится ли точка (x,y) внутри данного полигона, и возвращает 1, если это верно, или 0, если это неверно. Полифон должен быть задан с помощью функции [POLY2D()](../Functions/Geo_spatial_functions.md#POLY2D%28%29). Первая функция предназначена для «маленьких» полигонов, то есть меньше 500 км (300 миль) с каждой стороны, и не учитывает кривизну Земли для скорости. Для больших расстояний вам следует использовать `GEOPOLY2D`, который разрезает данный полигон на меньшие части, учитывая кривизну Земли.

### IF()

<!-- example if -->
Поведение `IF()` немного отличается от его аналога MySQL. Он принимает 3 аргумента, проверяет, равен ли 1-й аргумент 0,0, возвращает 2-й аргумент, если он не равен нулю, или 3-й, когда равен. Обратите внимание, что в отличие от операторов сравнения, `IF()` **не** использует порог! Поэтому безопасно использовать результаты сравнения в качестве его 1-го аргумента, но арифметические операторы могут давать неожиданные результаты. Например, следующие два вызова произведут *разные* результаты, даже если они логически эквивалентны:

<!-- request IF() -->
```sql
IF ( sqrt(3)*sqrt(3)-3<>0, a, b )
IF ( sqrt(3)*sqrt(3)-3, a, b )
```

<!-- end -->

В первом случае оператор сравнения <> вернет 0,0 (ложь) из-за порога, и `IF()` всегда будет возвращать `**` в качестве результата. Во втором случае то же самое выражение `sqrt(3)*sqrt(3)-3` будет сравниваться с нулем *без* порога самим функцией `IF()`. Тем не менее, его значение будет немного отличаться от нуля из-за ограниченной точности вычислений с плавающей запятой. Из-за этого сравнение с 0,0, выполненное `IF()`, не пройдет, и второй вариант вернет 'a' в качестве результата.

### HISTOGRAM()
<!-- example histogram -->
`HISTOGRAM(expr, {hist_interval=size, hist_offset=value})` принимает размер ведра и возвращает номер ведра для значения. Ключевая функция:
```sql
key_of_the_bucket = interval + offset * floor ( ( value - offset ) / interval )
```
Аргумент гистограммы `interval` должен быть положительным. Аргумент гистограммы `offset` должен быть положительным и меньше `interval`. Он используется в агрегации, `FACET`, и группировке.

<!-- intro -->
Пример:

<!-- request HISTOGRAM() -->
```sql
SELECT COUNT(*),
HISTOGRAM(price, {hist_interval=100}) as price_range
FROM facets
GROUP BY price_range ORDER BY price_range ASC;
```
<!-- end -->

### IN()
`IN(expr,val1,val2,...)` принимает 2 или более аргументов и возвращает 1, если 1-й аргумент (expr) равен любому из других аргументов (val1..valN), или 0 в противном случае. В настоящее время все проверяемые значения (но не само выражение) должны быть постоянными. Константы предварительно отсортированы, и используется бинарный поиск, поэтому `IN()` даже при большом произвольном списке констант будет очень быстрым. Первый аргумент также может быть атрибутом MVA. В этом случае `IN()` вернёт 1, если любое из значений MVA равно любому из других аргументов. `IN()` также поддерживает синтаксис `IN(expr,@uservar)`, чтобы проверить, принадлежит ли значение списку в данном глобальном пользовательском переменной. Первый аргумент может быть атрибутом JSON.

### INDEXOF()
`INDEXOF(cond FOR var IN json.array)` функция проходит через все элементы массива и возвращает индекс первого элемента, для которого 'cond' истинно, и -1, если 'cond' ложно для каждого элемента в массиве.

### INTERVAL()
`INTERVAL(expr,point1,point2,point3,...)` принимает 2 или более аргументов и возвращает индекс аргумента, который меньше первого аргумента: он возвращает 0, если `expr<point1`, 1, если `point1<=expr<point2`, и так далее. Требуется, чтобы `point1<point2<...<pointN` для корректной работы этой функции.

### LENGTH()
`LENGTH(attr_mva)` функция возвращает количество элементов в MVA наборе. Она работает как с 32-битными, так и с 64-битными атрибутами MVA. `LENGTH(attr_json)` возвращает длину поля в JSON. Возвращаемое значение зависит от типа поля. Например, `LENGTH(json_attr.some_int)` всегда возвращает 1, а `LENGTH(json_attr.some_array)` возвращает количество элементов в массиве. `LENGTH(string_expr)` функция возвращает длину строки, полученной из выражения.
[TO_STRING()](../Functions/Type_casting_functions.md#TO_STRING%28%29) должен охватывать выражение, независимо от того, возвращает ли выражение не строку или это просто строковый атрибут.

### RANGE()
<!-- example range -->
`RANGE(expr, {range_from=value,range_to=value})` принимает набор диапазонов и возвращает номер ведра для значения.
Это выражение включает значение `range_from` и исключает значение `range_to` для каждого диапазона. Диапазон может быть открытым - иметь только значение `range_from` или только значение `range_to`. Он используется в агрегации, `FACET` и группировке.

<!-- intro -->
Пример:

<!-- request RANGE() -->
```sql
SELECT COUNT(*),
RANGE(price, {range_to=150},{range_from=150,range_to=300},{range_from=300}) price_range
FROM facets
GROUP BY price_range ORDER BY price_range ASC;
```
<!-- end -->

### REMAP()
<!-- example remap -->
`REMAP(condition, expression, (cond1, cond2, ...), (expr1, expr2, ...))` функция позволяет вам сделать некоторые исключения для значений выражения в зависимости от значений условий. Выражение условия всегда должно приводить к целому числу, в то время как выражение может приводить к целому числу или дробному.

<!-- intro -->
Пример:

<!-- request REMAP() -->
```sql
SELECT id, size, REMAP(size, 15, (5,6,7,8), (1,1,2,2)) s
FROM products
ORDER BY s ASC;
```
<!-- request Another example -->
```sql
SELECT REMAP(userid, karmapoints, (1, 67), (999, 0)) FROM users;
SELECT REMAP(id%10, salary, (0), (0.0)) FROM employes;
```
<!-- end -->

Это разместит документы с размерами 5 и 6 первыми, за ними следуют размеры 7 и 8. Если есть оригинальное значение, не указанное в массиве (например, размер 10), оно вернётся к 15, и в этом случае будет размещено в конце.

<!-- proofread -->

