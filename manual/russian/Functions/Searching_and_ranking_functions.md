# Поиск и функции ранжирования

### BM25A()
`BM25A(k1,b)` возвращает точное значение `BM25A()`. Требует ранжировщика `expr` и включенные `index_field_lengths`. Параметры `k1` и `b` должны быть вещественными числами.

### BM25F()
`BM25F(k1, b, {field=weight, ...})` возвращает точное значение `BM25F()` и требует, чтобы `index_field_lengths` был включен. Также необходим ранжировщик `expr`. Параметры `k1` и `b` должны быть вещественными числами.

### EXIST()
Заменяет несуществующие столбцы значениями по умолчанию. Он возвращает либо значение атрибута, указанного через 'attr-name', либо 'default-value', если этот атрибут не существует. Атрибуты STRING или MVA не поддерживаются. Эта функция полезна при поиске по нескольким таблицам с разными схемами.

```sql
SELECT *, EXIST('gid', 6) as cnd FROM i1, i2 WHERE cnd>5
```

### MIN_TOP_SORTVAL()
Возвращает значение ключа сортировки наихудшего элемента в текущих топ-N совпадениях, если ключ сортировки является вещественным числом, и 0 в противном случае.

### MIN_TOP_WEIGHT()
Возвращает вес наихудшего элемента в текущих топ-N совпадениях.

### PACKEDFACTORS()
`PACKEDFACTORS()` может использоваться в запросах для отображения всех вычисленных весовых факторов во время сопоставления или для предоставления бинарного атрибута для создания пользовательского ранжирования UDF. Эта функция работает только в том случае, если указан ранжировщик выражений и запрос не является полным сканированием; в противном случае она возвращает ошибку. `PACKEDFACTORS()` может принимать необязательный аргумент, который отключает расчет фактора ранжирования ATC: `PACKEDFACTORS({no_atc=1})`. Вычисление ATC значительно замедляет обработку запросов, поэтому этот вариант может быть полезен, если вам нужно увидеть факторы ранжирования, но ATC не требуется. `PACKEDFACTORS()` также может выводить в формате JSON: `PACKEDFACTORS({json=1})`. Соответствующие выходные данные в формате ключ-значение или JSON показаны ниже. (Обратите внимание, что примеры ниже обернуты для удобочитаемости; фактические возвращаемые значения будут однострочными.)

```sql
mysql> SELECT id, PACKEDFACTORS() FROM test1
    -> WHERE MATCH('test one') OPTION ranker=expr('1') \G
*************************** 1\. row ***************************
             id: 1
packedfactors(): bm25=569, bm25a=0.617197, field_mask=2, doc_word_count=2,
    field1=(lcs=1, hit_count=2, word_count=2, tf_idf=0.152356,
        min_idf=-0.062982, max_idf=0.215338, sum_idf=0.152356, min_hit_pos=4,
        min_best_span_pos=4, exact_hit=0, max_window_hits=1, min_gaps=2,
        exact_order=1, lccs=1, wlccs=0.215338, atc=-0.003974),
    word0=(tf=1, idf=-0.062982),
    word1=(tf=1, idf=0.215338)
1 row in set (0.00 sec)
```

```sql
mysql> SELECT id, PACKEDFACTORS({json=1}) FROM test1
    -> WHERE MATCH('test one') OPTION ranker=expr('1') \G
*************************** 1\. row ***************************
                     id: 1
packedfactors({json=1}):
{

    "bm25": 569,
    "bm25a": 0.617197,
    "field_mask": 2,
    "doc_word_count": 2,
    "fields": [
        {
            "lcs": 1,
            "hit_count": 2,
            "word_count": 2,
            "tf_idf": 0.152356,
            "min_idf": -0.062982,
            "max_idf": 0.215338,
            "sum_idf": 0.152356,
            "min_hit_pos": 4,
            "min_best_span_pos": 4,
            "exact_hit": 0,
            "max_window_hits": 1,
            "min_gaps": 2,
            "exact_order": 1,
            "lccs": 1,
            "wlccs": 0.215338,
            "atc": -0.003974
        }
    ],
    "words": [
        {
            "tf": 1,
            "idf": -0.062982
        },
        {
            "tf": 1,
            "idf": 0.215338
        }
    ]

}
1 row in set (0.01 sec)
```

Эта функция может использоваться для реализации пользовательских функций ранжирования в UDF, как в:

```sql
SELECT *, CUSTOM_RANK(PACKEDFACTORS()) AS r
FROM my_index
WHERE match('hello')
ORDER BY r DESC
OPTION ranker=expr('1');
```

Где `CUSTOM_RANK()` - это функция, реализованная в UDF. Она должна объявлять структуру `SPH_UDF_FACTORS` (определенную в sphinxudf.h), инициализировать эту структуру, распаковывать факторы в нее перед использованием и деинициализировать ее после, следующим образом:

```sql
SPH_UDF_FACTORS factors;
sphinx_factors_init(&factors);
sphinx_factors_unpack((DWORD*)args->arg_values[0], &factors);
// ... можно использовать содержимое переменной factors здесь ...
sphinx_factors_deinit(&factors);
```

Данные `PACKEDFACTORS()` доступны на всех этапах запроса, а не только во время первоначального сопоставления и этапа ранжирования. Это открывает еще одно особенно интересное применение `PACKEDFACTORS()`: переранжирование.

В приведенном выше примере мы использовали ранжировщик на основе выражений с фиктивным выражением и отсортировали результирующий набор по значению, вычисленному нашим UDF. Другими словами, мы использовали UDF для ранжирования всех наших результатов. Теперь предположим для примера, что наш UDF очень дорого вычислить, с пропускной способностью всего 10,000 вызовов в секунду. Если наш запрос совпадает с 1,000,000 документами, мы хотели бы использовать гораздо более простое выражение для выполнения большей части нашего ранжирования, чтобы поддерживать разумную производительность. Затем мы применим дорогой UDF только к нескольким верхним результатам, скажем, к 100 наилучшим результатам. Другими словами, мы создадим топ-100 результатов, используя более простую функцию ранжирования, а затем переранжируем их более сложной. Это можно сделать с помощью подзапросов:

```sql
SELECT * FROM (
    SELECT *, CUSTOM_RANK(PACKEDFACTORS()) AS r
    FROM my_index WHERE match('hello')
    OPTION ranker=expr('sum(lcs)*1000+bm25')
    ORDER BY WEIGHT() DESC
    LIMIT 100
) ORDER BY r DESC LIMIT 10
```
В этом примере выражение-ранжер вызывается для каждого найденного документа для вычисления `WEIGHT()`, поэтому оно вызывается 1,000,000 раз. Однако UDF-вычисление может быть отложено до внешней сортировки, и оно будет выполнено только для топ-100 совпадений по `WEIGHT()` согласно внутреннему ограничению. Это означает, что UDF будет вызван только 100 раз. Наконец, выбираются и возвращаются в приложение топ-10 совпадений по значению UDF.

Для справки, в распределенной конфигурации данные `PACKEDFACTORS()` отправляются от агентов к главному узлу в двоичном формате. Это технически делает возможным реализацию дополнительных проходов перегруппировки на главном узле при необходимости.

При использовании в SQL, но не вызываемый из каких-либо UDF, результат `PACKEDFACTORS()` форматируется как обычный текст, который можно использовать для ручной оценки факторов ранжирования. Обратите внимание, что эта функция в настоящее время не поддерживается API Manticore.


### REMOVE_REPEATS()
`REMOVE_REPEATS ( result_set, column, offset, limit )` - удаляет повторяющиеся отрегулированные строки с одинаковым значением 'column'.

```sql
SELECT REMOVE_REPEATS((SELECT * FROM dist1), gid, 0, 10)
```
Обратите внимание, что `REMOVE_REPEATS` не влияет на `total_found` в [метаинформации поискового запроса](../../Node_info_and_management/SHOW_META.md#SHOW-META).

### WEIGHT()
Функция `WEIGHT()` возвращает вычисленную оценку совпадения. Если порядок сортировки не указан, результат сортируется по убыванию по оценке, предоставленной `WEIGHT()`. В этом примере мы сначала упорядочиваем по весу, а затем по целочисленному атрибуту.

Поиск выше выполняет простое совпадение, где должны присутствовать все слова. Однако мы можем сделать больше (и это всего лишь простой пример):

```sql
mysql> SELECT *,WEIGHT() FROM testrt WHERE MATCH('"list of business laptops"/3');
+------+------+-------------------------------------+---------------------------+----------+
| id   | gid  | title                               | content                   | weight() |
+------+------+-------------------------------------+---------------------------+----------+
|    1 |   10 | List of HP business laptops         | Elitebook Probook         |     2397 |
|    2 |   10 | List of Dell business laptops       | Latitude Precision Vostro |     2397 |
|    3 |   20 | List of Dell gaming laptops         | Inspirion Alienware       |     2375 |
|    5 |   30 | List of ASUS ultrabooks and laptops | Zenbook Vivobook          |     2375 |
+------+------+-------------------------------------+---------------------------+----------+
4 rows in set (0.00 sec)


mysql> SHOW META;
+----------------+----------+
| Variable_name  | Value    |
+----------------+----------+
| total          | 4        |
| total_found    | 4        |
| total_relation | eq       |
| time           | 0.000    |
| keyword[0]     | list     |
| docs[0]        | 5        |
| hits[0]        | 5        |
| keyword[1]     | of       |
| docs[1]        | 4        |
| hits[1]        | 4        |
| keyword[2]     | business |
| docs[2]        | 2        |
| hits[2]        | 2        |
| keyword[3]     | laptops  |
| docs[3]        | 5        |
| hits[3]        | 5        |
+----------------+----------+
16 rows in set (0.00 sec)
```

Здесь мы ищем четыре слова, но совпадение может произойти, даже если найдены только три из четырех слов. Поиск будет ранжировать документы, содержащие все слова, выше.

### ZONESPANLIST()
Функция `ZONESPANLIST()` возвращает пары найденных зоновых диапазонов. Каждая пара содержит идентификатор найденного зонового диапазона, двоеточие и порядковый номер найденного зонового диапазона. Например, если в документе написано `<emphasis role="bold"><i>текст</i> the <i>текст</i></emphasis>`, и вы запрашиваете `'ZONESPAN:(i,b) текст'`, то `ZONESPANLIST()` вернет строку `"1:1 1:2 2:1"`, что означает, что первый зоновый диапазон сопоставил "текст" в диапазонах 1 и 2, а второй зоновый диапазон — только в диапазоне 1.

### QUERY()
`QUERY()` возвращает текущий поисковый запрос. `QUERY()` является постлимитным выражением и предназначен для использования с [SNIPPET()](../Functions/String_functions.md#SNIPPET%28%29).

Табличные функции — это механизм постобработки результирующего набора запроса. Табличные функции принимают входной произвольный результирующий набор и возвращают новый обработанный набор. Первым аргументом должен быть входной результирующий набор, но табличная функция может дополнительно принимать и обрабатывать другие аргументы. Табличные функции могут полностью изменить результирующий набор, включая схему. В настоящее время поддерживаются только встроенные табличные функции. Табличные функции работают как для внешних `SELECT`, так и для [вложенных SELECT](../Searching/Sub-selects.md).

<!-- proofread -->

