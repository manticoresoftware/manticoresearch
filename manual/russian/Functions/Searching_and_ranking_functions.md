# Поисковые и ранжирующие функции

### BM25A()
`BM25A(k1,b)` возвращает точное значение `BM25A()`. Требуется ранжировщик `expr` и включённые `index_field_lengths`. Параметры `k1` и `b` должны быть числами с плавающей точкой.

### BM25F()
`BM25F(k1, b, {field=weight, ...})` возвращает точное значение `BM25F()` и требует включённые `index_field_lengths`. Также необходим ранжировщик `expr`. Параметры `k1` и `b` должны быть числами с плавающей точкой.

### EXIST()
Подставляет несуществующие колонки значениями по умолчанию. Возвращает либо значение атрибута, указанного в 'attr-name', либо 'default-value', если этот атрибут отсутствует. Строковые или MVA атрибуты не поддерживаются. Эта функция полезна при поиске по нескольким таблицам с разными схемами.

```sql
SELECT *, EXIST('gid', 6) as cnd FROM i1, i2 WHERE cnd>5
```

### MIN_TOP_SORTVAL()
Возвращает значение ключа сортировки худшего элемента из текущих топ-N совпадений, если ключ сортировки является числом с плавающей точкой, иначе 0.

### MIN_TOP_WEIGHT()
Возвращает вес худшего элемента из текущих топ-N совпадений.

### PACKEDFACTORS()
`PACKEDFACTORS()` может использоваться в запросах для отображения всех вычисленных факторных весов во время сопоставления или для предоставления двоичного атрибута для создания пользовательской функции ранжирования UDF. Эта функция работает только при указании ранжировщика expression и если запрос не является полным сканированием; в противном случае возвращается ошибка. `PACKEDFACTORS()` может принимать необязательный аргумент, отключающий вычисление фактора ранжирования ATC: `PACKEDFACTORS({no_atc=1})`. Вычисление ATC значительно замедляет обработку запроса, поэтому эта опция полезна, если нужно увидеть факторы ранжирования, но ATC не требуется. `PACKEDFACTORS()` также может выводить в формате JSON: `PACKEDFACTORS({json=1})`. Примеры соответствующего вывода в формате ключ-значение или JSON приведены ниже. (Обратите внимание, что примеры ниже разбиты для удобства чтения; фактические возвращаемые значения будут одной строкой.)

```sql
mysql> SELECT id, PACKEDFACTORS() FROM test1
    -> WHERE MATCH('test one') OPTION ranker=expr('1') \G
*************************** 1\. row ***************************
             id: 1
packedfactors(): bm25=569, bm25a=0.617197, field_mask=2, doc_word_count=2,
    field1=(lcs=1, hit_count=2, word_count=2, tf_idf=0.152356,
        min_idf=-0.062982, max_idf=0.215338, sum_idf=0.152356, min_hit_pos=4,
        min_best_span_pos=4, exact_hit=0, max_window_hits=1, min_gaps=2,
        exact_order=1, lccs=1, wlccs=0.215338, atc=-0.003974),
    word0=(tf=1, idf=-0.062982),
    word1=(tf=1, idf=0.215338)
1 row in set (0.00 sec)
```

```sql
mysql> SELECT id, PACKEDFACTORS({json=1}) FROM test1
    -> WHERE MATCH('test one') OPTION ranker=expr('1') \G
*************************** 1\. row ***************************
                     id: 1
packedfactors({json=1}):
{

    "bm25": 569,
    "bm25a": 0.617197,
    "field_mask": 2,
    "doc_word_count": 2,
    "fields": [
        {
            "lcs": 1,
            "hit_count": 2,
            "word_count": 2,
            "tf_idf": 0.152356,
            "min_idf": -0.062982,
            "max_idf": 0.215338,
            "sum_idf": 0.152356,
            "min_hit_pos": 4,
            "min_best_span_pos": 4,
            "exact_hit": 0,
            "max_window_hits": 1,
            "min_gaps": 2,
            "exact_order": 1,
            "lccs": 1,
            "wlccs": 0.215338,
            "atc": -0.003974
        }
    ],
    "words": [
        {
            "tf": 1,
            "idf": -0.062982
        },
        {
            "tf": 1,
            "idf": 0.215338
        }
    ]

}
1 row in set (0.01 sec)
```

Эта функция может использоваться для реализации пользовательских функций ранжирования в UDF, например:

```sql
SELECT *, CUSTOM_RANK(PACKEDFACTORS()) AS r
FROM my_index
WHERE match('hello')
ORDER BY r DESC
OPTION ranker=expr('1');
```

Где `CUSTOM_RANK()` — функция, реализованная в UDF. Она должна объявить структуру `SPH_UDF_FACTORS` (определена в sphinxudf.h), инициализировать эту структуру, распаковать факторы в неё перед использованием и выполнить деинициализацию после, следующим образом:

```sql
SPH_UDF_FACTORS factors;
sphinx_factors_init(&factors);
sphinx_factors_unpack((DWORD*)args->arg_values[0], &factors);
// ... can use the contents of factors variable here ...
sphinx_factors_deinit(&factors);
```

Данные `PACKEDFACTORS()` доступны на всех этапах запроса, а не только во время начальной проходки сопоставления и ранжирования. Это позволяет использовать `PACKEDFACTORS()` для еще одного особенно интересного применения: повторного ранжирования.

В приведённом выше примере мы использовали ранжировщик на основе выражения с фиктивным выражением и отсортировали результирующий набор по значению, вычисленному нашей UDF. Другими словами, мы использовали UDF для ранжирования всех результатов. Теперь предположим для примера, что наша UDF очень дорогая в вычислении, с пропускной способностью всего 10 000 вызовов в секунду. Если запрос совпадает с 1 000 000 документов, мы захотим использовать более простое выражение для большей части ранжирования, чтобы сохранить приемлемую производительность. Затем мы применим дорогую UDF только к нескольким лучшим результатам, например, к топ-100. Иными словами, мы построим топ-100 результатов с помощью более простой функции ранжирования, а затем заново отсортируем их более сложной. Это можно сделать с помощью подзапросов:

```sql
SELECT * FROM (
    SELECT *, CUSTOM_RANK(PACKEDFACTORS()) AS r
    FROM my_index WHERE match('hello')
    OPTION ranker=expr('sum(lcs)*1000+bm25')
    ORDER BY WEIGHT() DESC
    LIMIT 100
) ORDER BY r DESC LIMIT 10
```

В этом примере ранжировщик на основе выражения вызывается для каждого совпавшего документа для вычисления `WEIGHT()`, то есть вызывается 1 000 000 раз. Однако вычисление UDF можно отложить до внешней сортировки, и оно будет выполнено только для топ-100 совпадений по `WEIGHT()` согласно внутреннему лимиту. Это означает, что UDF вызовется всего 100 раз. Наконец, выбираются и возвращаются приложению топ-10 совпадений по значению UDF.

Для справки: в распределённой настройке данные `PACKEDFACTORS()` передаются от агентов к мастер-ноде в двоичном формате. Это делает технически возможным реализовать дополнительные проходы повторного ранжирования на мастер-ноде при необходимости.

При использовании в SQL, но без вызова из UDF, результат `PACKEDFACTORS()` форматируется как обычный текст, который можно использовать для ручной оценки факторов ранжирования. Обратите внимание, что эта функция в настоящее время не поддерживается API Manticore.


### REMOVE_REPEATS()
`REMOVE_REPEATS ( result_set, column, offset, limit )` — удаляет повторяющиеся скорректированные строки с одинаковым значением 'column'.

```sql
SELECT REMOVE_REPEATS((SELECT * FROM dist1), gid, 0, 10)
```
Обратите внимание, что `REMOVE_REPEATS` не влияет на `total_found` в [метаинформации поискового запроса](../Node_info_and_management/SHOW_META.md#SHOW-META).

### WEIGHT()
Функция `WEIGHT()` возвращает вычисленный балл совпадения. Если сортировка не указана, результат сортируется по убыванию по баллу, предоставленному функцией `WEIGHT()`. В этом примере мы сортируем сначала по весу, а затем по целочисленному атрибуту.

Выше приведён простой поиск, где все слова должны присутствовать. Однако можно сделать больше (и это лишь простой пример):

```sql
mysql> SELECT *,WEIGHT() FROM testrt WHERE MATCH('"list of business laptops"/3');
+------+------+-------------------------------------+---------------------------+----------+
| id   | gid  | title                               | content                   | weight() |
+------+------+-------------------------------------+---------------------------+----------+
|    1 |   10 | List of HP business laptops         | Elitebook Probook         |     2397 |
|    2 |   10 | List of Dell business laptops       | Latitude Precision Vostro |     2397 |
|    3 |   20 | List of Dell gaming laptops         | Inspirion Alienware       |     2375 |
|    5 |   30 | List of ASUS ultrabooks and laptops | Zenbook Vivobook          |     2375 |
+------+------+-------------------------------------+---------------------------+----------+
4 rows in set (0.00 sec)


mysql> SHOW META;
+----------------+----------+
| Variable_name  | Value    |
+----------------+----------+
| total          | 4        |
| total_found    | 4        |
| total_relation | eq       |
| time           | 0.000    |
| keyword[0]     | list     |
| docs[0]        | 5        |
| hits[0]        | 5        |
| keyword[1]     | of       |
| docs[1]        | 4        |
| hits[1]        | 4        |
| keyword[2]     | business |
| docs[2]        | 2        |
| hits[2]        | 2        |
| keyword[3]     | laptops  |
| docs[3]        | 5        |
| hits[3]        | 5        |
+----------------+----------+
16 rows in set (0.00 sec)
```

Здесь ищутся четыре слова, но совпадение может произойти, если найдутся только три из четырёх слов. При этом документы, содержащие все слова, будут ранжироваться выше.

### ZONESPANLIST()
Функция `ZONESPANLIST()` возвращает пары совпавших зональных интервалов. Каждая пара содержит идентификатор совпавшего зонального интервала, двоеточие и номер порядка совпавшего зонального интервала. Например, если документ содержит `<emphasis role="bold"><i>text</i> the <i>text</i></emphasis>`, и выполнен запрос `'ZONESPAN:(i,b) text'`, то функция `ZONESPANLIST()` вернёт строку `"1:1 1:2 2:1"`, что означает, что первый зональный интервал совпал со словом "text" в интервалах 1 и 2, а второй — только в интервале 1.

### QUERY()
`QUERY()` возвращает текущий поисковый запрос. `QUERY()` — это postlimit выражение и предназначено для использования с [SNIPPET()](../Functions/String_functions.md#SNIPPET%28%29).

Табличные функции представляют собой механизм для обработки результирующего набора после выполнения запроса. Табличные функции принимают произвольный результирующий набор в качестве входных данных и возвращают новый, обработанный набор в качестве выходных данных. Первый аргумент должен быть входным результирующим набором, но табличная функция может дополнительно принимать и обрабатывать другие аргументы. Табличные функции могут полностью изменять результирующий набор, включая его схему. В настоящее время поддерживаются только встроенные табличные функции. Табличные функции работают как для внешнего `SELECT`, так и для [вложенного SELECT](../Searching/Sub-selects.md).

<!-- proofread -->

