# Поисковые и ранжирующие функции

### BM25A()
`BM25A(k1,b)` возвращает точное значение `BM25A()`. Требует ранжировщика `expr` и включённого `index_field_lengths`. Параметры `k1` и `b` должны быть числами с плавающей точкой.

### BM25F()
`BM25F(k1, b, {field=weight, ...})` возвращает точное значение `BM25F()` и требует включённого `index_field_lengths`. Также необходим ранжировщик `expr`. Параметры `k1` и `b` должны быть числами с плавающей точкой.

### EXIST()
Заменяет несуществующие столбцы значениями по умолчанию. Возвращает либо значение атрибута, указанного в 'attr-name', либо 'default-value', если такой атрибут отсутствует. Атрибуты STRING или MVA не поддерживаются. Эта функция полезна при поиске по нескольким таблицам с разными схемами.

```sql
SELECT *, EXIST('gid', 6) as cnd FROM i1, i2 WHERE cnd>5
```

### MIN_TOP_SORTVAL()
Возвращает значение ключа сортировки наихудшего элемента в текущих топ-N совпадениях, если ключ сортировки — число с плавающей точкой, иначе 0.

### MIN_TOP_WEIGHT()
Возвращает вес наихудшего элемента в текущих топ-N совпадениях.

### PACKEDFACTORS()
`PACKEDFACTORS()` можно использовать в запросах для отображения всех вычисленных факторов взвешивания во время сопоставления или для предоставления бинарного атрибута для создания пользовательской функции ранжирования UDF. Эта функция работает только при указании ранжировщика выражений и если запрос не является полным сканированием; в противном случае возвращается ошибка. `PACKEDFACTORS()` может принимать необязательный аргумент, отключающий вычисление фактора ранжирования ATC: `PACKEDFACTORS({no_atc=1})`. Вычисление ATC значительно замедляет обработку запроса, поэтому эта опция полезна, если нужно видеть факторы ранжирования, но ATC не требуется. `PACKEDFACTORS()` также может выводить данные в формате JSON: `PACKEDFACTORS({json=1})`. Соответствующие выводы в формате пар ключ-значение или JSON показаны ниже. (Обратите внимание, что приведённые примеры разбиты для удобства чтения; фактические возвращаемые значения будут в одной строке.)

```sql
mysql> SELECT id, PACKEDFACTORS() FROM test1
    -> WHERE MATCH('test one') OPTION ranker=expr('1') \G
*************************** 1\. row ***************************
             id: 1
packedfactors(): bm25=569, bm25a=0.617197, field_mask=2, doc_word_count=2,
    field1=(lcs=1, hit_count=2, word_count=2, tf_idf=0.152356,
        min_idf=-0.062982, max_idf=0.215338, sum_idf=0.152356, min_hit_pos=4,
        min_best_span_pos=4, exact_hit=0, max_window_hits=1, min_gaps=2,
        exact_order=1, lccs=1, wlccs=0.215338, atc=-0.003974),
    word0=(tf=1, idf=-0.062982),
    word1=(tf=1, idf=0.215338)
1 row in set (0.00 sec)
```

```sql
mysql> SELECT id, PACKEDFACTORS({json=1}) FROM test1
    -> WHERE MATCH('test one') OPTION ranker=expr('1') \G
*************************** 1\. row ***************************
                     id: 1
packedfactors({json=1}):
{

    "bm25": 569,
    "bm25a": 0.617197,
    "field_mask": 2,
    "doc_word_count": 2,
    "fields": [
        {
            "lcs": 1,
            "hit_count": 2,
            "word_count": 2,
            "tf_idf": 0.152356,
            "min_idf": -0.062982,
            "max_idf": 0.215338,
            "sum_idf": 0.152356,
            "min_hit_pos": 4,
            "min_best_span_pos": 4,
            "exact_hit": 0,
            "max_window_hits": 1,
            "min_gaps": 2,
            "exact_order": 1,
            "lccs": 1,
            "wlccs": 0.215338,
            "atc": -0.003974
        }
    ],
    "words": [
        {
            "tf": 1,
            "idf": -0.062982
        },
        {
            "tf": 1,
            "idf": 0.215338
        }
    ]

}
1 row in set (0.01 sec)
```

Эта функция может использоваться для реализации пользовательских функций ранжирования в UDF, например:

```sql
SELECT *, CUSTOM_RANK(PACKEDFACTORS()) AS r
FROM my_index
WHERE match('hello')
ORDER BY r DESC
OPTION ranker=expr('1');
```

Где `CUSTOM_RANK()` — функция, реализованная в UDF. Она должна объявить структуру `SPH_UDF_FACTORS` (определённую в sphinxudf.h), инициализировать эту структуру, распаковать в неё факторы перед использованием и деинициализировать после, следующим образом:

```sql
SPH_UDF_FACTORS factors;
sphinx_factors_init(&factors);
sphinx_factors_unpack((DWORD*)args->arg_values[0], &factors);
// ... can use the contents of factors variable here ...
sphinx_factors_deinit(&factors);
```

Данные `PACKEDFACTORS()` доступны на всех этапах запроса, а не только во время начального прохода сопоставления и ранжирования. Это открывает ещё одно особенно интересное применение `PACKEDFACTORS()`: повторное ранжирование.

В приведённом выше примере мы использовали ранжировщик на основе выражений с фиктивным выражением и отсортировали набор результатов по значению, вычисленному нашей UDF. Другими словами, мы использовали UDF для ранжирования всех результатов. Теперь предположим для примера, что наша UDF чрезвычайно затратна в вычислении, с пропускной способностью всего 10 000 вызовов в секунду. Если наш запрос совпадает с 1 000 000 документов, мы хотели бы использовать гораздо более простое выражение для основной части ранжирования, чтобы сохранить разумную производительность. Затем мы применим дорогую UDF только к нескольким лучшим результатам, скажем, к топ-100. Другими словами, мы построим топ-100 результатов с помощью более простой функции ранжирования, а затем повторно отсортируем их с помощью более сложной. Это можно сделать с помощью подзапросов:

```sql
SELECT * FROM (
    SELECT *, CUSTOM_RANK(PACKEDFACTORS()) AS r
    FROM my_index WHERE match('hello')
    OPTION ranker=expr('sum(lcs)*1000+bm25')
    ORDER BY WEIGHT() DESC
    LIMIT 100
) ORDER BY r DESC LIMIT 10
```

В этом примере ранжировщик на основе выражений вызывается для каждого совпавшего документа для вычисления `WEIGHT()`, поэтому он вызывается 1 000 000 раз. Однако вычисление UDF можно отложить до внешней сортировки, и оно будет выполнено только для топ-100 совпадений по `WEIGHT()`, согласно внутреннему ограничению. Это означает, что UDF будет вызвана всего 100 раз. Наконец, выбираются и возвращаются приложению топ-10 совпадений по значению UDF.

Для справки, в распределённой конфигурации данные `PACKEDFACTORS()` передаются от агентов к мастер-узлу в бинарном формате. Это технически позволяет реализовать дополнительные проходы повторного ранжирования на мастер-узле при необходимости.

При использовании в SQL, но без вызова из UDF, результат `PACKEDFACTORS()` форматируется как простой текст, который можно использовать для ручной оценки факторов ранжирования. Обратите внимание, что эта функция в настоящее время не поддерживается API Manticore.


### REMOVE_REPEATS()
`REMOVE_REPEATS ( result_set, column, offset, limit )` — удаляет повторяющиеся скорректированные строки с одинаковым значением 'column'.

```sql
SELECT REMOVE_REPEATS((SELECT * FROM dist1), gid, 0, 10)
```
Обратите внимание, что `REMOVE_REPEATS` не влияет на `total_found` в [метаинформации поискового запроса](../Node_info_and_management/SHOW_META.md#SHOW-META).

### WEIGHT()
Функция `WEIGHT()` возвращает вычисленный балл совпадения. Если порядок не задан, результат сортируется по убыванию балла, возвращаемого `WEIGHT()`. В этом примере мы сначала сортируем по весу, затем по целочисленному атрибуту.

Приведённый выше поиск выполняет простое сопоставление, где все слова должны присутствовать. Однако можно сделать больше (и это всего лишь простой пример):

```sql
mysql> SELECT *,WEIGHT() FROM testrt WHERE MATCH('"list of business laptops"/3');
+------+------+-------------------------------------+---------------------------+----------+
| id   | gid  | title                               | content                   | weight() |
+------+------+-------------------------------------+---------------------------+----------+
|    1 |   10 | List of HP business laptops         | Elitebook Probook         |     2397 |
|    2 |   10 | List of Dell business laptops       | Latitude Precision Vostro |     2397 |
|    3 |   20 | List of Dell gaming laptops         | Inspirion Alienware       |     2375 |
|    5 |   30 | List of ASUS ultrabooks and laptops | Zenbook Vivobook          |     2375 |
+------+------+-------------------------------------+---------------------------+----------+
4 rows in set (0.00 sec)


mysql> SHOW META;
+----------------+----------+
| Variable_name  | Value    |
+----------------+----------+
| total          | 4        |
| total_found    | 4        |
| total_relation | eq       |
| time           | 0.000    |
| keyword[0]     | list     |
| docs[0]        | 5        |
| hits[0]        | 5        |
| keyword[1]     | of       |
| docs[1]        | 4        |
| hits[1]        | 4        |
| keyword[2]     | business |
| docs[2]        | 2        |
| hits[2]        | 2        |
| keyword[3]     | laptops  |
| docs[3]        | 5        |
| hits[3]        | 5        |
+----------------+----------+
16 rows in set (0.00 sec)
```

Здесь мы ищем четыре слова, но совпадение может произойти, если найдены только три из четырёх слов. Поиск будет ранжировать документы, содержащие все слова, выше.

### ZONESPANLIST()
Функция `ZONESPANLIST()` возвращает пары совпавших зональных интервалов. Каждая пара содержит идентификатор совпавшего зонального интервала, двоеточие и порядковый номер совпавшего зонального интервала. Например, если в документе содержится `<emphasis role="bold"><i>text</i> the <i>text</i></emphasis>`, и вы выполняете запрос `'ZONESPAN:(i,b) text'`, то `ZONESPANLIST()` вернёт строку `"1:1 1:2 2:1"`, что означает, что первый зональный интервал совпал со словом "text" в интервалах 1 и 2, а второй зональный интервал — только в интервале 1.

### QUERY()
`QUERY()` возвращает текущий поисковый запрос. `QUERY()` является выражением postlimit и предназначена для использования с [SNIPPET()](../Functions/String_functions.md#SNIPPET%28%29).

Табличные функции — это механизм обработки набора результатов после выполнения запроса. Табличные функции принимают произвольный набор результатов на вход и возвращают новый, обработанный набор на выход. Первый аргумент должен быть входным набором результатов, но табличная функция может дополнительно принимать и обрабатывать другие аргументы. Табличные функции могут полностью изменить набор результатов, включая схему. В настоящее время поддерживаются только встроенные табличные функции. Табличные функции работают как для внешнего `SELECT`, так и для [вложенного SELECT](../Searching/Sub-selects.md).

<!-- proofread -->

