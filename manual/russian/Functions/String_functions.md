# Строковые функции

### CONCAT()
Объединяет две или более строки в одну. Не строковые аргументы должны быть явно преобразованы в строку с использованием функции `TO_STRING()`.

```sql
CONCAT(TO_STRING(float_attr), ',', TO_STRING(int_attr), ',', title)
```

### LEVENSHTEIN()
`LEVENSHTEIN ( pattern, source, {normalize=0, length_delta=0})` возвращает число (расстояние Левенштейна) одиночных изменений (вставок, удалений или замен) между строками `pattern` и `source`, необходимых для того, чтобы сделать `pattern` равным `source`.

   * `pattern`, `source` - постоянная строка, имя строкового поля, имя поля JSON или любое выражение, которое производит строку (например, [SUBSTRING_INDEX()](../Functions/String_functions.md#SUBSTRING_INDEX%28%29))
   * `normalize` - опция для возврата расстояния как числа с плавающей точкой в диапазоне `[0.0 - 1.0]`, где 0.0 - это точное совпадение, а 1.0 - максимальная разница. Значение по умолчанию - 0, что означает отсутствие нормализации и предоставление результата как целого числа.
   * `length_delta` - пропускает расчет расстояния Левенштейна и возвращает `max(strlen(pattern), strlen(source))`, если опция установлена и длины строк отличаются более чем на значение `length_delta`. Значение по умолчанию - 0, что означает расчет расстояния Левенштейна для любых входных строк. Эта опция может быть полезна при проверке в основном схожих строк.

``` sql
SELECT LEVENSHTEIN('gily', attr1) AS dist, WEIGHT() AS w FROM test WHERE MATCH('test') ORDER BY w DESC, dist ASC;
SELECT LEVENSHTEIN('gily', j.name, {length_delta=6}) AS dist, WEIGHT() AS w FROM test WHERE MATCH('test') ORDER BY w DESC;
SELECT LEVENSHTEIN(title, j.name, {normalize=1}) AS dist, WEIGHT() AS w FROM test WHERE MATCH ('test') ORDER BY w DESC, dist ASC;
```

### REGEX()
Функция `REGEX(attr,expr)` возвращает 1, если регулярное выражение соответствует строке атрибута, и 0 в противном случае. Она работает как со строковыми, так и с JSON атрибутами.

```sql
SELECT REGEX(content, 'box?') FROM test;
SELECT REGEX(j.color, 'red | pink') FROM test;
```

Выражения должны соответствовать синтаксису RE2. Чтобы выполнить поиск без учета регистра, например, вы можете использовать:
```sql
SELECT REGEX(content, '(?i)box') FROM test;
```

### SNIPPET()
Функция `SNIPPET()` может быть использована для выделения результатов поиска в заданном тексте. Первые два аргумента: текст для выделения и запрос. [Опции](../Searching/Highlighting.md#Highlighting-options) могут быть переданы функции как третий, четвертый и так далее аргументы. `SNIPPET()` может получать текст для выделения непосредственно из таблицы. В этом случае первым аргументом должно быть имя поля:

```sql
SELECT SNIPPET(body, QUERY()) FROM myIndex WHERE MATCH('my.query')
```

В этом примере выражение `QUERY()` возвращает текущий полнотекстовый запрос. `SNIPPET()` также может выделять неиндексированный текст:

```sql
mysql  SELECT id, SNIPPET('text to highlight', 'my.query', 'limit=100') FROM myIndex WHERE MATCH('my.query')
```

Кроме того, он может использоваться для выделения текста, полученного из других источников, с использованием функции, определенной пользователем (UDF):

```sql
SELECT id, SNIPPET(myUdf(id), 'my.query', 'limit=100') FROM myIndex WHERE MATCH('my.query')
```

В этом контексте `myUdf()` - это функция, определенная пользователем (UDF), которая извлекает документ по его идентификатору из внешнего источника хранения. Функция `SNIPPET()` считается функцией "пост лимита", что означает, что вычисление фрагментов откладывается до тех пор, пока весь итоговый набор результатов не будет подготовлен, и даже после применения условия `LIMIT`. Например, если используется условие `LIMIT 20,10`, функция `SNIPPET()` будет вызвана не более 10 раз.

Важно отметить, что `SNIPPET()` не поддерживает ограничения, основанные на полях. Для этой функциональности используйте [HIGHLIGHT()](../Searching/Highlighting.md#Highlighting-via-SQL) вместо.

### SUBSTRING_INDEX()

<!-- example substring_index -->
`SUBSTRING_INDEX(string, delimiter, number)` возвращает подстроку оригинальной строки, основанную на заданном числе вхождений разделителя:

   *   string - Оригинальная строка, которая может быть постоянной строкой или строкой из строкового/JSON атрибута.
   *   delimiter - Разделитель, который нужно искать.
   *   number - Количество вхождений, которое нужно искать. Это может быть как положительное, так и отрицательное число. Если это положительное число, функция вернет все слева от разделителя. Если это отрицательное число, функция вернет все справа от разделителя.

`SUBSTRING_INDEX()` по умолчанию возвращает строку, но также может быть преобразована в другие типы (такие как целое или вещественное), если это необходимо. Числовые значения могут быть преобразованы с использованием специфических функций (таких как `BIGINT()`, `DOUBLE()`, и т.д.).

<!-- request SQL -->
```sql
SELECT SUBSTRING_INDEX('www.w3schools.com', '.', 2) FROM test;
SELECT SUBSTRING_INDEX(j.coord, ' ', 1) FROM test;
SELECT          SUBSTRING_INDEX('1.2 3.4', ' ',  1);  /* '1.2' */
SELECT          SUBSTRING_INDEX('1.2 3.4', ' ', -1);  /* '3.4' */
SELECT sint (   SUBSTRING_INDEX('1.2 3.4', ' ',  1)); /* 1 */
SELECT sint (   SUBSTRING_INDEX('1.2 3.4', ' ', -1)); /* 3 */
SELECT double ( SUBSTRING_INDEX('1.2 3.4', ' ',  1)); /* 1.200000 */
SELECT double ( SUBSTRING_INDEX('1.2 3.4', ' ', -1)); /* 3.400000 */
```

<!-- end -->

### UPPER() и LOWER()

`UPPER(string)` преобразует аргумент в верхний регистр, `LOWER(string)` преобразует аргумент в нижний регистр.

Результат также может быть преобразован в числовой тип, но только если строковый аргумент может быть преобразован в число. Числовые значения могут быть преобразованы произвольными функциями (`BITINT`, `DOUBLE`, и т.д.).

```sql
SELECT upper('www.w3schools.com', '.', 2); /* WWW.W3SCHOOLS.COM  */
SELECT double (upper ('1.2e3')); /* 1200.000000 */
SELECT integer (lower ('12345')); /* 12345 */
```
<!-- proofread -->
