# Компиляция Manticore из исходников

Компиляция Manticore Search из исходных кодов позволяет настроить сборку под свои нужды, например, отключить определённые функции или добавить новые патчи для тестирования. Например, вы можете захотеть собрать из исходников и отключить встроенный ICU, чтобы использовать другую версию, установленную в вашей системе, которую можно обновлять независимо от Manticore. Это также полезно, если вы заинтересованы в участии в проекте Manticore Search.

## Сборка с использованием CI Docker
Для подготовки [официальных релизных и разработческих пакетов](https://repo.manticoresearch.com/) мы используем Docker и специальный образ для сборки. Этот образ включает в себя необходимые инструменты и предназначен для использования с внешними sysroot, чтобы один контейнер мог собирать пакеты для всех операционных систем. Вы можете собрать образ, используя [Dockerfile](https://github.com/manticoresoftware/manticoresearch/blob/master/dist/build_dockers/cross/external_toolchain/Dockerfile) и [README](https://github.com/manticoresoftware/manticoresearch/blob/master/dist/build_dockers/README.md) или использовать образ с [Docker Hub](https://hub.docker.com/r/manticoresearch/external_toolchain/tags). Это самый простой способ создать бинарные файлы для любой поддерживаемой операционной системы и архитектуры. При запуске контейнера также необходимо указать следующие переменные окружения:

* `DISTR`: целевая платформа: `bionic`, `focal`, `jammy`, `buster`, `bullseye`, `bookworm`, `rhel7`, `rhel8`, `rhel9`, `rhel10`, `macos`, `windows`, `freebsd13`
* `arch`: архитектура: `x86_64`, `x64` (для Windows), `aarch64`, `arm64` (для Macos)
* `SYSROOT_URL`: URL к архивам системных корней. Вы можете использовать https://repo.manticoresearch.com/repository/sysroots, если вы не собираете sysroot самостоятельно (инструкции можно найти [здесь](https://github.com/manticoresoftware/manticoresearch/tree/master/dist/build_dockers/cross/sysroots)).
* Используйте файлы CI workflow в качестве справочника, чтобы узнать другие необходимые переменные окружения:
  - https://github.com/manticoresoftware/manticoresearch/blob/master/.github/workflows/pack_publish.yml
  - https://github.com/manticoresoftware/manticoresearch/blob/master/.github/workflows/build_template.yml

Чтобы найти возможные значения для `DISTR` и `arch`, вы можете использовать каталог https://repo.manticoresearch.com/repository/sysroots/roots_with_zstd/ в качестве справочника, так как он содержит sysroot для всех поддерживаемых комбинаций.

После этого сборка пакетов внутри Docker-контейнера так же проста, как вызов:

```bash
cmake -DPACK=1 /path/to/sources
cmake --build .
```

Например, чтобы создать пакет для Ubuntu Jammy, аналогичный официальной версии, предоставляемой командой Manticore Core, следует выполнить следующие команды в директории с исходниками Manticore Search. Эта директория является корнем клонированного репозитория с https://github.com/manticoresoftware/manticoresearch:

```bash
docker run -it --rm \
-e CACHEB="../cache" \
-e DIAGNOSTIC=1 \
-e PACK_ICUDATA=0 \
-e NO_TESTS=1 \
-e DISTR=jammy \
-e boost=boost_nov22 \
-e sysroot=roots_nov22 \
-e arch=x86_64 \
-e CTEST_CMAKE_GENERATOR=Ninja \
-e CTEST_CONFIGURATION_TYPE=RelWithDebInfo \
-e WITH_COVERAGE=0 \
-e SYSROOT_URL="https://repo.manticoresearch.com/repository/sysroots" \
-e HOMEBREW_PREFIX="" \
-e PACK_GALERA=0 \
-e UNITY_BUILD=1 \
-v $(pwd):/manticore_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \
manticoresearch/external_toolchain:vcpkg331_20250114 bash

# following is to be run inside docker shell
cd /manticore_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/
mkdir build && cd build
cmake -DPACK=1 ..
export CMAKE_TOOLCHAIN_FILE=$(pwd)/dist/build_dockers/cross/linux.cmake
cmake --build .
# or if you want to build packages:
# cmake --build . --target package
```
Требуется длинный путь к директории с исходниками, иначе в некоторых случаях (например, на Centos) сборка исходников может не произойти.

Аналогичным образом, вы можете собирать бинарники или пакеты не только для популярных дистрибутивов Linux, но также для FreeBSD, Windows и macOS.

#### Сборка SRPM с использованием Docker

Вы также можете использовать тот же специальный docker образ для сборки SRPM:

```bash
docker run -it --rm \
-e CACHEB="../cache" \
-e DIAGNOSTIC=1 \
-e PACK_ICUDATA=0 \
-e NO_TESTS=1 \
-e DISTR=rhel8 \
-e boost=boost_rhel_feb17 \
-e sysroot=roots_nov22 \
-e arch=x86_64 \
-e CTEST_CMAKE_GENERATOR=Ninja \
-e CTEST_CONFIGURATION_TYPE=RelWithDebInfo \
-e WITH_COVERAGE=0 \
-e SYSROOT_URL="https://repo.manticoresearch.com/repository/sysroots" \
-e HOMEBREW_PREFIX="" \
-e PACK_GALERA=0 \
-e UNITY_BUILD=1 \
-v $(pwd):/manticore_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \
manticoresearch/external_toolchain:vcpkg331_20250114 bash

# following is to be run inside docker shell
cd /manticore_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/
mkdir build && cd build
cmake -DPACK=1 ..
export CMAKE_TOOLCHAIN_FILE=$(pwd)/../dist/build_dockers/cross/linux.cmake
# The CPackSourceConfig.cmake file is now generated in the build directory
cpack -G RPM --config ./CPackSourceConfig.cmake
```

Это создаст исходный RPM (`.src.rpm` файл), содержащий весь исходный код.

#### Сборка бинарных RPM из SRPM

После того как вы сгенерировали SRPM, вы можете использовать его для сборки полного набора бинарных RPM пакетов:

```bash
# Install build tools and dependencies
dnf install -y rpm-build cmake gcc-c++ boost-devel epel-release

# Install SRPM dependencies automatically
dnf builddep -y manticore-*.src.rpm

# Build all binary RPMs from the SRPM
rpmbuild --rebuild manticore-*.src.rpm

# Find the generated packages
ls ~/rpmbuild/RPMS/*/manticore*
```

> ПРИМЕЧАНИЕ: **Чтобы собрать RPM из SRPM, необходимо убедиться, что все зависимости, указанные в SRPM, полностью установлены, что может быть сложно.** SRPM всё равно может быть полезен для:
> - Аудита процесса сборки или изучения исходников и spec-файлов
> - Внесения пользовательских изменений или патчей в сборку
> - Понимания того, как были получены бинарные файлы
> - Соблюдения требований лицензий с открытым исходным кодом

## Сборка вручную

Компиляция Manticore без использования Docker для сборки **не рекомендуется**, но если вам нужно это сделать, вот что вам может понадобиться знать:

### Необходимые инструменты

* Компилятор C++
  * В Linux — можно использовать GNU (версии 4.7.2 и выше) или Clang
  * В Windows — Microsoft Visual Studio 2019 и выше (комьюнити-версия подходит)
  * На macOS — Clang (из командных инструментов XCode, используйте `xcode-select --install` для установки).
* Bison, Flex — на большинстве систем доступны как пакеты, в Windows они доступны в фреймворке cygwin.
* Cmake — используется на всех платформах (требуется версия 3.19 или выше)

### Получение исходников

#### Из git

Исходный код Manticore расположен [на GitHub](https://github.com/manticoresoftware/manticoresearch).
Чтобы получить исходный код, клонируйте репозиторий, затем переключитесь на нужную ветку или тег. Ветка `master` представляет основную ветку разработки. При выпуске релиза создаётся тег с номером версии, например, `3.6.0`, и начинается новая ветка для текущего релиза, в данном случае `manticore-3.6.0`. Голова версии ветки после всех изменений используется в качестве исходника для всех бинарных выпусков. Например, чтобы взять исходники версии 3.6.0, можно выполнить:

```bash
git clone https://github.com/manticoresoftware/manticoresearch.git
cd manticoresearch
git checkout manticore-3.6.0
```

#### Из архива

Можно скачать необходимый код с GitHub, используя кнопку "Download ZIP". Подходят как .zip, так и .tar.gz форматы.

```bash
wget -c https://github.com/manticoresoftware/manticoresearch/archive/refs/tags/3.6.0.tar.gz
tar -zxf 3.6.0.tar.gz
cd manticoresearch-3.6.0
```

### Конфигурирование

Manticore использует CMake. Предположим, вы находитесь в корневой директории клонированного репозитория:

```bash
mkdir build && cd build
cmake ..
```

CMake проверит доступные функции и сконфигурирует сборку с их учётом. По умолчанию все функции считаются включёнными, если они доступны. Скрипт также загружает и собирает некоторые внешние библиотеки, предполагая, что вы захотите их использовать. Таким образом, вы получаете поддержку максимального количества функций.

Вы также можете настроить сборку явно с помощью флагов и опций. Чтобы включить функцию `FOO`, добавьте `-DFOO=1` к вызову CMake.
Чтобы отключить эту функцию, используйте `-DFOO=0`. Если явно не указано и функция, которую вы пытаетесь включить, недоступна (например, `WITH_GALERA` при сборке для MS Windows), конфигурация завершится с ошибкой. Отключение функции не только исключает её из сборки, но также отключает её проверку в системе и скачивание/сборку связанных внешних библиотек.

#### Флаги и опции конфигурации

- **USE_SYSLOG** - позволяет использовать `syslog` в [логировании запросов](../Logging/Query_logging.md).
- **WITH_GALERA** - включает поддержку репликации на демоне поиска. Поддержка будет сконфигурирована для сборки, а исходники библиотеки Galera будут загружены, собраны и включены в дистрибутив/установку. Обычно сборка с Galera безопасна, но при этом сама библиотека не распространяется (то есть нет модуля Galera, нет репликации). Однако иногда может потребоваться явное отключение, например, если вы хотите собрать статический бинарник, который по задумке не может загружать никакие библиотеки, так что даже наличие вызова функции 'dlopen' внутри демона приведёт к ошибке линковки.
- **WITH_RE2** - сборка с использованием библиотеки регулярных выражений RE2. Это необходимо для функций, таких как [REGEX()](../Functions/String_functions.md#REGEX%28%29), и фильтра [regexp_filter](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#regexp_filter)
  .
- **WITH_RE2_FORCE_STATIC** - загружает исходники RE2, компилирует их и линкует статически, так что итоговые бинарники не будут зависеть от наличия общей библиотеки `RE2` в вашей системе.
- **WITH_STEMMER** - сборка с использованием библиотеки стемминга Snowball.
- **WITH_STEMMER_FORCE_STATIC** - загружает исходники Snowball, компилирует их и линкует статически, так что итоговые бинарники не будут зависеть от наличия общей библиотеки `libstemmer` в вашей системе.
- **WITH_ICU** -  сборка с использованием библиотеки ICU (International Components for Unicode). Используется для сегментирования китайского текста. Применяется при использовании morphology=`icu_chinese`.
- **WITH_JIEBA** -  сборка с использованием инструмента Jieba для сегментирования китайского текста. Используется для сегментирования китайского текста. Применяется при использовании morphology=`jieba_chinese`.
- **WITH_ICU_FORCE_STATIC** - загружает исходники ICU, компилирует их и линкует статически, так что итоговые бинарники не будут зависеть от наличия общей библиотеки `icu` в вашей системе. Также включает файл данных ICU в установку/дистрибутив. Цель статически слинкованной ICU — наличие библиотеки определённой версии, чтобы поведение было предсказуемым и не зависело от системных библиотек. Чаще всего предпочтительнее использовать системную ICU, так как она может обновляться со временем без необходимости пересобирать демон Manticore. В этом случае необходимо явно отключить данную опцию. Это также позволит сэкономить место, занимаемое файлом данных ICU (около 30М), поскольку он не будет включен в дистрибутив.
- **WITH_SSL** - используется для поддержки HTTPS, а также для зашифрованных MySQL-соединений с демоном. Системная библиотека OpenSSL будет слинкована с демоном. Это означает, что наличие OpenSSL необходимо для запуска демона. Это обязательно для поддержки HTTPS, но не обязательно для сервера (т.е. если нет SSL — невозможна работа по HTTPS, но другие протоколы будут работать). Библиотеки SSL с версий от 1.0.2 до 1.1.1 могут использоваться Manticore, однако обратите внимание, что **в целях безопасности настоятельно рекомендуется использовать как можно более свежую библиотеку SSL
  **. На данный момент поддерживается только v1.1.1, остальные устарели (
  см. [openssl release strategy](https://www.openssl.org/policies/releasestrat.html)
- **WITH_ZLIB** - используется индексатором для работы с сжатыми колонками из MySQL. Используется демоном для поддержки сжатого MySQL-протокола.
- **WITH_ODBC** - используется индексатором для поддержки индексирования источников от ODBC-провайдеров (обычно UnixODBC и iODBC). В MS Windows, ODBC — правильный способ работы с источниками MS SQL, то есть индексирование `MSSQL` также подразумевает этот флаг.
- **DL_ODBC** - не линкуется с библиотекой ODBC. Если ODBC слинкована, но недоступна, невозможно запустить инструмент indexer даже если нужно обрабатывать данные, не связанные с ODBC. Эта опция заставляет индексатор загружать библиотеку только в рантайме и только при работе с источником ODBC.
- **ODBC_LIB** - имя файла библиотеки ODBC. Индексатор попытается загрузить этот файл, когда вы захотите обработать источник ODBC. Эта опция определяется автоматически по результатам исследования доступных разделяемых библиотек ODBC. Вы также можете переопределить это имя в рантайме, предоставив переменную окружения `ODBC_LIB` с путём к другой библиотеке перед запуском индексатора.
- **WITH_EXPAT** - используется индексатором для поддержки индексирования xmlpipe-источников.
- **DL_EXPAT** - не линкуется с библиотекой EXPAT. Если EXPAT слинкована, но недоступна, вы не сможете запустить инструмент `indexer` даже если хотите обработать что-то, не связанное с xmlpipe. Эта опция заставляет индексатор загружать библиотеку Только в рантайме, когда необходимо работать с xmlpipe-источником.
- **EXPAT_LIB** - имя файла библиотеки EXPAT. Индексатор будет пытаться загрузить этот файл при обработке источника xmlpipe. Эта опция определяется автоматически по результатам исследования доступных разделяемых библиотек EXPAT. Вы также можете переопределить это имя в рантайме, предоставив переменную окружения EXPAT_LIB с нужным путём к альтернативной библиотеке перед запуском индексатора.
- **WITH_ICONV** - для поддержки различных кодировок при индексировании xmlpipe-источников индексатором.
- **DL_ICONV** - не линкуется с библиотекой iconv. Если iconv слинкована, но недоступна, вы не сможете запустить инструмент `indexer` даже если хотите обработать что-то, не связанное с xmlpipe. Эта опция заставляет индексатор загружать библиотеку только в рантайме при работе с источником xmlpipe.
- **ICONV_LIB** - имя файла библиотеки iconv. Индексатор попытается загрузить этот файл, когда вы захотите обработать источник xmlpipe. Этот параметр автоматически записывается на основе исследования доступных разделяемых библиотек iconv. Вы также можете переопределить это имя во время выполнения, задав переменную окружения `ICONV_LIB` с правильным путем к альтернативной библиотеке перед запуском индексатора.
- **WITH_MYSQL** - используется индексатором для поддержки индексирования источников MySQL.
- **DL_MYSQL** - не связывать с библиотекой MySQL. Если MySQL связан, но недоступен, вы не сможете запустить инструмент `indexer`, даже если хотите обработать что-то, не связанное с MySQL. Эта опция требует от индексатора загрузить библиотеку во время выполнения только тогда, когда вы хотите работать с источником MySQL.
- **MYSQL_LIB** -- имя файла библиотеки MySQL. Индексатор попытается загрузить этот файл, когда вы захотите обработать источник MySQL. Этот параметр автоматически записывается на основе исследования доступных разделяемых библиотек MySQL. Вы также можете переопределить это имя во время выполнения, задав переменную окружения `MYSQL_LIB` с правильным путем к альтернативной библиотеке перед запуском индексатора.
- **WITH_POSTGRESQL** - используется индексатором для поддержки индексирования источников PostgreSQL.
- **DL_POSTGRESQL** - не связывать с библиотекой PostgreSQL. Если PostgreSQL связан, но недоступен, вы не сможете запустить инструмент `indexer`, даже если хотите обработать что-то, не связанное с PostgreSQL. Эта опция требует от индексатора загрузить библиотеку во время выполнения только тогда, когда вы хотите работать с источником PostgreSQL.
- **POSTGRESQL_LIB** - имя файла библиотеки postgresql. Индексатор попытается загрузить указанный файл библиотеки postgresql при обработке источника postgresql. Этот параметр автоматически определяется на основе исследования доступных разделяемых библиотек postgresql. Вы также можете переопределить имя во время выполнения, задав переменную окружения `POSTGRESQL_LIB` с правильным путем к альтернативной библиотеке перед запуском индексатора.
- **LOCALDATADIR** - путь по умолчанию, где демон хранит binlogs. Если этот путь не указан или явно отключен в конфигурации времени выполнения демона (т.е. в файле `manticore.conf`, который не относится к этой конфигурации сборки), binlogs будут размещены по этому пути. Обычно это абсолютный путь, однако он не обязательно должен быть таковым, могут использоваться и относительные пути. Вероятно, вам не нужно менять значение по умолчанию, заданное конфигурацией, которое, в зависимости от целевой системы, может быть таким, как `/var/data`, `/var/lib/manticore/data` или `/usr/local/var/lib/manticore/data`.
- **FULL_SHARE_DIR** - путь по умолчанию, где хранятся все ресурсы. Его можно переопределить переменной окружения `FULL_SHARE_DIR` перед запуском любого инструмента, использующего файлы из этой папки. Это важный путь, так как по умолчанию ожидается наличие многих файлов именно там. Это включает в себя предопределённые таблицы кодировок, стоп-слова, модули manticore и файлы данных icu, все размещённые в этой папке. Скрипт конфигурации обычно определяет этот путь как что-то вроде `/usr/share/manticore` или `/usr/local/share/manticore`.
- **DISTR_BUILD** - сокращение для опций создания релизных пакетов. Это строковое значение с именем целевой платформы. Можно использовать вместо ручной настройки всех параметров. На Debian и Redhat Linux значение по умолчанию может определяться лёгким интроспектированием и устанавливаться как универсальное 'Debian' или 'RHEL'. В противном случае значение не определяется.
- **PACK** - ещё более удобный ярлык. Он читает переменную окружения `DISTR`, присваивает её параметру **DISTR_BUILD**, а затем работает как обычно. Это очень полезно при сборке в подготовленных системах сборки, таких как Docker контейнеры, где переменная `DISTR` установлена на уровне системы и отражает целевую систему, для которой предназначен контейнер.
- **CMAKE_INSTALL_PREFIX** (путь) - место, куда предполагается установить Manticore. Сборка сама по себе не выполняет установку, но подготавливает правила установки, которые выполняются при запуске команды `cmake --install` или создании пакета и его установке. Префикс можно изменить в любое время, даже во время установки, вызвав
  `cmake --install . --prefix /path/to/installation`. Однако на этапе конфигурации эта переменная используется для инициализации значений по умолчанию для `LOCALDATADIR` и `FULL_SHARE_DIR`. Например, установка её в `/my/custom` на этапе конфигурации
  жёстко задаст `LOCALDATADIR` как `/my/custom/var/lib/manticore/data`, а `FULL_SHARE_DIR` как
  `/my/custom/usr/share/manticore`.
- **BUILD_TESTING** (булево) поддерживать ли тестирование. Если включено, после сборки можно запускать 'ctest' и тестировать сборку. Обратите внимание, что тестирование требует дополнительных зависимостей, таких как наличие PHP cli, Python и доступный сервер MySQL с тестовой базой данных. По умолчанию этот параметр включён. Поэтому для «просто сборки» вы, возможно, захотите явно отключить опцию, указав значение 'off'.
- **BUILD_SRPMS** (булево) показывать ли инструкции по сборке Source RPM (SRPM). Из-за ограничений CPack с компонентным пакетированием, SRPM не могут генерироваться напрямую вместе с бинарными RPM. Если включено, система сборки покажет инструкции для правильной генерации SRPM с использованием метода конфигурации исходников. По умолчанию этот параметр выключен.
- **LIBS_BUNDLE** - путь к папке с различными библиотеками. Это в основном актуально для сборки под Windows, но может быть полезно, если вы часто собираете, чтобы избежать скачивания сторонних исходников каждый раз. По умолчанию этот путь не изменяется скриптом конфигурации; вам нужно положить всё туда вручную. Например, когда нужен стеммер — исходники будут скачаны с сайта Snowball, затем распакованы, настроены, собраны и т.д. Вместо этого вы можете положить оригинальный исходный архив (например `libstemmer_c.tgz`) в эту папку. В следующий раз при сборке скрипт сначала посмотрит в этом каталоге, и если найдёт стеммер там, он не будет скачивать его снова из интернета.
- **CACHEB** - путь к папке с сохраненными сборками библиотек сторонних производителей. Обычно такие функции, как galera, re2, icu и т.д., сначала загружаются или получаются из пакета, затем распаковываются, собираются и устанавливаются во временную внутреннюю папку. При сборке Manticore эта папка затем используется как место, где находятся необходимые для поддержки запрошенной функции компоненты. В конечном итоге, они либо компонуются с Manticore, если это библиотека, либо напрямую попадают в дистрибутив/установку (как данные galera или icu). Когда **CACHEB** определен либо как параметр конфигурации cmake, либо как системная переменная окружения, он используется в качестве целевой папки для этих сборок. Эта папка может сохраняться между сборками, чтобы хранимые там библиотеки больше не пересобирались, что существенно сокращает весь процесс сборки.


Обратите внимание, что некоторые параметры организованы тройками: `WITH_XXX`, `DL_XXX` и `XXX_LIB` - например, поддержка mysql, odbc и т.д. `WITH_XXX` определяет, будут ли иметь эффект два следующих параметра. То есть, если вы установите `WITH_ODBC` в `0` - нет смысла указывать `DL_ODBC` и `ODBC_LIB`, и эти два не будут иметь эффекта, если вся функция отключена. Также, `XXX_LIB` не имеет смысла без `DL_XXX`, потому что если вы не хотите опцию `DL_XXX`, динамическая загрузка использоваться не будет, и имя, указанное в `XXX_LIB`, бесполезно. Это используется по умолчанию для интроспекции.

Также использование библиотеки `iconv` предполагает наличие `expat` и бесполезно, если последний отключен.

Кроме того, некоторые библиотеки могут быть всегда доступны, и поэтому нет смысла избегать их компоновки. Например, в Windows это ODBC. На macOS это Expat, iconv и, возможно, другие. Стандартная интроспекция определяет такие библиотеки и эффективно выдает только `WITH_XXX` для них, без `DL_XXX` и `XXX_LIB`, что упрощает процесс.

При некоторых параметрах настройка может выглядеть так:

```bash
mkdir build && cd build
cmake -DWITH_MYSQL=1 -DWITH_RE2=1 ..
```

Помимо общих значений конфигурации, вы также можете изучить файл `CMakeCache.txt`, который остается в папке сборки сразу после запуска конфигурации. Любые определенные там значения могут быть явно переопределены при запуске cmake. Например, вы можете запустить `cmake -DHAVE_GETADDRINFO_A=FALSE ...`, и этот запуск конфигурации не будет использовать исследованное значение этой переменной, а будет использовать предоставленное вами.

#### Специфические переменные окружения

Переменные окружения полезны для предоставления глобальных настроек, которые хранятся отдельно от конфигурации сборки и всегда присутствуют. Для сохранения они могут быть установлены глобально в системе различными способами - например, добавлением их в файл `.bashrc`, встраиванием в Dockerfile при создании docker-based системы сборки или записью в системных настройках переменных окружения в Windows. Также вы можете установить их кратковременно с помощью `export VAR=value` в оболочке. Или еще короче, предварив значения вызову cmake, например, `CACHEB=/my/cache cmake ...` - таким образом это сработает только в этом вызове и не будет видно в следующем.

Некоторые из таких переменных известны как используемые в целом cmake и некоторыми другими инструментами. Это такие вещи, как `CXX`, который определяет текущий компилятор C++, или `CXX_FLAGS` для предоставления флагов компилятора и т.д.

Однако у нас есть некоторые переменные, характерные для конфигурации Manticore, которые придуманы исключительно для наших сборок.

- **CACHEB** - то же, что и параметр конфигурации **CACHEB**
- **LIBS_BUNDLE** - то же, что и параметр конфигурации **LIBS_BUNDLE**
- **DISTR** - используется для инициализации опции `DISTR_BUILD` при использовании `-DPACK=1`
- **DIAGNOSTIC** - делает вывод конфигурации cmake гораздо более подробным, объясняя все происходящее
- **WRITEB** - предполагает **LIBS_BUNDLE** и, если установлен, будет загружать архивы исходных файлов для различных инструментов в папку LIBS_BUNDLE. То есть, если выйдет новая версия стеммера - вы можете вручную удалить libstemmer_c.tgz из пакета, а затем запустить одноразовый `WRITEB=1 cmake ...` - он не найдет исходные файлы стеммера в пакете и затем загрузит их с сайта производителя в пакет (без WRITEB они будут загружены во временную папку внутри сборки и исчезнут при очистке папки сборки).

В конце конфигурации вы можете увидеть, что доступно и будет использовано, в списке, похожем на этот:

```
-- Enabled features compiled in:
* Galera, replication of tables
* re2, a regular expression library
* stemmer, stemming library (Snowball)
* icu, International Components for Unicode
* OpenSSL, for encrypted networking
* ZLIB, for compressed data and networking
* ODBC, for indexing MSSQL (windows) and generic ODBC sources with indexer
* EXPAT, for indexing xmlpipe sources with indexer
* Iconv, for support of different encodings when indexing xmlpipe sources with indexer
* MySQL, for indexing MySQL sources with indexer
* PostgreSQL, for indexing PostgreSQL sources with indexer
```

### Сборка

```bash
cmake --build . --config RelWithDebInfo
```

### Установка

Для установки выполните:

```bash
cmake --install . --config RelWithDebInfo
```

чтобы установить в пользовательскую (не по умолчанию) папку, выполните:

```bash
cmake --install . --prefix path/to/build --config RelWithDebInfo
```

### Сборка пакетов

Для сборки пакета используйте цель `package`. Он соберет пакет в соответствии с выбором, предоставленным параметром `-DDISTR_BUILD`. По умолчанию это будет простой архив .zip или .tgz со всеми исполняемыми файлами и дополнительными файлами.

```bash
cmake --build . --target package --config RelWithDebInfo
```

## Некоторые дополнительные сведения о сборке

### Перекомпиляция (обновление) в однотипной конфигурации

Если вы не изменили путь к исходным файлам и сборке, просто перейдите в папку сборки и выполните:

```bash
cmake .
cmake --build . --clean-first --config RelWithDebInfo
```

Если по какой-либо причине это не работает, вы можете удалить файл `CMakeCache.txt`, расположенный в папке сборки. После этого шага вам
нужно снова запустить cmake, указав папку с исходными файлами и настроив параметры.

Если это тоже не помогает, просто очистите папку сборки и начните с начала.

### Типы сборки

Вкратце - просто используйте `--config RelWithDebInfo`, как написано выше. Это не вызовет ошибок.

Мы используем два типа сборки. Для разработки это `Debug` - он назначает флаги компилятора для оптимизации и других вещей таким образом, что это очень удобно для разработки, то есть отладочные запуски с пошаговым выполнением. Однако создаваемые двоичные файлы довольно велики и медленны для производства.

Для выпуска мы используем другой тип - `RelWithDebInfo` - что означает "сборка выпуска с отладочной информацией". Он создает производственные двоичные файлы со встроенной отладочной информацией. Последняя затем разделяется на отдельные пакеты отладочной информации, которые хранятся отдельно с пакетами выпуска и могут быть использованы в случае каких-либо проблем, таких как сбои - для исследования и исправления ошибок. Cmake также предоставляет `Release` и `MinSizeRel`, но мы их не используем. Если тип сборки недоступен, cmake создаст сборку `noconfig`.

#### Генераторы систем сборки

Существует два типа генераторов: однотипная конфигурация и многотипная конфигурация.

- Single-config требует указания типа сборки во время конфигурирования через параметр `CMAKE_BUILD_TYPE`. Если он не задан, сборка перейдет к типу `RelWithDebInfo`, который подходит, если вы просто хотите собрать Manticore из исходников и не участвовать в разработке. Для явных сборок следует указать тип сборки, например, `-DCMAKE_BUILD_TYPE=Debug`.
- Multi-config выбирает тип сборки во время сборки. Тип должен быть указан через опцию `--config`, в противном случае будет выполнена сборка типа `noconfig`, что нежелательно. Поэтому всегда указывайте тип сборки, например `--config Debug`.

Если вы хотите указать тип сборки, но не хотите заботиться о том, является ли генератор 'single' или 'multi' конфигурационным — просто укажите необходимые ключи в обоих местах. Т. е. сконфигурируйте с `-DCMAKE_BUILD_TYPE=Debug`, а затем собирайте с `--config Debug`. Главное, чтобы оба значения совпадали. Если целевой билд — single-config, он учтет параметр конфигурации. Если multi-config, параметр конфигурации будет проигнорирован, но правильная конфигурация сборки будет выбрана через ключ `--config`.

Если вам нужен `RelWithDebInfo` (то есть просто сборка для продакшена) и вы знаете, что используете single-config платформу (все, кроме Windows) — можете не указывать флаг `--config` при вызове cmake. По умолчанию будет установлен `CMAKE_BUILD_TYPE=RelWithDebInfo` и использован. Тогда все команды для 'сборки', 'установки' и 'создания пакета' будут короче.

#### Явный выбор генераторов системы сборки

Cmake — это инструмент, который сам сборку не выполняет, а генерирует правила для локальной системы сборки.
Обычно он хорошо определяет доступную систему сборки, но иногда нужно указать генератор явно. Вы
можете выполнить `cmake -G` и посмотреть список доступных генераторов.

- На Windows, если у вас установлено несколько версий Visual Studio, возможно, придется указать, какую использовать,
например:
```bash
cmake -G "Visual Studio 16 2019" ....
  ```
- On all other platforms - usually Unix Makefiles are used, but you can specify another one, such as Ninja, or Ninja Multi-Config, as:
  Multi-Config`, as:
```bash
  cmake -GNinja ...
  ```
  или
```bash
  cmake -G"Ninja Multi-Config" ...
```
Ninja Multi-Config достаточно полезен, так как он действительно 'multi-config' и доступен на Linux/macOS/BSD. С этим генератором вы можете отложить выбор типа конфигурации до времени сборки, а также собирать несколько конфигураций в одной и той же директории сборки, меняя только параметр `--config`.

### Особенности

1. Если вы хотите в итоге собрать полнофункциональный RPM пакет, путь к директории сборки должен быть достаточно длинным для корректного построения отладочной информации.
Например, как `/manticore012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789`. Это связано с тем, что инструменты RPM модифицируют путь к скомпилированным бинарям при создании отладочной информации, и могут перезаписать уже выделенное пространство, не выделяя больше. Указанный длинный путь содержит 100 символов, что вполне достаточно для такого случая.

## Внешние зависимости

Некоторые библиотеки должны быть доступны, если вы хотите их использовать.
- Для индексации (инструмент `indexer`): `expat`, `iconv`, `mysql`, `odbc`, `postgresql`. Без них можно обрабатывать только источники `tsv` и `csv`.
- Для обслуживания запросов (демон `searchd`): может понадобиться `openssl`.
- Для всех (обязательно, обязательно!) нужна библиотека Boost. Минимальная версия — 1.61.0, однако мы собираем бинарники с более свежей версией 1.75.0. Более новые версии (например, 1.76) также должны подходить. На Windows можно скачать готовый Boost с их сайта (boost.org) и установить в предложенный путь по умолчанию (например, `C:\\boost...`). На MacOs предоставляемый в brew вариант подходит. На Linux можно проверить доступную версию в официальных репозиториях, и если она не соответствует требованиям, собрать из исходников. Нам нужен компонент 'context', можно также собрать компоненты 'system' и 'program_options', они потребуются, если вы хотите также собрать библиотеку Galera из исходников. Смотрите `dist/build_dockers/xxx/boost_175/Dockerfile` для краткого самоокументированного скрипта/инструкции.

На системе сборки необходимо установить 'dev' или 'devel' версии этих пакетов (например - libmysqlclient-devel, unixodbc-devel и т. п. См. наши dockerfile для точных названий пакетов).

На системах запуска эти пакеты должны присутствовать как минимум в финальных (не-dev) версиях. (dev-версии обычно больше, так как включают не только бинарники, но и различные элементы разработки, такие как заголовочные файлы и т. п.).

### Сборка на Windows

Помимо необходимых предпосылок, вам могут понадобиться предсобранные клиентские библиотеки `expat`, `iconv`, `mysql`, и `postgresql`. Их необходимо либо собрать самим, либо связаться с нами для получения нашего сборочного пакета (простой zip-архив, где лежит папка с этими целями).

- ODBC не обязателен, так как это системная библиотека.
- OpenSSL может быть собран из исходников или скачан предсобранным с https://slproweb.com/products/Win32OpenSSL.html (как указано во внутреннем cmake-скрипте FindOpenSSL).
- Boost можно скачать предсобранным с https://www.boost.org/ releases.

### Просмотр собранных функций

Выполните `indexer -h`. Он покажет, какие возможности были сконфигурированы и собраны (явные или определённые автоматически — не имеет значения):

```
Built on Linux x86_64 by GNU 8.3.1 compiler.

Configured with these definitions: -DDISTR_BUILD=rhel8 -DUSE_SYSLOG=1 -DWITH_GALERA=1 -DWITH_RE2=1 -DWITH_RE2_FORCE_STATIC=1
-DWITH_STEMMER=1 -DWITH_STEMMER_FORCE_STATIC=1 -DWITH_ICU=1 -DWITH_ICU_FORCE_STATIC=1 -DWITH_SSL=1 -DWITH_ZLIB=1 -DWITH_ODBC=1 -DDL_ODBC=1
-DODBC_LIB=libodbc.so.2 -DWITH_EXPAT=1 -DDL_EXPAT=1 -DEXPAT_LIB=libexpat.so.1 -DWITH_ICONV=1 -DWITH_MYSQL=1 -DDL_MYSQL=1
-DMYSQL_LIB=libmariadb.so.3 -DWITH_POSTGRESQL=1 -DDL_POSTGRESQL=1 -DPOSTGRESQL_LIB=libpq.so.5 -DLOCALDATADIR=/var/lib/manticore/data
-DFULL_SHARE_DIR=/usr/share/manticore
```
<!-- proofread -->

