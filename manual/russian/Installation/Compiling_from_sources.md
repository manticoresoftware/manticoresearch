# Компиляция Manticore из исходников

Компиляция Manticore Search из исходников позволяет настраивать конфигурации сборки, такие как отключение определенных функций или добавление новых патчей для тестирования. Например, вы можете захотеть скомпилировать из исходников и отключить встроенный ICU, чтобы использовать другую версию, установленную на вашей системе, которую можно обновлять независимо от Manticore. Это также полезно, если вы заинтересованы в участии в проекте Manticore Search.

## Сборка с использованием CI Docker
Чтобы подготовить [официальные выпуска и пакеты разработки](https://repo.manticoresearch.com/), мы используем Docker и специальный образ сборки. Этот образ включает в себя необходимый инструментарий и предназначен для использования с внешними системными корнями, так что один контейнер может собирать пакеты для всех операционных систем. Вы можете собрать образ, используя [Dockerfile](https://github.com/manticoresoftware/manticoresearch/blob/master/dist/build_dockers/cross/external_toolchain/Dockerfile) и [README](https://github.com/manticoresoftware/manticoresearch/blob/master/dist/build_dockers/README.md) или использовать образ из [Docker Hub](https://hub.docker.com/r/manticoresearch/external_toolchain/tags). Это самый простой способ создать бинарные файлы для любой поддерживаемой операционной системы и архитектуры. Вам также нужно будет указать следующие переменные окружения при запуске контейнера:

* `DISTR`: целевая платформа: `bionic`, `focal`, `jammy`, `buster`, `bullseye`, `bookworm`, `rhel7`, `rhel8`, `rhel9`, `macos`, `windows`, `freebsd13`
* `arch`: архитектура: `x86_64`, `x64` (для Windows), `aarch64`, `arm64` (для Macos)
* `SYSROOT_URL`: URL архивов системных корней. Вы можете воспользоваться https://repo.manticoresearch.com/repository/sysroots, если вы не собираете системные корни самостоятельно (инструкции можно найти [здесь](https://github.com/manticoresoftware/manticoresearch/tree/master/dist/build_dockers/cross/sysroots)).
* Используйте файлы CI workflow в качестве справки, чтобы найти другие переменные окружения, которые вам, возможно, придется использовать:
  - https://github.com/manticoresoftware/manticoresearch/blob/master/.github/workflows/pack_publish.yml
  - https://github.com/manticoresoftware/manticoresearch/blob/master/.github/workflows/build_template.yml

Чтобы найти возможные значения для `DISTR` и `arch`, вы можете использовать директорию https://repo.manticoresearch.com/repository/sysroots/roots_with_zstd/ в качестве справки, так как она включает системные корни для всех поддерживаемых комбинаций.

После этого сборка пакетов внутри Docker-контейнера так же проста, как и вызов:

```bash
cmake -DPACK=1 /path/to/sources
cmake --build .
```

Например, чтобы создать пакет для Ubuntu Jammy, который будет аналогичен официальной версии, предоставляемой командой Manticore Core, вам следует выполнить следующие команды в директории, содержащей исходники Manticore Search. Эта директория является корнем клонированного репозитория с https://github.com/manticoresoftware/manticoresearch:

```bash
docker run -it --rm \
-e CACHEB="../cache" \
-e DIAGNOSTIC=1 \
-e PACK_ICUDATA=0 \
-e NO_TESTS=1 \
-e DISTR=jammy \
-e boost=boost_nov22 \
-e sysroot=roots_nov22 \
-e arch=x86_64 \
-e CTEST_CMAKE_GENERATOR=Ninja \
-e CTEST_CONFIGURATION_TYPE=RelWithDebInfo \
-e WITH_COVERAGE=0 \
-e SYSROOT_URL="https://repo.manticoresearch.com/repository/sysroots" \
-e HOMEBREW_PREFIX="" \
-e PACK_GALERA=0 \
-e UNITY_BUILD=1 \
-v $(pwd):/manticore_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \
manticoresearch/external_toolchain:vcpkg331_20250114 bash

# following is to be run inside docker shell
cd /manticore_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/
mkdir build && cd build
cmake -DPACK=1 ..
export CMAKE_TOOLCHAIN_FILE=$(pwd)/dist/build_dockers/cross/linux.cmake
cmake --build .
# or if you want to build packages:
# cmake --build . --target package
```
Длинный путь к директории исходников необходим, иначе сборка исходников в некоторых случаях может завершиться неудачей (например, в Centos).

Тот же процесс можно использовать для сборки бинарных файлов/пакетов не только для популярных дистрибутивов Linux, но и для FreeBSD, Windows и macOS.

## Сборка вручную

Компиляция Manticore без использования сборочного Docker **не рекомендована**, но если вам нужно это сделать, вот что вам может понадобиться знать:

### Необходимые инструменты

* Компилятор C++
  * В Linux - можно использовать GNU (4.7.2 и выше) или Clang
  * В Windows - Microsoft Visual Studio 2019 и выше (community edition достаточно)
  * В macOS - Clang (из инструментов командной строки XCode, используйте `xcode-select --install` для установки).
* Bison, Flex - на большинстве систем они доступны в виде пакетов, в Windows они доступны в рамках cygwin.
* Cmake - используется на всех платформах (требуется версия 3.19 и выше)

### Получение исходников

#### Из git

Исходный код Manticore [размещен на GitHub](https://github.com/manticoresoftware/manticoresearch).  
Чтобы получить исходный код, клонируйте репозиторий, а затем выберите желаемую ветку или тег. Ветка `master` представляет собой основную ветку разработки. По мере выпуска создается версия с тегом, такой как `3.6.0`, и начинается новая ветка для текущего релиза, в данном случае `manticore-3.6.0`. Головка версии ветки после всех изменений используется в качестве источника для сборки всех бинарных релизов. Например, чтобы взять исходники версии 3.6.0, вы можете выполнить:

```bash
git clone https://github.com/manticoresoftware/manticoresearch.git
cd manticoresearch
git checkout manticore-3.6.0
```

#### Из архива

Вы можете скачать необходимый код с GitHub, используя кнопку "Download ZIP". Форматы .zip и .tar.gz подходят.

```bash
wget -c https://github.com/manticoresoftware/manticoresearch/archive/refs/tags/3.6.0.tar.gz
tar -zxf 3.6.0.tar.gz
cd manticoresearch-3.6.0
```

### Конфигурирование

Manticore использует CMake. Предполагая, что вы находитесь внутри корневой директории клонированного репозитория:

```bash
mkdir build && cd build
cmake ..
```

CMake исследует доступные функции и настраивает сборку в соответствии с ними. По умолчанию все функции считаются включенными, если они доступны. Скрипт также загружает и собирает некоторые внешние библиотеки, предполагая, что вы хотите их использовать. Непрямо вы получаете поддержку максимального числа функций.

Вы также можете явно настроить сборку с помощью флагов и опций. Чтобы включить функцию `FOO`, добавьте `-DFOO=1` к вызову CMake.
Чтобы отключить ее, используйте `-DFOO=0`. Если не указано явно, включение функции, которая недоступна (например, `WITH_GALERA` при сборке под MS Windows), приведет к сбою конфигурации с ошибкой. Отключение функции, помимо исключения ее из сборки, также прекращает ее исследование в системе и отключает загрузку/сборку любых связанных внешних библиотек.

#### Флаги и опции конфигурации

- **USE_SYSLOG** - позволяет использовать `syslog` в [логировании запросов](Logging/Query_logging.md).
- **WITH_GALERA** - Включает поддержку репликации на демон поиска. Поддержка будет настроена для сборки, и источники библиотеки Galera будут загружены, собраны и включены в дистрибуцию/установку. Обычно безопасно собирать с Galera, но не распространять саму библиотеку (т.е. нет модуля Galera, нет репликации). Тем не менее, иногда может потребоваться явным образом отключить его, например, если вы хотите собрать статический бинарный файл, который по конструкции не может загружать библиотеки, так что даже наличие вызова функции 'dlopen' внутри демона вызовет ошибку линковки.
- **WITH_RE2** - Собирается с использованием библиотеки регулярных выражений RE2. Это необходимо для таких функций, как [REGEX()](../Functions/String_functions.md#REGEX%28%29), а также для [regexp_filter](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#regexp_filter)
  функции.
- **WITH_RE2_FORCE_STATIC** - Загружает источники RE2, компилирует их и линковает статически, так что финальные бинарные файлы не будут зависеть от наличия общей библиотеки `RE2` в вашей системе.
- **WITH_STEMMER** - Собирается с использованием библиотеки стеммирования Snowball.
- **WITH_STEMMER_FORCE_STATIC** - Загружает источники Snowball, компилирует их и линковает статически, так что финальные бинарные файлы не будут зависеть от наличия общей библиотеки `libstemmer` в вашей системе.
- **WITH_ICU** - Собирается с библиотекой ICU (Международные компоненты для Юникода). Она используется для сегментации китайского текста. Она используется, когда morphology=`icu_chinese` используется.
- **WITH_JIEBA** - Собирается с инструментом сегментации китайского текста Jieba. Она используется для сегментации китайского текста. Она используется, когда morphology=`jieba_chinese` используется.
- **WITH_ICU_FORCE_STATIC** - Загружает источники ICU, компилирует их и линковает статически, так что финальные бинарные файлы не будут зависеть от наличия общей библиотеки `icu` в вашей системе. Также включает файл данных ICU в установку/распределение. Цель статически слинкованного ICU — иметь библиотеку известной версии, чтобы поведение было предсказуемым и не зависело от любых системных библиотек. Вы, скорее всего, предпочтете использовать системный ICU, так как он может обновляться со временем без необходимости перекомпилировать демон Manticore. В этом случае вы должны явным образом отключить эту опцию. Это также сэкономит вам место, занимаемое файлом данных ICU (около 30М), так как он не будет включен в дистрибуцию.
- **WITH_SSL** - Используется для поддержки HTTPS, а также зашифрованных соединений MySQL с демоном. Системная библиотека OpenSSL будет связана с демоном. Это означает, что OpenSSL будет необходим для запуска демона. Это обязательно для поддержки HTTPS, но не строго обязательно для сервера (т.е. отсутствие SSL означает отсутствие возможности подключаться через HTTPS, но другие протоколы будут работать). Версии SSL библиотек от 1.0.2 до 1.1.1 могут использоваться Manticore, однако обратите внимание, что **ради безопасности настоятельно рекомендуется использовать как можно более свежую SSL
  библиотеку**. В настоящее время поддерживается только v1.1.1, остальные устарели (
  см. [стратегия выпуска openssl](https://www.openssl.org/policies/releasestrat.html)
- **WITH_ZLIB** - используется индексатором для работы с сжатыми колонками из MySQL. Используется демоном для обеспечения поддержки сжатого протокола MySQL.
- **WITH_ODBC** - используется индексатором для поддержки индексации источников из ODBC провайдеров (обычно это UnixODBC и iODBC). На MS Windows ODBC является правильным способом работы с источниками MS SQL, поэтому индексация `MSSQL` также предполагает этот флаг.
- **DL_ODBC** - не связываться с библиотекой ODBC. Если ODBC связано, но недоступно, вы не сможете запустить инструмент индексирования, даже если вы хотите обработать что-то, не связанное с ODBC. Эта опция запрашивает индексатор загрузить библиотеку только во время выполнения, когда вы хотите работать с источником ODBC.
- **ODBC_LIB** - имя файла библиотеки ODBC. Индексатор попытается загрузить этот файл, когда вы хотите обработать источник ODBC. Эта опция автоматически записывается из доступного расследования общей библиотеки ODBC. Вы также можете переопределить это имя во время выполнения, предоставив переменную окружения `ODBC_LIB` с правильным путем к альтернативной библиотеке перед запуском индексатора.
- **WITH_EXPAT** - используется индексатором для поддержки индексации xmlpipe источников.
- **DL_EXPAT** - не связываться с библиотекой EXPAT. Если EXPAT связано, но недоступно, вы не сможете запустить инструмент `indexer`, даже если вы хотите обработать что-то, не связанное с xmlpipe. Эта опция запрашивает индексатор загрузить библиотеку только во время выполнения, когда вы хотите работать с источником xmlpipe.
- **EXPAT_LIB** - имя файла библиотеки EXPAT. Индексатор попытается загрузить этот файл, когда вы хотите обработать источник xmlpipe. Эта опция автоматически записывается из доступного исследования общей библиотеки EXPAT. Вы также можете переопределить это имя во время выполнения, предоставив переменную окружения EXPAT_LIB с правильным путем к альтернативной библиотеке перед запуском индексатора.
- **WITH_ICONV** - для поддержки различных кодировок при индексации xmlpipe источников с индексатором.
- **DL_ICONV** - не связываться с библиотекой iconv. Если iconv связано, но недоступно, вы не сможете запустить инструмент `indexer`, даже если вы хотите обработать что-то, не связанное с xmlpipe. Эта опция запрашивает индексатор загрузить библиотеку только во время выполнения, когда вы хотите работать с источником xmlpipe.
- **ICONV_LIB** - имя файла библиотеки iconv. Индексатор попытается загрузить этот файл, когда вы хотите обработать источник xmlpipe. Эта опция автоматически записывается из доступного расследования общей библиотеки iconv. Вы также можете переопределить это имя во время выполнения, предоставив переменную окружения `ICONV_LIB` с правильным путем к альтернативной библиотеке перед запуском индексатора.
- **WITH_MYSQL** - используется индексатором для поддержки индексации источников MySQL.
- **DL_MYSQL** - не связывайтесь с библиотекой MySQL. Если MySQL связан, но недоступен, вы не сможете запустить инструмент `indexer`, даже если хотите обрабатывать что-то, не относящееся к MySQL. Эта опция требует от индексатора загружать библиотеку во время выполнения только когда вы хотите работать с источником MySQL.
- **MYSQL_LIB** -- имя файла библиотеки MySQL. Индексатор попытается загрузить этот файл, когда вы хотите обрабатывать источник MySQL. Эта опция автоматически записывается на основе доступной библиотеки общего доступа MySQL. Вы также можете переопределить это имя во время выполнения, предоставив переменную окружения `MYSQL_LIB` с правильным путем к альтернативной библиотеке перед запуском индексатора.
- **WITH_POSTGRESQL** - используется индексатором для поддержки индексации источников PostgreSQL.
- **DL_POSTGRESQL** - не связывайтесь с библиотекой PostgreSQL. Если PostgreSQL связан, но недоступен, вы не сможете запустить инструмент `indexer`, даже если хотите обрабатывать что-то, не относящееся к PostgreSQL. Эта опция требует от индексатора загружать библиотеку во время выполнения только когда вы хотите работать с источником PostgreSQL.
- **POSTGRESQL_LIB** - имя файла библиотеки PostgreSQL. Индексатор попытается загрузить указанный файл библиотеки PostgreSQL при обработке источника PostgreSQL. Эта опция автоматически определяется на основе доступного исследования библиотеки общего доступа PostgreSQL. Вы также можете переопределить имя во время выполнения, предоставив переменную окружения `POSTGRESQL_LIB` с правильным путем к альтернативной библиотеке перед запуском индексатора.
- **LOCALDATADIR** - путь по умолчанию, где демон хранит бинарные логи. Если этот путь не указан или явно отключен в конфигурации времени выполнения демона (т.е. в файле `manticore.conf`, который не относится к этой конфигурации сборки), бинарные логи будут помещены в этот путь. Обычно это абсолютный путь, однако необязательно, чтобы он был таковым, можно также использовать относительные пути. Вероятно, вам не потребуется изменять значение по умолчанию, определенное конфигурацией, которое, в зависимости от целевой системы, может быть чем-то вроде `/var/data`, `/var/lib/manticore/data` или `/usr/local/var/lib/manticore/data`.
- **FULL_SHARE_DIR** - путь по умолчанию, где хранятся все активы. Его можно переопределить переменной окружения `FULL_SHARE_DIR` перед запуском любого инструмента, который использует файлы из этой папки. Это важный путь, так как многие вещи ожидается найти именно там по умолчанию. К ним относятся предварительно определенные таблицы наборов символов, стоп-слова, модули Manticore и файлы данных ICU, все они помещаются в эту папку. Обычно конфигурационный скрипт определяет этот путь как что-то вроде `/usr/share/manticore` или `/usr/local/share/manticore`.
- **DISTR_BUILD** - сокращение для параметров выпуска пакетов. Это строковое значение с названием целевой платформы. Его можно использовать вместо ручной настройки всех опций. В Debian и Redhat Linux значение по умолчанию может быть определено легким интроспекцией и установлено на общее 'Debian' или 'RHEL'. В противном случае значение не определено.
- **PACK** - еще более удобное сокращение. Оно считывает переменную окружения `DISTR`, присваивает ее параметру **DISTR_BUILD** и затем работает как обычно. Это очень полезно при сборке в подготовленных системах сборки, таких как контейнеры Docker, где переменная `DISTR` установлена на уровне системы и отражает целевую систему, для которой предназначен контейнер.
- **CMAKE_INSTALL_PREFIX** (путь) - куда ожидается установка Manticore. Сборка не выполняет никаких установок, но подготавливает правила установки, которые выполняются, когда вы запускаете команду `cmake --install` или создаете пакет и затем устанавливаете его. Префикс можно изменить в любое время, даже во время установки, вызвав
  `cmake --install . --prefix /path/to/installation`. Однако, во время конфигурации эта переменная используется для инициализации значений по умолчанию `LOCALDATADIR` и `FULL_SHARE_DIR`. Например, установка этого значения на `/my/custom` во время конфигурации
  зафиксирует `LOCALDATADIR` как `/my/custom/var/lib/manticore/data`, а `FULL_SHARE_DIR` как
  `/my/custom/usr/share/manticore`.
- **BUILD_TESTING** (bool) указывает, поддерживать ли тестирование. Если включено, после сборки вы можете запустить 'ctest' и протестировать сборку. Обратите внимание, что тестирование подразумевает дополнительные зависимости, как минимум наличие PHP cli, Python и доступного сервера MySQL с тестовой базой данных. По умолчанию этот параметр включен. Итак, для 'просто сборки' вы можете отключить опцию, явно указав значение 'off'.
- **LIBS_BUNDLE** - путь к папке с различными библиотеками. Это в основном актуально для сборок под Windows, но может быть также полезно, если вам часто нужно собрать, чтобы избежать загрузки сторонних источников каждый раз. По умолчанию этот путь никогда не изменяется конфигурационным скриптом; вы должны помещать все туда вручную. Когда, скажем, нам нужна поддержка стеммера - источники будут загружены с главной страницы Snowball, затем распакованы, настроены, собраны и т.д. Вместо этого, вы можете сохранить оригинальный исходный файл архива (который является `libstemmer_c.tgz`) в этой папке. В следующий раз, когда вы захотите собрать с нуля, конфигурационный скрипт сначала поищет в архиве, и если он найдет там стеммер, он не загрузит его снова из Интернета.
- **CACHEB** - путь к папке с сохраненными сборками сторонних библиотек. Обычно такие компоненты, как galera, re2, icu и т.д., сначала загружаются или получают из архива, затем распаковываются, строятся и устанавливаются во временную внутреннюю папку. При сборке Manticore эта папка затем используется как место, где находятся необходимые для поддержки запрашиваемой функции компоненты. Наконец, они либо связываются с Manticore, если это библиотека; либо напрямую идут в дистрибуцию/установку (такие как galera или данные icu). Когда **CACHEB** определяется как параметр конфигурации cmake или как переменная окружения системы, он используется как целевая папка для этих сборок. Эта папка может храниться при сборках, так что сохраненные библиотеки там больше не будут пересобираться, что делает весь процесс сборки значительно короче.


Обратите внимание, что некоторые параметры организованы в тройках: `WITH_XXX`, `DL_XXX` и `XXX_LIB` - например, поддержка mysql, odbc и т.д. `WITH_XXX` определяет, имеют ли следующие два параметра эффект или нет. Т.е. если вы установите `WITH_ODBC` в `0` - тогда нет смысла предоставлять `DL_ODBC` и `ODBC_LIB`, и эти два не будут иметь эффекта, если вся функция отключена. Также `XXX_LIB` не имеет смысла без `DL_XXX`, потому что если вы не хотите опцию `DL_XXX`, динамическая загрузка не будет использоваться, и имя, предоставленное `XXX_LIB`, бесполезно. Это используется по умолчанию для интроспекции.

Кроме того, использование библиотеки `iconv` предполагает наличие `expat` и бесполезно, если последняя отключена.

Некоторые библиотеки могут быть всегда доступны, и поэтому нет смысла избегать связывания с ними. Например, в Windows это ODBC. На macOS это Expat, iconv и, возможно, другие. Интроспекция по умолчанию определяет такие библиотеки и эффективно выдает только `WITH_XXX` для них, без `DL_XXX` и `XXX_LIB`, что упрощает ситуацию.

При некоторых параметрах в игре конфигурация может выглядеть следующим образом:

```bash
mkdir build && cd build
cmake -DWITH_MYSQL=1 -DWITH_RE2=1 ..
```

Кроме общих значений конфигурации, вы также можете изучить файл `CMakeCache.txt`, который остается в папке сборки сразу после запуска конфигурации. Любые значения, определенные там, могут быть переопределены явно при запуске cmake. Например, вы можете запустить `cmake -DHAVE_GETADDRINFO_A=FALSE ...`, и этот запуск конфигурации не будет учитывать исследованное значение этой переменной, а будет использовать то, что вы предоставили.

#### Специфические переменные окружения

Переменные окружения полезны для предоставления некоего рода глобальных настроек, которые хранятся отдельно от конфигурации сборки и всегда присутствуют. Для сохранения они могут быть установлены глобально в системе различными способами - например, добавлением их в файл `.bashrc`, или встроением их в Dockerfile, если вы создаете систему сборки на базе докера, или записью их в системных предпочтениях переменных окружения в Windows. Кроме того, вы можете установить их временно, используя `export VAR=value` в оболочке. Или даже короче, предварив значения вызовом cmake, как `CACHEB=/my/cache cmake ...` - таким образом, это будет работать только для этого вызова и не будет видно в следующем.

Некоторые из таких переменных известны как используемые в общем случае cmake и некоторыми другими инструментами. Это такие вещи, как `CXX`, которые определяют текущий C++ компилятор, или `CXX_FLAGS` для предоставления флагов компилятора и т.д.

Тем не менее, у нас есть некоторые переменные, которые специфичны для конфигурации manticore, которые были придуманы исключительно для наших сборок.

- **CACHEB** - то же самое, что и опция конфигурации **CACHEB**
- **LIBS_BUNDLE** - то же самое, что и опция конфигурации **LIBS_BUNDLE**
- **DISTR** - используется для инициализации опции `DISTR_BUILD`, когда используется `-DPACK=1`.
- **DIAGNOSTIC** - делает вывод конфигурации cmake гораздо более подробным, объясняя все происходящее
- **WRITEB** - предполагает **LIBS_BUNDLE** и, если установлен, загрузит исходные архивные файлы для различных инструментов в папку LIBS_BUNDLE. То есть, если появляется свежая версия стеммера - вы можете вручную удалить libstemmer_c.tgz из пакета, а затем запустить одноразовое `WRITEB=1 cmake ...` - он не найдет источники стеммера в пакете и загрузит их с сайта поставщика в пакет (без WRITEB они загрузятся во временную папку внутри сборки и исчезнут, когда вы очистите папку сборки).

В конце конфигурации вы можете увидеть, что доступно и будет использовано в списке, подобном этому:

```
-- Enabled features compiled in:
* Galera, replication of tables
* re2, a regular expression library
* stemmer, stemming library (Snowball)
* icu, International Components for Unicode
* OpenSSL, for encrypted networking
* ZLIB, for compressed data and networking
* ODBC, for indexing MSSQL (windows) and generic ODBC sources with indexer
* EXPAT, for indexing xmlpipe sources with indexer
* Iconv, for support of different encodings when indexing xmlpipe sources with indexer
* MySQL, for indexing MySQL sources with indexer
* PostgreSQL, for indexing PostgreSQL sources with indexer
```

### Сборка

```bash
cmake --build . --config RelWithDebInfo
```

### Установка

Чтобы установить, выполните:

```bash
cmake --install . --config RelWithDebInfo
```

для установки в пользовательскую (непо умолчанию) папку выполните

```bash
cmake --install . --prefix path/to/build --config RelWithDebInfo
```

### Сборка пакетов

Для сборки пакета используйте цель `package`. Он создаст пакет в соответствии с выбором, предоставленным параметром `-DDISTR_BUILD`. По умолчанию это будет простой архив .zip или .tgz со всеми бинарными файлами и вспомогательными файлами.

```bash
cmake --build . --target package --config RelWithDebInfo
```

## Некоторые продвинутые вещи о сборке

### Перекомпиляция (обновление) на одноконфигурационной

Если вы не изменили путь к источникам и сборке, просто перейдите в вашу папку сборки и выполните:

```bash
cmake .
cmake --build . --clean-first --config RelWithDebInfo
```

Если по какой-то причине это не работает, вы можете удалить файл `CMakeCache.txt`, находящийся в папке сборки. После этого шага вам
нужно снова запустить cmake, указывая на папку с источниками и настраивая параметры.

Если это также не помогает, просто очистите вашу папку сборки и начните с нуля.

### Типы сборок

Кратко - просто используйте `--config RelWithDebInfo`, как написано выше. Это не приведет к ошибке.

Мы используем два типа сборок. Для разработки это `Debug` - он назначает флаги компилятора для оптимизации и других вещей таким образом, что это очень удобно для разработки, что подразумевает пошаговое выполнение отладки. Однако производимые бинарные файлы довольно большие и медленные для производства.

Для выпуска мы используем другой тип - `RelWithDebInfo` - что означает 'выпуск сборки с отладочной информацией'. Он производит производственные бинарные файлы с встроенной отладочной информацией. Последняя затем разделяется на отдельные пакеты отладочной информации, которые хранятся отдельно от пакетов выпуска и могут использоваться в случае каких-либо проблем, таких как сбои - для расследования и исправления ошибок. Cmake также предоставляет `Release` и `MinSizeRel`, но мы не используем их. Если тип сборки недоступен, cmake выполнит сборку `noconfig`.

#### Генераторы систем сборки

Есть два типа генераторов: одно-конфигурационные и много-конфигурационные.

- Одно-конфигурационные требуют указания типа сборки при конфигурации через параметр `CMAKE_BUILD_TYPE`. Если он не определен, сборка вернется к типу `RelWithDebInfo`, который подходит, если вы просто хотите собрать Manticore из источников и не участвовать в разработке. Для явных сборок вы должны указать тип сборки, например, `-DCMAKE_BUILD_TYPE=Debug`.
- Много-конфигурационные выбирают тип сборки во время сборки. Он должен быть указан с помощью параметра `--config`, в противном случае будет выполнена сборка типа `noconfig`, что нежелательно. Поэтому вы всегда должны указывать тип сборки, например, `--config Debug`.

Если вы хотите указать тип сборки, но не хотите заботиться о том, является ли он 'одиночным' или 'многофункциональным' генератором конфигурации - просто предоставьте необходимые ключи в обоих местах. Т.е. настройте с `-DCMAKE_BUILD_TYPE=Debug`, а затем собирайте с `--config Debug`. Просто убедитесь, что оба значения одинаковы. Если целевой сборщик является одиночной конфигурацией, он использует параметр конфигурации. Если это многофункциональная конфигурация, параметр конфигурации будет проигнорирован, но правильная конфигурация сборки будет выбрана по ключу `--config`.

Если вы хотите `RelWithDebInfo` (т.е. просто собирать для производства) и знаете, что вы на платформе с одиночной конфигурацией (все, кроме Windows) - вы можете опустить флаг `--config` при вызове cmake. По умолчанию будет настроено `CMAKE_BUILD_TYPE=RelWithDebInfo`, и оно будет использовано. Все команды для 'сборки', 'установки' и 'сборки пакета' станут короче.

#### Явно выберите генераторы систем сборки

Cmake - это инструмент, который не выполняет сборку самостоятельно, но он генерирует правила для локальной системы сборки.
Обычно он хорошо определяет доступную систему сборки, но иногда может потребоваться явно указать генератор. Вы
можете запустить `cmake -G` и просмотреть список доступных генераторов.

- В Windows, если у вас установлено более одной версии Visual Studio, вам может понадобиться указать, какую из них использовать,
как:
```bash
cmake -G "Visual Studio 16 2019" ....
  ```
- On all other platforms - usually Unix Makefiles are used, but you can specify another one, such as Ninja, or Ninja Multi-Config, as:
  Multi-Config`, as:
```bash
  cmake -GNinja ...
  ```
  или
```bash
  cmake -G"Ninja Multi-Config" ...
```
Ninja Multi-Config довольно полезен, так как он действительно 'многофункциональный' и доступен на Linux/macOS/BSD. С этим генератором вы можете перенести выбор типа конфигурации на время сборки, и также вы можете собирать несколько конфигураций в одной и той же папке сборки, меняя только параметр `--config`.

### Предостережения

1. Если вы хотите в конечном итоге создать полноценный RPM пакет, путь к директории сборки должен быть достаточно длинным для правильной сборки отладочных символов.
Например, вот так: `/manticore012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789`. Это потому, что инструменты RPM изменяют путь к скомпилированным бинарным файлам при сборке отладочной информации, и они могут просто записать поверх существующей области и не выделят больше. Упомянутый длинный путь имеет 100 символов, и этого вполне достаточно для такого случая.

## Внешние зависимости

Некоторые библиотеки должны быть доступны, если вы хотите их использовать.
- Для индексации (`indexer` tool): `expat`, `iconv`, `mysql`, `odbc`, `postgresql`. Без них вы можете обрабатывать только источники `tsv` и `csv`.
- Для обслуживания запросов (`searchd` daemon): может понадобиться `openssl`.
- Для всех (обязательно, обязательно!) нам нужна библиотека Boost. Минимальная версия - 1.61.0, однако мы собираем бинарные файлы с более свежей версией 1.75.0. Даже более новые версии (такие как 1.76) также подойдут. В Windows вы можете скачать готовый Boost с их сайта (boost.org) и установить его в предложенный путь по умолчанию (т.е. `C:\\boost...`). В MacOs версия из brew подойдет. В Linux вы можете проверить доступную версию в официальных репозиториях, и если она не соответствует требованиям, вы можете собрать из исходников. Нам нужен компонент 'context', вы также можете собрать компоненты 'system' и 'program_options', они будут необходимы, если вы также хотите собрать библиотеку Galera из исходников. Загляните в `dist/build_dockers/xxx/boost_175/Dockerfile` для короткого самодокументированного скрипта/инструкции о том, как это сделать.

На системе сборки вам нужно, чтобы установлены были 'dev' или 'devel' версии этих пакетов (т.е. - libmysqlclient-devel, unixodbc-devel и т.д. Смотрите наши докерфайлы для названий конкретных пакетов).

На системах запуска эти пакеты должны присутствовать хотя бы в финальных (не dev) вариантах. (варианты devel обычно больше, так как они включают не только целевые бинарные файлы, но и различные вещи для разработки, такие как заголовочные файлы и т.д.).

### Сборка на Windows

Помимо необходимых зависимостей, вам могут понадобиться предварительно собранные клиентские библиотеки `expat`, `iconv`, `mysql` и `postgresql`. Вам необходимо либо собрать их самостоятельно, либо обратиться к нам, чтобы получить наш пакет сборки (простой zip-архив, в котором находится папка с этими целевыми файлами).

- ODBC не нужен, так как это системная библиотека.
- OpenSSL может быть собран из исходников или загружен заранее собранным с https://slproweb.com/products/Win32OpenSSL.html (как упоминается в внутреннем скрипте cmake на FindOpenSSL).
- Boost может быть загружен предварительно собранным с https://www.boost.org/releases.

### Посмотрите, что скомпилировано

Запустите `indexer -h`. Это покажет, какие функции были настроены и собраны (независимо от того, являются ли они явными или исследуемыми, не имеет значения):

```
Built on Linux x86_64 by GNU 8.3.1 compiler.

Configured with these definitions: -DDISTR_BUILD=rhel8 -DUSE_SYSLOG=1 -DWITH_GALERA=1 -DWITH_RE2=1 -DWITH_RE2_FORCE_STATIC=1
-DWITH_STEMMER=1 -DWITH_STEMMER_FORCE_STATIC=1 -DWITH_ICU=1 -DWITH_ICU_FORCE_STATIC=1 -DWITH_SSL=1 -DWITH_ZLIB=1 -DWITH_ODBC=1 -DDL_ODBC=1
-DODBC_LIB=libodbc.so.2 -DWITH_EXPAT=1 -DDL_EXPAT=1 -DEXPAT_LIB=libexpat.so.1 -DWITH_ICONV=1 -DWITH_MYSQL=1 -DDL_MYSQL=1
-DMYSQL_LIB=libmariadb.so.3 -DWITH_POSTGRESQL=1 -DDL_POSTGRESQL=1 -DPOSTGRESQL_LIB=libpq.so.5 -DLOCALDATADIR=/var/lib/manticore/data
-DFULL_SHARE_DIR=/usr/share/manticore
```
<!-- proofread -->
