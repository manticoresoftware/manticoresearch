# Компиляция Manticore из исходников

Компиляция Manticore Search из исходников позволяет создавать конфигурации сборки с настройками по умолчанию, например, отключать определённые функции или добавлять новые патчи для тестирования. Например, вы можете захотеть скомпилировать из исходников и отключить встроенный ICU, чтобы использовать другую версию, установленную в вашей системе, которую можно обновлять независимо от Manticore. Это также полезно, если вы хотите внести свой вклад в проект Manticore Search.

## Сборка с использованием CI Docker
Для подготовки [официальных релизных и девелоперских пакетов](https://repo.manticoresearch.com/) мы используем Docker и специальный образ для сборки. Этот образ включает необходимые инструменты и предназначен для использования с внешними sysroot, чтобы один контейнер мог собирать пакеты для всех операционных систем. Вы можете собрать образ, используя [Dockerfile](https://github.com/manticoresoftware/manticoresearch/blob/master/dist/build_dockers/cross/external_toolchain/Dockerfile) и [README](https://github.com/manticoresoftware/manticoresearch/blob/master/dist/build_dockers/README.md), или использовать образ с [Docker Hub](https://hub.docker.com/r/manticoresearch/external_toolchain/tags). Это самый простой способ создать бинарники для любой поддерживаемой операционной системы и архитектуры. Также вам нужно будет указать следующие переменные окружения при запуске контейнера:

* `DISTR`: целевая платформа: `bionic`, `focal`, `jammy`, `buster`, `bullseye`, `bookworm`, `rhel7`, `rhel8`, `rhel9`, `rhel10`, `macos`, `windows`, `freebsd13`
* `arch`: архитектура: `x86_64`, `x64` (для Windows), `aarch64`, `arm64` (для Macos)
* `SYSROOT_URL`: URL для архивов системных root-ов. Вы можете использовать https://repo.manticoresearch.com/repository/sysroots, если не собираете systroots самостоятельно (инструкции доступны [здесь](https://github.com/manticoresoftware/manticoresearch/tree/master/dist/build_dockers/cross/sysroots)).
* Используйте файлы CI workflow как справочник, чтобы узнать о других переменных окружения, которые могут вам понадобиться:
  - https://github.com/manticoresoftware/manticoresearch/blob/master/.github/workflows/pack_publish.yml
  - https://github.com/manticoresoftware/manticoresearch/blob/master/.github/workflows/build_template.yml

Чтобы узнать возможные значения для `DISTR` и `arch`, вы можете использовать директорию https://repo.manticoresearch.com/repository/sysroots/roots_with_zstd/ как справочник, так как она содержит systroots для всех поддерживаемых комбинаций.

Далее сборка пакетов внутри Docker контейнера так же проста, как вызов:

```bash
cmake -DPACK=1 /path/to/sources
cmake --build .
```

Например, чтобы создать пакет для Ubuntu Jammy, аналогичный официальной версии, предоставляемой командой Manticore Core Team, вам нужно выполнить следующие команды в директории с исходниками Manticore Search. Эта директория является корнем клонированного репозитория с https://github.com/manticoresoftware/manticoresearch:

```bash
docker run -it --rm \
-e CACHEB="../cache" \
-e DIAGNOSTIC=1 \
-e PACK_ICUDATA=0 \
-e NO_TESTS=1 \
-e DISTR=jammy \
-e boost=boost_nov22 \
-e sysroot=roots_nov22 \
-e arch=x86_64 \
-e CTEST_CMAKE_GENERATOR=Ninja \
-e CTEST_CONFIGURATION_TYPE=RelWithDebInfo \
-e WITH_COVERAGE=0 \
-e SYSROOT_URL="https://repo.manticoresearch.com/repository/sysroots" \
-e HOMEBREW_PREFIX="" \
-e PACK_GALERA=0 \
-e UNITY_BUILD=1 \
-v $(pwd):/manticore_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \
manticoresearch/external_toolchain:vcpkg331_20250114 bash

# following is to be run inside docker shell
cd /manticore_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/
mkdir build && cd build
cmake -DPACK=1 ..
export CMAKE_TOOLCHAIN_FILE=$(pwd)/dist/build_dockers/cross/linux.cmake
cmake --build .
# or if you want to build packages:
# cmake --build . --target package
```
Требуется длинный путь к директории исходников, иначе в некоторых случаях (например, на Centos) сборка может завершиться ошибкой.

Аналогично, вы можете собрать бинарники или пакеты не только для популярных дистрибутивов Linux, но и для FreeBSD, Windows и macOS.

#### Сборка SRPM с помощью Docker

Вы также можете использовать тот же специальный docker-образ для сборки SRPM:

```bash
docker run -it --rm \
-e CACHEB="../cache" \
-e DIAGNOSTIC=1 \
-e PACK_ICUDATA=0 \
-e NO_TESTS=1 \
-e DISTR=rhel8 \
-e boost=boost_rhel_feb17 \
-e sysroot=roots_nov22 \
-e arch=x86_64 \
-e CTEST_CMAKE_GENERATOR=Ninja \
-e CTEST_CONFIGURATION_TYPE=RelWithDebInfo \
-e WITH_COVERAGE=0 \
-e SYSROOT_URL="https://repo.manticoresearch.com/repository/sysroots" \
-e HOMEBREW_PREFIX="" \
-e PACK_GALERA=0 \
-e UNITY_BUILD=1 \
-v $(pwd):/manticore_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \
manticoresearch/external_toolchain:vcpkg331_20250114 bash

# following is to be run inside docker shell
cd /manticore_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/
mkdir build && cd build
cmake -DPACK=1 ..
export CMAKE_TOOLCHAIN_FILE=$(pwd)/../dist/build_dockers/cross/linux.cmake
# The CPackSourceConfig.cmake file is now generated in the build directory
cpack -G RPM --config ./CPackSourceConfig.cmake
```

Это создаст Source RPM (`.src.rpm` файл), содержащий весь исходный код.

#### Сборка бинарных RPM из SRPM

После того как вы сгенерировали SRPM, вы можете использовать его для сборки полного набора бинарных RPM пакетов:

```bash
# Install build tools and dependencies
dnf install -y rpm-build cmake gcc-c++ boost-devel epel-release

# Install SRPM dependencies automatically
dnf builddep -y manticore-*.src.rpm

# Build all binary RPMs from the SRPM
rpmbuild --rebuild manticore-*.src.rpm

# Find the generated packages
ls ~/rpmbuild/RPMS/*/manticore*
```

> ПРИМЕЧАНИЕ: **Для сборки RPM из SRPM необходимо убедиться, что все зависимости, указанные в SRPM, полностью установлены, что может быть непросто.** Тем не менее, SRPM может быть полезен для:
> - Аудита процесса сборки или изучения исходников и spec-файлов
> - Внесения собственных изменений или патчей в сборку
> - Понимания, как были созданы бинарные файлы
> - Соблюдения требований лицензий с открытым исходным кодом

## Ручная сборка

Компиляция Manticore без использования Docker-образа **не рекомендуется**, но если вам необходимо это сделать, вот что вам может понадобиться:

### Необходимые инструменты

* Компилятор C++
  * В Linux — можно использовать GNU (версия 4.7.2 и выше) или Clang
  * В Windows — Microsoft Visual Studio 2019 и выше (достаточно community edition)
  * На macOS — Clang (из командных инструментов XCode, установите с помощью `xcode-select --install`).
* Bison, Flex — в большинстве систем доступны как пакеты, в Windows доступны в рамках cygwin.
* Cmake — используется на всех платформах (требуется версия 3.19 или выше)

### Получение исходников

#### Из git

Исходный код Manticore [размещён на GitHub](https://github.com/manticoresoftware/manticoresearch).
Чтобы получить исходный код, клонируйте репозиторий, а затем переключитесь на нужную ветку или тег. Ветка `master` представляет собой основную ветку разработки. При выпуске новой версии создаётся тег с номером версии, например, `3.6.0`, и начинается новая ветка для текущего релиза, в данном случае `manticore-3.6.0`. Головная версия этой ветки используется для сборки всех бинарных релизов. Например, чтобы взять исходники версии 3.6.0, выполните:

```bash
git clone https://github.com/manticoresoftware/manticoresearch.git
cd manticoresearch
git checkout manticore-3.6.0
```

#### Из архива

Вы можете скачать нужный код с GitHub с помощью кнопки «Download ZIP». Подходят и форматы .zip, и .tar.gz.

```bash
wget -c https://github.com/manticoresoftware/manticoresearch/archive/refs/tags/3.6.0.tar.gz
tar -zxf 3.6.0.tar.gz
cd manticoresearch-3.6.0
```

### Конфигурация

Manticore использует CMake. Предполагая, что вы находитесь в корневой директории клонированного репозитория:

```bash
mkdir build && cd build
cmake ..
```

CMake исследует доступные функции и настроит сборку в соответствии с ними. По умолчанию все функции считаются включёнными, если они доступны. Скрипт также скачивает и собирает некоторые внешние библиотеки, предполагая, что вы хотите их использовать. По умолчанию вы получаете поддержку максимального количества функций.

Вы также можете явно настроить сборку с помощью флагов и опций. Чтобы включить функцию `FOO`, добавьте `-DFOO=1` в вызов CMake.
Чтобы отключить его, используйте `-DFOO=0`. Если не указано иное, активация функции, которая недоступна (например, `WITH_GALERA` на сборке MS Windows), приведет к сбою конфигурации с ошибкой. Отключение функции, помимо исключения ее из сборки, также отключает ее исследование в системе и отключает загрузку/сборку любых связанных внешних библиотек.

#### Флаги конфигурации и параметры

- **USE_SYSLOG** - позволяет использовать `syslog` в [логировании запросов](../Logging/Query_logging.md).
- **WITH_GALERA** - включает поддержку репликации на демон поиска. Поддержка будет настроена для сборки, источники для библиотеки Galera будут загружены, собраны и включены в дистрибуцию/установку. Обычно безопасно собирать с Galera, но не распространять саму библиотеку (то есть нет модуля Galera, нет репликации). Однако иногда может понадобиться явно отключить ее, например, если вы хотите собрать статический бинарный файл, который по своему дизайну не может загружать никакие библиотеки, так что даже наличие вызова функции 'dlopen' внутри демона приведет к ошибке линковки.
- **WITH_RE2** - собирает с использованием библиотеки регулярных выражений RE2. Это необходимо для таких функций, как [REGEX()](../Functions/String_functions.md#REGEX%28%29) и [regexp_filter](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#regexp_filter)
  функция.
- **WITH_RE2_FORCE_STATIC** - загружает источники RE2, компилирует их и линковает статически, так что конечные бинарные файлы не будут зависеть от наличия общей библиотеки `RE2` в вашей системе.
- **WITH_STEMMER** - собирает с использованием библиотеки стемминга Snowball.
- **WITH_STEMMER_FORCE_STATIC** - загружает источники Snowball, компилирует их и линковает статически, так что конечные бинарные файлы не будут зависеть от наличия общей библиотеки `libstemmer` в вашей системе.
- **WITH_ICU** -  собирает с библиотекой ICU (International Components for Unicode). Она используется для сегментации китайского текста. Она используется, когда morphology=`icu_chinese`.
- **WITH_JIEBA** -  собирает с инструментом сегментации китайского текста Jieba. Он используется для сегментации китайского текста. Он используется, когда morphology=`jieba_chinese`.
- **WITH_ICU_FORCE_STATIC** - загружает источники ICU, компилирует их и линковает статически, чтобы конечные бинарные файлы не зависели от наличия общей библиотеки `icu` в вашей системе. Также включает файл данных ICU в установку/распределение. Цель статически подключенной ICU - иметь библиотеку известной версии, чтобы поведение было определено и не зависело от каких-либо системных библиотек. Вы, скорее всего, предпочтете использовать системную ICU, так как она может быть обновлена со временем без необходимости перекомпиляции демона Manticore. В этом случае вам нужно явно отключить эту опцию. Это также сэкономит вам место, занимаемое файлом данных ICU (около 30M), так как он не будет включен в дистрибуцию.
- **WITH_SSL** - используется для поддержки HTTPS, а также зашифрованных соединений MySQL с демоном. Системная библиотека OpenSSL будет подключена к демону. Это подразумевает, что OpenSSL будет необходим для запуска демона. Это обязательно для поддержки HTTPS, но не строго обязательно для сервера (т.е. отсутствие SSL означает отсутствие возможности подключения через HTTPS, но другие протоколы будут работать). Версии библиотеки SSL, начиная с 1.0.2 и до 1.1.1, могут использоваться Manticore, однако обратите внимание, что **из соображений безопасности настоятельно рекомендуется использовать самую свежую библиотеку SSL
  библиотека**. В настоящее время поддерживается только v1.1.1, остальные устарели (
  смотрите [стратегию релиза openssl](https://www.openssl.org/policies/releasestrat.html)
- **WITH_ZLIB** - используется индексатором для работы со сжатыми столбцами из MySQL. Используется демон для обеспечения поддержки сжатого протокола MySQL.
- **WITH_ODBC** - используется индексатором для поддержки источников индексации из ODBC-провайдеров (обычно это UnixODBC и iODBC). На MS Windows ODBC является надлежащим способом работы с источниками MS SQL, поэтому индексация `MSSQL` также подразумевает этот флаг.
- **DL_ODBC** - не связываться с библиотекой ODBC. Если ODBC связана, но недоступна, вы не можете запустить инструмент индексатора, даже если хотите обработать что-то, не относящееся к ODBC. Эта опция просит индексатор загружать библиотеку во время выполнения только тогда, когда вы хотите иметь дело с источником ODBC.
- **ODBC_LIB** - имя файла библиотеки ODBC. Индексатор попытается загрузить этот файл, когда вы захотите обработать источник ODBC. Эта опция автоматически записывается на основе доступной проверки общей библиотеки ODBC. Вы также можете переопределить это имя во время выполнения, предоставив переменную окружения `ODBC_LIB` с правильным путем к альтернативной библиотеке перед запуском индексатора.
- **WITH_EXPAT** - используется индексатором для поддержки индексации источников xmlpipe.
- **DL_EXPAT** - не связываться с библиотекой EXPAT. Если EXPAT связана, но недоступна, вы не можете запустить инструмент `indexer`, даже если хотите обработать что-то, не относящееся к xmlpipe. Эта опция просит индексатор загружать библиотеку во время выполнения только тогда, когда вы хотите иметь дело с источником xmlpipe.
- **EXPAT_LIB** - имя файла библиотеки EXPAT. Индексатор попытается загрузить этот файл, когда вы захотите обработать источник xmlpipe. Эта опция автоматически записывается на основе доступной проверки общей библиотеки EXPAT. Вы также можете переопределить это имя во время выполнения, предоставив переменную окружения EXPAT_LIB с правильным путем к альтернативной библиотеке перед запуском индексатора.
- **WITH_ICONV** - для поддержки различных кодировок при индексации источников xmlpipe с индексатором.
- **DL_ICONV** - не связываться с библиотекой iconv. Если iconv связана, но недоступна, вы не можете запустить инструмент `indexer`, даже если хотите обработать что-то, не относящееся к xmlpipe. Эта опция просит индексатор загружать библиотеку во время выполнения только тогда, когда вы хотите иметь дело с источником xmlpipe.
- **ICONV_LIB** - имя файла библиотеки iconv. Индексер попытается загрузить этот файл, когда вы захотите обработать источник xmlpipe. Эта опция автоматически записывается на основе исследования доступной разделяемой библиотеки iconv. Вы также можете переопределить это имя во время выполнения, задав переменную окружения `ICONV_LIB` с правильным путем к альтернативной библиотеке перед запуском индексера.
- **WITH_MYSQL** - используется индексером для поддержки индексирования источников MySQL.
- **DL_MYSQL** - не связывать с библиотекой MySQL. Если MySQL связан, но недоступен, вы не сможете запустить инструмент `indexer`, даже если хотите обработать что-то, не связанное с MySQL. Эта опция требует от индексера загрузки библиотеки во время выполнения только тогда, когда вы хотите работать с источником MySQL.
- **MYSQL_LIB** -- имя файла библиотеки MySQL. Индексер попытается загрузить этот файл, когда вы захотите обработать источник MySQL. Эта опция автоматически записывается на основе исследования доступной разделяемой библиотеки MySQL. Вы также можете переопределить это имя во время выполнения, задав переменную окружения `MYSQL_LIB` с правильным путем к альтернативной библиотеке перед запуском индексера.
- **WITH_POSTGRESQL** - используется индексером для поддержки индексирования источников PostgreSQL.
- **DL_POSTGRESQL** - не связывать с библиотекой PostgreSQL. Если PostgreSQL связан, но недоступен, вы не сможете запустить инструмент `indexer`, даже если хотите обработать что-то, не связанное с PostgreSQL. Эта опция требует от индексера загрузки библиотеки во время выполнения только тогда, когда вы хотите работать с источником PostgreSQL.
- **POSTGRESQL_LIB** - имя файла библиотеки postgresql. Индексер попытается загрузить указанный файл библиотеки postgresql при обработке источника postgresql. Эта опция автоматически определяется на основе исследования доступной разделяемой библиотеки postgresql. Вы также можете переопределить имя во время выполнения, задав переменную окружения `POSTGRESQL_LIB` с правильным путем к альтернативной библиотеке перед запуском индексера.
- **LOCALDATADIR** - путь по умолчанию, где демон хранит binlogs. Если этот путь не указан или явно отключен в конфигурации времени выполнения демона (например, в файле `manticore.conf`, который не связан с этой конфигурацией сборки), binlogs будут размещены в этом пути. Обычно это абсолютный путь, однако не обязательно, можно использовать и относительные пути. Скорее всего, вам не потребуется менять значение по умолчанию, определенное в конфигурации, которое в зависимости от целевой системы может быть таким, как `/var/data`, `/var/lib/manticore/data` или `/usr/local/var/lib/manticore/data`.
- **FULL_SHARE_DIR** - путь по умолчанию, где хранятся все ресурсы. Его можно переопределить переменной окружения `FULL_SHARE_DIR` перед запуском любого инструмента, который использует файлы из этой папки. Это важный путь, поскольку там по умолчанию ожидается наличие многих файлов. Включая предопределённые таблицы кодировки, стоп-слова, модули manticore и файлы данных icu, все они размещены в этой папке. Скрипт конфигурации обычно определяет этот путь как что-то вроде `/usr/share/manticore` или `/usr/local/share/manticore`.
- **DISTR_BUILD** - сокращение для опций выпуска пакетов. Это строковое значение с названием целевой платформы. Может использоваться вместо ручной настройки всех опций. В Debian и Redhat Linux значение по умолчанию может определяться лёгкой проверкой и устанавливаться как общее 'Debian' или 'RHEL'. В противном случае значение не определено.
- **PACK** - ещё более удобное сокращение. Оно читает переменную окружения `DISTR`, присваивает её параметру **DISTR_BUILD** и затем работает как обычно. Очень полезно при сборке в готовых системах сборки, таких как контейнеры Docker, где переменная `DISTR` устанавливается на уровне системы и отражает целевую систему, для которой предназначен контейнер.
- **CMAKE_INSTALL_PREFIX** (путь) - где ожидается установка Manticore. Сборка не выполняет установку, но готовит правила установки, которые выполняются при запуске команды `cmake --install` или при создании пакета и последующей установке. Префикс может быть изменён в любое время, даже во время установки, вызвав
  `cmake --install . --prefix /path/to/installation`. Однако, во время конфигурации эта переменная используется для инициализации значений по умолчанию для `LOCALDATADIR` и `FULL_SHARE_DIR`. Например, установка её в `/my/custom` на этапе конфигурации
  жёстко установит `LOCALDATADIR` как `/my/custom/var/lib/manticore/data`, а `FULL_SHARE_DIR` как
  `/my/custom/usr/share/manticore`.
- **BUILD_TESTING** (bool) - поддержка тестирования. Если включено, после сборки вы сможете запускать 'ctest' и тестировать сборку. Учтите, что для тестирования требуются дополнительные зависимости, такие как, по крайней мере, наличие PHP cli, Python и доступный сервер MySQL с тестовой базой данных. По умолчанию этот параметр включён. Так что для «просто сборки» возможно вы захотите отключить этот параметр, явно указав значение 'off'.
- **BUILD_SRPMS** (bool) - показывать инструкции по созданию Source RPM (SRPM). Из-за ограничений CPack с упаковкой по компонентам, SRPM не могут быть сгенерированы напрямую вместе с бинарными RPM. При включении эта опция заставит систему сборки выводить инструкции для правильного создания SRPM с помощью метода конфигурации исходников. По умолчанию параметр выключен.
- **LIBS_BUNDLE** - путь к папке с различными библиотеками. В основном актуально для сборки под Windows, но также может быть полезно при частой сборке, чтобы избежать скачивания сторонних исходников каждый раз. По умолчанию этот путь не изменяется скриптом конфигурации; всё туда нужно помещать вручную. Когда, например, нужна поддержка стеммера - исходники загружаются с главной страницы Snowball, затем распаковываются, настраиваются, собираются и т.д. Вместо этого можно хранить оригинальный исходный tarball (в данном случае это `libstemmer_c.tgz`) в этой папке. В следующий раз при сборке с нуля скрипт конфигурации сначала посмотрит в этом бандле, и если найдёт там стеммер, не станет скачивать его повторно из интернета.
- **CACHEB** - путь к папке соstored builds сторонних библиотек. Обычно такие компоненты, как galera, re2, icu и т.д., сначала загружаются или извлекаются из пакета, затем распаковываются, собираются и устанавливаются во временную внутреннюю папку. При сборке manticore эта папка используется как место, где находятся необходимые для поддержки запрашиваемой функции элементы. Наконец, они либо связываются с manticore, если это библиотека; либо идут напрямую к распределению/установке (как galera или данные icu). Когда **CACHEB** определен как параметр конфигурации cmake или как системная переменная окружения, он используется как целевая папка для этих сборок. Эта папка может храниться между сборками, чтобы сохраненные библиотеки там не пересобирались больше, что делает весь процесс сборки намного короче.


Обратите внимание, что некоторые опции организованы в тройки: `WITH_XXX`, `DL_XXX` и `XXX_LIB` - например, поддержка mysql, odbc и т.д. `WITH_XXX` определяет, имеют ли эффект следующие два. То есть, если вы установите `WITH_ODBC` в `0`, нет смысла предоставлять `DL_ODBC` и `ODBC_LIB`, и эти два не окажут влияния, если вся функция отключена. Также `XXX_LIB` не имеет смысла без `DL_XXX`, потому что если вы не хотите опцию `DL_XXX`, динамическая загрузка не будет использоваться, и имя, предоставленное `XXX_LIB`, бесполезно. Это используется по умолчанию для интроспекции.

Кроме того, использование библиотеки `iconv` предполагает наличие `expat` и бесполезно, если последнее отключено.

Также некоторые библиотеки могут быть всегда доступны, и поэтому нет смысла избегать связывания с ними. Например, в Windows это ODBC. На macOS это Expat, iconv и возможно другие. Интроспекция по умолчанию определяет такие библиотеки и эффективно выдает только `WITH_XXX` для них, без `DL_XXX` и `XXX_LIB`, что упрощает процесс.

При некоторых настройках в игре конфигурирование может выглядеть так:

```bash
mkdir build && cd build
cmake -DWITH_MYSQL=1 -DWITH_RE2=1 ..
```

Кроме общего значения конфигурации, вы также можете изучить файл `CMakeCache.txt`, который остается в папке сборки сразу после того, как вы запустите конфигурацию. Любые значения, определенные там, могут быть переопределены явно при запуске cmake. Например, вы можете запустить `cmake -DHAVE_GETADDRINFO_A=FALSE ...`, и этот конфигурационный запуск не будет принимать исследуемое значение этой переменной, а будет использовать то, что вы предоставили.

#### Специфические переменные окружения

Переменные окружения полезны для предоставления некоторых глобальных настроек, которые хранятся отдельно от конфигурации сборки и всегда присутствуют. Для постоянства их можно установить глобально в системе различными способами - например, добавив их в файл `.bashrc`, или встроив их в Dockerfile, если вы создаете сборочную систему на основе Docker, или записав их в системные переменные окружения в Windows. Также вы можете установить их непродолжительными, используя `export VAR=value` в оболочке. Или даже короче, предварив значения вызовом cmake, например, `CACHEB=/my/cache cmake ...` - таким образом это будет работать только для этого вызова и не будет видно в следующем.

Некоторые из таких переменных известны как используемые в общем cmake и некоторых других инструментах. Это такие вещи, как `CXX`, который определяет текущий компилятор C++, или `CXX_FLAGS` для задания флагов компилятора и т.д.

Однако у нас есть некоторые переменные, специфичные для конфигурации manticore, которые были придуманы исключительно для наших сборок.

- **CACHEB** - то же, что и параметр конфигурации **CACHEB**
- **LIBS_BUNDLE** - то же, что и параметр конфигурации **LIBS_BUNDLE**
- **DISTR** - используется для инициализации параметра `DISTR_BUILD`, когда используется `-DPACK=1`.
- **DIAGNOSTIC** - делает вывод конфигурации cmake намного более подробным, объясняя все происходящее
- **WRITEB** - подразумевает **LIBS_BUNDLE** и, если установлен, будет загружать архивы с исходниками для различных инструментов в папку LIBS_BUNDLE. То есть, если выходит свежая версия стеммера - вы можете вручную удалить libstemmer_c.tgz из пакета и затем выполнить однократный `WRITEB=1 cmake ...` - он не найдет исходники стеммера в пакете и затем загрузит их с сайта поставщика в пакет (без WRITEB он загрузит их во временную папку внутри сборки и удалится при очистке папки сборки).

В конце конфигурации вы можете увидеть, что доступно и будет использовано в списке, похожем на этот:

```
-- Enabled features compiled in:
* Galera, replication of tables
* re2, a regular expression library
* stemmer, stemming library (Snowball)
* icu, International Components for Unicode
* OpenSSL, for encrypted networking
* ZLIB, for compressed data and networking
* ODBC, for indexing MSSQL (windows) and generic ODBC sources with indexer
* EXPAT, for indexing xmlpipe sources with indexer
* Iconv, for support of different encodings when indexing xmlpipe sources with indexer
* MySQL, for indexing MySQL sources with indexer
* PostgreSQL, for indexing PostgreSQL sources with indexer
```

### Сборка

```bash
cmake --build . --config RelWithDebInfo
```

### Установка

Чтобы установить, выполните:

```bash
cmake --install . --config RelWithDebInfo
```

чтобы установить в пользовательскую (не по умолчанию) папку, выполните

```bash
cmake --install . --prefix path/to/build --config RelWithDebInfo
```

### Сборка пакетов

Для сборки пакета используйте цель `package`. Это соберет пакет в соответствии с выбором, предоставленным параметром `-DDISTR_BUILD`. По умолчанию это будет простой архив .zip или .tgz со всеми двоичными файлами и дополнительными файлами.

```bash
cmake --build . --target package --config RelWithDebInfo
```

## Некоторые расширенные аспекты сборки

### Пересборка (обновление) в одноконфигурационном режиме

Если вы не изменили путь к источникам и сборке, просто перейдите в папку сборки и выполните:

```bash
cmake .
cmake --build . --clean-first --config RelWithDebInfo
```

Если по какой-либо причине это не работает, вы можете удалить файл `CMakeCache.txt`, расположенный в папке сборки. После этого шага вам
необходимо запустить cmake снова, указав на папку исходников и сконфигурировав параметры.

Если это также не поможет, просто очистите папку сборки и начинайте с нуля.

### Типы сборки

Кратко - просто используйте `--config RelWithDebInfo`, как указано выше. Это исключит возможность ошибки.

Мы используем два типа сборки. Для разработки это `Debug` - он назначает флаги компилятора для оптимизации и других вещей так, чтобы он был очень удобен для разработки, что означает, что отладка проходит с поэтапным выполнением. Однако производимые двоичные файлы довольно большие и медленные для продакшна.

Для выпуска мы используем другой тип - `RelWithDebInfo` - что означает 'релизная сборка с отладочной информацией'. Это производит производственные двоичные файлы с встроенной отладочной информацией. Последняя затем разделяется на отдельные пакеты debuginfo, которые хранятся отдельно от релизных пакетов и могут быть использованы в случае каких-либо проблем, таких как сбои - для расследования и исправления ошибок. Cmake также предоставляет `Release` и `MinSizeRel`, но мы их не используем. Если тип сборки недоступен, cmake выполнит сборку `noconfig`.

#### Генераторы сборочной системы

Существуют два типа генераторов: одноконфигурационные и многоконфигурационные.

- Single-config требует указания типа сборки во время конфигурации через параметр `CMAKE_BUILD_TYPE`. Если он не определён, сборка по умолчанию перейдёт к типу `RelWithDebInfo`, который подходит, если вы просто хотите собрать Manticore из исходников, не участвуя в разработке. Для явных сборок следует указать тип сборки, например `-DCMAKE_BUILD_TYPE=Debug`.
- Multi-config выбирает тип сборки во время процесса сборки. Его следует указывать с помощью опции `--config`, иначе будет собираться тип `noconfig`, что нежелательно. Поэтому всегда нужно указывать тип сборки, например `--config Debug`.

Если вы хотите указать тип сборки, но не хотите беспокоиться о том, используется ли генератор с «одной» или «множественной» конфигурацией — просто укажите необходимые ключи в обоих местах. То есть, сконфигурируйте с `-DCMAKE_BUILD_TYPE=Debug`, а затем собирайте с `--config Debug`. Просто убедитесь, что оба значения совпадают. Если сборщик нацелен на single-config, он использует параметр конфигурации. Если multi-config — параметр конфигурации игнорируется, а нужный тип сборки выбирается ключом `--config`.

Если вам нужен `RelWithDebInfo` (т.е. просто сборка для продакшена) и вы знаете, что находитесь на платформе с single-config (это все, кроме Windows), можно опустить флаг `--config` при вызове cmake. Тогда по умолчанию будет настроен `CMAKE_BUILD_TYPE=RelWithDebInfo` и использован. Все команды для «сборки», «установки» и «создания пакета» станут короче.

#### Явный выбор генераторов системы сборки

CMake — это инструмент, который сам не выполняет сборку, а генерирует правила для локальной системы сборки.
Обычно он хорошо определяет доступную систему сборки, но иногда может понадобиться явно указать генератор. Вы
можете запустить `cmake -G` и просмотреть список доступных генераторов.

- В Windows, если у вас установлено несколько версий Visual Studio, может потребоваться указать, какую использовать,
например:
```bash
cmake -G "Visual Studio 16 2019" ....
  ```
- On all other platforms - usually Unix Makefiles are used, but you can specify another one, such as Ninja, or Ninja Multi-Config, as:
  Multi-Config`, as:
```bash
  cmake -GNinja ...
  ```
  или
```bash
  cmake -G"Ninja Multi-Config" ...
```
Ninja Multi-Config очень удобен тем, что он действительно «multi-config» и доступен на Linux/macOS/BSD. С этим генератором можно отложить выбор типа конфигурации на момент сборки, а также иметь возможность собирать несколько конфигураций в одной и той же папке сборки, меняя только параметр  `--config`.

### Особенности

1. Если вы хотите в итоге собрать полнофункциональный RPM-пакет, путь к каталогу сборки должен быть достаточно длинным для корректной генерации отладочной информации.
Например, как `/manticore012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789`. Это связано с тем, что инструменты RPM модифицируют путь к скомпилированным бинарникам при создании отладочной информации, и они могут просто перезаписать существующее пространство без выделения большего. Указанный длинный путь содержит 100 символов, чего обычно достаточно для такого случая.

## Внешние зависимости

Некоторые библиотеки должны быть доступны, если вы хотите их использовать.
- Для индексации (утилита `indexer`): `expat`, `iconv`, `mysql`, `odbc`, `postgresql`. Без них можно обрабатывать только исходники формата `tsv` и `csv`.
- Для обработки запросов (демон `searchd`): может потребоваться `openssl`.
- Для всех (обязательно!) необходима библиотека Boost. Минимальная версия — 1.61.0, однако мы компилируем бинарники с более свежей версией 1.75.0. Ещё более новые версии (например, 1.76) тоже подходят. В Windows можно скачать предварительно собранный Boost с их сайта (boost.org) и установить в предложенный по умолчанию путь (например, `C:\\boost...`). На MacOs версия из brew подходит. На Linux можно проверить доступную в официальных репозиториях версию, и если она не соответствует требованиям, собрать из исходников. Нам нужен компонент 'context', можно также собрать компоненты 'system' и 'program_options', они понадобятся, если вы хотите собрать библиотеку Galera из исходников. Инструкции можно найти в `dist/build_dockers/xxx/boost_175/Dockerfile` — это краткий самодокументированный скрипт/инструкция по сборке.

На системе сборки должны быть установлены версии пакетов с суффиксами 'dev' или 'devel' (например, libmysqlclient-devel, unixodbc-devel и т.п. Названия конкретных пакетов смотрите в наших dockerfile).

На целевых системах должны присутствовать хотя бы финальные (не-dev) варианты этих пакетов. (devel-варианты обычно больше, так как содержат не только готовые бинарники, но и различные средства разработки, такие как заголовочные файлы и т.п.).

### Сборка на Windows

Помимо необходимых предварительных условий, могут понадобиться предварительно собранные клиентские библиотеки `expat`, `iconv`, `mysql` и `postgresql`. Их можно либо собрать самостоятельно, либо обратиться к нам за пакетом сборки (простой zip-архив с папкой, содержащей эти цели).

- ODBC не требуется, так как это системная библиотека.
- OpenSSL можно либо собрать из исходников, либо скачать предварительно собранный с https://slproweb.com/products/Win32OpenSSL.html (как указано во внутреннем скрипте cmake на FindOpenSSL).
- Boost можно скачать предварительно собранный с https://www.boost.org/ releases.

### Просмотр собранных компонентов

Запустите `indexer -h`. Он покажет, какие функции были сконфигурированы и собраны (явно или найдены автоматически, это не важно):

```
Built on Linux x86_64 by GNU 8.3.1 compiler.

Configured with these definitions: -DDISTR_BUILD=rhel8 -DUSE_SYSLOG=1 -DWITH_GALERA=1 -DWITH_RE2=1 -DWITH_RE2_FORCE_STATIC=1
-DWITH_STEMMER=1 -DWITH_STEMMER_FORCE_STATIC=1 -DWITH_ICU=1 -DWITH_ICU_FORCE_STATIC=1 -DWITH_SSL=1 -DWITH_ZLIB=1 -DWITH_ODBC=1 -DDL_ODBC=1
-DODBC_LIB=libodbc.so.2 -DWITH_EXPAT=1 -DDL_EXPAT=1 -DEXPAT_LIB=libexpat.so.1 -DWITH_ICONV=1 -DWITH_MYSQL=1 -DDL_MYSQL=1
-DMYSQL_LIB=libmariadb.so.3 -DWITH_POSTGRESQL=1 -DDL_POSTGRESQL=1 -DPOSTGRESQL_LIB=libpq.so.5 -DLOCALDATADIR=/var/lib/manticore/data
-DFULL_SHARE_DIR=/usr/share/manticore
```
<!-- proofread -->

