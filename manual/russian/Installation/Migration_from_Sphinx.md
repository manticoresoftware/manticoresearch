# Миграция с Sphinx Search

## Sphinx 2.x -> Manticore 2.x
Manticore Search 2.x сохраняет совместимость с Sphinxsearch 2.x и может загружать существующие таблицы, созданные Sphinxsearch. В большинстве случаев обновление сводится к замене бинарных файлов.

Вместо sphinx.conf (в Linux обычно расположен по адресу `/etc/sphinxsearch/sphinx.conf`) Manticore по умолчанию использует `/etc/manticoresearch/manticore.conf`. Он также работает под другим пользователем и использует другие папки.

Имя службы systemd изменилось с `sphinx/sphinxsearch` на `manticore`, и служба работает под пользователем `manticore` (Sphinx использовал `sphinx` или `sphinxsearch`). Также используется другая папка для файла PID.

Папки, используемые по умолчанию, это `/var/lib/manticore`, `/var/log/manticore`, `/var/run/manticore`. Вы все еще можете использовать существующую конфигурацию Sphinx, но вам нужно вручную изменить права доступа для папок `/var/lib/sphinxsearch` и `/var/log/sphinxsearch`. Или просто глобально переименуйте 'sphinx' в 'manticore' в системных файлах. Если вы используете другие папки (для данных, файлов форм слов и т. д.), право собственности также должно быть изменено на пользователя `manticore`. Расположение `pid_file` должно быть изменено, чтобы соответствовать manticore.service на `/var/run/manticore/searchd.pid`.

Если вы хотите использовать папку Manticore вместо этого, файлы таблиц необходимо переместить в новую папку данных (`/var/lib/manticore`), и права доступа должны быть изменены на пользователя `manticore`.

## Sphinx 2.x / Manticore 2.x -> Manticore 3.x
Обновление с Sphinx / Manticore 2.x до 3.x не является тривиальным, так как хранение таблиц прошло значительное обновление, и новый searchd не может загружать старые таблицы и обновлять их до нового формата на лету.

Manticore Search 3 получил переработанное хранение таблиц. Таблицы, созданные с Manticore/Sphinx 2.x, не могут быть загружены Manticore Search 3 без [конвертации](../Installation/Migration_from_Sphinx.md#index_converter). Из-за ограничения в 4 ГБ реальная таблица в 2.x могла все еще иметь несколько дисковых частей после операции оптимизации. После обновления до 3.x эти таблицы теперь могут быть оптимизированы в 1-дисковую часть с помощью обычной команды [OPTIMIZE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE). Индексные файлы также изменились. Единственный компонент, который не претерпел структурных изменений, это файл `.spp` (hitlists). `.sps` (строки/json) и `.spm` (MVA) теперь хранятся в `.spb` (атрибуты переменной длины). Новый формат включает файл `.spm`, но он используется для отображения строки (ранее он был предназначен для атрибутов MVA). Новые добавленные расширения: `.spt` (поиск docid), `.sphi` (гистограммы вторичных индексов), `.spds` (хранение документов). В случае, если вы используете скрипты, которые манипулируют файлами таблиц, их следует адаптировать для новых расширений файлов.

Процедура обновления может отличаться в зависимости от вашей настройки (количество серверов в кластере, есть ли у вас высокая доступность и т. д.), но в общем она включает создание новых версий таблиц 3.x и замену существующих, а также замену старых бинарных файлов 2.x на новые.

Существуют два специальных требования:

* Реальные таблицы необходимо сбрасывать с использованием [FLUSH RAMCHUNK](../Securing_and_compacting_a_table/Flushing_RAM_chunk_to_a_new_disk_chunk.md#FLUSH-RAMCHUNK)
* Простые таблицы с убивающими списками требуют добавления новой директивы в конфигурацию таблицы (см. [killlist_target](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#killlist_target))

Manticore Search 3 включает новый инструмент - [index_converter](../Installation/Migration_from_Sphinx.md#index_converter) - который может конвертировать таблицы Sphinx 2.x / Manticore 2.x в формат 3.x. `index_converter` поставляется в отдельном пакете, который следует установить сначала. Используя инструмент конвертации, создайте версии таблиц 3.x. `index_converter` может записывать новые файлы в существующую папку данных и создавать резервные копии старых файлов или может записывать новые файлы в выбранную папку.

## Основные инструкции по обновлению

Если у вас один сервер:

* Установите пакет manticore-converter
* Используйте index_converter для создания новых версий таблиц в другой папке, чем существующая папка данных (используя опцию `--output-dir`)
* Остановите существующий Manticore/Sphinx, обновите до 3.0, переместите новые таблицы в папку данных и запустите Manticore

Чтобы минимизировать время простоя, вы можете скопировать таблицы 2.x, конфигурацию (вам нужно будет отредактировать пути здесь для таблиц, журналов и различных портов) и бинарные файлы в отдельное место и запустить это на отдельном порту. Укажите ваше приложение на него. После обновления до 3.0 и запуска нового сервера вы можете переключить приложение обратно на обычные порты. Если все хорошо, остановите копию 2.x и удалите файлы, чтобы освободить место.

Если у вас есть запасной сервер (например, сервер тестирования или подготовки), вы можете сначала выполнить обновление таблиц там и даже установить Manticore 3 для проведения нескольких тестов. Если все в порядке, скопируйте новые файлы таблиц на производственный сервер. Если у вас несколько серверов, которые можно отключить от производства, делайте это один за другим и выполняйте обновление на каждом. Для распределенных установок, searchd 2.x может работать как мастер с узлами 3.x, поэтому вы можете сначала выполнить обновление на узлах данных, а затем на главном узле.

Не было внесено изменений в способ подключения клиентов к движку или какие-либо изменения в режиме запроса или поведении запросов.

## Убивающие списки в Sphinx / Manticore 2.x против Manticore 3.x
[Убивающие списки](../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md) были переработаны в Manticore Search 3. В предыдущих версиях убивающие списки применялись к набору результатов, предоставленному каждой ранее запрашиваемой таблицей во время запроса.

Таким образом, в 2.x порядок таблицы во время запроса имел значение. Например, если у дельтовой таблицы был убивающий список, чтобы применить его к основной таблице, порядок должен был быть основным, дельтовым (либо в распределенной таблице, либо в предложении FROM).
В Manticore 3 списки удаления применяются к таблице, когда она загружается во время запуска searchd или переключается. Новый директив `killlist_target` в конфигурации таблицы указывает целевые таблицы и определяет, какие идентификаторы документов из исходной таблицы должны использоваться для подавления. Это могут быть идентификаторы из определенного списка удаления, фактические идентификаторы документов таблицы или оба.

Документы из списков удаления удаляются из целевых таблиц, они не возвращаются в результатах, даже если поиск не включает таблицу, которая предоставила списки удаления. Из-за этого порядок таблиц для поиска больше не имеет значения. Теперь `delta, main` и `main, delta` будут предоставлять одни и те же результаты.

В предыдущих версиях таблицы переключались в порядке, указанном в конфигурационном файле. В Manticore 3 порядок переключения таблиц гораздо умнее и работает в соответствии с целями списков удаления. Прежде чем начать переключение таблиц, сервер ищет цепочки таблиц по определениям `killlist_target`. Затем он сначала переключает таблицы, которые не упоминаются нигде как целевые списки удаления. Далее он переключает таблицы, на которые нацелены уже переключенные таблицы, и так далее. Например, если мы сделаем `indexer --all` и у нас есть 3 таблицы: main, delta_big (которая нацелена на main) и delta_small (с нацеливанием на delta_big), сначала переключается delta_small, затем delta_big и наконец main. Это необходимо для того, чтобы при переключении зависимой таблицы она получала самый актуальный список удаления от других таблиц.

## Удаленные ключи конфигурации в Manticore 3.x
* `docinfo` - теперь всё внешнее
* `inplace_docinfo_gap` - больше не нужен
* `mva_updates_pool` - MVAs больше не имеют выделенного пула для обновлений, так как теперь их можно обновлять непосредственно в блобе (см. ниже).

## Обновление атрибутов переменной длины в Manticore 3.x
Строковые, JSON и MVA атрибуты могут обновляться в Manticore 3.x с использованием оператора `UPDATE`.

В 2.x строковые атрибуты требовали `REPLACE`, для JSON было возможно обновлять только скалярные свойства (поскольку они были фиксированной ширины), а MVAs можно было обновлять с помощью пула MVA. Теперь обновления выполняются непосредственно на компоненте блоба. Одним из параметров, который может потребовать настройки, является [attr_update_reserve](../Data_creation_and_modification/Updating_documents/UPDATE.md#attr_update_reserve), который позволяет изменять выделенное дополнительное пространство в конце блоба, используемое для избежания частых изменений размера в случае, если новые значения больше существующих значений в блобе.

## Идентификаторы документов в Manticore 3.x
Идентификаторы документов ранее были UNSIGNED 64-битными целыми числами. Теперь они POSITIVE SIGNED 64-битные целые числа.

## RT режим в Manticore 3.x
Читайте здесь о [RT режиме](../Read_this_first.md#Real-time-mode-vs-plain-mode)

## Специальные суффиксы с Manticore 3.x
Manticore 3.x распознает и анализирует специальные суффиксы, что упрощает использование числовых значений со специальным значением. Общая форма для них - целое число + литерал, например 10k или 100d, но не 40.3s (поскольку 40.3 не является целым), или не 2d 4h (поскольку значений два, а не одно). Литералы не чувствительны к регистру, поэтому 10W это то же самое, что 10w. В настоящее время поддерживаются 2 типа таких суффиксов:

* Суффиксы размера - могут использоваться в параметрах, которые определяют размер чего-либо (оперативная память, файл на диске, лимит ОЗУ и т. д.) в байтах. "Обнаженные" числа в этих местах означают размер в байтах (октетах). Значения размера получают суффикс `k` для килобайт (1k=1024), `m` для мегабайт (1m=1024k), `g` для гигабайт (1g=1024m) и `t` для терабайт (1t=1024g).
* Суффиксы времени - могут использоваться в параметрах, определяющих некоторые временные интервалы, такие как задержки, таймауты и т. д. "Обнаженные" значения для этих параметров обычно имеют документированную шкалу, и вы должны знать, означают ли их числа, скажем, 100, '100 секунд' или '100 миллисекунд'. Однако вместо того, чтобы гадать, вы просто можете записать значение с суффиксом, и оно будет полностью определено его суффиксом. Значения времени получают суффикс `us` для микросекунд (микросекунд), `ms` для миллисекунд, `s` для секунд, `m` для минут, `h` для часов, `d` для дней и `w` для недель.

## index_converter

`index_converter` это инструмент для преобразования таблиц, созданных с Sphinx/Manticore Search 2.x в формат таблиц Manticore Search 3.x. Инструмент можно использовать несколькими разными способами:

#### Преобразование одной таблицы за раз

```ini
$ index_converter --config /home/myuser/manticore.conf --index tablename
```

#### Преобразование всех таблиц

```ini
$ index_converter --config /home/myuser/manticore.conf --all
```

#### Преобразование таблиц, найденных в папке

```ini
$ index_converter  --path /var/lib/manticoresearch/data --all
```

Новая версия таблицы по умолчанию записывается в ту же папку. Файлы предыдущей версии сохраняются с расширением `.old` в их имени. Исключение составляет файл `.spp` (хитлисты), который является единственным компонентом таблицы, не изменявшимся в новом формате.

Вы можете сохранить новую версию таблицы в другую папку, используя опцию `-–output-dir`

```ini
$ index_converter --config /home/myuser/manticore.conf --all --output-dir /new/path
```

#### Преобразование списков удаления

Специальный случай относится к таблицам, содержащим списки удаления. Поскольку поведение того, как работают списки удаления, изменилось (см. [killlist_target](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#killlist_target)), таблица дельты должна знать, какие целевые таблицы применяются для использования списков удаления. Существует 3 способа подготовить преобразованную таблицу для установки целевых таблиц для применения списков удаления:

* Используйте `-–killlist-target` при преобразовании таблицы
  ```ini
  $ index_converter --config /home/myuser/manticore.conf --index deltaindex --killlist-target mainindex:kl
  ```
* Добавьте killlist_target в конфигурацию перед преобразованием
* используйте команду [ALTER ... KILLIST_TARGET](../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#killlist_target) после преобразования

#### Полный список опций index_converter
Вот полный список опций `index_converter`:

* `--config <file>` (`-c <file>` для краткости) указывает index_converter использовать данный файл в качестве конфигурации. Обычно он ищет manticore.conf в каталоге установки (например, `/usr/local/manticore/etc/manticore.conf`, если установлен в `/usr/local/sphinx`), а затем в текущем каталоге, в котором вы находитесь при вызове index_converter из оболочки.
* `--index` указывает, какая таблица должна быть преобразована
* `--path` - вместо использования конфигурационного файла можно использовать путь, содержащий таблицу(ы)
* `--strip-path` - удаляет путь из имен файлов, на которые ссылаются таблицы: стоп-слова, исключения и формы слова
* `--large-docid` - позволяет преобразовывать документы с идентификаторами больше, чем 2^63, и отображает предупреждение; в противном случае просто завершит работу с ошибкой на большом идентификаторе. Эта опция была добавлена, поскольку в Manticore 3.x идентификаторы документа являются знаковыми bigint, в то время как ранее они были беззнаковыми
* `--output-dir <dir>` - записывает новые файлы в выбранной папке, а не в том же месте, что и существующие файлы таблиц. Когда установлена эта опция, существующие файлы таблиц останутся нетронутыми в своем местоположении.
* `--all` - преобразует все таблицы из конфигурации
* `--killlist-target <targets>` устанавливает целевые таблицы, к которым будут применяться списки исключений. Эта опция должна использоваться только в сочетании с опцией `--index`


<!-- proofread -->

