# Бинарное логирование

Бинарное логирование служит механизмом восстановления данных таблиц [реального времени](../Creating_a_table/Local_tables/Real-time_table.md). Когда бинарные логи включены, `searchd` записывает каждую транзакцию в binlog-файл и использует его для восстановления после некорректного завершения работы. При корректном завершении работы, RAM-чонки сохраняются на диск, и все binlog-файлы затем удаляются.

## Включение и отключение бинарного логирования

По умолчанию бинарное логирование включено для защиты целостности данных. В системах Linux, стандартное расположение файлов `binlog.*` в [Plain режиме](../Creating_a_table/Local_tables.md#Defining-table-schema-in-config-%28Plain-mode%29) — `/var/lib/manticore/data/`. В [RT режиме](../Creating_a_table/Local_tables.md#Online-schema-management-%28RT-mode%29) бинарные логи хранятся в папке `<data_dir>/binlog/`, если не указано иное.

### Глобальная конфигурация бинарного логирования

<!-- example binlog_path -->
Чтобы отключить бинарное логирование глобально, установите `binlog_path` в пустое значение в конфигурации `searchd`.
Отключение бинарного логирования требует перезапуска демона и подвергает данные риску при неожиданном завершении работы системы.

<!-- request Example -->
```ini
searchd {
...
    binlog_path = # disable logging
...
```
<!-- end -->

<!-- example binlog_path2 -->
Вы можете использовать следующую директиву для установки пользовательского пути:

<!-- request Example -->
```ini
searchd {
...
    binlog_path = /var/data
...
```
<!-- end -->

### Конфигурация бинарного логирования для каждой таблицы

<!-- Example binlog0 -->
Для более точного контроля бинарное логирование можно отключить на уровне таблицы для таблиц реального времени, установив параметр таблицы `binlog` в `0`. Эта опция недоступна для percolate таблиц.

<!-- request Example -->
```sql
create table a (id bigint, s string attribute) binlog='0';
```
<!-- end -->

<!-- Example binlog_alter -->
Для существующих RT таблиц бинарное логирование также можно отключить, изменив параметр `binlog`.

<!-- request Example -->
```sql
alter table FOO binlog='0';
```
<!-- end -->

<!-- Example binlog_alter2 -->
Если бинарное логирование было ранее отключено, его можно включить снова, установив параметр `binlog` обратно в `1`:

<!-- request Example -->
```sql
alter table FOO binlog='1';
```
<!-- end -->

#### Важные замечания:
* **Зависимость от глобальных настроек**: настройки бинарного логирования на уровне таблицы вступают в силу только если бинарное логирование глобально включено в конфигурации searchd (`binlog_path` не должен быть пустым).
* **Статус бинарного логирования и информация о ID транзакции**: изменение статуса бинарного логирования таблицы вызывает немедленный [сброс таблицы](../Securing_and_compacting_a_table/Flushing_RAM_chunk_to_disk.md#FLUSH-TABLE). Если вы отключаете бинарное логирование для таблицы, её ID транзакции (TID) меняется на `-1`. Это означает, что бинарное логирование не активно и изменения не отслеживаются. Напротив, если вы включаете бинарное логирование для таблицы, её ID транзакции становится неотрицательным числом (ноль или больше). Это означает, что изменения таблицы теперь записываются. Вы можете проверить ID транзакции с помощью команды: `SHOW TABLE <name> STATUS`. ID транзакции отражает, записываются ли изменения таблицы (неотрицательное число) или нет (`-1`).

## Операции

Когда бинарное логирование включено, каждое изменение в RT таблице сохраняется в лог-файл. Если система неожиданно выключается, эти логи автоматически используются при следующем запуске системы для восстановления всех зафиксированных изменений.

### Размер лога

<!-- Example binlog_max_log_size -->
Во время нормальной работы, когда объем записанных данных достигает определенного предела (установленного параметром `binlog_max_log_size`), начинается новый лог-файл. Старые лог-файлы сохраняются до тех пор, пока все изменения в них полностью не обработаны и не сохранены на диск в виде дисковой чанки. Если этот предел установлен в `0`, лог-файлы сохраняются до корректного завершения работы системы. По умолчанию нет ограничения на размер этих файлов.

<!-- request Example -->

```ini
searchd {
...
    binlog_max_log_size = 16M
....
```

<!-- end -->

### Лог-файлы

<!-- example binlog_filename_digits -->

Каждый binlog-файл именуется с нулями в начале номера, например `binlog.0000`, `binlog.0001` и т.д., обычно с четырьмя цифрами. Вы можете изменить количество цифр в номере с помощью настройки `binlog_filename_digits`. Если количество binlog-файлов превысит вместимость текущего количества цифр, количество цифр будет автоматически увеличено для размещения всех файлов.

**Важно**: чтобы изменить количество цифр, сначала необходимо сохранить все данные таблиц и корректно завершить работу системы. Затем удалить старые лог-файлы и перезапустить систему.

<!-- request Example -->
```ini
searchd {
...
    binlog_filename_digits = 6
...
```
<!-- end -->

### Стратегии бинарного логирования

<!-- Example binlog_common -->
Вы можете выбрать один из двух способов управления бинарными лог-файлами, которые задаются директивой `binlog_common`:
* Отдельный файл для каждой таблицы (по умолчанию, `0`): каждая таблица сохраняет свои изменения в собственном лог-файле. Эта настройка хороша, если у вас много таблиц, которые обновляются в разное время. Она позволяет обновлять таблицы без ожидания других. Также, если возникает проблема с лог-файлом одной таблицы, это не влияет на другие.
* Один файл для всех таблиц (`1`): все таблицы используют один и тот же бинарный лог-файл. Этот метод упрощает управление файлами, так как их меньше. Однако это может привести к тому, что файлы будут храниться дольше, чем нужно, если одна таблица все еще должна сохранить свои обновления. Эта настройка также может замедлить работу, если много таблиц обновляются одновременно, так как все изменения должны ждать записи в один файл.

<!-- request binlog_common -->

```ini
searchd {
...
    binlog_common = 1
...
```
<!-- end -->

### Стратегии сброса бинарного лога

<!-- Example binlog_flush -->
Существует четыре различных стратегии сброса binlog, контролируемые директивой `binlog_flush`:

* `0` - данные записываются на диск (сбрасываются) каждую секунду, и Manticore инициирует их защиту на диске ([syncing](https://linux.die.net/man/8/sync)) сразу после сброса. Этот метод самый быстрый, но если сервер или компьютер внезапно упадет, некоторые недавно записанные данные, которые еще не были защищены, могут быть потеряны.
* `1` - данные записываются в binlog и синхронизируются сразу после каждой транзакции. Этот метод самый безопасный, так как гарантирует немедленное сохранение каждого изменения, но замедляет запись.
* `2` - Данные записываются после каждой транзакции, и синхронизация запускается каждую секунду. Такой подход обеспечивает баланс, записывая данные регулярно и быстро. Однако, если компьютер выйдет из строя, часть данных, которые сохранялись, может не успеть сохраниться полностью. Также синхронизация может занять больше одной секунды в зависимости от диска.
* `3` - Аналогично `2`, но также гарантирует синхронизацию файла binlog перед его закрытием из-за превышения `binlog_max_log_size`.

Режим по умолчанию — `2`, который записывает данные после каждой транзакции и запускает их синхронизацию каждую секунду, обеспечивая баланс между скоростью и безопасностью.

<!-- request Example -->
```ini
searchd {
...
    binlog_flush = 1 # ultimate safety, low write speed
...
}
```
<!-- end -->

### Поддержка кластерного binlog

<!-- Example binlog_cluster -->
В кластере с использованием Galera поведение восстановления узла имеет решающее значение. Обычно Galera обрабатывает рассинхронизацию узла через IST (incremental state transfer — инкрементальная передача состояния), если узел был корректно выключен и его последний номер последовательности (seqno) был правильно сохранён. Однако в случае сбоя, когда seqno не сохраняется, Galera инициирует SST (state snapshot transfer — передача снимка состояния), что требует больших ресурсов и может значительно замедлить работу кластера из-за высокой активности ввода-вывода.

Для решения этой проблемы была введена поддержка кластерного binlog. Эта функция расширяет существующую функциональность бинарного логирования, помогая уменьшить необходимость SST, позволяя восстанавливающемуся узлу воспроизвести отсутствующие транзакции из локальных binlog и повторно присоединиться к кластеру с валидным seqno.

Кластерный binlog включён по умолчанию для любых операций в кластере. Однако его можно отключить, установив переменную окружения:

<!-- request binlog_cluster -->
```bash
MANTICORE_REPLICATION_BINLOG=0
```
<!-- end -->

Эта функция сокращает время простоя и избегает полной передачи данных, сочетая локальную надёжность бинарного лога с возможностями распределённой синхронизации Galera.

### Восстановление

При восстановлении после некорректного завершения работы binlog воспроизводится, и все записанные транзакции с момента последнего корректного состояния на диске восстанавливаются. Транзакции имеют контрольную сумму, поэтому в случае повреждения файла binlog мусорные данные **не** будут воспроизведены; такая повреждённая транзакция будет обнаружена и воспроизведение остановится.

### Сброс RT RAM чанков

<!-- Example rt_flush_period -->
Интенсивные обновления небольшой RT-таблицы, которая полностью помещается в RAM-чанк, могут привести к постоянно растущему binlog, который нельзя удалить до чистого завершения работы. Binlog фактически служит как дельта только для добавления по отношению к последнему известному корректному сохранённому состоянию на диске, и его нельзя удалить, пока RAM-чанк не будет сохранён. Постоянно растущий binlog не является оптимальным с точки зрения использования диска и времени восстановления после сбоя. Для решения этой проблемы можно настроить `searchd` на периодический сброс RAM-чанков с помощью директивы `rt_flush_period`. При включённых периодических сбросах `searchd` будет поддерживать отдельный поток, который проверяет, нужно ли записывать RT-чанки обратно на диск. После этого соответствующие binlog могут быть (и будут) безопасно удалены.

Период сброса RT по умолчанию установлен в 10 часов.

<!-- request Example -->
```ini
searchd {
...
    rt_flush_period = 3600 # 1 hour
...
}
```
<!-- end -->

Важно отметить, что `rt_flush_period` контролирует только частоту проверок. Нет гарантии, что конкретный RAM-чанк будет сохранён. Например, не имеет смысла регулярно пересохранять большой RAM-чанк, в который поступают обновления всего нескольких строк. Manticore автоматически определяет необходимость сброса, используя несколько эвристик.

<!-- proofread -->

