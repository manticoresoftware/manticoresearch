# Бинарное логирование

Бинарное логирование служит механизмом восстановления данных таблицы в [реальном времени](../Creating_a_table/Local_tables/Real-time_table.md). Когда бинарные логи включены, `searchd` записывает каждую транзакцию в файл binlog и использует его для восстановления после некорректного завершения работы. При корректном завершении работы фрагменты ОЗУ сохраняются на диск, а все файлы binlog затем удаляются.

## Включение и отключение бинарного логирования

По умолчанию бинарное логирование включено для обеспечения целостности данных. На системах Linux место по умолчанию для файлов `binlog.*` в [Plain mode](../Creating_a_table/Local_tables.md#Defining-table-schema-in-config-%28Plain-mode%29) — это `/var/lib/manticore/data/`. В [RT mode](../Creating_a_table/Local_tables.md#Online-schema-management-%28RT-mode%29) бинарные логи хранятся в папке `<data_dir>/binlog/`, если не указано иное.

### Глобальная конфигурация бинарного логирования

<!-- example binlog_path -->
Чтобы отключить бинарное логирование глобально, установите `binlog_path` в пустое значение в конфигурации `searchd`.
Отключение бинарного логирования требует перезапуска демона и ставит данные под угрозу, если система завершит работу неожиданно.

<!-- request Example -->
```ini
searchd {
...
    binlog_path = # отключить логирование
...
```
<!-- end -->

<!-- example binlog_path2 -->
Вы можете использовать следующую директиву, чтобы установить пользовательский путь:

<!-- request Example -->
```ini
searchd {
...
    binlog_path = /var/data
...
```
<!-- end -->

### Конфигурация бинарного логирования на уровне таблицы

<!-- Example binlog0 -->
Для более детального контроля бинарное логирование может быть отключено на уровне таблицы для таблиц в реальном времени, установив параметр таблицы `binlog` в `0`. Эта опция недоступна для таблиц перколяции.

<!-- request Example -->
```sql
create table a (id bigint, s string attribute) binlog='0';
```
<!-- end -->

<!-- Example binlog_alter -->
Для существующих RT-таблиц бинарное логирование также можно отключить, изменив параметр `binlog`.

<!-- request Example -->
```sql
alter table FOO binlog='0';
```
<!-- end -->

<!-- Example binlog_alter2 -->
Если бинарное логирование ранее было отключено, его можно снова включить, установив параметр `binlog` обратно в `1`:

<!-- request Example -->
```sql
alter table FOO binlog='1';
```
<!-- end -->

#### Важные моменты:
* **Зависимость от глобальных настроек**: настройки бинарного логирования на уровне таблицы вступают в силу только если бинарное логирование глобально включено в конфигурации searchd (`binlog_path` не должно быть пустым).
* **Статус бинарного логирования и информация о идентификаторе транзакции**: Изменение статуса бинарного логирования таблицы приводит к немедленному [сбросу таблицы](../Securing_and_compacting_a_table/Flushing_RAM_chunk_to_disk.md#FLUSH-TABLE). Если вы отключите бинарное логирование для таблицы, ее идентификатор транзакции (TID) изменится на `-1`. Это указывает на то, что бинарное логирование не активно, и изменения не отслеживаются. Напротив, если вы включите бинарное логирование для таблицы, ее идентификатор транзакции становится положительным числом (ноль или больше). Это указывает на то, что изменения таблицы теперь записываются. Вы можете проверить идентификатор транзакции, используя команду: `SHOW TABLE <name> STATUS`. Идентификатор транзакции отражает, записываются ли изменения в таблице (положительное число) или нет (`-1`).

## Операции

Когда бинарное логирование включено, каждое изменение, внесенное в таблицу RT, сохраняется в файл журнала. Если система завершает работу неожиданно, эти журналы автоматически используются при следующем запуске системы для восстановления всех изменений, которые были записаны.

### Размер журнала

<!-- Example binlog_max_log_size -->
Во время нормальной работы, когда количество записанных данных достигает определенного предела (установленного с помощью `binlog_max_log_size`), начинается новый файл журнала. Старые файлы журналов сохраняются до тех пор, пока все изменения в них полностью не будут обработаны и сохранены на диск в виде дискового фрагмента. Если этот лимит установлен в `0`, файлы журнала сохраняются до тех пор, пока система не будет корректно выключена. По умолчанию нет предела на то, насколько большими могут быть эти файлы.

<!-- request Example -->

```ini
searchd {
...
    binlog_max_log_size = 16M
....
```

<!-- end -->

### Файлы журналов

<!-- example binlog_filename_digits -->

Каждый файл binlog назван с нулевым дополнением, например `binlog.0000`, `binlog.0001` и т. д., обычно показывая четыре цифры. Вы можете изменить количество цифр в номере с помощью настройки `binlog_filename_digits`. Если у вас больше файлов binlog, чем может вместить количество цифр, количество цифр будет автоматически увеличено, чтобы охватить все файлы.

**Важно**: Чтобы изменить количество цифр, вы должны сначала сохранить все данные таблицы и корректно выключить систему. Затем удалите старые файлы журналов и перезагрузите систему.

<!-- request Example -->
```ini
searchd {
...
    binlog_filename_digits = 6
...
```
<!-- end -->

### Стратегии бинарного логирования

<!-- Example binlog_common -->
Вы можете выбрать между двумя способами управления файлами бинарного журнала, которые можно установить с помощью директивы `binlog_common`:
* Отдельный файл для каждой таблицы (по умолчанию, `0`): Каждая таблица сохраняет свои изменения в собственном файле журнала. Эта настройка хороша, если у вас много таблиц, которые обновляются в разное время. Это позволяет таблицам обновляться без ожидания других. Также, если возникает проблема с файлом журнала одной таблицы, это не сказывается на других.
* Один файл для всех таблиц (`1`): Все таблицы используют один и тот же файл бинарного журнала. Этот метод упрощает управление файлами, так как их меньше. Однако это может удерживать файлы дольше, чем нужно, если одной таблице все еще нужно сохранить свои обновления. Эта настройка также может замедлить процесс, если многие таблицы требуют обновления одновременно, так как все изменения должны ожидать записи в один файл.

<!-- request binlog_common -->

```ini
searchd {
...
    binlog_common = 1
...
```
<!-- end -->
### Стратегии сброса бинарных логов

<!-- Example binlog_flush -->
Существует четыре различных стратегии сброса бинарных логов, управляемых директивой `binlog_flush`:

* `0` - Данные записываются на диск (сбрасываются) каждую секунду, и Manticore инициирует их защиту на диске ([синхронизация](https://linux.die.net/man/8/sync)) сразу после сброса. Этот метод является самым быстрым, но если сервер или компьютер неожиданно выйдет из строя, некоторые недавно записанные данные, которые не были защищены, могут быть утеряны.
* `1` - Данные записываются в бинарный лог и синхронизируются немедленно после каждой транзакции. Этот метод является самым безопасным, так как он обеспечивает немедленное сохранение каждого изменения, но замедляет запись.
* `2` - Данные записываются после каждой транзакции, и синхронизация инициируется каждую секунду. Этот подход предлагает баланс, регулярно и быстро записывая данные. Однако если компьютер выйдет из строя, некоторые из данных, которые защищались, могут не сохраниться. Кроме того, синхронизация может занять больше одной секунды в зависимости от диска.
* `3` - Похоже на `2`, но также гарантирует, что файл бинарного лога синхронизируется перед закрытием из-за превышения `binlog_max_log_size`.

Режим по умолчанию - `2`, который записывает данные после каждой транзакции и начинает синхронизировать их каждую секунду, уравновешивая скорость и безопасность.

<!-- request Example -->
```ini
searchd {
...
    binlog_flush = 1 # максимальная безопасность, низкая скорость записи
...
}
```
<!-- end -->

### Восстановление

Во время восстановления после некорректного завершения работы бинарные логи воспроизводятся, и все зафиксированные транзакции с момента последнего успешного состояния на диске восстанавливаются. Транзакции проверяются на контрольную сумму, поэтому в случае повреждения файла бинарного лога мусорные данные **не** будут воспроизводиться; такая поврежденная транзакция будет обнаружена и остановит воспроизведение.

### Сброс RT-кусков RAM

<!-- Example rt_flush_period -->
Интенсивные обновления небольшого RT-таблицы, которая полностью помещается в кусок RAM, могут привести к постоянно растущему бинарному логу, который никогда не может быть отсоединен до корректного завершения работы. Бинарные логи по сути служат в качестве добавляемых дельт относительно последнего известного хорошего сохраненного состояния на диске, и они не могут быть отсоединены, пока кусок RAM не будет сохранен. Постоянно растущий бинарный лог не является идеальным для использования диска и времени восстановления после сбоя. Чтобы решить эту проблему, вы можете настроить `searchd` для выполнения периодических сбросов кусков RAM с помощью директивы `rt_flush_period`. При включенных периодических сбросах `searchd` будет поддерживать отдельный поток, который проверяет, нужно ли записывать куску RAM RT-таблицы обратно на диск. Как только это происходит, соответствующие бинарные логи могут быть (и являются) безопасно отсоединены.

Период сброса RT по умолчанию установлен на 10 часов.

<!-- request Example -->
```ini
searchd {
...
    rt_flush_period = 3600 # 1 час
...
}
```
<!-- end -->

Важно отметить, что `rt_flush_period` только контролирует частоту, с которой происходят проверки. Никаких гарантий нет, что конкретный кусок RAM будет сохранен. Например, нет смысла регулярно повторно сохранять большой кусок RAM, который получает всего несколько строк обновлений. Manticore автоматически определяет, стоит ли выполнять сброс, используя несколько эвристик.

<!-- proofread -->

