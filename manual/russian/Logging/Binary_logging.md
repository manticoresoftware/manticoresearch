# Двоичное логирование

Двоичное логирование служит механизмом восстановления данных таблиц [real-time](../Creating_a_table/Local_tables/Real-time_table.md). Когда двоичное логирование включено, `searchd` записывает каждую транзакцию в binlog-файл и использует его для восстановления после некорректного завершения работы. При корректном завершении работы фрагменты в ОЗУ сохраняются на диск, а все binlog-файлы впоследствии удаляются.

## Включение и отключение двоичного логирования

По умолчанию двоичное логирование включено для защиты целостности данных. В Linux-системах стандартное расположение файлов `binlog.*` в [Plain mode](../Creating_a_table/Local_tables.md#Defining-table-schema-in-config-%28Plain-mode%29) — `/var/lib/manticore/data/`. В [RT mode](../Creating_a_table/Local_tables.md#Online-schema-management-%28RT-mode%29) двоичные логи хранятся в папке `<data_dir>/binlog/`, если не указано иное.

### Глобальная конфигурация двоичного логирования

<!-- example binlog_path -->
Чтобы отключить двоичное логирование глобально, задайте `binlog_path` пустым значением в конфигурации `searchd`.
Отключение двоичного логирования требует перезапуска демона и подвергает данные риску в случае неожиданного завершения работы системы.

<!-- request Example -->
```ini
searchd {
...
    binlog_path = # disable logging
...
```
<!-- end -->

<!-- example binlog_path2 -->
Вы можете использовать следующую директиву для установки пользовательского пути:

<!-- request Example -->
```ini
searchd {
...
    binlog_path = /var/data
...
```
<!-- end -->

### Конфигурация двоичного логирования для отдельных таблиц

<!-- Example binlog0 -->
Для более точного контроля двоичное логирование можно отключить на уровне таблицы для real-time таблиц, задав параметр `binlog` таблицы в значение `0`. Эта опция недоступна для percolate таблиц.

<!-- request Example -->
```sql
create table a (id bigint, s string attribute) binlog='0';
```
<!-- end -->

<!-- Example binlog_alter -->
Для существующих RT таблиц двоичное логирование также можно отключить, изменив параметр `binlog`.

<!-- request Example -->
```sql
alter table FOO binlog='0';
```
<!-- end -->

<!-- Example binlog_alter2 -->
Если двоичное логирование было ранее отключено, его можно включить снова, установив параметр `binlog` обратно в `1`:

<!-- request Example -->
```sql
alter table FOO binlog='1';
```
<!-- end -->

#### Важные замечания:
* **Зависимость от глобальных настроек**: настройки двоичного логирования на уровне таблицы вступают в силу только если двоичное логирование глобально включено в конфигурации searchd (должен быть непустой `binlog_path`).
* **Статус двоичного логирования и сведения о идентификаторе транзакции**: изменение статуса двоичного логирования таблицы заставляет немедленно [сбросить таблицу](../Securing_and_compacting_a_table/Flushing_RAM_chunk_to_disk.md#FLUSH-TABLE). Если вы отключаете двоичное логирование для таблицы, её идентификатор транзакции (TID) меняется на `-1`. Это означает, что двоичное логирование не активно и изменения не отслеживаются. Напротив, при включении двоичного логирования TID становится неотрицательным числом (ноль или выше), что показывает, что изменения таблицы теперь фиксируются. Вы можете проверить идентификатор транзакции командой: `SHOW TABLE <name> STATUS`. Идентификатор транзакции отражает, ведётся ли запись изменений в таблице (неотрицательное число) или нет (`-1`).

## Операции

При включённом двоичном логировании каждое изменение RT таблицы сохраняется в лог-файл. Если система неожиданно завершает работу, эти логи автоматически используются при следующем старте системы для восстановления всех зафиксированных изменений.

### Размер лога

<!-- Example binlog_max_log_size -->
Во время нормальной работы, когда размер записанных данных достигает определённого лимита (установленного параметром `binlog_max_log_size`), начинается новый лог-файл. Старые лог-файлы хранятся до тех пор, пока все изменения в них полностью не обработаются и не сохранятся на диск в виде дискового чанка. Если этот лимит установлен в `0`, лог-файлы сохраняются до корректного завершения работы системы. По умолчанию нет ограничения на размер этих файлов.

<!-- request Example -->

```ini
searchd {
...
    binlog_max_log_size = 16M
....
```

<!-- end -->

### Файлы лога

<!-- example binlog_filename_digits -->

Каждый binlog-файл называется с числом с ведущими нулями, например, `binlog.0000`, `binlog.0001` и т.д., обычно с четырьмя цифрами. Вы можете изменить количество цифр в числе с помощью настройки `binlog_filename_digits`. Если количество файлов превышает возможности заданного количества цифр, число цифр будет автоматически увеличено.

**Важно**: чтобы изменить количество цифр, сначала сохраните все данные таблиц и корректно завершите работу системы. Затем удалите старые лог-файлы и перезапустите систему.

<!-- request Example -->
```ini
searchd {
...
    binlog_filename_digits = 6
...
```
<!-- end -->

### Стратегии двоичного логирования

<!-- Example binlog_common -->
Вы можете выбрать один из двух способов управления двоичными лог-файлами, задаваемых директивой `binlog_common`:
* Отдельный файл для каждой таблицы (по умолчанию, `0`): каждая таблица сохраняет свои изменения в собственном лог-файле. Эта схема подходит, если у вас много таблиц, которые обновляются в разное время. Это позволяет обновлять таблицы без ожидания друг друга. Также при проблеме с лог-файлом одной таблицы остальные не затрагиваются.
* Один файл для всех таблиц (`1`): все таблицы используют один общий двоичный лог-файл. Этот вариант упрощает управление файлами, так как их меньше. Однако это может приводить к более длительному хранению файлов, если одна таблица продолжает сохранять обновления. Такая настройка может также замедлять работу, если много таблиц одновременно нуждаются в обновлении, так как все изменения должны ожидать записи в один файл.

<!-- request binlog_common -->

```ini
searchd {
...
    binlog_common = 1
...
```
<!-- end -->

### Стратегии сброса двоичного лога

<!-- Example binlog_flush -->
Существует четыре разных стратегии сброса binlog, управляемые директивой `binlog_flush`:

* `0` - данные записываются на диск (сброс) каждую секунду, и Manticore сразу же начинает процедуру обеспечения сохранности на диске ([syncing](https://linux.die.net/man/8/sync)) после сброса. Этот метод самый быстрый, но при внезапном сбое сервера или компьютера могут быть потеряны недавно записанные данные, которые ещё не были зафиксированы на диске.
* `1` - данные записываются в binlog и синхронизируются сразу после каждой транзакции. Этот метод самый надёжный, так как гарантирует немедленное сохранение каждого изменения, однако замедляет запись.
* `2` - Данные записываются после каждой транзакции, и синхронизация инициируется каждую секунду. Этот подход предлагает баланс, записывая данные регулярно и быстро. Однако, если компьютер выйдет из строя, некоторые данные, которые пытались сохранить, могут не успеть записаться. Также синхронизация может занять больше одной секунды в зависимости от диска.
* `3` - Аналогично `2`, но также гарантирует, что файл binlog будет синхронизирован перед его закрытием из-за превышения `binlog_max_log_size`.

Режим по умолчанию — `2`, который записывает данные после каждой транзакции и запускает синхронизацию каждую секунду, обеспечивая баланс скорости и безопасности.

<!-- request Example -->
```ini
searchd {
...
    binlog_flush = 1 # ultimate safety, low write speed
...
}
```
<!-- end -->

### Поддержка кластерного binlog

<!-- Example binlog_cluster -->
В кластере с использованием Galera поведение восстановления узла крайне важно. Обычно Galera справляется с рассинхронизацией узла с помощью IST (incremental state transfer, инкрементальная передача состояния), если узел был корректно остановлен и его последний порядковый номер (seqno) был правильно сохранён. Однако в случае сбоя, когда seqno не сохранён, Galera инициирует SST (state snapshot transfer, передача снимка состояния), что требует больших ресурсов и может значительно замедлить кластер из-за высокой активности ввода-вывода.

Для решения этой проблемы была введена поддержка кластерного binlog. Эта функция расширяет существующую функциональность бинарного логирования, чтобы сократить необходимость SST, позволяя восстанавливающемуся узлу воспроизвести пропущенные транзакции из локальных binlog и заново войти в кластер с валидным seqno.

Кластерный binlog включён по умолчанию для любых операций в кластере. Тем не менее, его можно отключить, установив переменную окружения:

<!-- request binlog_cluster -->
```bash
MANTICORE_REPLICATION_BINLOG=0
```
<!-- end -->

Эта функция сокращает время простоя и избегает полной передачи данных, объединяя локальную надёжность бинарного лога с возможностями распределённой синхронизации Galera.

### Восстановление

Во время восстановления после некорректного выключения binlog воспроизводится, и все зафиксированные транзакции после последнего корректного сохранённого состояния восстанавливаются. Транзакции проверяются контрольной суммой, поэтому в случае повреждения файла binlog мусорные данные **не будут** воспроизведены; такая повреждённая транзакция будет обнаружена и остановит воспроизведение.

### Сброс RAM-чанк RT

<!-- Example rt_flush_period -->
Интенсивные обновления небольшой RT-таблицы, которая полностью помещается в RAM-чанк, могут привести к бесконечно растущему binlog, который нельзя удалить до корректного завершения работы. Binlog фактически служит в качестве журнала изменений (append-only) по отношению к последнему известному корректному сохранённому состоянию на диске и не может быть удалён, пока RAM-чанк не сохранён. Бесконечно растущий binlog не является оптимальным с точки зрения дискового пространства и времени восстановления после сбоя. Для решения этой проблемы вы можете настроить `searchd` на периодические сбросы RAM-чанков с помощью директивы `rt_flush_period`. При включённых периодических сбросах `searchd` поддерживает отдельный поток, который проверяет, нужно ли записать обратно на диск RAM-чанки RT-таблицы. Когда это происходит, соответствующие binlog могут быть (и будут) безопасно удалены.

Период сброса RT по умолчанию установлен на 10 часов.

<!-- request Example -->
```ini
searchd {
...
    rt_flush_period = 3600 # 1 hour
...
}
```
<!-- end -->

Важно отметить, что `rt_flush_period` управляет только частотой проверок. Нет гарантии, что конкретный RAM-чанк будет сохранён. К примеру, бессмысленно регулярно пересохранять большой RAM-чанк, который принимает лишь несколько обновлённых строк. Manticore самостоятельно определяет необходимость выполнения сброса, используя несколько эвристик.

<!-- proofread -->

