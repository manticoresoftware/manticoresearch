# Различные инструменты

## indextool

`indextool` — полезная утилита, которая извлекает различную информацию о физической таблице, исключая `template` или `distributed` таблицы. Вот общий синтаксис использования `indextool`:

```sql
indextool <command> [options]
```

### Опции

Эти опции применимы ко всем командам:

* `--config <file>` (`-c <file>` для краткости) позволяет переопределить имена файлов конфигурации по умолчанию.
* `--quiet` (`-q` для краткости) подавляет вывод баннеров и подобного от `indextool`.
* `--help` (`-h` для краткости) отображает все параметры, доступные в вашей конкретной сборке `indextool`.
* `-v` отображает информацию о версии вашей конкретной сборки `indextool`.

### Команды

Доступные команды:

* `--checkconfig` загружает и проверяет файл конфигурации, проверяя его валидность и наличие синтаксических ошибок.
* `--buildidf DICTFILE1 [DICTFILE2 ...] --out IDFILE` строит IDF файл из одного или нескольких дампов словарей (см. `--dumpdict`). Дополнительный параметр `--skip-uniq` пропустит уникальные слова (df=1).
* `--build-infixes TABLENAME` генерирует инфиксы для уже существующей таблицы dict=keywords (обновляет .sph, .spi на месте). Используйте эту опцию для устаревших файлов таблиц, которые уже используют dict=keywords, но теперь требуют поддержки инфиксного поиска; обновление файлов таблиц с помощью indextool может быть проще или быстрее, чем их пересоздание с нуля с помощью indexer.
* `--dumpheader FILENAME.sph` быстро выводит указанный файл заголовка таблицы без изменения других файлов таблицы или даже файла конфигурации. Отчет предоставляет подробный обзор всех настроек таблицы, особенно полный список атрибутов и полей.
* `--dumpconfig FILENAME.sph` извлекает определение таблицы из указанного файла заголовка таблицы в формате, (почти) совместимом с файлом manticore.conf.
* `--dumpheader TABLENAME` выводит заголовок таблицы по имени таблицы, при этом путь к заголовку ищется в файле конфигурации.
* `--dumpdict TABLENAME` выводит словарь. Дополнительный переключатель `-stats` добавит общее количество документов к дампу словаря. Это необходимо для файлов словаря, используемых при создании IDF файла.
* `--dumpdocids TABLENAME` выводит идентификаторы документов по имени таблицы.
* `--dumphitlist TABLENAME KEYWORD` выводит все вхождения указанного ключевого слова в заданной таблице, при этом ключевое слово задано как текст.
* `--dumphitlist TABLENAME --wordid ID` выводит все вхождения конкретного ключевого слова в заданной таблице, при этом ключевое слово представлено внутренним числовым ID.
* `--dumpkilllist TABLENAME` выводит содержимое kill-листа указанной таблицы, включая цели и флаги. Также может использоваться как `--dumpkilllist FILENAME.spk`.
* `--docextract TBL DOCID` выполняет стандартную проверку таблицы всей словарной базы/документов/вхождений и собирает все слова и вхождения, связанные с запрошенным документом. Затем все слова упорядочиваются по полям и позициям, и результат выводится, сгруппированный по полям.
* `--fold TABLENAME OPTFILE` Эта опция помогает понять, как токенизатор обрабатывает ввод. Вы можете передать indextool текст из файла, если он указан, или из stdin в противном случае. Вывод заменит разделители пробелами (на основе настроек `charset_table`) и преобразует буквы в словах в нижний регистр.
* `--htmlstrip TABLENAME` применяет настройки HTML-стриппера для указанной таблицы для фильтрации stdin и отправляет результаты фильтрации в stdout. Учтите, что настройки будут взяты из manticore.conf, а не из заголовка таблицы.
* `--mergeidf NODE1.idf [NODE2.idf ...] --out GLOBAL.idf` объединяет несколько .idf файлов в один. Дополнительный параметр `--skip-uniq` пропустит уникальные слова (df=1).
* `--morph TABLENAME` применяет морфологию к входным данным из stdin и направляет результат в stdout.
* `--check TABLENAME` проверяет файлы данных таблицы на ошибки согласованности, которые могут быть вызваны ошибками в `indexer` или аппаратными сбоями. `--check` также работает с RT таблицами, RAM и дисковыми чанками. Дополнительные опции:
    - `--check-id-dups` проверяет дубликаты идентификаторов документов в простой таблице и во всех дисковых чанках RT таблицы
    - `--check-disk-chunk CHUNK_NAME` проверяет только конкретный дисковый чанк RT таблицы. Аргумент — числовое расширение дискового чанка RT таблицы для проверки.
* `--strip-path` удаляет пути из всех имен файлов, на которые ссылается таблица (стоп-слова, словоформы, исключения и т.д.). Это полезно при проверке таблиц, собранных на другой машине с возможно отличающейся структурой путей.
* `--rotate` совместимо только с `--check` и определяет, проверять ли таблицу, ожидающую ротации, т.е. с расширением .new. Это полезно, если вы хотите проверить таблицу перед её фактическим использованием.
* `--apply-killlists` загружает и применяет kill-листы для всех таблиц, перечисленных в файле конфигурации. Изменения сохраняются в .SPM файлах. Файлы kill-листов (.SPK) удаляются. Это удобно, если вы хотите перенести применение таблиц с запуска сервера на этап индексирования.

### Важное замечание по проверке RT таблиц

`indextool` не может полностью проверить RT таблицу, которая в данный момент обслуживается демоном. При попытке проверить активную RT таблицу вы можете столкнуться с следующим предупреждением:

```
WARNING: failed to load RAM chunks, checking only N disk chunks
```

Чтобы избежать этих предупреждений и обеспечить корректную проверку RT таблицы, рассмотрите следующие подходы:

- остановите демон перед запуском `indextool --check`.
- убедитесь, что RT таблица не обслуживается демоном.
- проверьте отдельную копию RT таблицы вместо живой.

Если остановка демона невозможна, вы можете предотвратить нежелательные изменения RT таблицы, выполнив следующий MySQL-запрос перед запуском `indextool --check`:

```sql
SET GLOBAL AUTO_OPTIMIZE=0;
```

Эта команда предотвращает автоматическую оптимизацию демоном, гарантируя, что файлы RT таблицы останутся неизменными. После выполнения этого запроса дождитесь полного завершения потока оптимизации перед продолжением с `indextool --check`. Это гарантирует, что во время проверки не будут случайно изменены или удалены дисковые чанки.
Если автооптимизация была включена ранее, вам следует вручную включить её снова после завершения проверки, выполнив:

```sql
SET GLOBAL AUTO_OPTIMIZE=1;
```

## spelldump

Команда `spelldump` предназначена для извлечения содержимого из файла словаря, использующего формат `ispell` или `MySpell`. Это может быть полезно, когда нужно составить списки слов для форм слов, так как она генерирует все возможные формы за вас.

Общий синтаксис выглядит так:

```bash
spelldump [options] <dictionary> <affix> [result] [locale-name]
```

Основными параметрами являются основной файл и файл аффиксов словаря. Обычно они называются `[language-prefix].dict` и `[language-prefix].aff` соответственно. Эти файлы можно найти в большинстве стандартных дистрибутивов Linux или в многочисленных онлайн-источниках.

Параметр `[result]` — это место, куда будет сохранён извлечённый словарь, а `[locale-name]` — параметр для указания нужных локалей.

Также есть необязательный параметр `-c [file]`. Эта опция позволяет указать файл с деталями преобразования регистра.

Вот несколько примеров использования:

```bash
spelldump en.dict en.aff
spelldump ru.dict ru.aff ru.txt ru_RU.CP1251
spelldump ru.dict ru.aff ru.txt .1251
```

В результате получится файл, в котором будут перечислены все слова из словаря, расположенные в алфавитном порядке и отформатированные как файл форм слов. Вы можете затем изменить этот файл в соответствии с вашими конкретными требованиями. Вот пример того, как может выглядеть выходной файл:

```bash
zone > zone
zoned > zoned
zoning > zoning
```

## wordbreaker

Инструмент `wordbreaker` предназначен для разбиения составных слов, часто встречающихся в URL, на отдельные компоненты. Например, он может разделить "lordoftherings" на четыре отдельных слова или разбить `http://manofsteel.warnerbros.com` на "man of steel warner bros". Эта возможность улучшает функциональность поиска, устраняя необходимость в префиксах или инфиксах. Например, поиск по слову "sphinx" не выдаст "sphinxsearch" в результатах. Однако, если применить `wordbreaker` для разбиения составного слова и индексировать отдельные элементы, поиск будет успешным без увеличения размера файла, связанного с использованием префиксов или инфиксов в полнотекстовом индексировании.

Вот несколько примеров использования `wordbreaker`:

```bash
echo manofsteel | bin/wordbreaker -dict dict.txt split
man of steel
```

Файл словаря `-dict` используется для разделения входного потока на отдельные слова. Если файл словаря не указан, Wordbreaker будет искать файл с именем `wordbreaker-dict.txt` в текущей рабочей директории. (Убедитесь, что файл словаря соответствует языку составного слова, с которым вы работаете.) Команда `split` разбивает слова из стандартного ввода и отправляет результаты в стандартный вывод. Команды `test` и `bench` также доступны для оценки качества разбиения и измерения производительности функции разбиения соответственно.

Wordbreaker использует словарь для определения отдельных подстрок в заданной строке. Чтобы различать несколько возможных вариантов разбиения, он учитывает относительную частоту каждого слова в словаре. Более высокая частота указывает на большую вероятность разбиения на это слово. Для создания такого файла можно использовать инструмент `indexer`:


```bash
indexer --buildstops dict.txt 100000 --buildfreqs myindex -c /path/to/manticore.conf
```

который создаст текстовый файл с именем `dict.txt`, содержащий 100 000 наиболее часто встречающихся слов из `myindex` вместе с их соответствующими количествами. Поскольку этот выходной файл является простым текстовым документом, у вас есть возможность вручную редактировать его в любое время. Не стесняйтесь добавлять или удалять слова по мере необходимости.

<!-- proofread -->

