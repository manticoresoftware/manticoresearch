# Автозаполнение

Автозаполнение, или завершение слова, предсказывает и предлагает окончание слова или фразы по мере того, как вы печатаете. Оно часто используется в:
- Полях поиска на веб-сайтах
- Предложениях в поисковых системах
- Полях ввода в приложениях

Manticore предлагает продвинутую функцию автозаполнения, которая дает подсказки во время ввода, аналогично тем, что используются в известных поисковых системах. Это помогает ускорить поиск и позволяет пользователям быстрее находить нужную информацию.

В дополнение к основной функциональности автозаполнения Manticore включает в себя расширенные функции, чтобы улучшить пользовательский опыт:

1. **Коррекция орфографии (приблизительность):** Автозаполнение Manticore помогает исправлять орфографические ошибки с помощью алгоритмов, которые распознают и исправляют распространенные ошибки. Это означает, что даже если вы напечатаете что-то неправильно, вы все равно сможете найти то, что искали.
2. **Автоопределение раскладки клавиатуры:** Manticore может определить, какую раскладку клавиатуры вы используете. Это действительно полезно в местах, где используется много языков, или если вы случайно печатаете на неправильном языке. Например, если вы ошибочно наберете "ghbdtn", Manticore знает, что вы хотели сказать "привет" и предлагает правильное слово.

Автозаполнение Manticore можно настроить для соответствия различным потребностям и условиям, что делает его гибким инструментом для многих приложений.

![Автозаполнение](autocomplete.png)

## ВЫЗОВ АВТОЗАПОЛНЕНИЯ

> ПРИМЕЧАНИЕ: `ВЫЗОВ АВТОЗАПОЛНЕНИЯ` и `/autocomplete` требуют [Manticore Buddy](../Installation/Manticore_Buddy.md). Если это не работает, убедитесь, что Buddy установлен.

<!-- example call_autocomplete -->
Чтобы использовать автозаполнение в Manticore, используйте оператор SQL `ВЫЗОВ АВТОЗАПОЛНЕНИЯ` или его эквивалент в JSON `/autocomplete`. Эта функция предоставляет предложения по завершению слов на основе ваших индексированных данных.

Перед тем как продолжить, убедитесь, что таблица, которую вы собираетесь использовать для автозаполнения, имеет включенные [инфиксные](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) настройки.

**Примечание:** В настройках таблицы есть автоматическая проверка `min_infix_len`, которая использует 30-секундный кэш для улучшения производительности `ВЫЗОВ АВТОЗАПОЛНЕНИЯ`. После внесения изменений в вашу таблицу может быть кратковременная задержка при первом использовании `ВЫЗОВ АВТОЗАПОЛНЕНИЯ` (хотя это обычно незаметно). Только успешные результаты кэшируются, поэтому, если вы удалите таблицу или отключите `min_infix_len`, `ВЫЗОВ АВТОЗАПОЛНЕНИЯ` временно может возвращать неправильные результаты, пока в конечном итоге не начнет показывать ошибку, связанную с `min_infix_len`.

### Общий синтаксис

#### SQL
```sql
ВЫЗОВ АВТОЗАПОЛНЕНИЯ('начало_запроса', 'таблица', [...опции]);
```

#### JSON
```json
POST /autocomplete
{
	"table":"имя_таблицы",
	"query":"начало_запроса"
	[,"options": {<опции_автозаполнения>}]
}
```

#### Опции
- `layouts`: Строка, разделенная запятыми, с кодами раскладок клавиатуры для проверки и проверки на коррекцию орфографии. Доступные опции: us, ru, ua, se, pt, no, it, gr, uk, fr, es, dk, de, ch, br, bg, be (более подробная информация [здесь](../../Searching/Spell_correction.md#Options)). Значение по умолчанию: все включены
- `fuzziness`: `0`, `1` или `2` (по умолчанию: `2`). Максимальное расстояние Левенштейна для нахождения опечаток. Установите `0`, чтобы отключить нечеткое соответствие.
- `prepend`: Логическое значение (0/1 в SQL). Если true(1), добавляет звездочку перед последним словом для расширения по префиксу (например, `*слово`)
- `append`: Логическое значение (0/1 в SQL). Если true(1), добавляет звездочку после последнего слова для расширения по суффиксу (например, `слово*`)
- `expansion_len`: Количество символов для расширения в последнем слове. Значение по умолчанию: `10`

<!-- request SQL -->

```sql
mysql> ВЫЗОВ АВТОЗАПОЛНЕНИЯ('hello', 'comment');
+------------+
| query      |
+------------+
| hello      |
| helio      |
| hell       |
| shell      |
| nushell    |
| powershell |
| well       |
| help       |
+------------+
```

<!-- request SQL with no fuzzy search -->

```sql
mysql> ВЫЗОВ АВТОЗАПОЛНЕНИЯ('hello', 'comment', 0 as fuzziness);
+-------+
| query |
+-------+
| hello |
+-------+
```

<!-- request JSON -->

```json
POST /autocomplete
{
	"table":"comment",
	"query":"hello"
}
```

<!-- response JSON -->
```json
[
  {
    "total": 8,
    "error": "",
    "warning": "",
    "columns": [
      {
        "query": {
          "type": "string"
        }
      }
    ],
    "data": [
      {
        "query": "hello"
      },
      {
        "query": "helio"
      },
      {
        "query": "hell"
      },
      {
        "query": "shell"
      },
      {
        "query": "nushell"
      },
      {
        "query": "powershell"
      },
      {
        "query": "well"
      },
      {
        "query": "help"
      }
    ]
  }
]
```

<!-- end -->

#### Ссылки
* [Этот демонстрационный проект](https://github.manticoresearch.com/manticoresoftware/manticoresearch) демонстрирует функциональность автозаполнения:
  ![Пример автозаполнения](autocomplete_github_demo.png){.scale-0.7}
* Пост в блоге о Нечетком поиске и Автозаполнении - https://manticoresearch.com/blog/new-fuzzy-search-and-autocomplete/

## Альтернативные методы автозаполнения

Хотя `ВЫЗОВ АВТОЗАПОЛНЕНИЯ` является рекомендуемым методом для большинства случаев использования, Manticore также поддерживает другие контролируемые и настраиваемые подходы для реализации функциональности автозаполнения:

##### Автозаполнение предложения
Чтобы автозаполнить предложение, вы можете использовать [инфиксный поиск](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len). Вы можете найти окончание поля документа, предоставив его начало и:
* используя [оператор подстановки для полнотекстового поиска](../Searching/Full_text_matching/Operators.md) `*` для совпадения с любыми символами
* по желанию используя `^`, чтобы начать с начала поля
* по желанию используя `""` для совпадения фраз
* и используя [подсветку результатов](../Searching/Highlighting.md)

В [нашей статье в блоге](https://manticoresearch.com/blog/simple-autocomplete-with-manticore/) и [интерактивном курсе](https://play.manticoresearch.com/simpleautocomplete/) представлен быстрый пример:
* Предположим, у вас есть документ: `Моя кошка любит мою собаку. Кошка (Felis catus) является домашним видом небольшого хищного млекопитающего.`
* Тогда вы можете использовать `^`, `""` и `*`, так что, когда пользователь начинает вводить, вы выполняете запросы, такие как: `^"м*"`, `^"мою *"`, `^"мою к*"`, `^"мою ко*"` и так далее.
* Это найдет документ, и если вы также используете [подсветку](../Searching/Highlighting.md), вы получите что-то вроде: `<b>Моя кошка</b> любит мою собаку. Кошка ( ...`

##### Автозаполнение слова
В некоторых случаях вам нужно только автозаполнить одно слово или несколько слов. В этом случае вы можете использовать `CALL KEYWORDS`.

### CALL KEYWORDS
`CALL KEYWORDS` доступен через SQL-интерфейс и предлагает способ изучить, как ключевые слова токенизируются, или получить токенизированные формы конкретных ключевых слов. Если таблица разрешает [инфиксные формы](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len), это позволяет вам быстро находить возможные окончания для заданных ключевых слов, что делает его подходящим для функции автозаполнения.

Это отличная альтернатива общему инфиксному поиску, так как обеспечивает более высокую производительность, поскольку требует лишь словаря таблицы, а не самих документов.

### Общий синтаксис
<!-- example keywords -->
```sql
CALL KEYWORDS(text, table [, options])
```
Оператор `CALL KEYWORDS` делит текст на ключевые слова. Он возвращает токенизированные и нормализованные формы ключевых слов, а также, при желании, статистику ключевых слов. Кроме того, он предоставляет позицию каждого ключевого слова в запросе и все формы токенизированных ключевых слов, когда таблица позволяет использовать [лемматизаторы](../Creating_a_table/NLP_and_tokenization/Morphology.md).

| Параметр | Описание |
| - | - |
| text | Текст для разбиения на ключевые слова |
| table | Имя таблицы, из которой следует забирать настройки обработки текста |
| 0/1 как stats | Показывает статистику ключевых слов, по умолчанию 0 |
| 0/1 как fold_wildcards | Свернуть подстановочные знаки, по умолчанию 0 |
| 0/1 как fold_lemmas | Свернуть морфологические леммы, по умолчанию 0 |
| 0/1 как fold_blended | Свернуть смешанные слова, по умолчанию 0 |
| N как expansion_limit | Переопределить [expansion_limit](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expansion_limit), определенный в конфигурации сервера, по умолчанию 0 (использовать значение из конфигурации) |
| docs/hits как sort_mode | Сортирует выходные результаты по 'docs' или 'hits'. По умолчанию сортировка не применяется. |
| jieba_mode | Режим сегментации Jieba для запроса. Смотрите [jieba_mode](Creating_a_table/NLP_and_tokenization/Morphology.md#jieba_mode) для получения более подробной информации |

Примеры показывают, как это работает, если предположить, что пользователь пытается получить автозаполнение для "моя кошка ...". Таким образом, на стороне приложения вам нужно всего лишь предложить пользователю окончания из столбца "нормализованное" для каждого нового слова. Часто имеет смысл сортировать по 'hits' или 'docs' с использованием `'hits' как sort_mode` или `'docs' как sort_mode`.

<!-- intro -->
##### Примеры:

<!-- request Examples -->

```sql
MySQL [(none)]> CALL KEYWORDS('м*', 't', 1 как stats);
+------+-----------+------------+------+------+
| qpos | tokenized | normalized | docs | hits |
+------+-----------+------------+------+------+
| 1    | м*        | моя        | 1    | 2    |
| 1    | м*        | млекопитающее | 1    | 1    |
+------+-----------+------------+------+------+

MySQL [(none)]> CALL KEYWORDS('мою*', 't', 1 как stats);
+------+-----------+------------+------+------+
| qpos | tokenized | normalized | docs | hits |
+------+-----------+------------+------+------+
| 1    | мою*      | мою       | 1    | 2    |
+------+-----------+------------+------+------+

MySQL [(none)]> CALL KEYWORDS('к*', 't', 1 как stats, 'hits' как sort_mode);
+------+-----------+-------------+------+------+
| qpos | tokenized | normalized  | docs | hits |
+------+-----------+-------------+------+------+
| 1    | к*        | кошка      | 1    | 2    |
| 1    | к*        | хищное     | 1    | 1    |
| 1    | к*        | catus       | 1    | 1    |
+------+-----------+-------------+------+------+

MySQL [(none)]> CALL KEYWORDS('ка*', 't', 1 как stats, 'hits' как sort_mode);
+------+-----------+-------------+------+------+
| qpos | tokenized | normalized  | docs | hits |
+------+-----------+-------------+------+------+
| 1    | ка*       | кошка      | 1    | 2    |
| 1    | ка*       | хищное     | 1    | 1    |
| 1    | ка*       | catus       | 1    | 1    |
+------+-----------+-------------+------+------+

MySQL [(none)]> CALL KEYWORDS('ко*', 't', 1 как stats, 'hits' как sort_mode);
+------+-----------+------------+------+------+
| qpos | tokenized | normalized | docs | hits |
+------+-----------+------------+------+------+
| 1    | ко*       | кошка      | 1    | 2    |
| 1    | ко*       | catus      | 1    | 1    |
+------+-----------+------------+------+------+
```
<!-- end -->
<!-- example bigram -->
Существует хороший трюк, как вы можете улучшить вышеуказанный алгоритм - использовать [bigram_index](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#bigram_index). Когда для таблицы включен этот индекс, вы получаете не просто одно слово, а каждую пару слов, стоящих друг за другом, индексируемую как отдельный токен.

Это позволяет предсказать не только текущее окончание слова, но и следующее слово, что особенно полезно для автозаполнения.

<!-- intro -->
##### Примеры:

<!-- request Examples -->

```sql
MySQL [(none)]> CALL KEYWORDS('м*', 't', 1 как stats, 'hits' как sort_mode);
+------+-----------+------------+------+------+
| qpos | tokenized | normalized | docs | hits |
+------+-----------+------------+------+------+
| 1    | м*        | моя        | 1    | 2    |
| 1    | m*        | млекопитающее | 1    | 1    |
| 1    | m*        | мой кот      | 1    | 1    |
| 1    | m*        | моя собака   | 1    | 1    |
+------+-----------+------------+------+------+

MySQL [(none)]> CALL KEYWORDS('my*', 't', 1 as stats, 'hits' as sort_mode);
+------+-----------+------------+------+------+
| qpos | tokenized | normalized | docs | hits |
+------+-----------+------------+------+------+
| 1    | my*       | мой        | 1    | 2    |
| 1    | my*       | мой кот    | 1    | 1    |
| 1    | my*       | моя собака | 1    | 1    |
+------+-----------+------------+------+------+

MySQL [(none)]> CALL KEYWORDS('c*', 't', 1 as stats, 'hits' as sort_mode);
+------+-----------+--------------------+------+------+
| qpos | tokenized | normalized         | docs | hits |
+------+-----------+--------------------+------+------+
| 1    | c*        | кот                | 1    | 2    |
| 1    | c*        | плотоядный        | 1    | 1    |
| 1    | c*        | плотоядное млекопитающее | 1    | 1    |
| 1    | c*        | кот felis          | 1    | 1    |
| 1    | c*        | кот любит          | 1    | 1    |
| 1    | c*        | catus              | 1    | 1    |
| 1    | c*        | catus is           | 1    | 1    |
+------+-----------+--------------------+------+------+

MySQL [(none)]> CALL KEYWORDS('ca*', 't', 1 as stats, 'hits' as sort_mode);
+------+-----------+--------------------+------+------+
| qpos | tokenized | normalized         | docs | hits |
+------+-----------+--------------------+------+------+
| 1    | ca*       | кот                | 1    | 2    |
| 1    | ca*       | плотоядный        | 1    | 1    |
| 1    | ca*       | плотоядное млекопитающее | 1    | 1    |
| 1    | ca*       | кот felis          | 1    | 1    |
| 1    | ca*       | кот любит          | 1    | 1    |
| 1    | ca*       | catus              | 1    | 1    |
| 1    | ca*       | catus is           | 1    | 1    |
+------+-----------+--------------------+------+------+

MySQL [(none)]> CALL KEYWORDS('cat*', 't', 1 as stats, 'hits' as sort_mode);
+------+-----------+------------+------+------+
| qpos | tokenized | normalized | docs | hits |
+------+-----------+------------+------+------+
| 1    | cat*      | кот        | 1    | 2    |
| 1    | cat*      | кот felis  | 1    | 1    |
| 1    | cat*      | кот любит  | 1    | 1    |
| 1    | cat*      | catus      | 1    | 1    |
| 1    | cat*      | catus is   | 1    | 1    |
+------+-----------+------------+------+------+
```
<!-- end -->

`CALL KEYWORDS` поддерживает распределенные таблицы, так что независимо от того, насколько велика ваша база данных, вы можете извлечь выгоду от её использования.
<!-- proofread -->
