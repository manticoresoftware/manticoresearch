# Автозаполнение

Автозаполнение, или завершение слов, предсказывает и предлагает окончание слова или фразы по мере ввода. Оно часто используется в:
- Поисковых строках на веб-сайтах
- Подсказках в поисковых системах
- Текстовых полях в приложениях

Manticore предлагает расширенную функцию автозаполнения, которая дает предложения во время ввода, аналогично тем, что есть в известных поисковых системах. Это помогает ускорить поиск и позволяет пользователям быстрее находить нужное.

В дополнение к базовому функционалу автозаполнения, Manticore включает продвинутые возможности для улучшения пользовательского опыта:

1. **Коррекция орфографии (Fuzziness):** автозаполнение Manticore помогает исправлять орфографические ошибки с помощью алгоритмов, распознающих и исправляющих распространённые ошибки. Это значит, что даже если вы что-то ввели с ошибкой, вы всё равно сможете найти нужное.
2. **Автоопределение раскладки клавиатуры:** Manticore может определить, какую раскладку клавиатуры вы используете. Это особенно полезно в местах с множеством языков или если вы случайно ввели текст в неправильной раскладке. Например, если вы по ошибке напечатали "ghbdtn", Manticore понимает, что вы хотели написать "привет" и предлагает правильное слово.

Автозаполнение Manticore можно настроить в соответствии с различными требованиями и настройками, что делает его гибким инструментом для многих приложений.

![Autocomplete](autocomplete.png)

## ВЫЗОВ AUTOCOMPLETE

> ПРИМЕЧАНИЕ: `CALL AUTOCOMPLETE` и `/autocomplete` требуют [Manticore Buddy](../Installation/Manticore_Buddy.md). Если функция не работает, убедитесь, что Buddy установлен.

<!-- example call_autocomplete -->
Для использования автозаполнения в Manticore используйте SQL-запрос `CALL AUTOCOMPLETE` или его JSON-эквивалент `/autocomplete`. Эта функция предоставляет предложения по завершению слов на основе ваших индексированных данных.

Перед использованием убедитесь, что в таблице, которую вы хотите использовать для автозаполнения, включена функция [infixes](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len).

**Примечание:** В настройках таблицы автоматически проверяется параметр `min_infix_len`, при этом используется кеширование на 30 секунд для повышения производительности `CALL AUTOCOMPLETE`. После внесения изменений в таблицу может быть небольшая задержка при первом использовании `CALL AUTOCOMPLETE` (обычно она незаметна). Кешируются только успешные результаты, поэтому если вы удалите таблицу или отключите `min_infix_len`, `CALL AUTOCOMPLETE` может временно выдавать некорректные результаты, пока в итоге не начнет показываться ошибка, связанная с `min_infix_len`.

### Общий синтаксис

#### SQL
```sql
CALL AUTOCOMPLETE('query_beginning', 'table', [...options]);
```

#### JSON
```json
POST /autocomplete
{
	"table":"table_name",
	"query":"query_beginning"
	[,"options": {<autocomplete options>}]
}
```

#### Опции
- `layouts`: строка с кодами раскладок клавиатуры через запятую для обнаружения ошибок ввода из-за неправильной раскладки (например, ввод "ghbdtn" вместо "привет" при неправильной раскладке). Manticore сравнивает позиции символов в разных раскладках, чтобы предложить исправления. Для эффективного обнаружения несоответствий требуется минимум 2 раскладки. Доступные варианты: us, ru, ua, se, pt, no, it, gr, uk, fr, es, dk, de, ch, br, bg, be (подробнее [здесь](../Searching/Spell_correction.md#Options)). По умолчанию: отсутствует
- `fuzziness`: `0`, `1` или `2` (по умолчанию: `2`). Максимальное расстояние Левенштейна для поиска опечаток. Установите в `0` для отключения нечеткого поиска
- `preserve`: `0` или `1` (по умолчанию: `0`). При значении `1` в результаты поиска включаются слова без совпадений по нечеткому поиску (например, запрос "hello wrld" вернет и "hello wrld", и "hello world"). При значении `0` возвращаются только слова с успешными нечеткими совпадениями (например, "hello wrld" вернет только "hello world"). Особенно полезно для сохранения коротких слов или имен собственных, которые могут отсутствовать в Manticore Search
- `prepend`: Булево (0/1 в SQL). Если `true` (1), добавляет звездочку перед последним словом для расширения префикса (например, `*word`)
- `append`: Булево (0/1 в SQL). Если `true` (1), добавляет звездочку после последнего слова для расширения суффикса (например, `word*`)
- `expansion_len`: Количество символов для расширения в последнем слове. По умолчанию: `10`

<!-- request SQL -->

```sql
mysql> CALL AUTOCOMPLETE('hello', 'comment');
+------------+
| query      |
+------------+
| hello      |
| helio      |
| hell       |
| shell      |
| nushell    |
| powershell |
| well       |
| help       |
+------------+
```

<!-- request SQL with no fuzzy search -->

```sql
mysql> CALL AUTOCOMPLETE('hello', 'comment', 0 as fuzziness);
+-------+
| query |
+-------+
| hello |
+-------+
```

<!-- request JSON -->

```json
POST /autocomplete
{
	"table":"comment",
	"query":"hello"
}
```

<!-- response JSON -->
```json
[
  {
    "total": 8,
    "error": "",
    "warning": "",
    "columns": [
      {
        "query": {
          "type": "string"
        }
      }
    ],
    "data": [
      {
        "query": "hello"
      },
      {
        "query": "helio"
      },
      {
        "query": "hell"
      },
      {
        "query": "shell"
      },
      {
        "query": "nushell"
      },
      {
        "query": "powershell"
      },
      {
        "query": "well"
      },
      {
        "query": "help"
      }
    ]
  }
]
```

<!-- request SQL with preserve option -->

```sql
mysql> CALL AUTOCOMPLETE('hello wrld', 'comment', 1 as preserve);
+------------+
| query      |
+------------+
| hello wrld |
| hello world|
+------------+
```

<!-- request JSON with preserve option -->

```json
POST /autocomplete
{
	"table":"comment",
	"query":"hello wrld",
	"options": {
		"preserve": 1
	}
}
```

<!-- response JSON with preserve option -->
```json
[
  {
    "total": 2,
    "error": "",
    "warning": "",
    "columns": [
      {
        "query": {
          "type": "string"
        }
      }
    ],
    "data": [
      {
        "query": "hello wrld"
      },
      {
        "query": "hello world"
      }
    ]
  }
]
```

<!-- end -->

#### Ссылки
* [Демонстрация](https://github.manticoresearch.com/manticoresoftware/manticoresearch) работы автозаполнения:
  ![Пример автозаполнения](autocomplete_github_demo.png){.scale-0.7}
* Блог о нечетком поиске и автозаполнении - https://manticoresearch.com/blog/new-fuzzy-search-and-autocomplete/

## Альтернативные методы автозаполнения

Хотя `CALL AUTOCOMPLETE` является рекомендуемым методом для большинства случаев, Manticore также поддерживает другие контролируемые и настраиваемые подходы для реализации функции автозаполнения:

##### Автозаполнение предложения
Для автозаполнения предложения можно использовать [поиск по инфиксам](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len). Вы можете находить конец поля документа, вводя его начало и:
* используя [оператор подстановки для полнотекстового поиска](../Searching/Full_text_matching/Operators.md) `*` для совпадения с любыми символами
* опционально используя `^`, чтобы начинать с начала поля
* опционально используя `""` для поиска фразы
* а также используя [выделение результатов](../Searching/Highlighting.md)

Об этом есть [статья в блоге](https://manticoresearch.com/blog/simple-autocomplete-with-manticore/) и [интерактивный курс](https://play.manticoresearch.com/simpleautocomplete/). Краткий пример:
* Предположим, у вас есть документ: `My cat loves my dog. The cat (Felis catus) is a domestic species of small carnivorous mammal.`
* Тогда вы можете использовать `^`, `""` и `*`, чтобы при вводе пользователь делал запросы типа: `^"m*"`, `^"my *"`, `^"my c*"`, `^"my ca*"` и так далее
* Поиск найдет документ, и если вы также используете [выделение](../Searching/Highlighting.md), вы получите что-то вроде: `<b>My cat</b> loves my dog. The cat ( ...`

##### Автозаполнение слова
В некоторых случаях все, что вам нужно — это автодополнение одного слова или пары слов. В этом случае вы можете использовать `CALL KEYWORDS`.

### CALL KEYWORDS
`CALL KEYWORDS` доступна через SQL-интерфейс и предлагает способ проверить, как токенизируются ключевые слова или получить токенизированные формы конкретных ключевых слов. Если в таблице включены [инфиксы](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len), это позволяет быстро находить возможные окончания для заданных ключевых слов, что делает её подходящей для функции автодополнения.

Это отличная альтернатива общему инфиксному поиску, так как обеспечивает более высокую производительность, поскольку требует только словарь таблицы, а не сами документы.

### Общий синтаксис
<!-- example keywords -->
```sql
CALL KEYWORDS(text, table [, options])
```
Оператор `CALL KEYWORDS` разбивает текст на ключевые слова. Он возвращает токенизированные и нормализованные формы ключевых слов, а при желании — статистику по ключевым словам. Кроме того, он предоставляет позицию каждого ключевого слова в запросе и все формы токенизированных ключевых слов, если в таблице включены [лемматизаторы](../Creating_a_table/NLP_and_tokenization/Morphology.md).

| Parameter | Description |
| - | - |
| text | Текст для разбиения на ключевые слова |
| table | Имя таблицы, из которой берутся настройки обработки текста |
| 0/1 as stats | Показать статистику по ключевым словам, по умолчанию 0 |
| 0/1 as fold_wildcards | Свернуть подстановочные знаки, по умолчанию 0 |
| 0/1 as fold_lemmas | Свернуть морфологические леммы, по умолчанию 0 |
| 0/1 as fold_blended | Свернуть составные слова, по умолчанию 0 |
| N as expansion_limit | Переопределить [expansion_limit](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expansion_limit), заданный в конфигурации сервера, по умолчанию 0 (использовать значение из конфигурации) |
| docs/hits as sort_mode | Сортировать результаты по 'docs' или 'hits'. По умолчанию сортировка не применяется. |
| jieba_mode | Режим сегментации Jieba для запроса. Подробнее см. в разделе [jieba_mode](../Creating_a_table/NLP_and_tokenization/Morphology.md#jieba_mode) |

Примеры показывают, как это работает, если предположить, что пользователь пытается получить автодополнение для "my cat ...". Таким образом, со стороны приложения все, что нужно — предложить пользователю окончания из столбца "normalized" для каждого нового слова. Часто имеет смысл сортировать по hits или docs, используя `'hits' as sort_mode` или `'docs' as sort_mode`.

<!-- intro -->
##### Примеры:

<!-- request Examples -->

```sql
MySQL [(none)]> CALL KEYWORDS('m*', 't', 1 as stats);
+------+-----------+------------+------+------+
| qpos | tokenized | normalized | docs | hits |
+------+-----------+------------+------+------+
| 1    | m*        | my         | 1    | 2    |
| 1    | m*        | mammal     | 1    | 1    |
+------+-----------+------------+------+------+

MySQL [(none)]> CALL KEYWORDS('my*', 't', 1 as stats);
+------+-----------+------------+------+------+
| qpos | tokenized | normalized | docs | hits |
+------+-----------+------------+------+------+
| 1    | my*       | my         | 1    | 2    |
+------+-----------+------------+------+------+

MySQL [(none)]> CALL KEYWORDS('c*', 't', 1 as stats, 'hits' as sort_mode);
+------+-----------+-------------+------+------+
| qpos | tokenized | normalized  | docs | hits |
+------+-----------+-------------+------+------+
| 1    | c*        | cat         | 1    | 2    |
| 1    | c*        | carnivorous | 1    | 1    |
| 1    | c*        | catus       | 1    | 1    |
+------+-----------+-------------+------+------+

MySQL [(none)]> CALL KEYWORDS('ca*', 't', 1 as stats, 'hits' as sort_mode);
+------+-----------+-------------+------+------+
| qpos | tokenized | normalized  | docs | hits |
+------+-----------+-------------+------+------+
| 1    | ca*       | cat         | 1    | 2    |
| 1    | ca*       | carnivorous | 1    | 1    |
| 1    | ca*       | catus       | 1    | 1    |
+------+-----------+-------------+------+------+

MySQL [(none)]> CALL KEYWORDS('cat*', 't', 1 as stats, 'hits' as sort_mode);
+------+-----------+------------+------+------+
| qpos | tokenized | normalized | docs | hits |
+------+-----------+------------+------+------+
| 1    | cat*      | cat        | 1    | 2    |
| 1    | cat*      | catus      | 1    | 1    |
+------+-----------+------------+------+------+
```
<!-- end -->
<!-- example bigram -->
Существует хороший приём, как можно улучшить приведённый выше алгоритм — использовать [bigram_index](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#bigram_index). Когда он включен для таблицы, в нем индексируется не просто одно слово, а каждая пара слов, идущих подряд, как отдельный токен.

Это позволяет предсказывать не только окончание текущего слова, но и следующее слово, что особенно полезно для функции автодополнения.

<!-- intro -->
##### Примеры:

<!-- request Examples -->

```sql
MySQL [(none)]> CALL KEYWORDS('m*', 't', 1 as stats, 'hits' as sort_mode);
+------+-----------+------------+------+------+
| qpos | tokenized | normalized | docs | hits |
+------+-----------+------------+------+------+
| 1    | m*        | my         | 1    | 2    |
| 1    | m*        | mammal     | 1    | 1    |
| 1    | m*        | my cat     | 1    | 1    |
| 1    | m*        | my dog     | 1    | 1    |
+------+-----------+------------+------+------+

MySQL [(none)]> CALL KEYWORDS('my*', 't', 1 as stats, 'hits' as sort_mode);
+------+-----------+------------+------+------+
| qpos | tokenized | normalized | docs | hits |
+------+-----------+------------+------+------+
| 1    | my*       | my         | 1    | 2    |
| 1    | my*       | my cat     | 1    | 1    |
| 1    | my*       | my dog     | 1    | 1    |
+------+-----------+------------+------+------+

MySQL [(none)]> CALL KEYWORDS('c*', 't', 1 as stats, 'hits' as sort_mode);
+------+-----------+--------------------+------+------+
| qpos | tokenized | normalized         | docs | hits |
+------+-----------+--------------------+------+------+
| 1    | c*        | cat                | 1    | 2    |
| 1    | c*        | carnivorous        | 1    | 1    |
| 1    | c*        | carnivorous mammal | 1    | 1    |
| 1    | c*        | cat felis          | 1    | 1    |
| 1    | c*        | cat loves          | 1    | 1    |
| 1    | c*        | catus              | 1    | 1    |
| 1    | c*        | catus is           | 1    | 1    |
+------+-----------+--------------------+------+------+

MySQL [(none)]> CALL KEYWORDS('ca*', 't', 1 as stats, 'hits' as sort_mode);
+------+-----------+--------------------+------+------+
| qpos | tokenized | normalized         | docs | hits |
+------+-----------+--------------------+------+------+
| 1    | ca*       | cat                | 1    | 2    |
| 1    | ca*       | carnivorous        | 1    | 1    |
| 1    | ca*       | carnivorous mammal | 1    | 1    |
| 1    | ca*       | cat felis          | 1    | 1    |
| 1    | ca*       | cat loves          | 1    | 1    |
| 1    | ca*       | catus              | 1    | 1    |
| 1    | ca*       | catus is           | 1    | 1    |
+------+-----------+--------------------+------+------+

MySQL [(none)]> CALL KEYWORDS('cat*', 't', 1 as stats, 'hits' as sort_mode);
+------+-----------+------------+------+------+
| qpos | tokenized | normalized | docs | hits |
+------+-----------+------------+------+------+
| 1    | cat*      | cat        | 1    | 2    |
| 1    | cat*      | cat felis  | 1    | 1    |
| 1    | cat*      | cat loves  | 1    | 1    |
| 1    | cat*      | catus      | 1    | 1    |
| 1    | cat*      | catus is   | 1    | 1    |
+------+-----------+------------+------+------+
```
<!-- end -->

`CALL KEYWORDS` поддерживает распределённые таблицы, поэтому неважно, насколько велик ваш набор данных — вы сможете получить выгоду от его использования.
<!-- proofread -->

