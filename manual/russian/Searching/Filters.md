# Фильтры

## WHERE

`WHERE` — это SQL-клауза, которая работает как для полнотекстового поиска, так и для дополнительной фильтрации. Доступны следующие операторы:

* [Операторы сравнения](../Searching/Expressions.md#Comparison-operators) `<, >, <=, >=, =, <>, BETWEEN, IN, IS NULL`
* [Булевы операторы](../Searching/Full_text_matching/Operators.md#Boolean-operators) `AND, OR, NOT`

`MATCH('query')` поддерживается и соответствует [полнотекстовому запросу](../Searching/Full_text_matching/Operators.md).

Синтаксис условия `{col_name | expr_alias} [NOT] IN @uservar` поддерживается. См. синтаксис [SET](../Server_settings/Setting_variables_online.md#SET) для описания глобальных пользовательских переменных.

## HTTP JSON

Если вы предпочитаете HTTP JSON интерфейс, вы также можете применять фильтрацию. Это может показаться более сложным, чем SQL, но это рекомендуется в случаях, когда вам нужно программно подготовить запрос, например, когда пользователь заполняет форму в вашем приложении.

<!-- example json1 -->
Вот пример нескольких фильтров в `bool` запросе.

Этот полнотекстовый запрос соответствует всем документам, содержащим `product` в любом поле. Эти документы должны иметь цену больше или равную 500 (`gte`) и меньше или равную 1000 (`lte`). Все эти документы не должны иметь ревизию меньше 15 (`lt`).

<!-- request JSON -->
```json
POST /search
{
  "table": "test1",
  "query": {
    "bool": {
      "must": [
        { "match" : { "_all" : "product" } },
        { "range": { "price": { "gte": 500, "lte": 1000 } } }
      ],
      "must_not": {
        "range": { "revision": { "lt": 15 } }
      }
    }
  }
}
```
<!-- end -->


### bool запрос

<!-- example bool -->
`bool` запрос соответствует документам на основе булевых комбинаций других запросов и/или фильтров. Запросы и фильтры должны быть указаны в секциях `must`, `should` или `must_not` и могут быть [вложенными](../Searching/Filters.md#Nested-bool-query).

<!-- request JSON -->
```json
POST /search
{
  "table":"test1",
  "query": {
    "bool": {
      "must": [
        { "match": {"_all":"keyword"} },
        { "range": { "revision": { "gte": 14 } } }
      ]
    }
  }
}
```
<!-- end -->

<!-- example must_not -->
### must
Запросы и фильтры, указанные в секции `must`, обязаны совпадать с документами. Если указано несколько полнотекстовых запросов или фильтров, все они должны совпадать. Это эквивалентно запросам `AND` в SQL. Обратите внимание, если вы хотите выполнить поиск по массиву ([многоценностный атрибут](../../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29)), вы можете указать атрибут несколько раз. Результат будет положительным только в том случае, если все запрашиваемые значения найдены в массиве, например:

```json
"must": [
  {"equals" : { "product_codes": 5 }},
  {"equals" : { "product_codes": 6 }}
]
```

Также имейте в виду, что с точки зрения производительности может быть лучше использовать:
```json
  {"in" : { "all(product_codes)": [5,6] }}
```
(см. детали ниже).

### should
Запросы и фильтры, указанные в секции `should`, должны совпадать с документами. Если некоторые запросы указаны в `must` или `must_not`, запросы `should` игнорируются. С другой стороны, если нет запросов, кроме `should`, то хотя бы один из этих запросов должен совпадать с документом, чтобы он соответствовал булевому запросу. Это эквивалентно запросам `OR`. Обратите внимание, если вы хотите выполнить поиск по массиву ([многоценностный атрибут](../../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29)), вы можете указать атрибут несколько раз, например:

```json
"should": [
  {"equals" : { "product_codes": 7 }},
  {"equals" : { "product_codes": 8 }}
]
```

Также имейте в виду, что с точки зрения производительности может быть лучше использовать:
```json
  {"in" : { "any(product_codes)": [7,8] }}
```
(см. детали ниже).

### must_not
Запросы и фильтры, указанные в секции `must_not`, не должны совпадать с документами. Если несколько запросов указаны под `must_not`, документ соответствует, если ни один из них не совпадает.

<!-- request JSON -->
```json
POST /search
{
  "table":"t",
  "query": {
    "bool": {
      "should": [
        {
          "equals": {
            "b": 1
          }
        },
        {
          "equals": {
            "b": 3
          }
        }
      ],
      "must": [
        {
          "equals": {
            "a": 1
          }
        }
      ],
      "must_not": {
        "equals": {
          "b": 2
        }
      }
    }
  }
}
```
<!-- end -->

### Вложенный bool запрос

<!-- example eq_and_or -->
Bool запрос может быть вложен внутри другого bool, так что вы можете делать более сложные запросы. Чтобы создать вложенный булевый запрос, просто используйте другой `bool` вместо `must`, `should` или `must_not`. Вот как этот запрос:

```
a = 2 и (a = 10 или b = 0)
```

должен быть представлен в JSON.

<!-- request JSON -->
a = 2 и (a = 10 или b = 0)

```json
POST /search
{
  "table":"t",
  "query": {
    "bool": {
      "must": [
        {
          "equals": {
            "a": 2
          }
        },
        {
          "bool": {
            "should": [
              {
                "equals": {
                  "a": 10
                }
              },
              {
                "equals": {
                  "b": 0
                }
              }
            ]
          }
        }
      ]
    }
  }
}
```
<!-- end -->

<!-- example complex -->
Более сложный запрос:
```
(a = 1 и b = 1) или (a = 10 и b = 2) или (b = 0)
```
<!-- request JSON -->

(a = 1 и b = 1) или (a = 10 и b = 2) или (b = 0)

```json
POST /search
{
  "table":"t",
  "query": {
    "bool": {
      "should": [
        {
          "bool": {
            "must": [
              {
                "equals": {
                  "a": 1
                }
              },
              {
                "equals": {
                  "b": 1
                }
              }
            ]
          }
        },
        {
          "bool": {
            "must": [
              {
                "equals": {
                  "a": 10
                }
              },
              {
                "equals": {
                  "b": 2
                }
              }
            ]
          }
        },
        {
          "bool": {
            "must": [
              {
                "equals": {
                  "b": 0
                }
              }
            ]
          }
        }
      ]
    }
  }
}
```
<!-- end -->

### Запросы в формате SQL
<!-- example query_string -->
Запросы в формате SQL (`query_string`) также могут использоваться в булевых запросах.

<!-- request JSON -->
```json
POST /search
{
  "table": "test1",
  "query": {
    "bool": {
      "must": [
        { "query_string" : "product" },
        { "query_string" : "good" }
      ]
    }
  }
}
```
<!-- end -->

## Различные фильтры

### Фильтры равенства
<!-- example equals -->
Фильтры равенства — это самые простые фильтры, которые работают с целыми числами, плавающими числами и строковыми атрибутами.

<!-- request JSON -->
```json
POST /search
{
  "table":"test1",
  "query": {
    "equals": { "price": 500 }
  }
}
```
<!-- end -->

<!-- example equals_any -->
Фильтр `equals` можно применить к [атрибуту с несколькими значениями](../../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29), и вы можете использовать:
* `any()` который будет положительным, если атрибут имеет хотя бы одно значение, равное запрашиваемому значению;
* `all()` который будет положительным, если атрибут имеет единственное значение, и оно равно запрашиваемому значению

<!-- request JSON -->
```json
POST /search
{
  "table":"test1",
  "query": {
    "equals": { "any(price)": 100 }
  }
}
```
<!-- end -->


### Фильтры множества
<!-- example set -->
Фильтры множества проверяют, равно ли значение атрибута любому из значений в указанном множестве.

Фильтры множества поддерживают целые числа, строки и атрибуты с несколькими значениями.

<!-- request JSON -->
```json
POST /search
{
  "table":"test1",
  "query": {
    "in": {
      "price": [1,10,100]
    }
  }
}
```
<!-- end -->

<!-- example set_any -->
Когда применяется к [атрибуту с несколькими значениями](../../Creating_a_table/Data_types.md#Multi-value-integer-%28MVA%29), вы можете использовать:
* `any()` (эквивалентно отсутствию функции), который будет положительным, если существует хотя бы одно совпадение между значениями атрибутов и запрашиваемыми значениями;
* `all()` который будет положительным, если все значения атрибутов находятся в запрашиваемом множестве

<!-- request JSON -->
```json
POST /search
{
  "table":"test1",
  "query": {
    "in": {
      "all(price)": [1,10]
    }
  }
}
```
<!-- end -->

### Фильтры диапазона
<!-- example range -->
Фильтры диапазона сопоставляют документы, у которых значения атрибутов находятся в заданном диапазоне.

Фильтры диапазона поддерживают следующие свойства:
* `gte`: больше или равно
* `gt`: больше
* `lte`: меньше или равно
* `lt`: меньше

<!-- request JSON -->
```json
POST /search
{
  "table":"test1",
  "query": {
    "range": {
      "price": {
        "gte": 500,
        "lte": 1000
      }
    }
  }
}
```
<!-- end -->

### Гео-фильтры расстояния

<!-- example geo -->
Фильтры `geo_distance` используются для фильтрации документов, которые находятся на определенном расстоянии от геолокации.

##### location_anchor
Указывает местоположение пина в градусах. Расстояния рассчитываются от этой точки.

##### location_source
Указывает атрибуты, содержащие широту и долготу.

##### distance_type
Указывает функцию расчета расстояния. Может быть адаптивной или на основе гудерни. Адаптивная функция быстрее и более точная, для получения дополнительных сведений смотрите `GEODIST()`. Необязательный параметр, по умолчанию устанавливается в адаптивный.

##### distance
Указывает максимальное расстояние от местоположений пинов. Все документы в пределах этого расстояния соответствуют запросу. Расстояние может быть указано в различных единицах. Если не указана единица измерения, расстояние считается в метрах. Вот список поддерживаемых единиц измерения расстояния:

* Метр: `m` или `meters`
* Километр: `km` или `kilometers`
* Сантиметр: `cm` или `centimeters`
* Миллиметр: `mm` или `millimeters`
* Миля: `mi` или `miles`
* Ярд: `yd` или `yards`
* Фут: `ft` или `feet`
* Дюйм: `in` или `inch`
* Морская миля: `NM`, `nmi` или `nauticalmiles`

Свойства `location_anchor` и `location_source` принимают следующие форматы широты/долготы:

* объект с ключами lat и lon: `{ "lat": "attr_lat", "lon": "attr_lon" }`
* строка следующей структуры: `"attr_lat, attr_lon"`
* массив с широтой и долготой в следующем порядке: `[attr_lon, attr_lat]`

Широта и долгота указываются в градусах.


<!-- request Basic example -->
```json
POST /search
{
  "table":"test",
  "query": {
    "geo_distance": {
      "location_anchor": {"lat":49, "lon":15},
      "location_source": {"attr_lat, attr_lon"},
      "distance_type": "adaptive",
      "distance":"100 km"
    }
  }
}
```

<!-- request Advanced example -->
`geo_distance` может использоваться в качестве фильтра в булевых запросах вместе с совпадениями или другими атрибутами фильтров.

```json
POST /search
{
  "table": "geodemo",
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "*": "station"
          }
        },
        {
          "equals": {
            "state_code": "ENG"
          }
        },
        {
          "geo_distance": {
            "distance_type": "adaptive",
            "location_anchor": {
              "lat": 52.396,
              "lon": -1.774
            },
            "location_source": "latitude_deg,longitude_deg",
            "distance": "10000 m"
          }
        }
      ]
    }
  }
}
```

<!-- end -->
<!-- proofread -->

