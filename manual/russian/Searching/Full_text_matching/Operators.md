# Полнотекстовые операторы

Строка запроса может включать конкретные операторы, которые определяют условия того, как должны сопоставляться слова из строки запроса.

### Булевы операторы

#### Оператор AND

Неявный логический оператор AND всегда присутствует, поэтому "hello world" подразумевает, что оба слова "hello" и "world" должны быть найдены в сопоставляемом документе.

```sql
hello  world
```

Примечание: явного оператора `AND` нет.

#### Оператор OR

Логический оператор OR `|` имеет более высокий приоритет, чем AND, поэтому `looking for cat | dog | mouse` означает `looking for (cat | dog | mouse)`, а не `(looking for cat) | dog | mouse`.

```sql
hello | world
```

Примечание: оператора `OR` не существует. Пожалуйста, используйте `|` вместо него.

### Оператор MAYBE

```sql
hello MAYBE world
```

Оператор `MAYBE` работает аналогично оператору `|`, но не возвращает документы, которые совпадают только с правым выражением дерева.

### Оператор отрицания

```sql
hello -world
hello !world
```

Оператор отрицания задаёт правило, что слово не должно присутствовать.

Запросы, содержащие **только** отрицания, по умолчанию **не** поддерживаются. Чтобы включить поддержку, используйте опцию сервера [not_terms_only_allowed](../../Server_settings/Searchd.md#not_terms_only_allowed).

### Оператор поиска по полю

```sql
@title hello @body world
```

Оператор ограничения поля ограничивает последующие поиски указанным полем. По умолчанию запрос вызовет ошибку, если заданное имя поля отсутствует в искомой таблице. Тем не менее, это поведение можно подавить, указав опцию `@@relaxed` в начале запроса:

```sql
@@relaxed @nosuchfield my query
```

Это может быть полезно при поиске по гетерогенным таблицам с разными схемами.

Ограничения позиции поля дополнительно ограничивают поиск первыми N позициями в данном поле (или полях). Например, `@body [50] hello` не совпадает с документами, где ключевое слово `hello` появляется на позиции 51 или далее в теле текста.

```sql
@body[50] hello
```

Оператор поиска по нескольким полям:

```sql
@(title,body) hello world
```

Оператор игнорирования поля поиска (игнорирует любые совпадения 'hello world' из поля 'title'):

```sql
@!title hello world
```

Оператор игнорирования поиска по нескольким полям (если существуют поля 'title', 'subject' и 'body', то `@!(title)` эквивалентен `@(subject,body)`):

```sql
@!(title,body) hello world
```

Оператор поиска по всем полям:

```sql
@* hello
```

### Оператор поиска по фразе

```sql
"hello world"
```

Оператор фразы требует, чтобы слова шли подряд друг за другом.

Оператор поиска по фразе может включать модификатор `match any term`. Внутри оператора фразы термины имеют позиционное значение. При использовании модификатора 'match any term' позиции последующих терминов в запросе с фразой будут смещены. В результате модификатор 'match any' не влияет на производительность поиска.

Примечание: при использовании этого оператора с запросами, содержащими более 31 ключевого слова, статистика ранжирования (такая как `tf`, `idf`, `bm25`) для слов в позициях 31 и выше может учитываться с понижением точности. Это связано с внутренним использованием 32-битной маски для отслеживания вхождений терминов в совпадении. Логика сопоставления (нахождение документов) остаётся корректной, но рейтинг может быть искажен для очень длинных запросов.

```sql
"exact * phrase * * for terms"
```

Вы также можете использовать оператор OR внутри кавычек. Оператор OR (`|`) должен быть заключён в скобки `()` при использовании внутри фраз. Каждый вариант проверяется на одной позиции, и фраза совпадает, если любой из вариантов подходит для этой позиции.

**Верные примеры** (со скобками):
```sql
"( a | b ) c"
"( ( a b c ) | d ) e"
"man ( happy | sad ) but all ( ( as good ) | ( as fast ) )"
```

**Неверные примеры** (без скобок — такие не работают):
```sql
"a | b c"
"happy | sad"
```

###  Оператор поиска по близости

```sql
"hello world"~10
```

Расстояние близости измеряется в словах, учитывая количество слов, и применяется ко всем словам внутри кавычек. Например, запрос `"cat dog mouse"~5` означает, что должен быть отрезок меньше 8 слов, содержащий все 3 слова. Поэтому документ с текстом `CAT aaa bbb ccc DOG eee fff MOUSE` не соответствует запросу, так как отрезок равен ровно 8 словам.

Примечание: при использовании этого оператора с запросами, содержащими более 31 ключевого слова, статистика ранжирования (такая как `tf`, `idf`, `bm25`) для слов в позициях 31 и выше может учитываться с понижением точности. Это связано с внутренним использованием 32-битной маски для отслеживания вхождений терминов в совпадении. Логика сопоставления (нахождение документов) остаётся корректной, но рейтинг может быть искажен для очень длинных запросов.

Вы также можете использовать оператор OR внутри поиска по близости. Оператор OR (`|`) должен быть заключён в скобки `()` при использовании внутри поисков по близости. Каждый вариант проверяется отдельно.

**Верный пример** (со скобками):
```sql
"( two | four ) fish chips"~5
```

**Неверный пример** (без скобок — не работает):
```sql
"two | four fish chips"~5
```

###  Оператор кворумного совпадения

```sql
"the world is a wonderful place"/3
```

Оператор кворумного совпадения вводит тип нечеткого поиска. Он совпадает только с теми документами, которые соответствуют заданному порогу по количеству указанных слов. В примере выше (`"the world is a wonderful place"/3`) совпадут все документы, содержащие не менее 3 из 6 указанных слов. Оператор ограничен 255 ключевыми словами. Вместо абсолютного числа можно указать значение от 0.0 до 1.0 (представляющее 0% и 100%), и Manticore будет совпадать только с документами, содержащими не менее указанного процента слов. Тот же пример выше можно записать как `"the world is a wonderful place"/0.5`, и он будет совпадать с документами, содержащими не менее 50% из 6 слов.

Оператор кворума поддерживает оператор OR (`|`). Оператор OR (`|`) должен быть заключён в скобки `()` при использовании внутри кворумного совпадения. Для совпадения учитывается только одно слово из каждой группы OR.

**Верные примеры** (со скобками):
```sql
"( ( a b c ) | d ) e f g"/0.5
"happy ( sad | angry ) man"/2
```

**Неверный пример** (без скобок — не работает):
```sql
"a b c | d e f g"/0.5
```

### Оператор строгого порядка

```sql
aaa << bbb << ccc
```

Оператор строгого порядка (также известный как оператор "before") совпадает с документом только если ключевые слова аргумента появляются в документе именно в том порядке, который указан в запросе. Например, запрос `black << cat` совпадёт с документом "black and white cat", но не с документом "that cat was black". Оператор порядка имеет самый низкий приоритет. Его можно применять как к отдельным ключевым словам, так и к более сложным выражениям. Например, это корректный запрос:

```sql
(bag of words) << "exact phrase" << red|green|blue
```

### Модификатор точной формы

```sql
raining =cats and =dogs
="exact phrase"
```

Модификатор ключевого слова точной формы совпадает с документом только если ключевое слово встречается в точно указанной форме. По умолчанию документ считается совпадающим, если совпадает основа/лемма ключевого слова. Например, запрос "runs" совпадает с документом, содержащим "runs", и с документом, содержащим "running", поскольку обе формы сводятся к основе "run". Однако запрос `=runs` совпадает только с первым документом. Модификатор точной формы требует включения опции [index_exact_words](../../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words).

Другой сценарий использования — предотвращение [расширения](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expand_keywords) ключевого слова до формы `*keyword*`. Например, при `index_exact_words=1` + `expand_keywords=1/star`, запрос `bcd` найдет документ, содержащий `abcde`, а `=bcd` — нет.

Как модификатор, влияющий на ключевое слово, его можно использовать внутри операторов, таких как оператор фразы, близости и кворума. Применение модификатора точной формы к оператору фразы возможно, и в этом случае он внутренне добавляет модификатор точной формы ко всем терминам в фразе.

### Операторы подстановки

```sql
nation* *nation* *national
```

Требует установки [min_infix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) для префикса (расширение в конце) и/или суффикса (расширение в начале). Если требуется только префиксное расширение, можно использовать [min_prefix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_prefix_len).

Поиск пытается найти все расширения токенов с подстановочными символами, и каждое расширение фиксируется как совпадающее попадание. Количество расширений токена можно контролировать с помощью настройки таблицы [expansion_limit](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expansion_limit). Токены с подстановочными символами могут существенно влиять на время поиска запросов, особенно если токены короткие. В таких случаях рекомендуется использовать ограничение расширения.

Оператор подстановки может автоматически применяться, если используется настройка таблицы [expand_keywords](../../Searching/Options.md#expand_keywords).

Кроме того, поддерживаются следующие встроенные операторы подстановки:

* `?` может соответствовать любому одному символу: `t?st` совпадает с `test`, но не с `teast`
* `%` может соответствовать нулю или одному символу: `tes%` совпадает с `tes` или `test`, но не с `testing`

Встроенные операторы требуют `dict=keywords` (включено по умолчанию) и включения префиксного/вставочного режимов.

### Оператор REGEX

```sql
REGEX(/t.?e/)
```

Требует установки [min_infix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) или [min_prefix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_prefix_len) и опций [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=keywords (по умолчанию).

Аналогично [операторам подстановки](../../Searching/Full_text_matching/Operators.md#Wildcard-operators), оператор REGEX пытается найти все токены, соответствующие заданному шаблону, и каждое расширение фиксируется как совпадающее попадание. Обратите внимание, это может существенно влиять на время поиска по запросу, так как просматривается весь словарь, и каждый термин проверяется на соответствие шаблону REGEX.

Шаблоны должны соответствовать синтаксису [RE2](https://github.com/google/re2/wiki/Syntax). Разделитель выражения REGEX — первый символ после открывающей скобки. Иными словами, весь текст между открывающей скобкой с разделителем и разделителем с закрывающей скобкой считается выражением RE2.
Обратите внимание, что термины, хранящиеся в словаре, подвергаются преобразованию `charset_table`, то есть, например, REGEX может не распознать заглавные буквы, если все символы приведены к нижнему регистру в соответствии с `charset_table` (что происходит по умолчанию). Чтобы успешно сопоставить термин с помощью выражения REGEX, шаблон должен соответствовать всему токену целиком. Для частичного совпадения поставьте `.*` в начале и/или конце шаблона.

```sql
REGEX(/.{3}t/)
REGEX(/t.*\d*/)
```

### Модификаторы начала и конца поля

```sql
^hello world$
```

Модификаторы ключевого слова начала и конца поля обеспечивают совпадение ключевого слова только если оно появляется в самом начале или в самом конце полнотекстового поля соответственно. Например, запрос `"^hello world$"` (в кавычках, чтобы объединить оператор фразы с модификаторами начала/конца) будет совпадать исключительно с документами, содержащими хотя бы одно поле с этими двумя конкретными ключевыми словами.

### Модификатор усиления IDF

```sql
boosted^1.234 boostedfieldend$^1.234
```

Модификатор усиления повышает оценку слова по [IDF](../../Searching/Options.md#idf) на указанный коэффициент в ранжировании, которое учитывает IDF. Он не влияет на процесс совпадения.

### Оператор NEAR

```sql
hello NEAR/3 world NEAR/4 "my test"
```

Оператор `NEAR` является более универсальной версией оператора близости. Его синтаксис — `NEAR/N`, он чувствителен к регистру и не допускает пробелов между ключевым словом `NEAR`, слэшем и числом дистанции.

В то время как исходный оператор близости работает только с наборами ключевых слов, `NEAR` более универсален и может принимать произвольные подвыражения в качестве двух аргументов. Он совпадает с документом, когда оба подвыражения находятся на расстоянии не более N слов друг от друга, независимо от порядка. `NEAR` — левосторонне ассоциативный оператор с таким же (самым низким) приоритетом, как и [BEFORE](../../Searching/Full_text_matching/Operators.md#Strict-order-operator).

Важно отметить, что выражение `one NEAR/7 two NEAR/7 three` не полностью эквивалентно `"one two three"~7`. Главное отличие в том, что оператор близости допускает до 6 слов между всеми тремя совпадающими словами, а версия с `NEAR` менее строгая: она разрешает до 6 слов между `one` и `two`, а затем еще до 6 слов между найденной двухсловной группой и `three`.

Примечание: При использовании этого оператора с запросами, содержащими более 31 ключевого слова, статистика ранжирования (такая как `tf`, `idf`, `bm25`) для ключевых слов на позиции 31 и выше может быть недооценена. Это связано с использованием 32-битной маски для отслеживания вхождений терминов внутри совпадения. Логика сопоставления (поиск документов) остается корректной, но оценки ранжирования могут быть затронуты для очень длинных запросов.

### Оператор NOTNEAR

```sql
Church NOTNEAR/3 street
```

Оператор `NOTNEAR` служит отрицательным утверждением и функционирует как логическая инверсия оператора `NEAR`. Он находит совпадение в документе, когда левый аргумент присутствует, при условии, что правый аргумент либо отсутствует в документе, либо находится **дальше** указанного расстояния от левого аргумента.

Синтаксис: `NOTNEAR/N`, регистрозависимый, пробелы между ключевым словом `NOTNEAR`, знаком слэша и значением расстояния не допускаются.

Ключевые особенности:
*   **Симметричность**: Как и `NEAR`, оператор `NOTNEAR` применяется независимо от порядка терминов в тексте. Он исключит совпадение, если правый аргумент будет найден в пределах указанного расстояния **до** или **после** левого аргумента.
*   **Порог расстояния**: Расстояние `N` представляет собой ближний диапазон (включительно). Если слова разделены `N` словами или меньше, совпадение отбрасывается. Правый аргумент должен находиться на расстоянии `N + 1` или более слов.
*   **Аргументы**: Оба аргумента этого оператора могут быть терминами, фразами или группами операторов.

### Операторы SENTENCE и PARAGRAPH

```sql
all SENTENCE words SENTENCE "in one sentence"
```


```sql
"Bill Gates" PARAGRAPH "Steve Jobs"
```
Операторы `SENTENCE` и `PARAGRAPH` находят совпадение в документе, когда оба их аргумента находятся в пределах одного предложения или одного абзаца текста, соответственно. Этими аргументами могут быть ключевые слова, фразы или экземпляры того же оператора.

Порядок аргументов внутри предложения или абзаца не имеет значения. Эти операторы работают только с таблицами, построенными с включенной функцией [index_sp](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_sp) (индексация предложений и абзацев), и в противном случае сводятся к простой операции AND. Информацию о том, что считается предложением и абзацем, смотрите в документации директивы [index_sp](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_sp).


### Оператор ограничения ZONE

```sql
ZONE:(h3,h4)

only in these titles
```

Оператор `ZONE limit` очень похож на оператор ограничения поля, но ограничивает совпадение указанной внутриполевой зоной или списком зон. Важно отметить, что последующие подвыражения не обязаны совпадать в пределах одного непрерывного сегмента данной зоны и могут совпадать в нескольких сегментах. Например, запрос `(ZONE:th hello world)` найдет совпадение в следующем примере документа:

```html
<th>Table 1. Local awareness of Hello Kitty brand.</th>
.. some table data goes here ..
<th>Table 2. World-wide brand awareness.</th>
```

Оператор `ZONE` действует на запрос до следующего оператора ограничения поля или `ZONE`, или до закрывающей скобки. Он работает исключительно с таблицами, построенными с поддержкой зон (см. [index_zones](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_zones)), и в противном случае игнорируется.

### Оператор ограничения ZONESPAN

```sql
ZONESPAN:(h2)

only in a (single) title
```

Оператор ограничения `ZONESPAN` похож на оператор `ZONE`, но требует, чтобы совпадение происходило в пределах одного непрерывного сегмента. В приведенном ранее примере `ZONESPAN:th hello world` не нашел бы совпадения в документе, так как "hello" и "world" не появляются в одном сегменте.

<!-- proofread -->

