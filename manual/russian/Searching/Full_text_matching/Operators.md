# Операторы полнотекстового поиска

Строка запроса может включать специфические операторы, которые определяют условия, по которым слова из строки запроса должны сопоставляться.

### Булевы операторы

#### Оператор AND

Неявный логический оператор AND всегда присутствует, поэтому "hello world" означает, что оба слова "hello" и "world" должны быть найдены в сопоставляемом документе.

```sql
hello  world
```

Примечание: Явного оператора `AND` нет.

#### Оператор OR

Логический оператор OR `|` имеет более высокий приоритет, чем AND, поэтому `looking for cat | dog | mouse` означает `looking for (cat | dog | mouse)`, а не `(looking for cat) | dog | mouse`.

```sql
hello | world
```

Примечание: Оператора `OR` нет. Пожалуйста, используйте вместо него `|`.

### Оператор MAYBE

```sql
hello MAYBE world
```

Оператор `MAYBE` работает аналогично оператору `|`, но не возвращает документы, которые совпадают только с выражением из правого поддерева.

### Оператор отрицания

```sql
hello -world
hello !world
```

Оператор отрицания задаёт условие отсутствия слова.

Запросы, содержащие **исключительно** отрицания, по умолчанию **не поддерживаются**. Чтобы включить поддержку, используйте параметр сервера [not_terms_only_allowed](../../Server_settings/Searchd.md#not_terms_only_allowed).

### Оператор поиска по полю

```sql
@title hello @body world
```

Оператор ограничения поля ограничивает последующий поиск указанным полем. По умолчанию, если имя поля не существует в таблице, поиск завершится с ошибкой. Однако это поведение можно подавить, указав опцию `@@relaxed` в начале запроса:

```sql
@@relaxed @nosuchfield my query
```

Это полезно при поиске по гетерогенным таблицам с разными схемами.

Ограничения по позициям поля дополнительно ограничивают поиск первыми N позициями внутри заданного поля (или полей). Например, `@body [50] hello` не найдёт документы, где ключевое слово `hello` находится на позиции 51 или позже в теле.

```sql
@body[50] hello
```

Оператор поиска по нескольким полям:

```sql
@(title,body) hello world
```

Оператор игнорирования поиска по полю (игнорирует совпадения 'hello world' в поле 'title'):

```sql
@!title hello world
```

Оператор игнорирования поиска по нескольким полям (если есть поля 'title', 'subject' и 'body', то `@!(title)` эквивалентен `@(subject,body)`):

```sql
@!(title,body) hello world
```

Оператор поиска по всем полям:

```sql
@* hello
```

### Оператор поиска по фразе

```sql
"hello world"
```

Оператор фразы требует, чтобы слова шли подряд.

Оператор поиска по фразе может включать модификатор `match any term` (совпадение любого термина). Внутри оператора фразы порядок слов важен. При использовании модификатора `match any term` позиции последующих терминов сдвигаются. Следовательно, модификатор `match any` не влияет на производительность поиска.

```sql
"exact * phrase * * for terms"
```

Также внутри кавычек можно использовать оператор `OR`. Каждая опция проверяется на той же позиции, и фраза совпадает, если хотя бы одна из опций подходит под эту позицию. Примеры:

```sql
"( a | b ) c"
"( ( a b c ) | d ) e"
"man ( happy | sad ) but all ( ( as good ) | ( as fast ) )"
```

###  Оператор поиска по близости

```sql
"hello world"~10
```

Расстояние близости измеряется в количестве слов, учитывая количество слов, и применяется ко всем словам в кавычках. Например, запрос `"cat dog mouse"~5` означает, что должен быть интервал меньше 8 слов, содержащий все 3 слова. Следовательно, документ с `CAT aaa bbb ccc DOG eee fff MOUSE` не будет совпадать с этим запросом, поскольку интервал ровно 8 слов.

Также можно использовать оператор `OR` внутри поиска по близости. Каждая опция проверяется отдельно. Пример:

```sql
"( two | four ) fish chips"~5
```

###  Оператор кворума

```sql
"the world is a wonderful place"/3
```

Оператор кворума вводит своего рода нестрогое совпадение. Он сопоставит только те документы, которые соответствуют заданному порогу указанных слов. В приведённом примере (`"the world is a wonderful place"/3`) будут найдены документы, содержащие не менее 3 из 6 указанных слов. Оператор ограничен 255 ключевыми словами. Вместо абсолютного числа можно также использовать значение от 0.0 до 1.0 (обозначающее 0% и 100%), и Manticore сопоставит только документы, содержащие не менее указанного процента заданных слов. Тот же пример выше можно записать как `"the world is a wonderful place"/0.5`, и он даст совпадение с документами, содержащими не менее 50% из 6 слов.

Оператор кворума поддерживает оператор `OR`. В каждую группу `OR` засчитывается только одно слово для совпадения. Примеры:

```sql
"( ( a b c ) | d ) e f g"/0.5
"happy ( sad | angry ) man"/2
```

### Оператор строгого порядка

```sql
aaa << bbb << ccc
```

Оператор строгого порядка (также известный как оператор «до») сопоставит документ только в том случае, если ключевые слова появляются в документе именно в указанном в запросе порядке. Например, запрос `black << cat` совпадёт с документом "black and white cat", но не с документом "that cat was black". Оператор порядка имеет самый низкий приоритет. Он может применяться как к отдельным ключевым словам, так и к более сложным выражениям. Например, следующий запрос валиден:

```sql
(bag of words) << "exact phrase" << red|green|blue
```

### Модификатор точной формы

```sql
raining =cats and =dogs
="exact phrase"
```

Модификатор ключевого слова exact form совпадает с документом только в том случае, если ключевое слово встречается в точной форме, указанной в запросе. По умолчанию документ считается совпадающим, если совпадает основа/лемматизированная форма ключевого слова. Например, запрос "runs" найдёт как документ с "runs", так и документ с "running", поскольку обе формы сводятся к основе "run". Однако запрос `=runs` найдёт только первый документ. Модификатор exact form требует включения опции [index_exact_words](../../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words).

Другой случай использования — предотвратить [расширение](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expand_keywords) ключевого слова до формы `*keyword*`. Например, с установками `index_exact_words=1` + `expand_keywords=1/star` запрос `bcd` найдёт документ, содержащий `abcde`, но `=bcd` — не найдёт.

Как модификатор, влияющий на ключевое слово, он может использоваться внутри операторов, таких как оператор фразы, оператора близости и кворума. Применение модификатора точной формы к оператору фразы возможно, и в этом случае он внутренне применяется ко всем терминам в фразе.

### Операторы подстановочных знаков

```sql
nation* *nation* *national
```

Требуют наличия [min_infix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) для префикса (расширение в конце) и/или суффикса (расширение в начале). Если нужно только префиксное расширение, вместо этого можно использовать [min_prefix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_prefix_len).

Поиск попытается найти все расширения токенов с подстановочными знаками, и каждое расширение записывается как совпавший результат. Количество расширений для токена можно контролировать с помощью настройки таблицы [expansion_limit](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expansion_limit). Токены с подстановочными знаками могут существенно увеличить время поиска запроса, особенно при короткой длине токенов. В таких случаях рекомендуется использовать ограничение на расширение.

Оператор подстановочного знака может применяться автоматически, если используется настройка таблицы [expand_keywords](../../Searching/Options.md#expand_keywords).

Кроме того, поддерживаются следующие встроенные операторы подстановочных знаков:

* `?` может соответствовать любому одному символу: `t?st` найдёт `test`, но не `teast`
* `%` может соответствовать нулю или одному символу: `tes%` найдёт `tes` или `test`, но не `testing`

Встроенные операторы требуют `dict=keywords` (включено по умолчанию) и включённое префиксное/инфиксное расширение.

### Оператор REGEX

```sql
REGEX(/t.?e/)
```

Требует установки [min_infix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) или [min_prefix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_prefix_len) и опции [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=keywords (что является настройкой по умолчанию).

Аналогично [операторам подстановочных знаков](../../Searching/Full_text_matching/Operators.md#Wildcard-operators), оператор REGEX пытается найти все токены, соответствующие заданному шаблону, и каждое соответствие записывается как совпавший результат. Обратите внимание, что это может значительно увеличить время поиска, поскольку происходит сканирование всего словаря, и каждый термин проходит сопоставление с шаблоном REGEX.

Шаблоны должны соответствовать [синтаксису RE2](https://github.com/google/re2/wiki/Syntax). Ограничителем выражения REGEX является первый символ после открывающей скобки. Иными словами, весь текст между открывающей скобкой с последующим ограничителем и таким же ограничителем с закрывающей скобкой считается выражением RE2.
Обратите внимание, что термины, хранящиеся в словаре, проходят преобразование `charset_table`, то есть, например, REGEX может не совпасть с заглавными буквами, если все символы приведены к нижнему регистру согласно `charset_table` (что происходит по умолчанию). Чтобы успешно сопоставить термин с помощью REGEX, шаблон должен соответствовать всему токену целиком. Для частичного совпадения разместите `.*` в начале и/или конце шаблона.

```sql
REGEX(/.{3}t/)
REGEX(/t.*\d*/)
```

### Модификаторы начала и конца поля

```sql
^hello world$
```

Модификаторы начала (^ ) и конца ($ ) поля гарантируют, что ключевое слово совпадёт только если оно находится в самом начале или самом конце поля полнотекстового поиска соответственно. Например, запрос `"^hello world$"` (в кавычках для объединения оператора фразы с модификаторами начала/конца) найдёт только документы, содержащие хотя бы одно поле с этими двумя точными ключевыми словами.

### Модификатор повышения IDF

```sql
boosted^1.234 boostedfieldend$^1.234
```

Модификатор повышения увеличивает слово [IDF](../../Searching/Options.md#idf)_оценку в ранжировании на указанный коэффициент в ранжировочных скорорах, включающих IDF в расчёты. Он не влияет на процесс поиска совпадений.

### Оператор NEAR

```sql
hello NEAR/3 world NEAR/4 "my test"
```

Оператор `NEAR` является более универсальной версией оператора близости. Его синтаксис — `NEAR/N`, при этом регистр важен, и между ключевыми словами `NEAR`, слэшем и значением расстояния не допускаются пробелы.

В то время как исходный оператор близости работает только с наборами ключевых слов, `NEAR` более гибок и может принимать произвольные подвыражения в качестве двух аргументов. Он сопоставляет документ, если оба подвыражения находятся на расстоянии не более N слов друг от друга, независимо от их порядка. `NEAR` является левосторонне ассоциативным и имеет тот же (низший) приоритет, что и [BEFORE](../../Searching/Full_text_matching/Operators.md#Strict-order-operator).
Важно отметить, что `one NEAR/7 two NEAR/7 three` не совсем эквивалентно `"one two three"~7`. Ключевое отличие заключается в том, что оператор близости позволяет иметь до 6 не совпадающих слов между всеми тремя совпадающими словами, тогда как версия с `NEAR` менее строгая: она допускает до 6 слов между `one` и `two`, а затем до 6 слов между этим двухсловным совпадением и `three`.

### Оператор NOTNEAR

```sql
Church NOTNEAR/3 street
```
Оператор `NOTNEAR` служит для отрицательного утверждения. Он сопоставляет документ, когда левый аргумент присутствует, а либо правого аргумента нет в документе, либо правый аргумент находится на заданном расстоянии от конца совпадающего левого аргумента. Расстояние обозначается в словах. Синтаксис — `NOTNEAR/N`, он чувствителен к регистру и не допускает пробелов между ключевым словом `NOTNEAR`, символом слэша и значением расстояния. Оба аргумента этого оператора могут быть терминами, любыми операторами или группами операторов.

### Операторы SENTENCE и PARAGRAPH

```sql
all SENTENCE words SENTENCE "in one sentence"
```


```sql
"Bill Gates" PARAGRAPH "Steve Jobs"
```
Операторы `SENTENCE` и `PARAGRAPH` сопоставляют документ, если оба их аргумента находятся в одном предложении или в одном абзаце текста соответственно. Эти аргументы могут быть ключевыми словами, фразами или экземплярами одного и того же оператора.

Порядок аргументов внутри предложения или абзаца не имеет значения. Эти операторы работают только с таблицами, построенными с включённой функцией [index_sp](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_sp) (индексация предложений и абзацев), и в противном случае сводятся к простой операции AND. Для информации о том, что считается предложением и абзацем, обратитесь к документации по директиве [index_sp](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_sp).


### Оператор ограничения ZONE

```sql
ZONE:(h3,h4)

only in these titles
```

Оператор ограничения `ZONE` очень похож на оператор ограничения поля, но ограничивает совпадение указанной зоной внутри поля или списком таких зон. Важно отметить, что последующие подвыражения не обязаны совпадать внутри одного непрерывного промежутка заданной зоны и могут совпадать в разных промежутках. Например, запрос `(ZONE:th hello world)` сопоставит следующий пример документа:

```html
<th>Table 1. Local awareness of Hello Kitty brand.</th>
.. some table data goes here ..
<th>Table 2. World-wide brand awareness.</th>
```

Оператор `ZONE` действует на запрос до следующего оператора ограничения поля или `ZONE`, либо до закрывающейся скобки. Он работает исключительно с таблицами, построенными с поддержкой зон (см. [index_zones](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_zones)) и игнорируется в противном случае.

### Оператор ограничения ZONESPAN

```sql
ZONESPAN:(h2)

only in a (single) title
```

Оператор ограничения `ZONESPAN` похож на оператор `ZONE`, но требует, чтобы совпадение происходило внутри одного непрерывного промежутка. В приведённом ранее примере `ZONESPAN:th hello world` не сопоставлял бы документ, так как "hello" и "world" не находятся внутри одного промежутка.

<!-- proofread -->


