# Полные текстовые операторы

В строке запроса могут быть включены специальные операторы, которые определяют условия для сопоставления слов из строки запроса.

### Логические операторы

#### Оператор И

Неявный логический оператор И всегда присутствует, поэтому "hello world" подразумевает, что и "hello", и "world" должны быть найдены в соответствующем документе.

```sql
hello  world
```

Примечание: Нет явного оператора `И`.

#### Оператор ИЛИ

Логический оператор ИЛИ `|` имеет более высокий приоритет, чем И, поэтому `looking for cat | dog | mouse` означает `looking for (cat | dog | mouse)`, а не `(looking for cat) | dog | mouse`.

```sql
hello | world
```

Примечание: Нет оператора `ИЛИ`. Пожалуйста, используйте `|` вместо этого.

### Оператор МОЖЕТ БЫТЬ

```sql
hello MAYBE world
```

Оператор `МОЖЕТ БЫТЬ` работает аналогично оператору `|`, но не возвращает документы, которые соответствуют только выражению правого поддерева.

### Оператор отрицания

```sql
hello -world
hello !world
```

Оператор отрицания налагает правило, что слово не должно существовать.

Запросы, содержащие **только** отрицания, по умолчанию **не** поддерживаются. Чтобы включить, используйте параметр сервера [not_terms_only_allowed](../../Server_settings/Searchd.md#not_terms_only_allowed).

### Оператор поиска по полю

```sql
@title hello @body world
```

Оператор ограничения поля ограничивает последующий поиск указанным полем. По умолчанию запрос завершится ошибкой, если указанное имя поля не существует в searched таблице. Однако это поведение можно подавить, указав опцию `@@relaxed` в начале запроса:

```sql
@@relaxed @nosuchfield my query
```

Это может быть полезно при поиске через разнородные таблицы с различными схемами.

Ограничения позиции поля дополнительно ограничивают поиск первыми N позициями в заданном поле (или полях). Например, `@body [50] hello` не будет сопоставлять документы, где ключевое слово `hello` появляется в позиции 51 или позже в теле.

```sql
@body[50] hello
```

Оператор поиска по нескольким полям:

```sql
@(title,body) hello world
```

Оператор игнорирования поиска по полю (игнорирует любые совпадения 'hello world' из поля 'title'):

```sql
@!title hello world
```

Оператор игнорирования поиска по нескольким полям (если есть поля 'title', 'subject' и 'body', то `@!(title)` эквивалентно `@(subject,body)`):

```sql
@!(title,body) hello world
```

Оператор поиска по всем полям:

```sql
@* hello
```

### Оператор поиска фраз

```sql
"hello world"
```

Оператор фраз требует, чтобы слова были расположены рядом друг с другом.

Оператор поиска фраз может включать модификатор `сопоставление любого термина`. В операторе фразы термины имеют позиционную значимость. При использовании модификатора 'сопоставление любого' позиции последующих терминов в этом запросе фразы будут смещены. Как следствие, модификатор 'сопоставление любого' не влияет на производительность поиска.

Примечание: При использовании этого оператора с запросами, содержащими более 31 ключевого слова, статистика ранжирования (такая как `tf`, `idf`, `bm25`) для ключевых слов в позиции 31 и выше может быть недосчитана. Это связано с 32-битной маской, используемой внутренне для отслеживания вхождений терминов в совпадении. Логика сопоставления (поиск документов) остается корректной, но оценки ранжирования могут быть затронуты для очень длинных запросов.

```sql
"exact * phrase * * for terms"
```

Можно также использовать оператор ИЛИ внутри кавычек. Оператор ИЛИ (`|`) должен быть заключен в квадратные скобки `()` при использовании внутри фраз. Каждый вариант проверяется в одной позиции, и фраза совпадает, если любой из вариантов подходит к этой позиции.

**Правильные примеры** (со скобками):
```sql
"( a | b ) c"
"( ( a b c ) | d ) e"
"man ( happy | sad ) but all ( ( as good ) | ( as fast ) )"
```

**Неправильные примеры** (без скобок - они не сработают):
```sql
"a | b c"
"happy | sad"
```

### Оператор proximity-поиска

```sql
"hello world"~10
```

Proximity-расстояние измеряется в словах, учитывает количество слов и применяется ко всем словам в кавычках. Например, запрос `"cat dog mouse"~5` означает, что должен быть промежуток менее 8 слов, содержащий все 3 слова. Поэтому документ с `CAT aaa bbb ccc DOG eee fff MOUSE` не будет соответствовать этому запросу, так как промежуток составляет ровно 8 слов.

Примечание: При использовании этого оператора с запросами, содержащими более 31 ключевого слова, статистика ранжирования (такая как `tf`, `idf`, `bm25`) для ключевых слов в позиции 31 и выше может быть недосчитана. Это связано с 32-битной маской, используемой внутренне для отслеживания вхождений терминов в совпадении. Логика сопоставления (поиск документов) остается корректной, но оценки ранжирования могут быть затронуты для очень длинных запросов.

Можно также использовать оператор ИЛИ внутри proximity-поиска. Оператор ИЛИ (`|`) должен быть заключен в квадратные скобки `()` при использовании внутри proximity-поисков. Каждый вариант проверяется отдельно.

**Правильный пример** (со скобками):
```sql
"( two | four ) fish chips"~5
```

**Неправильный пример** (без скобок - это не сработает):
```sql
"two | four fish chips"~5
```

### Оператор кворум-сопоставления

```sql
"the world is a wonderful place"/3
```

Оператор кворум-сопоставления вводит тип нечеткого сопоставления. Он будет сопоставлять только те документы, которые удовлетворяют заданному порогу указанных слов. В примере выше (`"the world is a wonderful place"/3`) он будет сопоставлять все документы, содержащие по крайней мере 3 из 6 указанных слов. Оператор ограничен 255 ключевыми словами. Вместо абсолютного числа можно также указать значение от 0.0 до 1.0 (представляющее 0% и 100%), и Manticore будет сопоставлять только документы, содержащие по крайней мере указанный процент данных слов. Тот же пример выше также может быть выражен как `"the world is a wonderful place"/0.5`, и он будет сопоставлять документы не менее чем с 50% слов.

Кворум-оператор поддерживает оператор ИЛИ (`|`). Оператор ИЛИ (`|`) должен быть заключен в квадратные скобки `()` при использовании внутри кворум-сопоставления. Только одно слово из каждой группы ИЛИ учитывается при сопоставлении.

**Правильные примеры** (со скобками):
```sql
"( ( a b c ) | d ) e f g"/0.5
"happy ( sad | angry ) man"/2
```

**Неправильный пример** (без скобок - это не сработает):
```sql
"a b c | d e f g"/0.5
```

### Оператор строгого порядка

```sql
aaa << bbb << ccc
```

Оператор строгого порядка (также известный как оператор "перед") сопоставляет документ только в том случае, если ключевые слова его аргументов появляются в документе строго в порядке, указанном в запросе. Например, запрос `black << cat` будет сопоставлен с документом "black and white cat", но не с документом "that cat was black". Оператор порядка имеет самый низкий приоритет. Он может быть применен как к отдельным ключевым словам, так и к более сложным выражениям. Например, это допустимый запрос:

```sql
(bag of words) << "exact phrase" << red|green|blue
```

### Точный модификатор формы

```sql
raining =cats and =dogs
="exact phrase"
```

Ключевое слово точного модификатора формы сопоставляет документ только в том случае, если ключевое слово встречается в точно указанной форме. По умолчанию документ считается совпадающим, если стемминговое/лемматизированное ключевое слово совпадает. Например, запрос "runs" будет соответствовать как документу, содержащему "runs", так и содержащему "running", поскольку обе формы стемируются до "run". Однако запрос `=runs` будет соответствовать только первому документу. Точный модификатор формы требует включения параметра [index_exact_words](../../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words).

Другой вариант использования - предотвращение [расширения](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expand_keywords) ключевого слова до его формы `*keyword*`. Например, при `index_exact_words=1` + `expand_keywords=1/star`, `bcd` найдет документ, содержащий `abcde`, а `=bcd` - нет.

Как модификатор, влияющий на ключевое слово, он может использоваться внутри операторов, таких как фразовый, proximity и кворумный операторы. Применение точного модификатора формы к фразовому оператору возможно, и в этом случае он внутренне добавляет точный модификатор формы ко всем терминам в фразе.

### Операторы подстановки

```sql
nation* *nation* *national
```

Требует [min_infix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) для префикса (расширение в конце) и/или суффикса (расширение в начале). Если требуется только префиксация, можно использовать [min_prefix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_prefix_len).

Поиск попытается найти все расширения токенов с подстановочными знаками, и каждое расширение записывается как найденное совпадение. Количество расширений для токена можно контролировать с помощью параметра таблицы [expansion_limit](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expansion_limit). Токены с подстановочными знаками могут существенно влиять на время поиска запроса, особенно когда токены имеют небольшую длину. В таких случаях желательно использовать ограничение расширения.

Оператор подстановочных знаков может быть автоматически применен при использовании параметра таблицы [expand_keywords](../../Searching/Options.md#expand_keywords).

Кроме того, поддерживаются следующие встроенные операторы подстановочных знаков:

* `?` может соответствовать любому одному символу: `t?st` будет соответствовать `test`, но не `teast`
* `%` может соответствовать нулю или одному символу: `tes%` будет соответствовать `tes` или `test`, но не `testing`

Встроенные операторы требуют `dict=keywords` (включено по умолчанию) и включенной префиксации/инфиксации.

### Оператор REGEX

```sql
REGEX(/t.?e/)
```

Требует установки параметров [min_infix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) или [min_prefix_len](../../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_prefix_len) и [dict](../../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict)=keywords (что является настройкой по умолчанию).

Подобно [операторам подстановочных знаков](../../Searching/Full_text_matching/Operators.md#Wildcard-operators), оператор REGEX пытается найти все токены, соответствующие указанному шаблону, и каждое расширение записывается как найденное совпадение. Обратите внимание, что это может существенно повлиять на время поиска запроса, так как сканируется весь словарь, и каждый термин в словаре проходит сопоставление с шаблоном REGEX.

Шаблоны должны соответствовать синтаксису [RE2](https://github.com/google/re2/wiki/Syntax). Разделитель выражения REGEX - первый символ после открывающей скобки. Другими словами, весь текст между открывающей скобкой, за которой следует разделитель, и разделителем и закрывающей скобкой считается выражением RE2.
Обратите внимание, что термины, хранящиеся в словаре, проходят преобразование `charset_table`, что означает, например, REGEX может не суметь сопоставить прописные буквы, если все символы преобразованы в строчные согласно `charset_table` (что происходит по умолчанию). Чтобы успешно сопоставить термин с помощью выражения REGEX, шаблон должен соответствовать всему токену. Для достижения частичного сопоставления поместите `.*` в начало и/или конец вашего шаблона.

```sql
REGEX(/.{3}t/)
REGEX(/t.*\d*/)
```

### Модификатор начала и конца поля

```sql
^hello world$
```

Модификаторы ключевого слова начала и конца поля гарантируют, что ключевое слово будет соответствовать только в том случае, если оно встречается в самом начале или в самом конце полнотекстового поля соответственно. Например, запрос `"^hello world$"` (заключенный в кавычки для объединения фразового оператора с модификаторами начала/конца) будет исключительно соответствовать документам, содержащим хотя бы одно поле с этими двумя конкретными ключевыми словами.

### Модификатор усиления IDF

```sql
boosted^1.234 boostedfieldend$^1.234
```

Модификатор усиления повышает [IDF](../../Searching/Options.md#idf)_score на указанный коэффициент при вычислении оценок ранжирования, включающих IDF. Он не влияет на процесс сопоставления никоим образом.

### Оператор NEAR

```sql
hello NEAR/3 world NEAR/4 "my test"
```

Оператор `NEAR` является более обобщенной версией proximity-оператора. Его синтаксис - `NEAR/N`, который чувствителен к регистру и не допускает пробелов между ключевыми словами `NEAR`, знаком косой черты и значением расстояния.

Если исходный proximity-оператор работает только с наборами ключевых слов, `NEAR` является более универсальным и может принимать произвольные подвыражения в качестве своих двух аргументов. Он сопоставляет документ, когда оба подвыражения находятся в пределах N слов друг от друга, независимо от их порядка. `NEAR` левоассоциативен и имеет такой же (самый низкий) приоритет, как и [BEFORE](../../Searching/Full_text_matching/Operators.md#Strict-order-operator).

Важно отметить, что `one NEAR/7 two NEAR/7 three` не совсем эквивалентен `"one two three"~7`. Ключевое различие заключается в том, что proximity-оператор допускает до 6 несовпадающих слов между всеми тремя совпадающими словами, в то время как версия с `NEAR` менее ограничительна: она допускает до 6 слов между `one` и `two`, а затем еще до 6 между этим двухсловным совпадением и `three`.

Примечание: При использовании этого оператора в запросах, содержащих более 31 ключевого слова, статистика ранжирования (такая как `tf`, `idf`, `bm25`) для ключевых слов в позиции 31 и выше может быть занижена. Это связано с 32-битной маской, используемой внутренне для отслеживания вхождений терминов в совпадении. Логика сопоставления (поиск документов) остается корректной, но оценки ранжирования могут быть затронуты для очень длинных запросов.

### Оператор NOTNEAR

```sql
Church NOTNEAR/3 street
```
Оператор `NOTNEAR` служит для отрицательного утверждения. Он находит документ, когда левый аргумент присутствует, а правый аргумент либо отсутствует в документе, либо находится на указанном расстоянии от конца левого совпавшего аргумента. Расстояние указывается в словах. Синтаксис — `NOTNEAR/N`, который чувствителен к регистру и не допускает пробелов между ключевым словом `NOTNEAR`, знаком косой черты и значением расстояния. Оба аргумента этого оператора могут быть терминами, операторами или группами операторов.

### Операторы SENTENCE и PARAGRAPH

```sql
all SENTENCE words SENTENCE "in one sentence"
```


```sql
"Bill Gates" PARAGRAPH "Steve Jobs"
```
Операторы `SENTENCE` и `PARAGRAPH` находят документ, когда оба их аргумента находятся в одном предложении или в одном абзаце текста соответственно. Этими аргументами могут быть ключевые слова, фразы или экземпляры того же оператора.

Порядок аргументов внутри предложения или абзаца не имеет значения. Эти операторы работают только с таблицами, построенными с включенной функцией [index_sp](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_sp) (индексирование предложений и абзацев), в противном случае они вырождаются в простую операцию И. Информацию о том, что считается предложением и абзацем, см. в документации по директиве [index_sp](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_sp).


### Оператор ограничения зоны

```sql
ZONE:(h3,h4)

only in these titles
```

Оператор `ZONE limit` очень похож на оператор ограничения поля, но ограничивает сопоставление указанной зоной внутри поля или списком зон. Важно отметить, что последующие подвыражения не обязательно должны совпадать в пределах одного непрерывного участка данной зоны и могут совпадать в разных участках. Например, запрос `(ZONE:th hello world)` найдет следующий образец документа:

```html
<th>Table 1. Local awareness of Hello Kitty brand.</th>
.. some table data goes here ..
<th>Table 2. World-wide brand awareness.</th>
```

Оператор `ZONE` влияет на запрос до следующего оператора ограничения поля или зоны либо до закрывающей скобки. Он работает исключительно с таблицами, построенными с поддержкой зон (см. [index_zones](../../Creating_a_table/NLP_and_tokenization/Advanced_HTML_tokenization.md#index_zones)), в противном случае будет проигнорирован.

### Оператор ограничения ZONESPAN

```sql
ZONESPAN:(h2)

only in a (single) title
```

Оператор `ZONESPAN limit` похож на оператор `ZONE`, но требует, чтобы совпадение происходило в пределах одного непрерывного участка. В приведенном ранее примере `ZONESPAN:th hello world` не найдет документ, поскольку слова "hello" и "world" не находятся в одном участке.

<!-- proofread -->

