# Параметры поиска

SQL-предложение [SELECT](../Searching/Full_text_matching/Basic_usage.md#SQL) и HTTP-эндпоинт [/search](../Searching/Full_text_matching/Basic_usage.md#HTTP-JSON) поддерживают ряд опций, которые можно использовать для тонкой настройки поведения поиска.

## OPTION

### Общий синтаксис

<!-- example options -->

**SQL**:

```sql
SELECT ... [OPTION <optionname>=<value> [ , ... ]] [/*+ [NO_][ColumnarScan|DocidIndex|SecondaryIndex(<attribute>[,...])]] /*]
```

**HTTP**:
```json
POST /search
{
    "table" : "table_name",
    "options":
    {
        "optionname": "value",
        "optionname2": <value2>
    }
}
```


<!-- intro -->
SQL:
<!-- request SQL -->
```sql
SELECT * FROM test WHERE MATCH('@title hello @body world')
OPTION ranker=bm25, max_matches=3000,
field_weights=(title=10, body=3), agent_query_timeout=10000
```

<!-- response SQL -->
```sql
+------+-------+-------+
| id   | title | body  |
+------+-------+-------+
|    1 | hello | world |
+------+-------+-------+
1 row in set (0.00 sec)
```

<!-- intro -->
JSON:
<!-- request JSON -->

```json
POST /search
{
    "table" : "test",
    "query": {
      "match": {
        "title": "hello"
      },
      "match": {
        "body": "world"
      }
    },
    "options":
    {
        "ranker": "bm25",
        "max_matches": 3000,
        "field_weights": {
            "title": 10,
            "body": 3
        },
        "agent_query_timeout": 10000
    }
}
```

<!-- response JSON -->

```json
{
  "took": 0,
  "timed_out": false,
  "hits": {
    "total": 1,
    "total_relation": "eq",
    "hits": [
      {
        "_id": 1,
        "_score": 10500,
        "_source": {
          "title": "hello",
          "body": "world"
        }
      }
    ]
  }
}
```

<!-- end -->

Поддерживаемые опции:

### accurate_aggregation
Целое число. Включает или отключает гарантированную точность агрегации при выполнении групповых запросов в нескольких потоках. По умолчанию 0.

При выполнении группового запроса он может выполняться параллельно на обычной таблице с несколькими псевдошардами (если включен `pseudo_sharding`). Аналогичный подход работает на RT-таблицах. Каждый шард/чанк выполняет запрос, но количество групп ограничено `max_matches`. Если результирующие наборы из разных шардов/чанков содержат разные группы, подсчет групп и агрегаты могут быть неточными. Обратите внимание, что Manticore пытается увеличить `max_matches` до [`max_matches_increase_threshold`](../Searching/Options.md#max_matches_increase_threshold) на основе количества уникальных значений группирующего атрибута (полученных из вторичных индексов). Если это удается, потери точности не будет.

Однако, если количество уникальных значений группирующего атрибута велико, дальнейшее увеличение `max_matches` может быть не лучшей стратегией, так как это может привести к потере производительности и увеличению использования памяти. Установка `accurate_aggregation` в 1 заставляет групповые поиски выполняться в одном потоке, что решает проблему точности. Обратите внимание, что выполнение в одном потоке применяется только тогда, когда `max_matches` не может быть установлен достаточно высоким; в противном случае поиски с `accurate_aggregation=1` все равно будут выполняться в нескольких потоках.

В целом, установка `accurate_aggregation` в 1 гарантирует точность подсчета групп и агрегатов в RT-таблицах и обычных таблицах с `pseudo_sharding=1`. Недостаток в том, что поиски будут выполняться медленнее, так как они будут вынуждены работать в одном потоке.

Однако, если у нас есть RT-таблица и обычная таблица, содержащие одни и те же данные, и мы выполняем запрос с `accurate_aggregation=1`, мы все равно можем получить разные результаты. Это происходит потому, что демон может выбрать разные настройки `max_matches` для RT-таблицы и обычной таблицы из-за настройки [`max_matches_increase_threshold`](../Searching/Options.md#max_matches_increase_threshold).

### agent_query_timeout
Целое число. Максимальное время в миллисекундах ожидания завершения удаленных запросов, см. [этот раздел](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_query_timeout).

### boolean_simplify
`0` или `1` (по умолчанию `1`). `boolean_simplify=1` включает [упрощение запроса](../Searching/Full_text_matching/Boolean_optimization.md) для ускорения его выполнения.

Эта опция также может быть установлена глобально в [конфигурации searchd](../Server_settings/Searchd.md#boolean_simplify) для изменения поведения по умолчанию для всех запросов. Опция на уровне запроса переопределит глобальную настройку.

### comment
Строка, пользовательский комментарий, который копируется в файл журнала запросов.

### cutoff
Целое число. Определяет максимальное количество совпадений для обработки. Если не установлено, Manticore автоматически выберет подходящее значение.

<!-- example cutoff_aggregation -->

* `N = 0`: Отключает ограничение на количество совпадений.
* `N > 0`: Указывает Manticore остановить обработку результатов, как только будет найдено `N` соответствующих документов.
* Не установлено: Manticore определяет порог автоматически.

Когда Manticore не может определить точное количество соответствующих документов, поле `total_relation` в [метаинформации](../Node_info_and_management/SHOW_META.md#SHOW-META) запроса будет показывать `gte`, что означает **Больше или Равно**. Это указывает, что фактическое количество совпадений составляет по меньшей мере указанное `total_found` (в SQL) или `hits.total` (в JSON). Когда количество точное, `total_relation` будет отображать `eq`.

Примечание: Использование `cutoff` в агрегационных запросах не рекомендуется, так как это может привести к неточным или неполным результатам.

<!-- request Example -->

Использование `cutoff` в агрегационных запросах может привести к некорректным или вводящим в заблуждение результатам, как показано в следующем примере:
```
drop table if exists t
--------------

Query OK, 0 rows affected (0.02 sec)

--------------
create table t(a int)
--------------

Query OK, 0 rows affected (0.04 sec)

--------------
insert into t(a) values(1),(2),(3),(1),(2),(3)
--------------

Query OK, 6 rows affected (0.00 sec)

--------------
select avg(a) from t option cutoff=1 facet a
--------------

+----------+
| avg(a)   |
+----------+
| 1.000000 |
+----------+
1 row in set (0.00 sec)
--- 1 out of 1 results in 0ms ---

+------+----------+
| a    | count(*) |
+------+----------+
|    1 |        1 |
+------+----------+
1 row in set (0.00 sec)
--- 1 out of 1 results in 0ms ---
```

Сравните с тем же запросом без `cutoff`:
```
--------------
select avg(a) from t facet a
--------------

+----------+
| avg(a)   |
+----------+
| 2.000000 |
+----------+
1 row in set (0.00 sec)
--- 1 out of 1 results in 0ms ---

+------+----------+
| a    | count(*) |
+------+----------+
|    1 |        2 |
|    2 |        2 |
|    3 |        2 |
+------+----------+
3 rows in set (0.00 sec)
--- 3 out of 3 results in 0ms ---
```

<!-- end -->

### distinct_precision_threshold
Целое число. По умолчанию `3500`. Эта опция устанавливает порог, ниже которого количества, возвращаемые `count distinct`, гарантированно точны в пределах обычной таблицы.

Допустимые значения в диапазоне от `500` до `15500`. Значения вне этого диапазона будут ограничены.

Когда эта опция установлена в 0, включается алгоритм, гарантирующий точные подсчеты. Этот алгоритм собирает пары `{группа, значение}`, сортирует их и периодически удаляет дубликаты. Результат — точные подсчеты в пределах обычной таблицы. Однако этот подход не подходит для наборов данных с высокой кардинальностью из-за высокого потребления памяти и медленного выполнения запроса.

Когда `distinct_precision_threshold` установлен в значение больше `0`, Manticore использует другой алгоритм. Он загружает подсчеты в хеш-таблицу и возвращает размер таблицы. Если хеш-таблица становится слишком большой, ее содержимое перемещается в структуру данных `HyperLogLog`. На этом этапе подсчеты становятся приблизительными, поскольку HyperLogLog — это вероятностный алгоритм. Этот подход поддерживает фиксированное максимальное использование памяти на группу, но есть компромисс в точности подсчетов.

Точность `HyperLogLog` и порог преобразования из хеш-таблицы в HyperLogLog определяются настройкой `distinct_precision_threshold`. Важно использовать эту опцию с осторожностью, поскольку удвоение ее значения также удвоит максимальный объем памяти, необходимый для вычисления подсчетов. Максимальное использование памяти можно приблизительно оценить по формуле: `64 * max_matches * distinct_precision_threshold`, хотя на практике вычисления подсчетов часто используют меньше памяти, чем в худшем случае.

### expand_keywords
`0` или `1` (по умолчанию `0`). Расширяет ключевые слова точными формами и/или звёздочками, если это возможно. Подробности смотрите в [expand_keywords](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expand_keywords).

### field_weights
Именованный список целых чисел (веса пользователя для ранжирования по полям).

Пример:
```sql
SELECT ... OPTION field_weights=(title=10, body=3)
```

### global_idf
Использовать глобальную статистику (частоты) из файла [global_idf](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#global_idf) для вычислений IDF.

### idf
Кавычками, через запятую перечисленные флаги вычисления IDF. Известные флаги:

* `normalized`: вариант BM25, idf = log((N-n+1)/n), согласно Robertson et al
* `plain`: простой вариант, idf = log(N/n), согласно Sparck-Jones
* `tfidf_normalized`: дополнительно делить IDF на количество слов запроса, чтобы `TF*IDF` находился в диапазоне [0, 1]
* `tfidf_unnormalized`: не делить дополнительно IDF на количество слов запроса, где N — размер коллекции, а n — количество совпадающих документов

Исторически используемый по умолчанию IDF (обратная частота документа) в Manticore эквивалентен `OPTION idf='normalized,tfidf_normalized'`, и эти нормализации могут вызывать несколько нежелательных эффектов.

Во-первых, `idf=normalized` приводит к штрафованию ключевых слов. Например, если вы ищете `the | something` и `the` встречается более чем в 50% документов, тогда документы с двумя ключевыми словами `the` и `something` будут иметь меньший вес, чем документы с одним ключевым словом `something`. Использование `OPTION idf=plain` это избегает. Простой IDF варьируется в диапазоне `[0, log(N)]`, и ключевые слова никогда не штрафуются; а нормализованный IDF варьируется в диапазоне `[-log(N), log(N)]`, и слишком частотные ключевые слова штрафуются.

Во-вторых, `idf=tfidf_normalized` приводит к дрейфу IDF между запросами. Исторически IDF также делился на количество ключевых слов в запросе, гарантируя, что сумма по всем ключевым словам `sum(tf*idf)` оставалась в диапазоне [0,1]. Однако это означало, что запросы, например, `word1` и `word1 | nonmatchingword2` присваивали разный вес абсолютно одинаковому множеству результатов, так как IDF для обоих слов делилось на 2. Использование `OPTION idf='tfidf_unnormalized'` решает эту проблему. Имейте в виду, что факторы ранжирования BM25, BM25A, BM25F() будут соответственно скорректированы при отключении этой нормализации.

Флаги IDF могут комбинироваться; `plain` и `normalized` взаимоисключающие; `tfidf_unnormalized` и `tfidf_normalized` также взаимоисключающие; неуказанные флаги в таких взаимоисключающих группах принимают значения по умолчанию. Это означает, что `OPTION idf=plain` эквивалентен полному указанию `OPTION idf='plain,tfidf_normalized'`.

### jieba_mode
Задает режим сегментации Jieba для запроса.

При использовании китайской сегментации Jieba иногда полезно применять разные режимы сегментации для токенизации документов и запроса. Полный список режимов смотрите в [jieba_mode](../Creating_a_table/NLP_and_tokenization/Morphology.md#jieba_mode).

### index_weights
Именованный список целых чисел. Веса пользователя для ранжирования по таблицам.

### local_df
`0` или `1`, автоматически суммирует DFs по всем локальным частям распределенной таблицы, обеспечивая согласованный (и точный) IDF для локально шардированной таблицы. По умолчанию включено для дисковых частей RT-таблицы. Термины запроса со звёздочками игнорируются.

### low_priority
`0` или `1` (по умолчанию `0`). Установка `low_priority=1` выполняет запрос с более низким приоритетом, пересматривая задания для него в 10 раз реже, чем для запросов с обычным приоритетом.

### max_matches
Целое число. Максимальное количество совпадений, сохраняемых для каждого запроса.

Максимальное количество совпадений, которые сервер сохраняет в ОЗУ для каждой таблицы и может вернуть клиенту. По умолчанию 1000.

Введено для контроля и ограничения использования ОЗУ, настройка `max_matches` определяет, сколько совпадений будет храниться в ОЗУ при поиске по каждой таблице. Все найденные совпадения обрабатываются, но в память сохраняются и в итоге клиенту возвращаются только лучшие N из них. Например, предположим, что таблица содержит 2 000 000 совпадений для запроса. Редко бывает нужным получить их все. Вместо этого нужно просмотреть все совпадения, но выбрать «лучшие» 500, например, по какому-то критерию (сортировка по релевантности, цене или другим факторам), и показать во всплывающих страницах для пользователя по 20–100 совпадений. Отслеживание только лучших 500 совпадений гораздо эффективнее с точки зрения ОЗУ и ЦП, чем хранение всех 2 000 000, сортировка и затем отбрасывание всего, кроме первых 20 для страницы результатов поиска. Параметр `max_matches` контролирует количество N в этом «лучшие N».

Этот параметр существенно влияет на использование ОЗУ и ЦП для каждого запроса. Обычно приемлемы значения от 1000 до 10000, но более высокие лимиты следует использовать с осторожностью. Небрежное увелечение max_matches до 1 000 000 означает, что `searchd` потребуется выделить и инициализировать буфер совпадений с 1 миллионом записей для каждого запроса. Это неизбежно увеличит использование ОЗУ на запрос и, в некоторых случаях, может заметно повлиять на производительность.

Дополнительную информацию о влиянии параметра `max_matches` смотрите в [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold).

### max_matches_increase_threshold

Целое число. Устанавливает порог, до которого можно увеличить `max_matches`. По умолчанию 16384.

Manticore может увеличить `max_matches` для повышения точности группировки и/или агрегации при включенном `pseudo_sharding`, если обнаружено, что количество уникальных значений атрибута группировки меньше этого порога. Потеря точности может произойти при выполнении запроса в нескольких потоках через псевдо-шардинг или при параллельном поиске в дисковых частях RT-таблицы.

Если количество уникальных значений атрибута группировки меньше порога, `max_matches` будет установлено в это значение. В противном случае будет использовано значение `max_matches` по умолчанию.

Если `max_matches` был явно задан в опциях запроса, этот порог не действует.

Имейте в виду, что слишком высокое значение этого порога приведет к увеличению потребления памяти и общему снижению производительности.

Вы также можете применить режим гарантированной точности группировки/агрегации с помощью опции [accurate_aggregation](../Searching/Options.md#accurate_aggregation).

### max_query_time
Устанавливает максимальное время выполнения поискового запроса в миллисекундах. Должно быть неотрицательным целым числом. Значение по умолчанию — 0, что означает «не ограничиваться». Локальные поисковые запросы будут прерваны после истечения заданного времени. Обратите внимание, что если вы выполняете поиск, обращающийся к нескольким локальным таблицам, это ограничение применяется к каждой таблице отдельно. Будьте готовы к тому, что это может немного увеличить время отклика запроса из-за накладных расходов, связанных с постоянным отслеживанием момента, когда нужно остановить запрос.

### max_predicted_time
Целое число. Максимальное прогнозируемое время поиска; смотрите [predicted_time_costs](../Server_settings/Searchd.md#predicted_time_costs).

### morphology
`none` позволяет заменять все термины запроса их точными формами, если таблица была создана с включённой опцией [index_exact_words](../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words). Это полезно для предотвращения стемминга или лемматизации терминов запроса.

### not_terms_only_allowed
<!-- example not_terms_only_allowed -->
`0` или `1` разрешает самостоятельное [отрицание](../Searching/Full_text_matching/Operators.md#Negation-operator) для запроса. Значение по умолчанию — 0. См. также соответствующую [глобальную настройку](../Server_settings/Searchd.md#not_terms_only_allowed).

<!-- request SQL -->
```sql
MySQL [(none)]> select * from tbl where match('-donald');
ERROR 1064 (42000): index t: query error: query is non-computable (single NOT operator)
MySQL [(none)]> select * from t where match('-donald') option not_terms_only_allowed=1;
+---------------------+-----------+
| id                  | field     |
+---------------------+-----------+
| 1658178727135150081 | smth else |
+---------------------+-----------+
```
<!-- end -->

### ranker
Выберите один из следующих вариантов:
* `proximity_bm25`
* `bm25`
* `none`
* `wordcount`
* `proximity`
* `matchany`
* `fieldmask`
* `sph04`
* `expr`
* `export`

Подробнее о каждом ранжировщике смотрите в разделе [Ранжирование результатов поиска](../Searching/Sorting_and_ranking.md#Available-built-in-rankers).

### rand_seed
Позволяет указать конкретное значение начального «семени» для запроса `ORDER BY RAND()`, например: `... OPTION rand_seed=1234`. По умолчанию для каждого запроса автоматически создаётся новое иное значение.

### retry_count
Целое число. Количество повторных попыток в распределённом режиме.

### retry_delay
Целое число. Задержка между попытками в распределённом режиме, в миллисекундах.

### scroll

Строка. Токен scroll для поэтапного получения результатов с помощью [Scroll pagination approach](../Searching/Pagination.md#Scroll-Search-Option).

### sort_method
* `pq` - очередь с приоритетом, используется по умолчанию
* `kbuffer` - обеспечивает более быструю сортировку для уже частично отсортированных данных, например, для данных таблицы, отсортированных по id
Набор результатов в обоих случаях одинаков; выбор одного из вариантов может лишь улучшить (или ухудшить) производительность.

### threads
Ограничивает максимальное число потоков, используемых для обработки текущего запроса. По умолчанию — без ограничений (запрос может использовать все [потоки](../Server_settings/Searchd.md#threads), установленные глобально).
Для пакета запросов опция должна быть применена к первому запросу в пакете, после чего она применяется при создании рабочей очереди и действует на весь пакет. Эта опция эквивалентна опции [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query), но применяется только к текущему запросу или пакету запросов.

### token_filter
Значение в кавычках, строка с разделителем двоеточием в формате `имя_библиотеки:имя_плагина:необязательная_строка_настроек`. При вызове полнотекстового поиска для каждой задействованной таблицы создаётся фильтр токенов в режиме выполнения запроса, что позволяет реализовать собственный токенизатор, генерирующий токены по пользовательским правилам.
```sql
SELECT * FROM index WHERE MATCH ('yes@no') OPTION token_filter='mylib.so:blend:@'
```
### expansion_limit
Ограничивает максимальное число расширенных ключевых слов для одного подстановочного знака, по умолчанию 0 означает отсутствие ограничений. Дополнительную информацию см. в разделе [expansion_limit](../Server_settings/Searchd.md#expansion_limit).

## Подсказки оптимизатора запросов

<!-- example options_force -->

В редких случаях встроенный анализатор запросов Manticore может ошибочно интерпретировать запрос и определить, следует ли использовать индекс docid, вторичные индексы или посколонный скан. Чтобы переопределить решения оптимизатора запросов, можно использовать следующие подсказки в вашем запросе:

* `/*+ DocidIndex(id) */` — принудительно использовать индекс docid, `/*+ NO_DocidIndex(id) */` — указать оптимизатору игнорировать его
* `/*+ SecondaryIndex(<attr_name1>[, <attr_nameN>]) */` — принудительно использовать вторичный индекс (если доступен), `/*+ NO_SecondaryIndex(id) */` — указать оптимизатору игнорировать его
* `/*+ ColumnarScan(<attr_name1>[, <attr_nameN>]) */` — принудительно использовать посколонный скан (если атрибут колонный), `/*+ NO_ColumnarScan(id) */` — указать оптимизатору игнорировать его

Обратите внимание, что при выполнении полнотекстового запроса с фильтрами оптимизатор запроса выбирает между пересечением результатов полнотекстового дерева с результатами фильтра или стандартным подходом «сначала совпадение, затем фильтр». Указание *любой* подсказки заставит демон использовать путь кода, который выполняет пересечение результатов полнотекстового дерева с фильтрующими результатами.

Подробнее о работе оптимизатора запросов смотрите на странице [Оптимизатор на основе стоимости](../Searching/Cost_based_optimizer.md).

<!-- request SQL -->

```sql
SELECT * FROM students where age > 21 /*+ SecondaryIndex(age) */
```

<!-- end -->

<!-- example comments -->
При использовании клиента MySQL/MariaDB не забудьте включить флаг `--comments`, чтобы подсказки были активны в ваших запросах.

<!-- request mysql -->
```bash
mysql -P9306 -h0 --comments
```
<!-- end -->

<!-- proofread -->

