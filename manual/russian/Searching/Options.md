# Опции поиска

Условие SQL [SELECT](../Searching/Full_text_matching/Basic_usage.md#SQL) и конечная точка HTTP [/search](../Searching/Full_text_matching/Basic_usage.md#HTTP-JSON) поддерживают ряд опций, которые могут быть использованы для уточнения поведения поиска.

## ОПЦИЯ

### Общий синтаксис

<!-- пример опций -->

**SQL**:

```sql
SELECT ... [OPTION <optionname>=<value> [ , ... ]] [/*+ [NO_][ColumnarScan|DocidIndex|SecondaryIndex(<attribute>[,...])]] /*]
```

**HTTP**:
```json
POST /search
{   
    "table" : "table_name",
    "options":   
    {
        "optionname": "value",
        "optionname2": <value2>
    }
}
```


<!-- ввод -->
SQL:
<!-- запрос SQL -->
```sql
SELECT * FROM test WHERE MATCH('@title hello @body world')
OPTION ranker=bm25, max_matches=3000,
field_weights=(title=10, body=3), agent_query_timeout=10000
```

<!-- ответ SQL -->
```sql
+------+-------+-------+
| id   | title | body  |
+------+-------+-------+
|    1 | hello | world |
+------+-------+-------+
1 row in set (0.00 sec)
```

<!-- ввод -->
JSON:
<!-- запрос JSON -->

```json
POST /search
{   
    "table" : "test",
    "query": {
      "match": {
        "title": "hello"
      },
      "match": {
        "body": "world"     
      }
    },
    "options":   
    {
        "ranker": "bm25",
        "max_matches": 3000,
        "field_weights": {
            "title": 10,
            "body": 3
        },
        "agent_query_timeout": 10000
    }
}
```

<!-- ответ JSON -->

```json
{
  "took": 0,
  "timed_out": false,
  "hits": {
    "total": 1,
    "total_relation": "eq",
    "hits": [
      {
        "_id": 1,
        "_score": 10500,
        "_source": {
          "title": "hello",
          "body": "world"
        }
      }
    ]
  }
}
```

<!-- конец -->

Поддерживаемые опции:

### accurate_aggregation
Целое число. Включает или отключает гарантированную агрегатную точность при выполнении запросов groupby в нескольких потоках. По умолчанию 0.

При выполнении запроса groupby он может быть выполнен параллельно на обычной таблице с несколькими псевдо-шардами (если `pseudo_sharding` включен). Похожий подход работает для RT таблиц. Каждый шард/часть выполняет запрос, но количество групп ограничено `max_matches`. Если наборы результатов из различных шардов/частей имеют разные группы, количество групп и агрегаты могут быть неточными. Обратите внимание, что Manticore пытается увеличить `max_matches` до [ `max_matches_increase_threshold`](../Searching/Options.md#max_matches_increase_threshold) на основе количества уникальных значений атрибута groupby (полученного из вторичных индексов). Если это удастся, потерь в точности не будет.

Однако, если количество уникальных значений атрибута groupby велико, дальнейшее увеличение `max_matches` может быть не лучшей стратегией, так как это может привести к потере производительности и большему потреблению памяти. Установка `accurate_aggregation` в 1 заставляет поиски groupby выполняться в одном потоке, что исправляет проблему с точностью. Обратите внимание, что выполнение в одном потоке применяется только тогда, когда `max_matches` не может быть установлен высоко; в противном случае поиски с `accurate_aggregation=1` все равно будут выполняться в нескольких потоках.

В целом, установка `accurate_aggregation` в 1 обеспечивает точность количества групп и агрегатов в RT таблицах и обычных таблицах с `pseudo_sharding=1`. Недостаток этого заключается в том, что поиски будут выполняться медленнее, поскольку они будут вынуждены работать в одном потоке.

Однако, если у нас есть RT таблица и обычная таблица, содержащие одни и те же данные, и мы выполняем запрос с `accurate_aggregation=1`, мы все равно можем получить разные результаты. Это происходит потому, что демон может выбрать разные настройки `max_matches` для RT и обычной таблицы из-за настройки [`max_matches_increase_threshold`](../Searching/Options.md#max_matches_increase_threshold).

### agent_query_timeout
Целое число. Максимальное время в миллисекундах ожидания завершения удаленных запросов, см. [этот раздел](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_query_timeout).

### boolean_simplify
`0` или `1` (`1` по умолчанию). `boolean_simplify=1` включает [упрощение запроса](../Searching/Full_text_matching/Boolean_optimization.md) для его ускорения.

### comment
Строка, пользовательский комментарий, который копируется в файл журнала запросов.

### cutoff
Целое число. Указывает максимальное количество найденных совпадений для обработки. Если не указано, Manticore автоматически выберет подходящее значение.

<!-- пример cutoff_aggregation -->

* `N = 0`: Отключает ограничение на количество совпадений.
* `N > 0`: Дает указание Manticore остановить обработку результатов, как только он найдет `N` совпадающих документов.
* Не установлено: Manticore автоматически решает порог.

Когда Manticore не может определить точное количество совпадающих документов, поле `total_relation` в [метаинформации запроса](../Node_info_and_management/SHOW_META.md#SHOW-META) покажет `gte`, что означает **Больше или Равно**. Это указывает на то, что фактическое количество совпадений составляет не менее указанного `total_found` (в SQL) или `hits.total` (в JSON). Когда количество точное, `total_relation` будет отображать `eq`.

Примечание: Использовать `cutoff` в агрегатных запросах не рекомендуется, так как это может привести к неточным или неполным результатам.

<!-- запрос Пример -->

Использование `cutoff` в агрегатных запросах может привести к неправильным или вводящим в заблуждение результатам, как показано в следующем примере:
```
drop table if exists t
--------------

Query OK, 0 rows affected (0.02 sec)

--------------
create table t(a int)
--------------

Query OK, 0 rows affected (0.04 sec)

--------------
insert into t(a) values(1),(2),(3),(1),(2),(3)
--------------

Query OK, 6 rows affected (0.00 sec)

--------------
select avg(a) from t option cutoff=1 facet a
--------------

+----------+
| avg(a)   |
+----------+
| 1.000000 |
+----------+
1 row in set (0.00 sec)
--- 1 out of 1 results in 0ms ---

+------+----------+
| a    | count(*) |
+------+----------+
|    1 |        1 |
+------+----------+
1 row in set (0.00 sec)
--- 1 out of 1 results in 0ms ---
```

Сравните с тем же запросом без `cutoff`:
```
--------------
select avg(a) from t facet a
--------------

+----------+
| avg(a)   |
+----------+
| 2.000000 |
+----------+
1 row in set (0.00 sec)
--- 1 out of 1 results in 0ms ---

+------+----------+
| a    | count(*) |
+------+----------+
|    1 |        2 |
|    2 |        2 |
|    3 |        2 |
+------+----------+
3 rows in set (0.00 sec)
--- 3 out of 3 results in 0ms ---
```

<!-- end -->

### distinct_precision_threshold
Целое число. По умолчанию `3500`. Эта опция устанавливает порог, ниже которого количество, возвращаемое `count distinct`, гарантировано будет точным в простой таблице.

Допустимые значения варьируются от `500` до `15500`. Значения вне этого диапазона будут ограничены.

Когда эта опция установлена в 0, она включает алгоритм, который обеспечивает точные подсчеты. Этот алгоритм собирает пары `{group, value}`, сортирует их и периодически исключает дубликаты. Результат - точные подсчеты в простой таблице. Однако этот подход не подходит для наборов данных с высокой кардинальностью из-за высокого потребления памяти и медленного выполнения запросов.

Когда `distinct_precision_threshold` установлен на значение больше 0, Manticore использует другой алгоритм. Он загружает подсчеты в хэш-таблицу и возвращает размер таблицы. Если хэш-таблица становится слишком большой, ее содержимое перемещается в структуру данных `HyperLogLog`. В этот момент подсчеты становятся приблизительными, поскольку HyperLogLog является вероятностным алгоритмом. Этот подход поддерживает фиксированное максимальное использование памяти на группу, но это связано с компромиссом в точности подсчета.

Точность `HyperLogLog` и порог для преобразования из хэш-таблицы в HyperLogLog выводятся из настройки `distinct_precision_threshold`. Важно использовать эту опцию с осторожностью, так как удвоение ее значения также удвоит максимальную память, необходимую для вычисления подсчетов. Максимальное использование памяти можно приблизительно оценить по этой формуле: `64 * max_matches * distinct_precision_threshold`, хотя на практике вычисления подсчетов часто используют меньше памяти, чем в случае наихудшего сценария.

### expand_keywords
`0` или `1` (`0` по умолчанию). Расширяет ключевые слова с точными формами и/или символами звездочки, когда это возможно. Дополнительные сведения см. в [expand_keywords](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expand_keywords).

### field_weights
Именованный список целых чисел (веса пользователя по полям для ранжирования).

Пример:
```sql
SELECT ... OPTION field_weights=(title=10, body=3)
```

### global_idf
Использовать глобальную статистику (частоты) из файла [global_idf](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#global_idf) для вычислений IDF.

### idf
Цитируемый, разделенный запятыми список флагов вычисления IDF. Известные флаги:

* `normalized`: вариант BM25, idf = log((N-n+1)/n), согласно Робертсону и др.
* `plain`: простой вариант, idf = log(N/n), согласно Спарк-Джонс.
* `tfidf_normalized`: дополнительно делить IDF на количество слов в запросе, чтобы `TF*IDF` вписывался в диапазон [0, 1].
* `tfidf_unnormalized`: не дополнительно делить IDF на количество слов в запросе, где N - размер коллекции, а n - количество совпавших документов.

Исторически, значение IDF (Inverse Document Frequency) по умолчанию в Manticore эквивалентно `OPTION idf='normalized,tfidf_normalized'`, и эти нормализации могут вызывать несколько нежелательных эффектов.

Во-первых, `idf=normalized` вызывает штраф за ключевые слова. Например, если вы ищете `the | something` и `the` встречается более чем в 50% документов, тогда документы с обоими ключевыми словами `the` и `something` получат меньший вес, чем документы с только одним ключевым словом `something`. Использование `OPTION idf=plain` позволяет избежать этого. Простой IDF варьируется в диапазоне `[0, log(N)]`, и ключевые слова никогда не подвергаются штрафу; в то время как нормализованный IDF варьируется в диапазоне `[-log(N), log(N)]`, и слишком частые ключевые слова подвергаются штрафу.

Во-вторых, `idf=tfidf_normalized` приводит к сдвигу IDF по запросам.Исторически IDF также делили на количество ключевых слов запроса, обеспечивая, что вся `sum(tf*idf)` по всем ключевым словам оставалась в диапазоне [0,1]. Однако это означало, что запросы, такие как `word1` и `word1 | nonmatchingword2`, будут присваивать разные веса точно для одного и того же результирующего набора, так как IDF для `word1` и `nonmatchingword2` будут делиться на 2. Использование `OPTION idf='tfidf_unnormalized'` решает эту проблему. Имейте в виду, что факторы ранжирования BM25, BM25A, BM25F() будут соответственно скорректированы, когда вы отключаете эту нормализацию.

Флаги IDF могут быть объединены; `plain` и `normalized` являются взаимоисключающими; `tfidf_unnormalized` и `tfidf_normalized` также являются взаимоисключающими; и не указанные флаги в таких взаимосключающих группах по умолчанию принимают свои оригинальные настройки. Это означает, что `OPTION idf=plain` эквивалентно тому, чтобы указать `OPTION idf='plain,tfidf_normalized'` целиком.

### jieba_mode
Указывает режим сегментации Jieba для запроса.

При использовании сегментации на китайском языке Jieba иногда может помочь использовать разные режимы сегментации для токенизации документов и запроса. Для полного списка режимов см. [jieba_mode](Creating_a_table/NLP_and_tokenization/Morphology.md#jieba_mode).

### index_weights
Именованный список целых чисел. Веса пользователя по таблице для ранжирования.

### local_df
`0` или `1`, автоматически суммирует DF по всем локальным частям распределенной таблицы, обеспечивая согласованный (и точный) IDF в локально разбиенных таблицах. Включено по умолчанию для дисковых фрагментов таблицы RT. Условия запроса с подстановочными знаками игнорируются.

### low_priority
`0` или `1` (`0` по умолчанию). Установка `low_priority=1` выполняет запрос с более низким приоритетом, пересоздавая его задачи в 10 раз реже, чем другие запросы с нормальным приоритетом.

### max_matches
Целое число. Максимальное значение совпадений на запрос.

Максимальное количество совпадений, которые сервер сохраняет в оперативной памяти для каждой таблицы и может вернуть клиенту. По умолчанию - 1000.

Введено для контроля и ограничения использования оперативной памяти, настройка `max_matches` определяет, сколько совпадений будет храниться в оперативной памяти при поиске в каждой таблице. Каждое найденное совпадение все равно обрабатывается, но в памяти будут оставлены только лучшие N из них, которые будут возвращены клиенту в конце. Например, предположим, что в таблице содержится 2 000 000 совпадений для запроса. Редко бывает необходимость извлекать их все. Вместо этого вам необходимо просканировать все, но выбрать только "лучшие" 500, например, на основе каких-либо критериев (например, сортировка по релевантности, цене или другим факторам) и отобразить эти 500 совпадений конечному пользователю по страницам от 20 до 100 совпадений. Отслеживание только 500 лучших совпадений гораздо эффективнее как по использованию оперативной памяти, так и по времени ЦП, чем хранение всех 2 000 000 совпадений, их сортировка, а затем выбывание всего, кроме первых 20, необходимых для страницы результатов поиска. `max_matches` управляет N в этом "лучшем N".

Этот параметр значительно влияет на использование оперативной памяти и ЦП для каждого запроса. Значения от 1 000 до 10 000 обычно приемлемы, но более высокие пределы должны использоваться с осторожностью. Неосторожное увеличение max_matches до 1 000 000 означает, что `searchd` придется выделить и инициализировать буфер совпадений на 1 миллион записей для каждого запроса. Это неизбежно увеличит использование оперативной памяти для каждого запроса и, в некоторых случаях, может заметно сказаться на производительности.

Смотрите [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold) для дополнительной информации о том, как это может повлиять на поведение параметра `max_matches`.

### max_matches_increase_threshold

Целое число. Устанавливает порог, до которого может быть увеличен `max_matches`. Значение по умолчанию - 16384.

Manticore может увеличить `max_matches`, чтобы повысить точность groupby и/или агрегации, когда включено `pseudo_sharding`, и если он обнаруживает, что количество уникальных значений атрибута groupby меньше этого порога. Потеря точности может произойти, когда псевдо-разбиение выполняет запрос в нескольких потоках или когда таблица RT выполняет параллельные поиски по дисковым чанкам.

Если количество уникальных значений атрибута groupby меньше порога, `max_matches` будет установлен на это число. В противном случае будет использоваться значение по умолчанию `max_matches`.

Если `max_matches` был явно установлен в параметрах запроса, этот порог не будет иметь эффекта.

Имейте в виду, что если этот порог установлен слишком высоко, это приведет к увеличению потребления памяти и общему снижению производительности.

Вы также можете обеспечить режим гарантированной точности groupby/агрегата с помощью опции [accurate_aggregation](../Searching/Options.md#accurate_aggregation).

### max_query_time
Устанавливает максимальное время выполнения поискового запроса в миллисекундах. Должен быть неотрицательным целым числом. Значение по умолчанию - 0, что означает "не ограничивать". Локальные поисковые запросы будут остановлены, как только истечет указанное время. Обратите внимание, что если вы выполняете поиск, который запрашивает несколько локальных таблиц, это ограничение применяется к каждой таблице отдельно. Имейте в виду, что это может слегка увеличить время отклика запроса из-за накладных расходов, вызванных постоянным отслеживанием, когда пришло время остановить запрос.

### max_predicted_time
Целое число. Максимальное предсказанное время поиска; см. [predicted_time_costs](../Server_settings/Searchd.md#predicted_time_costs).

### morphology
`none` позволяет заменять все термины запроса на их точные формы, если таблица была создана с включенной [index_exact_words](../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words). Это полезно для предотвращения стемминга или лемматизации терминов запроса.

### not_terms_only_allowed
<!-- example not_terms_only_allowed -->
`0` или `1` позволяет использовать самостоятельную [отрицание](../Searching/Full_text_matching/Operators.md#Negation-operator) для запроса. Значение по умолчанию - 0. Смотрите также соответствующую [глобальную настройку](../Server_settings/Searchd.md#not_terms_only_allowed).

<!-- request SQL -->
```sql
MySQL [(none)]> select * from tbl where match('-donald');
ERROR 1064 (42000): index t: ошибка запроса: запрос не может быть вычислен (единичный оператор NOT)
MySQL [(none)]> select * from t where match('-donald') option not_terms_only_allowed=1;
+---------------------+-----------+
| id                  | field     |
+---------------------+-----------+
| 1658178727135150081 | smth else |
+---------------------+-----------+
```
<!-- end -->

### ranker
Выберите из следующих вариантов:
* `proximity_bm25`
* `bm25`
* `none`
* `wordcount`
* `proximity`
* `matchany`
* `fieldmask`
* `sph04`
* `expr`
* `export`

Для получения более подробной информации о каждом ранкере смотрите [Рейтинг результатов поиска](../Searching/Sorting_and_ranking.md#Available-built-in-rankers).

### rand_seed
Позволяет указать конкретное целое значение начального значения для запроса `ORDER BY RAND()`, например: `... OPTION rand_seed=1234`. По умолчанию для каждого запроса генерируется новое и отличающееся значение семени.

### retry_count
Целое число. Количество распределенных повторов.

### retry_delay
Целое число. Задержка повторов в миллисекундах.

### scroll

Строка. Токен прокрутки для постраничного отображения результатов с использованием [подхода пагинации Scroll](../Searching/Pagination.md#Scroll-Search-Option).

### sort_method
* `pq` - очередь с приоритетом, установлена по умолчанию
* `kbuffer` - обеспечивает более быструю сортировку для уже предварительно отсортированных данных, например, данных таблицы, отсортированных по id
Набор результатов одинаков для обоих случаев; выбор одного варианта или другого может просто улучшить (или ухудшить) производительность.

### threads
Ограничивает максимальное количество потоков, используемых для обработки текущего запроса. По умолчанию - без ограничения (запрос может занять все [потоки](../Server_settings/Searchd.md#threads), заданные глобально).
Для партии запросов опция должна быть прикреплена к самому первому запросу в партии, и затем она применяется, когда создается рабочая очередь, и действует для всей партии. Эта опция имеет то же значение, что и опция [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query), но применяется только к текущему запросу или партии запросов.

### token_filter
Цитированная строка, разделенная двоеточием, вида `имя библиотеки:имя плагина:необязательная строка с настройками`. Токен-фильтр для времени запроса создается для каждого поиска, когда полнотекстовый поиск вызывается каждой вовлеченной таблицей, позволяя вам реализовать собственный токенизатор, который генерирует токены в соответствии с пользовательскими правилами.
```sql
SELECT * FROM index WHERE MATCH ('yes@no') OPTION token_filter='mylib.so:blend:@'
```
### expansion_limit
Ограничивает максимальное количество расширенных ключевых слов для одного подстановочного знака, со значением по умолчанию 0, что указывает на отсутствие ограничений. Для получения дополнительной информации обратитесь к [expansion_limit](../Server_settings/Searchd.md#expansion_limit).

## Подсказки оптимизатора запросов

<!-- example options_force -->

В редких случаях встроенный анализатор запросов Manticore может ошибаться в понимании запроса и определении того, следует ли использовать индекс docid, вторичные индексы или колоннарный скан. Чтобы переопределить решения оптимизатора запросов, вы можете использовать следующие подсказки в вашем запросе:

* `/*+ DocidIndex(id) */`, чтобы заставить использовать индекс docid, `/*+ NO_DocidIndex(id) */`, чтобы сказать оптимизатору игнорировать его
* `/*+ SecondaryIndex(<attr_name1>[, <attr_nameN>]) */`, чтобы заставить использовать вторичный индекс (если доступен), `/*+ NO_SecondaryIndex(id) */`, чтобы сказать оптимизатору игнорировать его
* `/*+ ColumnarScan(<attr_name1>[, <attr_nameN>]) */`, чтобы заставить использовать колоннарный скан (если атрибут колоннарный), `/*+ NO_ColumnarScan(id) */`, чтобы сказать оптимизатору игнорировать его

Обратите внимание, что при выполнении полнотекстового запроса с фильтрами оптимизатор запросов решает, будет ли он пересекать результаты полнотекстового дерева с результатами фильтра или использовать стандартный подход «совпадение-затем-фильтр». Указание *любой* подсказки заставит демон использовать кодовый путь, который выполняет пересечение результатов полнотекстового дерева с результатами фильтра.

Для получения дополнительной информации о том, как работает оптимизатор запросов, обратитесь к странице [Cost based optimizer](../Searching/Cost_based_optimizer.md).

<!-- request SQL -->

```sql
SELECT * FROM students where age > 21 /*+ SecondaryIndex(age) */
```

<!-- end -->

<!-- example comments -->
При использовании клиента MySQL/MariaDB убедитесь, что вы включили флаг `--comments`, чтобы активировать подсказки в ваших запросах.

<!-- request mysql -->
```bash
mysql -P9306 -h0 --comments
```
<!-- end -->

<!-- proofread -->
