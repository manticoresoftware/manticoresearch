# Параметры поиска

SQL-клауза [SELECT](../Searching/Full_text_matching/Basic_usage.md#SQL) и HTTP-эндпоинт [/search](../Searching/Full_text_matching/Basic_usage.md#HTTP-JSON) поддерживают ряд опций, которые можно использовать для тонкой настройки поведения поиска.

## OPTION

### Общий синтаксис

<!-- example options -->

**SQL**:

```sql
SELECT ... [OPTION <optionname>=<value> [ , ... ]] [/*+ [NO_][ColumnarScan|DocidIndex|SecondaryIndex(<attribute>[,...])]] /*]
```

**HTTP**:
```json
POST /search
{
    "table" : "table_name",
    "options":
    {
        "optionname": "value",
        "optionname2": <value2>
    }
}
```


<!-- intro -->
SQL:
<!-- request SQL -->
```sql
SELECT * FROM test WHERE MATCH('@title hello @body world')
OPTION ranker=bm25, max_matches=3000,
field_weights=(title=10, body=3), agent_query_timeout=10000
```

<!-- response SQL -->
```sql
+------+-------+-------+
| id   | title | body  |
+------+-------+-------+
|    1 | hello | world |
+------+-------+-------+
1 row in set (0.00 sec)
```

<!-- intro -->
JSON:
<!-- request JSON -->

```json
POST /search
{
    "table" : "test",
    "query": {
      "match": {
        "title": "hello"
      },
      "match": {
        "body": "world"
      }
    },
    "options":
    {
        "ranker": "bm25",
        "max_matches": 3000,
        "field_weights": {
            "title": 10,
            "body": 3
        },
        "agent_query_timeout": 10000
    }
}
```

<!-- response JSON -->

```json
{
  "took": 0,
  "timed_out": false,
  "hits": {
    "total": 1,
    "total_relation": "eq",
    "hits": [
      {
        "_id": 1,
        "_score": 10500,
        "_source": {
          "title": "hello",
          "body": "world"
        }
      }
    ]
  }
}
```

<!-- end -->

Поддерживаемые опции:

### accurate_aggregation
Целое число. Включает или отключает гарантированную точность агрегатов при выполнении запросов groupby в нескольких потоках. По умолчанию 0.

При выполнении запроса groupby он может быть запущен параллельно на простой таблице с несколькими псевдо-шардами (если включён `pseudo_sharding`). Аналогичный подход работает для RT таблиц. Каждый шард/чанк выполняет запрос, но количество групп ограничено `max_matches`. Если результирующие наборы из разных шардов/чанков содержат разные группы, подсчёты групп и агрегаты могут быть неточными. Обратите внимание, что Manticore пытается увеличить `max_matches` до [`max_matches_increase_threshold`](../Searching/Options.md#max_matches_increase_threshold) исходя из числа уникальных значений атрибута groupby (полученных из вторичных индексов). Если это удаётся, потери точности не происходит.

Однако, если число уникальных значений атрибута groupby высоко, дальнейшее увеличение `max_matches` может быть не лучшей стратегией, так как это приводит к ухудшению производительности и увеличенному потреблению памяти. Установка `accurate_aggregation` в 1 заставляет выполнять поиски groupby в одном потоке, что решает проблему точности. Обратите внимание, что запуск в одном потоке принудительно включается только если `max_matches` нельзя повысить до нужного уровня; иначе поиск с `accurate_aggregation=1` всё равно будет выполняться в нескольких потоках.

В целом, установка `accurate_aggregation` в 1 гарантирует точность подсчёта групп и агрегатов в RT таблицах и простых таблицах с включённым `pseudo_sharding=1`. Недостаток — замедление поиска, так как он принудительно выполняется в одном потоке.

Однако, если у нас есть RT таблица и простая таблица, содержащие одинаковые данные, и мы выполняем запрос с `accurate_aggregation=1`, мы всё равно можем получить разные результаты. Это происходит потому, что демон может выбрать разные значения `max_matches` для RT и простой таблицы вследствие настройки [`max_matches_increase_threshold`](../Searching/Options.md#max_matches_increase_threshold).

### agent_query_timeout
Целое число. Максимальное время в миллисекундах ожидания завершения удалённых запросов, см. [этот раздел](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_query_timeout).

### boolean_simplify
`0` или `1` (по умолчанию `1`). Значение `boolean_simplify=1` включает [упрощение запроса](../Searching/Full_text_matching/Boolean_optimization.md) для ускорения обработки.

Эту опцию можно также задать глобально в [конфигурации searchd](../Server_settings/Searchd.md#boolean_simplify), чтобы изменить поведение по умолчанию для всех запросов. Опция, указанная в запросе, переопределит глобальные настройки.

### comment
Строка, комментарий пользователя, который копируется в файл журнала запросов.

### cutoff
Целое число. Указывает максимальное количество обрабатываемых совпадений. Если не задано, Manticore выберет подходящее значение автоматически.

<!-- example cutoff_aggregation -->

* `N = 0`: Отключает ограничение на количество совпадений.
* `N > 0`: Приказывает Manticore прекратить обработку результатов, как только будет найдено `N` совпадающих документов.
* Не задано: Порог выбирается автоматически.

Если Manticore не может определить точное количество совпадающих документов, поле `total_relation` в [метаинформации](../Node_info_and_management/SHOW_META.md#SHOW-META) запроса покажет `gte`, что означает **больше или равно**. Это означает, что фактическое количество совпадений как минимум равно указанному `total_found` (в SQL) или `hits.total` (в JSON). Когда количество точное, `total_relation` выводит `eq`.

Примечание: Использование `cutoff` в агрегатных запросах не рекомендуется, так как это может привести к неточным или неполным результатам.

<!-- request Example -->

Использование `cutoff` в агрегатных запросах может привести к некорректным или вводящим в заблуждение результатам, как показано в следующем примере:
```
drop table if exists t
--------------

Query OK, 0 rows affected (0.02 sec)

--------------
create table t(a int)
--------------

Query OK, 0 rows affected (0.04 sec)

--------------
insert into t(a) values(1),(2),(3),(1),(2),(3)
--------------

Query OK, 6 rows affected (0.00 sec)

--------------
select avg(a) from t option cutoff=1 facet a
--------------

+----------+
| avg(a)   |
+----------+
| 1.000000 |
+----------+
1 row in set (0.00 sec)
--- 1 out of 1 results in 0ms ---

+------+----------+
| a    | count(*) |
+------+----------+
|    1 |        1 |
+------+----------+
1 row in set (0.00 sec)
--- 1 out of 1 results in 0ms ---
```

Сравните с тем же запросом без `cutoff`:
```
--------------
select avg(a) from t facet a
--------------

+----------+
| avg(a)   |
+----------+
| 2.000000 |
+----------+
1 row in set (0.00 sec)
--- 1 out of 1 results in 0ms ---

+------+----------+
| a    | count(*) |
+------+----------+
|    1 |        2 |
|    2 |        2 |
|    3 |        2 |
+------+----------+
3 rows in set (0.00 sec)
--- 3 out of 3 results in 0ms ---
```

<!-- end -->

### distinct_precision_threshold
Целое число. По умолчанию `3500`. Эта опция задаёт порог, ниже которого подсчёты, возвращаемые `count distinct`, гарантированно точны в пределах простой таблицы.

Допустимый диапазон значений — от `500` до `15500`. Значения вне этого диапазона будут ограничены.

Если параметр установлен в 0, включается алгоритм, обеспечивающий точные подсчёты. Он собирает пары `{group, value}`, сортирует их и периодически устраняет дубликаты. Результат — точные подсчёты в простой таблице. Однако этот подход не подходит для многовалентных данных из-за высокого потребления памяти и медленной работы запроса.

Если `distinct_precision_threshold` больше 0, Manticore использует другой алгоритм. Он загружает подсчёты в хеш-таблицу и возвращает её размер. Если хеш-таблица становится слишком большой, её содержимое переносится в структуру данных `HyperLogLog`. В этот момент подсчёты становятся приближенными, так как HyperLogLog — вероятностный алгоритм. Такой подход ограничивает максимальное потребление памяти на группу, однако может снижаться точность подсчётов.

Точность HyperLogLog и порог перехода от хеш-таблицы к HyperLogLog зависят от настройки `distinct_precision_threshold`. Использовать эту опцию нужно с осторожностью, так как удвоение её значения также приблизительно удвоит максимум памяти, необходимый для подсчётов. Максимальное потребление памяти можно приблизительно оценить по формуле: `64 * max_matches * distinct_precision_threshold`, хотя на практике вычисления подсчётов часто требуют меньше памяти, чем в худшем случае.

### expand_keywords
`0` или `1` (по умолчанию `0`). Расширяет ключевые слова с точными формами и/или звездочками, когда это возможно. Подробнее см. [expand_keywords](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expand_keywords).

### field_weights
Именованный список целых чисел (веса пользователя по полям для ранжирования).

Пример:
```sql
SELECT ... OPTION field_weights=(title=10, body=3)
```

### global_idf
Использовать глобальную статистику (частоты) из файла [global_idf](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#global_idf) для вычисления IDF.

### idf
Заключенный в кавычки, разделенный запятыми список флагов вычисления IDF. Известные флаги:

* `normalized`: вариант BM25, idf = log((N-n+1)/n), согласно Роберсону и др.
* `plain`: простой вариант, idf = log(N/n), согласно Спарк-Джонсу
* `tfidf_normalized`: дополнительно делить IDF на количество слов запроса, чтобы `TF*IDF` попадал в диапазон [0, 1]
* `tfidf_unnormalized`: не делить дополнительно IDF на количество слов запроса, где N — размер коллекции, а n — количество документов, где найдено совпадение

Исторически используемый IDF (обратная частота документа) в Manticore эквивалентен `OPTION idf='normalized,tfidf_normalized'`, и эти нормализации могут приводить к нежелательным эффектам.

Во-первых, `idf=normalized` вызывает штрафование ключевых слов. Например, если вы ищете `the | something` и `the` встречается более чем в 50% документов, тогда документы с обоими ключевыми словами `the` и `something` получат меньший вес, чем документы только с ключевым словом `something`. Использование `OPTION idf=plain` избегает этого. Простой IDF варьируется в диапазоне `[0, log(N)]`, и ключевые слова не штрафуются; в то время как нормализованный IDF варьируется в диапазоне `[-log(N), log(N)]`, и слишком частые ключевые слова получают штраф.

Во-вторых, `idf=tfidf_normalized` приводит к дрейфу IDF между запросами. Исторически IDF также делился на количество ключевых слов в запросе, чтобы сумма `tf*idf` по всем ключевым словам оставалась в диапазоне [0,1]. Однако это означало, что запросы типа `word1` и `word1 | nonmatchingword2` присваивали разный вес одинаковому набору результатов, так как IDF для обоих `word1` и `nonmatchingword2` делился на 2. Использование `OPTION idf='tfidf_unnormalized'` решает эту проблему. Помните, что при отключении этой нормализации факторы ранжирования BM25, BM25A, BM25F() будут соответствующим образом скорректированы.

Флаги IDF можно комбинировать; `plain` и `normalized` взаимоисключающие; `tfidf_unnormalized` и `tfidf_normalized` также взаимоисключающие; а неуказанные флаги в таких взаимоисключающих группах по умолчанию принимаются из их исходных настроек. Это значит, что `OPTION idf=plain` эквивалентно полному указанию `OPTION idf='plain,tfidf_normalized'`.

### jieba_mode
Указывает режим сегментации Jieba для запроса.

При использовании китайской сегментации Jieba иногда полезно применять разные режимы сегментации для токенизации документов и запроса. Для полного списка режимов см. [jieba_mode](../Creating_a_table/NLP_and_tokenization/Morphology.md#jieba_mode).

### index_weights
Именованный список целых чисел. Веса пользователя по таблицам для ранжирования.

### local_df
`0` или `1`, автоматически суммирует DF по всем локальным частям распределенной таблицы, обеспечивая согласованный (и точный) IDF для локально шардированной таблицы. По умолчанию включено для дисковых чанков RT таблиц. Термины запроса с подстановочными знаками игнорируются.

### low_priority
`0` или `1` (по умолчанию `0`). Установка `low_priority=1` выполняет запрос с пониженным приоритетом, выполняя его задачи в 10 раз реже, чем запросы с нормальным приоритетом.

### max_matches
Целое число. Максимальное количество совпадений на запрос.

Максимальное количество совпадений, которое сервер хранит в оперативной памяти для каждой таблицы и может вернуть клиенту. По умолчанию 1000.

Введено для контроля и ограничения использования ОЗУ, настройка `max_matches` определяет, сколько совпадений будет храниться в оперативной памяти при поиске в каждой таблице. Все найденные совпадения по-прежнему обрабатываются, но в память сохраняются и клиенту возвращаются только лучшие N из них. Например, если в таблице содержится 2 000 000 совпадений по запросу, редко возникает необходимость получить их все. Вместо этого необходимо просмотреть все, но выбрать "лучшие" 500, к примеру, согласно каким-либо критериям (например, отсортированные по релевантности, цене или другим факторам), чтобы отобразить пользователю страницы по 20-100 совпадений. Хранение только лучших 500 совпадений гораздо более эффективно по памяти и CPU, чем хранение всех 2 000 000, их сортировка и отбрасывание всех, кроме первых 20 нужных на странице результатов. Параметр `max_matches` контролирует значение N в "лучших N".

Этот параметр существенно влияет на использование памяти и CPU на запрос. Значения от 1000 до 10000 обычно приемлемы, но более высокие значения следует использовать с осторожностью. Необдуманное повышение max_matches до 1 000 000 приведет к тому, что `searchd` придется выделять и инициализировать буфер матчей на миллион записей для каждого запроса. Это неизбежно увеличит использование памяти на запрос и в некоторых случаях заметно повлияет на производительность.

Дополнительную информацию о том, как это может влиять на поведение параметра `max_matches`, см. в [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold).

### max_matches_increase_threshold

Целое число. Устанавливает порог, до которого может быть увеличен `max_matches`. По умолчанию 16384.

Manticore может увеличить `max_matches` для повышения точности группировки и/или агрегации при включенном `pseudo_sharding`, если обнаружит, что количество уникальных значений группируемого атрибута меньше этого порога. Потеря точности может происходить, когда псевдо-шардирование выполняет запрос в нескольких потоках или когда RT таблица осуществляет параллельные поиски в дисковых чанках.

Если число уникальных значений группируемого атрибута меньше порога, `max_matches` будет установлено в это число. В противном случае будет использовано значение по умолчанию.

Если `max_matches` был явно установлен в опциях запроса, этот порог не действует.

Учитывайте, что слишком высокий порог приведет к увеличенному потреблению памяти и общему снижению производительности.

Вы также можете обеспечить гарантированно точный режим groupby/aggregate, используя опцию [accurate_aggregation](../Searching/Options.md#accurate_aggregation).

### max_query_time
Устанавливает максимальное время выполнения поискового запроса в миллисекундах. Должно быть неотрицательным целым числом. Значение по умолчанию — 0, что означает «без ограничений». Локальные поисковые запросы будут прерваны после истечения указанного времени. Обратите внимание, что если вы выполняете поиск, который опрашивает несколько локальных таблиц, это ограничение применяется отдельно к каждой таблице. Имейте в виду, что это может немного увеличить время отклика запроса из-за накладных расходов, связанных с постоянным отслеживанием момента остановки запроса.

### max_predicted_time
Целое число. Максимальное прогнозируемое время поиска; см. [predicted_time_costs](../Server_settings/Searchd.md#predicted_time_costs).

### morphology
`none` позволяет заменять все термины запроса их точными формами, если таблица была построена с включённым [index_exact_words](../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words). Это полезно для предотвращения стемминга или лемматизации терминов запроса.

### not_terms_only_allowed
<!-- example not_terms_only_allowed -->
`0` или `1` разрешает использование одиночного [отрицания](../Searching/Full_text_matching/Operators.md#Negation-operator) в запросе. По умолчанию — 0. См. также соответствующую [глобальную настройку](../Server_settings/Searchd.md#not_terms_only_allowed).

<!-- request SQL -->
```sql
MySQL [(none)]> select * from tbl where match('-donald');
ERROR 1064 (42000): index t: query error: query is non-computable (single NOT operator)
MySQL [(none)]> select * from t where match('-donald') option not_terms_only_allowed=1;
+---------------------+-----------+
| id                  | field     |
+---------------------+-----------+
| 1658178727135150081 | smth else |
+---------------------+-----------+
```
<!-- end -->

### ranker
Выберите один из следующих вариантов:
* `proximity_bm25`
* `bm25`
* `none`
* `wordcount`
* `proximity`
* `matchany`
* `fieldmask`
* `sph04`
* `expr`
* `export`

Для получения дополнительной информации о каждом ранжировщике обращайтесь к разделу [Ранжирование результатов поиска](../Searching/Sorting_and_ranking.md#Available-built-in-rankers).

### rand_seed
Позволяет указать конкретное целочисленное значение зерна для запроса `ORDER BY RAND()`, например: `... OPTION rand_seed=1234`. По умолчанию для каждого запроса автоматически генерируется новое и уникальное значение зерна.

### retry_count
Целое число. Количество попыток повторного выполнения распределённого запроса.

### retry_delay
Целое число. Задержка повторной попытки в миллисекундах.

### scroll

Строка. Токен прокрутки для постраничного вывода результатов с использованием [способа Scroll pagination](../Searching/Pagination.md#Scroll-Search-Option).

### sort_method
* `pq` — приоритетная очередь, используется по умолчанию
* `kbuffer` — обеспечивает более быструю сортировку уже предварительно отсортированных данных, например, данных таблицы, отсортированных по id
Набор результатов в обоих случаях одинаков; выбор одного варианта может просто улучшить (или ухудшить) производительность.

### threads
Ограничивает максимальное количество потоков, используемых для обработки текущего запроса. По умолчанию — без ограничений (запрос может использовать все [потоки](../Server_settings/Searchd.md#threads), определённые глобально).
Для пакетного выполнения запросов опция должна быть добавлена к самому первому запросу в пакете. Она применяется при создании рабочей очереди и действует для всего пакета. Эта опция эквивалентна опции [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query), но применяется только к текущему запросу или пакету запросов.

### token_filter
Кавычками заключённая строка с двоеточиями, разделяющая `название библиотеки:название плагина:необязательная строка настроек`. Фильтр токенов во время выполнения запроса создаётся для каждого поиска, когда используется полнотекстовый поиск каждой задействованной таблицей, что позволяет реализовать пользовательский токенизатор, который генерирует токены согласно особым правилам.
```sql
SELECT * FROM index WHERE MATCH ('yes@no') OPTION token_filter='mylib.so:blend:@'
```
### expansion_limit
Ограничивает максимальное количество расширенных ключевых слов для одного подстановочного знака, значение по умолчанию — 0, что означает отсутствие ограничений. Для подробностей смотрите [expansion_limit](../Server_settings/Searchd.md#expansion_limit).

## Подсказки оптимизатора запросов

<!-- example options_force -->

В редких случаях встроенный анализатор запросов Manticore может неправильно определить запрос и выбрать использование docid индекса, вторичных индексов или колоночного сканирования. Чтобы переопределить решения оптимизатора запросов, можно использовать следующие подсказки в вашем запросе:

* `/*+ DocidIndex(id) */` — заставить использовать docid индекс, `/*+ NO_DocidIndex(id) */` — игнорировать его
* `/*+ SecondaryIndex(<attr_name1>[, <attr_nameN>]) */` — заставить использовать вторичный индекс (если доступен), `/*+ NO_SecondaryIndex(id) */` — игнорировать его
* `/*+ ColumnarScan(<attr_name1>[, <attr_nameN>]) */` — заставить использовать колоночное сканирование (если атрибут колоночный), `/*+ NO_ColumnarScan(id) */` — игнорировать его

Обратите внимание, что при выполнении полнотекстового запроса с фильтрами оптимизатор выбирает между пересечением результатов полнотекстового дерева с результатами фильтра или стандартным подходом match-then-filter. Указание *любых* подсказок заставит демона использовать путь кода, который выполняет пересечение результатов полнотекстового дерева с результатами фильтра.

Для получения дополнительной информации о работе оптимизатора запросов смотрите страницу [Оптимизатор на основе стоимости](../Searching/Cost_based_optimizer.md).

<!-- request SQL -->

```sql
SELECT * FROM students where age > 21 /*+ SecondaryIndex(age) */
```

<!-- end -->

<!-- example comments -->
При использовании клиента MySQL/MariaDB обязательно включите флаг `--comments`, чтобы подсказки в ваших запросах были активированы.

<!-- request mysql -->
```bash
mysql -P9306 -h0 --comments
```
<!-- end -->

<!-- proofread -->

