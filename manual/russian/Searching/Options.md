# Параметры поиска

SQL [SELECT](../Searching/Full_text_matching/Basic_usage.md#SQL) оператор и HTTP [/search](../Searching/Full_text_matching/Basic_usage.md#HTTP-JSON) эндпоинт поддерживают ряд опций, которые можно использовать для тонкой настройки поведения поиска.

## OPTION

### Общий синтаксис

<!-- example options -->

**SQL**:

```sql
SELECT ... [OPTION <optionname>=<value> [ , ... ]] [/*+ [NO_][ColumnarScan|DocidIndex|SecondaryIndex(<attribute>[,...])]] /*]
```

**HTTP**:
```json
POST /search
{
    "table" : "table_name",
    "options":
    {
        "optionname": "value",
        "optionname2": <value2>
    }
}
```


<!-- intro -->
SQL:
<!-- request SQL -->
```sql
SELECT * FROM test WHERE MATCH('@title hello @body world')
OPTION ranker=bm25, max_matches=3000,
field_weights=(title=10, body=3), agent_query_timeout=10000
```

<!-- response SQL -->
```sql
+------+-------+-------+
| id   | title | body  |
+------+-------+-------+
|    1 | hello | world |
+------+-------+-------+
1 row in set (0.00 sec)
```

<!-- intro -->
JSON:
<!-- request JSON -->

```json
POST /search
{
    "table" : "test",
    "query": {
      "match": {
        "title": "hello"
      },
      "match": {
        "body": "world"
      }
    },
    "options":
    {
        "ranker": "bm25",
        "max_matches": 3000,
        "field_weights": {
            "title": 10,
            "body": 3
        },
        "agent_query_timeout": 10000
    }
}
```

<!-- response JSON -->

```json
{
  "took": 0,
  "timed_out": false,
  "hits": {
    "total": 1,
    "total_relation": "eq",
    "hits": [
      {
        "_id": 1,
        "_score": 10500,
        "_source": {
          "title": "hello",
          "body": "world"
        }
      }
    ]
  }
}
```

<!-- end -->

Поддерживаемые опции:

### accurate_aggregation
Целое число. Включает или отключает гарантированную точность агрегатов при выполнении запросов groupby в нескольких потоках. По умолчанию 0.

При выполнении groupby запроса он может выполняться параллельно на простой таблице с несколькими псевдо-шифрами (если включён `pseudo_sharding`). Аналогичный подход работает и на RT таблицах. Каждый шард/чанк выполняет запрос, но число групп ограничено значением `max_matches`. Если результат запроса с разных шардов/чанков содержат разные группы, подсчёты групп и агрегаты могут быть неточными. Обратите внимание, что Manticore пытается увеличить `max_matches` до [`max_matches_increase_threshold`](../Searching/Options.md#max_matches_increase_threshold) на основе числа уникальных значений атрибута groupby (получаемого из вторичных индексов). Если это удаётся, то потери точности не будет.

Однако, если количество уникальных значений атрибута groupby велико, дальнейшее увеличение `max_matches` может быть плохой стратегией, так как это может привести к потере производительности и повышенному использованию памяти. Установка `accurate_aggregation` в 1 заставляет groupby запросы выполняться в одном потоке, что решает проблему точности. Заметьте, что выполнение в одном потоке применяется только когда нельзя задать достаточно высокое значение `max_matches`; иначе запросы с `accurate_aggregation=1` всё равно будут выполняться в нескольких потоках.

В целом, установка `accurate_aggregation` в 1 обеспечивает точность подсчёта групп и агрегатов на RT таблицах и простых таблицах с `pseudo_sharding=1`. Недостаток в том, что запросы будут выполняться медленнее, так как их заставят работать в одном потоке.

Однако, если у нас есть RT таблица и простая таблица с одинаковыми данными, и мы выполняем запрос с `accurate_aggregation=1`, мы всё равно можем получить разные результаты. Это происходит потому, что демон может выбирать разные настройки `max_matches` для RT и простой таблиц из-за параметра [`max_matches_increase_threshold`](../Searching/Options.md#max_matches_increase_threshold).

### agent_query_timeout
Целое число. Максимальное время в миллисекундах ожидания завершения удалённых запросов, подробнее см. [в этом разделе](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_query_timeout).

### boolean_simplify
`0` или `1` (по умолчанию `1`). `boolean_simplify=1` включает [упрощение запроса](../Searching/Full_text_matching/Boolean_optimization.md) для ускорения его выполнения.

### comment
Строка, комментарий пользователя, который копируется в файл лога запросов.

### cutoff
Целое число. Определяет максимальное количество обрабатываемых совпадений. Если не установлено, Manticore самостоятельно выберет подходящее значение.

<!-- example cutoff_aggregation -->

* `N = 0`: Отключает ограничение по количеству совпадений.
* `N > 0`: Приказывает Manticore прекратить обработку результатов, как только найдено `N` подходящих документов.
* Не установлено: Manticore самостоятельно определяет порог.

Когда Manticore не может определить точное количество документов, подходящих под запрос, поле `total_relation` в [метаинформации](../Node_info_and_management/SHOW_META.md#SHOW-META) запроса будет содержать значение `gte` — что означает **больше или равно**. Это значит, что фактическое число совпадений как минимум равно сообщённому значению `total_found` (в SQL) или `hits.total` (в JSON). Если количество совпадений точно, `total_relation` будет содержать `eq`.

Примечание: Использовать `cutoff` в агрегирующих запросах не рекомендуется, так как это может привести к неточным или неполным результатам.

<!-- request Example -->

Использование `cutoff` в агрегирующих запросах может привести к некорректным или вводящим в заблуждение результатам, как показано в следующем примере:
```
drop table if exists t
--------------

Query OK, 0 rows affected (0.02 sec)

--------------
create table t(a int)
--------------

Query OK, 0 rows affected (0.04 sec)

--------------
insert into t(a) values(1),(2),(3),(1),(2),(3)
--------------

Query OK, 6 rows affected (0.00 sec)

--------------
select avg(a) from t option cutoff=1 facet a
--------------

+----------+
| avg(a)   |
+----------+
| 1.000000 |
+----------+
1 row in set (0.00 sec)
--- 1 out of 1 results in 0ms ---

+------+----------+
| a    | count(*) |
+------+----------+
|    1 |        1 |
+------+----------+
1 row in set (0.00 sec)
--- 1 out of 1 results in 0ms ---
```

Сравните с тем же запросом без `cutoff`:
```
--------------
select avg(a) from t facet a
--------------

+----------+
| avg(a)   |
+----------+
| 2.000000 |
+----------+
1 row in set (0.00 sec)
--- 1 out of 1 results in 0ms ---

+------+----------+
| a    | count(*) |
+------+----------+
|    1 |        2 |
|    2 |        2 |
|    3 |        2 |
+------+----------+
3 rows in set (0.00 sec)
--- 3 out of 3 results in 0ms ---
```

<!-- end -->

### distinct_precision_threshold
Целое число. По умолчанию `3500`. Эта опция задаёт порог ниже которого подсчёты, возвращаемые `count distinct`, гарантированно точны в пределах простой таблицы.

Допустимые значения от `500` до `15500`. Значения вне этого диапазона будут ограничены.

Если опция установлена в 0, включается алгоритм, обеспечивающий точный подсчёт. Этот алгоритм собирает пары `{group, value}`, сортирует их и периодически удаляет дубликаты. Результатом являются точные подсчёты в пределах простой таблицы. Однако этот подход не подходит для наборов данных с высокой кардинальностью из-за высокого потребления памяти и медленного выполнения запроса.

Если `distinct_precision_threshold` установлена в значение больше 0, Manticore использует другой алгоритм. Он загружает подсчёты в хеш-таблицу и возвращает размер таблицы. Если хеш-таблица становится слишком большой, её содержимое переносится в структуру данных `HyperLogLog`. В этот момент подсчёты становятся приблизительными, так как HyperLogLog — вероятностный алгоритм. Такой подход поддерживает фиксированное максимальное использование памяти на группу, но с компромиссом по точности подсчётов.

Точность `HyperLogLog` и порог перехода от хеш-таблицы к HyperLogLog зависят от настройки `distinct_precision_threshold`. Важно использовать эту опцию осторожно, так как удвоение её значения также удвоит максимальное необходимое количество памяти для вычисления подсчётов. Максимальное потребление памяти можно примерно оценить по формуле: `64 * max_matches * distinct_precision_threshold`, хотя на практике подсчёты обычно используют меньше памяти, чем в худшем случае.

### expand_keywords
`0` или `1` (по умолчанию `0`). Расширяет ключевые слова точными формами и/или подстановочными знаками, где возможно. Подробнее см. [expand_keywords](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expand_keywords).

### field_weights
Именованный список целых чисел (весовые коэффициенты пользователя для ранжирования по полям).

Пример:
```sql
SELECT ... OPTION field_weights=(title=10, body=3)
```

### global_idf
Используйте глобальную статистику (частоты) из файла [global_idf](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#global_idf) для вычислений IDF.

### idf
Кавычки, разделенный запятыми список флагов вычисления IDF. Известные флаги:

* `normalized`: вариант BM25, idf = log((N-n+1)/n), согласно Робертсону и др.
* `plain`: простой вариант, idf = log(N/n), согласно Спарку-Джонсу
* `tfidf_normalized`: дополнительно делить IDF на количество слов в запросе, чтобы `TF*IDF` попадал в диапазон [0, 1]
* `tfidf_unnormalized`: не делить дополнительно IDF на количество слов в запросе, где N — размер коллекции, а n — количество совпадающих документов

Исторически стандартный IDF (обратная частота документа) в Manticore эквивалентен `OPTION idf='normalized,tfidf_normalized'`, и эти нормализации могут вызывать несколько нежелательных эффектов.

Во-первых, `idf=normalized` приводит к штрафованию ключевых слов. Например, если вы ищете `the | something` и `the` встречается более чем в 50% документов, то документы с ключевыми словами `the` и `something` вместе получат меньший вес, чем документы с одним ключевым словом `something`. Использование `OPTION idf=plain` избегает этого. Простой IDF варьируется в диапазоне `[0, log(N)]`, и ключевые слова не штрафуются; в то время как нормализованный IDF варьируется в диапазоне `[-log(N), log(N)]`, и слишком частые ключевые слова штрафуются.

Во-вторых, `idf=tfidf_normalized` приводит к смещению IDF между запросами. Исторически IDF также делился на количество ключевых слов в запросе, что обеспечивало, что весь `sum(tf*idf)` для всех ключевых слов оставался в пределах [0,1]. Однако это означало, что запросы типа `word1` и `word1 | nonmatchingword2` присваивали разные веса точно одному и тому же набору результатов, так как IDF для `word1` и `nonmatchingword2` делился на 2. Использование `OPTION idf='tfidf_unnormalized'` решает эту проблему. Имейте в виду, что факторы ранжирования BM25, BM25A, BM25F() будут соответствующим образом скорректированы при отключении этой нормализации.

Флаги IDF можно комбинировать; `plain` и `normalized` взаимно исключающие; `tfidf_unnormalized` и `tfidf_normalized` тоже взаимно исключающие; и неуказанные флаги в таких взаимно исключающих группах принимают значение по умолчанию. Это означает, что `OPTION idf=plain` эквивалентно указанию полностью `OPTION idf='plain,tfidf_normalized'`.

### jieba_mode
Определяет режим сегментации Jieba для запроса.

При использовании разделения китайского текста Jieba иногда полезно использовать разные режимы сегментации для токенизации документов и запроса. Полный список режимов см. в [jieba_mode](../Creating_a_table/NLP_and_tokenization/Morphology.md#jieba_mode).

### index_weights
Именованный список целых чисел. Весовые коэффициенты пользователя для ранжирования по таблицам.

### local_df
`0` или `1`, автоматически суммирует DF по всем локальным частям распределенной таблицы, обеспечивая последовательный (и точный) IDF для локально шардированной таблицы. По умолчанию включено для дисковых чанков таблиц RT. Термины запроса с подстановочными знаками игнорируются.

### low_priority
`0` или `1` (по умолчанию `0`). Установка `low_priority=1` запускает запрос с пониженным приоритетом, перепланируя его задания в 10 раз реже, чем другие запросы с нормальным приоритетом.

### max_matches
Целое число. Максимум совпадений на запрос.

Максимальное количество совпадений, которое сервер сохраняет в ОЗУ для каждой таблицы и может вернуть клиенту. Значение по умолчанию – 1000.

Введено для контроля и ограничения использования ОЗУ, параметр `max_matches` определяет, сколько совпадений будет сохранено в памяти при поиске по каждой таблице. Каждый найденный совпадение обрабатывается, но в память будут сохранены и возвращены клиенту только лучшие N из них. Например, если по запросу таблица содержит 2,000,000 совпадений, редко есть необходимость получить их все. Вместо этого нужно просмотреть все совпадения, но выбрать «лучшие» 500, например, по каким-то критериям (например, отсортированные по релевантности, цене или другим факторам) и показать эти 500 совпадений пользователю с разбивкой на страницы по 20–100 совпадений. Отслеживание только лучших 500 совпадений гораздо эффективнее по ОЗУ и CPU, чем хранение всех 2,000,000 совпадений, их сортировка и отбрасывание всего, кроме первых 20, необходимых для отображения результатов. `max_matches` управляет этой величиной «лучших N».

Этот параметр значительно влияет на использование ОЗУ и CPU на запрос. Значения от 1000 до 10000 обычно приемлемы, однако более высокие значения следует использовать с осторожностью. Небрежное увеличение max_matches до 1,000,000 означает, что `searchd` придется выделить и инициализировать буфер совпадений с миллионом записей для каждого запроса. Это неизбежно увеличит использование ОЗУ на запрос и в некоторых случаях может заметно повлиять на производительность.

Дополнительную информацию о том, как это параметр влияет на поведение опции `max_matches`, см. в [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold).

### max_matches_increase_threshold

Целое число. Устанавливает порог, до которого `max_matches` может быть увеличен. Значение по умолчанию — 16384.

Manticore может увеличивать `max_matches` для повышения точности groupby и/или агрегаций при включенном `pseudo_sharding` и если обнаружит, что количество уникальных значений атрибута groupby меньше этого порога. Потеря точности может возникать, когда pseudo-sharding выполняет запрос в нескольких потоках или RT таблица выполняет параллельные поиски в дисковых чанках.

Если количество уникальных значений groupby-атрибута меньше порога, `max_matches` устанавливается в это значение. В противном случае используется значение по умолчанию.

Если `max_matches` задан явно в опциях запроса, этот порог не действует.

Имейте в виду, что если порог установлен слишком высоким, это приведет к увеличенному потреблению памяти и снижению общей производительности.

Вы также можете включить режим гарантированной точности группировок/агрегаций с помощью опции [accurate_aggregation](../Searching/Options.md#accurate_aggregation).

### max_query_time
Устанавливает максимальное время выполнения поискового запроса в миллисекундах. Должно быть неотрицательным целым числом. Значение по умолчанию — 0, что означает «без ограничения». Локальные поисковые запросы будут остановлены после истечения указанного времени. Обратите внимание, что если выполняется поиск, затрагивающий несколько локальных таблиц, это ограничение применяется к каждой таблице отдельно. Имейте в виду, что это может слегка увеличить время отклика запроса из-за накладных расходов на постоянный контроль времени остановки запроса.

### max_predicted_time
Целое число. Максимальное предсказанное время поиска; см. [predicted_time_costs](../Server_settings/Searchd.md#predicted_time_costs).

### morphology
`none` позволяет заменять все термины запроса их точными формами, если таблица была создана с включённой опцией [index_exact_words](../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words). Это полезно для предотвращения стемминга или лемматизации терминов запроса.

### not_terms_only_allowed
<!-- example not_terms_only_allowed -->
`0` или `1` разрешают самостоятельное использование [отрицания](../Searching/Full_text_matching/Operators.md#Negation-operator) в запросе. Значение по умолчанию — 0. См. также соответствующую [глобальную настройку](../Server_settings/Searchd.md#not_terms_only_allowed).

<!-- request SQL -->
```sql
MySQL [(none)]> select * from tbl where match('-donald');
ERROR 1064 (42000): index t: query error: query is non-computable (single NOT operator)
MySQL [(none)]> select * from t where match('-donald') option not_terms_only_allowed=1;
+---------------------+-----------+
| id                  | field     |
+---------------------+-----------+
| 1658178727135150081 | smth else |
+---------------------+-----------+
```
<!-- end -->

### ranker
Выберите из следующих вариантов:
* `proximity_bm25`
* `bm25`
* `none`
* `wordcount`
* `proximity`
* `matchany`
* `fieldmask`
* `sph04`
* `expr`
* `export`

Более подробную информацию о каждом ранжировщике смотрите в разделе [Ранжирование результатов поиска](../Searching/Sorting_and_ranking.md#Available-built-in-rankers).

### rand_seed
Позволяет указать конкретное целочисленное значение seed для запроса `ORDER BY RAND()`, например: `... OPTION rand_seed=1234`. По умолчанию для каждого запроса генерируется новое и уникальное seed-значение.

### retry_count
Целое число. Количество повторных попыток в распределённом режиме.

### retry_delay
Целое число. Задержка перед повторной попыткой в распределённом режиме в миллисекундах.

### scroll

Строка. Токен скролла для постраничного вывода результатов с использованием [Scroll pagination approach](../Searching/Pagination.md#Scroll-Search-Option).

### sort_method
* `pq` — очередь с приоритетом, установлено по умолчанию
* `kbuffer` — обеспечивает более быструю сортировку для уже предварительно отсортированных данных, например, данных таблицы, отсортированных по id
Набор результатов одинаков в обоих случаях; выбор одного из вариантов может просто улучшить (или ухудшить) производительность.

### threads
Ограничивает максимальное количество потоков, используемых для обработки текущего запроса. По умолчанию — без ограничений (запрос может использовать все [потоки](../Server_settings/Searchd.md#threads), определённые глобально).
Для пакета запросов эта опция должна быть прикреплена к самому первому запросу в пакете и применяется при создании рабочей очереди, действуя для всего пакета. Эта опция имеет то же значение, что и опция [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query), но применяется только к текущему запросу или пакету запросов.

### token_filter
Цитированная строка, разделённая двоеточиями, которая содержит `имя библиотеки:имя плагина:опциональная строка настроек`. Для каждого поиска создаётся фильтр токенов на этапе выполнения запроса при вызове полнотекстового поиска каждой задействованной таблицей, позволяя реализовать пользовательский токенизатор, который генерирует токены согласно индивидуальным правилам.
```sql
SELECT * FROM index WHERE MATCH ('yes@no') OPTION token_filter='mylib.so:blend:@'
```
### expansion_limit
Ограничивает максимальное количество расширенных ключевых слов для одного шаблона с подстановочными знаками, значение по умолчанию — 0, что означает отсутствие ограничения. Дополнительные сведения смотрите в разделе [expansion_limit](../Server_settings/Searchd.md#expansion_limit).

## Подсказки оптимизатору запросов

<!-- example options_force -->

В редких случаях встроенный анализатор запросов Manticore может неправильно понимать запрос и решать, использовать ли индекс docid, вторичные индексы или колонный скан. Чтобы переопределить решения оптимизатора запросов, можно использовать следующие подсказки в запросе:

* `/*+ DocidIndex(id) */` чтобы заставить использовать индекс docid, `/*+ NO_DocidIndex(id) */` чтобы указать оптимизатору игнорировать его
* `/*+ SecondaryIndex(<attr_name1>[, <attr_nameN>]) */` чтобы заставить использовать вторичный индекс (если доступен), `/*+ NO_SecondaryIndex(id) */` чтобы указать оптимизатору игнорировать его
* `/*+ ColumnarScan(<attr_name1>[, <attr_nameN>]) */` чтобы заставить использовать колонный скан (если атрибут является колонным), `/*+ NO_ColumnarScan(id) */` чтобы указать оптимизатору игнорировать его

Обратите внимание, что при выполнении полнотекстового запроса с фильтрами оптимизатор запроса решает, пересекать ли результаты полнотекстового дерева с результатами фильтра или использовать стандартный подход match-then-filter. Указание *любых* подсказок заставит демон использовать код, который выполняет пересечение результатов полнотекстового дерева с результатами фильтра.

Для дополнительной информации о работе оптимизатора запроса смотрите страницу [Оптимизатор на основе стоимости](../Searching/Cost_based_optimizer.md).

<!-- request SQL -->

```sql
SELECT * FROM students where age > 21 /*+ SecondaryIndex(age) */
```

<!-- end -->

<!-- example comments -->
При использовании клиента MySQL/MariaDB убедитесь, что включён флаг `--comments`, чтобы подсказки работали в ваших запросах.

<!-- request mysql -->
```bash
mysql -P9306 -h0 --comments
```
<!-- end -->

<!-- proofread -->

