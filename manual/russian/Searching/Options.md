# Параметры поиска

SQL [SELECT](../Searching/Full_text_matching/Basic_usage.md#SQL) оператор и HTTP [/search](../Searching/Full_text_matching/Basic_usage.md#HTTP-JSON) endpoint поддерживают ряд опций, которые можно использовать для тонкой настройки поведения поиска.

## OPTION

### Общий синтаксис

<!-- example options -->

**SQL**:

```sql
SELECT ... [OPTION <optionname>=<value> [ , ... ]] [/*+ [NO_][ColumnarScan|DocidIndex|SecondaryIndex(<attribute>[,...])]] /*]
```

**HTTP**:
```json
POST /search
{
    "table" : "table_name",
    "options":
    {
        "optionname": "value",
        "optionname2": <value2>
    }
}
```


<!-- intro -->
SQL:
<!-- request SQL -->
```sql
SELECT * FROM test WHERE MATCH('@title hello @body world')
OPTION ranker=bm25, max_matches=3000,
field_weights=(title=10, body=3), agent_query_timeout=10000
```

<!-- response SQL -->
```sql
+------+-------+-------+
| id   | title | body  |
+------+-------+-------+
|    1 | hello | world |
+------+-------+-------+
1 row in set (0.00 sec)
```

<!-- intro -->
JSON:
<!-- request JSON -->

```json
POST /search
{
    "table" : "test",
    "query": {
      "match": {
        "title": "hello"
      },
      "match": {
        "body": "world"
      }
    },
    "options":
    {
        "ranker": "bm25",
        "max_matches": 3000,
        "field_weights": {
            "title": 10,
            "body": 3
        },
        "agent_query_timeout": 10000
    }
}
```

<!-- response JSON -->

```json
{
  "took": 0,
  "timed_out": false,
  "hits": {
    "total": 1,
    "total_relation": "eq",
    "hits": [
      {
        "_id": 1,
        "_score": 10500,
        "_source": {
          "title": "hello",
          "body": "world"
        }
      }
    ]
  }
}
```

<!-- end -->

Поддерживаемые опции:

### accurate_aggregation
Целое число. Включает или отключает гарантированную точность агрегирования при выполнении запросов groupby в нескольких потоках. По умолчанию 0.

При выполнении запроса groupby он может выполняться параллельно над обычной таблицей с несколькими псевдо-шардами (если включён `pseudo_sharding`). Аналогичный подход работает и для RT таблиц. Каждый шард/чанк выполняет запрос, но количество групп ограничено `max_matches`. Если наборы результатов из разных шардов/чанков содержат разные группы, количество групп и агрегаты могут быть неточными. Следует отметить, что Manticore пытается увеличить `max_matches` до уровня [`max_matches_increase_threshold`](../Searching/Options.md#max_matches_increase_threshold) на основе количества уникальных значений атрибута groupby (получаемых из вторичных индексов). Если попытка успешна, потери в точности не будет.

Однако, если количество уникальных значений атрибута groupby высоко, дальнейшее увеличение `max_matches` может не быть хорошей стратегией, так как это приведёт к снижению производительности и увеличению использования памяти. Установка `accurate_aggregation` в 1 заставляет запросы groupby выполняться в одном потоке, что решает проблему точности. Отметим, что однопоточное выполнение применяется только тогда, когда `max_matches` нельзя установить достаточно высоким; в противном случае запросы с `accurate_aggregation=1` всё равно будут выполняться в нескольких потоках.

В целом, установка `accurate_aggregation` в 1 обеспечивает точность подсчёта групп и агрегатов в RT таблицах и обычных таблицах с `pseudo_sharding=1`. Недостаток в том, что запросы будут выполняться медленнее, так как будут принудительно работать в одном потоке.

Однако, если у нас есть RT таблица и обычная таблица с одинаковыми данными, и мы выполняем запрос с `accurate_aggregation=1`, мы всё равно можем получить разные результаты. Это происходит потому, что демон может выбрать разные настройки `max_matches` для RT и обычной таблицы из-за параметра [`max_matches_increase_threshold`](../Searching/Options.md#max_matches_increase_threshold).

### agent_query_timeout
Целое число. Максимальное время ожидания в миллисекундах для завершения удалённых запросов, см. [этот раздел](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_query_timeout).

### boolean_simplify
`0` или `1` (по умолчанию `1`). `boolean_simplify=1` включает [упрощение запроса](../Searching/Full_text_matching/Boolean_optimization.md) для ускорения его выполнения.

Эта опция также может быть установлена глобально в [конфигурации searchd](../Server_settings/Searchd.md#boolean_simplify) для изменения поведения по умолчанию для всех запросов. Опция на уровне запроса переопределит глобальную настройку.

### comment
Строка, пользовательский комментарий, который копируется в файл логов запросов.

### cutoff
Целое число. Задает максимальное количество обрабатываемых совпадений. Если не задано, Manticore автоматически выберет подходящее значение.

<!-- example cutoff_aggregation -->

* `N = 0`: Отключает ограничение на количество совпадений.
* `N > 0`: Инструктирует Manticore прекратить обработку результатов, как только найдено `N` совпадающих документов.
* Не задано: Manticore автоматически устанавливает порог.

Если Manticore не может определить точное количество совпадающих документов, поле `total_relation` в [метаинформации](../Node_info_and_management/SHOW_META.md#SHOW-META) запроса будет содержать значение `gte`, что означает **больше или равно**. Это указывает, что фактическое количество совпадений как минимум равно заявленному `total_found` (в SQL) или `hits.total` (в JSON). Если подсчёт точен, `total_relation` будет равен `eq`.

Примечание: Использование `cutoff` в запросах с агрегацией не рекомендуется, так как это может привести к неточным или неполным результатам.

<!-- request Example -->

Использование `cutoff` в агрегационных запросах может привести к некорректным или вводящим в заблуждение результатам, как показано в следующем примере:
```
drop table if exists t
--------------

Query OK, 0 rows affected (0.02 sec)

--------------
create table t(a int)
--------------

Query OK, 0 rows affected (0.04 sec)

--------------
insert into t(a) values(1),(2),(3),(1),(2),(3)
--------------

Query OK, 6 rows affected (0.00 sec)

--------------
select avg(a) from t option cutoff=1 facet a
--------------

+----------+
| avg(a)   |
+----------+
| 1.000000 |
+----------+
1 row in set (0.00 sec)
--- 1 out of 1 results in 0ms ---

+------+----------+
| a    | count(*) |
+------+----------+
|    1 |        1 |
+------+----------+
1 row in set (0.00 sec)
--- 1 out of 1 results in 0ms ---
```

Сравните с тем же запросом без `cutoff`:
```
--------------
select avg(a) from t facet a
--------------

+----------+
| avg(a)   |
+----------+
| 2.000000 |
+----------+
1 row in set (0.00 sec)
--- 1 out of 1 results in 0ms ---

+------+----------+
| a    | count(*) |
+------+----------+
|    1 |        2 |
|    2 |        2 |
|    3 |        2 |
+------+----------+
3 rows in set (0.00 sec)
--- 3 out of 3 results in 0ms ---
```

<!-- end -->

### distinct_precision_threshold
Целое число. По умолчанию `3500`. Этот параметр задаёт порог, ниже которого подсчёты, возвращаемые `count distinct`, гарантированно будут точными для обычной таблицы.

Принимаемые значения от `500` до `15500`. Значения за пределами этого диапазона будут обрезаны.

Если эта опция установлена в 0, включается алгоритм, обеспечивающий точный подсчёт. Этот алгоритм собирает пары `{group, value}`, сортирует их и периодически устраняет дубликаты. В итоге подсчёты точны для обычной таблицы. Однако этот подход не подходит для данных с высокой кардинальностью из-за большого потребления памяти и медленного выполнения запросов.

Если `distinct_precision_threshold` задано значением больше 0, Manticore использует другой алгоритм. Он загружает подсчёты в хеш-таблицу и возвращает размер таблицы. Если хеш-таблица становится слишком большой, её содержимое перемещается в структуру данных `HyperLogLog`. На этом этапе подсчёты становятся приблизительными, так как HyperLogLog — вероятностный алгоритм. Этот подход поддерживает фиксированное максимальное использование памяти на группу, но с потерей точности подсчёта.

Точность `HyperLogLog` и порог конверсии из хеш-таблицы в HyperLogLog основываются на настройке `distinct_precision_threshold`. Важно использовать эту опцию с осторожностью, так как удвоение её значения также удваивает максимальное необходимое количество памяти для подсчётов. Максимальное использование памяти можно приблизительно оценить по формуле: `64 * max_matches * distinct_precision_threshold`, хотя на практике подсчёты обычно используют меньше памяти, чем в худшем случае.

### expand_keywords












































































































































































