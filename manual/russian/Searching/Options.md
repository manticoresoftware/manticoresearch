# Параметры поиска

SQL-клауза [SELECT](../Searching/Full_text_matching/Basic_usage.md#SQL) и HTTP-эндпоинт [/search](../Searching/Full_text_matching/Basic_usage.md#HTTP-JSON) поддерживают ряд параметров, которые можно использовать для тонкой настройки поведения поиска.

## OPTION

### Общий синтаксис

<!-- example options -->

**SQL**:

```sql
SELECT ... [OPTION <optionname>=<value> [ , ... ]] [/*+ [NO_][ColumnarScan|DocidIndex|SecondaryIndex(<attribute>[,...])]] /*]
```

**HTTP**:
```json
POST /search
{
    "table" : "table_name",
    "options":
    {
        "optionname": "value",
        "optionname2": <value2>
    }
}
```


<!-- intro -->
SQL:
<!-- request SQL -->
```sql
SELECT * FROM test WHERE MATCH('@title hello @body world')
OPTION ranker=bm25, max_matches=3000,
field_weights=(title=10, body=3), agent_query_timeout=10000
```

<!-- response SQL -->
```sql
+------+-------+-------+
| id   | title | body  |
+------+-------+-------+
|    1 | hello | world |
+------+-------+-------+
1 row in set (0.00 sec)
```

<!-- intro -->
JSON:
<!-- request JSON -->

```json
POST /search
{
    "table" : "test",
    "query": {
      "match": {
        "title": "hello"
      },
      "match": {
        "body": "world"
      }
    },
    "options":
    {
        "ranker": "bm25",
        "max_matches": 3000,
        "field_weights": {
            "title": 10,
            "body": 3
        },
        "agent_query_timeout": 10000
    }
}
```

<!-- response JSON -->

```json
{
  "took": 0,
  "timed_out": false,
  "hits": {
    "total": 1,
    "total_relation": "eq",
    "hits": [
      {
        "_id": 1,
        "_score": 10500,
        "_source": {
          "title": "hello",
          "body": "world"
        }
      }
    ]
  }
}
```

<!-- end -->

Поддерживаемые параметры:

### accurate_aggregation
Целое число. Включает или отключает гарантированную точность агрегирования при выполнении запросов groupby в нескольких потоках. По умолчанию 0.

При выполнении запроса groupby он может выполняться параллельно на обычной таблице с несколькими псевдо-шейдами (если включен `pseudo_sharding`). Аналогичный подход работает на RT-таблицах. Каждый шейд/чанк выполняет запрос, но число групп ограничено `max_matches`. Если результирующие наборы из разных шейдов/чанков содержат разные группы, подсчёты групп и агрегаты могут быть неточными. Обратите внимание, что Manticore пытается увеличить `max_matches` до [`max_matches_increase_threshold`](../Searching/Options.md#max_matches_increase_threshold) на основе количества уникальных значений атрибута группировки (полученных из вторичных индексов). Если удаётся, то потерь в точности не будет.

Однако, если количество уникальных значений атрибута группировки высоко, дальнейшее увеличение `max_matches` может быть плохой стратегией, так как это приведёт к снижению производительности и увеличению использования памяти. Установка `accurate_aggregation` в 1 заставляет выполнять запросы groupby в одном потоке, что исправляет проблему точности. Обратите внимание, что выполнение в одном потоке принудительно только если невозможно установить достаточно высокий `max_matches`; в противном случае запросы с `accurate_aggregation=1` всё ещё будут выполняться в нескольких потоках.

В целом, установка `accurate_aggregation` в 1 гарантирует точность подсчёта групп и агрегатов в RT-таблицах и обычных таблицах с `pseudo_sharding=1`. Недостаток — запросы будут выполняться медленнее, так как им придётся работать в одном потоке.

Однако, если у нас есть RT-таблица и обычная таблица с одинаковыми данными и мы запускаем запрос с `accurate_aggregation=1`, мы всё равно можем получить разные результаты. Это происходит потому, что демон может выбирать разные настройки `max_matches` для RT и обычных таблиц из-за настройки [`max_matches_increase_threshold`](../Searching/Options.md#max_matches_increase_threshold).

### agent_query_timeout
Целое число. Максимальное время в миллисекундах, в течение которого ждут завершения удалённых запросов, см. [этот раздел](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_query_timeout).

### boolean_simplify
`0` или `1` (по умолчанию `1`). Значение `boolean_simplify=1` включает [упрощение запроса](../Searching/Full_text_matching/Boolean_optimization.md) для ускорения его выполнения.

Этот параметр также можно установить глобально в [конфигурации searchd](../Server_settings/Searchd.md#boolean_simplify) для изменения поведения по умолчанию для всех запросов. Параметр в запросе переопределит глобальную настройку.

### comment
Строка, комментарий пользователя, который копируется в файл журнала запросов.

### cutoff
Целое число. Определяет максимальное количество совпадений для обработки. Если не задано, Manticore выберет подходящее значение автоматически.

<!-- example cutoff_aggregation -->

* `N = 0`: Отключает ограничение на количество совпадений.
* `N > 0`: Инструктирует Manticore прекратить обработку результатов, как только будет найдено `N` совпадающих документов.
* Не задано: Manticore определяет порог автоматически.

Если Manticore не может определить точное количество совпадающих документов, поле `total_relation` в [метаинформации](../Node_info_and_management/SHOW_META.md#SHOW-META) запроса покажет `gte`, что означает **Больше или равно**. Это указывает на то, что фактическое количество совпадений по крайней мере равно указанному в `total_found` (в SQL) или `hits.total` (в JSON). Если количество точное, `total_relation` покажет `eq`.

Примечание: использование `cutoff` в агрегирующих запросах не рекомендуется, так как это может привести к неточным или неполным результатам.

<!-- request Example -->

Использование `cutoff` в агрегирующих запросах может привести к некорректным или вводящим в заблуждение результатам, как показано на следующем примере:
```
drop table if exists t
--------------

Query OK, 0 rows affected (0.02 sec)

--------------
create table t(a int)
--------------

Query OK, 0 rows affected (0.04 sec)

--------------
insert into t(a) values(1),(2),(3),(1),(2),(3)
--------------

Query OK, 6 rows affected (0.00 sec)

--------------
select avg(a) from t option cutoff=1 facet a
--------------

+----------+
| avg(a)   |
+----------+
| 1.000000 |
+----------+
1 row in set (0.00 sec)
--- 1 out of 1 results in 0ms ---

+------+----------+
| a    | count(*) |
+------+----------+
|    1 |        1 |
+------+----------+
1 row in set (0.00 sec)
--- 1 out of 1 results in 0ms ---
```

Сравните с тем же запросом без `cutoff`:
```
--------------
select avg(a) from t facet a
--------------

+----------+
| avg(a)   |
+----------+
| 2.000000 |
+----------+
1 row in set (0.00 sec)
--- 1 out of 1 results in 0ms ---

+------+----------+
| a    | count(*) |
+------+----------+
|    1 |        2 |
|    2 |        2 |
|    3 |        2 |
+------+----------+
3 rows in set (0.00 sec)
--- 3 out of 3 results in 0ms ---
```

<!-- end -->

### distinct_precision_threshold
Целое число. Значение по умолчанию – `3500`. Этот параметр задаёт порог, ниже которого подсчёты, возвращаемые `count distinct`, гарантируются как точные в обычной таблице.

Допустимые значения в диапазоне от `500` до `15500`. Значения вне этого диапазона будут ограничены.

Если этот параметр установлен в 0, включается алгоритм, обеспечивающий точные подсчёты. Этот алгоритм собирает пары `{группа, значение}`, сортирует их и периодически устраняет дубликаты. В результате подсчёты точны для обычной таблицы. Однако такой подход не подходит для наборов с высокой кардинальностью из-за высокого потребления памяти и медленного выполнения запросов.

Когда `distinct_precision_threshold` установлен в значение больше 0, Manticore использует другой алгоритм. Он загружает подсчёты в хеш-таблицу и возвращает размер таблицы. Если хеш-таблица становится слишком большой, её содержимое переводится в структуру данных `HyperLogLog`. В этот момент подсчёты становятся приблизительными, потому что HyperLogLog — вероятностный алгоритм. Такой подход поддерживает фиксированный максимальный объём памяти на группу, но возникает компромисс в точности подсчётов.

Точность `HyperLogLog` и порог для перехода из хеш-таблицы в `HyperLogLog` исходят из настройки `distinct_precision_threshold`. Важно использовать этот параметр с осторожностью, так как удвоение его значения также удвоит максимум используемой памяти для вычислений. Максимальное использование памяти можно примерно оценить по формуле: `64 * max_matches * distinct_precision_threshold`, хотя на практике подсчёты часто используют меньше памяти, чем в худшем случае.

### expand_keywords
`0` или `1` (по умолчанию `0`). Расширяет ключевые слова с точными формами и/или звёздочками, если это возможно. Подробнее см. [expand_keywords](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#expand_keywords).

### field_weights
Названный список целых чисел (веса пользователя для ранжирования по полям).

Пример:
```sql
SELECT ... OPTION field_weights=(title=10, body=3)
```

### global_idf
Использовать глобальную статистику (частоты) из файла [global_idf](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#global_idf) для вычисления IDF.

### idf
Взятый в кавычки, разделённый запятыми список флагов вычисления IDF. Известные флаги:

* `normalized`: вариант BM25, idf = log((N-n+1)/n), согласно Робертсону и др.
* `plain`: простой вариант, idf = log(N/n), согласно Спарк-Джонсу
* `tfidf_normalized`: дополнительно делить IDF на количество слов в запросе, чтобы `TF*IDF` укладывался в диапазон [0, 1]
* `tfidf_unnormalized`: не делить дополнительно IDF на количество слов в запросе, где N — размер коллекции, а n — количество совпавших документов

Исторически по умолчанию IDF (обратная документная частота) в Manticore эквивалентен `OPTION idf='normalized,tfidf_normalized'`, и эти нормализации могут вызывать несколько нежелательных эффектов.

Во-первых, `idf=normalized` вызывает штрафование ключевых слов. Например, если вы ищете `the | something` и `the` встречается в более чем 50% документов, то документы с обоими ключевыми словами `the` и `something` будут получать меньший вес, чем документы только с ключевым словом `something`. Использование `OPTION idf=plain` этого избегает. Простой IDF варьируется в диапазоне `[0, log(N)]`, и ключевые слова никогда не штрафуются; в то время как нормализованный IDF варьируется в диапазоне `[-log(N), log(N)]`, и слишком частые ключевые слова штрафуются.

Во-вторых, `idf=tfidf_normalized` приводит к дрейфу IDF между запросами. Исторически IDF также делился на количество слов в запросе, что гарантировало, что сумма `sum(tf*idf)` по всем ключевым словам оставалась в диапазоне [0,1]. Однако это означало, что запросы вроде `word1` и `word1 | nonmatchingword2` присваивали разный вес одному и тому же набору результатов, так как IDF для `word1` и `nonmatchingword2` делились на 2. Использование `OPTION idf='tfidf_unnormalized'` решает эту проблему. Учтите, что коэффициенты ранжирования BM25, BM25A, BM25F() будут корректироваться соответствующим образом при отключении этой нормализации.

Флаги IDF могут комбинироваться; `plain` и `normalized` взаимоисключающи; `tfidf_unnormalized` и `tfidf_normalized` также взаимоисключающи; и неуказанные флаги в таких взаимоисключающих группах принимаются по умолчанию. Это значит, что `OPTION idf=plain` эквивалентно полному указанию `OPTION idf='plain,tfidf_normalized'`.

### jieba_mode
Задает режим сегментации Jieba для запроса.

При использовании сегментации китайского языка Jieba иногда полезно применять разные режимы сегментации для токенизации документов и запроса. Полный список режимов см. в [jieba_mode](../Creating_a_table/NLP_and_tokenization/Morphology.md#jieba_mode).

### index_weights
Названный список целых чисел. Веса пользователя для ранжирования по таблицам.

### local_df
`0` или `1`, автоматически суммирует DF по всем локальным частям распределённой таблицы, обеспечивая согласованный (и точный) IDF для локально шарденных таблиц. Включено по умолчанию для дисковых чанков таблицы RT. Термины запроса со звёздочками игнорируются.

### low_priority
`0` или `1` (по умолчанию `0`). Установка `low_priority=1` выполняет запрос с пониженным приоритетом, планируя его задачи в 10 раз реже, чем другие запросы с нормальным приоритетом.

### max_matches
Целое число. Максимальное количество совпадений на запрос.

Максимальное число совпадений, которое сервер хранит в ОЗУ для каждой таблицы и может вернуть клиенту. По умолчанию — 1000.

Введено для контроля и ограничения использования ОЗУ, настройка `max_matches` определяет, сколько совпадений будет храниться в памяти при поиске по каждой таблице. Каждое найденное совпадение всё ещё обрабатывается, но в память и клиенту возвращаются только лучшие N из них. Например, если в таблице найдено 2 000 000 совпадений по запросу, редко нужно извлекать их все. Вместо этого требуется просканировать все, но выбрать, скажем, лучшие 500 по какому-то критерию (например, по релевантности, цене и т. п.) и показать пользователю постранично от 20 до 100 совпадений. Отслеживание только лучших 500 значительно эффективнее по использованию памяти и CPU, чем хранение всех 2 000 000, сортировка и отбрасывание лишних, чтобы взять только первые 20 нужных для страницы результатов. `max_matches` контролирует именно эту величину N лучших.

Этот параметр существенно влияет на использование ОЗУ и CPU на запрос. Значения от 1000 до 10 000 обычно приемлемы, но более высокие следует применять с осторожностью. Неосмотрительное увеличение `max_matches` до 1 000 000 заставит `searchd` выделять и инициализировать буфер с 1 миллионом элементов для каждого запроса. Это неизбежно повысит использование памяти на запрос и в некоторых случаях заметно повлияет на производительность.

Дополнительную информацию о влиянии на поведение опции `max_matches` см. в [max_matches_increase_threshold](../Searching/Options.md#max_matches_increase_threshold).

### max_matches_increase_threshold

Целое число. Задает порог, до которого `max_matches` может быть увеличен. По умолчанию 16384.

Manticore может увеличить `max_matches` для повышения точности группировок и/или агрегаций при включенном `pseudo_sharding`, если обнаружит, что количество уникальных значений атрибута группировки меньше этого порога. Потеря точности возможна, когда при псевдо-шардинге запрос выполняется в нескольких потоках или когда таблица RT ведёт параллельные поиски по дисковым чанкам.

Если количество уникальных значений атрибута группировки меньше порога, `max_matches` будет установлен в это число. В противном случае будет использовано значение по умолчанию.

Если `max_matches` явно задан в опциях запроса, этот порог не действует.

Учтите, что слишком высокий порог приведёт к увеличенному потреблению памяти и общему снижению производительности.

Вы также можете включить гарантированный режим точности groupby/aggregate, используя опцию [accurate_aggregation](../Searching/Options.md#accurate_aggregation).

### max_query_time
Устанавливает максимальное время выполнения поискового запроса в миллисекундах. Значение должно быть неотрицательным целым числом. Значение по умолчанию — 0, что означает «без ограничений». Локальные поисковые запросы будут остановлены после истечения указанного времени. Обратите внимание, что если вы выполняете поиск с запросом к нескольким локальным таблицам, это ограничение применяется отдельно к каждой таблице. Учтите, что это может немного увеличить время ответа запроса из-за накладных расходов на постоянный контроль необходимости остановки запроса.

### max_predicted_time
Целое число. Максимальное прогнозируемое время выполнения поиска; см. [predicted_time_costs](../Server_settings/Searchd.md#predicted_time_costs).

### morphology
`none` позволяет заменять все термины запроса их точными формами, если таблица была построена с включённым [index_exact_words](../Creating_a_table/NLP_and_tokenization/Morphology.md#index_exact_words). Это полезно для предотвращения стемминга или лемматизации терминов запроса.

### not_terms_only_allowed
<!-- example not_terms_only_allowed -->
`0` или `1` разрешает использование отдельной [отрицательной части](../Searching/Full_text_matching/Operators.md#Negation-operator) в запросе. Значение по умолчанию — 0. См. также соответствующую [глобальную настройку](../Server_settings/Searchd.md#not_terms_only_allowed).

<!-- request SQL -->
```sql
MySQL [(none)]> select * from tbl where match('-donald');
ERROR 1064 (42000): index t: query error: query is non-computable (single NOT operator)
MySQL [(none)]> select * from t where match('-donald') option not_terms_only_allowed=1;
+---------------------+-----------+
| id                  | field     |
+---------------------+-----------+
| 1658178727135150081 | smth else |
+---------------------+-----------+
```
<!-- end -->

### ranker
Выберите из следующих вариантов:
* `proximity_bm25`
* `bm25`
* `none`
* `wordcount`
* `proximity`
* `matchany`
* `fieldmask`
* `sph04`
* `expr`
* `export`

Для получения подробностей о каждом ранжировщике смотрите [Ранжирование результатов поиска](../Searching/Sorting_and_ranking.md#Available-built-in-rankers).

### rand_seed
Позволяет указать конкретное целочисленное значение seed для запроса `ORDER BY RAND()`, например: `... OPTION rand_seed=1234`. По умолчанию для каждого запроса генерируется новое и уникальное значение seed.

### retry_count
Целое число. Количество повторных попыток в распределённом режиме.

### retry_delay
Целое число. Задержка между повторными попытками в распределённом режиме, в миллисекундах.

### scroll

Строка. Токен прокрутки для постраничного вывода результатов с использованием [подхода Scroll pagination](../Searching/Pagination.md#Scroll-Search-Option).

### sort_method
* `pq` - очередь с приоритетом, установлена по умолчанию
* `kbuffer` - обеспечивает более быструю сортировку для уже предварительно отсортированных данных, например, данных таблицы, отсортированных по id
Набор результатов одинаков в обоих случаях; выбор одного варианта может просто улучшить (или ухудшить) производительность.

### threads
Ограничивает максимальное количество потоков, используемых для обработки текущего запроса. По умолчанию — без ограничений (запрос может занять все [потоки](../Server_settings/Searchd.md#threads), определённые глобально).
Для пакета запросов опция должна быть указана в самом первом запросе пакета, затем она применяется при создании рабочей очереди и действует для всего пакета. Эта опция эквивалентна опции [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query), но применяется только к текущему запросу или пакету запросов.

### token_filter
Цитированная, разделённая двоеточиями строка вида `название библиотеки:название плагина:необязательная строка настроек`. Для каждого поиска при вызове полнотекстового поиска каждой задействованной таблицей создаётся фильтр токенов времени запроса, позволяя реализовать пользовательский токенизатор, который генерирует токены по своим правилам.
```sql
SELECT * FROM index WHERE MATCH ('yes@no') OPTION token_filter='mylib.so:blend:@'
```
### expansion_limit
Ограничивает максимальное количество расширенных ключевых слов для одного шаблона с подстановочными знаками, значение по умолчанию — 0, что означает отсутствие ограничений. Дополнительную информацию смотрите в разделе [expansion_limit](../Server_settings/Searchd.md#expansion_limit).

## Подсказки оптимизатора запросов

<!-- example options_force -->

В редких случаях встроенный анализатор запросов Manticore может неправильно понять запрос и определить, следует ли использовать индекс docid, вторичные индексы или колонковое сканирование. Чтобы переопределить решения оптимизатора запросов, можно использовать следующие подсказки в вашем запросе:

* `/*+ DocidIndex(id) */`  — принудительно использовать индекс docid, `/*+ NO_DocidIndex(id) */` — игнорировать его оптимизатором
* `/*+ SecondaryIndex(<attr_name1>[, <attr_nameN>]) */` — принудительно использовать вторичный индекс (если доступен), `/*+ NO_SecondaryIndex(id) */` — игнорировать его оптимизатором
* `/*+ ColumnarScan(<attr_name1>[, <attr_nameN>]) */` — принудительно использовать колонковое сканирование (если атрибут колонковый), `/*+ NO_ColumnarScan(id) */` — игнорировать его оптимизатором

Обратите внимание, что при выполнении полнотекстового запроса с фильтрами оптимизатор запроса выбирает между пересечением результатов полнотекстового дерева с результатами фильтра или стандартным подходом «сопоставить, затем отфильтровать». Указание *любой* подсказки заставляет демон использовать путь выполнения, который пересекает результаты полнотекстового дерева с результатами фильтра.

Для получения дополнительной информации о работе оптимизатора запросов смотрите страницу [Оптимизатор на основе стоимости](../Searching/Cost_based_optimizer.md).

<!-- request SQL -->

```sql
SELECT * FROM students where age > 21 /*+ SecondaryIndex(age) */
```

<!-- end -->

<!-- example comments -->
При использовании клиента MySQL/MariaDB убедитесь, что включён флаг `--comments` для поддержки подсказок в ваших запросах.

<!-- request mysql -->
```bash
mysql -P9306 -h0 --comments
```
<!-- end -->

<!-- proofread -->

