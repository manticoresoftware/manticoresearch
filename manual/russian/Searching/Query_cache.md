# Кэш запросов

Кэш запросов хранит сжатые наборы результатов в памяти и повторно использует их для последующих запросов, когда это возможно. Вы можете настроить его с помощью следующих директив:

* [qcache_max_bytes](../Server_settings/Searchd.md#qcache_max_bytes) — ограничение на использование RAM для хранения кэшированных результатов запросов. По умолчанию 16 MB. Установка `qcache_max_bytes` в 0 полностью отключает кэш запросов.
* [qcache_thresh_msec](../Server_settings/Searchd.md#qcache_thresh_msec) — минимальное время выполнения запроса (в реальном времени) для кэширования. Запросы, которые выполняются быстрее указанного времени, *не* будут кэшироваться. По умолчанию 3000 мсек, или 3 секунды.
* [qcache_ttl_sec](../Server_settings/Searchd.md#qcache_ttl_sec) — TTL (время жизни) кэшированной записи. Запросы будут оставаться в кэше в течение этого времени. По умолчанию 60 секунд, или 1 минута.

Эти настройки можно менять на лету с помощью оператора `SET GLOBAL`:

```sql
mysql> SET GLOBAL qcache_max_bytes=128000000;
```

Эти изменения применяются сразу же, и кэшированные результаты, которые больше не соответствуют ограничениям, немедленно удаляются. При уменьшении размера кэша на лету выигрывают результаты MRU (наиболее недавно использованные).

Работа кэша запросов происходит следующим образом. При включении, каждый результат полнотекстового поиска полностью сохраняется в памяти. Это происходит после полнотекстового сопоставления, фильтрации и ранжирования, таким образом, по сути, мы сохраняем пары `total_found` {docid,weight}. Сжатые совпадения могут занимать в среднем от 2 до 12 байт на совпадение, в основном в зависимости от дельт между последовательными docid. Как только запрос завершён, мы проверяем ограничения по времени исполнения и размеру, и либо сохраняем сжатый набор результатов для повторного использования, либо отбрасываем его.

Обратите внимание, что влияние кэша запросов на использование RAM не ограничено `qcache_max_bytes`! Если, например, вы одновременно запускаете 10 параллельных запросов, каждый из которых возвращает до 1 млн совпадений (после фильтров), то пиковое временное использование RAM будет в диапазоне от 40 MB до 240 MB, даже если запросы достаточно быстрые и не кэшируются.

Запросы могут использовать кэш, когда совпадают таблица, полнотекстовый запрос (т.е. содержимое `MATCH()`) и ранжировщик, и фильтры совместимы. Это означает:

*   Полнотекстовая часть внутри `MATCH()` должна совпадать пословно (байтово). Добавьте один лишний пробел — и это уже другой запрос с точки зрения кэша запросов.
*   Ранжировщик (и его параметры, если есть, для пользовательских ранжировщиков) также должен совпадать послово (байтово).
*   Фильтры должны быть супермножеством исходных фильтров. Вы можете добавить дополнительные фильтры и всё равно попасть в кэш. (В этом случае дополнительные фильтры будут применяться к кэшированному результату.) Но если убрать хотя бы один фильтр, это будет уже новый запрос.

Записи в кэше истекают по TTL, а также инвалидируются при ротации таблиц, или при выполнении `TRUNCATE`, или при `ATTACH`. Обратите внимание, что в настоящее время записи не инвалидируются при произвольных записях в RT таблицы! Поэтому кэшированный запрос может возвращать устаревшие результаты в течение всего срока жизни TTL.

Вы можете просмотреть текущий статус кэша с помощью команды [SHOW STATUS](../Node_info_and_management/Node_status.md#SHOW-STATUS) через переменные `qcache_XXX`:

```sql
mysql> SHOW STATUS LIKE 'qcache%';
+-----------------------+----------+
| Counter               | Value    |
+-----------------------+----------+
| qcache_max_bytes      | 16777216 |
| qcache_thresh_msec    | 3000     |
| qcache_ttl_sec        | 60       |
| qcache_cached_queries | 0        |
| qcache_used_bytes     | 0        |
| qcache_hits           | 0        |
+-----------------------+----------+
6 rows in set (0.00 sec)
```
<!-- proofread -->

