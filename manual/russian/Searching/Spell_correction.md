# Исправление орфографии

Исправление орфографии, также известное как:

* Автоматическая коррекция
* Коррекция текста
* Исправление орфографических ошибок
* Толерантность к опечаткам
* "Вы имели в виду?"

и так далее, — это программная функция, которая предлагает альтернативы или автоматически исправляет введённый вами текст. Концепция исправления набранного текста восходит к 1960-м годам, когда учёный-компьютерщик Уоррен Тейтельман, также изобретший команду "отменить", представил философию вычислений под названием D.W.I.M., или "Do What I Mean" (делай, что я имею в виду). Вместо того чтобы программировать компьютеры принимать только идеально отформатированные инструкции, Тейтельман утверждал, что их следует программировать на распознавание очевидных ошибок.

Первым известным продуктом, предоставляющим функцию исправления орфографии, был Microsoft Word 6.0, выпущенный в 1993 году.

### Как это работает

Существует несколько способов реализации исправления орфографии, но важно отметить, что не существует чисто программного способа с достойным качеством преобразовать вашу ошибочно набранную "ipone" в "iphone". В основном, должна быть база данных, на которой основана система. Эта база данных может быть:

* Словарём правильно написанных слов, который, в свою очередь, может быть:
  * Основан на ваших реальных данных. Идея здесь в том, что, в основном, орфография в словаре, составленном из ваших данных, правильная, и система пытается найти слово, наиболее похожее на введённое (мы вскоре обсудим, как это можно сделать с помощью Manticore).
  * Или он может основываться на внешнем словаре, не связанном с вашими данными. Проблема, которая может возникнуть здесь, заключается в том, что ваши данные и внешний словарь могут слишком сильно отличаться: некоторые слова могут отсутствовать в словаре, в то время как другие могут отсутствовать в ваших данных.
* Не только основанным на словаре, но и учитывающим контекст, например, "white ber" будет исправлено на "white bear", а "dark ber" — на "dark beer". Контекстом может быть не только соседнее слово в вашем запросе, но и ваше местоположение, время суток, грамматика текущего предложения (чтобы изменить "there" на "their" или нет), история ваших поисков и практически любые другие факторы, которые могут повлиять на ваш замысел.
* Ещё один классический подход — использовать предыдущие поисковые запросы в качестве базы данных для исправления орфографии. Это ещё больше используется в функционале [автозаполнения](../Searching/Autocomplete.md), но также имеет смысл и для автокоррекции. Идея в том, что пользователи в основном правильно пишут слова, поэтому мы можем использовать слова из их истории поиска как источник истины, даже если у нас нет этих слов в наших документах или мы не используем внешний словарь. Здесь также возможна учёт контекста.

Manticore предоставляет опцию нечеткого поиска и команды `CALL QSUGGEST` и `CALL SUGGEST`, которые можно использовать для автоматического исправления орфографии.

## Нечеткий поиск

Функция нечеткого поиска позволяет более гибко сопоставлять, учитывая небольшие вариации или опечатки в поисковом запросе. Она работает аналогично обычному SQL-запросу `SELECT` или JSON-запросу `/search`, но предоставляет дополнительные параметры для управления поведением нечеткого сопоставления.

> ПРИМЕЧАНИЕ: Опция `fuzzy` требует [Manticore Buddy](../Installation/Manticore_Buddy.md). Если она не работает, убедитесь, что Buddy установлен.

> ПРИМЕЧАНИЕ: Опция `fuzzy` недоступна для [мультизапросов](../Searching/Multi-queries.md).

## Общий синтаксис

### SQL

<!-- example Fuzzy_Search_SQL -->

```sql
SELECT
  ...
  MATCH('...')
  ...
  OPTION fuzzy={0|1}
  [, distance=N]
  [, preserve={0|1}]
  [, layouts='{be,bg,br,ch,de,dk,es,fr,uk,gr,it,no,pt,ru,se,ua,us}']
}
```

Примечание: При выполнении нечеткого поиска через SQL, в клаузе MATCH не должно быть полнотекстовых операторов, кроме [оператора поиска фразы](../Searching/Full_text_matching/Operators.md#Phrase-search-operator), и должны быть включены только слова, которые вы хотите сопоставить.

<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
SELECT * FROM mytable WHERE MATCH('someting') OPTION fuzzy=1, layouts='us,ua', distance=2;
```

<!-- request SQL with additional filters -->
Пример более сложного запроса нечеткого поиска с дополнительными фильтрами:

```sql
SELECT * FROM mytable WHERE MATCH('someting') OPTION fuzzy=1 AND (category='books' AND price < 20);
```

<!-- request JSON -->

```json
POST /search
{
  "table": "test",
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "*": "ghbdtn"
          }
        }
      ]
    }
  },
  "options": {
    "fuzzy": true,
    "layouts": ["us", "ru"],
    "distance": 2
  }
}
```

<!-- response SQL -->

```sql
+------+-------------+
| id   | content     |
+------+-------------+
|    1 | something   |
|    2 | some thing  |
+------+-------------+
2 rows in set (0.00 sec)
```

<!-- request SQL with preserve option -->

```sql
SELECT * FROM mytable WHERE MATCH('hello wrld') OPTION fuzzy=1, preserve=1;
```

<!-- request JSON with preserve option -->

```json
POST /search
{
  "table": "test",
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "*": "hello wrld"
          }
        }
      ]
    }
  },
  "options": {
    "fuzzy": true,
    "preserve": 1
  }
}
```

<!-- response SQL with preserve option -->

```sql
+------+-------------+
| id   | content     |
+------+-------------+
|    1 | hello wrld  |
|    2 | hello world |
+------+-------------+
2 rows in set (0.00 sec)
```

<!-- end -->

### JSON

```json
POST /search
{
  "table": "table_name",
  "query": {
    <full-text query>
  },
  "options": {
    "fuzzy": {true|false}
    [,"layouts": ["be","bg","br","ch","de","dk","es","fr","uk","gr","it","no","pt","ru","se","ua","us"]]
    [,"distance": N]
    [,"preserve": {0|1}]
  }
}
```

Примечание: Если вы используете [query_string](../Searching/Full_text_matching/Basic_usage.md#query_string), имейте в виду, что он не поддерживает полнотекстовые операторы, кроме [оператора поиска фразы](../Searching/Full_text_matching/Operators.md#Phrase-search-operator). Строка запроса должна состоять только из слов, которые вы хотите сопоставить.

### Опции

- `fuzzy`: Включить или выключить нечеткий поиск.
- `distance`: Установить расстояние Левенштейна для сопоставления. По умолчанию `2`.
- `preserve`: `0` или `1` (по умолчанию: `0`). При установке в `1` сохраняет слова, для которых не найдено нечетких совпадений в результатах поиска (например, "hello wrld" возвращает и "hello wrld", и "hello world"). При установке в `0` возвращает только слова с успешными нечеткими совпадениями (например, "hello wrld" возвращает только "hello world"). Особенно полезно для сохранения коротких слов или собственных имён, которые могут отсутствовать в Manticore Search.
- `layouts`: Раскладки клавиатуры для обнаружения ошибок набора, вызванных несоответствием раскладки клавиатуры (например, набор "ghbdtn" вместо "привет" при неправильной раскладке). Manticore сравнивает позиции символов в разных раскладках для предложения исправлений. Требуется минимум 2 раскладки для эффективного обнаружения несоответствий. По умолчанию раскладки не используются. Используйте пустую строку `''` (SQL) или массив `[]` (JSON), чтобы отключить эту функцию. Поддерживаемые раскладки включают:
  - `be` - бельгийская раскладка AZERTY
  - `bg` - стандартная болгарская раскладка
  - `br` - бразильская раскладка QWERTY
  - `ch` - швейцарская раскладка QWERTZ
  - `de` - немецкая раскладка QWERTZ
  - `dk` - датская раскладка QWERTY
  - `es` - испанская раскладка QWERTY
  - `fr` - французская раскладка AZERTY
  - `uk` - британская раскладка QWERTY
  - `gr` - греческая раскладка QWERTY
  - `it` - итальянская раскладка QWERTY
  - `no` - норвежская раскладка QWERTY
  - `pt` - португальская раскладка QWERTY
  - `ru` - русская раскладка JCUKEN
  - `se` - шведская раскладка QWERTY
  - `ua` - украинская раскладка JCUKEN
  - `us` - американская раскладка QWERTY


### Ссылки

* <a href="https://github.manticoresearch.com/manticoresoftware/manticoresearch?query=fature&filters%5Bcomment%5D%5B%5D=28798446&filters%5Bcommon%5D%5Brepo_id%5D%5B%5D=95614931&sort=&search=keyword-search-fuzzy-layouts">Эта демонстрация</a> показывает функциональность нечеткого поиска:
  ![Пример нечеткого поиска](fuzzysearch.png){.scale-0.7}
* Пост в блоге о нечетком поиске и автозаполнении - https://manticoresearch.com/blog/new-fuzzy-search-and-autocomplete/

## CALL QSUGGEST, CALL SUGGEST

Обе команды доступны через SQL и поддерживают запросы как к локальным (обычным и реального времени), так и к распределённым таблицам. Синтаксис следующий:
```sql
CALL QSUGGEST(<word or words>, <table name> [,options])
CALL SUGGEST(<word or words>, <table name> [,options])

options: N as option_name[, M as another_option, ...]
```

Эти команды предоставляют все предложения из словаря для заданного слова. Они работают только с таблицами, у которых включён [infixing](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) и [dict=keywords](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict). Они возвращают предложенные ключевые слова, расстояние Левенштейна между предложенным и исходным ключевым словом, а также статистику документов по предложенному ключевому слову.

Если первый параметр содержит несколько слов, то:
* `CALL QSUGGEST` вернёт предложения только для **последнего** слова, игнорируя остальные.
* `CALL SUGGEST` вернёт предложения только для **первого** слова.

Это единственное различие между ними. Поддерживается несколько опций для настройки:

| Опция | Описание | По умолчанию |
| - | - | - |
| limit | Возвращает N лучших совпадений | 5 |
| max_edits | Оставляет только слова из словаря с расстоянием Левенштейна меньше или равным N | 4 |
| result_stats | Предоставляет расстояние Левенштейна и количество документов для найденных слов | 1 (включено) |
| delta_len | Оставляет только слова из словаря с разницей в длине меньше N | 3 |
| max_matches | Количество совпадений для сохранения | 25 |
| reject | Отклонённые слова — это совпадения, которые не лучше тех, что уже в очереди совпадений. Они помещаются в очередь отклонённых, которая сбрасывается, если одно из них может попасть в очередь совпадений. Этот параметр определяет размер очереди отклонённых (как reject*max(max_matched,limit)). Если очередь отклонённых заполнена, движок прекращает поиск потенциальных совпадений | 4 |
| result_line | альтернативный режим отображения данных, возвращая все предложения, расстояния и документы по одной строке | 0 |
| non_char | не пропускать слова из словаря с неалфавитными символами | 0 (пропускать такие слова) |
| sentence | Возвращает исходное предложение с заменой последнего слова на найденное совпадение. | 0 (не возвращать полное предложение) |
| force_bigrams | Принудительно использовать биграммы (2-символьные n-граммы) вместо триграмм для всех длин слов, что может улучшить совпадения для слов с ошибками перестановки | 0 (использовать триграммы для слов ≥6 символов) |

Чтобы показать, как это работает, создадим таблицу и добавим в неё несколько документов.

```sql
create table products(title text) min_infix_len='2';
insert into products values (0,'Crossbody Bag with Tassel'), (0,'microfiber sheet set'), (0,'Pet Hair Remover Glove');
```
<!-- example single -->
##### Пример с одним словом
Как видите, неправильно введённое слово "crossb**U**dy" исправляется на "crossbody". По умолчанию `CALL SUGGEST/QSUGGEST` возвращают:

* `distance` - расстояние Левенштейна, показывающее, сколько изменений пришлось сделать, чтобы преобразовать заданное слово в предложение
* `docs` - количество документов, содержащих предложенное слово

Чтобы отключить отображение этой статистики, можно использовать опцию `0 as result_stats`.


<!-- intro -->
##### Пример:

<!-- request Example -->

```sql
call suggest('crossbudy', 'products');
```
<!-- response Example -->

```sql
+-----------+----------+------+
| suggest   | distance | docs |
+-----------+----------+------+
| crossbody | 1        | 1    |
+-----------+----------+------+
```
<!-- end -->
<!-- example first -->
##### CALL SUGGEST берёт только первое слово
Если первый параметр содержит не одно, а несколько слов, то `CALL SUGGEST` вернёт предложения только для первого слова.


<!-- intro -->
##### Пример:

<!-- request Example -->

```sql
call suggest('bagg with tasel', 'products');
```
<!-- response Example -->

```sql
+---------+----------+------+
| suggest | distance | docs |
+---------+----------+------+
| bag     | 1        | 1    |
+---------+----------+------+
```
<!-- end -->
<!-- example last -->
##### CALL QSUGGEST берёт только последнее слово
Если первый параметр содержит не одно, а несколько слов, то `CALL QSUGGEST` вернёт предложения только для последнего слова.


<!-- intro -->
##### Пример:

<!-- request Example -->

```sql
CALL QSUGGEST('bagg with tasel', 'products');
```
<!-- response Example -->

```sql
+---------+----------+------+
| suggest | distance | docs |
+---------+----------+------+
| tassel  | 1        | 1    |
+---------+----------+------+
```
<!-- end -->

<!-- example last2 -->

Добавление `1 as sentence` заставляет `CALL QSUGGEST` возвращать полное предложение с исправленным последним словом.

<!-- request Example -->
```sql
CALL QSUGGEST('bag with tasel', 'products', 1 as sentence);
```
<!-- response Example -->
```sql
+-------------------+----------+------+
| suggest           | distance | docs |
+-------------------+----------+------+
| bag with tassel   | 1        | 1    |
+-------------------+----------+------+
```
<!-- end -->

##### Другой режим отображения
Опция `1 as result_line` меняет способ отображения предложений в выводе. Вместо того, чтобы показывать каждое предложение в отдельной строке, она выводит все предложения, расстояния и документы в одной строке. Вот пример для демонстрации:

<!-- intro -->
##### Пример:

<!-- request Example -->

```sql
CALL QSUGGEST('bagg with tasel', 'products', 1 as result_line);
```
<!-- response Example -->

```sql
+----------+--------+
| name     | value  |
+----------+--------+
| suggests | tassel |
| distance | 1      |
| docs     | 1      |
+----------+--------+
```
<!-- end -->

##### Использование force_bigrams для лучшей обработки перестановок
Опция `force_bigrams` помогает с словами, в которых есть ошибки перестановки, например "ipohne" вместо "iphone". Используя биграммы вместо триграмм, алгоритм лучше справляется с перестановками символов.

<!-- intro -->
##### Пример:

<!-- request Example -->

```sql
CALL SUGGEST('ipohne', 'products', 1 as force_bigrams);
```
<!-- response Example -->

```sql
+--------+----------+------+
| suggest| distance | docs |
+--------+----------+------+
| iphone | 2        | 1    |
+--------+----------+------+
```
<!-- end -->

### Демонстрация

* [Этот интерактивный курс](https://play.manticoresearch.com/didyoumean/) показывает, как работает `CALL SUGGEST` в небольшом веб-приложении.

![Пример CALL SUGGEST](didyoumean.png){.scale-0.5}


<!-- proofread -->

