# Исправление орфографии

Исправление орфографии, также известное как:

* Автоматическая коррекция
* Коррекция текста
* Исправление орфографических ошибок
* Допуск опечаток
* «Вы имели в виду?»

и так далее, — это программная функция, которая предлагает альтернативы или автоматически исправляет введённый вами текст. Концепция исправления набранного текста восходит к 1960-м годам, когда компьютерный учёный Уоррен Тейтельман, также изобретший команду «отмена» (undo), предложил философию вычислений под названием D.W.I.M., или «Do What I Mean» («Делай, что я имею в виду»). Вместо того чтобы программировать компьютеры принимать только идеально отформатированные инструкции, Тейтельман утверждал, что их следует программировать на распознавание очевидных ошибок.

Первым широко известным продуктом, предоставившим функцию исправления орфографии, был Microsoft Word 6.0, выпущенный в 1993 году.

### Как это работает

Существуют разные способы исправления орфографии, но важно понимать, что не существует чисто программного способа преобразовать ошибочно набранное «ipone» в «iphone» с достойным качеством. В большинстве случаев необходим набор данных, на котором основана система. Набор данных может быть:

* Словарём правильно написанных слов, который, в свою очередь, может быть:
  * Основан на ваших реальных данных. Идея здесь в том, что, в большинстве случаев, написание слов в словаре, составленном из ваших данных, корректно, и система пытается найти слово, наиболее похожее на введённое (мы скоро рассмотрим, как это можно сделать с помощью Manticore).
  * Или он может основываться на внешнем словаре, не связанном с вашими данными. Проблема, которая может возникнуть здесь, заключается в том, что ваши данные и внешний словарь могут слишком сильно отличаться: одни слова могут отсутствовать в словаре, другие — в ваших данных.
* Не только на основе словаря, но и учитывая контекст, например, «white ber» будет исправлено на «white bear», а «dark ber» — на «dark beer». Контекстом может быть не только соседнее слово в запросе, но и ваше местоположение, время суток, грамматика текущего предложения (чтобы заменить «there» на «their» или нет), история ваших поисков и практически любые другие факторы, которые могут повлиять на смысл запроса.
* Ещё один классический подход — использовать предыдущие поисковые запросы как набор данных для исправления орфографии. Этим чаще всего пользуются в функционале [автозаполнения](../Searching/Autocomplete.md), но он также имеет смысл и для автокоррекции. Идея в том, что пользователи в большинстве случаев правильно пишут, поэтому мы можем использовать слова из их истории поиска как основу, даже если этих слов нет в наших документах или внешнем словаре. Также возможно учитывать контекст.

Manticore предоставляет опцию нечеткого поиска и команды `CALL QSUGGEST` и `CALL SUGGEST`, которые можно использовать для автоматического исправления орфографии.

## Нечеткий поиск

Функция нечеткого поиска позволяет более гибко сопоставлять, учитывая незначительные вариации или опечатки в поисковом запросе. Она работает аналогично обычному SQL-запросу `SELECT` или JSON-запросу `/search`, но предоставляет дополнительные параметры для управления поведением нечеткого сопоставления.

> ПРИМЕЧАНИЕ: Опция `fuzzy` требует [Manticore Buddy](../Installation/Manticore_Buddy.md). Если она не работает, убедитесь, что Buddy установлен.

## Общий синтаксис

### SQL

<!-- example Fuzzy_Search_SQL -->

```sql
SELECT
  ...
  MATCH('...')
  ...
  OPTION fuzzy={0|1}
  [, distance=N]
  [, preserve={0|1}]
  [, layouts='{be,bg,br,ch,de,dk,es,fr,uk,gr,it,no,pt,ru,se,ua,us}']
}
```

Примечание: При выполнении нечеткого поиска через SQL, в клаузе MATCH не должно быть полнотекстовых операторов, кроме [оператора поиска фразы](../Searching/Full_text_matching/Operators.md#Phrase-search-operator), и она должна содержать только те слова, которые вы хотите сопоставлять.

<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
SELECT * FROM mytable WHERE MATCH('someting') OPTION fuzzy=1, layouts='us,ua', distance=2;
```

<!-- request SQL with additional filters -->
Пример более сложного запроса нечеткого поиска с дополнительными фильтрами:

```sql
SELECT * FROM mytable WHERE MATCH('someting') OPTION fuzzy=1 AND (category='books' AND price < 20);
```

<!-- request JSON -->

```json
POST /search
{
  "table": "test",
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "*": "ghbdtn"
          }
        }
      ]
    }
  },
  "options": {
    "fuzzy": true,
    "layouts": ["us", "ru"],
    "distance": 2
  }
}
```

<!-- response SQL -->

```sql
+------+-------------+
| id   | content     |
+------+-------------+
|    1 | something   |
|    2 | some thing  |
+------+-------------+
2 rows in set (0.00 sec)
```

<!-- request SQL with preserve option -->

```sql
SELECT * FROM mytable WHERE MATCH('hello wrld') OPTION fuzzy=1, preserve=1;
```

<!-- request JSON with preserve option -->

```json
POST /search
{
  "table": "test",
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "*": "hello wrld"
          }
        }
      ]
    }
  },
  "options": {
    "fuzzy": true,
    "preserve": 1
  }
}
```

<!-- response SQL with preserve option -->

```sql
+------+-------------+
| id   | content     |
+------+-------------+
|    1 | hello wrld  |
|    2 | hello world |
+------+-------------+
2 rows in set (0.00 sec)
```

<!-- end -->

### JSON

```json
POST /search
{
  "table": "table_name",
  "query": {
    <full-text query>
  },
  "options": {
    "fuzzy": {true|false}
    [,"layouts": ["be","bg","br","ch","de","dk","es","fr","uk","gr","it","no","pt","ru","se","ua","us"]]
    [,"distance": N]
    [,\"preserve\": {0|1}]
  }
}
```

Примечание: Если вы используете [query_string](../Searching/Full_text_matching/Basic_usage.md#query_string), имейте в виду, что он не поддерживает полнотекстовые операторы, кроме [оператора поиска фразы](../Searching/Full_text_matching/Operators.md#Phrase-search-operator). Строка запроса должна содержать только те слова, которые вы хотите сопоставить.

### Опции

- `fuzzy`: Включить или выключить нечеткий поиск.
- `distance`: Установить расстояние Левенштейна для сопоставления. По умолчанию — `2`.
- `preserve`: `0` или `1` (по умолчанию: `0`). При значении `1` в результатах поиска сохраняются слова, которые не имеют нечетких совпадений (например, «hello wrld» вернет и «hello wrld», и «hello world»). При значении `0` возвращаются только слова с успешными нечеткими совпадениями (например, «hello wrld» вернет только «hello world»). Особенно полезно для сохранения коротких слов или собственных имён, которые могут отсутствовать в Manticore Search.
- `layouts`: Раскладки клавиатуры для обнаружения ошибочного ввода, вызванного несоответствием раскладок (например, набор «ghbdtn» вместо «привет» при неправильной раскладке). Manticore сравнивает позиции символов в разных раскладках, чтобы предложить исправления. Для эффективного обнаружения несоответствий требуется минимум 2 раскладки. По умолчанию раскладки не используются. Для отключения используйте пустую строку `''` (SQL) или массив `[]` (JSON). Поддерживаемые раскладки включают:
  - `be` — бельгийская раскладка AZERTY
  - `bg` — стандартная болгарская раскладка
  - `br` — бразильская раскладка QWERTY
  - `ch` — швейцарская раскладка QWERTZ
  - `de` — немецкая раскладка QWERTZ
  - `dk` — датская раскладка QWERTY
  - `es` — испанская раскладка QWERTY
  - `fr` — французская раскладка AZERTY
  - `uk` — британская раскладка QWERTY
  - `gr` — греческая раскладка QWERTY
  - `it` — итальянская раскладка QWERTY
  - `no` — норвежская раскладка QWERTY
  - `pt` — португальская раскладка QWERTY
  - `ru` — русская раскладка JCUKEN
  - `se` — шведская раскладка QWERTY
  - `ua` — украинская раскладка JCUKEN
  - `us` — американская раскладка QWERTY


### Ссылки

* <a href="https://github.manticoresearch.com/manticoresoftware/manticoresearch?query=fature&filters%5Bcomment%5D%5B%5D=28798446&filters%5Bcommon%5D%5Brepo_id%5D%5B%5D=95614931&sort=&search=keyword-search-fuzzy-layouts">Эта демонстрация</a> показывает работу функции нечеткого поиска:
  ![Пример нечеткого поиска](fuzzysearch.png){.scale-0.7}
* Пост в блоге о нечетком поиске и автозаполнении - https://manticoresearch.com/blog/new-fuzzy-search-and-autocomplete/

## CALL QSUGGEST, CALL SUGGEST

Обе команды доступны через SQL и поддерживают запросы как к локальным (обычным и реального времени), так и к распределённым таблицам. Синтаксис следующий:
```sql
CALL QSUGGEST(<word or words>, <table name> [,options])
CALL SUGGEST(<word or words>, <table name> [,options])

options: N as option_name[, M as another_option, ...]
```

Эти команды предоставляют все предложения из словаря для заданного слова. Они работают только с таблицами, у которых включён [infixing](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) и [dict=keywords](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict). Команды возвращают предложенные ключевые слова, расстояние Левенштейна между предложенным и исходным ключевым словом, а также статистику документов для предложенного ключевого слова.

Если первый параметр содержит несколько слов, то:
* `CALL QSUGGEST` вернёт предложения только для **последнего** слова, игнорируя остальные.
* `CALL SUGGEST` вернёт предложения только для **первого** слова.

Это единственное различие между ними. Для настройки поддерживаются несколько опций:

| Опция | Описание | Значение по умолчанию |
| - | - | - |
| limit | Возвращает N лучших совпадений | 5 |
| max_edits | Оставляет только слова из словаря с расстоянием Левенштейна меньше или равно N | 4 |
| result_stats | Показывает расстояние Левенштейна и количество документов найденных слов | 1 (включено) |
| delta_len | Оставляет только слова из словаря с разницей в длине меньше N | 3 |
| max_matches | Количество сохраняемых совпадений | 25 |
| reject | Отклонённые слова — это совпадения, которые не лучше уже находящихся в очереди совпадений. Они помещаются в очередь отклонённых слов, которая сбрасывается, если какое-то слово может попасть в очередь совпадений. Этот параметр задаёт размер очереди отклонённых слов (как reject*max(max_matched,limit)). Если очередь отклонённых заполнена, поиск потенциальных совпадений останавливается | 4 |
| result_line | альтернативный режим отображения данных, возвращая все предложения, расстояния и количество документов отдельными строками | 0 |
| non_char | не пропускать слова из словаря с нелитературными символами | 0 (пропускать такие слова) |
| sentence | Возвращает исходное предложение с последним словом, заменённым на найденное совпадение | 0 (не возвращать все предложение) |

Чтобы показать, как это работает, давайте создадим таблицу и добавим туда несколько документов.

```sql
create table products(title text) min_infix_len='2';
insert into products values (0,'Crossbody Bag with Tassel'), (0,'microfiber sheet set'), (0,'Pet Hair Remover Glove');
```
<!-- example single -->
##### Пример с одним словом
Как видите, ошибочно введённое слово "crossb**U**dy" исправляется на "crossbody". По умолчанию, `CALL SUGGEST/QSUGGEST` возвращают:

* `distance` — расстояние Левенштейна, то есть, сколько изменений было сделано, чтобы преобразовать исходное слово в предложение
* `docs` — количество документов, содержащих предложенное слово

Чтобы отключить показ этих статистик, можно использовать опцию `0 as result_stats`.


<!-- intro -->
##### Пример:

<!-- request Example -->

```sql
call suggest('crossbudy', 'products');
```
<!-- response Example -->

```sql
+-----------+----------+------+
| suggest   | distance | docs |
+-----------+----------+------+
| crossbody | 1        | 1    |
+-----------+----------+------+
```
<!-- end -->
<!-- example first -->
##### CALL SUGGEST принимает только первое слово
Если первый параметр содержит не одно, а несколько слов, то `CALL SUGGEST` вернёт предложения только для первого слова.


<!-- intro -->
##### Пример:

<!-- request Example -->

```sql
call suggest('bagg with tasel', 'products');
```
<!-- response Example -->

```sql
+---------+----------+------+
| suggest | distance | docs |
+---------+----------+------+
| bag     | 1        | 1    |
+---------+----------+------+
```
<!-- end -->
<!-- example last -->
##### CALL QSUGGEST принимает только последнее слово
Если первый параметр содержит не одно, а несколько слов, то `CALL SUGGEST` вернёт предложения только для последнего слова.


<!-- intro -->
##### Пример:

<!-- request Example -->

```sql
CALL QSUGGEST('bagg with tasel', 'products');
```
<!-- response Example -->

```sql
+---------+----------+------+
| suggest | distance | docs |
+---------+----------+------+
| tassel  | 1        | 1    |
+---------+----------+------+
```
<!-- end -->

<!-- example last2 -->

Добавление `1 as sentence` заставляет `CALL QSUGGEST` возвращать целое предложение с исправленным последним словом.

<!-- request Example -->
```sql
CALL QSUGGEST('bag with tasel', 'products', 1 as sentence);
```
<!-- response Example -->
```sql
+-------------------+----------+------+
| suggest           | distance | docs |
+-------------------+----------+------+
| bag with tassel   | 1        | 1    |
+-------------------+----------+------+
```
<!-- end -->

##### Другой режим отображения
Опция `1 as result_line` меняет способ отображения предложений в выводе. Вместо того, чтобы показывать каждое предложение в отдельной строке, она выводит все предложения, расстояния и количество документов в одной строке. Вот пример, демонстрирующий это:

<!-- intro -->
##### Пример:

<!-- request Example -->

```sql
CALL QSUGGEST('bagg with tasel', 'products', 1 as result_line);
```
<!-- response Example -->

```sql
+----------+--------+
| name     | value  |
+----------+--------+
| suggests | tassel |
| distance | 1      |
| docs     | 1      |
+----------+--------+
```
<!-- end -->

### Демонстрация

* [Этот интерактивный курс](https://play.manticoresearch.com/didyoumean/) показывает, как работает `CALL SUGGEST` в небольшом веб-приложении.

![Пример CALL SUGGEST](didyoumean.png){.scale-0.5}


<!-- proofread -->

