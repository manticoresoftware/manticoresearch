# Исправление орфографии

Исправление орфографии, также известное как:

* Автоисправление
* Исправление текста
* Исправление орфографических ошибок
* Допуск опечаток
* "Вы имели в виду?"

и так далее, это функциональность программного обеспечения, которая предлагает альтернативы или осуществляет автоматические исправления текста, который вы ввели. Концепция исправления вводимого текста восходит к 1960-м годам, когда компьютерный ученый Уоррен Тейтлман, который также изобрел команду "отменить", представил философию вычислений, называемую D.W.I.M., или "Сделай то, что я имею в виду". Вместо программирования компьютеров для принятия только идеально отформатированных инструкций, Тейтлман утверждал, что их следует программировать на распознавание очевидных ошибок.

Первым известным продуктом, предоставляющим функциональность исправления орфографии, был Microsoft Word 6.0, выпущенный в 1993 году.

### Как это работает

Существует несколько способов осуществления исправления орфографии, но важно отметить, что нет чисто программного способа преобразовать вашу неправильно введенную "ipone" в "iphone" с приемлемым качеством. В основном, должна быть база данных, на основе которой работает система. База данных может быть:

* Словарем правильно написанных слов, который в свою очередь может быть:
  * Основан на ваших реальных данных. Идея здесь заключается в том, что в большинстве случаев орфография в словаре, составленном из ваших данных, правильная, и система пытается найти слово, наиболее похожее на введенное слово (мы вскоре обсудим, как это можно сделать с помощью Manticore).
  * Или она может основываться на внешнем словаре, не имеющем отношения к вашим данным. Проблема, которая может возникнуть здесь, заключается в том, что ваши данные и внешний словарь могут сильно отличаться: некоторые слова могут отсутствовать в словаре, в то время как другие могут отсутствовать в ваших данных.
* Не только основанным на словаре, но и учитывающим контекст, например, "белый бер" будет исправлено на "белый медведь", в то время как "темный бер" будет исправлено на "темное пиво." Контекст может быть не только соседним словом в вашем запросе, но и вашим местоположением, временем суток, грамматикой текущего предложения (изменять "там" на "их" или нет), вашей историей поиска и практически любыми другими факторами, которые могут повлиять на ваше намерение.
* Еще один классический подход заключается в использовании предыдущих поисковых запросов в качестве базы данных для исправления орфографии. Это еще больше используется в функциональности [автозавершения](../Searching/Autocomplete.md), но также имеет смысл для автоисправления. Идея заключается в том, что пользователи в большинстве случаев правильно пишут, так что мы можем использовать слова из их истории поиска в качестве источника истины, даже если у нас нет этих слов в наших документах или мы используем внешний словарь. Учет контекста также возможен здесь.

Manticore предоставляет возможность нечеткого поиска и команды `CALL QSUGGEST` и `CALL SUGGEST`, которые могут использоваться для автоматических исправлений орфографии.

## Нечеткий поиск

Функция нечеткого поиска позволяет более гибкое совпадение, учитывая легкие вариации или опечатки в поисковом запросе. Это работает аналогично обычному SQL выражению `SELECT` или JSON запросу `/search`, но предоставляет дополнительные параметры для управления поведением нечеткого совпадения.

> ЗАМЕТКА: Опция `fuzzy` требует [Manticore Buddy](../Installation/Manticore_Buddy.md). Если это не работает, убедитесь, что Buddy установлен.

## Общий синтаксис

### SQL

<!-- example Fuzzy_Search_SQL -->

```sql
SELECT
  ...
  MATCH('...')
  ...
  OPTION fuzzy={0|1}
  [, distance=N]
  [, layouts='{be,bg,br,ch,de,dk,es,fr,uk,gr,it,no,pt,ru,se,ua,us}']
}
```

Примечание: При проведении нечеткого поиска через SQL, условие MATCH не должно содержать полных текстовых операторов, кроме [оператора поискового выражения](../Searching/Full_text_matching/Operators.md#Phrase-search-operator) и должно включать только слова, которые вы намерены сопоставить.

<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
SELECT * FROM mytable WHERE MATCH('someting') OPTION fuzzy=1, layouts='us,ua', distance=2;
```

<!-- request SQL with additional filters -->
Пример более сложного запроса нечеткого поиска с дополнительными фильтрами:

```sql
SELECT * FROM mytable WHERE MATCH('someting') OPTION fuzzy=1 AND (category='books' AND price < 20);
```

<!-- request JSON -->

```json
POST /search
{
  "table": "test",
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "*": "ghbdtn"
          }
        }
      ]
    }
  },
  "options": {
    "fuzzy": true,
    "layouts": ["us", "ru"],
    "distance": 2
  }
}
```

<!-- response SQL -->

```sql
+------+-------------+
| id   | content     |
+------+-------------+
|    1 | something   |
|    2 | some thing  |
+------+-------------+
2 rows in set (0.00 sec)
```

<!-- end -->

### JSON

```json
POST /search
{
  "table": "table_name",
  "query": {
    <full-text query>
  },
  "options": {
    "fuzzy": {true|false}
    [,"layouts": ["be","bg","br","ch","de","dk","es","fr","uk","gr","it","no","pt","ru","se","ua","us"]]
    [,"distance": N]
  }
}
```

Примечание: Если вы используете [query_string](../../Searching/Full_text_matching/Basic_usage.md#query_string), имейте в виду, что он не поддерживает полные текстовые операторы, кроме [оператора поискового выражения](../Searching/Full_text_matching/Operators.md#Phrase-search-operator). Строка запроса должна состоять исключительно из слов, которые вы хотите сопоставить.

### Опции

- `fuzzy`: Включить или отключить нечеткий поиск.
- `distance`: Установить расстояние Левенштейна для сопоставления. По умолчанию равно `2`.
- `layouts`: Раскладки клавиатуры для проверки ошибок печати. По умолчанию используются все раскладки. Используйте пустую строку `''` (SQL) или массив `[]` (JSON), чтобы отключить это. Поддерживаемые раскладки включают:
  - `be` - Бельгийская раскладка AZERTY
  - `bg` - Стандартная болгарская раскладка
  - `br` - Бразильская раскладка QWERTY
  - `ch` - Швейцарская раскладка QWERTZ
  - `de` - Немецкая раскладка QWERTZ
  - `dk` - Датская раскладка QWERTY
  - `es` - Испанская раскладка QWERTY
  - `fr` - Французская раскладка AZERTY
  - `uk` - Британская раскладка QWERTY
  - `gr` - Греческая раскладка QWERTY
  - `it` - Итальянская раскладка QWERTY
  - `no` - Норвежская раскладка QWERTY
  - `pt` - Португальская раскладка QWERTY
  - `ru` - Русская раскладка JCUKEN
  - `se` - Шведская раскладка QWERTY
  - `ua` - Украинская раскладка JCUKEN
  - `us` - Американская раскладка QWERTY


### Ссылки

* <a href="https://github.manticoresearch.com/manticoresoftware/manticoresearch?query=fature&filters%5Bcomment%5D%5B%5D=28798446&filters%5Bcommon%5D%5Brepo_id%5D%5B%5D=95614931&sort=&search=keyword-search-fuzzy-layouts">Этот демонстрационный пример</a> демонстрирует функционал нечеткого поиска:
  ![Пример нечеткого поиска](fuzzysearch.png){.scale-0.7}
* Пост в блоге о Нечетком Поиске и Автозаполнении - https://manticoresearch.com/blog/new-fuzzy-search-and-autocomplete/

## Вызов QSUGGEST, Вызов SUGGEST

Оба команды доступны через SQL и поддерживают запросы как для локальных (обычных и в реальном времени), так и для распределенных таблиц. Синтаксис следующий:
```sql
CALL QSUGGEST(<слово или слова>, <имя таблицы> [,options])
CALL SUGGEST(<слово или слова>, <имя таблицы> [,options])

options: N как option_name[, M как another_option, ...]
```

Эти команды предоставляют все предложения из словаря для данного слова. Они работают только с таблицами, у которых включено [infixing](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) и [dict=keywords](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict). Они возвращают предложенные ключевые слова, расстояние Левенштейна между предложенными и оригинальными ключевыми словами, а также статистику документов для предложенного ключевого слова.

Если первый параметр содержит несколько слов, то:
* `CALL QSUGGEST` вернет предложения только для **последнего** слова, игнорируя остальные.
* `CALL SUGGEST` вернет предложения только для **первого** слова.

Это единственное различие между ними. Поддерживается несколько опций для настройки:

| Опция        | Описание                                                       | По умолчанию |
| -            | -                                                             | -           |
| limit        | Возвращает N лучших совпадений                                 | 5           |
| max_edits    | Оставляет только слова из словаря с расстоянием Левенштейна меньше или равным N | 4           |
| result_stats | Предоставляет расстояние Левенштейна и количество документов найденных слов | 1 (включено) |
| delta_len    | Оставляет только слова из словаря с разницей в длине меньше N | 3           |
| max_matches  | Количество совпадений для сохранения                            | 25          |
| reject       | Отклоненные слова — это совпадения, которые не лучше тех, что уже в очереди совпадений. Они помещаются в очередь отклонений, которая сбрасывается в случае, если одно из них может попасть в очередь совпадений. Этот параметр определяет размер очереди отклонений (как reject*max(max_matched,limit)). Если очередь отклонений заполнена, движок прекращает поиск потенциальных совпадений | 4           |
| result_line  | альтернативный режим отображения данных, возвращая все предложения, расстояния и документы по одной строке | 0           |
| non_char     | не пропускать слова из словаря с неалфавитными символами        | 0 (пропускать такие слова) |
| sentence      | Возвращает оригинальное предложение вместе с последним словом, замененным на совпадающее.  | 0 (не возвращать полное предложение) |

Чтобы показать, как это работает, давайте создадим таблицу и добавим в нее несколько документов.

```sql
create table products(title text) min_infix_len='2';
insert into products values (0,'Сумка через плечо с кисточкой'), (0,'Комплект простыней из микрофибры'), (0,'Перчатка для удаления шерсти животных');
```
<!-- example single -->
##### Пример с одним словом
Как видите, неправильно написанное слово "crossb**U**dy" исправляется на "crossbody". По умолчанию, `CALL SUGGEST/QSUGGEST` возвращает:

* `distance` - расстояние Левенштейна, которое означает, сколько правок они должны были сделать, чтобы преобразовать данное слово в предложение
* `docs` - количество документов, содержащих предложенное слово

Чтобы отключить отображение этой статистики, вы можете использовать опцию `0 as result_stats`.


<!-- intro -->
##### Пример:

<!-- request Example -->

```sql
call suggest('crossbudy', 'products');
```
<!-- response Example -->

```sql
+-----------+----------+------+
| suggest   | distance | docs |
+-----------+----------+------+
| crossbody | 1        | 1    |
+-----------+----------+------+
```
<!-- end -->
<!-- example first -->
##### CALL SUGGEST берет только первое слово
Если первый параметр не является одним словом, а несколькими, то `CALL SUGGEST` вернет предложения только для первого слова.


<!-- intro -->
##### Пример:

<!-- request Example -->

```sql
call suggest('bagg with tasel', 'products');
```
<!-- response Example -->

```sql
+---------+----------+------+
| suggest | distance | docs |
+---------+----------+------+
| bag     | 1        | 1    |
+---------+----------+------+
```
<!-- end -->
<!-- example last -->
##### CALL QSUGGEST берет только последнее слово
Если первый параметр не является одним словом, а несколькими, то `CALL SUGGEST` вернет предложения только для последнего слова.


<!-- intro -->
##### Пример:

<!-- request Example -->

```sql
CALL QSUGGEST('bagg with tasel', 'products');
```
<!-- response Example -->

```sql
+---------+----------+------+
| suggest | distance | docs |
+---------+----------+------+
| tassel  | 1        | 1    |
+---------+----------+------+
```
<!-- end -->

<!-- example last2 -->

Добавление `1 as sentence` заставляет `CALL QSUGGEST` вернуть полное предложение с исправленным последним словом.

<!-- request Example -->
```sql
CALL QSUGGEST('bag with tasel', 'products', 1 as sentence);
```
<!-- response Example -->
```sql
+-------------------+----------+------+
| suggest           | distance | docs |
+-------------------+----------+------+
| bag with tassel   | 1        | 1    |
+-------------------+----------+------+
```
<!-- end -->

##### Режим отображения
Опция `1 as result_line` изменяет способ отображения предложений в выводе. Вместо того чтобы показывать каждое предложение в отдельной строке, она отображает все предложения, расстояния и документы в одной строке. Вот пример, чтобы продемонстрировать это:

<!-- intro -->
##### Пример:

<!-- request Example -->

```sql
CALL QSUGGEST('bagg with tasel', 'products', 1 as result_line);
```
<!-- response Example -->

```sql
+----------+--------+
| name     | value  |
+----------+--------+
| suggests | tassel |
| distance | 1      |
| docs     | 1      |
+----------+--------+
```
<!-- end -->

### Демонстрация

* [Этот интерактивный курс](https://play.manticoresearch.com/didyoumean/) показывает, как работает `CALL SUGGEST` в небольшом веб-приложении.

![Пример CALL SUGGEST](didyoumean.png){.scale-0.5}


<!-- proofread -->
# Исправление орфографии

Исправление орфографии, также известное как:

* Автоисправление
* Исправление текста
* Исправление орфографических ошибок
* Толерантность к опечаткам
* "Вы имели в виду?"

и так далее, является функциональностью программного обеспечения, которая предлагает альтернативы или делает автоматические исправления текста, который вы ввели. Концепция исправления вводимого текста восходит к 1960-м годам, когда компьютерный ученый Уоррен Тейтлман, который также изобрел команду "отмены", ввел философию вычислений, названную D.W.I.M., или "Делай то, что я имею в виду." Вместо того чтобы программировать компьютеры на принятие только идеально отформатированных инструкций, Тейтлман утверждает, что их следует программировать на распознавание очевидных ошибок.

Первым известным продуктом, предоставившим функциональность исправления орфографии, был Microsoft Word 6.0, выпущенный в 1993 году.

### Как это работает

Есть несколько способов осуществления исправления орфографии, но важно отметить, что нет чисто программного способа преобразовать вашу неверно набранную "ipone" в "iphone" с приемлемым качеством. В основном, система должна основываться на наборе данных. Набор данных может быть:

* Словарем правильно написанных слов, который, в свою очередь, может быть:
  * Основан на ваших реальных данных. Идея здесь заключается в том, что, в основном, орфография в словаре, составленном из ваших данных, правильная, и система пытается найти слово, наиболее похожее на написанное слово (мы вскоре обсудим, как это можно сделать с Manticore).
  * Или он может быть основан на внешнем словаре, не связанном с вашими данными. Проблема, которая может возникнуть здесь, заключается в том, что ваши данные и внешний словарь могут сильно различаться: некоторые слова могут отсутствовать в словаре, в то время как другие могут отсутствовать в ваших данных.
* Не только словарный, но и учитывающий контекст, например, "белый бер" будет исправлено на "белый медведь", в то время как "темный бер" будет исправлено на "темное пиво". Контекст может быть не только соседним словом в вашем запросе, но и вашим местоположением, временем суток, грамматикой текущего предложения (изменить "там" на "их" или нет), вашей историей поиска и практически любыми другими факторами, которые могут повлиять на ваше намерение.
* Другой классический подход — использовать предыдущие поисковые запросы в качестве набора данных для исправления орфографии. Это даже больше используется в [авзаполнении](../Searching/Autocomplete.md) функциональности, но также имеет смысл и для автокоррекции. Идея заключается в том, что пользователи в основном правы с орфографией, поэтому мы можем использовать слова из их истории поиска как источник правды, даже если у нас нет слов в наших документах или мы используем внешний словарь. Учет контекста также возможен здесь.

Manticore предоставляет опцию нечеткого поиска и команды `CALL QSUGGEST` и `CALL SUGGEST`, которые могут быть использованы для автоматических целей исправления орфографии.

# Нечеткий Поиск

Функция Нечеткого Поиска позволяет более гибко сопоставлять за счет учета небольших вариаций или опечаток в поисковом запросе. Она работает похоже на обычное SQL выражение `SELECT` или на JSON запрос `/search`, но предоставляет дополнительные параметры для управления поведением нечеткого сопоставления.

> ЗАМЕТКА: Опция `fuzzy` требует [Manticore Buddy](../Installation/Manticore_Buddy.md). Если это не работает, убедитесь, что Buddy установлен.

## Общий синтаксис

### SQL

<!-- example Fuzzy_Search_SQL -->

```sql
SELECT
  ...
  MATCH('...')
  ...
  OPTION fuzzy={0|1}
  [, distance=N]
  [, layouts='{be,bg,br,ch,de,dk,es,fr,uk,gr,it,no,pt,ru,se,ua,us}']
}
```

Примечание: При выполнении нечеткого поиска через SQL, оператор MATCH не должен содержать никаких операторов полнотекстового поиска, кроме [оператора поиска по фразам](../Searching/Full_text_matching/Operators.md#Phrase-search-operator) и должен содержать только те слова, которые вы намерены сопоставить.

<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
SELECT * FROM mytable WHERE MATCH('someting') OPTION fuzzy=1, layouts='us,ua', distance=2;
```

<!-- request SQL with additional filters -->
Пример более сложного запроса Нечеткого поиска с дополнительными фильтрами:

```sql
SELECT * FROM mytable WHERE MATCH('someting') OPTION fuzzy=1 AND (category='books' AND price < 20);
```

<!-- request JSON -->

```json
POST /search
{
  "table": "test",
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "*": "ghbdtn"
          }
        }
      ]
    }
  },
  "options": {
    "fuzzy": true,
    "layouts": ["us", "ru"],
    "distance": 2
  }
}
```

<!-- response SQL -->

```sql
+------+-------------+
| id   | content     |
+------+-------------+
|    1 | что-то     |
|    2 | кое-что    |
+------+-------------+
2 rows in set (0.00 sec)
```

<!-- end -->

### JSON

```json
POST /search
{
  "table": "table_name",
  "query": {
    <полнотекстовый запрос>
  },
  "options": {
    "fuzzy": {true|false}
    [,"layouts": ["be","bg","br","ch","de","dk","es","fr","uk","gr","it","no","pt","ru","se","ua","us"]]
    [,"distance": N]
  }
}
```

Примечание: Если вы используете [query_string](../../Searching/Full_text_matching/Basic_usage.md#query_string), имейте в виду, что он не поддерживает полнотекстовые операторы, кроме [оператора поиска по фразам](../Searching/Full_text_matching/Operators.md#Phrase-search-operator). Строка запроса должна состоять исключительно из слов, которые вы хотите сопоставить.

### Опции

- `fuzzy`: Включить или отключить нечеткий поиск.
- `distance`: Установить расстояние Левенштейна для сопоставления. Значение по умолчанию — `2`.
- `layouts`: Раскладки клавиатуры для проверки ошибок при вводе. Все раскладки используются по умолчанию. Используйте пустую строку `''` (SQL) или массив `[]` (JSON), чтобы отключить это. Поддерживаемые раскладки включают:
  - `be` - бельгийская раскладка AZERTY
  - `bg` - стандартная болгарская раскладка
  - `br` - бразильская раскладка QWERTY
  - `ch` - швейцарская раскладка QWERTZ
  - `de` - немецкая раскладка QWERTZ
  - `dk` - датская раскладка QWERTY
  - `es` - испанская раскладка QWERTY
  - `fr` - французская раскладка AZERTY
  - `uk` - Британская раскладка QWERTY
  - `gr` - Греческая раскладка QWERTY
  - `it` - Итальянская раскладка QWERTY
  - `no` - Норвежская раскладка QWERTY
  - `pt` - Португальская раскладка QWERTY
  - `ru` - Русская раскладка JCUKEN
  - `se` - Шведская раскладка QWERTY
  - `ua` - Украинская раскладка JCUKEN
  - `us` - Американская раскладка QWERTY


### Ссылки

* <a href="https://github.manticoresearch.com/manticoresoftware/manticoresearch?query=fature&filters%5Bcomment%5D%5B%5D=28798446&filters%5Bcommon%5D%5Brepo_id%5D%5B%5D=95614931&sort=&search=keyword-search-fuzzy-layouts">Эта демонстрация</a> демонстрирует функциональность нечеткого поиска:
  ![Пример нечеткого поиска](fuzzysearch.png){.scale-0.7}
* Пост в блоге о Нечетком Поиске и Автозаполнении - https://manticoresearch.com/blog/new-fuzzy-search-and-autocomplete/

## ВЫЗОВ QSUGGEST, ВЫЗОВ SUGGEST

Оба запроса доступны через SQL и поддерживают запросы как к локальным (простым и в реальном времени), так и распределенным таблицам. Синтаксис следующий:
```sql
CALL QSUGGEST(<слово или слова>, <имя таблицы> [,options])
CALL SUGGEST(<слово или слова>, <имя таблицы> [,options])

options: N как option_name[, M как другой_option, ...]
```

Эти команды предоставляют все предложения из словаря для данного слова. Они работают только с таблицами, где включено [infixing](../Creating_a_table/NLP_and_tokenization/Wildcard_searching_settings.md#min_infix_len) и [dict=keywords](../Creating_a_table/NLP_and_tokenization/Low-level_tokenization.md#dict). Они возвращают предлагаемые ключевые слова, расстояние Левенштейна между предложенными и оригинальными ключевыми словами, а также статистику документов по предложенному ключевому слову.

Если первый параметр содержит несколько слов, тогда:
* `CALL QSUGGEST` вернет предложения только для **последнего** слова, игнорируя остальные.
* `CALL SUGGEST` вернет предложения только для **первого** слова.

Это единственное различие между ними. Поддерживаются несколько параметров для настройки:

| Опция | Описание | По умолчанию |
| - | - | - |
| limit | Возвращает N лучших совпадений | 5 |
| max_edits | Сохраняет только слова из словаря с расстоянием Левенштейна меньше или равно N | 4 |
| result_stats | Предоставляет расстояние Левенштейна и количество документов по найденным словам | 1 (включено) |
| delta_len | Сохраняет только слова из словаря с разницей в длине меньше N | 3 |
| max_matches | Количество совпадений для сохранения | 25 |
| reject | Отказанные слова - это совпадения, которые не лучше, чем те, что уже находятся в очереди совпадений. Они помещаются в очередь отказов, которая сбрасывается, если одно из них может попасть в очередь совпадений. Этот параметр определяет размер очереди отказов (как reject*max(max_matched,limit)). Если очередь отказов заполнена, движок прекращает поиск потенциальных совпадений | 4 |
| result_line | альтернативный режим отображения данных, возвращая все предложения, расстояния и документы в каждой строке | 0 |
| non_char | не пропускать слова из словаря с не алфавитными символами | 0 (пропускать такие слова) |
| sentence | Возвращает оригинальное предложение вместе с последним словом, замененным на совпадающее. | 0 (не возвращать полное предложение) |

Чтобы показать, как это работает, давайте создадим таблицу и добавим в нее несколько документов.

```sql
create table products(title text) min_infix_len='2';
insert into products values (0,'Сумка через плечо с кисточкой'), (0,'набор простыней из микрофибры'), (0,'Перчатка для удаления шерсти домашних животных');
```
<!-- example single -->
##### Пример одного слова
Как вы видите, опечатанное слово "crossb**U**dy" исправляется на "crossbody". По умолчанию, `CALL SUGGEST/QSUGGEST` возвращает:

* `distance` - расстояние Левенштейна, что означает, сколько правок нужно было сделать, чтобы преобразовать данное слово в предложение
* `docs` - количество документов, содержащих предложенное слово

Чтобы отключить отображение этих статистических данных, вы можете использовать параметр `0 как result_stats`.


<!-- intro -->
##### Пример:

<!-- request Example -->

```sql
call suggest('crossbudy', 'products');
```
<!-- response Example -->

```sql
+-----------+----------+------+
| suggest   | distance | docs |
+-----------+----------+------+
| crossbody | 1        | 1    |
+-----------+----------+------+
```
<!-- end -->
<!-- example first -->
##### CALL SUGGEST берет только первое слово
Если первый параметр - это не одно слово, а несколько, тогда `CALL SUGGEST` вернет предложения только для первого слова.


<!-- intro -->
##### Пример:

<!-- request Example -->

```sql
call suggest('bagg with tasel', 'products');
```
<!-- response Example -->

```sql
+---------+----------+------+
| suggest | distance | docs |
+---------+----------+------+
| bag     | 1        | 1    |
+---------+----------+------+
```
<!-- end -->
<!-- example last -->
##### CALL QSUGGEST берет только последнее слово
Если первый параметр - это не одно слово, а несколько, тогда `CALL SUGGEST` вернет предложения только для последнего слова.


<!-- intro -->
##### Пример:

<!-- request Example -->

```sql
CALL QSUGGEST('bagg with tasel', 'products');
```
<!-- response Example -->

```sql
+---------+----------+------+
| suggest | distance | docs |
+---------+----------+------+
| tassel  | 1        | 1    |
+---------+----------+------+
```
<!-- end -->

<!-- example last2 -->

Добавление `1 как sentence` позволяет `CALL QSUGGEST` вернуть полное предложение с исправленным последним словом.

<!-- request Example -->
```sql
CALL QSUGGEST('bag with tasel', 'products', 1 as sentence);
```
<!-- response Example -->
```sql
+-------------------+----------+------+
| suggest           | distance | docs |
+-------------------+----------+------+
| bag with tassel   | 1        | 1    |
+-------------------+----------+------+
```
<!-- end -->

##### Разный режим отображения
Опция `1 as result_line` изменяет способ отображения предложений в выходных данных. Вместо того чтобы показывать каждое предложение в отдельной строке, она отображает все предложения, расстояния и документы в одной строке. Вот пример, чтобы продемонстрировать это:

<!-- intro -->
##### Пример:

<!-- request Example -->

```sql
CALL QSUGGEST('bagg with tasel', 'products', 1 as result_line);
```
<!-- response Example -->

```sql
+----------+--------+
| name     | value  |
+----------+--------+
| suggests | tassel |
| distance | 1      |
| docs     | 1      |
+----------+--------+
```
<!-- end -->

### Демонстрация

* [Этот интерактивный курс](https://play.manticoresearch.com/didyoumean/) показывает, как работает `CALL SUGGEST` в небольшом веб-приложении.

![CALL SUGGEST example](didyoumean.png){.scale-0.5}

<!-- proofread -->

