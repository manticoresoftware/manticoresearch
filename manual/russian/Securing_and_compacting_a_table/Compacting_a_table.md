# Компактирование таблицы

С течением времени таблицы RT могут фрагментироваться на множество дисковых фрагментов и/или загрязняться удалёнными, но не очищенными данными, что влияет на производительность поиска. В этих случаях оптимизация необходима. По сути, процесс оптимизации объединяет пары дисковых фрагментов, удаляя документы, которые были ранее удалены с помощью операторов DELETE.

Начиная с Manticore 4, этот процесс происходит [автоматически по умолчанию](../Server_settings/Searchd.md#auto_optimize). Тем не менее, вы также можете использовать следующие команды для ручного запуска компактирования таблицы.

## OPTIMIZE TABLE

<!-- example optimize -->
```sql
OPTIMIZE TABLE table_name [OPTION opt_name = opt_value [,...]]
```

Оператор `OPTIMIZE` добавляет таблицу RT в очередь оптимизации, которая будет обрабатываться в фоне.

<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
OPTIMIZE TABLE rt;
```
<!-- end -->

### Количество оптимизированных дисковых фрагментов

<!-- example optimize_cutoff -->

По умолчанию, OPTIMIZE объединяет дисковые фрагменты таблицы RT до числа, меньшего или равного количеству логических ядер CPU, умноженному на 2.

Однако, если у таблицы есть атрибуты с индексами KNN, этот порог отличается. В этом случае он устанавливается равным количеству физических ядер CPU, делённому на 2, чтобы улучшить производительность поиска KNN.

Вы также можете контролировать количество оптимизированных дисковых фрагментов вручную, используя опцию `cutoff`.

Дополнительные параметры включают:
* Настройка сервера [optimize_cutoff](../Server_settings/Searchd.md#optimize_cutoff) для переопределения значения порога по умолчанию
* Параметр для каждой таблицы [optimize_cutoff](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#optimize_cutoff)

<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
OPTIMIZE TABLE rt OPTION cutoff=4;
```
<!-- end -->

### Запуск на переднем плане

<!-- example optimize_sync -->

При использовании `OPTION sync=1` (0 по умолчанию) команда будет ждать завершения процесса оптимизации перед возвратом. Если соединение будет прервано, оптимизация продолжит выполняться на сервере.

<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
OPTIMIZE TABLE rt OPTION sync=1;
```
<!-- end -->

### Ограничение влияния на I/O

Оптимизация может быть длительным и требовательным к I/O процессом. Чтобы минимизировать влияние, вся фактическая работа по объединению выполняется последовательно в специальном фоновом потоке, и оператор `OPTIMIZE` просто добавляет задачу в его очередь. Поток оптимизации может быть ограничен по I/O, и вы можете контролировать максимальное количество I/O в секунду и максимальный размер I/O с помощью директив [rt_merge_iops](../Server_settings/Searchd.md#rt_merge_iops) и [rt_merge_maxiosize](../Server_settings/Searchd.md#rt_merge_maxiosize) соответственно.

Во время оптимизации таблица RT, которая оптимизируется, остаётся онлайн и доступной как для поиска, так и для обновлений почти всё время. Она блокируется на очень короткий период, когда пара дисковых фрагментов успешно объединяется, что позволяет переименовать старые и новые файлы и обновить заголовок таблицы.

### Оптимизация кластеризованных таблиц

Пока [auto_optimize](../Server_settings/Searchd.md#auto_optimize) не отключён, таблицы оптимизируются автоматически.

Если вы сталкиваетесь с неожиданными SST или хотите, чтобы таблицы на всех узлах кластера были бинарно идентичны, вам нужно:
1. Отключить [auto_optimize](../Server_settings/Searchd.md#auto_optimize).
2. Оптимизировать таблицы вручную:
<!-- example cluster_manual_drop -->
На одном из узлов, удалите таблицу из кластера:
<!-- request SQL -->
```sql
ALTER CLUSTER mycluster DROP myindex;
```
<!-- end -->
<!-- example cluster_manual_optimize -->
Оптимизируйте таблицу:
<!-- request SQL -->
```sql
OPTIMIZE TABLE myindex;
```
<!-- end -->
<!-- example cluster_manual_add -->
Добавьте таблицу обратно в кластер:
<!-- request SQL -->
```sql
ALTER CLUSTER mycluster ADD myindex;
```
<!-- end -->
Когда таблица добавляется обратно, новые файлы, созданные в процессе оптимизации, будут реплицированы на другие узлы в кластере.
Любые локальные изменения, сделанные в таблице на других узлах, будут потеряны.

Модификации данных таблицы (вставки, замены, удаления, обновления) должны либо:

1. Быть отложены, или
2. Направлены на узел, где выполняется процесс оптимизации.

Обратите внимание, что пока таблица вне кластера, команды вставки/замены/удаления/обновления должны обращаться к ней без префикса имени кластера (для SQL операторов или свойства кластера в случае HTTP JSON запроса), иначе они потерпят неудачу.
После того как таблица будет добавлена обратно в кластер, вы должны возобновить операции записи в таблицу и снова включить префикс имени кластера, иначе они потерпят неудачу.

Операции поиска доступны как обычно в процессе на любом из узлов.

<!-- proofread -->
