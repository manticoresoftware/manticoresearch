# Уплотнение таблицы

Со временем RT таблицы могут фрагментироваться на множество дисковых чанков и/или загрязняться удалёнными, но неочищенными данными, что ухудшает производительность поиска. В таких случаях требуется оптимизация. По сути, процесс оптимизации объединяет пары дисковых чанков, удаляя документы, которые ранее были удалены с помощью операторов DELETE.

Начиная с Manticore 4, этот процесс происходит [автоматически по умолчанию](../Server_settings/Searchd.md#auto_optimize). Однако вы также можете использовать следующие команды для ручного запуска уплотнения таблицы.

## OPTIMIZE TABLE

<!-- example optimize -->
```sql
OPTIMIZE TABLE table_name [OPTION opt_name = opt_value [,...]]
```

Оператор `OPTIMIZE` добавляет RT таблицу в очередь оптимизации, которая будет обрабатываться в фоновом потоке.

<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
OPTIMIZE TABLE rt;
```

<!-- intro -->
##### JSON:

<!-- request JSON -->

```JSON
POST /sql?mode=raw -d "OPTIMIZE TABLE rt"
```

<!-- end -->

### Количество уплотняемых дисковых чанков

<!-- example optimize_cutoff -->

По умолчанию OPTIMIZE объединяет дисковые чанки RT таблицы до числа, меньшего или равного количеству логических ядер процессора, умноженному на 2.

Однако если в таблице есть атрибуты с KNN индексами, этот порог отличается. В этом случае он устанавливается как количество физических ядер процессора, делённое на 2, для улучшения производительности KNN поиска.

Также вы можете вручную контролировать количество уплотняемых дисковых чанков с помощью опции `cutoff`.

Дополнительные опции включают:
* Настройку сервера [optimize_cutoff](../Server_settings/Searchd.md#optimize_cutoff) для переопределения порога по умолчанию
* Настройку таблицы [optimize_cutoff](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#optimize_cutoff)

<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
OPTIMIZE TABLE rt OPTION cutoff=4;
```

<!-- intro -->
##### JSON:

<!-- request JSON -->

```JSON
POST /sql?mode=raw -d "OPTIMIZE TABLE rt OPTION cutoff=4"
```

<!-- end -->

### Запуск в фореграунде

<!-- example optimize_sync -->

При использовании `OPTION sync=1` (по умолчанию 0) команда будет ждать завершения процесса оптимизации перед возвратом результата. Если соединение прервётся, оптимизация продолжит выполняться на сервере.

<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
OPTIMIZE TABLE rt OPTION sync=1;
```

<!-- intro -->
##### JSON:

<!-- request JSON -->

```JSON
POST /sql?mode=raw -d "OPTIMIZE TABLE rt OPTION sync=1"
```

<!-- end -->

### Ограничение воздействия на ввод-вывод

Оптимизация может быть длительным и интенсивным по вводу-выводу процессом. Чтобы минимизировать нагрузку, вся реальная работа по слиянию выполняется последовательно в специальном фоновом потоке, а оператор `OPTIMIZE` лишь добавляет задачу в его очередь. Фоновый поток оптимизации может быть ограничен по ввод-выводу, и вы можете контролировать максимальное количество операций ввода-вывода в секунду и максимальный размер ввода-вывода с помощью директив [rt_merge_iops](../Server_settings/Searchd.md#rt_merge_iops) и [rt_merge_maxiosize](../Server_settings/Searchd.md#rt_merge_maxiosize) соответственно.

Во время оптимизации RT таблица остаётся в сети и доступна для поиска и обновлений почти всё время. Она блокируется лишь на очень короткий период при успешном слиянии пары дисковых чанков, что позволяет переименовать старые и новые файлы и обновить заголовок таблицы.

### Оптимизация кластерных таблиц

Пока не отключена настройка [auto_optimize](../Server_settings/Searchd.md#auto_optimize), таблицы оптимизируются автоматически.

Если вы сталкиваетесь с неожиданными SST или хотите, чтобы таблицы на всех узлах кластера были бинарно идентичны, нужно:
1. Отключить [auto_optimize](../Server_settings/Searchd.md#auto_optimize).
2. Вручную оптимизировать таблицы:
<!-- example cluster_manual_drop -->
На одном из узлов удалить таблицу из кластера:
<!-- request SQL -->
```sql
ALTER CLUSTER mycluster DROP myindex;
```

<!-- request JSON -->
```JSON
POST /sql?mode=raw -d "ALTER CLUSTER mycluster DROP myindex"
```

<!-- end -->
<!-- example cluster_manual_optimize -->
Оптимизировать таблицу:
<!-- request SQL -->
```sql
OPTIMIZE TABLE myindex;
```

<!-- request JSON -->
```JSON
POST /sql?mode=raw -d "OPTIMIZE TABLE myindex"
```

<!-- end -->
<!-- example cluster_manual_add -->
Добавить таблицу обратно в кластер:
<!-- request SQL -->
```sql
ALTER CLUSTER mycluster ADD myindex;
```

<!-- request JSON -->
```JSON
POST /sql?mode=raw -d "ALTER CLUSTER mycluster ADD myindex"
```

<!-- end -->
При добавлении таблицы обратно новые файлы, созданные в процессе оптимизации, будут реплицированы на остальные узлы кластера.
Любые локальные изменения, внесённые в таблицу на других узлах, будут потеряны.

Модификации данных таблицы (вставки, замены, удаления, обновления) должны либо:

1. Быть отложены, либо
2. Направляться к узлу, где выполняется процесс оптимизации.

Обратите внимание, что пока таблица находится вне кластера, команды insert/replace/delete/update должны обращаться к ней без префикса имени кластера (в SQL операторах или свойстве cluster в случае HTTP JSON запроса), иначе они завершатся с ошибкой.
После добавления таблицы обратно в кластер необходимо возобновить операции записи в таблицу и снова использовать префикс имени кластера, иначе они завершатся с ошибкой.

Операции поиска доступны как обычно на любом из узлов в процессе.

<!-- proofread -->

