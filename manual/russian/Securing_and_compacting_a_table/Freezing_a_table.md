# Заморозка таблицы

<!-- example freeze -->

```sql
FREEZE tbl1[, tbl2, ...]
```

`FREEZE` подготавливает таблицу в реальном времени/обычную для безопасного [резервного копирования](../Securing_and_compacting_a_table/Backup_and_restore.md). В частности, он:
1. Деактивирует сжатие таблицы. Если таблица в настоящее время сжимается, `FREEZE` прервет его корректно.
2. Переносит текущий RAM чанк на дисковый чанк.
3. Сбрасывает атрибуты.
4. Отключаетimplicit операции, которые могут изменить дисковые файлы.
5. Увеличивает счетчик заблокированных таблиц.
6. Показывает фактический список файлов, связанных с таблицей.

Если таблица уже заморожена (заблокирована), `FREEZE`:
1. Увеличит счетчик заблокированных таблиц.
2. Покажет фактический список файлов, связанных с таблицей.

Встроенный инструмент [manticore-backup](../Securing_and_compacting_a_table/Backup_and_restore.md) использует `FREEZE` для обеспечения согласованности данных. Вы можете сделать то же самое, если хотите создать собственное решение для резервного копирования или необходимо заморозить таблицы по другим причинам. Просто следуйте этим шагам:
1. `FREEZE` таблицу (или несколько).
2. Захватите вывод команды `FREEZE` и создайте резервную копию указанных файлов.
3. `UNFREEZE` таблицы после завершения.

<!-- request Example -->
```sql
FREEZE t;
```

<!-- response Example -->
```sql
+-------------------+---------------------------------+
| file              | normalized                      |
+-------------------+---------------------------------+
| data/t/t.0.spa    | /work/anytest/data/t/t.0.spa    |
| data/t/t.0.spd    | /work/anytest/data/t/t.0.spd    |
| data/t/t.0.spds   | /work/anytest/data/t/t.0.spds   |
| data/t/t.0.spe    | /work/anytest/data/t/t.0.spe    |
| data/t/t.0.sph    | /work/anytest/data/t/t.0.sph    |
| data/t/t.0.sphi   | /work/anytest/data/t/t.0.sphi   |
| data/t/t.0.spi    | /work/anytest/data/t/t.0.spi    |
| data/t/t.0.spm    | /work/anytest/data/t/t.0.spm    |
| data/t/t.0.spp    | /work/anytest/data/t/t.0.spp    |
| data/t/t.0.spt    | /work/anytest/data/t/t.0.spt    |
| data/t/t.meta     | /work/anytest/data/t/t.meta     |
| data/t/t.ram      | /work/anytest/data/t/t.ram      |
| data/t/t.settings | /work/anytest/data/t/t.settings |
+-------------------+---------------------------------+
13 rows in set (0.01 sec)
```

<!-- end -->

Столбец `file` указывает пути к файлам таблицы внутри [data_dir](../Server_settings/Searchd.md#data_dir) работающего экземпляра. Столбец `normalized` отображает абсолютные пути для тех же файлов. Чтобы сделать резервную копию таблицы, просто скопируйте предоставленные файлы без дополнительной подготовки.

Когда таблица заморожена, вы не можете выполнять запросы `UPDATE`; они будут ждать, пока таблица не будет разморожена.

Кроме того, запросы `DELETE` и `REPLACE` имеют некоторые ограничения, пока таблица заморожена:
* Если `DELETE` затрагивает документ в текущем RAM чанке - это допустимо.
* Если `DELETE` затрагивает документ в дисковом чанке, но был ранее удален - это разрешено.
* Если `DELETE` изменит фактический дисковый чанк - он будет ждать, пока таблица не будет разморожена.

Ручное `FLUSH`-инг RAM чанка замороженной таблицы будет сообщать о 'успехе', но реальное сохранение не произойдет.

`DROP`/`TRUNCATE` замороженной таблицы **разрешены**, так как эти операции не являютсяimplicit. Мы предполагаем, что если вы обрезаете или удаляете таблицу, вам не нужно ее резервировать; следовательно, ее не должно было замораживать изначально.

`INSERT` в замороженную таблицу поддерживается, но ограничено: новые данные будут храниться в RAM (как обычно), пока не достигнется `rt_mem_limit`; затем новые вставки будут ожидать, пока таблица не будет разморожена.

Если вы завершите работу демона с замороженной таблицей, это будет означать, что она испытала грязное завершение работы (например, `kill -9`): вновь вставленные данные **не** будут сохранены в RAM-чанке на диске, и после перезапуска они будут восстановлены из бинарного лога (если таковой имеется) или потеряны (если бинарное логирование отключено).

## Размораживание таблицы

<!-- example unfreeze -->

```sql
UNFREEZE tbl1[, tbl2, ...]
```

Команда `UNFREEZE` уменьшает счетчик заблокированных таблиц, и если он достигает нуля, активирует ранее заблокированные операции и возобновляет внутреннюю службу сжатия. Любые операции, которые ожидали разморозки таблицы, также возобновятся и завершатся нормально.

<!-- request Example -->
```sql
UNFREEZE tbl;
```

<!-- end -->

## Проверка состояния блокировки таблицы

<!-- example show_table_status -->

Вы можете использовать `SHOW table_name STATUS`, чтобы проверить, заморожена ли таблица или нет.

Счетчик блокировок отображается в состоянии таблицы в столбце `locked`. Значение ноль указывает на то, что таблица не заморожена, в то время как ненулевое значение отражает количество активных блокировок. Каждая явная команда `FREEZE` и неявная блокировка (таких как когда таблица является частью кластера, и процедура репликации выбирает её как донора для реплики) увеличивает счетчик. Каждая команда `UNFREEZE` уменьшает счетчик, в конечном итоге до нуля.

<!-- request Example -->

```sql
SHOW TABLE `foo` STATUS LIKE 'locked';
```

<!-- response Example -->

```sql
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| locked        | 2     |
+---------------+-------+
1 row in set (0,00 sec)
```

<!-- end -->

## ПОКАЗАТЬ БЛОКИРОВКИ

<!-- example show_locks -->

Заблокированные таблицы также отображаются с помощью команды `SHOW LOCKS`. Счетчики блокировок отображаются в столбце `Дополнительная информация`.

<!-- request Example -->

```sql
SHOW LOCKS;
```

<!-- response Example -->

```sql
+-----------+------+-----------+-----------------+
| Type      | Name | Lock Type | Additional Info |
+-----------+------+-----------+-----------------+
| rt        | a    | freeze    | Count: 1        |
| percolate | bar  | freeze    | Count: 3        |
| rt        | foo  | freeze    | Count: 2        |
+-----------+------+-----------+-----------------+
3 строки в наборе (0,01 сек)
```

<!-- end -->
# Замораживание таблицы

<!-- example freeze -->

```sql
FREEZE tbl1[, tbl2, ...]
```

`FREEZE` подготавливает таблицу в реальном времени/обычную для безопасного [резервного копирования](../Securing_and_compacting_a_table/Backup_and_restore.md). В частности, это:
1. Деактивирует сжатие таблицы. Если таблица в настоящее время сжимается, `FREEZE` прервет его корректно.
2. Переносит текущий кусок оперативной памяти на диск.
3. Сбрасывает атрибуты.
4. Отключает неявные операции, которые могут изменить файлы на диске.
5. Увеличивает счетчик блокировок таблицы.
6. Показывает текущий список файлов, связанных с таблицей.

Если таблица уже заморожена (заблокирована), `FREEZE` будет:
1. Увеличивать счетчик блокировок таблицы.
2. Показывать текущий список файлов, связанных с таблицей.

Встроенный инструмент [manticore-backup](../Securing_and_compacting_a_table/Backup_and_restore.md) использует `FREEZE`, чтобы обеспечить согласованность данных. Вы можете сделать то же самое, если хотите создать свое собственное решение для резервного копирования или вам нужно заморозить таблицы по другим причинам. Просто выполните следующие шаги:
1. `FREEZE` таблицу (или несколько).
2. Захватите вывод команды `FREEZE` и создайте резервную копию указанных файлов.
3. `UNFREEZE` таблицу(ы) после завершения.

<!-- request Example -->
```sql
FREEZE t;
```

<!-- response Example -->
```sql
+-------------------+---------------------------------+
| file              | normalized                      |
+-------------------+---------------------------------+
| data/t/t.0.spa    | /work/anytest/data/t/t.0.spa    |
| data/t/t.0.spd    | /work/anytest/data/t/t.0.spd    |
| data/t/t.0.spds   | /work/anytest/data/t/t.0.spds   |
| data/t/t.0.spe    | /work/anytest/data/t/t.0.spe    |
| data/t/t.0.sph    | /work/anytest/data/t/t.0.sph    |
| data/t/t.0.sphi   | /work/anytest/data/t/t.0.sphi   |
| data/t/t.0.spi    | /work/anytest/data/t/t.0.spi    |
| data/t/t.0.spm    | /work/anytest/data/t/t.0.spm    |
| data/t/t.0.spp    | /work/anytest/data/t/t.0.spp    |
| data/t/t.0.spt    | /work/anytest/data/t/t.0.spt    |
| data/t/t.meta     | /work/anytest/data/t/t.meta     |
| data/t/t.ram      | /work/anytest/data/t/t.ram      |
| data/t/t.settings | /work/anytest/data/t/t.settings |
+-------------------+---------------------------------+
13 rows in set (0.01 sec)
```

<!-- end -->

Колонка `file` указывает пути к файлам таблицы в [data_dir](../Server_settings/Searchd.md#data_dir) работающего экземпляра. Колонка `normalized` отображает абсолютные пути к тем же файлам. Чтобы создать резервную копию таблицы, просто скопируйте предоставленные файлы без дополнительной подготовки.

Когда таблица заморожена, вы не можете выполнять запросы `UPDATE`; они будут ждать, пока таблица не будет разморожена.

Кроме того, запросы `DELETE` и `REPLACE` имеют некоторые ограничения, пока таблица заморожена:
* Если `DELETE` затрагивает документ в текущем куске оперативной памяти - это разрешено.
* Если `DELETE` затрагивает документ в дисковом куске, но он был ранее удален - это разрешено.
* Если `DELETE` изменит фактический дисковый кусок - он будет ждать, пока таблица не будет разморожена.

Ручное `FLUSH` куска RAM замороженной таблицы будет сообщать о 'успехе', но никаких реальных сохранений не произойдет.

`DROP`/`TRUNCATE` замороженной таблицы **разрешены**, так как эти операции не являются неявными. Мы предполагаем, что если вы обрезаете или удаляете таблицу, вам не нужно ее резервировать; следовательно, ее не следовало замораживать изначально.

`INSERT` в замороженную таблицу поддерживается, но ограниченно: новые данные будут храниться в оперативной памяти (как обычно), пока не будет достигнут лимит `rt_mem_limit`; затем новые вставки будут ждать, пока таблица не будет разморожена.

Если вы остановите демон с замороженной таблицей, он будет вести себя так, будто произошел грязный обычный сбой (например, `kill -9`): вновь вставленные данные **не** будут сохранены в RAM-кусочке на диске, и при перезапуске они будут восстановлены из бинарного лога (если таковой имеется) или потеряны (если бинарное логирование отключено).

# Размораживание таблицы

<!-- example unfreeze -->

```sql
UNFREEZE tbl1[, tbl2, ...]
```

Команда `UNFREEZE` уменьшает счетчик блокировок таблицы, и если он достигает нуля, повторно активирует ранее заблокированные операции и возобновляет внутреннюю службу сжатия. Все операции, которые ожидали размораживания таблицы, также возобновятся и завершатся нормально.

<!-- request Example -->
```sql
UNFREEZE tbl;
```

<!-- end -->

# Проверка состояния блокировки таблицы

<!-- example show_table_status -->

Вы можете использовать `SHOW table_name STATUS`, чтобы проверить, заморожена таблица или нет.

Счетчик блокировок отображается в статусе таблицы под колонкой `locked`. Значение ноль указывает на то, что таблица не заморожена, в то время как ненулевое значение отражает количество активных блокировок. Каждая явная команда `FREEZE` и неявная блокировка (например, когда таблица является частью кластера и процедура репликации выбирает ее в качестве донора для реплики) увеличивает счетчик. Каждая команда `UNFREEZE` уменьшает счетчик, в конечном итоге до нуля.

<!-- request Example -->

```sql
SHOW TABLE `foo` STATUS LIKE 'locked';
```

<!-- response Example -->

```sql
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| locked        | 2     |
+---------------+-------+
1 row in set (0,00 sec)
```

<!-- end -->

# ПОКАЗАТЬ БЛОКИРОВКИ

<!-- example show_locks -->

Заблокированные таблицы также отображаются с помощью команды `SHOW LOCKS`. Счетчики блокировок показываются в колонке `Additional Info`.

<!-- request Example -->

```sql
SHOW LOCKS;
```

<!-- response Example -->

```sql
+-----------+------+-----------+-----------------+
| Type      | Name | Lock Type | Additional Info |
+-----------+------+-----------+-----------------+
| rt        | a    | freeze    | Count: 1        |
| percolate | bar  | freeze    | Count: 3        |
| rt        | foo  | freeze    | Count: 2        |
+-----------+------+-----------+-----------------+
3 строки в наборе (0,01 сек)
```

<!-- end -->
