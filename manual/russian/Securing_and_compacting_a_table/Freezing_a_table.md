# Заморозка таблицы

<!-- example freeze -->

```sql
FREEZE tbl1[, tbl2, ...]
```

`FREEZE` подготавливает таблицу реального времени/простую таблицу для безопасного [резервного копирования](../Securing_and_compacting_a_table/Backup_and_restore.md). В частности, он:
1. Деактивирует сжатие таблицы. Если таблица в данный момент сжимается, `FREEZE` аккуратно прервет этот процесс.
2. Переносит текущий RAM-чанк на диск.
3. Сбрасывает атрибуты.
4. Отключает неявные операции, которые могут изменить файлы на диске.
5. Увеличивает счетчик блокировок таблицы.
6. Показывает актуальный список файлов, связанных с таблицей.

Если таблица уже заморожена (заблокирована), `FREEZE`:
1. Увеличит счетчик блокировок таблицы.
2. Покажет актуальный список файлов, связанных с таблицей.

Встроенный инструмент [manticore-backup](../Securing_and_compacting_a_table/Backup_and_restore.md) использует `FREEZE` для обеспечения согласованности данных. Вы можете сделать то же самое, если хотите создать собственное решение для резервного копирования или нужно заморозить таблицы по другим причинам. Просто выполните следующие шаги:
1. `FREEZE` таблицу (или несколько).
2. Сохраните вывод команды `FREEZE` и сделайте резервную копию указанных файлов.
3. `UNFREEZE` таблицу(ы) после завершения.

<!-- request Example -->
```sql
FREEZE t;
```

<!-- response Example -->
```sql
+-------------------+---------------------------------+
| file              | normalized                      |
+-------------------+---------------------------------+
| data/t/t.0.spa    | /work/anytest/data/t/t.0.spa    |
| data/t/t.0.spd    | /work/anytest/data/t/t.0.spd    |
| data/t/t.0.spds   | /work/anytest/data/t/t.0.spds   |
| data/t/t.0.spe    | /work/anytest/data/t/t.0.spe    |
| data/t/t.0.sph    | /work/anytest/data/t/t.0.sph    |
| data/t/t.0.sphi   | /work/anytest/data/t/t.0.sphi   |
| data/t/t.0.spi    | /work/anytest/data/t/t.0.spi    |
| data/t/t.0.spm    | /work/anytest/data/t/t.0.spm    |
| data/t/t.0.spp    | /work/anytest/data/t/t.0.spp    |
| data/t/t.0.spt    | /work/anytest/data/t/t.0.spt    |
| data/t/t.meta     | /work/anytest/data/t/t.meta     |
| data/t/t.ram      | /work/anytest/data/t/t.ram      |
| data/t/t.settings | /work/anytest/data/t/t.settings |
+-------------------+---------------------------------+
13 rows in set (0.01 sec)
```

<!-- end -->

Столбец `file` указывает пути к файлам таблицы внутри [data_dir](../Server_settings/Searchd.md#data_dir) запущенного экземпляра. Столбец `normalized` отображает абсолютные пути к тем же файлам. Чтобы сделать резервную копию таблицы, просто скопируйте указанные файлы без дополнительной подготовки.

Когда таблица заморожена, выполнение запросов `UPDATE` невозможно; они будут ожидать, пока таблица не будет разморожена.

Также запросы `DELETE` и `REPLACE` имеют некоторые ограничения во время заморозки таблицы:
* Если `DELETE` затрагивает документ в текущем RAM-чанке — это разрешено.
* Если `DELETE` влияет на документ в дисковом чанке, но он был ранее удален — это разрешено.
* Если `DELETE` изменит реальный дисковый чанк — запрос будет ждать, пока таблица не будет разморожена.

Ручной `FLUSH` RAM-чанка замороженной таблицы сообщит об «успехе», но реального сохранения не произойдет.

`DROP`/`TRUNCATE` замороженной таблицы **разрешены**, так как эти операции не являются неявными. Предполагается, что если вы удаляете или очищаете таблицу, она вам не нужна для резервного копирования; следовательно, она изначально не должна была быть заморожена.

`INSERT` в замороженную таблицу поддерживается, но с ограничениями: новые данные будут храниться в RAM (как обычно) до достижения `rt_mem_limit`; затем новые вставки будут ждать, пока таблица не будет разморожена.

Если вы завершите работу демона с замороженной таблицей, это будет эквивалентно некорректному завершению работы (например, `kill -9`): недавно вставленные данные **не** будут сохранены в RAM-чанке на диске, и при перезапуске они будут восстановлены из бинарного лога (если он есть) или потеряны (если бинарное логирование отключено).

## Разморозка таблицы

<!-- example unfreeze -->

```sql
UNFREEZE tbl1[, tbl2, ...]
```

Команда `UNFREEZE` уменьшает счетчик блокировок таблицы, и если он достигает нуля, повторно активирует ранее заблокированные операции и возобновляет внутреннюю службу сжатия. Все операции, ожидавшие разморозки таблицы, также возобновятся и завершатся нормально.

<!-- request Example -->
```sql
UNFREEZE tbl;
```

<!-- end -->

## Проверка состояния блокировки таблицы

<!-- example show_table_status -->

Вы можете использовать `SHOW table_name STATUS`, чтобы проверить, заморожена таблица или нет.

Счетчик блокировок отображается в статусе таблицы в столбце `locked`. Значение ноль означает, что таблица не заморожена, а ненулевое значение отражает количество активных блокировок. Каждая явная команда `FREEZE` и неявная блокировка (например, когда таблица является частью кластера и репликационная процедура выбирает ее в качестве донора для реплики) увеличивает счетчик. Каждая команда `UNFREEZE` уменьшает счетчик, в конечном итоге до нуля.

<!-- request Example -->

```sql
SHOW TABLE `foo` STATUS LIKE 'locked';
```

<!-- response Example -->

```sql
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| locked        | 2     |
+---------------+-------+
1 row in set (0,00 sec)
```

<!-- end -->

## SHOW LOCKS

<!-- example show_locks -->

Заблокированные таблицы также отображаются с помощью команды `SHOW LOCKS`. Счетчики блокировок показаны в столбце `Additional Info`.

<!-- request Example -->

```sql
SHOW LOCKS;
```

<!-- response Example -->

```sql
+-----------+------+-----------+-----------------+
| Type      | Name | Lock Type | Additional Info |
+-----------+------+-----------+-----------------+
| rt        | a    | freeze    | Count: 1        |
| percolate | bar  | freeze    | Count: 3        |
| rt        | foo  | freeze    | Count: 2        |
+-----------+------+-----------+-----------------+
3 rows in set (0,01 sec)
```

<!-- end -->

