# Замораживание таблицы

<!-- example freeze -->

```sql
FREEZE tbl1[, tbl2, ...]
```

`FREEZE` подготавливает таблицу в реальном времени/обычную для безопасного [резервного копирования](../Securing_and_compacting_a_table/Backup_and_restore.md). В частности, это:
1. Деактивирует сжатие таблицы. Если таблица в настоящее время сжимается, `FREEZE` прервет его корректно.
2. Переносит текущий кусок оперативной памяти на диск.
3. Сбрасывает атрибуты.
4. Отключает неявные операции, которые могут изменить файлы на диске.
5. Увеличивает счетчик блокировок таблицы.
6. Показывает текущий список файлов, связанных с таблицей.

Если таблица уже заморожена (заблокирована), `FREEZE` будет:
1. Увеличивать счетчик блокировок таблицы.
2. Показывать текущий список файлов, связанных с таблицей.

Встроенный инструмент [manticore-backup](../Securing_and_compacting_a_table/Backup_and_restore.md) использует `FREEZE`, чтобы обеспечить согласованность данных. Вы можете сделать то же самое, если хотите создать свое собственное решение для резервного копирования или вам нужно заморозить таблицы по другим причинам. Просто выполните следующие шаги:
1. `FREEZE` таблицу (или несколько).
2. Захватите вывод команды `FREEZE` и создайте резервную копию указанных файлов.
3. `UNFREEZE` таблицу(ы) после завершения.

<!-- request Example -->
```sql
FREEZE t;
```

<!-- response Example -->
```sql
+-------------------+---------------------------------+
| file              | normalized                      |
+-------------------+---------------------------------+
| data/t/t.0.spa    | /work/anytest/data/t/t.0.spa    |
| data/t/t.0.spd    | /work/anytest/data/t/t.0.spd    |
| data/t/t.0.spds   | /work/anytest/data/t/t.0.spds   |
| data/t/t.0.spe    | /work/anytest/data/t/t.0.spe    |
| data/t/t.0.sph    | /work/anytest/data/t/t.0.sph    |
| data/t/t.0.sphi   | /work/anytest/data/t/t.0.sphi   |
| data/t/t.0.spi    | /work/anytest/data/t/t.0.spi    |
| data/t/t.0.spm    | /work/anytest/data/t/t.0.spm    |
| data/t/t.0.spp    | /work/anytest/data/t/t.0.spp    |
| data/t/t.0.spt    | /work/anytest/data/t/t.0.spt    |
| data/t/t.meta     | /work/anytest/data/t/t.meta     |
| data/t/t.ram      | /work/anytest/data/t/t.ram      |
| data/t/t.settings | /work/anytest/data/t/t.settings |
+-------------------+---------------------------------+
13 rows in set (0.01 sec)
```

<!-- end -->

Колонка `file` указывает пути к файлам таблицы в [data_dir](../Server_settings/Searchd.md#data_dir) работающего экземпляра. Колонка `normalized` отображает абсолютные пути к тем же файлам. Чтобы создать резервную копию таблицы, просто скопируйте предоставленные файлы без дополнительной подготовки.

Когда таблица заморожена, вы не можете выполнять запросы `UPDATE`; они будут ждать, пока таблица не будет разморожена.

Кроме того, запросы `DELETE` и `REPLACE` имеют некоторые ограничения, пока таблица заморожена:
* Если `DELETE` затрагивает документ в текущем куске оперативной памяти - это разрешено.
* Если `DELETE` затрагивает документ в дисковом куске, но он был ранее удален - это разрешено.
* Если `DELETE` изменит фактический дисковый кусок - он будет ждать, пока таблица не будет разморожена.

Ручное `FLUSH` куска RAM замороженной таблицы будет сообщать о 'успехе', но никаких реальных сохранений не произойдет.

`DROP`/`TRUNCATE` замороженной таблицы **разрешены**, так как эти операции не являются неявными. Мы предполагаем, что если вы обрезаете или удаляете таблицу, вам не нужно ее резервировать; следовательно, ее не следовало замораживать изначально.

`INSERT` в замороженную таблицу поддерживается, но ограниченно: новые данные будут храниться в оперативной памяти (как обычно), пока не будет достигнут лимит `rt_mem_limit`; затем новые вставки будут ждать, пока таблица не будет разморожена.

Если вы остановите демон с замороженной таблицей, он будет вести себя так, будто произошел грязный обычный сбой (например, `kill -9`): вновь вставленные данные **не** будут сохранены в RAM-кусочке на диске, и при перезапуске они будут восстановлены из бинарного лога (если таковой имеется) или потеряны (если бинарное логирование отключено).

# Размораживание таблицы

<!-- example unfreeze -->

```sql
UNFREEZE tbl1[, tbl2, ...]
```

Команда `UNFREEZE` уменьшает счетчик блокировок таблицы, и если он достигает нуля, повторно активирует ранее заблокированные операции и возобновляет внутреннюю службу сжатия. Все операции, которые ожидали размораживания таблицы, также возобновятся и завершатся нормально.

<!-- request Example -->
```sql
UNFREEZE tbl;
```

<!-- end -->

# Проверка состояния блокировки таблицы

<!-- example show_table_status -->

Вы можете использовать `SHOW table_name STATUS`, чтобы проверить, заморожена таблица или нет.

Счетчик блокировок отображается в статусе таблицы под колонкой `locked`. Значение ноль указывает на то, что таблица не заморожена, в то время как ненулевое значение отражает количество активных блокировок. Каждая явная команда `FREEZE` и неявная блокировка (например, когда таблица является частью кластера и процедура репликации выбирает ее в качестве донора для реплики) увеличивает счетчик. Каждая команда `UNFREEZE` уменьшает счетчик, в конечном итоге до нуля.

<!-- request Example -->

```sql
SHOW TABLE `foo` STATUS LIKE 'locked';
```

<!-- response Example -->

```sql
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| locked        | 2     |
+---------------+-------+
1 row in set (0,00 sec)
```

<!-- end -->

# ПОКАЗАТЬ БЛОКИРОВКИ

<!-- example show_locks -->

Заблокированные таблицы также отображаются с помощью команды `SHOW LOCKS`. Счетчики блокировок показываются в колонке `Additional Info`.

<!-- request Example -->

```sql
SHOW LOCKS;
```

<!-- response Example -->

```sql
+-----------+------+-----------+-----------------+
| Type      | Name | Lock Type | Additional Info |
+-----------+------+-----------+-----------------+
| rt        | a    | freeze    | Count: 1        |
| percolate | bar  | freeze    | Count: 3        |
| rt        | foo  | freeze    | Count: 2        |
+-----------+------+-----------+-----------------+
3 строки в наборе (0,01 сек)
```

<!-- end -->
