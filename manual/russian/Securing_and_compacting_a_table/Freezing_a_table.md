# Заморозка и блокировка таблицы

`Заморозка` таблицы полезна для создания физической копии/резервной копии. Она «замораживает» файлы, принадлежащие таблице, и отображает, где они расположены. После заморозки вы можете безопасно скопировать файлы в другое место. Вы все еще можете вставлять новые документы в замороженные таблицы, пока не достигнете rt_mem_limit, но эти данные будут накапливаться в оперативной памяти и не будут сохраняться на диск, пока таблица не будет разморожена. Если вы превысите rt_mem_limit, изменения будут приостановлены до разморозки таблицы. Если демон неожиданно завершит работу, несохранённые данные будут восстановлены из binlog.

Дополняющая `блокировка` таблицы полезна для логического резервного копирования. Она не влияет на текущую внутреннюю реорганизацию, такую как оптимизация, сохранение RAM-чанкa на диск и т.д. Вместо этого она просто запрещает любые операции модификации. То есть вы не можете вставлять/заменять/обновлять данные в заблокированной таблице. Это полезно для таких инструментов, как mysqldump. Блокируя таблицу, вы обеспечиваете логическую целостность данных. Например, если вы замените документ во время дампа, может случиться так, что предыдущая версия уже есть в дампе, а новая версия появляется в конце, с тем же ID документа. Заблокировав таблицу, вы можете быть уверены, что такого случая не произойдет.

## Заморозка таблицы
<!-- example freeze -->

```sql
FREEZE tbl1[, tbl2, ...]
```

`FREEZE` подготавливает таблицу real-time/plain для безопасного [резервного копирования](../Securing_and_compacting_a_table/Backup_and_restore.md). В частности, он:
1. Деактивирует компактизацию таблицы. Если таблица в данный момент компактизируется, `FREEZE` корректно прервет этот процесс.
2. Переносит текущий RAM-чанк в диск-чанк.
3. Сбрасывает атрибуты.
4. Отключает неявные операции, которые могут изменить файлы на диске.
5. Увеличивает счетчик блокировок таблицы.
6. Показывает текущий список файлов, связанных с таблицей.

Если таблица уже заморожена (заблокирована), `FREEZE` выполнит:
1. Увеличение счетчика блокировок таблицы.
2. Показ текущего списка файлов, связанных с таблицей.

Встроенный инструмент [manticore-backup](../Securing_and_compacting_a_table/Backup_and_restore.md) использует `FREEZE` для обеспечения консистентности данных. Вы можете поступать так же, если хотите создать собственное решение резервного копирования или нужно заморозить таблицы по другим причинам. Просто выполните следующие шаги:
1. `FREEZE` одну или несколько таблиц.
2. Захватите вывод команды `FREEZE` и сделайте резервную копию указанных файлов.
3. Выполните `UNFREEZE` для таблицы(ц) после окончания.

<!-- request Example -->
```sql
FREEZE t;
```

<!-- response Example -->
```sql
+-------------------+---------------------------------+
| file              | normalized                      |
+-------------------+---------------------------------+
| data/t/t.0.spa    | /work/anytest/data/t/t.0.spa    |
| data/t/t.0.spd    | /work/anytest/data/t/t.0.spd    |
| data/t/t.0.spds   | /work/anytest/data/t/t.0.spds   |
| data/t/t.0.spe    | /work/anytest/data/t/t.0.spe    |
| data/t/t.0.sph    | /work/anytest/data/t/t.0.sph    |
| data/t/t.0.sphi   | /work/anytest/data/t/t.0.sphi   |
| data/t/t.0.spi    | /work/anytest/data/t/t.0.spi    |
| data/t/t.0.spm    | /work/anytest/data/t/t.0.spm    |
| data/t/t.0.spp    | /work/anytest/data/t/t.0.spp    |
| data/t/t.0.spt    | /work/anytest/data/t/t.0.spt    |
| data/t/t.meta     | /work/anytest/data/t/t.meta     |
| data/t/t.ram      | /work/anytest/data/t/t.ram      |
| data/t/t.settings | /work/anytest/data/t/t.settings |
+-------------------+---------------------------------+
13 rows in set (0.01 sec)
```

<!-- end -->

Столбец `file` указывает пути файлов таблицы в [data_dir](../Server_settings/Searchd.md#data_dir) запущенного экземпляра. Столбец `normalized` показывает абсолютные пути для тех же файлов. Чтобы создать резервную копию таблицы, просто скопируйте указанные файлы без дополнительной подготовки.

Когда таблица заморожена, выполнить запросы `UPDATE` невозможно; они будут ожидать, пока таблица не будет разморожена.

Также у запросов `DELETE` и `REPLACE` есть некоторые ограничения при замороженной таблице:
* Если `DELETE` затрагивает документ в текущем RAM-чанке — это разрешено.
* Если `DELETE` касается документа в диск-чанке, но документ уже был удалён — это разрешено.
* Если `DELETE` изменит фактический диск-чанк — запрос будет ожидать, пока таблица не будет разморожена.

Ручной `FLUSH` RAM-чанка замороженной таблицы вернет успех, но реального сохранения не произойдет.

`DROP`/`TRUNCATE` замороженной таблицы **разрешены**, поскольку эти операции не являются неявными. Мы предполагаем, что если вы удаляете или усечете таблицу, она вам не нужна в резервной копии, и поэтому изначально она не должна была быть заморожена.

`INSERT` в замороженную таблицу поддерживается, но с ограничениями: новые данные будут храниться в ОЗУ (как обычно) до достижения `rt_mem_limit`; затем новые вставки будут ждать, пока таблица не будет разморожена.

Если вы завершите работу демона при замороженной таблице, он поведет себя, будто произошло грязное завершение (например, с помощью `kill -9`): недавно вставленные данные **не** будут сохранены в RAM-чанк на диске, и при перезапуске они будут восстановлены из binlog (если он включён) или потеряны (если бинарное логирование отключено).

## Разморозка таблицы

<!-- example unfreeze -->

```sql
UNFREEZE tbl1[, tbl2, ...]
```

Команда `UNFREEZE` уменьшает счетчик блокировок таблицы, и если он достигает нуля, реактивирует ранее заблокированные операции и возобновляет внутреннюю службу компактации. Все операции, ожидавшие разморозки таблицы, также возобновятся и завершатся нормально.

<!-- request Example -->
```sql
UNFREEZE tbl;
```

<!-- end -->

## Проверка состояния блокировки таблицы

<!-- example show_table_status -->

Вы можете использовать `SHOW table_name STATUS`, чтобы проверить, заморожена таблица или нет.

Счетчик блокировок отображается в статусе таблицы в столбце `locked`. Значение ноль означает, что
таблица не заморожена, а ненулевое значение отражает количество активных блокировок. Каждая явная команда `FREEZE` и
неявная блокировка (например, когда таблица входит в кластер и используется рутиной репликации как донор для
реплики) увеличивает счетчик. Каждая команда `UNFREEZE` уменьшает счетчик до достижения нуля.

<!-- request Example -->

```sql
SHOW TABLE `foo` STATUS LIKE 'locked';
```

<!-- response Example -->

```sql
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| locked        | 2     |
+---------------+-------+
1 row in set (0,00 sec)
```

<!-- end -->

## Получение блокировки таблицы

<!-- example lock -->

```sql
lock tables tbl1 read[, tbl2 write, ...]
```

Manticore позволяет клиентским сессиям sphinxql явно получать блокировки таблиц, чтобы взаимодействовать с другими сессиями для доступа к таблицам или предотвращать изменение таблиц другими сессиями во время эксклюзивного доступа. Сессия sphinxql может получить или освободить блокировки только для себя. Одна сессия не может получить или освободить блокировки, принадлежащие другой сессии. Блокировки могут быть получены и освобождены только в сессиях sphinxql, подключённых по протоколу mysql, однако вы не можете изменять данные в заблокированных таблицах через любой протокол. Также блокировки недоступны для таблиц в кластере. Это связано с тем, что если мы отклоним изменения, поступающие из кластера в заблокированную таблицу, весь кластер может зависнуть или даже повредиться.

Manticore реализует только разделяемые блокировки (read). Исключительные блокировки (write) не реализованы.

Чтение блокировки:

1. Проверяет, что текущий протокол подключения — mysql.
2. Проверяет, подходит ли таблица для блокировки. Она должна быть локальной rt или percolate таблицей. Не должна быть частью кластера.
3. Неявно освобождает любые блокировки таблиц, удерживаемые текущей сессией.
4. Ожидает завершения всех текущих изменений (вставок/замен/обновлений).
5. Увеличивает счетчик блокировок на чтение таблицы.

Операторы изменения, такие как insert/replace/update/delete, сначала проверяют, заблокирована ли таблица на чтение. В таком случае они будут отклонены с ошибкой "table is locked".

Блокировка на запись:

1. Проверяет, что протокол текущего соединения mysql.
2. Не проверяет, подходит ли таблица или даже существует ли она.
3. Неявно освобождает любые блокировки таблиц, удерживаемые текущей сессией.
4. Выдает предупреждение "Write lock is not implemented."

<!-- request Example -->

```sql
LOCK TABLES tbl READ, tbl2 WRITE;
```

<!-- end -->

## Снятие блокировки таблицы

<!-- example unlock -->

```sql
UNLOCK TABLES
```

Команда `UNLOCK` явно снимает любые блокировки таблиц, удерживаемые текущей сессией sphinxql.

Если соединение клиентской сессии прерывается, независимо от того, нормально или ненормально, демон неявно снимает все
блокировки таблиц, удерживаемые сессией. Если клиент повторно подключается, блокировки больше не действуют.

<!-- request Example -->

```sql
UNLOCK TABLES;
```

<!-- end -->


## SHOW LOCKS

<!-- example show_locks -->

Заблокированные и замороженные таблицы также отображаются с помощью команды `SHOW LOCKS`. Счетчики блокировок показываются в столбце `Additional Info`.

<!-- request Example -->

```sql
SHOW LOCKS;
```

<!-- response Example -->

```sql
+-----------+------+-----------+-----------------+
| Type      | Name | Lock Type | Additional Info |
+-----------+------+-----------+-----------------+
| rt        | a    | read      | Count: 1        |
| percolate | bar  | freeze    | Count: 3        |
| rt        | foo  | freeze    | Count: 2        |
+-----------+------+-----------+-----------------+
3 rows in set (0,01 sec)
```

<!-- end -->

