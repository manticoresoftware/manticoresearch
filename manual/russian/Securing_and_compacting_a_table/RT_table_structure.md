# Структура таблицы в реальном времени

Обычную таблицу можно создать из внешнего источника с помощью специального инструмента под названием `indexer`, который читает "рецепт" из конфигурации, подключается к источникам данных, извлекает документы и строит файлы таблицы. Этот процесс занимает много времени. Если ваши данные меняются, таблица становится устаревшей, и её нужно перестраивать из обновлённых источников. Если ваши данные меняются по нарастающей, например, блог или лента новостей, где старые документы никогда не меняются, а добавляются только новые, перестроение будет занимать всё больше времени, поскольку вам придётся снова и снова обрабатывать архивные источники с каждым проходом.

Один из способов решения этой проблемы — использовать несколько таблиц вместо одной большой таблицы. Например, вы можете обработать источники за предыдущие годы и сохранить таблицу. Затем взять только источники за текущий год и поместить их в отдельную таблицу, перестраивая её так часто, как необходимо. Затем вы можете объединить обе таблицы в составную распределённую таблицу и использовать её для запросов. Смысл в том, что при каждой перестройке вы обрабатываете только данные за последние 12 месяцев максимум, а таблица с более старыми данными остаётся неизменной и не требует перестроения. Можно пойти дальше и разделить таблицу за последние 12 месяцев на месячные, недельные или ежедневные таблицы и так далее.

Этот подход работает, но вам нужно поддерживать распределённую таблицу вручную. То есть добавлять новые куски, удалять старые и не допускать слишком большого количества частичных таблиц (слишком большое число таблиц может замедлить поиск, а ОС обычно ограничивает количество одновременно открытых файлов). Чтобы решить эту проблему, можно вручную объединять несколько таблиц, запуская [indexer --merge](../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Merging_tables.md). Однако это только решает проблему большого количества таблиц, усложняя обслуживание. И даже при пересборке "каждый час" вы, скорее всего, получите заметный временной разрыв между появлением новых данных в источниках и перестроением таблицы, которая делает эти данные доступными для поиска.

Таблица в реальном времени предназначена для решения этой проблемы. Она состоит из двух частей:

1. Специальной таблицы в памяти (называемой RAM chunk), которая содержит части данных, поступающих прямо сейчас.
2. Коллекции обычных таблиц, называемых дисковыми кусками (disk chunks), которые были созданы ранее.

Это очень похоже на стандартную [распределённую таблицу](../Creating_a_table/Creating_a_distributed_table/Creating_a_distributed_table.md), состоящую из нескольких локальных таблиц.

Вам не нужно создавать такую таблицу с помощью запуска `indexer`, который читает "рецепт" из конфигурации и таблицы источников данных. Вместо этого таблица в реальном времени предоставляет возможность 'вставлять' новые документы и 'заменять' существующие. При выполнении команды 'insert' вы отправляете новые документы на сервер. Он затем строит небольшую таблицу из добавленных документов и сразу же делает её доступной онлайн. Таким образом, сразу после завершения команды 'insert' вы можете выполнять поиск по всем частям таблицы, включая только что добавленные документы.

Сервер поиска автоматически поддерживает таблицу, так что вам не нужно об этом заботиться. Однако вы можете заинтересоваться несколькими деталями о том, "как она поддерживается".

**Во-первых, поскольку индексированные данные хранятся в памяти — что насчёт внезапного отключения питания?** Потеряю ли я тогда свою таблицу? Ну, перед завершением сервер сохраняет новые данные в специальный 'binlog'. Это состоит из одного или нескольких файлов на постоянном носителе, которые инкрементально растут по мере добавления новых изменений. Вы можете настроить поведение работы с binlog относительно того, как часто новые запросы (или транзакции) сохраняются в binlog, и как часто командой 'sync' вызывается синхронизация файла binlog, чтобы ОС действительно записала данные на безопасное хранилище. Наиболее параноидальный способ — сбрасывать буфер и синхронизировать после каждой транзакции. Это самый медленный, но и самый безопасный метод. Самый дешевый способ — полностью отключить binlog. Это самый быстрый метод, но вы рискуете потерять индексированные данные. Также предусмотрены промежуточные варианты, например сброс и синхронизация каждую секунду.

Binlog специально разработан для последовательного сохранения поступающих транзакций; он не является таблицей и по нему нельзя выполнять поиск. Это лишь страховка, гарантирующая, что сервер не потеряет ваши данные. Если происходит внезапный сбой и всё прекращает работать из-за проблемы с программным обеспечением или оборудованием, сервер загрузит самый свежий доступный дамп RAM chunk, а затем повторит binlog, проигрывая сохранённые транзакции. В конечном итоге он восстановит то же состояние, в котором находился в момент последнего изменения.

**Во-вторых, что насчёт ограничений?** Что если я хочу обработать, скажем, 10ТБ данных, но они просто не помещаются в память! Объём памяти для таблицы в реальном времени ограничен и может быть настроен. Когда индексируется определённый объём данных, сервер управляет частью таблицы в памяти, объединяя мелкие транзакции, поддерживая их число и общий размер в разумных пределах. Однако этот процесс иногда вызывает задержки при вставке. Когда объединение перестаёт помогать, и новые вставки достигают [лимита памяти](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#rt_mem_limit), сервер конвертирует таблицу в памяти в обычную таблицу на диске (называемую дисковым куском). Эта таблица добавляется в коллекцию таблиц во второй части RT таблицы и становится доступной онлайн. Память при этом очищается и освобождается.

Когда данные из памяти надёжно сохранены на диске, что происходит:

* когда сервер сохраняет собранные данные как дисковую таблицу
* или когда он сбрасывает часть в памяти при корректном завершении работы или с помощью [ручного сброса](../Securing_and_compacting_a_table/Flushing_RAM_chunk_to_disk.md#FLUSH-TABLE)

binlog для этой таблицы становится больше не нужен. Поэтому он удаляется. Если все таблицы сохранены, binlog будет удалён.

**Третий пункт: как насчёт коллекции дисков?** Если наличие множества дисковых частей замедляет поиск, в чём разница, если я создам их вручную в виде распределённой таблицы, или они будут сгенерированы в виде дисковых частей (или «чанков») таблицей RT? В обоих случаях вы можете объединить несколько таблиц в одну. Например, можно объединить почасовые таблицы за вчера и сохранить вместо них одну «суточную» таблицу за вчера. При ручном обслуживании вам нужно самостоятельно продумывать схему и команды. В случае таблицы RT сервер предоставляет команду [OPTIMIZE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE), которая делает то же самое, но избавляет вас от необходимости разбираться во внутренних деталях.

**Четвёртый пункт: если мой «документ» представляет собой «мини-таблицу» и он мне больше не нужен, я могу просто его выбросить. Но если он «оптимизирован», то есть смешан вместе с множеством других документов, как мне отменить операцию или удалить его?** Да, индексированные документы «смешаны» вместе, и удалить один без перестройки всей таблицы непросто. И если для простых таблиц перестройка или слияние - это нормальный способ обслуживания, то для таблиц реального времени (RT) это облегчает манипуляции, но не обеспечивает настоящей работы в реальном времени. Чтобы решить эту проблему, Manticore использует трюк: при удалении документа с идентификатором документа сервер просто фиксирует этот номер. Вместе с другими удалёнными документами их идентификаторы сохраняются в так называемом [kill-листе](../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Killlist_in_plain_tables.md#Table-kill-list). При поиске по таблице сервер сначала получает все совпадающие документы, а потом исключает документы, найденные в kill-листе (это самое простое описание; на самом деле внутри всё сложнее). Суть в том, что ради «немедленного» удаления документы фактически не удаляются, а просто помечаются как «удалённые». Они всё ещё занимают место в различных структурах таблицы и по сути являются мусором. Статистика слов, влияющая на ранжирование, также не меняется, то есть поиск происходит среди всех документов, а отмеченные как удалённые просто не показываются в окончательном результате. Когда документ [заменяется](../Data_creation_and_modification/Updating_documents/REPLACE.md), это означает, что он помечается как удалённый в старых частях таблицы и вставляется заново в самую свежую часть. Все последствия «скрытия через kill-лист» также действуют в этом случае.

Когда происходит перестройка части таблицы, например, при слиянии некоторых транзакций (сегментов) RAM-чанка, или при конвертации RAM-чанка в дисковый чанок, либо при слиянии двух дисковых чанков, сервер выполняет полный перебор затронутых частей и физически исключает удалённые документы из всех из них. То есть, если документ был в списках документов некоторых слов — он стирается. Если слово было уникальным — оно полностью удаляется.

В качестве резюме: удаление происходит в два этапа:
1. Сначала документы помечаются как «удалённые» в реальном времени и подавляются в результатах поиска.
2. При выполнении некоторых операций с чанком таблицы RT удалённые документы окончательно физически удаляются.

**Пятый пункт: если таблица RT содержит в своей коллекции простые дисковые таблицы, могу ли я просто добавить туда готовую старую дисковую таблицу?** Нет. Это не позволит избежать ненужной сложности и случайной порчи данных. Однако если ваша таблица RT была только что создана и не содержит данных, вы можете [ПРИСОЕДИНИТЬ ТАБЛИЦУ](../Data_creation_and_modification/Adding_data_from_external_storages/Adding_data_to_tables/Attaching_one_table_to_another.md) своей дисковой таблицы к ней. Ваша старая таблица будет перенесена внутрь таблицы RT и станет её частью.

В качестве резюме о структуре таблицы RT: это умело организованная коллекция простых дисковых таблиц с быстрой таблицей в памяти, предназначенная для вставок в реальном времени и полуреального времени для удаления документов. Таблица RT имеет общую схему, общие настройки и может легко обслуживаться без глубокого погружения в детали.
<!-- proofread -->

