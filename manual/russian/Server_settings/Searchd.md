# Раздел "Searchd" в конфигурации
Ниже приведены настройки, которые должны использоваться в разделе `searchd` конфигурационного файла Manticore Search для управления поведением сервера. Ниже представлен краткий обзор каждой настройки:
### access_plain_attrs
Эта настройка задает значение по умолчанию для всего экземпляра для [access_plain_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, со значением по умолчанию `mmap_preread`.
Директива `access_plain_attrs` позволяет вам определить значение по умолчанию для [access_plain_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых данным экземпляром searchd. Директивы для каждой таблицы имеют более высокий приоритет и заменят это значение по умолчанию для всего экземпляра, обеспечивая более детальный контроль.
### access_blob_attrs
Эта настройка задает значение по умолчанию для всего экземпляра для [access_blob_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, со значением по умолчанию `mmap_preread`.
Директива `access_blob_attrs` позволяет вам определить значение по умолчанию для [access_blob_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых данным экземпляром searchd. Директивы для каждой таблицы имеют более высокий приоритет и заменят это значение по умолчанию для всего экземпляра, обеспечивая более детальный контроль.
### access_doclists
Эта настройка задает значение по умолчанию для всего экземпляра для [access_doclists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, со значением по умолчанию `file`.
Директива `access_doclists` позволяет вам определить значение по умолчанию для [access_doclists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых данным экземпляром searchd. Директивы для каждой таблицы имеют более высокий приоритет и заменят это значение по умолчанию для всего экземпляра, обеспечивая более детальный контроль.
### access_hitlists
Эта настройка задает значение по умолчанию для всего экземпляра для [access_hitlists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, со значением по умолчанию `file`.
Директива `access_hitlists` позволяет вам определить значение по умолчанию для [access_hitlists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых данным экземпляром searchd. Директивы для каждой таблицы имеют более высокий приоритет и заменят это значение по умолчанию для всего экземпляра, обеспечивая более детальный контроль.
### access_dict
Эта настройка задает значение по умолчанию для всего экземпляра для [access_dict](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, со значением по умолчанию `mmap_preread`.
Директива `access_dict` позволяет вам определить значение по умолчанию для [access_dict](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых данным экземпляром searchd. Директивы для каждой таблицы имеют более высокий приоритет и заменят это значение по умолчанию для всего экземпляра, обеспечивая более детальный контроль.
### agent_connect_timeout
Эта настройка задает значение по умолчанию для параметра [agent_connect_timeout](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_connect_timeout).
### agent_query_timeout
Эта настройка задает значение по умолчанию для параметра [agent_query_timeout](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_query_timeout). Его можно переопределить для каждого запроса, используя параметр `OPTION agent_query_timeout=XXX`.
### agent_retry_count
Эта настройка является целым числом, которое указывает, сколько раз Manticore попытается подключиться и выполнить запрос к удаленным агентам через распределенную таблицу, прежде чем сообщить о фатальной ошибке запроса. Значение по умолчанию – 0 (т.е. без повторных попыток). Вы также можете установить это значение для каждого запроса, используя параметр `OPTION retry_count=XXX`. Если предоставлена опция для каждого запроса, она заменит значение, указанное в конфигурации.
Обратите внимание, что если вы используете [агентские зеркала](../Creating_a_cluster/Remote_nodes/Mirroring.md#Agent-mirrors) в определении своей распределенной таблицы, сервер выберет другое зеркало для каждой попытки подключения в соответствии с выбранной [ha_strategy](../Creating_a_cluster/Remote_nodes/Load_balancing.md#ha_strategy). В этом случае `agent_retry_count` будет агрегироваться для всех зеркал в наборе.
Например, если у вас есть 10 зеркал и вы установите `agent_retry_count=5`, сервер повторит попытку до 50 раз, предполагая в среднем 5 попыток для каждого из 10 зеркал (при опции `ha_strategy = roundrobin` это будет так).
Однако значение, указанное в качестве опции `retry_count` для [агента](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent), служит абсолютным лимитом. Другими словами, опция `[retry_count=2]` в определении агента всегда означает максимум 2 попытки, независимо от того, указали ли вы 1 или 10 зеркал для агента.
### agent_retry_delay
Эта настройка является целым числом в миллисекундах (или [special_suffixes](../Server_settings/Special_suffixes.md)), которое указывает задержку перед тем, как Manticore повторит попытку запроса к удаленному агенту в случае сбоя. Это значение актуально только когда задано ненулевое значение [agent_retry_count](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md) или ненулевое значение `retry_count` для конкретного запроса. Значение по умолчанию – 500. Вы также можете установить это значение на уровне конкретного запроса, используя параметр `OPTION retry_delay=XXX`. Если предоставлена опция для конкретного запроса, она заменит значение, указанное в конфигурации.
### attr_flush_period
<!-- example conf attr_flush_period -->
Когда вы используете [Update](../Data_creation_and_modification/Updating_documents/UPDATE.md) для изменения атрибутов документа в реальном времени, изменения сначала записываются в копию атрибутов в памяти. Эти обновления происходят в памяти, работающей по карте файла, что означает, что ОС решает, когда записывать изменения на диск. При нормальном завершении работы `searchd` (инициируемом сигналом `SIGTERM`) все изменения принудительно записываются на диск.

Вы также можете instruировать `searchd`, чтобы периодически записывать эти изменения обратно на диск для предотвращения потери данных. Интервал между этими сбросами определяется `attr_flush_period`, указанным в секундах (или [special_suffixes](../Server_settings/Special_suffixes.md)).

По умолчанию значение равно 0, что отключает периодический сброс. Однако сброс все равно будет происходить во время нормального завершения работы.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
attr_flush_period = 900 # сохранять обновления на диск каждые 15 минут
```
<!-- end -->

### auto_optimize

<!-- example conf auto_optimize -->
Эта настройка управляет автоматическим процессом [OPTIMIZE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE) для сжатия таблицы.

По умолчанию сжатие таблицы происходит автоматически. Вы можете изменить это поведение с помощью настройки `auto_optimize`:
* 0 для отключения автоматического сжатия таблицы (вы все равно можете вручную вызывать `OPTIMIZE`)
* 1 для явного включения
* 2 для включения с умножением порога оптимизации на 2.

По умолчанию, OPTIMIZE выполняется до тех пор, пока количество дисковых чанков не станет меньше или равно количеству логических CPU-ядр, умноженных на 2.

Однако, если у таблицы есть атрибуты с KNN индексами, этот порог отличается. В этом случае он устанавливается в количество физических CPU-ядр, деленное на 2, чтобы улучшить производительность поиска KNN.

Обратите внимание, что переключение `auto_optimize` в режим включения или отключения не препятствует вам запускать [OPTIMIZE TABLE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE) вручную.

<!-- intro -->
##### Пример:

<!-- request Disable -->
```ini
auto_optimize = 0 # отключить автоматическое OPTIMIZE
```

<!-- request Throttle -->
```ini
auto_optimize = 2 # OPTIMIZE начинается с 16 чанков (на сервере с 4 CPU ядрами)
```

<!-- end -->

### auto_schema

<!-- example conf auto_schema -->
Manticore поддерживает автоматическое создание таблиц, которые еще не существуют, но указаны в операторах INSERT. Эта функция включена по умолчанию. Чтобы отключить ее, установите `auto_schema = 0` явно в вашей конфигурации. Чтобы снова включить ее, установите `auto_schema = 1` или удалите настройку `auto_schema` из конфигурации.

Имейте в виду, что HTTP-эндпоинт `/bulk` не поддерживает автоматическое создание таблиц.

> ЗАМЕТКА: Функциональность [авто-схемы](../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real_time_table.md#Auto-schema) требует [Manticore Buddy](../Installation/Manticore_Buddy.md). Если это не работает, убедитесь, что Buddy установлен.

<!-- request Disable -->
```ini
auto_schema = 0 # отключить автоматическое создание таблиц
```

<!-- request Enable -->
```ini
auto_schema = 1 # включить автоматическое создание таблиц
```

<!-- end -->

### binlog_flush

<!-- example conf binlog_flush -->
Эта настройка управляет режимом сброса/синхронизации бинарного журнала транзакций. Она является необязательной, со значением по умолчанию 2 (сбрасывать каждую транзакцию, синхронизироваться каждую секунду).

Директива определяет, как часто бинарный журнал будет сбрасываться в ОС и синхронизироваться с диском. Поддерживаются три режима:

*  0, сброс и синхронизация каждую секунду. Это обеспечивает наилучшие показатели производительности, но в случае сбоя сервера или сбоя ОС/аппаратного обеспечения может быть потеряно до 1 секунды зафиксированных транзакций.
*  1, сброс и синхронизация каждой транзакции. Этот режим обеспечивает худшую производительность, но гарантирует, что данные каждой зафиксированной транзакции будут сохранены.
*  2, сброс каждую транзакцию, синхронизация каждую секунду. Этот режим предоставляет хорошую производительность и обеспечивает сохранение каждой зафиксированной транзакции в случае сбоя сервера. Однако в случае сбоя ОС/аппаратного обеспечения может быть потеряно до 1 секунды зафиксированных транзакций.

Для тех, кто знаком с MySQL и InnoDB, эта директива похожа на `innodb_flush_log_at_trx_commit`. В большинстве случаев режим по умолчанию 2 обеспечивает хороший баланс между скоростью и безопасностью, с полной защитой данных RT-таблицы от сбоев сервера и некоторой защитой от аппаратных сбоев.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_flush = 1 # максимальная безопасность, низкая скорость
```
<!-- end -->


### binlog_max_log_size

<!-- example conf binlog_max_log_size -->
Эта настройка управляет максимальным размером файла бинарного журнала. Она является необязательной, со значением по умолчанию 256 МБ.

Новый файл бинарного журнала будет принудительно открыт, как только текущий файл бинарного журнала достигнет этого предела размера. Это приводит к более тонкой гранулярности журналов и может привести к более эффективному использованию дискового пространства бинарного журнала в определенных пограничных нагрузках. Значение 0 указывает на то, что файл бинарного журнала не должен быть повторно открыт на основе размера.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_max_log_size = 16M
```
<!-- end -->


### binlog_path

<!-- example conf binlog_path -->
Эта настройка определяет путь к файлам бинарного журнала (также известным как журнал транзакций). Она является необязательной, со значением по умолчанию, установленным в директорию данных, настроенную во время сборки (например, `/var/lib/manticore/data/binlog.*` в Linux).

Бинарные журналы используются для восстановления данных RT-таблиц и для обновления атрибутов простых дисковых индексов, которые в противном случае будут храниться только в ОЗУ до сброса. Когда ведение журнала включено, каждая транзакция, зафиксированная в RT-таблице, записывается в файл журнала. Журналы затем автоматически воспроизводятся при запуске после некорректного завершения работы, восстанавливая зафиксированные изменения.
Директива `binlog_path` указывает местоположение бинарных файлов журналов. Она должна содержать только путь; `searchd` будет создавать и удалять несколько файлов `binlog.*` в директории по мере необходимости (включая данные журнала, метаданные и файлы блокировок и т. д).

Пустое значение отключает бинарное логирование, что улучшает производительность, но ставит данные RT таблиц под риск.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_path = # отключить логирование
binlog_path = /var/lib/manticore/data # будут созданы /var/lib/manticore/data/binlog.001 и т.д.
```
<!-- end -->


### buddy_path

<!-- example conf buddy_path -->
Эта настройка определяет путь к бинарному файлу Manticore Buddy. Она является необязательной, при этом значение по умолчанию — это путь, настроенный во время сборки, который различается в разных операционных системах. Обычно вы не нуждаетесь в изменении этой настройки. Тем не менее, это может быть полезно, если вы хотите запустить Manticore Buddy в режиме отладки, внести изменения в Manticore Buddy или реализовать новый плагин. В последнем случае вы можете выполнить `git clone` Buddy с https://github.com/manticoresoftware/manticoresearch-buddy, добавить новый плагин в директорию `./plugins/` и выполнить `composer install --prefer-source` для упрощения разработки после изменения директории на исходный код Buddy.

Чтобы убедиться, что вы можете запустить `composer`, ваша машина должна иметь установленный PHP 8.2 или выше с следующими расширениями:

```
--enable-dom
--with-libxml
--enable-tokenizer
--enable-xml
--enable-xmlwriter
--enable-xmlreader
--enable-simplexml
--enable-phar
--enable-bcmath
--with-gmp
--enable-debug
--with-mysqli
--enable-mysqlnd
```

Вы также можете выбрать специальную версию `manticore-executor-dev` для Linux amd64, доступную в релизах, например: https://github.com/manticoresoftware/executor/releases/tag/v1.0.13

Если вы выберете этот путь, не забудьте связать версию dev мантекорной системы с `/usr/bin/php`.

Чтобы отключить Manticore Buddy, установите значение в пустое, как показано в примере.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
buddy_path = manticore-executor -n /usr/share/manticore/modules/manticore-buddy/src/main.php --debug # используйте Manticore Buddy по умолчанию в Linux, но запустите его в режиме отладки
buddy_path = manticore-executor -n /opt/homebrew/share/manticore/modules/manticore-buddy/bin/manticore-buddy/src/main.php --debug # используйте Manticore Buddy по умолчанию в MacOS arm64, но запустите его в режиме отладки
buddy_path = manticore-executor -n /Users/username/manticoresearch-buddy/src/main.php --debug # используйте Manticore Buddy из нестандартного расположения
buddy_path = # отключает Manticore Buddy
buddy_path = manticore-executor -n /Users/username/manticoresearch-buddy/src/main.php --debugv --skip=manticoresoftware/buddy-plugin-replace # debugv - включает более подробное логирование, --skip - пропускает плагины
```
<!-- end -->

### client_timeout

<!-- example conf client_timeout -->
Эта настройка определяет максимальное время ожидания между запросами (в секундах или [special_suffixes](../Server_settings/Special_suffixes.md)) при использовании постоянных соединений. Она является необязательной, значение по умолчанию составляет пять минут.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
client_timeout = 1h
```
<!-- end -->


### collation_libc_locale

<!-- example conf collation_libc_locale -->
Локаль libc сервера. Необязательная, по умолчанию C.

Указывает локаль libc, влияющую на сортировки, основанные на libc. Смотрите раздел [collations](../Searching/Collations.md) для подробностей.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
collation_libc_locale = fr_FR
```
<!-- end -->


### collation_server

<!-- example conf collation_server -->
Сортировка по умолчанию для сервера. Необязательная, по умолчанию libc_ci.

Указывает сортировку по умолчанию, используемую для входящих запросов. Сортировку можно переопределить на основе каждого запроса. Смотрите раздел [collations](../Searching/Collations.md) для списка доступных сортировок и других деталей.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
collation_server = utf8_ci
```
<!-- end -->


### data_dir

<!-- example conf data_dir -->
Если указано, эта настройка включает [режим реального времени](../Creating_a_table/Local_tables.md#Online-schema-management-%28RT-mode%29), который является обязательным способом управления схемой данных. Значение должно быть путем к директории, где вы хотите хранить все свои таблицы, бинарные журналы и все остальное, необходимое для правильного функционирования Manticore Search в этом режиме.
Индексация [простых таблиц](../Creating_a_table/Local_tables/Plain_table.md) не разрешена, когда указано `data_dir`. Узнайте больше о различиях между режимом реального времени и простым режимом в [этом разделе](../Read_this_first.md#Real-time-table-vs-plain-table).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
data_dir = /var/lib/manticore
```
<!-- end -->

### diskchunk_flush_search_timeout

<!-- example conf diskchunk_flush_search_timeout -->
Таймаут для предотвращения автоматической выгрузки блока RAM, если в таблице нет поисковых запросов. Необязательная, по умолчанию 30 секунд.

Время, чтобы проверить наличие поисковых запросов, прежде чем определять, следует ли выполнять автоматическую выгрузку.
Автоматическая выгрузка произойдет только в том случае, если было хотя бы одно обращение к таблице в пределах последних `diskchunk_flush_search_timeout` секунд. Работает в сочетании с [diskchunk_flush_write_timeout](../../Server_settings/Searchd.md#diskchunk_flush_write_timeout). Соответствующая [настройка на уровне таблицы](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#diskchunk_flush_search_timeout) имеет более высокий приоритет и переопределит это значение для всего экземпляра, обеспечивая более детальный контроль.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
diskchunk_flush_search_timeout = 120s
```
<!-- end -->

### diskchunk_flush_write_timeout

<!-- example conf diskchunk_flush_write_timeout -->
Время в секундах, которое нужно ждать без записи перед автоматической выгрузкой блока RAM на диск. Необязательно, по умолчанию 1 секунда.

Если в блоке RAM не происходит запись в течение `diskchunk_flush_write_timeout` секунд, блок будет выгружен на диск. Работает в сочетании с [diskchunk_flush_search_timeout](../../Server_settings/Searchd.md#diskchunk_flush_search_timeout). Чтобы отключить автоматическую выгрузку, явно установите `diskchunk_flush_write_timeout = -1` в вашей конфигурации. Соответствующая [перетабличная настройка](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#diskchunk_flush_write_timeout) имеет более высокий приоритет и переопределит этот экземплярный вариант по умолчанию, обеспечивая более детальный контроль.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
diskchunk_flush_write_timeout = 60s
```
<!-- end -->

### docstore_cache_size

<!-- example conf docstore_cache_size -->
Эта настройка определяет максимальный размер блоков документов из хранилища документов, которые хранятся в памяти. Она необязательная, со значением по умолчанию 16m (16 мегабайт).

Когда используется `stored_fields`, блоки документов считываются с диска и распаковываются. Поскольку каждый блок обычно содержит несколько документов, он может быть повторно использован при обработке следующего документа. Для этой цели блок хранится в кэше на уровне сервера. Кэш хранит распакованные блоки.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
docstore_cache_size = 8m
```
<!-- end -->

### engine

<!-- example conf engine -->
Стандартный движок хранения атрибутов, используемый при создании таблиц в RT режиме. Может быть `rowwise` (по умолчанию) или `columnar`.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
engine = columnar
```
<!-- end -->


### expansion_limit

<!-- example conf expansion_limit -->
Эта настройка определяет максимальное количество расширенных ключевых слов для одного подстановочного знака. Она необязательная, со значением по умолчанию 0 (без ограничения).

При выполнении поиска подстрок в таблицах, построенных с включенной функцией `dict = keywords`, один подстановочный знак может потенциально привести к тысячам или даже миллионам совпадающих ключевых слов (учтите, что это может совпадать с `a*` по всему словарю Оксфорда). Эта директива позволяет ограничить влияние таких расширений. Установка `expansion_limit = N` ограничивает расширения не более чем N наиболее частыми совпадающими ключевыми словами (для каждого подстановочного знака в запросе).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_limit = 16
```
<!-- end -->

### expansion_merge_threshold_docs

<!-- example conf expansion_merge_threshold_docs -->
Эта настройка определяет максимальное количество документов в расширенном ключевом слове, которое позволяет объединять все такие ключевые слова. Она необязательная, со значением по умолчанию 32.

При выполнении поиска подстрок в таблицах, построенных с включенной функцией `dict = keywords`, один подстановочный знак может потенциально привести к тысячам или даже миллионам совпадающих ключевых слов. Эта директива позволяет увеличить лимит на то, сколько ключевых слов будет объединяться для ускорения совпадений, но при этом использует больше памяти в поиске.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_merge_threshold_docs = 1024
```
<!-- end -->

### expansion_merge_threshold_hits

<!-- example conf expansion_merge_threshold_hits -->
Эта настройка определяет максимальное количество совпадений в расширенном ключевом слове, которое позволяет объединять все такие ключевые слова. Она необязательная, со значением по умолчанию 256.

При выполнении поиска подстрок в таблицах, построенных с включенной функцией `dict = keywords`, один подстановочный знак может потенциально привести к тысячам или даже миллионам совпадающих ключевых слов. Эта директива позволяет увеличить лимит на то, сколько ключевых слов будет объединяться для ускорения совпадений, но при этом использует больше памяти в поиске.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_merge_threshold_hits = 512
```
<!-- end -->

### grouping_in_utc

Эта настройка указывает, будет ли временная группировка в API и SQL рассчитываться в местной временной зоне или в UTC. Она необязательная, со значением по умолчанию 0 (что означает 'местная временная зона').

По умолчанию все выражения 'группировка по времени' (например, группировка по дням, неделям, месяцам и годам в API, также группировка по дням, месяцам, годам, годам/месяцам, годам/месяцам/дням в SQL) выполняются с использованием местного времени. Например, если у вас есть документы с атрибутами временной привязки `13:00 utc` и `15:00 utc`, в случае группировки они оба попадут в группы объектов в соответствии с настройками вашей местной временной зоны. Если вы живете в `utc`, это будет один день, но если вы живете в `utc+10`, тогда эти документы будут соответствовать разным группам объектов 'группировка по дням' (поскольку 13:00 utc в временной зоне UTC+10 это 23:00 местного времени, а 15:00 это 01:00 следующего дня). Иногда такое поведение неприемлемо, и желательно сделать временную группировку независимой от временной зоны. Вы можете запустить сервер с определенной глобальной переменной окружения TZ, но это повлияет не только на группировку, но и на временные метки в журналах, что также может быть нежелательным. Включение этой опции (либо в конфигурации, либо с использованием [SET global](../Server_settings/Setting_variables_online.md#SET) в SQL) приведет к тому, что все выражения временной группировки будут рассчитываться в UTC, оставляя остальные функции, зависящие от времени (т.е. ведение журнала сервера) в местной TZ.


### timezone

Эта настройка определяет временную зону, которая будет использоваться функциями, связанными с датой/временем. По умолчанию используется местная временная зона, но вы можете указать другую временную зону в формате IANA (например, `Europe/Amsterdam`).

Обратите внимание, что эта настройка не влияет на ведение журнала, которое всегда работает в местной временной зоне.
Также обратите внимание, что если используется `grouping_in_utc`, функция 'группировка по времени' все равно будет использовать UTC, в то время как другие функции, связанные с датой/временем, будут использовать указанную временную зону. В целом, не рекомендуется смешивать `grouping_in_utc` и `timezone`.

Вы можете настроить эту опцию либо в конфигурации, либо с помощью оператора [SET global](../Server_settings/Setting_variables_online.md#SET) в SQL.


### ha_period_karma

<!-- example conf ha_period_karma -->
Эта настройка задает размер окна статистики зеркал агентов в секундах (или [special_suffixes](../Server_settings/Special_suffixes.md)). Она является необязательной, со значением по умолчанию 60 секунд.

Для распределенной таблицы с зеркалами агентов (см. подробнее в [agent](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md)), мастер отслеживает несколько различных счетчиков для каждого зеркала. Эти счетчики затем используются для переключения на резервный экземпляр и балансировки (мастер выбирает лучшее зеркало для использования на основе счетчиков). Счетчики накапливаются блоками по `ha_period_karma` секунд.

После начала нового блока мастер может по-прежнему использовать накопленные значения из предыдущего блока до тех пор, пока новый блок не заполнится на половину. В результате, любая предыдущая история перестает влиять на выбор зеркала после 1.5 раз `ha_period_karma` секунд в наибольшем случае.

Хотя используется не более двух блоков для выбора зеркала, до 15 последних блоков сохраняются для целей инструментирования. Эти блоки можно просмотреть с помощью оператора [SHOW AGENT STATUS](../Node_info_and_management/Node_status.md#SHOW-AGENT-STATUS).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ha_period_karma = 2m
```
<!-- end -->


### ha_ping_interval

<!-- example conf ha_ping_interval -->
Эта настройка определяет интервал между пингами зеркал агентов в миллисекундах (или [special_suffixes](../Server_settings/Special_suffixes.md)). Она является необязательной, со значением по умолчанию 1000 миллисекунд.

Для распределенной таблицы с зеркалами агентов (см. подробнее в [agent](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md)), мастер отправляет всем зеркалам команду пинга в нерабочие периоды. Это необходимо для отслеживания текущего состояния агента (жив или мертв, время сетевого кругового путешествия и т. д.). Интервал между такими пингами определяется этой директивой. Чтобы отключить пинги, установите `ha_ping_interval` в 0.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ha_ping_interval = 3s
```
<!-- end -->


### hostname_lookup

Опция `hostname_lookup` определяет стратегию обновления имен хостов. По умолчанию IP-адреса имен агентов кэшируются при старте сервера, чтобы избежать чрезмерного доступа к DNS. Однако в некоторых случаях IP может изменяться динамически (например, в облачном хостинге), и может быть желательным не кэшировать IP-адреса. Установка этой опции в `request` отключает кэширование и запрашивает DNS для каждого запроса. IP-адреса также можно вручную обновить с помощью команды `FLUSH HOSTNAMES`.

### jobs_queue_size

Настройка `jobs_queue_size` определяет, сколько "работ" может находиться в очереди одновременно. По умолчанию это значение не ограничено.

В большинстве случаев "работа" означает один запрос к одной локальной таблице (обычной таблице или дисковому чанку реальной таблицы). Например, если у вас есть распределенная таблица, состоящая из 2 локальных таблиц или реальной таблицы с 2 дисковыми чанками, поиск в любой из них в основном ставит 2 работы в очередь. Затем пул потоков (размер которого определяется с помощью [threads](../Server_settings/Searchd.md#threads)) будет их обрабатывать. Однако в некоторых случаях, если запрос слишком сложный, может быть создано больше работ. Изменение этой настройки рекомендуется, когда [max_connections](../Server_settings/Searchd.md#max_connections) и [threads](../Server_settings/Searchd.md#threads) недостаточны для достижения баланса между желаемой производительностью.

### join_batch_size

Объединение таблиц осуществляется путем накопления пакета совпадений, которые являются результатами запроса, выполненного на левой таблице. Этот пакет затем обрабатывается как единый запрос на правой таблице.

Эта опция позволяет вам регулировать размер пакета. Значение по умолчанию равно `1000`, а установка этой опции в `0` отключает пакетирование.

Больший размер пакета может улучшить производительность; однако для некоторых запросов это может привести к чрезмерному потреблению памяти.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
join_batch_size = 2000
```
<!-- end -->

### join_cache_size

Каждый запрос, выполняемый на правой таблице, определяется конкретными условиями JOIN ON, которые определяют набор результатов, извлекаемых из правой таблицы.

Если существует лишь несколько уникальных условий JOIN ON, повторное использование результатов может быть более эффективным, чем многократное выполнение запросов на правой таблице. Для этого наборы результатов сохраняются в кэше.

Эта опция позволяет вам настроить размер этого кэша. Значение по умолчанию равно `20 MB`, а установка этой опции в 0 отключает кэширование.

Обратите внимание, что каждый поток поддерживает собственный кэш, поэтому вы должны учитывать число потоков, выполняющих запросы, при оценке общего потребления памяти.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
join_cache_size = 10M
```
<!-- end -->

### listen_backlog

<!-- example conf listen_backlog -->
Настройка `listen_backlog` определяет длину очереди прослушиваний TCP для входящих соединений. Это особенно актуально для сборок под Windows, которые обрабатывают запросы по одному. Когда очередь соединений достигает своего предела, новые входящие соединения будут отклонены.
Для сборок, не относящихся к Windows, значение по умолчанию должно работать нормально, и обычно нет необходимости настраивать эту настройку.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
listen_backlog = 20
```
<!-- end -->

### kibana_version_string

<!-- example conf kibana_version_string -->
Строка версии сервера, которую возвращать в Kibana или OpenSearch Dashboards. Необязательный параметр — по умолчанию установлено `7.6.0`.

Некоторые версии Kibana и OpenSearch Dashboards ожидают, что сервер будет сообщать о конкретном номере версии и могут вести себя иначе в зависимости от него. Чтобы обойти такие проблемы, вы можете использовать эту настройку, которая заставляет Manticore сообщать произвольную версию Kibana или OpenSearch Dashboards.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
kibana_version_string = 1.2.3
```
<!-- end -->

### listen

<!-- example conf listen -->
Эта настройка позволяет вам указать IP-адрес и порт или путь сокета Unix-домена, на котором Manticore будет принимать соединения.

Общий синтаксис для `listen`:

```ini
listen = ( address ":" port | port | path | address ":" port start - port end ) [ ":" protocol [ "_vip" ] [ "_readonly" ] ]
```

Вы можете указать:
* либо IP-адрес (или имя хоста) и номер порта
* или просто номер порта
* или путь к Unix-сокету (не поддерживается на Windows)
* или диапазон IP-адресов и портов

Если вы указали номер порта, но не указали адрес, `searchd` будет слушать на всех сетевых интерфейсах. Путь к Unix-сокету определяется ведущим слешем. Диапазон портов можно задать только для протокола репликации.

Вы также можете указать обработчик протокола (слушатель), который будет использоваться для соединений на этом сокете. Слушатели:

* **Не указано** - Manticore будет принимать соединения на этом порту от:
  - других агентов Manticore (т.е. удаленной распределенной таблицы)
  - клиентов через HTTP и HTTPS
  - [Manticore Buddy](https://manticoresearch.com/blog/manticoresearch-buddy-intro/). **Убедитесь, что у вас есть слушатель этого типа (или слушатель `http`, как упоминалось ниже), чтобы избежать ограничений функциональности Manticore.**
* `mysql` Протокол MySQL для соединений от клиентов MySQL. Обратите внимание:
  - Сжатый протокол также поддерживается.
  - Если включен [SSL](../Security/SSL.md#SSL), вы можете установить зашифрованное соединение.
* `replication` - протокол репликации, используемый для связи между узлами. Более подробную информацию можно найти в разделе [репликации](../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md). Вы можете указать несколько слушателей репликации, но все они должны слушать на одном и том же IP; только порты могут быть разными. Когда вы определяете слушатель репликации с диапазоном портов (например, `listen = 192.168.0.1:9320-9328:replication`), Manticore не начинает немедленно слушать на этих портах. Вместо этого он возьмет случайные свободные порты из указанного диапазона только при начале использования репликации. Для корректной работы репликации требуется как минимум 2 порта в диапазоне.
* `http` - то же самое, что и **Не указано**. Manticore будет принимать соединения на этом порту от удаленных агентов и клиентов через HTTP и HTTPS.
* `https` - Протокол HTTPS. Manticore будет принимать **только** HTTPS соединения на этом порту. Более подробную информацию можно найти в разделе [SSL](../Security/SSL.md).
* `sphinx` - устаревший двоичный протокол. Используется для обслуживания соединений от удаленных [SphinxSE](../Extensions/SphinxSE.md) клиентов. Некоторые реализации клиентов Sphinx API (например, на Java) требуют явного указания слушателя.

Добавление суффикса `_vip` к протоколам клиентов (то есть, всем, кроме `replication`, например, `mysql_vip` или `http_vip` или просто `_vip`) заставляет создавать выделенный поток для соединения, чтобы обойти различные ограничения. Это полезно для обслуживания узлов в случае сильной перегрузки, когда сервер либо зависает, либо не позволяет вам подключаться через обычный порт.

Суффикс `_readonly` устанавливает [режим только для чтения](../Security/Read_only.md) для слушателя и ограничивает его в принятии только запросов на чтение.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
listen = localhost
listen = localhost:5000 # слушать удаленные агенты (двойной API) и http/https запросы на порту 5000 на localhost
listen = 192.168.0.1:5000 # слушать удаленные агенты (двойной API) и http/https запросы на порту 5000 на 192.168.0.1
listen = /var/run/manticore/manticore.s # слушать запросы бинарного API на unix сокете
listen = /var/run/manticore/manticore.s:mysql # слушать mysql запросы на unix сокете
listen = 9312 # слушать удаленные агенты (двойной API) и http/https запросы на порту 9312 на любом интерфейсе
listen = localhost:9306:mysql # слушать mysql запросы на порту 9306 на localhost
listen = localhost:9307:mysql_readonly # слушать mysql запросы на порту 9307 на localhost и принимать только запросы на чтение
listen = 127.0.0.1:9308:http # слушать http запросы, а также соединения от удаленных агентов (и двойной API) на порту 9308 на localhost
listen = 192.168.0.1:9320-9328:replication # слушать соединения репликации на портах 9320-9328 на 192.168.0.1
listen = 127.0.0.1:9443:https # слушать запросы https (не http) на порту 9443 на 127.0.0.1
listen = 127.0.0.1:9312:sphinx # слушать устаревшие Sphinx запросы (например, от SphinxSE) на порту 9312 на 127.0.0.1
```
<!-- end -->

Может быть несколько директив `listen`. `searchd` будет слушать клиентские подключения на всех указанных портах и сокетах. Конфигурация по умолчанию, предоставленная в пакетах Manticore, определяет прослушивание на портах:
* `9308` и `9312` для соединений от удаленных агентов и клиентов, не основанных на MySQL
* и на порту `9306` для MySQL подключений.

Если вы не укажете ни одной `listen` в конфигурации, Manticore будет ждать соединений на:
* `127.0.0.1:9306` для клиентов MySQL
* `127.0.0.1:9312`  для HTTP/HTTPS и соединений от других узлов Manticore и клиентов, основанных на бинарном API Manticore.

#### Прослушивание на привилегированных портах
По умолчанию Linux не позволит вам запустить Manticore на порту ниже 1024 (например, `listen = 127.0.0.1:80:http` или `listen = 127.0.0.1:443:https`), если вы не запустите searchd от имени root. Если вы все же хотите иметь возможность запустить Manticore, чтобы он слушал на портах < 1024 от пользователя, не обладающего правами root, рассмотрите возможность выполнения одного из следующих действий (любое из этих действий должно сработать):
* Выполните команду `setcap CAP_NET_BIND_SERVICE=+eip /usr/bin/searchd`
* Добавьте `AmbientCapabilities=CAP_NET_BIND_SERVICE` в unit-файл Manticore в systemd и перезагрузите демон (`systemctl daemon-reload`).

#### Технические детали протокола Sphinx API и TFO
<details>
Устаревший протокол Sphinx имеет 2 фазы: обмен рукопожатиями и поток данных. Рукопожатие состоит из пакета в 4 байта от клиента и пакета в 4 байта от демона с единственной целью - клиент определяет, что удаленный узел является настоящим демоном Sphinx, а демон определяет, что удаленный узел является настоящим клиентом Sphinx. Основной поток данных довольно прост: пусть обе стороны объявят свои рукопожатия, а противоположная проверит их. Этот обмен краткими пакетами подразумевает использование специального флага `TCP_NODELAY`, который отключает алгоритм Nagle для TCP и декларирует, что TCP-соединение будет выполняться как диалог небольших пакетов.
Однако не строго определено, кто говорит первым в этом переговорах. Исторически все клиенты, использующие двоичный API, говорят первыми: отправляют рукопожатие, затем читают 4 байта от демона, затем отправляют запрос и читают ответ от демона.
Когда мы улучшали совместимость протокола Sphinx, мы учитывали эти моменты:

1. Обычно связь между мастером и агентом устанавливается от известного клиента к известному хосту на известном порту. Таким образом, невозможно, чтобы конечная точка предоставила неправильное рукопожатие. Таким образом, мы можем косвенно предположить, что обе стороны действительны и действительно говорят на протоколе Sphinx.
2. Учитывая это предположение, мы можем 'склеить' рукопожатие с реальным запросом и отправить его в одном пакете. Если бэкенд является устаревшим демоном Sphinx, он просто прочитает этот склеенный пакет как 4 байта рукопожатия, а затем тело запроса. Поскольку оба они пришли в одном пакете, стек бэкенда имеет -1 RTT, а буфер фронтенда все еще работает, несмотря на это обычным образом.
3. Продолжая предположение: поскольку пакет 'query' довольно мал, а рукопожатие еще меньше, давайте отправим оба в начальном 'SYN' TCP-пакете с использованием современной техники TFO (tcp-fast-open). То есть: мы подключаемся к удаленному узлу с пакетом склеенного рукопожатия + тела. Демон принимает соединение и сразу же получает и рукопожатие, и тело в буфере сокета, так как они пришли в самом первом TCP 'SYN' пакете. Это исключает еще один RTT.
4. Наконец, обучите демон принимать это улучшение. На самом деле, с точки зрения приложения, это подразумевает НЕ использование `TCP_NODELAY`. А с точки зрения системы это подразумевает обеспечить, чтобы на стороне демона активация TFO была включена, а на стороне клиента отправка TFO также была активирована. По умолчанию в современных системах клиент TFO уже активирован по умолчанию, так что вам нужно только настроить серверный TFO, чтобы все работало.

Все эти улучшения без фактического изменения самого протокола позволили нам устранить 1.5 RTT протокола TCP от соединения. Что означает, если запрос и ответ могут быть помещены в один TCP-пакет, уменьшает всю сессию двоичного API с 3.5 RTT до 2 RTT - что делает сетевуюNegotiation примерно в 2 раза быстрее.

Итак, все наши улучшения основаны на изначально неопределенном заявлении: 'кто говорит первым.' Если клиент говорит первым, мы можем применять все эти оптимизации и эффективно обрабатывать соединение + рукопожатие + запрос в одном TFO-пакете. Более того, мы можем посмотреть на начало полученного пакета и определить настоящий протокол. Именно поэтому вы можете подключиться к одному и тому же порту через API/http/https. Если демон должен говорить первым, все эти оптимизации невозможны, и мультипротокол тоже невозможен. Именно поэтому у нас есть выделенный порт для MySQL, и мы не объединили его со всеми другими протоколами в один и тот же порт. Вдруг, среди всех клиентов, оказался один, написанный с намеком на то, что демон должен отправить рукопожатие первым. То есть - никакой возможности для всех описанных улучшений. Это плагин SphinxSE для mysql/mariadb. Поэтому, специально для этого единственного клиента, мы выделили определение протокола `sphinx`, чтобы работать наиболее устаревшим образом. А именно: обе стороны активируют `TCP_NODELAY` и обмениваются небольшими пакетами. Демон отправляет свое рукопожатие при соединении, затем клиент отправляет свое, и затем все работает обычным образом. Это не очень оптимально, но просто работает. Если вы используете SphinxSE для подключения к Manticore - вам нужно выделить слушателя с явно указанным протоколом `sphinx`. Для других клиентов - избегайте использования этого слушателя, так как он медленнее. Если вы используете других клиентов устаревшего Sphinx API - сначала проверьте, могут ли они работать с недедицированным мультипротокольным портом. Для связи мастер-агент использование недедицированного (мультипротокольного) порта и активация TFO на стороне клиента и сервера хорошо работает и определенно сделает работу сетевого бэкенда быстрее, особенно если у вас очень легкие и быстрые запросы.
</details>

### listen_tfo

Эта настройка позволяет флаг TCP_FASTOPEN для всех слушателей. По умолчанию им управляет система, но его можно явно отключить, установив в '0'.

Для общего ознакомления с расширением TCP Fast Open, пожалуйста, обратитесь к [Wikipedia](https://en.wikipedia.org/wiki/TCP_Fast_Open). Короче говоря, это позволяет устранить одну TCP-круговую поездку при установлении соединения.

На практике использование TFO во многих ситуациях может оптимизировать сетевую эффективность клиента-агента, так как если [постоянные агенты](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md) находятся в игре, но без активных соединений и также без ограничения на максимальное количество соединений.
На современных ОС поддержка TFO обычно включена на уровне системы, но это всего лишь «возможность», а не правило. Linux (как наиболее прогрессивный) поддерживает это с 2011 года, начиная с версий ядра 3.7 (для серверной стороны). Windows поддерживает это с некоторых сборок Windows 10. Другие операционные системы (FreeBSD, MacOS) также участвуют в игре.

Для сервера Linux система проверяет переменную `/proc/sys/net/ipv4/tcp_fastopen` и ведет себя в соответствии с ней. Бит 0 управляет клиентской стороной, бит 1 контролирует слушателей. По умолчанию система имеет этот параметр, установленный на 1, т.е. клиенты включены, слушатели отключены.

### лог

<!-- пример конфигурации лог -->
Настройка лога указывает имя файла лога, в который будут записаны все события времени выполнения `searchd`. Если не указано, то имя по умолчанию - 'searchd.log'.

В качестве имени файла вы также можете использовать 'syslog'. В этом случае события будут отправлены демону syslog. Чтобы использовать опцию syslog, вам необходимо настроить Manticore с опцией `-–with-syslog` во время сборки.


<!-- ввод -->
##### Пример:

<!-- пример запроса -->

```ini
log = /var/log/searchd.log
```
<!-- конец -->


### max_batch_queries

<!-- пример конф max_batch_queries -->
Ограничивает количество запросов в одной партии. Необязательно, по умолчанию 32.

Заставляет searchd выполнять проверку разумности количества запросов, поданных в одной партии при использовании [мульти-запросов](../Searching/Multi-queries.md). Установите его на 0, чтобы пропустить проверку.


<!-- ввод -->
##### Пример:

<!-- пример запроса -->

```ini
max_batch_queries = 256
```
<!-- конец -->

### max_connections

<!-- пример max_connections -->
Максимальное количество одновременных клиентских соединений. По умолчанию неограничено. Это обычно заметно только при использовании любого типа постоянных соединений, таких как сессии cli mysql или постоянные удаленные соединения от удаленных распределенных таблиц. Когда лимит превышен, вы все равно можете подключиться к серверу, используя [VIP-соединение](../Connecting_to_the_server/MySQL_protocol.md#VIP-connection). VIP-соединения не учитываются в лимите.

<!-- пример запроса -->
```ini
max_connections = 10
```

<!-- конец -->

### max_threads_per_query

<!-- пример max_threads_per_query -->
Лимит на уровне экземпляра потоков, которые может использовать одна операция. По умолчанию соответствующие операции могут занимать все ядра ЦП, не оставляя места для других операций. Например, `call pq` к значительно крупной таблице перколяции может использовать все потоки в течение десятков секунд. Установка `max_threads_per_query` на, скажем, половину от [потоков](../Server_settings/Searchd.md#threads) обеспечит возможность одновременного выполнения нескольких таких операций `call pq`.

Вы также можете установить эту настройку как сессию или глобальную переменную во время выполнения.

Кроме того, вы можете контролировать поведение на уровне каждого запроса с помощью [опции threads](../Searching/Options.md#threads).

<!-- ввод -->
##### Пример:
<!-- пример запроса -->

```ini
max_threads_per_query = 4
```

<!-- конец -->

### max_filters

<!-- пример конф max_filters -->
Максимально допустимое количество фильтров на запрос. Эта настройка используется только для внутренних проверок корректности и не оказывает непосредственного влияния на использование ОЗУ или производительность. Необязательно, по умолчанию 256.


<!-- ввод -->
##### Пример:

<!-- пример запроса -->

```ini
max_filters = 1024
```
<!-- конец -->


### max_filter_values

<!-- пример конф max_filter_values -->
Максимально допустимое количество значений на фильтр. Эта настройка используется только для внутренних проверок корректности и не оказывает непосредственного влияния на использование ОЗУ или производительность. Необязательно, по умолчанию 4096.


<!-- ввод -->
##### Пример:

<!-- пример запроса -->

```ini
max_filter_values = 16384
```
<!-- конец -->


### max_open_files

<!-- пример конф max_open_files -->
Максимальное количество файлов, которые сервер может открыть, называется "мягким лимитом". Обратите внимание, что обслуживание больших фрагментированных таблиц в реальном времени может потребовать установления этого лимита на высоком уровне, так как каждый диск может занимать дюжину или более файлов. Например, таблица в реальном времени с 1000 частями может требовать открытия тысяч файлов одновременно. Если вы столкнетесь с ошибкой 'Слишком много открытых файлов' в логах, попробуйте скорректировать эту опцию, так как это может помочь решить проблему.

Существует также "жесткий лимит", который не может быть превышен данной опцией. Этот лимит определяется системой и может быть изменен в файле `/etc/security/limits.conf` на Linux. В других операционных системах могут быть другие подходы, поэтому проконсультируйтесь с вашими руководствами для получения дополнительной информации.

<!-- ввод -->
##### Пример:

<!-- пример запроса -->

```ini
max_open_files = 10000
```
<!-- конец -->

<!-- пример конф max_open_files max -->
Помимо прямых числовых значений, вы можете использовать магическое слово 'max', чтобы установить лимит равным доступному текущему жесткому лимиту.

<!-- ввод -->
##### Пример:

<!-- пример запроса -->

```ini
max_open_files = max
```
<!-- конец -->


### max_packet_size

<!-- пример конф max_packet_size -->
Максимально допустимый размер сетевого пакета. Эта настройка ограничивает как пакеты запроса от клиентов, так и пакеты ответа от удаленных агентов в распределенной среде. Используется только для внутренних проверок корректности, она не оказывает непосредственного влияния на использование ОЗУ или производительность. Необязательно, по умолчанию 128M.


<!-- ввод -->
##### Пример:

<!-- пример запроса -->

```ini
max_packet_size = 32M
```
<!-- конец -->


### mysql_version_string

<!-- пример конф mysql_version_string -->
Строка версии сервера для возврата через протокол MySQL. Необязательно, по умолчанию пустая (возвращает версию Manticore).
Несколько привередливых клиентских библиотек MySQL зависят от определенного формата номера версии, используемого MySQL, и, кроме того, иногда выбирают другой путь выполнения в зависимости от сообщенного номера версии (вместо указанных флагов возможностей). Например, Python MySQLdb 1.2.2 вызывает исключение, когда номер версии не в формате X.Y.ZZ; MySQL .NET connector 6.3.x теряет работоспособность при номерах версии 1.x вместе с определенной комбинацией флагов и т. д. Для обхода этого вы можете использовать директиву `mysql_version_string`, чтобы `searchd` сообщал клиентам, подключающимся по протоколу MySQL, другую версию. (По умолчанию, он сообщает свою собственную версию.)


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
mysql_version_string = 5.0.37
```
<!-- end -->


### net_workers

Количество сетевых потоков, по умолчанию 1.

Эта настройка полезна для крайне высоких частот запросов, когда одного потока недостаточно для управления всеми входящими запросами.


### net_wait_tm

Управляет интервалом активного цикла сетевого потока. По умолчанию -1, его можно установить на -1, 0 или положительное целое число.

В случаях, когда сервер сконфигурирован как чистый мастер и просто маршрутизирует запросы к агентам, важно обрабатывать запросы без задержек и не позволять сетевому потоку засыпать. Для этого существует активный цикл. После входящего запроса сетевой поток использует нагрузку CPU в течение `10 * net_wait_tm` миллисекунд, если `net_wait_tm` является положительным числом, или выполняет опрос только с использованием CPU, если `net_wait_tm` равно `0`. Также активный цикл можно отключить с помощью `net_wait_tm = -1` - в этом случае опросщик устанавливает тайм-аут на фактические тайм-ауты агентов в системном вызове опроса.

> **WARNING:** Активный цикл CPU фактически нагружает ядро CPU, поэтому установка этого значения на любое ненастандартное значение приведет к заметному использованию CPU даже при неактивном сервере.


### net_throttle_accept

Определяет, сколько клиентов принимается на каждой итерации сетевого цикла. По умолчанию 0 (без ограничений), что должно быть нормально для большинства пользователей. Это вариант тонкой настройки для контроля пропускной способности сетевого цикла в условиях высокой нагрузки.


### net_throttle_action

Определяет, сколько запросов обрабатывается на каждой итерации сетевого цикла. По умолчанию 0 (без ограничений), что должно быть нормально для большинства пользователей. Это вариант тонкой настройки для контроля пропускной способности сетевого цикла в условиях высокой нагрузки.

### network_timeout

<!-- example conf network_timeout -->
Таймаут чтения/записи запроса сетевого клиента, в секундах (или [special_suffixes](../Server_settings/Special_suffixes.md)). Необязательный, по умолчанию 5 секунд. `searchd` принудительно закроет соединение с клиентом, если он не успевает отправить запрос или прочитать результат в течение этого тайм-аута.

Обратите внимание также на параметр [reset_network_timeout_on_packet](../Server_settings/Searchd.md#reset_network_timeout_on_packet). Этот параметр изменяет поведение `network_timeout`, применяя его не ко всему `query` или `result`, а к отдельным пакета вместо. Обычно запрос/результат помещается в один или два пакета. Однако в случаях, когда требуется большое количество данных, этот параметр может быть бесценным для поддержания активных операций.

<!-- request Example -->

```ini
network_timeout = 10s
```
<!-- end -->

### node_address

<!-- example conf node_address -->
Эта настройка позволяет вам указать сетевой адрес узла. По умолчанию он установлен на адрес репликации [listen](../Server_settings/Searchd.md#listen). Это верно в большинстве случаев; однако есть ситуации, когда вам нужно указать его вручную:

* Узел за файрволом
* Включен перевод сетевых адресов (NAT)
* Развертывания в контейнерах, таких как Docker или облачные развертывания
* Кластеры с узлами в более чем одном регионе


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
node_address = 10.101.0.10
```
<!-- end -->

### not_terms_only_allowed

<!-- example conf not_terms_only_allowed -->
Эта настройка определяет, разрешать ли запросы только с оператором полного текста [отрицания](../Searching/Full_text_matching/Operators.md#Negation-operator). Необязательный, по умолчанию 0 (отказ в запросах только с оператором NOT).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
not_terms_only_allowed = 1
```
<!-- end -->

### optimize_cutoff

<!-- example conf optimize_cutoff -->
Устанавливает порог сжатия таблицы по умолчанию. Читать больше здесь - [Число оптимизированных дисковых фрагментов](../Securing_and_compacting_a_table/Compacting_a_table.md#Number-of-optimized-disk-chunks). Эта настройка может быть переопределена параметром запроса [cutoff](../Securing_and_compacting_a_table/Compacting_a_table.md#Number-of-optimized-disk-chunks). Она также может быть изменена динамически через [SET GLOBAL](../Server_settings/Setting_variables_online.md#SET).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
optimize_cutoff = 4
```
<!-- end -->

### persistent_connections_limit

<!-- example conf persistent_connections_limit -->
Эта настройка определяет максимальное количество одновременных постоянных соединений с удаленными [постоянными агентами](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md). Каждый раз, когда агент, определенный в `agent_persistent`, подключается, мы пытаемся повторно использовать существующее соединение (если оно есть) или подключиться и сохранить соединение для будущего использования. Однако в некоторых случаях имеет смысл ограничить количество таких постоянных соединений. Эта директива определяет предел. Это влияет на количество соединений с хостом каждого агента через все распределенные таблицы.

Разумно установить значение равным или меньше, чем опция [max_connections](../Server_settings/Searchd.md#max_connections) в конфигурации агента.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
persistent_connections_limit = 29 # предполагаем, что у каждого хоста агентов max_connections = 30 (или 29).
```
<!-- end -->


### pid_file

<!-- пример конф pid_file -->
pid_file - это обязательный параметр конфигурации в Manticore search, который указывает путь к файлу, где хранится идентификатор процесса сервера `searchd`.

Файл идентификатора процесса searchd создается заново и блокируется при запуске, и содержит идентификатор главного серверного процесса во время работы сервера. Он будет удален при завершении работы сервера.
Цель этого файла - позволить Manticore выполнять различные внутренние задачи, такие как проверка, есть ли уже запущенный экземпляр `searchd`, остановка `searchd` и уведомление его о необходимости ротировать таблицы. Файл также может быть использован для внешних автоматизированных скриптов.


<!-- intro -->
##### Пример:

<!-- запрос Пример -->

```ini
pid_file = /var/run/manticore/searchd.pid
```
<!-- end -->


### predicted_time_costs

<!-- пример конф predicted_time_costs -->
Стоимости для модели предсказания времени запроса, в наносекундах. Необязательно, значение по умолчанию `doc=64, hit=48, skip=2048, match=64`.

<!-- intro -->
##### Пример:

<!-- запрос Пример -->

```ini
predicted_time_costs = doc=128, hit=96, skip=4096, match=128
```
<!-- end -->

<!-- пример конф predicted_time_costs 1 -->
Прекращение запросов до завершения на основе их времени выполнения (с настройкой максимального времени запроса) является хорошей подстраховкой, но имеет свой внутренний недостаток: неопределенные (нестабильные) результаты. То есть, если вы несколько раз повторите один и тот же (сложный) поисковый запрос с ограничением по времени, ограничение по времени будет достигнуто на разных этапах, и вы получите *разные* наборы результатов.

<!-- intro -->
##### SQL:

<!-- запрос SQL -->

```sql
SELECT … OPTION max_query_time
```
<!-- запрос API -->

```api
SetMaxQueryTime()
```
<!-- end -->

Существует новая опция, [SELECT … OPTION max_predicted_time](../Searching/Options.md#max_predicted_time), которая позволяет вам ограничить время запроса *и* получить стабильные, повторяемые результаты. Вместо того, чтобы регулярно проверять текущее время, пока выполняется запрос, что является неопределенным, она предсказывает текущее время выполнения, используя вместо этого простую линейную модель:

```ini
predicted_time =
    doc_cost * processed_documents +
    hit_cost * processed_hits +
    skip_cost * skiplist_jumps +
    match_cost * found_matches
```

Запрос будет завершен досрочно, когда `predicted_time` достигнет определенного предела.

Конечно, это не жесткий лимит на фактическое затраченное время (тем не менее, это жесткий лимит на объем *обработки*), и простая линейная модель отнюдь не является идеально точной. Поэтому время на часах *может* быть как ниже, так и выше целевого предела. Тем не менее, допустимые погрешности вполне приемлемы: например, в наших экспериментах с целевым лимитом в 100 мс большинство тестовых запросов находились в диапазоне от 95 до 105 мс, и *все* запросы находились в диапазоне от 80 до 120 мс. Кроме того, как приятный побочный эффект, использование моделируемого времени запроса вместо измерения фактического времени выполнения приводит к немного меньшему количеству вызовов gettimeofday().

Ни одна пара серверов не идентична, поэтому директива `predicted_time_costs` позволяет вам настраивать стоимости для вышеупомянутой модели. Для удобства они являются целыми числами, измеряемыми в наносекундах. (Лимит в max_predicted_time измеряется в миллисекундах, и необходимость указывать значения стоимости как 0.000128 мс вместо 128 нс является несколько более подверженной ошибкам.) Не обязательно указывать все четыре стоимости одновременно, поскольку пропущенные примут значения по умолчанию. Тем не менее, мы настоятельно рекомендуем указывать все из них для читабельности.


### preopen_tables

<!-- пример конф preopen_tables -->
Директива конфигурации preopen_tables указывает, следует ли принудительно предварительно открыть все таблицы при запуске. Значение по умолчанию равно 1, что означает, что все таблицы будут предварительно открыты независимо от параметра [preopen](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Other-performance-related-settings) для каждой таблицы. Если установлено в 0, настройки для каждой таблицы могут вступить в силу, и они по умолчанию составят 0.

Предварительное открытие таблиц может предотвратить гонки между поисковыми запросами и ротациями, которые могут иногда приводить к сбоям запросов. Тем не менее, это также требует больше дескрипторов файлов. В большинстве сценариев рекомендуется предварительное открытие таблиц.

Вот пример конфигурации:

<!-- intro -->
##### Пример:

<!-- запрос Пример -->

```ini
preopen_tables = 1
```
<!-- end -->

### pseudo_sharding

<!-- пример конф pseudo_sharding -->
Настройка pseudo_sharding включает параллелизацию поисковых запросов к локальным обычным и реальным таблицам, независимо от того, запрашиваются ли они напрямую или через распределенную таблицу. Эта функция автоматически параллелизует запросы до количества потоков, указанного в `searchd.threads`.

Обратите внимание, что если ваши рабочие потоки уже заняты, потому что у вас:
* высокая конкуренция запросов
* физическое шардирование любого рода:
  - распределенная таблица из нескольких обычных/реальных таблиц
  - реальная таблица, состоящая из слишком многих дисковых частей

то включение pseudo_sharding может не дать никаких преимуществ и даже привести к небольшому снижению пропускной способности. Если вы предпочитаете более высокую пропускную способность над более низкой задержкой, рекомендуется отключить эту опцию.

Включено по умолчанию.

<!-- intro -->
##### Пример:

<!-- запрос Пример -->

```ini
pseudo_sharding = 0
```
<!-- end -->


### replication_connect_timeout

Директива `replication_connect_timeout` определяет тайм-аут для подключения к удаленному узлу. Поскольку по умолчанию значение предполагается в миллисекундах, оно может иметь [другой суффикс](../../Server_settings/Special_suffixes.md). Значение по умолчанию - 1000 (1 секунда).
При подключении к удалённому узлу Manticore будет ожидать это количество времени максимум, чтобы успешно завершить подключение. Если время ожидания истекло, но соединение не было установлено, и `retries` включены, будет инициирована попытка повторного подключения.


### replication_query_timeout

Параметр `replication_query_timeout` задаёт количество времени, в течение которого searchd будет ожидать, пока удалённый узел завершит запрос. Значение по умолчанию - 3000 миллисекунд (3 секунды), но может быть `suffixed`, чтобы указать другую единицу времени.

После установления соединения Manticore будет ждать максимум `replication_query_timeout` для завершения запроса удалённым узлом. Обратите внимание, что этот таймаут отдельный от `replication_connect_timeout`, и общая возможная задержка, вызванная удалённым узлом, будет равна сумме обоих значений.


### replication_retry_count

Эта настройка является целым числом, которое указывает, сколько раз Manticore будет пытаться подключиться и выполнить запрос к удалённому узлу во время репликации, прежде чем сообщить об ошибке запроса. Значение по умолчанию - 3.


### replication_retry_delay

Эта настройка является целым числом в миллисекундах (или [special_suffixes](../Server_settings/Special_suffixes.md)), которое указывает задержку перед тем, как Manticore повторит попытку запроса к удалённому узлу в случае сбоя во время репликации. Это значение актуально только тогда, когда задано ненулевое значение. Значение по умолчанию - 500.

### qcache_max_bytes

<!-- example conf qcache_max_bytes -->
Эта настройка устанавливает максимальный объём RAM, выделяемый для кэшированных наборов результатов в байтах. Значение по умолчанию - 16777216, что эквивалентно 16 мегабайтам. Если значение установлено на 0, кэш запросов отключен. Для получения дополнительной информации о кэше запросов, обратитесь к [кэшу запросов](../Searching/Query_cache.md).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
qcache_max_bytes = 16777216
```
<!-- end -->


### qcache_thresh_msec

Целое число, в миллисекундах. Минимальный порог времени для кэширования результата запроса. По умолчанию 3000, или 3 секунды. 0 означает кэширование всего. Обратитесь к [кэшу запросов](../Searching/Query_cache.md) для получения подробностей. Это значение также может быть выражено с использованием времени [special_suffixes](../Server_settings/Special_suffixes.md), но будьте осторожны и не путайте себя с названием самого значения, содержащим '_msec'.


### qcache_ttl_sec

Целое число, в секундах. Период истечения срока действия для кэшированного набора результатов. По умолчанию 60, или 1 минута. Минимально возможное значение - 1 секунда. Обратитесь к [кэшу запросов](../Searching/Query_cache.md) для получения подробностей. Это значение также может быть выражено с использованием времени [special_suffixes](../Server_settings/Special_suffixes.md), но будьте осторожны и не путайте себя с названием самого значения, содержащим '_sec'.


### query_log_format

<!-- example conf query_log_format -->
Формат журнала запросов. Необязательный, допустимые значения - `plain` и `sphinxql`, по умолчанию `sphinxql`.

Режим `sphinxql` регистрирует действительные SQL-запросы. Режим `plain` регистрирует запросы в текстовом формате (в основном подходит для чисто полнотекстовых случаев использования). Эта директива позволяет вам переключаться между двумя форматами при запуске сервера поиска. Формат журнала также может быть изменён на лету с использованием синтаксиса `SET GLOBAL query_log_format=sphinxql`. Обратитесь к [журналированию запросов](../Logging/Query_logging.md) для получения дополнительных сведений.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
query_log_format = sphinxql
```
<!-- end -->

### query_log_min_msec

Ограничение (в миллисекундах), которое предотвращает запись запроса в журнал запросов. Необязательный, по умолчанию 0 (все запросы записываются в журнал запросов). Эта директива определяет, что только запросы с временем выполнения, превышающим указанное ограничение, будут записаны (это значение также может быть выражено с использованием времени [special_suffixes](../Server_settings/Special_suffixes.md), но будьте осторожны и не путайте себя с названием самого значения, содержащим `_msec`).

### query_log

<!-- example conf query_log -->
Имя файла журнала запросов. Необязательный, по умолчанию пусто (запись запросов не производится). Все поисковые запросы (такие как SELECT ... но не INSERT/REPLACE/UPDATE запросы) будут записаны в этот файл. Формат описан в [журналировании запросов](../Logging/Query_logging.md). В случае формата 'plain' вы можете использовать 'syslog' как путь к файлу журнала. В этом случае все поисковые запросы будут отправлены демону syslog с приоритетом `LOG_INFO`, предварительно помеченные '[query]', вместо временной метки. Чтобы использовать опцию syslog, Manticore должен быть настроен с `-–with-syslog` при сборке.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
query_log = /var/log/query.log
```
<!-- end -->


### query_log_mode

<!-- example conf query_log_mode -->
Директива query_log_mode позволяет вам установить разные разрешения для файлов поиска и журнала запросов. По умолчанию эти журналы создаются с разрешением 600, что означает, что только пользователь, от имени которого работает сервер, и пользователи root могут читать журналы.
Эта директива может быть полезной, если вы хотите разрешить другим пользователям читать журналы, например, для решений мониторинга, работающих от пользователей без прав root.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
query_log_mode  = 666
```
<!-- end -->

### read_buffer_docs

<!-- example conf read_buffer_docs -->
Директива read_buffer_docs управляет размером буфера чтения на ключевое слово для списков документов. Для каждого вхождения ключевого слова в каждом поисковом запросе существует два связанных буфера чтения: один для списка документов и один для списка попаданий. Эта настройка позволяет вам контролировать размер буфера списка документов.

Больший размер буфера может увеличить использование RAM на запрос, но может потенциально уменьшить время ввода-вывода. Имеет смысл устанавливать большие значения для медленного хранения, но для хранилищ, способных к высоким IOPS, эксперименты следует проводить в области низких значений.
Значение по умолчанию составляет 256K, а минимальное значение — 8K. Вы также можете установить [read_buffer_docs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#read_buffer_docs) для каждой таблицы, что переопределит все настройки на уровне конфигурации сервера.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
read_buffer_docs = 128K
```
<!-- end -->


### read_buffer_hits

<!-- example conf read_buffer_hits -->
Директива read_buffer_hits задает размер буфера чтения по ключевому слову для списков попаданий в поисковых запросах. По умолчанию размер составляет 256K, а минимальное значение — 8K. Для каждого вхождения ключевого слова в поисковом запросе есть два связанных буфера чтения: один для списка документов и один для списка попаданий. Увеличение размера буфера может увеличить использование RAM на запрос, но уменьшить время I/O. Для медленного хранилища большие размеры буфера имеют смысл, в то время как для хранилища, способного на высокие IOPS, следует экспериментировать на уровне низких значений.

Эта настройка также может быть указана для каждой таблицы с помощью параметра read_buffer_hits в [read_buffer_hits](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#read_buffer_hits), который переопределит настройку на уровне сервера.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
read_buffer_hits = 128K
```
<!-- end -->

### read_unhinted

<!-- example conf read_unhinted -->
Размер чтения без подсказки. Необязательно, по умолчанию 32K, минимально 1K

При запросах некоторые чтения заранее знают, сколько данных нужно прочитать, но некоторые в данный момент этого не знают. В первую очередь, размер списка попаданий в данный момент не известен заранее. Эта настройка позволяет вам контролировать, сколько данных следует прочитать в таких случаях. Это влияет на время I/O для списка попаданий, уменьшая его для списков, превышающих размер чтения без подсказки, но увеличивая его для более маленьких списков. Это **не** влияет на использование RAM, поскольку буфер чтения уже будет выделен. Поэтому он не должен превышать read_buffer.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
read_unhinted = 32K
```
<!-- end -->

### reset_network_timeout_on_packet

<!-- example conf reset_network_timeout_on_packet -->
Уточняет поведение таймаутов сети (таких как `network_timeout`, `read_timeout` и `agent_query_timeout`).

Когда установлено значение 0, таймауты ограничивают максимальное время для отправки всего запроса/запроса.
Когда установлено значение 1 (по умолчанию), таймауты ограничивают максимальное время между сетевыми действиями.

При репликации узел может понадобиться отправить большой файл (например, 100GB) на другой узел. Предположим, что сеть может передавать данные со скоростью 1GB/s, с серией пакетов размером 4-5MB каждый. Чтобы передать весь файл, вам потребуется 100 секунд. Таймаут по умолчанию в 5 секунд позволит передать только 5GB до разрыва соединения. Увеличение таймаута может быть временным решением, но это не масштабируемо (например, следующий файл может быть 150GB, что приведет к сбою снова). Однако с установленным по умолчанию `reset_network_timeout_on_packet` равным 1, таймаут применяется не ко всей передаче, а к отдельным пакетам. Пока передача продолжается (и данные действительно принимаются по сети в течение периода таймаута), соединение остается активным. Если передача зависает, так что таймаут происходит между пакетами, она будет разорвана.

Обратите внимание, что если вы настраиваете распределенную таблицу, каждый узел — как мастер, так и агенты — должен быть отрегулирован. На стороне мастера воздействует `agent_query_timeout`; на агентах актуален `network_timeout`.

<!-- intro -->

##### Пример:

<!-- request Example -->

```ini
reset_network_timeout_on_packet = 0
```

<!-- end -->


### rt_flush_period

<!-- example conf rt_flush_period -->
Период проверки сброса блоков RAM таблиц RT, в секундах (или [special_suffixes](../Server_settings/Special_suffixes.md)). Необязательно, по умолчанию 10 часов.

Активно обновляемые таблицы RT, которые полностью помещаются в блоки RAM, все еще могут привести к постоянному росту binlogs, что влияет на использование диска и время восстановления после сбоя. С помощью данной директивы сервер поиска выполняет периодические проверки сброса, и подходящие блоки RAM могут быть сохранены, что позволяет осуществить последующую очистку binlog. См. [Бинарная запись](../Logging/Binary_logging.md) для более подробной информации.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
rt_flush_period = 3600 # 1 hour
```
<!-- end -->


### rt_merge_iops

<!-- example conf rt_merge_iops -->
Максимальное количество операций ввода-вывода (в секунду), которые поток объединения блоков RT может начать. Необязательно, по умолчанию 0 (без ограничений).

Эта директива позволяет вам ограничить влияние ввода-вывода, возникающее из-за операторов `OPTIMIZE`. Гарантируется, что все действия оптимизации RT не будут генерировать больше дисковых IOPS (операций ввода-вывода в секунду), чем заданный лимит. Ограничение rt_merge_iops может снизить ухудшение производительности поиска, вызванное объединением.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
rt_merge_iops = 40
```
<!-- end -->

### rt_merge_maxiosize

<!-- example conf rt_merge_maxiosize -->
Максимальный размер операции ввода-вывода, которую поток объединения блоков RT может начать. Необязательно, по умолчанию 0 (без ограничений).

Эта директива позволяет вам ограничить влияние ввода-вывода, возникающее из-за операторов `OPTIMIZE`. I/O, превышающие этот лимит, будут разбиты на два или более I/O, которые затем будут учитываться как отдельные I/O с учетом лимита [rt_merge_iops](../Server_settings/Searchd.md#rt_merge_iops). Таким образом, гарантируется, что все действия оптимизации не генерируют более (rt_merge_iops * rt_merge_maxiosize) байт дискового ввода-вывода в секунду.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
rt_merge_maxiosize = 1M
```
<!-- end -->


### seamless_rotate

<!-- example conf seamless_rotate -->
Предотвращает зависания `searchd` во время ротации таблиц с огромными объемами данных для предварительного кеширования. Необязательно, по умолчанию 1 (включена бесшовная ротация). В системах Windows бесшовная ротация по умолчанию отключена.

Таблицы могут содержать некоторые данные, которые необходимо предварительно кешировать в ОЗУ. В данный момент файлы `.spa`, `.spb`, `.spi` и `.spm` полностью кешируются (они содержат данные атрибутов, данные атрибутов блобов, таблицу ключевых слов и карту убитых строк соответственно). Без бесшовной ротации ротация таблицы пытается использовать как можно меньше ОЗУ и работает следующим образом:

1. Новые запросы временно отклоняются (с кодом ошибки "retry");

2. `searchd` ждет завершения всех текущих запросов;

3. Старая таблица освобождается, а ее файлы переименовываются;

4. Файлы новой таблицы переименовываются, и выделяется необходимое ОЗУ;

5. Данные атрибутов и словаря новой таблицы предварительно загружаются в ОЗУ;

6. `searchd` возобновляет обслуживание запросов из новой таблицы.

Однако, если данных атрибутов или словаря много, то этап предварительной загрузки может занять заметное количество времени - до нескольких минут в случае предварительной загрузки файлов размером 1-5+ ГБ.

С включенной бесшовной ротацией ротация работает следующим образом:

1. Выделяется ОЗУ для хранения новой таблицы;

2. Данные атрибутов и словаря новой таблицы асинхронно предварительно загружаются в ОЗУ;

3. В случае успеха старая таблица освобождается, и файлы обеих таблиц переименовываются;

4. В случае неудачи новая таблица освобождается;

5. В любой данный момент запросы обслуживаются либо из старой, либо из новой копии таблицы.

Бесшовная ротация обходится стоимостью большего пикового использования памяти во время ротации (поскольку обе старые и новые копии данных `.spa/.spb/.spi/.spm` должны находиться в ОЗУ во время предварительной загрузки новой копии). Среднее использование остается прежним.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
seamless_rotate = 1
```
<!-- end -->

### secondary_indexes

<!-- example conf secondary_indexes -->

Эта опция включает/выключает использование вторичных индексов для поисковых запросов. Она является необязательной, а по умолчанию равна 1 (включено). Обратите внимание, что вам не нужно включать ее для индексации, так как она всегда включена, пока [Manticore Columnar Library](https://github.com/manticoresoftware/columnar) установлена. Последняя также необходима для использования индексов при поиске. Доступно три режима:

* `0`: Отключить использование вторичных индексов в поиске. Их можно включить для отдельных запросов с помощью [подсказок анализатора](../Searching/Options.md#Query-optimizer-hints)

* `1`: Включить использование вторичных индексов в поиске. Их можно отключить для отдельных запросов с помощью [подсказок анализатора](../Searching/Options.md#Query-optimizer-hints)

* `force`: То же самое, что и включить, но любые ошибки при загрузке вторичных индексов будут сообщены, и весь индекс не будет загружен в демона.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
secondary_indexes = 1
```

<!-- end -->

### server_id

<!-- example conf server_id -->
Целое число, которое служит идентификатором сервера, используемым в качестве семени для генерации уникального короткого UUID для узлов, которые являются частью кластера репликации. server_id должен быть уникальным среди узлов кластера и находится в диапазоне от 0 до 127. Если server_id не установлен, он вычисляется как хэш MAC-адреса и путь к файлу PID или будет использоваться случайное число в качестве семени для короткого UUID.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
server_id = 1
```
<!-- end -->

### shutdown_timeout

<!-- example conf shutdown_timeout -->
Время ожидания `searchd --stopwait`, в секундах (или [special_suffixes](../Server_settings/Special_suffixes.md)). Необязательно, по умолчанию 60 секунд.

Когда вы запускаете `searchd --stopwait`, ваш сервер должен выполнить некоторые действия перед остановкой, такие как завершение запросов, очищение RT RAM-кусков, очищение атрибутов и обновление бинлога. Эти задачи требуют некоторого времени. `searchd --stopwait` будет ждать до `shutdown_time` секунд, чтобы сервер завершил свои задачи. Подходящее время зависит от размера вашей таблицы и нагрузки.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
shutdown_timeout = 3m # ждать до 3 минут
```
<!-- end -->

### shutdown_token

SHA1-хэш пароля, необходимого для вызова команды 'shutdown' из VIP-соединения Manticore SQL. Без него, [debug](../Reporting_bugs.md#DEBUG) подкоманда 'shutdown' никогда не заставит сервер остановиться. Обратите внимание, что такая простая хешировка не должна считаться надежной защитой, так как мы не используем хэш с солью или какой-либо современный хэш-функцию. Это предназначено как надежная мера для обслуживающих демонов в локальной сети.

### snippets_file_prefix

<!-- example conf snippets_file_prefix -->
Префикс, который будет добавлен к именам локальных файлов при генерации фрагментов. Необязательно, по умолчанию это текущая рабочая папка.

Этот префикс может использоваться для распределенной генерации фрагментов вместе с опциями `load_files` или `load_files_scattered`.

Обратите внимание, что это префикс и **не** путь! Это означает, что если префикс установлен на "server1" и запрос относится к "file23", `searchd` попытается открыть "server1file23" (все это без кавычек). Таким образом, если вам нужно, чтобы это был путь, вам нужно включить завершающий слеш.

После конструирования окончательного пути к файлу сервер разворачивает все относительные директории и сравнивает окончательный результат с значением `snippet_file_prefix`. Если результат не начинается с префикса, такой файл будет отклонен с сообщением об ошибке.

Например, если вы установите его на `/mnt/data`, и кто-то вызовет генерацию фрагментов с файлом `../../../etc/passwd` в качестве источника, они получат сообщение об ошибке:

`Файл '/mnt/data/../../../etc/passwd' выходит за пределы области '/mnt/data/'`

вместо содержимого файла.
Также, при незаданном параметре и чтении `/etc/passwd`, на самом деле будет прочитано /daemon/working/folder/etc/passwd, так как значение по умолчанию для параметра — рабочая папка сервера.

Обратите также внимание, что это локальный параметр; он никоим образом не влияет на агентов. Поэтому вы можете безопасно установить префикс на главном сервере. Запросы, направляемые к агентам, не будут затронуты настройками главного сервера. Однако они будут затронуты собственными настройками агента.

Это может быть полезно, например, когда местоположения хранения документов (независимо от того, локальное ли это хранилище или точки монтирования NAS) несовместимы на разных серверах.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
snippets_file_prefix = /mnt/common/server1/
```
<!-- end -->

> **ПРЕДУПРЕЖДЕНИЕ:** Если вы все же хотите получить доступ к файлам из корня ФС, вам нужно явно установить `snippets_file_prefix` на пустое значение (строка `snippets_file_prefix=`) или на корень (строка `snippets_file_prefix=/`).


### sphinxql_state

<!-- example conf sphinxql_state -->
Путь к файлу, в который будет сериализовано текущее состояние SQL.

При запуске сервера этот файл воспроизводится. При подходящих изменениях состояния (например, SET GLOBAL) этот файл автоматически перезаписывается. Это может предотвратить трудно диагностируемую проблему: если вы загружаете UDF функции, но Manticore выдает сбой, когда он (автоматически) перезапускается, ваши UDF и глобальные переменные больше не будут доступны. Использование постоянного состояния помогает обеспечить плавное восстановление без неожиданных сюрпризов.

`sphinxql_state` не может использоваться для выполнения произвольных команд, таких как `CREATE TABLE`.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
sphinxql_state = uservars.sql
```
<!-- end -->


### sphinxql_timeout

<!-- example conf sphinxql_timeout -->
Максимальное время ожидания между запросами (в секундах, или [special_suffixes](../Server_settings/Special_suffixes.md)) при использовании SQL-интерфейса. Необязательный, по умолчанию 15 минут.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
sphinxql_timeout = 15m
```
<!-- end -->


### ssl_ca

<!-- example conf ssl_ca -->
Путь к файлу сертификата Основного сертификата SSL (CA) (также известного как корневой сертификат). Необязательный, по умолчанию пустой. Если не пустой, сертификат в `ssl_cert` должен быть подписан этим корневым сертификатом.

Сервер использует файл CA для проверки подписи на сертификате. Файл должен быть в формате PEM.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ssl_ca = keys/ca-cert.pem
```
<!-- end -->


### ssl_cert

<!-- example conf ssl_cert -->
Путь к SSL сертификату сервера. Необязательный, по умолчанию пустой.

Сервер использует этот сертификат в качестве самоподписанного открытого ключа для шифрования HTTP-трафика по SSL. Файл должен быть в формате PEM.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ssl_cert = keys/server-cert.pem
```
<!-- end -->


### ssl_key

<!-- example conf ssl_key -->
Путь к ключу сертификата SSL. Необязательный, по умолчанию пустой.

Сервер использует этот приватный ключ для шифрования HTTP-трафика по SSL. Файл должен быть в формате PEM.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ssl_key = keys/server-key.pem
```
<!-- end -->


### subtree_docs_cache

<!-- example conf subtree_docs_cache -->
Максимальный общий размер кеша документов поддеревьев, на запрос. Необязательный, по умолчанию 0 (отключен).

Эта настройка ограничивает использование оперативной памяти общим оптимизатором поддеревьев (см. [multi-queries](../Searching/Multi-queries.md)). Максимально это количество оперативной памяти будет потрачено на кеширование записей документов для каждого запроса. Установка лимита на 0 отключает оптимизатор.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
subtree_docs_cache = 8M
```
<!-- end -->


### subtree_hits_cache

<!-- example conf subtree_hits_cache -->
Максимальный общий размер кеша попаданий поддеревьев, на запрос. Необязательный, по умолчанию 0 (отключен).

Эта настройка ограничивает использование оперативной памяти общим оптимизатором поддеревьев (см. [multi-queries](../Searching/Multi-queries.md)). Максимально это количество оперативной памяти будет потрачено на кеширование вхождений ключевых слов (попаданий) для каждого запроса. Установка лимита на 0 отключает оптимизатор.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
subtree_hits_cache = 16M
```
<!-- end -->

### threads

<!-- example threads -->
Количество рабочих потоков (или размер пула потоков) для демона Manticore. Manticore создает это количество OS потоков при запуске, и они выполняют все задачи внутри демона, такие как выполнение запросов, создание сниппетов и т. д. Некоторые операции могут быть разбиты на подзадачи и выполняться параллельно, например:

* Поиск в таблице реального времени
* Поиск в распределенной таблице, состоящей из локальных таблиц
* Вызов перколяции запроса
* и другие

По умолчанию это значение устанавливается равным количеству ядер ЦП на сервере. Manticore создает потоки при запуске и сохраняет их до остановки. Каждая подзадача может использовать один из потоков, когда это необходимо. Когда подзадача завершается, она освобождает поток, чтобы другая подзадача могла использовать его.

В случае интенсивной нагрузки ввода-вывода имеет смысл установить это значение выше количества ядер ЦП.

<!-- request Example -->
```ini
threads = 10
```

<!-- end -->

### thread_stack

<!-- example conf thread_stack -->
Максимальный размер стека для задания (корутины, один поисковый запрос может вызывать несколько заданий/корутин). Необязательный, по умолчанию 128K.

Каждое задание имеет свой собственный стек размером 128K. При выполнении запроса проверяется, сколько стека оно требует. Если стандартных 128K достаточно, оно просто обрабатывается. Если требуется больше, запланировано другое задание с увеличенным стеком, которое продолжает обработку. Максимальный размер такого расширенного стека ограничен этой настройкой.

Установка значения на разумно высоком уровне поможет обрабатывать очень глубокие запросы, не предполагая, что общее потребление ОЗУ вырастет слишком высоко. Например, установка значения на 1 ГБ не предполагает, что каждая новая задача потребует 1 ГБ ОЗУ, но если мы увидим, что ей требуется, скажем, 100 МБ стека, мы просто выделим 100 МБ для задачи. Другие задачи в это же время будут выполняться со своим значением по умолчанию 128 КБ стека. Таким же образом мы можем выполнять даже более сложные запросы, которым требуется 500 МБ. И только если мы **увидим** внутренне, что задача требует более 1 ГБ стека, мы потерпим неудачу и сообщим о слишком низком thread_stack.

Однако на практике даже запрос, которому требуется 16 МБ стека, часто слишком сложен для разбора и потребляет слишком много времени и ресурсов для обработки. Поэтому демон будет обрабатывать его, но ограничение таких запросов с помощью настройки `thread_stack` выглядит вполне разумным.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
thread_stack = 8M
```
<!-- end -->

### unlink_old

<!-- example conf unlink_old -->
Определяет, следует ли удалять `.old` копии таблиц при успешной ротации. Необязательно, по умолчанию 1 (удалить).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
unlink_old = 0
```
<!-- end -->

### watchdog

<!-- example conf watchdog -->
Наблюдатель за потоком сервера. Необязательно, по умолчанию 1 (наблюдатель включен).

Когда запрос Manticore терпит неудачу, он может отключить весь сервер. При включенной функции наблюдателя `searchd` также поддерживает отдельный легковесный процесс, который следит за основным серверным процессом и автоматически перезагружает его в случае ненормального завершения. Наблюдатель включен по умолчанию.

<!-- request Example -->

```ini
watchdog = 0 # отключить наблюдателя
```
<!-- end -->
<!-- proofread -->





































