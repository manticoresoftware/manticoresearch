# Раздел "Searchd" в конфигурации

Ниже приведены настройки, которые должны использоваться в секции `searchd` файла конфигурации Manticore Search для контроля поведения сервера. Ниже представлено резюме каждой настройки:

### access_plain_attrs

Эта настройка устанавливает значения по умолчанию для всей инстанции для [access_plain_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Это необязательная настройка, значение по умолчанию - `mmap_preread`.

Директива `access_plain_attrs` позволяет вам определить значение по умолчанию для [access_plain_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Директивы на уровне таблицы имеют более высокий приоритет и переопределят это значение по умолчанию на уровне инстанции, предоставляя более детальный контроль.

### access_blob_attrs

Эта настройка устанавливает значения по умолчанию для всей инстанции для [access_blob_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Это необязательная настройка, значение по умолчанию - `mmap_preread`.

Директива `access_blob_attrs` позволяет вам определить значение по умолчанию для [access_blob_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Директивы на уровне таблицы имеют более высокий приоритет и переопределят это значение по умолчанию на уровне инстанции, предоставляя более детальный контроль.

### access_doclists

Эта настройка устанавливает значения по умолчанию для всей инстанции для [access_doclists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Это необязательная настройка, значение по умолчанию - `file`.

Директива `access_doclists` позволяет вам определить значение по умолчанию для [access_doclists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Директивы на уровне таблицы имеют более высокий приоритет и переопределят это значение по умолчанию на уровне инстанции, предоставляя более детальный контроль.

### access_hitlists

Эта настройка устанавливает значения по умолчанию для всей инстанции для [access_hitlists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Это необязательная настройка, значение по умолчанию - `file`.

Директива `access_hitlists` позволяет вам определить значение по умолчанию для [access_hitlists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Директивы на уровне таблицы имеют более высокий приоритет и переопределят это значение по умолчанию на уровне инстанции, предоставляя более детальный контроль.

### access_dict

Эта настройка устанавливает значения по умолчанию для всей инстанции для [access_dict](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Это необязательная настройка, значение по умолчанию - `mmap_preread`.

Директива `access_dict` позволяет вам определить значение по умолчанию для [access_dict](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Директивы на уровне таблицы имеют более высокий приоритет и переопределят это значение по умолчанию на уровне инстанции, предоставляя более детальный контроль.

### agent_connect_timeout

Эта настройка устанавливает значения по умолчанию для параметра [agent_connect_timeout](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_connect_timeout).


### agent_query_timeout

Эта настройка устанавливает значения по умолчанию для параметра [agent_query_timeout](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_query_timeout). Его можно переопределить для каждого запроса, используя условие `OPTION agent_query_timeout=XXX`.


### agent_retry_count

Эта настройка является целым числом, которое указывает, сколько раз Manticore попытается подключиться и выполнить запрос к удалённым агентам через распределённую таблицу, прежде чем сообщить об фатальной ошибке запроса. Значение по умолчанию - 0 (т.е. без повторов). Вы также можете установить это значение для каждого запроса, используя условие `OPTION retry_count=XXX`. Если предоставлена опция для запроса, она переопределит значение, указанное в конфигурации.

Обратите внимание, что если вы используете [агентские зеркала](../Creating_a_cluster/Remote_nodes/Mirroring.md#Agent-mirrors) в определении вашей распределённой таблицы, сервер будет выбирать другое зеркало для каждой попытки подключения в соответствии с выбранной [ha_strategy](../Creating_a_cluster/Remote_nodes/Load_balancing.md#ha_strategy). В этом случае `agent_retry_count` будет суммироваться для всех зеркал в наборе.

Например, если у вас есть 10 зеркал и вы установите `agent_retry_count=5`, сервер попытается повторить до 50 раз, предполагая в среднем 5 попыток для каждого из 10 зеркал (при опции `ha_strategy = roundrobin`, это будет так).

Тем не менее, значение, указанное в опции `retry_count` для [агента](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent), служит абсолютным лимитом. Другими словами, опция `[retry_count=2]` в определении агента всегда означает максимум 2 попытки, независимо от того, указали ли вы 1 или 10 зеркал для агента.

### agent_retry_delay

Эта настройка является целым числом в миллисекундах (или [special_suffixes](../Server_settings/Special_suffixes.md)), которое указывает задержку перед тем, как Manticore повторно попытается выполнить запрос к удалённому агенту в случае сбоя. Это значение имеет значение только в том случае, если указано ненулевое значение [agent_retry_count](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md) или ненулевое значение `retry_count` для запроса. Значение по умолчанию - 500. Вы также можете установить это значение для каждого запроса, используя условие `OPTION retry_delay=XXX`. Если предоставлена опция для запроса, она переопределит значение, указанное в конфигурации.


### attr_flush_period

<!-- example conf attr_flush_period -->
Когда вы используете [Обновление](../Data_creation_and_modification/Updating_documents/UPDATE.md) для изменения атрибутов документов в реальном времени, изменения сначала записываются в копию атрибутов в памяти. Эти обновления происходят в файле, сопоставленном с памятью, что означает, что операционная система решает, когда записывать изменения на диск. При нормальном завершении работы `searchd` (инициированном сигналом `SIGTERM`) все изменения принудительно записываются на диск.

Вы также можете указать `searchd`, чтобы периодически записывать эти изменения обратно на диск, чтобы предотвратить потерю данных. Интервал между этими сбросами определяется `attr_flush_period`, указанным в секундах (или [специальными_суффиксами](../Server_settings/Special_suffixes.md)).

По умолчанию значение равно 0, что отключает периодический сброс. Тем не менее, сброс все равно произойдет при нормальном завершении работы.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
attr_flush_period = 900 # persist updates to disk every 15 minutes
```
<!-- end -->

### auto_optimize

<!-- example conf auto_optimize -->
Эта настройка контролирует автоматический процесс [OPTIMIZE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE) для сжатия таблиц.

По умолчанию сжатие таблиц происходит автоматически. Вы можете изменить это поведение с помощью настройки `auto_optimize`:
* 0 для отключения автоматического сжатия таблиц (вы все равно можете вручную вызвать `OPTIMIZE`)
* 1 для явного включения
* для включения его с умножением порога оптимизации на 2.

По умолчанию OPTIMIZE выполняется до тех пор, пока количество дисковых чанков не станет меньше или равно количеству логических ядер процессора, умноженному на 2.

Тем не менее, если у таблицы есть атрибуты с KNN индексами, этот порог отличается. В этом случае он устанавливается на количество физических ядер процессора, деленное на 2, чтобы улучшить производительность поиска KNN.

Обратите внимание, что переключение `auto_optimize` включено или выключено не помешает вам вручную запускать [OPTIMIZE TABLE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE).

<!-- intro -->
##### Пример:

<!-- request Disable -->
```ini
auto_optimize = 0 # disable automatic OPTIMIZE
```

<!-- request Throttle -->
```ini
auto_optimize = 2 # OPTIMIZE starts at 16 chunks (on 4 cpu cores server)
```

<!-- end -->

### auto_schema

<!-- example conf auto_schema -->
Manticore поддерживает автоматическое создание таблиц, которые еще не существуют, но указаны в операторах INSERT. Эта функция включена по умолчанию. Чтобы отключить ее, установите `auto_schema = 0` явно в вашей конфигурации. Чтобы снова включить ее, установите `auto_schema = 1` или удалите настройку `auto_schema` из конфигурации.

Имейте в виду, что HTTP-эндпоинт `/bulk` не поддерживает автоматическое создание таблиц.

> ПРИМЕЧАНИЕ: Функция [авто схемы](../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real_time_table.md#Auto-schema) требует [Manticore Buddy](../Installation/Manticore_Buddy.md). Если это не работает, убедитесь, что Buddy установлен.

<!-- request Disable -->
```ini
auto_schema = 0 # disable automatic table creation
```

<!-- request Enable -->
```ini
auto_schema = 1 # enable automatic table creation
```

<!-- end -->

### binlog_flush

<!-- example conf binlog_flush -->
Эта настройка контролирует режим сброса/синхронизации бинарного журнала транзакций. Это необязательная настройка, с значением по умолчанию 2 (сбрасывать каждую транзакцию, синхронизировать каждую секунду).

Директива определяет, как часто бинарный журнал будет сбрасываться в операционную систему и синхронизироваться с диском. Поддерживаются три режима:

* 0, сбрасывать и синхронизировать каждую секунду. Это обеспечивает наилучшее качество производительности, но при сбое сервера или сбое ОС/аппаратуры может быть потеряно до 1 секунды подтвержденных транзакций.
* 1, сбрасывать и синхронизировать каждую транзакцию. Этот режим обеспечивает наихудшую производительность, но гарантирует, что данные каждой подтвержденной транзакции будут сохранены.
* 2, сбрасывать каждую транзакцию, синхронизировать каждую секунду. Этот режим обеспечивает хорошую производительность и гарантирует, что каждая подтвержденная транзакция будет сохранена в случае сбоя сервера. Тем не менее, в случае сбоя ОС/аппаратуры может быть потеряно до 1 секунды подтвержденных транзакций.

Для тех, кто знаком с MySQL и InnoDB, эта директива аналогична `innodb_flush_log_at_trx_commit`. В большинстве случаев режим по умолчанию 2 обеспечивает хороший баланс скорости и безопасности, с полной защитой данных RT таблицы от сбоев сервера и некоторой защитой от аппаратных сбоев.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_flush = 1 # ultimate safety, low speed
```
<!-- end -->

### binlog_common

<!-- example conf binlog_common -->
Эта настройка контролирует, как управляются бинарные файлы журнала. Это необязательная настройка, с значением по умолчанию 0 (отдельный файл для каждой таблицы).

Вы можете выбрать один из двух способов управления бинарными файлами журнала:

* Отдельный файл для каждой таблицы (по умолчанию, `0`): Каждая таблица сохраняет свои изменения в собственном журнальном файле. Эта настройка хороша, если у вас много таблиц, которые обновляются в разное время. Это позволяет таблицам обновляться без ожидания других. Также, если возникает проблема с журнальным файлом одной таблицы, это не влияет на другие.
* Один файл для всех таблиц (`1`): Все таблицы используют один и тот же бинарный файл журнала. Этот метод упрощает управление файлами, так как их меньше. Однако это может удерживать файлы дольше, чем необходимо, если одной таблице все еще нужно сохранить свои обновления. Эта настройка также может замедлить процесс, если многим таблицам нужно обновиться одновременно, потому что все изменения должны ожидать записи в один файл.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_common = 1 # use a single binary log file for all tables
```
<!-- end -->

### binlog_max_log_size

<!-- example conf binlog_max_log_size -->
Эта настройка контролирует максимальный размер бинарного файла журнала. Это необязательная настройка, с значением по умолчанию 256 МБ.

Новый файл бинарного журнала будет принудительно открыт, как только текущий файл бинарного журнала достигнет этого предела. Это приводит к более тонкой градации журналов и может привести к более эффективному использованию диска бинарного журнала в определенных пограничных нагрузках. Значение 0 указывает на то, что файл бинарного журнала не должен быть снова открыт на основе размера.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_max_log_size = 16M
```
<!-- end -->


### binlog_path

<!-- example conf binlog_path -->
Эта настройка определяет путь для файлов бинарного журнала (также известного как журнал транзакций). Это необязательная настройка, с значением по умолчанию - настроенная на этапе сборки директория данных (например, `/var/lib/manticore/data/binlog.*` в Linux).

Двоичные журналы используются для восстановления данных таблицы RT после сбоя и для обновлений атрибутов простых дисковых индексов, которые в противном случае хранились бы только в оперативной памяти до сброса. Когда ведение журнала включено, каждая транзакция, зафиксированная в таблице RT, записывается в файл журнала. Журналы затем автоматически воспроизводятся при запуске после некорректного завершения работы, восстанавливая зафиксированные изменения.

Директива `binlog_path` указывает расположение файлов двоичного журнала. Она должна содержать только путь; `searchd` создаст и удалит несколько файлов `binlog.*` в директории по мере необходимости (включая данные двоичного журнала, метаданные и файлы блокировки и т.д.).

Пустое значение отключает ведение двоичного журнала, что улучшает производительность, но ставит данные таблицы RT под угрозу.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_path = # disable logging
binlog_path = /var/lib/manticore/data # /var/lib/manticore/data/binlog.001 etc will be created
```
<!-- end -->


### buddy_path

<!-- example conf buddy_path -->
Эта настройка определяет путь к двоичному файлу Manticore Buddy. Она является необязательной, с значением по умолчанию, конфигурируемым на этапе сборки, которое варьируется в зависимости от операционной системы. Обычно, вам не нужно изменять эту настройку. Тем не менее, это может быть полезно, если вы хотите запустить Manticore Buddy в режиме отладки, внести изменения в Manticore Buddy или реализовать новый плагин. В последнем случае вы можете `git clone` Buddy с https://github.com/manticoresoftware/manticoresearch-buddy, добавить новый плагин в директорию `./plugins/` и запустить `composer install --prefer-source` для упрощения разработки после того, как вы измените директорию на исходный код Buddy.

Чтобы гарантировать, что вы сможете запустить `composer`, на вашем компьютере должна быть установлена PHP 8.2 или выше с следующими расширениями:

```
--enable-dom
--with-libxml
--enable-tokenizer
--enable-xml
--enable-xmlwriter
--enable-xmlreader
--enable-simplexml
--enable-phar
--enable-bcmath
--with-gmp
--enable-debug
--with-mysqli
--enable-mysqlnd
```

Вы также можете выбрать специальную версию `manticore-executor-dev` для Linux amd64, доступную в релизах, например: https://github.com/manticoresoftware/executor/releases/tag/v1.0.13

Если вы выберете этот путь, не забудьте связать версию dev manticore executor с `/usr/bin/php`.

Чтобы отключить Manticore Buddy, установите значение пустым, как показано в примере.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
buddy_path = manticore-executor -n /usr/share/manticore/modules/manticore-buddy/src/main.php --debug # use the default Manticore Buddy in Linux, but run it in debug mode
buddy_path = manticore-executor -n /opt/homebrew/share/manticore/modules/manticore-buddy/bin/manticore-buddy/src/main.php --debug # use the default Manticore Buddy in MacOS arm64, but run it in debug mode
buddy_path = manticore-executor -n /Users/username/manticoresearch-buddy/src/main.php --debug # use Manticore Buddy from a non-default location
buddy_path = # disables Manticore Buddy
buddy_path = manticore-executor -n /Users/username/manticoresearch-buddy/src/main.php --debugv --skip=manticoresoftware/buddy-plugin-replace # debugv - enables more detailed logging, --skip - skips plugins
```
<!-- end -->

### client_timeout

<!-- example conf client_timeout -->
Эта настройка определяет максимальное время ожидания между запросами (в секундах или [special_suffixes](../Server_settings/Special_suffixes.md)) при использовании постоянных соединений. Она является необязательной, со значением по умолчанию равным пяти минутам.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
client_timeout = 1h
```
<!-- end -->


### collation_libc_locale

<!-- example conf collation_libc_locale -->
Локаль libc сервера. Необязательная, по умолчанию C.

Указывает локаль libc, влияя на колляции на основе libc. Смотрите раздел [collations](../Searching/Collations.md) для получения деталей.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
collation_libc_locale = fr_FR
```
<!-- end -->


### collation_server

<!-- example conf collation_server -->
Колляция сервера по умолчанию. Необязательная, по умолчанию libc_ci.

Указывает колляцию по умолчанию, используемую для входящих запросов. Колляция может быть переопределена на уровне каждого запроса. Смотрите раздел [collations](../Searching/Collations.md) для списка доступных колляций и других деталей.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
collation_server = utf8_ci
```
<!-- end -->


### data_dir

<!-- example conf data_dir -->
При указании эта настройка включает [режим реального времени](../Creating_a_table/Local_tables.md#Online-schema-management-%28RT-mode%29), который является императивным способом управления схемой данных. Значение должно быть путем к директории, в которой вы хотите хранить все ваши таблицы, двоичные журналы и все остальное, необходимое для правильного функционирования Manticore Search в этом режиме.
Индексация [простых таблиц](../Creating_a_table/Local_tables/Plain_table.md) не допускается, когда указан `data_dir`. Узнайте больше о различиях между режимом RT и простым режимом в [этом разделе](../Read_this_first.md#Real-time-table-vs-plain-table).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
data_dir = /var/lib/manticore
```
<!-- end -->

### diskchunk_flush_search_timeout

<!-- example conf diskchunk_flush_search_timeout -->
Тайм-аут для предотвращения автоматического сброса RAM-чанка, если в таблице нет поисковых запросов. Необязательный, по умолчанию 30 секунд.

Время для проверки наличия поисковых запросов перед тем, как определить, следует ли автоматически сбрасывать.
Автоматический сброс произойдет только в том случае, если в таблице был хотя бы один поиск в течение последних `diskchunk_flush_search_timeout` секунд. Работает в связке с [diskchunk_flush_write_timeout](../../Server_settings/Searchd.md#diskchunk_flush_write_timeout). Соответствующая [перетабличная настройка](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#diskchunk_flush_search_timeout) имеет более высокий приоритет и переопределит этот экземпляр по умолчанию, обеспечивая более точный контроль.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
diskchunk_flush_search_timeout = 120s
```
<!-- end -->

### diskchunk_flush_write_timeout

<!-- example conf diskchunk_flush_write_timeout -->
Время в секундах, которое нужно ждать без записи перед автоматическим сбросом RAM-чанка на диск. Необязательный, по умолчанию 1 секунда.

Если запись не происходит в RAM-чанке в течение `diskchunk_flush_write_timeout` секунд, чанка будет сброшена на диск. Работает в связке с [diskchunk_flush_search_timeout](../../Server_settings/Searchd.md#diskchunk_flush_search_timeout). Для отключения автоматического сброса установите `diskchunk_flush_write_timeout = -1` явно в вашей конфигурации. Соответствующая [перетабличная настройка](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#diskchunk_flush_write_timeout) имеет более высокий приоритет и переопределит этот экземпляр по умолчанию, обеспечивая более точный контроль.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
diskchunk_flush_write_timeout = 60s
```
<!-- end -->

### docstore_cache_size

<!-- example conf docstore_cache_size -->
Эта настройка определяет максимальный размер блоков документов из хранилища документов, которые хранятся в памяти. Она является необязательной, со значением по умолчанию 16m (16 мегабайт).

Когда используется `stored_fields`, блоки документов считываются с диска и распаковываются. Поскольку каждый блок обычно содержит несколько документов, он может быть повторно использован при обработке следующего документа. Для этой цели блок хранится в кэше, который охватывает весь сервер. Кэш хранит распакованные блоки.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
docstore_cache_size = 8m
```
<!-- end -->

### engine

<!-- example conf engine -->
Используемый по умолчанию механизм хранения атрибутов при создании таблиц в режиме RT. Может быть `rowwise` (по умолчанию) или `columnar`.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
engine = columnar
```
<!-- end -->


### expansion_limit

<!-- example conf expansion_limit -->
Эта настройка определяет максимальное количество расширенных ключевых слов для одного шаблона. Она является необязательной, с значением по умолчанию 0 (без ограничений).

При выполнении поисков подстрок в таблицах, построенных с включенной опцией `dict = keywords`, один шаблон может потенциально привести к тысячам или даже миллионам совпадающих ключевых слов (подумайте о совпадении `a*` со всем Оксфордским словарем). Эта директива позволяет ограничить влияние таких расширений. Установка `expansion_limit = N` ограничивает расширения не более чем N из наиболее частых совпадающих ключевых слов (для каждого шаблона в запросе).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_limit = 16
```
<!-- end -->

### expansion_merge_threshold_docs

<!-- example conf expansion_merge_threshold_docs -->
Эта настройка определяет максимальное количество документов в расширенном ключевом слове, которое позволяет объединять все такие ключевые слова вместе. Она является необязательной, с значением по умолчанию 32.

При выполнении поисков подстрок в таблицах, построенных с включенной опцией `dict = keywords`, один шаблон может потенциально привести к тысячам или даже миллионам совпадающих ключевых слов. Эта директива позволяет увеличить лимит того, сколько ключевых слов будет объединяться вместе, чтобы ускорить сопоставление, но использует больше памяти в поиске.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_merge_threshold_docs = 1024
```
<!-- end -->

### expansion_merge_threshold_hits

<!-- example conf expansion_merge_threshold_hits -->
Эта настройка определяет максимальное количество совпадений в расширенном ключевом слове, которое позволяет объединять все такие ключевые слова вместе. Она является необязательной, с значением по умолчанию 256.

При выполнении поисков подстрок в таблицах, построенных с включенной опцией `dict = keywords`, один шаблон может потенциально привести к тысячам или даже миллионам совпадающих ключевых слов. Эта директива позволяет увеличить лимит того, сколько ключевых слов будет объединяться вместе, чтобы ускорить сопоставление, но использует больше памяти в поиске.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_merge_threshold_hits = 512
```
<!-- end -->

### grouping_in_utc

Эта настройка определяет, будет ли временная группировка в API и SQL рассчитываться в местном часовом поясе или в UTC. Она является необязательной, со значением по умолчанию 0 (что означает 'местной часовой пояс').

По умолчанию все выражения 'группировать по времени' (такие как группировка по дням, неделям, месяцам и годам в API, также группировка по дням, месяцам, годам, годмесяцам, годмесяцдням в SQL) выполняются с использованием местного времени. Например, если у вас есть документы с атрибутами времени `13:00 utc` и `15:00 utc`, в случае группировки они оба будут относиться к группам объектов в соответствии с настройкой вашего местного часового пояса. Если вы живете в `utc`, это будет один день, но если вы живете в `utc+10`, то эти документы будут сгруппированы в разные группы объектов `группировать по дням` (поскольку 13:00 utc в часовом поясе UTC+10 — это 23:00 местного времени, а 15:00 — это 01:00 следующего дня). Иногда такое поведение неприемлемо, и желательно сделать временную группировку независимой от часового пояса. Вы можете запустить сервер с установленной глобальной переменной среды TZ, но это повлияет не только на группировку, но и на отметки времени в журналах, что также может быть нежелательно. Включение этой опции ('включить' как в конфигурации, так и с помощью [SET global](../Server_settings/Setting_variables_online.md#SET) в SQL) приведет к тому, что все выражения временной группировки будут рассчитаны в UTC, оставляя остальные функции, зависящие от времени (например, ведение журналов сервера), в местном часовом поясе.


### timezone

Эта настройка определяет часовой пояс, который будет использоваться для связанных с датой/временем функций. По умолчанию используется местный часовой пояс, но вы можете указать другой часовой пояс в формате IANA (например, `Europe/Amsterdam`).

Обратите внимание, что эта настройка не влияет на ведение журналов, которое всегда работает в местном часовом поясе.

Кроме того, обратите внимание, что если используется `grouping_in_utc`, функция 'группировать по времени' все равно будет использовать UTC, в то время как другие функции, связанные с датой/временем, будут использовать указанный часовой пояс. В целом, не рекомендуется смешивать `grouping_in_utc` и `timezone`.

Вы можете настроить эту опцию либо в конфигурации, либо с помощью [SET global](../Server_settings/Setting_variables_online.md#SET) в SQL.


### ha_period_karma

<!-- example conf ha_period_karma -->
Эта настройка определяет размер окна статистики зеркал агента, в секундах (или [special_suffixes](../Server_settings/Special_suffixes.md)). Она является необязательной, со значением по умолчанию 60 секунд.

Для распределенной таблицы с зеркалами агентов (см. подробнее в [agent](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md)) мастер отслеживает несколько разных счетчиков для каждого зеркала. Эти счетчики затем используются для переключения на резервный вариант и балансировки (мастер выбирает лучшее зеркало для использования, основываясь на счетчиках). Счетчики накапливаются блоками по `ha_period_karma` секунд.

После начала нового блока мастер все еще может использовать накопленные значения из предыдущего блока, пока новый не заполнен наполовину. В результате любая предыдущая история перестает накладывать влияние на выбор зеркала не более чем 1.5 раза за время ha_period_karma.

Несмотря на то, что в основном используются два блока для выбора зеркала, до 15 последних блоков сохраняются для целей инструментирования. Эти блоки можно просмотреть с помощью команды [SHOW AGENT STATUS](../Node_info_and_management/Node_status.md#SHOW-AGENT-STATUS).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ha_period_karma = 2m
```
<!-- end -->


### ha_ping_interval

<!-- example conf ha_ping_interval -->
Этот параметр настраивает интервал между пингами зеркал агента, в миллисекундах (или [special_suffixes](../Server_settings/Special_suffixes.md)). Он является необязательным, со значением по умолчанию 1000 миллисекунд.

Для распределенной таблицы с зеркалами агентов (подробнее см. в [агенте](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md)), мастер отправляет всем зеркалам команду пинга в период простоя. Это необходимо для отслеживания текущего состояния агента (работает или нет, время кругового прохода по сети и т. д.). Интервал между такими пингами определяется этим директивом. Чтобы отключить пинги, установите ha_ping_interval в 0.


<!-- intro -->
##### Пример:

<!-- request Пример -->

```ini
ha_ping_interval = 3s
```
<!-- end -->


### hostname_lookup

Опция `hostname_lookup` определяет стратегию обновления имен хостов. По умолчанию IP-адреса имен агентов кэшируются при запуске сервера для избежания чрезмерного доступа к DNS. Однако в некоторых случаях IP может изменяться динамически (например, облачный хостинг), и может быть желательным не кэшировать IP-адреса. Установка этой опции в `request` отключает кэширование и выполняет запрос DNS для каждого запроса. IP-адреса также могут быть вручную обновлены с помощью команды `FLUSH HOSTNAMES`.

### jobs_queue_size

Настройка jobs_queue_size определяет, сколько "задач" может находиться в очереди одновременно. По умолчанию это неограниченно.

В большинстве случаев "задача" означает один запрос к одной локальной таблице (обычной таблице или дисковому чанку реальной таблицы). Например, если у вас есть распределенная таблица, состоящая из 2 локальных таблиц или реальной таблицы с 2 дисковыми чанками, поисковый запрос к любой из них в основном создаст 2 задачи в очереди. Затем пул потоков (размер которого определяется по [threads](../Server_settings/Searchd.md#threads)) будет их обрабатывать. Однако в некоторых случаях, если запрос слишком сложный, может быть создано больше задач. Изменение этой настройки рекомендуется, когда [max_connections](../Server_settings/Searchd.md#max_connections) и [threads](../Server_settings/Searchd.md#threads) недостаточны для нахождения баланса между желаемой производительностью.

### join_batch_size

Объединение таблиц работает путем накопления пакета совпадений, которые являются результатами запроса, выполненного над левой таблицей. Этот пакет затем обрабатывается как один запрос к правой таблице.

Эта опция позволяет вам настроить размер пакета. Значение по умолчанию равно `1000`, а установка этой опции в `0` отключает передачу пакетами.

Больший размер пакета может улучшить производительность; однако для некоторых запросов это может привести к чрезмерному потреблению памяти.

<!-- intro -->
##### Пример:

<!-- request Пример -->

```ini
join_batch_size = 2000
```
<!-- end -->

### join_cache_size

Каждый запрос, выполненный на правой таблице, определяется конкретными условиями JOIN ON, которые определяют набор результатов, извлекаемых из правой таблицы.

Если существует лишь несколько уникальных условий JOIN ON, повторное использование результатов может быть более эффективным, чем многократное выполнение запросов к правой таблице. Чтобы включить это, наборы результатов хранятся в кэше.

Эта опция позволяет вам настроить размер этого кэша. Значение по умолчанию равно `20 MB`, а установка этой опции в 0 отключает кэширование.

Учтите, что каждый поток поддерживает собственный кэш, поэтому следует учитывать количество потоков, выполняющих запросы, при оценке общего потребления памяти.

<!-- intro -->
##### Пример:

<!-- request Пример -->

```ini
join_cache_size = 10M
```
<!-- end -->

### listen_backlog

<!-- пример конфигурации listen_backlog -->
Параметр listen_backlog определяет длину очереди прослушивания TCP для входящих соединений. Это особенно актуально для сборок Windows, которые обрабатывают запросы по одному. Когда очередь соединений достигает своего предела, новые входящие соединения будут отклонены.
Для не-Windows сборок значение по умолчанию должно работать нормально, и обычно нет необходимости настраивать этот параметр.


<!-- intro -->
##### Пример:

<!-- request Пример -->

```ini
listen_backlog = 20
```
<!-- end -->

### kibana_version_string

<!-- пример конфигурации kibana_version_string -->
Строка версии сервера для возврата в Kibana или OpenSearch Dashboards. Необязательно — по умолчанию установлено `7.6.0`.

Некоторые версии Kibana и OpenSearch Dashboards ожидают, что сервер будет сообщать конкретный номер версии и могут вести себя иначе в зависимости от этого. Чтобы обойти такие проблемы, вы можете использовать эту настройку, которая заставляет Manticore сообщать пользовательскую версию в Kibana или OpenSearch Dashboards.

<!-- intro -->
##### Пример:

<!-- request Пример -->

```ini
kibana_version_string = 1.2.3
```
<!-- end -->

### listen

<!-- пример конфигурации listen -->
Этот параметр позволяет вам указать IP-адрес и порт или путь сокета Unix, на котором Manticore будет принимать соединения.

Общий синтаксис для `listen`:

```ini
listen = ( address ":" port | port | path | address ":" port start - port end ) [ ":" protocol [ "_vip" ] [ "_readonly" ] ]
```

Вы можете указать:
* либо IP-адрес (или имя хоста) и номер порта
* или только номер порта
* или путь сокета Unix (не поддерживается в Windows)
* или диапазон IP-адресов и портов

Если вы указываете номер порта, но не адрес, `searchd` будет прослушивать все сетевые интерфейсы. Путь Unix определяется начальным слешем. Диапазон портов можно установить только для протокола репликации.

Вы также можете указать обработчик протокола (слушатель), который будет использоваться для соединений на этом сокете. Слушатели следующие:

* **Не указано** - Manticore будет принимать соединения на этом порту от:
  - других агентов Manticore (т. е. удаленной распределенной таблицы)
  - клиентов через HTTP и HTTPS
  - [Manticore Buddy](https://manticoresearch.com/blog/manticoresearch-buddy-intro/). **Убедитесь, что у вас есть слушатель такого рода (или HTTP слушатель, как указано ниже), чтобы избежать ограничений в функциональности Manticore.**
* `mysql` Протокол MySQL для соединений от клиентов MySQL. Примечание:
  - Поддерживается также сжатый протокол.
  - Если [SSL](../Security/SSL.md#SSL) включен, вы можете установить зашифрованное соединение.
* `replication` - протокол репликации, используемый для связи узлов. Более подробную информацию можно найти в разделе [репликация](../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md). Вы можете указать несколько слушателей репликации, но все они должны слушать на одном и том же IP; только порты могут быть разными. Когда вы определяете слушатель репликации с диапазоном портов (например, `listen = 192.168.0.1:9320-9328:replication`), Manticore не начинает немедленно слушать на этих портах. Вместо этого он возьмет случайные свободные порты из указанного диапазона только когда вы начнете использовать репликацию. Для правильной работы репликации требуется как минимум 2 порта в диапазоне.
* `http` - то же самое, что и **Не указано**. Manticore будет принимать подключения на этом порту от удаленных агентов и клиентов через HTTP и HTTPS.
* `https` - протокол HTTPS. Manticore будет принимать **только** HTTPS подключения на этом порту. Более подробную информацию можно найти в разделе [SSL](../Security/SSL.md).
* `sphinx` - устаревший двоичный протокол. Используется для обслуживания подключений от удаленных [SphinxSE](../Extensions/SphinxSE.md) клиентов. Некоторые реализации API клиентов Sphinx (примером является Java) требуют явного указания слушателя.

Добавление суффикса `_vip` к протоколам клиентов (то есть, ко всем, кроме `replication`, например `mysql_vip` или `http_vip` или просто `_vip`) заставляет создавать выделенный поток для подключения, чтобы обойти различные ограничения. Это полезно для обслуживания узлов в случае сильной перегрузки, когда сервер либо зависнет, либо не позволит вам подключиться через обычный порт.

Суффикс `_readonly` устанавливает [режим только для чтения](../Security/Read_only.md) для слушателя и ограничивает его только для приема читающих запросов.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
listen = localhost
listen = localhost:5000 # listen for remote agents (binary API) and http/https requests on port 5000 at localhost
listen = 192.168.0.1:5000 # listen for remote agents (binary API) and http/https requests on port 5000 at 192.168.0.1
listen = /var/run/manticore/manticore.s # listen for binary API requests on unix socket
listen = /var/run/manticore/manticore.s:mysql # listen for mysql requests on unix socket
listen = 9312 # listen for remote agents (binary API) and http/https requests on port 9312 on any interface
listen = localhost:9306:mysql # listen for mysql requests on port 9306 at localhost
listen = localhost:9307:mysql_readonly # listen for mysql requests on port 9307 at localhost and accept only read queries
listen = 127.0.0.1:9308:http # listen for http requests as well as connections from remote agents (and binary API) on port 9308 at localhost
listen = 192.168.0.1:9320-9328:replication # listen for replication connections on ports 9320-9328 at 192.168.0.1
listen = 127.0.0.1:9443:https # listen for https requests (not http) on port 9443 at 127.0.0.1
listen = 127.0.0.1:9312:sphinx # listen for legacy Sphinx requests (e.g. from SphinxSE) on port 9312 at 127.0.0.1
```
<!-- end -->

Может быть несколько директив `listen`. `searchd` будет слушать клиентские подключения на всех указанных портах и сокетах. Конфигурация по умолчанию, предоставленная в пакетах Manticore, определяет прослушивание на портах:
* `9308` и `9312` для подключений от удаленных агентов и клиентов, не основанных на MySQL
* и на порту `9306` для MySQL подключений.

Если вы вообще не укажете никаких директив `listen` в конфигурации, Manticore будет ждать подключений на:
* `127.0.0.1:9306` для MySQL клиентов
* `127.0.0.1:9312` для HTTP/HTTPS и подключений от других узлов Manticore и клиентов, основанных на двоичном API Manticore.

#### Прослушивание на привилегированных портах

По умолчанию Linux не позволит вам заставить Manticore слушать на порту ниже 1024 (например, `listen = 127.0.0.1:80:http` или `listen = 127.0.0.1:443:https`), если вы не запустите searchd от имени root. Если вы все же хотите иметь возможность запускать Manticore, чтобы он слушал на портах < 1024 от имени пользователя, не имеющего прав root, подумайте о том, чтобы сделать одно из следующих (любое из них должно сработать):
* Выполните команду `setcap CAP_NET_BIND_SERVICE=+eip /usr/bin/searchd`
* Добавьте `AmbientCapabilities=CAP_NET_BIND_SERVICE` в системный юнит Manticore и перезагрузите демон (`systemctl daemon-reload`).

#### Технические детали о протоколе Sphinx API и TFO
<details>
Устаревший протокол Sphinx имеет 2 фазы: обмен рукопожатиями и поток данных. Рукопожатие состоит из пакета размером 4 байта от клиента и пакета размером 4 байта от демона с единственной целью - клиент определяет, что удаленный узел является настоящим демоном Sphinx, а демон определяет, что удаленный узел является настоящим клиентом Sphinx. Основной поток данных довольно прост: давайте обе стороны объявят свои рукопожатия, а противоположная сторона проверит их. Этот обмен короткими пакетами подразумевает использование специального флага `TCP_NODELAY`, который отключает алгоритм TCP Nagle и объявляет, что TCP соединение будет выполняться как диалог маленьких пакетов.
Однако не строго определено, кто говорит первым в этойNegotiation. Исторически все клиенты, которые используют двоичный API, говорят первыми: отправляют рукопожатие, затем читают 4 байта от демона, затем отправляют запрос и читают ответ от демона.
Когда мы улучшили совместимость протокола Sphinx, мы учитывали эти вещи:

1. Обычно связь между мастером и агентом устанавливается от известного клиента к известному хосту на известном порту. Поэтому довольно невозможно, что конечная точка предоставит неверное рукопожатие. Таким образом, мы можем неявно предположить, что обе стороны действительны и действительно общаются с протоколом Sphinx.
2. Учитывая это предположение, мы можем "склеить" рукопожатие с реальным запросом и отправить его в одном пакете. Если бэкендом является устаревший демон Sphinx, он просто прочитает этот склеенный пакет как 4 байта рукопожатия, затем тело запроса. Поскольку оба они пришли в одном пакете, сокет бэкенда имеет -1 RTT, а буфер фронтенда все еще работает, несмотря на этот факт обычным способом.
3. Продолжая предположение: поскольку пакет 'query' довольно маленький, а рукопожатие еще меньше, давайте отправим оба в начальном 'SYN' TCP пакете с использованием современной техники TFO (tcp-fast-open). То есть, мы подключаемся к удаленному узлу с пакетом склеенного рукопожатия + тела запроса. Демон принимает соединение и сразу же имеет и рукопожатие, и тело в сокетном буфере, так как они пришли в самом первом TCP 'SYN' пакете. Это устраняет еще один RTT.
4. Наконец, научите демон принимать это улучшение. На самом деле, с точки зрения приложения это подразумевает НЕ использовать `TCP_NODELAY`. А с точки зрения системы это подразумевает необходимость убедиться, что на стороне демона активация TFO включена, а на стороне клиента также активирована отправка TFO. По умолчанию в современных системах клиент TFO уже активирован по умолчанию, поэтому вам только нужно настроить сервер TFO, чтобы все работало.

Все эти улучшения, без фактического изменения самого протокола, позволили нам устранить 1.5 RTT протокола TCP из соединения. Что, если запрос и ответ могут быть размещены в одном TCP пакете, уменьшает всю сессию двоичного API с 3.5 RTT до 2 RTT - что делает сетевую переговорку примерно в 2 раза быстрее.

Так что все наши улучшения основаны на первоначально неопределенном заявлении: «кто говорит первым». Если клиент говорит первым, мы можем применить все эти оптимизации и эффективно обработать соединение + рукопожатие + запрос в одном пакете TFO. Более того, мы можем взглянуть на начало полученного пакета и определить реальный протокол. Именно поэтому вы можете подключиться к одному и тому же порту через API/http/https. Если демон должен говорить первым, все эти оптимизации невозможны, и многопротокол также невозможен. Именно поэтому у нас есть выделенный порт для MySQL, и мы не объединили его со всеми другими протоколами в один и тот же порт. Вдруг среди всех клиентов один был написан с тем предположением, что демон должен сначала отправить рукопожатие. То есть — нет возможности для всех описанных улучшений. Это плагин SphinxSE для mysql/mariadb. Поэтому специально для этого единственного клиента мы посвятили определение протокола `sphinx`, чтобы работать наиболее привычным способом. А именно: обе стороны активируют `TCP_NODELAY` и обмениваются небольшими пакетами. Демон отправляет свое рукопожатие при подключении, затем клиент отправляет свое, а потом все работает обычным образом. Это не очень оптимально, но просто работает. Если вы используете SphinxSE для подключения к Manticore — вам нужно выделить слушатель с явно указанным протоколом `sphinx`. Для других клиентов — избегайте использования этого слушателя, так как он медленнее. Если вы используете другие устаревшие клиенты Sphinx API — сначала проверьте, способны ли они работать с невыделенным многопротокольным портом. Для связи мастер-агент использование невыделенного (многопротокольного) порта и включение TFO для клиента и сервера хорошо сработает и определенно ускорит работу сетевой подсистемы, особенно если у вас очень легкие и быстрые запросы.
</details>

### listen_tfo

Эта настройка позволяет устанавливать флаг TCP_FASTOPEN для всех слушателей. По умолчанию им управляет система, но его можно явно отключить, установив значение '0'.

Для общего понимания расширения TCP Fast Open, пожалуйста, обратитесь к [Wikipedia](https://en.wikipedia.org/wiki/TCP_Fast_Open). Короче говоря, это позволяет устранить одну TCP круговорот при установлении соединения.

На практике использование TFO во многих ситуациях может оптимизировать эффективность сети клиент-агент, так как если [постоянные агенты](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md) используются, но без поддержания активных соединений и также без ограничения на максимальное количество соединений.

На современных операционных системах поддержка TFO обычно включена на уровне системы, но это просто 'возможность', а не правило. Linux (как самый прогрессивный) поддерживает это с 2011 года, на ядрах начиная с 3.7 (для серверной стороны). Windows поддерживает это с некоторых сборок Windows 10. Другие операционные системы (FreeBSD, MacOS) также участвуют в игре.

Для проверки серверов Linux переменная `/proc/sys/net/ipv4/tcp_fastopen` проверяется и ведет себя в соответствии с ней. Бит 0 управляет стороной клиента, бит 1 управляет слушателями. По умолчанию система имеет этот параметр установленным на 1, т.е. клиенты включены, слушатели отключены.

### log

<!-- example conf log -->
Настройка журнала задает имя файла журнала, в который будут записываться все события времени выполнения `searchd`. Если не указано, по умолчанию имя — 'searchd.log'.

В качестве альтернативы вы можете использовать 'syslog' в качестве имени файла. В этом случае события будут отправляться демону syslog. Чтобы использовать опцию syslog, вам нужно настроить Manticore с опцией `-–with-syslog` во время сборки.


<!-- intro -->
##### Example:

<!-- request Example -->

```ini
log = /var/log/searchd.log
```
<!-- end -->


### max_batch_queries

<!-- example conf max_batch_queries -->
Ограничивает количество запросов в одной партии. Необязательный параметр, по умолчанию 32.

Заставляет searchd выполнять проверку корректности количества запросов, поданных в одной партии при использовании [мульти-запросов](../Searching/Multi-queries.md). Установите значение 0, чтобы пропустить проверку.


<!-- intro -->
##### Example:

<!-- request Example -->

```ini
max_batch_queries = 256
```
<!-- end -->

### max_connections

<!-- example max_connections -->
Максимальное количество одновременных соединений клиентов. По умолчанию неограничено. Это обычно заметно только при использовании какого-либо рода постоянных соединений, таких как сеансы cli mysql или постоянные удаленные соединения из удаленных распределенных таблиц. Когда лимит превышен, вы все еще можете подключиться к серверу, используя [VIP соединение](../Connecting_to_the_server/MySQL_protocol.md#VIP-connection). VIP соединения не учитываются в лимите.

<!-- request Example -->
```ini
max_connections = 10
```

<!-- end -->

### max_threads_per_query

<!-- example max_threads_per_query -->
Лимит по экземпляру на количество потоков, которые может использовать одна операция. По умолчанию соответствующие операции могут занимать все ядра ЦП, не оставляя места для других операций. Например, `call pq` против значительно большой таблицы перколят может использовать все потоки на десятки секунд. Установив `max_threads_per_query` на, скажем, половину [потоков](../Server_settings/Searchd.md#threads), вы убедитесь, что сможете выполнять несколько таких операций `call pq` параллельно.

Вы также можете установить эту настройку как переменную сеанса или глобальную переменную во время выполнения.

Кроме того, вы можете контролировать поведение для каждого запроса с помощью [опции потоков](../Searching/Options.md#threads).

<!-- intro -->
##### Example:
<!-- request Example -->

```ini
max_threads_per_query = 4
```

<!-- end -->

### max_filters

<!-- example conf max_filters -->
Максимально допустимое количество фильтров на запрос. Эта настройка используется только для внутренних проверок корректности и не влияет напрямую на использование ОЗУ или производительность. Необязательный параметр, по умолчанию 256.


<!-- intro -->
##### Example:

<!-- request Example -->

```ini
max_filters = 1024
```
<!-- end -->


### max_filter_values

<!-- example conf max_filter_values -->
Максимально допустимое количество значений на фильтр. Эта настройка используется только для внутренних проверок корректности и не влияет напрямую на использование ОЗУ или производительность. Необязательный параметр, по умолчанию 4096.


<!-- intro -->
##### Example:

<!-- request Example -->

```ini
max_filter_values = 16384
```
<!-- end -->


### max_open_files

<!-- example conf max_open_files -->
Максимальное количество файлов, которые сервер может открыть, называется "мягким пределом". Обратите внимание, что работа с большими фрагментированными таблицами в реальном времени может потребовать установки этого предела на высоком уровне, так как каждый кусок диска может занимать десяток и более файлов. Например, таблица в реальном времени с 1000 кусками может потребовать открытия тысяч файлов одновременно. Если вы сталкиваетесь с ошибкой 'Слишком много открытых файлов' в журналах, попробуйте изменить этот параметр, так как это может помочь решить проблему.

Существует также "жесткий предел", который нельзя превышать с помощью этого параметра. Этот предел определяется системой и может быть изменен в файле `/etc/security/limits.conf` на Linux. У других операционных систем могут быть другие подходы, поэтому обратитесь к вашим руководствам для получения дополнительной информации.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_open_files = 10000
```
<!-- end -->

<!-- example conf max_open_files max -->
Помимо прямых числовых значений, вы можете использовать волшебное слово 'max', чтобы установить предел равным доступному текущему жесткому пределу.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_open_files = max
```
<!-- end -->


### max_packet_size

<!-- example conf max_packet_size -->
Максимально допустимый размер сетевого пакета. Этот параметр ограничивает как запросы от клиентов, так и ответные пакеты от удаленных агентов в распределенной среде. Используется только для внутренних проверок, он не влияет непосредственно на использование ОЗУ или производительность. Необязательный, по умолчанию 128M.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_packet_size = 32M
```
<!-- end -->


### mysql_version_string

<!-- example conf mysql_version_string -->
Строка версии сервера, которую нужно вернуть через протокол MySQL. Необязательный, по умолчанию пустая (возвращает версию Manticore).

Некоторые требовательные библиотеки клиентов MySQL зависят от определенного формата номера версии, используемого MySQL, и более того, иногда выбирают другой путь выполнения в зависимости от указанного номера версии (а не от указанных флагов возможностей). Например, Python MySQLdb 1.2.2 вызывает исключение, когда номер версии не в формате X.Y.ZZ; MySQL .NET connector 6.3.x не работает на номерах версий 1.x вместе с определенной комбинацией флагов и т.д. Чтобы обойти это, вы можете использовать директиву `mysql_version_string` и заставить `searchd` сообщить клиентам другую версию при подключении через протокол MySQL. (По умолчанию он сообщает свою собственную версию.)


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
mysql_version_string = 5.0.37
```
<!-- end -->


### net_workers

Количество сетевых потоков, по умолчанию 1.

Этот параметр полезен для чрезвычайно высоких скоростей запросов, когда одного потока недостаточно для управления всеми входящими запросами.


### net_wait_tm

Управляет интервалом занятости потока сети. По умолчанию -1, и его можно установить на -1, 0 или положительное целое число.

В случаях, когда сервер настроен как чистый мастер и просто направляет запросы агентам, важно обрабатывать запросы без задержек и не позволять потоку сети спать. Для этого существует цикл занятости. После входящего запроса поток сети использует опрос ЦП на `10 * net_wait_tm` миллисекунд, если `net_wait_tm` является положительным числом, или опрашивает только с помощью ЦП, если `net_wait_tm` равно `0`. Также цикл занятости может быть отключен с помощью `net_wait_tm = -1` - в этом случае опросщик устанавливает тайм-аут на актуальные тайм-ауты агента при системном вызове опроса.

> **ПРЕДУПРЕЖДЕНИЕ:** Цикл занятости ЦП фактически нагружает ядро ЦП, поэтому установка этого значения на любое незначение по умолчанию приведет к заметному использованию ЦП даже при неактивном сервере.


### net_throttle_accept

Определяет, сколько клиентов принимается на каждой итерации сетевого цикла. По умолчанию 0 (без ограничений), что должно подойти большинству пользователей. Это параметр тонкой настройки для управления пропускной способностью сетевого цикла в условиях высокой нагрузки.


### net_throttle_action

Определяет, сколько запросов обрабатывается на каждой итерации сетевого цикла. По умолчанию 0 (без ограничений), что должно подойти большинству пользователей. Это параметр тонкой настройки для управления пропускной способностью сетевого цикла в условиях высокой нагрузки.

### network_timeout

<!-- example conf network_timeout -->
Тайм-аут чтения/записи сетевого клиентского запроса, в секундах (или [special_suffixes](../Server_settings/Special_suffixes.md)). Необязательный, по умолчанию 5 секунд. `searchd` принудительно закроет соединение с клиентом, если не удастся отправить запрос или получить результат в течение этого таймаута.

Обратите внимание также на параметр [reset_network_timeout_on_packet](../Server_settings/Searchd.md#reset_network_timeout_on_packet). Этот параметр изменяет поведение `network_timeout` с применения ко всему `query` или `result` на отдельные пакеты вместо этого. Обычно запрос/результат помещается в один или два пакета. Однако в случаях, когда требуется большое количество данных, этот параметр может быть бесценен для поддержания активных операций.

<!-- request Example -->

```ini
network_timeout = 10s
```
<!-- end -->

### node_address

<!-- example conf node_address -->
Этот параметр позволяет указать сетевой адрес узла. По умолчанию он установлен на адрес репликации [listen](../Server_settings/Searchd.md#listen). Это правильно в большинстве случаев; однако есть ситуации, когда вам нужно указать его вручную:

* Узел за брандмауэром
* Включен перевод сетевых адресов (NAT)
* Развертывания контейнеров, такие как Docker или облачные развертывания
* Кластеры с узлами в более чем одном регионе


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
node_address = 10.101.0.10
```
<!-- end -->

### not_terms_only_allowed

<!-- example conf not_terms_only_allowed -->
Этот параметр определяет, разрешать ли запросы только с оператором [отрицания](../Searching/Full_text_matching/Operators.md#Negation-operator) полного текста. Необязательный, по умолчанию 0 (провалить запросы только с оператором NOT).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
not_terms_only_allowed = 1
```
<!-- end -->

### optimize_cutoff

<!-- example conf optimize_cutoff -->
Устанавливает порог по умолчанию для сжатия таблицы. Подробнее читайте здесь - [Количество оптимизированных дисковых чанков](../Securing_and_compacting_a_table/Compacting_a_table.md#Number-of-optimized-disk-chunks). Эта настройка может быть переопределена с помощью опции на уровне запроса [cutoff](../Securing_and_compacting_a_table/Compacting_a_table.md#Number-of-optimized-disk-chunks). Ее также можно изменить динамически через [SET GLOBAL](../Server_settings/Setting_variables_online.md#SET).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
optimize_cutoff = 4
```
<!-- end -->

### persistent_connections_limit

<!-- example conf persistent_connections_limit -->
Эта настройка определяет максимальное количество одновременных постоянных соединений с удалёнными [постоянными агентами](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md). Каждый раз, когда агент, определённый в `agent_persistent`, подключается, мы пытаемся повторно использовать существующее соединение (если таковое имеется), или подключаемся и сохраняем соединение для дальнейшего использования. Однако в некоторых случаях имеет смысл ограничить количество таких постоянных соединений. Эта директива определяет предел. Она влияет на количество соединений с хостом каждого агента по всем распределённым таблицам.

Разумно установить значение равным или меньше значения опции [max_connections](../Server_settings/Searchd.md#max_connections) в конфигурации агента.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
persistent_connections_limit = 29 # assume that each host of agents has max_connections = 30 (or 29).
```
<!-- end -->


### pid_file

<!-- example conf pid_file -->
pid_file - это обязательная конфигурационная опция в Manticore search, которая указывает путь к файлу, где хранится идентификатор процесса сервера `searchd`.

Файл идентификатора процесса searchd создаётся заново и блокируется при запуске, и содержит идентификатор основного серверного процесса, пока сервер работает. Он удаляется при завершении работы сервера.
Цель этого файла - позволить Manticore выполнять различные внутренние задачи, такие как проверка, запущен ли уже экземпляр `searchd`, остановка `searchd` и уведомление его о необходимости поворота таблиц. Файл также может быть использован для внешних скриптов автоматизации.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
pid_file = /var/run/manticore/searchd.pid
```
<!-- end -->


### predicted_time_costs

<!-- example conf predicted_time_costs -->
Затраты на модель предсказания времени запроса, в наносекундах. Необязательно, по умолчанию `doc=64, hit=48, skip=2048, match=64`.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
predicted_time_costs = doc=128, hit=96, skip=4096, match=128
```
<!-- end -->

<!-- example conf predicted_time_costs 1 -->
Прекращение запросов до завершения на основе их времени выполнения (с настройкой максимального времени запроса) - это хорошая мера безопасности, но она имеет свой встроенный недостаток: неопределённые (нестабильные) результаты. То есть, если вы повторите точно такой же (сложный) поисковый запрос с ограничением по времени несколько раз, ограничение по времени будет достигнуто на разных стадиях, и вы получите *разные* наборы результатов.

<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
SELECT … OPTION max_query_time
```
<!-- request API -->

```api
SetMaxQueryTime()
```
<!-- end -->

Существует новая опция, [SELECT … OPTION max_predicted_time](../Searching/Options.md#max_predicted_time), которая позволяет ограничить время запроса *и* получать стабильные, повторяемые результаты. Вместо регулярной проверки фактического текущего времени во время оценки запроса, что является неопределённым, она предсказывает текущее время выполнения с использованием простой линейной модели:

```ini
predicted_time =
    doc_cost * processed_documents +
    hit_cost * processed_hits +
    skip_cost * skiplist_jumps +
    match_cost * found_matches
```

Запрос затем прекращается преждевременно, когда `predicted_time` достигает заданного предела.

Конечно, это не жёсткий предел на фактическое затраченное время (тем не менее, это жёсткий предел на объём выполненной *обработки*), и простая линейная модель никоим образом не является идеальной точной. Поэтому фактическое время *может* быть как ниже, так и выше целевого предела. Тем не менее, пределы погрешности вполне допустимы: например, в наших экспериментах с целевым пределом 100 мс большинство тестовых запросов попало в диапазон 95-105 мс, и *все* запросы были в диапазоне 80-120 мс. Также, в качестве приятного побочного эффекта, использование смоделированного времени запроса вместо измерения фактического времени выполнения приводит к нескольким меньшему количеству вызовов gettimeofday().

Нет двух серверов, которые были бы идентичны, поэтому директива `predicted_time_costs` позволяет вам настроить затраты для вышеуказанной модели. Для удобства они являются целыми числами, измеряемыми в наносекундах. (Предел в max_predicted_time измеряется в миллисекундах, и необходимость указывать значения затрат как 0.000128 мс вместо 128 нс является несколько более подверженной ошибкам.) Не обязательно указывать все четыре значения затрат сразу, так как пропущенные будут принимать значения по умолчанию. Тем не менее, мы настоятельно рекомендуем указать все из них для удобочитаемости.


### preopen_tables

<!-- example conf preopen_tables -->
Директива настройки preopen_tables указывает, следует ли принудительно предварительно открывать все таблицы при запуске. Значение по умолчанию - 1, что означает, что все таблицы будут предварительно открыты независимо от настройки [preopen](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Other-performance-related-settings) для каждой таблицы. Если установлено в 0, могут вступить в силу настройки для каждой таблицы, и они будут по умолчанию равны 0.

Предварительное открытие таблиц может предотвратить конфликты между поисковыми запросами и ротациями, которые могут время от времени приводить к сбоям запросов. Однако это также использует больше дескрипторов файлов. В большинстве сценариев рекомендуется предварительно открывать таблицы.

Вот пример конфигурации:

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
preopen_tables = 1
```
<!-- end -->

### pseudo_sharding

<!-- example conf pseudo_sharding -->
Опция конфигурации pseudo_sharding включает параллелизацию поисковых запросов к локальным обычным и реальным таблицам, независимо от того, запрашиваются ли они непосредственно или через распределённую таблицу. Эта функция автоматически параллелизует запросы до указанного в `searchd.threads` количества потоков.

Обратите внимание, что если ваши рабочие потоки уже заняты, потому что у вас:
* высокая конкуренция запросов
* физическое шардирование любого рода:
  - распределённая таблица из нескольких обычных/реальных таблиц
  - реальная таблица, состоящая из слишком многих дисковых чанков

тогда включение псевдо_sharding может не дать никаких преимуществ и даже привести к незначительному снижению пропускной способности. Если вы придаете большее значение высокой пропускной способности, чем низкой задержке, рекомендуется отключить эту опцию.

Включено по умолчанию.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
pseudo_sharding = 0
```
<!-- end -->


### replication_connect_timeout

Директива `replication_connect_timeout` определяет тайм-аут для подключения к удаленному узлу. По умолчанию предполагается, что значение указывается в миллисекундах, но оно может иметь [другой суффикс](../../Server_settings/Special_suffixes.md). Значение по умолчанию - 1000 (1 секунда).

При подключении к удаленному узлу Manticore будет ожидать не более этого времени для успешного завершения соединения. Если тайм-аут истекает, но соединение не установлено, и включены `retries`, будет инициирована повторная попытка.


### replication_query_timeout

`replication_query_timeout` устанавливает время, в течение которого searchd будет ждать, чтобы удаленный узел завершил запрос. Значение по умолчанию - 3000 миллисекунд (3 секунды), но его можно `суффиксировать`, чтобы указать другую единицу времени.

После установления соединения Manticore будет ждать максимум `replication_query_timeout`, чтобы удаленный узел завершил запрос. Обратите внимание, что этот тайм-аут отличается от `replication_connect_timeout`, и общее возможное время задержки, вызванное удаленным узлом, будет суммой обоих значений.


### replication_retry_count

Эта настройка представляет собой целое число, которое указывает, сколько раз Manticore попытается подключиться и выполнить запрос к удаленному узлу во время репликации, прежде чем сообщить о фатальной ошибке запроса. Значение по умолчанию - 3.


### replication_retry_delay

Эта настройка представляет собой целое число в миллисекундах (или [special_suffixes](../Server_settings/Special_suffixes.md)), которое указывает задержку перед повторной попыткой Manticore выполнить запрос к удаленному узлу в случае ошибки во время репликации. Это значение имеет значение только в том случае, если указано значение, отличное от нуля. Значение по умолчанию - 500.

### qcache_max_bytes

<!-- example conf qcache_max_bytes -->
Эта конфигурация устанавливает максимальное количество ОЗУ, выделенное для кэшированных наборов результатов в байтах. Значение по умолчанию - 16777216, что эквивалентно 16 мегабайтам. Если значение установлено в 0, кэш запросов отключен. Для получения дополнительной информации о кэше запросов, пожалуйста, обратитесь к [кэшу запросов](../Searching/Query_cache.md) для получения подробностей.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
qcache_max_bytes = 16777216
```
<!-- end -->


### qcache_thresh_msec

Целое число в миллисекундах. Минимальный порог времени ожидания, при котором результаты запроса могут быть кэшированы. По умолчанию - 3000 или 3 секунды. 0 означает кэширование всего. Обратитесь к [кэшу запросов](../Searching/Query_cache.md) для получения подробностей. Это значение также может быть выражено с помощью [special_suffixes](../Server_settings/Special_suffixes.md), но используйте его с осторожностью и не путайте с названием самого значения, содержащим '_msec'.


### qcache_ttl_sec

Целое число в секундах. Период действия для кэшированного набора результатов. По умолчанию - 60 или 1 минута. Минимально возможное значение - 1 секунда. Обратитесь к [кэшу запросов](../Searching/Query_cache.md) для получения подробностей. Это значение также может быть выражено с помощью [special_suffixes](../Server_settings/Special_suffixes.md), но используйте его с осторожностью и не путайте с названием самого значения, содержащим '_sec'.


### query_log_format

<!-- example conf query_log_format -->
Формат журнала запросов. Необязательный, допустимые значения: `plain` и `sphinxql`, по умолчанию `sphinxql`.

Режим `sphinxql` записывает допустимые SQL-операторы. Режим `plain` записывает запросы в простом текстовом формате (в основном подходит для случаев полной текстовой обработки). Эта директива позволяет вам переключаться между двумя форматами при запуске поискового сервера. Формат журнала также может быть изменен динамически, используя синтаксис `SET GLOBAL query_log_format=sphinxql`. Обратитесь к [журналированию запросов](../Logging/Query_logging.md) для получения дополнительных деталей.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
query_log_format = sphinxql
```
<!-- end -->

### query_log_min_msec

Лимит (в миллисекундах), который предотвращает запись запроса в журнал запросов. Необязательный, по умолчанию 0 (все запросы записываются в журнал запросов). Эта директива указывает, что только запросы с временем выполнения, превышающим указанный лимит, будут записываться (это значение также может быть выражено с помощью [special_suffixes](../Server_settings/Special_suffixes.md), но используйте его с осторожностью и не путайте с названием самого значения, содержащим `_msec`).

### query_log

<!-- example conf query_log -->
Имя файла журнала запросов. Необязательное, по умолчанию пусто (не записывать запросы). Все поисковые запросы (такие как SELECT ... но не INSERT/REPLACE/UPDATE запросы) будут записываться в этот файл. Формат описан в [журналировании запросов](../Logging/Query_logging.md). В случае формата 'plain' вы можете использовать 'syslog' в качестве пути к файлу журнала. В этом случае все поисковые запросы будут отправлены демону syslog с приоритетом `LOG_INFO`, с префиксом '[query]' вместо временной метки. Чтобы использовать опцию syslog, Manticore должен быть настроен с `-–with-syslog` при сборке.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
query_log = /var/log/query.log
```
<!-- end -->


### query_log_mode

<!-- example conf query_log_mode -->
Директива query_log_mode позволяет установить свои права доступа для файлов журнала searchd и журнала запросов. По умолчанию эти файлы журнала создаются с правами 600, что означает, что только пользователь, под которым работает сервер, и пользователи с правами root могут читать файлы журнала.
Эта директива может быть полезна, если вы хотите разрешить другим пользователям чтение файлов журнала, например, решениям для мониторинга, работающим на не-root пользователях.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
query_log_mode  = 666
```
<!-- end -->

### read_buffer_docs

<!-- example conf read_buffer_docs -->
Директива read_buffer_docs управляет размером буфера чтения на ключевое слово для списков документов. Для каждого вхождения ключевого слова в каждом поисковом запросе существует два связанных буфера чтения: один для списка документов и один для списка результатов. Эта настройка позволяет вам контролировать размер буфера списка документов.

Более крупный размер буфера может увеличить использование RAM на запрос, но, возможно, снизит время I/O. Имеет смысл устанавливать большие значения для медленных хранилищ, но для хранилищ, способных к высокой IOPS, следует проводить эксперименты в области низких значений.

Значение по умолчанию составляет 256K, а минимальное значение – 8K. Вы также можете установить [read_buffer_docs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#read_buffer_docs) на уровне отдельных таблиц, что переопределит все, что задано на уровне конфигурации сервера.


<!-- intro -->
##### Пример:

<!-- request Пример -->

```ini
read_buffer_docs = 128K
```
<!-- end -->


### read_buffer_hits

<!-- example conf read_buffer_hits -->
Директива read_buffer_hits задает размер буфера чтения для списков хитов в поисковых запросах на ключевом уровне. По умолчанию размер составляет 256K, а минимальное значение – 8K. Для каждого вхождения ключевого слова в поисковом запросе существуют два связанных буфера чтения, один для списка документов и один для списка хитов. Увеличение размера буфера может увеличить использование RAM на запрос, но снизить время I/O. Для медленного хранилища большие размеры буфера имеют смысл, в то время как для хранилищ, способных к высокой IOPS, эксперименты следует проводить в области низких значений.

Эту настройку также можно указать для каждой таблицы отдельно, используя опцию read_buffer_hits в [read_buffer_hits](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#read_buffer_hits), что переопределит настройку на уровне сервера.

<!-- intro -->
##### Пример:

<!-- request Пример -->

```ini
read_buffer_hits = 128K
```
<!-- end -->

### read_unhinted

<!-- example conf read_unhinted -->
Размер необозначенного чтения. Необязательный, по умолчанию 32K, минимально 1K

При запросе некоторые чтения заранее знают, сколько данных нужно прочитать, но некоторые в данный момент этого не знают. В частности, размер списка хитов в данный момент не известен заранее. Эта настройка позволяет вам контролировать, сколько данных считывать в таких случаях. Она влияет на время I/O списков хитов, уменьшая его для списков, больших необозначенного размера чтения, но увеличивая для меньших списков. Она **не** влияет на использование RAM, поскольку буфер чтения уже будет выделен. Поэтому он не должен превышать read_buffer.


<!-- intro -->
##### Пример:

<!-- request Пример -->

```ini
read_unhinted = 32K
```
<!-- end -->

### reset_network_timeout_on_packet

<!-- example conf reset_network_timeout_on_packet -->
Уточняет поведение сетевых таймаутов (таких как `network_timeout`, `read_timeout` и `agent_query_timeout`).

При установке на 0 таймауты ограничивают максимальное время отправки всего запроса/запроса.
При установке на 1 (по умолчанию) таймауты ограничивают максимальное время между сетевыми действиями.

При репликации узел может потребоваться отправить большой файл (например, 100 ГБ) другому узлу. Предположим, что сеть может передавать данные со скоростью 1 ГБ/с, с серией пакетов размером по 4-5 МБ каждый. Чтобы передать весь файл, вам потребуется 100 секунд. Таймаут по умолчанию в 5 секунд позволит передать только 5 ГБ, прежде чем соединение будет прервано. Увеличение таймаута может быть обходным решением, но это не масштабируемо (например, следующий файл может составлять 150 ГБ, что снова приведет к сбою). Однако при установленном по умолчанию `reset_network_timeout_on_packet` на 1 таймаут применяется не ко всему передаче, а к отдельным пакетам. Пока передача продолжается (и данные действительно принимаются через сеть в течение периода таймаута), соединение остается активным. Если передача застрянет так, что таймаут произойдет между пакетами, соединение будет прервано.

Обратите внимание, что если вы настроите распределенную таблицу, каждый узел — как мастер, так и агенты — должен быть настроен. С стороны мастера на это влияет `agent_query_timeout`, а для агентов актуален `network_timeout`.

<!-- intro -->

##### Пример:

<!-- request Пример -->

```ini
reset_network_timeout_on_packet = 0
```

<!-- end -->


### rt_flush_period

<!-- example conf rt_flush_period -->
Период проверки сброса блока RAM таблиц RT, в секундах (или [special_suffixes](../Server_settings/Special_suffixes.md)). Необязательный, по умолчанию 10 часов.

Активно обновляемые RT таблицы, которые полностью помещаются в блоки RAM, все равно могут приводить к постоянно растущим binlogs, влияя на использование диска и время восстановления после сбоя. С помощью этой директивы сервер поиска выполняет периодические проверки сброса, и соответствующие блоки RAM могут быть сохранены, что позволяет провести последующую очистку binlog. Смотрите [Бинарная регистрация](../Logging/Binary_logging.md) для получения более подробной информации.

<!-- intro -->
##### Пример:

<!-- request Пример -->

```ini
rt_flush_period = 3600 # 1 hour
```
<!-- end -->


### rt_merge_iops

<!-- example conf rt_merge_iops -->
Максимальное количество операций I/O (в секунду), которые разрешено запускать потоку слияния блоков RT. Необязательный, по умолчанию 0 (без ограничений).

Эта директива позволяет снизить влияние I/O от операторов `OPTIMIZE`. Гарантируется, что все действия по оптимизации RT не будут генерировать более дисковых IOPS (I/Os в секунду), чем установленный лимит. Ограничение rt_merge_iops может снизить деградацию производительности поиска, вызванную слиянием.

<!-- intro -->
##### Пример:

<!-- request Пример -->

```ini
rt_merge_iops = 40
```
<!-- end -->

### rt_merge_maxiosize

<!-- example conf rt_merge_maxiosize -->
Максимальный размер операции I/O, которую разрешено запускать потоку слияния блоков RT. Необязательный, по умолчанию 0 (без ограничений).

Эта директива позволяет снизить влияние I/O от операторов `OPTIMIZE`. I/Os, превышающие этот лимит, будут разбиты на две или более I/O, которые затем будут учитываться как отдельные I/O относительно лимита [rt_merge_iops](../Server_settings/Searchd.md#rt_merge_iops). Таким образом, гарантируется, что все действия оптимизации не будут генерировать более чем (rt_merge_iops * rt_merge_maxiosize) байт дискового I/O в секунду.


<!-- intro -->
##### Пример:

<!-- request Пример -->

```ini
rt_merge_maxiosize = 1M
```
<!-- end -->


### seamless_rotate

<!-- example conf seamless_rotate -->
Предотвращает зависания `searchd` при вращении таблиц с огромными объемами данных для предварительного кэширования. Необязательный, по умолчанию 1 (включить бесшовное вращение). В системах Windows бесшовное вращение по умолчанию отключено.

Таблицы могут содержать данные, которые необходимо предварительно кэшировать в ОЗУ. На данный момент файлы `.spa`, `.spb`, `.spi` и `.spm` полностью кэшируются (они содержат данные атрибутов, данные атрибутов блобов, таблицу ключевых слов и карту удаленных строк соответственно). Без бесшовного вращения, вращение таблицы пытается использовать как можно меньше ОЗУ и работает следующим образом:

1. Новые запросы временно отклоняются (с кодом ошибки "retry");
2. `searchd` ожидает завершения всех текущих выполняемых запросов;
3. Старая таблица освобождается, и ее файлы переименовываются;
4. Новые файлы таблицы переименовываются, и требуется ОЗУ выделяется;
5. Новые данные атрибутов и словаря таблицы предварительно загружаются в ОЗУ;
6. `searchd` возобновляет обслуживание запросов из новой таблицы.

Однако, если имеется много данных атрибутов или данных словаря, то шаг предварительной загрузки может занять заметное количество времени - до нескольких минут в случае предварительной загрузки файлов объемом 1-5+ ГБ.

При включенном бесшовном вращении, вращение работает следующим образом:

1. ОЗУ для новой таблицы выделяется;
2. Новые данные атрибутов и словаря таблицы асинхронно загружаются в ОЗУ;
3. В случае успеха старая таблица освобождается, и файлы обеих таблиц переименовываются;
4. В случае неудачи новая таблица освобождается;
5. В любой момент времени запросы обслуживаются либо из старой, либо из новой копии таблицы.

Бесшовное вращение стоит дороже в плане повышения пикового использования памяти во время вращения (так как обе старые и новые копии данных `.spa/.spb/.spi/.spm` должны находиться в ОЗУ во время предварительной загрузки новой копии). Среднее использование остается таким же.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
seamless_rotate = 1
```
<!-- end -->

### secondary_indexes
<!-- example conf secondary_indexes -->

Этот параметр включает/выключает использование вторичных индексов для поисковых запросов. Он необязателен, и по умолчанию значение 1 (включено). Обратите внимание, что вам не нужно включать его для индексирования, так как он всегда включен, пока установлена [Manticore Columnar Library](https://github.com/manticoresoftware/columnar). Последняя также требуется для использования индексов при поиске. Доступны три режима:

* `0`: Отключить использование вторичных индексов в поиске. Их можно включить для отдельных запросов с помощью [подсказок анализатора](../Searching/Options.md#Query-optimizer-hints)
* `1`: Включить использование вторичных индексов в поиске. Их можно отключить для отдельных запросов с помощью [подсказок анализатора](../Searching/Options.md#Query-optimizer-hints)
* `force`: То же самое, что и включение, но любые ошибки во время загрузки вторичных индексов будут сообщены, и весь индекс не будет загружен в демон.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
secondary_indexes = 1
```

<!-- end -->

### server_id

<!-- example conf server_id -->
Целое число, которое служит идентификатором сервера, используемым как начальное значение для генерации уникального короткого UUID для узлов, являющихся частью кластера репликации. server_id должен быть уникальным среди узлов кластера и находиться в диапазоне от 0 до 127. Если server_id не установлен, он рассчитывается как хэш физического адреса и пути к файлу PID или случайное число будет использовано как начальное значение для короткого UUID.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
server_id = 1
```
<!-- end -->


### shutdown_timeout

<!-- example conf shutdown_timeout -->
Время ожидания `searchd --stopwait`, в секундах (или [special_suffixes](../Server_settings/Special_suffixes.md)). Необязательный, по умолчанию 60 секунд.

Когда вы запускаете `searchd --stopwait`, вашему серверу необходимо выполнить некоторые действия перед остановкой, такие как завершение запросов, сброс кусочков ОЗУ RT, сброс атрибутов и обновление binlog. Эти задачи требуют определенного времени. `searchd --stopwait` будет ожидать до `shutdown_time` секунд, чтобы сервер завершил свои задачи. Подходящее время зависит от размера вашей таблицы и нагрузки.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
shutdown_timeout = 3m # wait for up to 3 minutes
```
<!-- end -->


### shutdown_token

SHA1 хэш пароля, необходимый для вызова команды 'shutdown' из VIP Manticore SQL соединения. Без него [debug](../Reporting_bugs.md#DEBUG) подкоманда 'shutdown' никогда не заставит сервер остановиться. Обратите внимание, что такой простой хэш не следует считать надежной защитой, так как мы не используем хэш с солью или какой-либо другой современный хэш-функции. Он предназначен как мера предосторожности для обслуживающих демонов в локальной сети.

### snippets_file_prefix

<!-- example conf snippets_file_prefix -->
Префикс, который добавляется к локальным именам файлов при генерации фрагментов. Необязательный, по умолчанию текущая рабочая папка.

Этот префикс может быть использован в распределенной генерации фрагментов вместе с параметрами `load_files` или `load_files_scattered`.

Обратите внимание, что это префикс, а **не** путь! Это означает, что если префикс установлен на "server1", и запрос ссылается на "file23", `searchd` попытается открыть "server1file23" (все это без кавычек). Таким образом, если вам нужно, чтобы это был путь, вы должны включить завершающий слэш.

После построения финального пути к файлу, сервер разворачивает все относительные директории и сравнивает финальный результат со значением `snippet_file_prefix`. Если результат не начинается с префикса, такой файл будет отклонен с сообщением об ошибке.

Например, если вы установите его на `/mnt/data`, и кто-то вызовет генерацию фрагмента с файлом `../../../etc/passwd` в качестве источника, они получат сообщение об ошибке:

`Файл '/mnt/data/../../../etc/passwd' выходит за пределы области '/mnt/data/'`

вместо содержимого файла.

Также, при неустановленном параметре и чтении `/etc/passwd`, он фактически прочитает /daemon/working/folder/etc/passwd, так как по умолчанию для параметра установлена рабочая папка сервера.

Также обратите внимание, что это локальный параметр; он не влияет на агенты никаким образом. Таким образом, вы можете безопасно установить префикс на главном сервере. Запросы, перенаправляемые к агентам, не будут затронуты установкой главного сервера. Однако они будут затронуты собственными настройками агента.

Это может быть полезно, например, когда расположения хранилищ документов (будь то локальное хранилище или точки монтирования NAS) непоследовательны по серверам.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
snippets_file_prefix = /mnt/common/server1/
```
<!-- end -->

> **ПРЕДУПРЕЖДЕНИЕ:** Если вы все еще хотите получить доступ к файлам из корня FS, вам нужно явно установить `snippets_file_prefix` в пустое значение (строкой `snippets_file_prefix=`) или в корень (строкой `snippets_file_prefix=/`).


### sphinxql_state

<!-- example conf sphinxql_state -->
Путь к файлу, в котором будет сериализовано текущее состояние SQL.

При запуске сервера этот файл воспроизводится. При изменениях состояния, подлежащих обработке (например, SET GLOBAL), этот файл автоматически перезаписывается. Это может предотвратить трудно диагностируемую проблему: если вы загружаете функции UDF, но Manticore вылетает, когда он (автоматически) перезапускается, ваши функции UDF и глобальные переменные больше не будут доступны. Использование постоянного состояния помогает обеспечить плавное восстановление без таких неприятных сюрпризов.

`sphinxql_state` не может быть использован для выполнения произвольных команд, таких как `CREATE TABLE`.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
sphinxql_state = uservars.sql
```
<!-- end -->


### sphinxql_timeout

<!-- example conf sphinxql_timeout -->
Максимальное время ожидания между запросами (в секундах или [special_suffixes](../Server_settings/Special_suffixes.md)) при использовании SQL интерфейса. Необязательно, по умолчанию 15 минут.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
sphinxql_timeout = 15m
```
<!-- end -->


### ssl_ca

<!-- example conf ssl_ca -->
Путь к файлу сертификата Удостоверяющего центра (CA) SSL (также известен как корневой сертификат). Необязательно, по умолчанию пусто. Если не пусто, сертификат в `ssl_cert` должен быть подписан этим корневым сертификатом.

Сервер использует файл CA для проверки подписи на сертификате. Файл должен быть в формате PEM.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ssl_ca = keys/ca-cert.pem
```
<!-- end -->


### ssl_cert

<!-- example conf ssl_cert -->
Путь к SSL-сертификату сервера. Необязательно, по умолчанию пусто.

Сервер использует этот сертификат в качестве самоподписанного открытого ключа для шифрования HTTP-трафика через SSL. Файл должен быть в формате PEM.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ssl_cert = keys/server-cert.pem
```
<!-- end -->


### ssl_key

<!-- example conf ssl_key -->
Путь к ключу сертификата SSL. Необязательно, по умолчанию пусто.

Сервер использует этот закрытый ключ для шифрования HTTP-трафика через SSL. Файл должен быть в формате PEM.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ssl_key = keys/server-key.pem
```
<!-- end -->


### subtree_docs_cache

<!-- example conf subtree_docs_cache -->
Максимальный размер кеша документов общего поддерева на запрос. Необязательно, по умолчанию 0 (отключен).

Эта настройка ограничивает использование оперативной памяти оптимизатором общего поддерева (см. [multi-queries](../Searching/Multi-queries.md)). Максимум, так много оперативной памяти будет потрачено на кеширование записей документов для каждого запроса. Установка лимита в 0 отключает оптимизатор.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
subtree_docs_cache = 8M
```
<!-- end -->


### subtree_hits_cache

<!-- example conf subtree_hits_cache -->
Максимальный размер кеша результатов общего поддерева на запрос. Необязательно, по умолчанию 0 (отключен).

Эта настройка ограничивает использование оперативной памяти оптимизатором общего поддерева (см. [multi-queries](../Searching/Multi-queries.md)). Максимум, так много оперативной памяти будет потрачено на кеширование вхождений ключевых слов (результатов) для каждого запроса. Установка лимита в 0 отключает оптимизатор.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
subtree_hits_cache = 16M
```
<!-- end -->

### threads

<!-- example threads -->
Количество рабочих потоков (или, размер пула потоков) для демона Manticore. Manticore создает это количество потоков ОС при запуске, и они выполняют все задачи внутри демона, такие как выполнение запросов, создание сниппетов и т. д. Некоторые операции могут быть разделены на подзадачи и выполняться параллельно, например:

* Поиск в таблице реального времени
* Поиск в распределенной таблице, состоящей из локальных таблиц
* Вызов запроса перколяции
* и другие

По умолчанию оно установлено на количество ядер ЦПУ на сервере. Manticore создает потоки при запуске и держит их до остановки. Каждая подзадача может использовать один из потоков, когда ему это нужно. Когда подзадача завершается, она освобождает поток, чтобы другая подзадача могла его использовать.

В случае интенсивной загрузки, связанной с вводом-выводом, может иметь смысл установить значение выше, чем количество ядер ЦПУ.

<!-- request Example -->
```ini
threads = 10
```

<!-- end -->

### thread_stack

<!-- example conf thread_stack -->
Максимальный размер стека для задания (корутину, один поисковый запрос может вызвать несколько заданий/корутин). Необязательно, по умолчанию 128K.

Каждое задание имеет свой собственный стек объемом 128K. Когда вы запускаете запрос, проверяется, сколько стека требуется. Если по умолчанию 128K достаточно, он просто обрабатывается. Если требуется больше, запланировано другое задание с увеличенным стеком, которое продолжает обработку. Максимальный размер такого расширенного стека ограничен этой настройкой.

Установка значения на разумно высокое значение поможет с обработкой очень глубоких запросов без предположения о том, что общее потребление ОЗУ станет слишком высоким. Например, установка его на 1G не подразумевает, что каждое новое задание будет занимать 1G ОЗУ, но если мы увидим, что оно требует, скажем, 100M стека, мы просто выделяем 100M для задания. Другие задания в то же время будут выполняться с их стандартным стеком 128K. Таким же образом мы можем выполнять даже более сложные запросы, которые требуют 500M. И только если мы **увидим** внутри, что задание требует более 1G стека, мы потерпим неудачу и сообщим о слишком низком значении thread_stack.

Тем не менее, на практике даже запрос, который требует 16M стека, часто слишком сложен для парсинга и требует слишком много времени и ресурсов для обработки. Таким образом, демон будет обрабатывать его, но ограничение таких запросов с помощью настройки `thread_stack` выглядит вполне разумным.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
thread_stack = 8M
```
<!-- end -->


### unlink_old

<!-- example conf unlink_old -->
Определяет, следует ли удалять `.old` копии таблиц при успешной ротации. Необязательно, по умолчанию 1 (удалить).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
unlink_old = 0
```
<!-- end -->


### watchdog

<!-- example conf watchdog -->
Поточный серверный монитор. Необязательно, по умолчанию 1 (монитор включен).

Когда запрос Manticore вызывает сбой, это может привести к падению всего сервера. С включенной функцией наблюдателя `searchd` также поддерживает отдельный легковесный процесс, который отслеживает основной серверный процесс и автоматически перезапускает его в случае ненормального завершения. Функция наблюдателя включена по умолчанию.

<!-- request Example -->

```ini
watchdog = 0 # disable watchdog
```
<!-- end -->
<!-- proofread -->
