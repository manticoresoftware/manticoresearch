# Раздел "Searchd" в конфигурации

Приведённые ниже настройки используются в разделе `searchd` файла конфигурации Manticore Search для управления поведением сервера. Ниже приведено краткое описание каждой настройки:

### access_plain_attrs

Эта настройка устанавливает глобальные значения по умолчанию для [access_plain_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `mmap_preread`.

Директива `access_plain_attrs` позволяет определить значение по умолчанию для [access_plain_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых данным экземпляром searchd. Директивы на уровне таблицы имеют более высокий приоритет и переопределяют это глобальное значение по умолчанию, обеспечивая более детальный контроль.

### access_blob_attrs

Эта настройка устанавливает глобальные значения по умолчанию для [access_blob_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `mmap_preread`.

Директива `access_blob_attrs` позволяет определить значение по умолчанию для [access_blob_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых данным экземпляром searchd. Директивы на уровне таблицы имеют более высокий приоритет и переопределяют это глобальное значение по умолчанию, обеспечивая более детальный контроль.

### access_doclists

Эта настройка устанавливает глобальные значения по умолчанию для [access_doclists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `file`.

Директива `access_doclists` позволяет определить значение по умолчанию для [access_doclists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых данным экземпляром searchd. Директивы на уровне таблицы имеют более высокий приоритет и переопределяют это глобальное значение по умолчанию, обеспечивая более детальный контроль.

### access_hitlists

Эта настройка устанавливает глобальные значения по умолчанию для [access_hitlists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `file`.

Директива `access_hitlists` позволяет определить значение по умолчанию для [access_hitlists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых данным экземпляром searchd. Директивы на уровне таблицы имеют более высокий приоритет и переопределяют это глобальное значение по умолчанию, обеспечивая более детальный контроль.

### access_dict

Эта настройка устанавливает глобальные значения по умолчанию для [access_dict](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `mmap_preread`.

Директива `access_dict` позволяет определить значение по умолчанию для [access_dict](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых данным экземпляром searchd. Директивы на уровне таблицы имеют более высокий приоритет и переопределяют это глобальное значение по умолчанию, обеспечивая более детальный контроль.

### agent_connect_timeout

Эта настройка устанавливает глобальные значения по умолчанию для параметра [agent_connect_timeout](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_connect_timeout).


### agent_query_timeout

Эта настройка устанавливает глобальные значения по умолчанию для параметра [agent_query_timeout](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_query_timeout). Она может быть переопределена для отдельного запроса с помощью предложения `OPTION agent_query_timeout=XXX`.


### agent_retry_count

Эта настройка представляет собой целое число, которое указывает, сколько раз Manticore будет пытаться подключиться и выполнить запрос к удалённым агентам через распределённую таблицу, прежде чем сообщить о фатальной ошибке запроса. Значение по умолчанию — 0 (т.е. без повторных попыток). Это значение также можно установить для отдельного запроса с помощью предложения `OPTION retry_count=XXX`. Если указана опция для запроса, она переопределит значение, заданное в конфигурации.

Обратите внимание, что если в определении вашей распределённой таблицы используются [зеркала агентов](../Creating_a_cluster/Remote_nodes/Mirroring.md#Agent-mirrors), сервер будет выбирать другое зеркало для каждой попытки подключения в соответствии с выбранной [ha_strategy](../Creating_a_cluster/Remote_nodes/Load_balancing.md#ha_strategy). В этом случае значение `agent_retry_count` будет агрегировано для всех зеркал в наборе.

Например, если у вас есть 10 зеркал и установлено `agent_retry_count=5`, сервер выполнит до 50 повторных попыток, предполагая в среднем по 5 попыток для каждого из 10 зеркал (при опции `ha_strategy = roundrobin` так и будет).

Однако значение, указанное в качестве опции `retry_count` для [агента](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent), служит абсолютным ограничением. Другими словами, опция `[retry_count=2]` в определении агента всегда означает максимум 2 попытки, независимо от того, указали вы для агента 1 или 10 зеркал.

### agent_retry_delay

Эта настройка представляет собой целое число в миллисекундах (или [специальных суффиксах](../Server_settings/Special_suffixes.md)), которое указывает задержку перед повторной попыткой выполнения запроса к удалённому агенту в случае сбоя. Это значение актуально только при указании ненулевого значения [agent_retry_count](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md) или ненулевого значения `retry_count` для запроса. Значение по умолчанию — 500. Это значение также можно установить для отдельного запроса с помощью предложения `OPTION retry_delay=XXX`. Если указана опция для запроса, она переопределит значение, заданное в конфигурации.


### attr_flush_period

<!-- example conf attr_flush_period -->
При использовании [UPDATE](../Data_creation_and_modification/Updating_documents/UPDATE.md) для изменения атрибутов документов в реальном времени изменения сначала записываются в копию атрибутов в оперативной памяти. Эти обновления происходят в файле, отображаемом в память, что означает, что ОС решает, когда записать изменения на диск. При нормальном завершении работы `searchd` (вызванном сигналом `SIGTERM`) все изменения принудительно записываются на диск.

Вы также можете указать `searchd` периодически записывать эти изменения обратно на диск, чтобы предотвратить потерю данных. Интервал между этими сбросами определяется параметром `attr_flush_period`, указываемым в секундах (или с использованием [специальных суффиксов](../Server_settings/Special_suffixes.md)).

По умолчанию значение равно 0, что отключает периодический сброс. Однако сброс всё равно произойдёт при нормальном завершении работы.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
attr_flush_period = 900 # persist updates to disk every 15 minutes
```
<!-- end -->

### auto_optimize

<!-- example conf auto_optimize -->
Эта настройка управляет автоматическим процессом [OPTIMIZE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE) для уплотнения таблицы.

По умолчанию уплотнение таблицы происходит автоматически. Вы можете изменить это поведение с помощью настройки `auto_optimize`:
* 0 для отключения автоматического уплотнения таблицы (вы всё равно можете вручную вызывать `OPTIMIZE`)
* 1 для явного включения
* для включения с умножением порога оптимизации на 2.

По умолчанию OPTIMIZE выполняется до тех пор, пока количество дисковых чанков не станет меньше или равно количеству логических ядер ЦП, умноженному на 2.

Однако, если у таблицы есть атрибуты с KNN-индексами, этот порог отличается. В этом случае он устанавливается равным количеству физических ядер ЦП, делённому на 2, для повышения производительности поиска KNN.

Обратите внимание, что включение или отключение `auto_optimize` не мешает вам вручную запускать [OPTIMIZE TABLE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE).

<!-- intro -->
##### Пример:

<!-- request Disable -->
```ini
auto_optimize = 0 # disable automatic OPTIMIZE
```

<!-- request Throttle -->
```ini
auto_optimize = 2 # OPTIMIZE starts at 16 chunks (on 4 cpu cores server)
```

<!-- end -->

### auto_schema

<!-- example conf auto_schema -->
Manticore поддерживает автоматическое создание таблиц, которые ещё не существуют, но указаны в операторах INSERT. Эта функция включена по умолчанию. Чтобы отключить её, явно установите `auto_schema = 0` в вашей конфигурации. Чтобы снова включить, установите `auto_schema = 1` или удалите настройку `auto_schema` из конфигурации.

Имейте в виду, что HTTP-эндпоинт `/bulk` не поддерживает автоматическое создание таблиц.

> ПРИМЕЧАНИЕ: [Функциональность автоматической схемы](../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md#Auto-schema) требует наличия [Manticore Buddy](../Installation/Manticore_Buddy.md). Если она не работает, убедитесь, что Buddy установлен.

<!-- request Disable -->
```ini
auto_schema = 0 # disable automatic table creation
```

<!-- request Enable -->
```ini
auto_schema = 1 # enable automatic table creation
```

<!-- end -->

### binlog_flush

<!-- example conf binlog_flush -->
Эта настройка управляет режимом сброса/синхронизации транзакций бинарного лога. Она является необязательной, по умолчанию имеет значение 2 (сброс каждой транзакции, синхронизация каждую секунду).

Директива определяет, как часто бинарный лог будет сбрасываться в ОС и синхронизироваться с диском. Поддерживаются три режима:

*  0, сброс и синхронизация каждую секунду. Это обеспечивает наилучшую производительность, но до 1 секунды зафиксированных транзакций может быть потеряно в случае сбоя сервера или сбоя ОС/оборудования.
*  1, сброс и синхронизация каждой транзакции. Этот режим обеспечивает наихудшую производительность, но гарантирует сохранение данных каждой зафиксированной транзакции.
*  2, сброс каждой транзакции, синхронизация каждую секунду. Этот режим обеспечивает хорошую производительность и гарантирует, что каждая зафиксированная транзакция будет сохранена в случае сбоя сервера. Однако в случае сбоя ОС/оборудования может быть потеряно до 1 секунды зафиксированных транзакций.

Для тех, кто знаком с MySQL и InnoDB, эта директива похожа на `innodb_flush_log_at_trx_commit`. В большинстве случаев гибридный режим 2 по умолчанию обеспечивает хороший баланс скорости и безопасности, с полной защитой данных RT-таблиц от сбоев сервера и некоторой защитой от аппаратных сбоев.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_flush = 1 # ultimate safety, low speed
```
<!-- end -->

### binlog_common

<!-- example conf binlog_common -->
Эта настройка управляет тем, как обрабатываются файлы бинарного лога. Она является необязательной, по умолчанию имеет значение 0 (отдельный файл для каждой таблицы).

Вы можете выбрать один из двух способов управления файлами бинарного лога:

* Отдельный файл для каждой таблицы (по умолчанию, `0`): Каждая таблица сохраняет свои изменения в собственном файле журнала. Такая настройка хороша, если у вас много таблиц, которые обновляются в разное время. Она позволяет обновлять таблицы, не дожидаясь других. Кроме того, если возникнет проблема с файлом журнала одной таблицы, это не затронет другие.
* Один файл для всех таблиц (`1`): Все таблицы используют один и тот же файл бинарного лога. Этот метод упрощает управление файлами, потому что их меньше. Однако это может сохранять файлы дольше, чем необходимо, если одной таблице всё ещё нужно сохранять свои обновления. Эта настройка также может замедлить работу, если многим таблицам нужно обновляться одновременно, потому что все изменения должны ждать записи в один файл.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_common = 1 # use a single binary log file for all tables
```
<!-- end -->

### binlog_max_log_size

<!-- example conf binlog_max_log_size -->
Эта настройка управляет максимальным размером файла бинарного лога. Она является необязательной, по умолчанию имеет значение 256 МБ.

Новый файл бинарного лога будет принудительно открыт, как только текущий файл достигнет этого ограничения по размеру. Это приводит к более детальной гранулярности логов и может обеспечить более эффективное использование диска для бинарного лога при определённых пограничных рабочих нагрузках. Значение 0 указывает, что файл бинарного лога не должен переоткрываться на основе размера.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_max_log_size = 16M
```
<!-- end -->


### binlog_path

<!-- example conf binlog_path -->
Эта настройка определяет путь к файлам бинарного лога (также известного как журнал транзакций). Она является необязательной, по умолчанию имеет значение каталога данных, настроенного во время сборки (например, `/var/lib/manticore/data/binlog.*` в Linux).

Бинарные логи используются для восстановления данных RT-таблиц после сбоев и для обновления атрибутов обычных дисковых индексов, которые в противном случае хранились бы только в оперативной памяти до сброса на диск. При включенном логировании каждая транзакция, зафиксированная (COMMIT) в RT-таблице, записывается в файл журнала. Затем логи автоматически воспроизводятся при запуске после некорректного завершения работы, восстанавливая залогированные изменения.

Директива `binlog_path` указывает расположение файлов бинарных логов. Она должна содержать только путь; `searchd` будет создавать и удалять несколько файлов `binlog.*` в этом каталоге по мере необходимости (включая файлы данных, метаданных, блокировок и т.д.).

Пустое значение отключает бинарное логирование, что повышает производительность, но подвергает данные RT-таблиц риску.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_path = # disable logging
binlog_path = /var/lib/manticore/data # /var/lib/manticore/data/binlog.001 etc will be created
```
<!-- end -->

### boolean_simplify

<!-- example conf boolean_simplify -->
Эта настройка управляет значением по умолчанию для опции поиска [boolean_simplify](../Searching/Options.md#boolean_simplify). Она является необязательной, значение по умолчанию — 1 (включено).

При значении 1 сервер будет автоматически применять [оптимизацию булевых запросов](../Searching/Full_text_matching/Boolean_optimization.md) для повышения производительности запросов. При значении 0 запросы по умолчанию будут выполняться без оптимизации. Это значение по умолчанию можно переопределить для каждого отдельного запроса с помощью соответствующей опции поиска `boolean_simplify`.

<!-- request Example -->
```ini
searchd {
    boolean_simplify = 0  # disable boolean optimization by default
}
```
<!-- end -->

### buddy_path

<!-- example conf buddy_path -->
Эта настройка определяет путь к исполняемому файлу Manticore Buddy. Она является необязательной, значение по умолчанию — путь, заданный при сборке, который различается в разных операционных системах. Обычно изменять эту настройку не требуется. Однако она может быть полезна, если вы хотите запустить Manticore Buddy в режиме отладки, внести изменения в Manticore Buddy или реализовать новый плагин. В последнем случае вы можете клонировать Buddy из репозитория `git clone` https://github.com/manticoresoftware/manticoresearch-buddy, добавить новый плагин в каталог `./plugins/` и выполнить `composer install --prefer-source` для упрощения разработки после перехода в каталог с исходным кодом Buddy.

Чтобы иметь возможность запускать `composer`, на вашей машине должна быть установлена PHP версии 8.2 или выше со следующими расширениями:

```
--enable-dom
--with-libxml
--enable-tokenizer
--enable-xml
--enable-xmlwriter
--enable-xmlreader
--enable-simplexml
--enable-phar
--enable-bcmath
--with-gmp
--enable-debug
--with-mysqli
--enable-mysqlnd
```

Вы также можете выбрать специальную версию `manticore-executor-dev` для Linux amd64, доступную в релизах, например: https://github.com/manticoresoftware/executor/releases/tag/v1.0.13

Если вы выберете этот путь, не забудьте создать символическую ссылку на dev-версию manticore executor в `/usr/bin/php`.

Чтобы отключить Manticore Buddy, установите значение пустым, как показано в примере.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
buddy_path = manticore-executor -n /usr/share/manticore/modules/manticore-buddy/src/main.php # use the default Manticore Buddy in Linux
buddy_path = manticore-executor -n /usr/share/manticore/modules/manticore-buddy/src/main.php --threads=1 # runs Buddy with a single worker
buddy_path = manticore-executor -n /opt/homebrew/share/manticore/modules/manticore-buddy/bin/manticore-buddy/src/main.php # use the default Manticore Buddy in MacOS arm64
buddy_path = manticore-executor -n /Users/username/manticoresearch-buddy/src/main.php # use Manticore Buddy from a non-default location
buddy_path = # disables Manticore Buddy
buddy_path = manticore-executor -n /Users/username/manticoresearch-buddy/src/main.php --skip=manticoresoftware/buddy-plugin-replace # --skip - skips plugins
buddy_path = manticore-executor -n /usr/share/manticore/modules/manticore-buddy/src/main.php --enable-plugin=manticoresoftware/buddy-plugin-show # runs Buddy with only the SHOW plugin
```
<!-- end -->

### client_timeout

<!-- example conf client_timeout -->
Эта настройка определяет максимальное время ожидания между запросами (в секундах или с [специальными суффиксами](../Server_settings/Special_suffixes.md)) при использовании постоянных соединений. Она является необязательной, значение по умолчанию — пять минут.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
client_timeout = 1h
```
<!-- end -->


### collation_libc_locale

<!-- example conf collation_libc_locale -->
Локаль libc сервера. Необязательная, по умолчанию C.

Определяет локаль libc, влияющую на правила сортировки, основанные на libc. Подробности см. в разделе [collations](../Searching/Collations.md).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
collation_libc_locale = fr_FR
```
<!-- end -->


### collation_server

<!-- example conf collation_server -->
Коллация сервера по умолчанию. Необязательная, по умолчанию libc_ci.

Определяет коллацию по умолчанию, используемую для входящих запросов. Коллацию можно переопределить для каждого отдельного запроса. Список доступных коллаций и другие подробности см. в разделе [collations](../Searching/Collations.md).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
collation_server = utf8_ci
```
<!-- end -->


### data_dir

<!-- example conf data_dir -->
При указании эта настройка включает [режим реального времени](../Creating_a_table/Local_tables.md#Online-schema-management-%28RT-mode%29), который является императивным способом управления схемой данных. Значение должно быть путем к каталогу, в котором вы хотите хранить все свои таблицы, бинарные логи и всё остальное, необходимое для корректной работы Manticore Search в этом режиме.
Индексирование [обычных таблиц](../Creating_a_table/Local_tables/Plain_table.md) не допускается, когда указан `data_dir`. Подробнее о различиях между RT-режимом и обычным режимом читайте в [этом разделе](../Read_this_first.md#Real-time-table-vs-plain-table).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
data_dir = /var/lib/manticore
```
<!-- end -->

### attr_autoconv_strict

<!-- example conf attr_autoconv_strict -->
Эта настройка управляет режимом строгой проверки при преобразовании строк в числовые типы во время операций INSERT и REPLACE. Необязательная, по умолчанию 0 (нестрогий режим, обратно совместимый).

При значении 1 (строгий режим) некорректные преобразования строк в числа (например, преобразование пустой строки `''` или нечисловой строки `'a'` в атрибут типа bigint) будут возвращать ошибки вместо тихого преобразования в 0. Это помогает раньше выявлять проблемы с качеством данных при вставке.

При значении 0 (нестрогий режим, по умолчанию) некорректные преобразования будут тихо преобразовываться в 0, сохраняя обратную совместимость со старыми версиями.

Строгий режим проверяет следующие случаи:
* Пустые строки или строки, которые не могут быть преобразованы
* Строки с завершающими нечисловыми символами (например, `'123abc'`)
* Числовые значения, выходящие за пределы диапазона типа (переполнение/потеря значимости)

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
attr_autoconv_strict = 1  # enable strict conversion mode
```
<!-- end -->

### diskchunk_flush_search_timeout

<!-- example conf diskchunk_flush_search_timeout -->
Таймаут для предотвращения автоматического сброса RAM-чанка на диск, если в таблице не выполняются поисковые запросы. Необязательный, по умолчанию 30 секунд.

Время проверки наличия поисковых запросов перед определением необходимости автоматической сброски на диск.
Автоматическая сброска на диск произойдет только если в таблице был хотя бы один поисковый запрос за последние `diskchunk_flush_search_timeout` секунд. Работает совместно с [diskchunk_flush_write_timeout](../Server_settings/Searchd.md#diskchunk_flush_write_timeout). Соответствующая [настройка на уровне таблицы](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#diskchunk_flush_search_timeout) имеет более высокий приоритет и переопределяет этот глобальный параметр по умолчанию, обеспечивая более детальный контроль.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
diskchunk_flush_search_timeout = 120s
```
<!-- end -->

### diskchunk_flush_write_timeout

<!-- example conf diskchunk_flush_write_timeout -->
Время в секундах ожидания без записи перед автоматической сброской RAM-чанка на диск. Необязательный параметр, значение по умолчанию — 1 секунда.

Если в RAM-чанке не происходит запись в течение `diskchunk_flush_write_timeout` секунд, чанк будет сброшен на диск. Работает совместно с [diskchunk_flush_search_timeout](../Server_settings/Searchd.md#diskchunk_flush_search_timeout). Чтобы отключить автоматическую сброску, явно установите `diskchunk_flush_write_timeout = -1` в вашей конфигурации. Соответствующая [настройка на уровне таблицы](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#diskchunk_flush_write_timeout) имеет более высокий приоритет и переопределяет этот глобальный параметр по умолчанию, обеспечивая более детальный контроль.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
diskchunk_flush_write_timeout = 60s
```
<!-- end -->

### docstore_cache_size

<!-- example conf docstore_cache_size -->
Эта настройка определяет максимальный размер блоков документов из хранилища документов, которые хранятся в памяти. Необязательный параметр, значение по умолчанию — 16m (16 мегабайт).

При использовании `stored_fields` блоки документов считываются с диска и распаковываются. Поскольку каждый блок обычно содержит несколько документов, он может быть повторно использован при обработке следующего документа. Для этой цели блок хранится в кэше на уровне сервера. Кэш содержит распакованные блоки.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
docstore_cache_size = 8m
```
<!-- end -->

### engine

<!-- example conf engine -->
Движок хранения атрибутов по умолчанию, используемый при создании таблиц в режиме RT. Может быть `rowwise` (по умолчанию) или `columnar`.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
engine = columnar
```
<!-- end -->


### expansion_limit

<!-- example conf expansion_limit -->
Эта настройка определяет максимальное количество расширенных ключевых слов для одного подстановочного знака. Необязательный параметр, значение по умолчанию — 0 (без ограничений).

При выполнении поиска по подстроке в таблицах, построенных с включенным `dict = keywords`, один подстановочный знак потенциально может привести к тысячам или даже миллионам совпадающих ключевых слов (представьте себе сопоставление `a*` со всем Оксфордским словарем). Эта директива позволяет ограничить влияние таких расширений. Установка `expansion_limit = N` ограничивает расширения не более чем N наиболее часто встречающихся совпадающих ключевых слов (для каждого подстановочного знака в запросе).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_limit = 16
```
<!-- end -->

### expansion_merge_threshold_docs

<!-- example conf expansion_merge_threshold_docs -->
Эта настройка определяет максимальное количество документов в расширенном ключевом слове, которое позволяет объединить все такие ключевые слова вместе. Необязательный параметр, значение по умолчанию — 32.

При выполнении поиска по подстроке в таблицах, построенных с включенным `dict = keywords`, один подстановочный знак потенциально может привести к тысячам или даже миллионам совпадающих ключевых слов. Эта директива позволяет увеличить лимит того, сколько ключевых слов будет объединено вместе для ускорения сопоставления, но использует больше памяти при поиске.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_merge_threshold_docs = 1024
```
<!-- end -->

### expansion_merge_threshold_hits

<!-- example conf expansion_merge_threshold_hits -->
Эта настройка определяет максимальное количество вхождений (хитов) в расширенном ключевом слове, которое позволяет объединить все такие ключевые слова вместе. Необязательный параметр, значение по умолчанию — 256.

При выполнении поиска по подстроке в таблицах, построенных с включенным `dict = keywords`, один подстановочный знак потенциально может привести к тысячам или даже миллионам совпадающих ключевых слов. Эта директива позволяет увеличить лимит того, сколько ключевых слов будет объединено вместе для ускорения сопоставления, но использует больше памяти при поиске.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_merge_threshold_hits = 512
```
<!-- end -->

### expansion_phrase_limit

<!-- example conf expansion_phrase_limit -->
Эта настройка управляет максимальным количеством альтернативных вариантов фразы, генерируемых из-за операторов `OR` внутри операторов `PHRASE`, `PROXIMITY` и `QUORUM`. Необязательный параметр, значение по умолчанию — 1024.

При использовании оператора `|` (OR) внутри оператора, похожего на фразу, общее количество расширенных комбинаций может расти экспоненциально в зависимости от количества указанных альтернатив. Эта настройка помогает предотвратить чрезмерное расширение запроса, ограничивая количество перестановок, рассматриваемых во время обработки запроса.

Если количество сгенерированных вариантов превышает этот лимит, запрос либо:

- завершится с ошибкой (поведение по умолчанию)
- вернет частичные результаты с предупреждением, если включен `expansion_phrase_warning`

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_phrase_limit = 4096
```
<!-- end -->

### expansion_phrase_warning

<!-- example conf expansion_phrase_warning -->
Эта настройка управляет поведением при превышении лимита расширения запроса, определенного `expansion_phrase_limit`.

По умолчанию запрос завершится с сообщением об ошибке. Когда `expansion_phrase_warning` установлен в 1, поиск продолжается с использованием частичного преобразования фразы (вплоть до настроенного лимита), и сервер возвращает пользователю предупреждающее сообщение вместе с набором результатов. Это позволяет запросам, которые слишком сложны для полного расширения, все равно возвращать частичные результаты без полного сбоя.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_phrase_warning = 1
```
<!-- end -->

### grouping_in_utc

Данная настройка определяет, будет ли группировка по времени в API и SQL рассчитываться в локальном часовом поясе или в UTC. Она является необязательной, со значением по умолчанию 0 (что означает 'локальный часовой пояс').

По умолчанию все выражения 'group by time' (такие как группировка по дням, неделям, месяцам и годам в API, а также по дням, месяцам, годам, yearmonth, yearmonthday в SQL) выполняются с использованием локального времени. Например, если у вас есть документы с атрибутами времени `13:00 utc` и `15:00 utc`, при группировке они оба попадут в соответствующие группы в соответствии с вашей настройкой локального часового пояса. Если вы находитесь в `utc`, это будет один день, но если вы находитесь в `utc+10`, то эти документы будут отнесены к разным группам `group by day` (поскольку 13:00 utc в часовом поясе UTC+10 — это 23:00 местного времени, а 15:00 — 01:00 следующего дня). Иногда такое поведение неприемлемо, и желательно сделать группировку по времени независимой от часового пояса. Вы можете запустить сервер с определенной глобальной переменной окружения TZ, но это повлияет не только на группировку, но и на временные метки в логах, что также может быть нежелательно. Включение этой опции (либо в конфигурации, либо с помощью оператора [SET global](../Server_settings/Setting_variables_online.md#SET) в SQL) приведет к тому, что все выражения группировки по времени будут рассчитываться в UTC, оставляя остальные зависящие от времени функции (например, логирование сервера) в локальном часовом поясе TZ.


### timezone

Эта настройка определяет часовой пояс, используемый функциями, связанными с датой/временем. По умолчанию используется локальный часовой пояс, но вы можете указать другой часовой пояс в формате IANA (например, `Europe/Amsterdam`).

Обратите внимание, что эта настройка не влияет на логирование, которое всегда работает в локальном часовом поясе.

Также обратите внимание, что если используется `grouping_in_utc`, функция 'group by time' по-прежнему будет использовать UTC, в то время как другие функции, связанные с датой/временем, будут использовать указанный часовой пояс. В целом, не рекомендуется смешивать `grouping_in_utc` и `timezone`.

Вы можете настроить эту опцию либо в конфигурации, либо с помощью оператора [SET global](../Server_settings/Setting_variables_online.md#SET) в SQL.


### ha_period_karma

<!-- example conf ha_period_karma -->
Эта настройка определяет размер окна статистики зеркал агента в секундах (или [специальных суффиксах](../Server_settings/Special_suffixes.md)). Она является необязательной, со значением по умолчанию 60 секунд.

Для распределенной таблицы с зеркалами агента (подробнее см. [agent](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md)) мастер отслеживает несколько различных счетчиков для каждого зеркала. Эти счетчики затем используются для отказоустойчивости и балансировки (мастер выбирает лучшее зеркало для использования на основе счетчиков). Счетчики накапливаются блоками по `ha_period_karma` секунд.

После начала нового блока мастер может по-прежнему использовать накопленные значения из предыдущего блока, пока новый не заполнится наполовину. В результате любая предыдущая история перестает влиять на выбор зеркала максимум через 1,5 раза от ha_period_karma секунд.

Несмотря на то, что для выбора зеркала используется не более двух блоков, до 15 последних блоков хранятся для целей инструментирования. Эти блоки можно проверить с помощью оператора [SHOW AGENT STATUS](../Node_info_and_management/Node_status.md#SHOW-AGENT-STATUS).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ha_period_karma = 2m
```
<!-- end -->


### ha_ping_interval

<!-- example conf ha_ping_interval -->
Эта настройка задает интервал между пингами зеркал агента в миллисекундах (или [специальных суффиксах](../Server_settings/Special_suffixes.md)). Она является необязательной, со значением по умолчанию 1000 миллисекунд.

Для распределенной таблицы с зеркалами агента (подробнее см. [agent](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md)) мастер отправляет всем зеркалам команду ping в периоды простоя. Это необходимо для отслеживания текущего статуса агента (жив или мертв, сетевая задержка и т.д.). Интервал между такими пингами определяется этой директивой. Чтобы отключить пинги, установите ha_ping_interval в 0.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ha_ping_interval = 3s
```
<!-- end -->


### hostname_lookup

Опция `hostname_lookup` определяет стратегию обновления имен хостов. По умолчанию IP-адреса имен хостов агентов кэшируются при запуске сервера, чтобы избежать чрезмерного обращения к DNS. Однако в некоторых случаях IP может меняться динамически (например, в облачном хостинге), и может быть желательно не кэшировать IP-адреса. Установка этой опции в `request` отключает кэширование и запрашивает DNS для каждого запроса. IP-адреса также можно обновить вручную с помощью команды `FLUSH HOSTNAMES`.

### jobs_queue_size

Настройка jobs_queue_size определяет, сколько "заданий" может одновременно находиться в очереди. По умолчанию ограничения нет.

В большинстве случаев "задание" означает один запрос к одной локальной таблице (обычной таблице или дисковому чанку таблицы реального времени). Например, если у вас есть распределенная таблица, состоящая из 2 локальных таблиц, или таблица реального времени с 2 дисковыми чанками, поисковый запрос к любой из них в основном поместит 2 задания в очередь. Затем пул потоков (размер которого определяется настройкой [threads](../Server_settings/Searchd.md#threads)) будет обрабатывать их. Однако в некоторых случаях, если запрос слишком сложный, может быть создано больше заданий. Изменение этой настройки рекомендуется, когда [max_connections](../Server_settings/Searchd.md#max_connections) и [threads](../Server_settings/Searchd.md#threads) недостаточно для достижения баланса между желаемой производительностью.

### join_batch_size

Соединения таблиц работают путем накопления пакета совпадений, которые являются результатами запроса, выполненного по левой таблице. Затем этот пакет обрабатывается как единый запрос по правой таблице.

Эта опция позволяет настроить размер пакета. Значение по умолчанию — `1000`, а установка этой опции в `0` отключает пакетную обработку.

Увеличение размера пакета может повысить производительность; однако для некоторых запросов это может привести к чрезмерному потреблению памяти.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
join_batch_size = 2000
```
<!-- end -->

### join_cache_size

Каждый запрос, выполняемый на правой таблице, определяется конкретными условиями JOIN ON, которые определяют результирующий набор, извлекаемый из правой таблицы.

Если существует лишь несколько уникальных условий JOIN ON, повторное использование результатов может быть более эффективным, чем многократное выполнение запросов к правой таблице. Чтобы это стало возможным, результирующие наборы сохраняются в кэше.

Эта опция позволяет настроить размер этого кэша. Значение по умолчанию — `20 МБ`, а установка этой опции в 0 отключает кэширование.

Обратите внимание, что каждый поток поддерживает свой собственный кэш, поэтому при оценке общего использования памяти следует учитывать количество потоков, выполняющих запросы.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
join_cache_size = 10M
```
<!-- end -->

### listen_backlog

<!-- example conf listen_backlog -->
Настройка `listen_backlog` определяет длину очереди TCP-подключений (backlog) для входящих соединений. Это особенно актуально для сборок под Windows, которые обрабатывают запросы по одному. Когда очередь соединений достигает своего предела, новые входящие соединения будут отклоняться.
Для сборок, отличных от Windows, значение по умолчанию должно работать нормально, и обычно нет необходимости изменять эту настройку.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
listen_backlog = 20
```
<!-- end -->

### kibana_version_string

<!-- example conf kibana_version_string -->
Строка версии сервера, возвращаемая Kibana или OpenSearch Dashboards. Необязательная — по умолчанию установлено значение `7.6.0`.

Некоторые версии Kibana и OpenSearch Dashboards ожидают, что сервер сообщит определённый номер версии, и могут вести себя по-разному в зависимости от него. Чтобы обойти такие проблемы, вы можете использовать эту настройку, которая заставляет Manticore сообщать пользовательскую версию Kibana или OpenSearch Dashboards.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
kibana_version_string = 1.2.3
```
<!-- end -->

### listen

<!-- example conf listen -->
Эта настройка позволяет указать IP-адрес и порт или путь к Unix-доменному сокету, на которых Manticore будет принимать соединения.

Общий синтаксис для `listen`:

```ini
listen = ( address ":" port | port | path | address ":" port start - port end ) [ ":" protocol [ "_vip" ] [ "_readonly" ] ]
```

Вы можете указать:
* либо IP-адрес (или имя хоста) и номер порта
* либо только номер порта
* либо путь к Unix-сокету (не поддерживается в Windows)
* либо IP-адрес и диапазон портов

Если вы укажете номер порта, но не адрес, `searchd` будет прослушивать все сетевые интерфейсы. Unix-путь идентифицируется начальным слешем. Диапазон портов может быть установлен только для протокола репликации.

Вы также можете указать обработчик протокола (слушатель), который будет использоваться для соединений на этом сокете. Слушатели:

* **Не указан** - Manticore будет принимать соединения на этом порту от:
  - других агентов Manticore (т.е. удалённой распределённой таблицы)
  - клиентов через HTTP и HTTPS
  - [Manticore Buddy](https://manticoresearch.com/blog/manticoresearch-buddy-intro/). **Убедитесь, что у вас есть слушатель такого типа (или слушатель `http`, как упомянуто ниже), чтобы избежать ограничений в функциональности Manticore.**
* `mysql` - протокол MySQL для соединений от клиентов MySQL. Примечание:
  - Сжатый протокол также поддерживается.
  - Если включён [SSL](../Security/SSL.md#SSL), вы можете установить зашифрованное соединение.
* `replication` - протокол репликации, используемый для общения между узлами. Подробнее можно узнать в разделе [репликация](../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md). Вы можете указать несколько слушателей репликации, но все они должны слушать на одном IP; могут различаться только порты. Когда вы определяете слушатель репликации с диапазоном портов (например, `listen = 192.168.0.1:9320-9328:replication`), Manticore не начинает немедленно прослушивать эти порты. Вместо этого он будет брать случайные свободные порты из указанного диапазона только тогда, когда вы начнёте использовать репликацию. Для корректной работы репликации в диапазоне требуется как минимум 2 порта.
* `http` - то же самое, что и **Не указан**. Manticore будет принимать соединения на этом порту от удалённых агентов и клиентов через HTTP и HTTPS.
* `https` - протокол HTTPS. Manticore будет принимать **только** HTTPS-соединения на этом порту. Подробнее можно узнать в разделе [SSL](../Security/SSL.md).
* `sphinx` - устаревший бинарный протокол. Используется для обслуживания соединений от удалённых клиентов [SphinxSE](../Extensions/SphinxSE.md). Некоторые реализации клиентов Sphinx API (пример — Java) требуют явного объявления слушателя.

Добавление суффикса `_vip` к клиентским протоколам (то есть всем, кроме `replication`, например `mysql_vip` или `http_vip` или просто `_vip`) заставляет создавать выделенный поток для соединения, чтобы обойти различные ограничения. Это полезно для обслуживания узла в случае сильной перегрузки, когда сервер в противном случае либо зависнет, либо не позволит подключиться через обычный порт.

Суффикс `_readonly` устанавливает [режим только для чтения](../Security/Read_only.md) для слушателя и ограничивает его приём только запросов на чтение.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
listen = localhost
listen = localhost:5000 # listen for remote agents (binary API) and http/https requests on port 5000 at localhost
listen = 192.168.0.1:5000 # listen for remote agents (binary API) and http/https requests on port 5000 at 192.168.0.1
listen = /var/run/manticore/manticore.s # listen for binary API requests on unix socket
listen = /var/run/manticore/manticore.s:mysql # listen for mysql requests on unix socket
listen = 9312 # listen for remote agents (binary API) and http/https requests on port 9312 on any interface
listen = localhost:9306:mysql # listen for mysql requests on port 9306 at localhost
listen = localhost:9307:mysql_readonly # listen for mysql requests on port 9307 at localhost and accept only read queries
listen = 127.0.0.1:9308:http # listen for http requests as well as connections from remote agents (and binary API) on port 9308 at localhost
listen = 192.168.0.1:9320-9328:replication # listen for replication connections on ports 9320-9328 at 192.168.0.1
listen = 127.0.0.1:9443:https # listen for https requests (not http) on port 9443 at 127.0.0.1
listen = 127.0.0.1:9312:sphinx # listen for legacy Sphinx requests (e.g. from SphinxSE) on port 9312 at 127.0.0.1
```
<!-- end -->

Может быть несколько директив `listen`. `searchd` будет прослушивать клиентские соединения на всех указанных портах и сокетах. Конфигурация по умолчанию, предоставляемая в пакетах Manticore, определяет прослушивание на портах:
* `9308` и `9312` для соединений от удалённых агентов и клиентов, не основанных на MySQL
* и на порту `9306` для MySQL-соединений.

Если вы вообще не укажете `listen` в конфигурации, Manticore будет ожидать соединений на:
* `127.0.0.1:9306` для MySQL-клиентов
* `127.0.0.1:9312` для HTTP/HTTPS и соединений от других узлов Manticore и клиентов, основанных на бинарном API Manticore.

#### Прослушивание на привилегированных портах

По умолчанию Linux не позволит вам заставить Manticore прослушивать порт ниже 1024 (например, `listen = 127.0.0.1:80:http` или `listen = 127.0.0.1:443:https`), если вы не запустите searchd от имени root. Если вы всё же хотите иметь возможность запускать Manticore так, чтобы он прослушивал порты < 1024 под непривилегированным пользователем, рассмотрите один из следующих вариантов (любой из них должен работать):
* Выполните команду `setcap CAP_NET_BIND_SERVICE=+eip /usr/bin/searchd`
* Добавьте `AmbientCapabilities=CAP_NET_BIND_SERVICE` в systemd-юнит Manticore и перезагрузите демон (`systemctl daemon-reload`).

#### Технические детали протокола Sphinx API и TFO
<details>
Устаревший протокол Sphinx имеет 2 фазы: обмен рукопожатием и поток данных. Рукопожатие состоит из пакета в 4 байта от клиента и пакета в 4 байта от демона с единственной целью - клиент определяет, что удаленная сторона является настоящим демоном Sphinx, а демон определяет, что удаленная сторона является настоящим клиентом Sphinx. Основной поток данных довольно прост: пусть обе стороны объявят свои рукопожатия, а противоположная сторона их проверит. Этот обмен короткими пакетами подразумевает использование специального флага `TCP_NODELAY`, который отключает алгоритм Нагла в TCP и объявляет, что TCP-соединение будет выполняться как диалог небольших пакетов.
Однако, строго не определено, кто говорит первым в этом согласовании. Исторически все клиенты, использующие бинарный API, говорят первыми: отправляют рукопожатие, затем читают 4 байта от демона, затем отправляют запрос и читают ответ от демона.
Когда мы улучшали совместимость протокола Sphinx, мы учли следующее:

1. Обычно связь мастер-агент устанавливается от известного клиента к известному хосту на известном порту. Поэтому маловероятно, что конечная точка предоставит неверное рукопожатие. Таким образом, мы можем неявно предположить, что обе стороны действительны и действительно общаются по протоколу Sphinx.
2. Исходя из этого предположения, мы можем "склеить" рукопожатие с реальным запросом и отправить его в одном пакете. Если бэкенд - это устаревший демон Sphinx, он просто прочитает этот склеенный пакет как 4 байта рукопожатия, а затем тело запроса. Поскольку они оба пришли в одном пакете, сокет бэкенда имеет -1 RTT, а буфер фронтенда все еще работает обычным образом, несмотря на этот факт.
3. Продолжая предположение: поскольку пакет "запроса" довольно мал, а рукопожатие еще меньше, давайте отправим оба в начальном TCP-пакете 'SYN', используя современную технику TFO (tcp-fast-open). То есть: мы подключаемся к удаленному узлу со склеенным пакетом рукопожатия + тела. Демон принимает соединение и сразу же имеет и рукопожатие, и тело в буфере сокета, так как они пришли в самом первом TCP-пакете 'SYN'. Это устраняет еще один RTT.
4. Наконец, научим демона принимать это улучшение. Фактически, со стороны приложения это подразумевает НЕ использовать `TCP_NODELAY`. А со стороны системы это подразумевает обеспечение того, что на стороне демона прием TFO активирован, и на стороне клиента отправка TFO также активирована. По умолчанию в современных системах клиентский TFO уже активирован по умолчанию, поэтому вам нужно только настроить серверный TFO, чтобы все работало.

Все эти улучшения без фактического изменения самого протокола позволили нам устранить 1,5 RTT протокола TCP из соединения. Что, если запрос и ответ могут быть размещены в одном TCP-пакете, уменьшает всю сессию бинарного API с 3,5 RTT до 2 RTT - что делает сетевое согласование примерно в 2 раза быстрее.

Итак, все наши улучшения основаны на изначально неопределенном утверждении: "кто говорит первым". Если клиент говорит первым, мы можем применить все эти оптимизации и эффективно обработать подключение + рукопожатие + запрос в одном TFO-пакете. Более того, мы можем посмотреть на начало полученного пакета и определить реальный протокол. Вот почему вы можете подключиться к одному и тому же порту через API/http/https. Если демон должен говорить первым, все эти оптимизации невозможны, и мультипротокол также невозможен. Вот почему у нас есть выделенный порт для MySQL, и мы не объединили его со всеми другими протоколами в один порт. Неожиданно среди всех клиентов один был написан с предположением, что демон должен отправить рукопожатие первым. То есть - нет возможности для всех описанных улучшений. Это плагин SphinxSE для mysql/mariadb. Поэтому специально для этого единственного клиента мы выделили определение протокола `sphinx` для работы наиболее устаревшим способом. А именно: обе стороны активируют `TCP_NODELAY` и обмениваются небольшими пакетами. Демон отправляет свое рукопожатие при подключении, затем клиент отправляет свое, а затем все работает обычным образом. Это не очень оптимально, но просто работает. Если вы используете SphinxSE для подключения к Manticore - вам нужно выделить слушатель с явно указанным протоколом `sphinx`. Для других клиентов - избегайте использования этого слушателя, так как он медленнее. Если вы используете другие устаревшие клиенты Sphinx API - сначала проверьте, могут ли они работать с невыделенным мультипротокольным портом. Для связи мастер-агент использование невыделенного (мультипротокольного) порта и включение клиентского и серверного TFO работает хорошо и определенно сделает работу сетевого бэкенда быстрее, особенно если у вас очень легкие и быстрые запросы.
</details>

### listen_tfo

Эта настройка позволяет использовать флаг TCP_FASTOPEN для всех слушателей. По умолчанию она управляется системой, но может быть явно отключена установкой значения '0'.

Для общего понимания расширения TCP Fast Open, пожалуйста, обратитесь к [Википедии](https://en.wikipedia.org/wiki/TCP_Fast_Open). Вкратце, оно позволяет устранить один TCP-раундтрип при установлении соединения.

На практике использование TFO во многих ситуациях может оптимизировать сетевую эффективность клиент-агент, как если бы использовались [постоянные агенты](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md), но без удержания активных соединений, а также без ограничения на максимальное количество соединений.

В современных ОС поддержка TFO обычно включена на системном уровне, но это лишь "возможность", а не правило. Linux (как самый прогрессивный) поддерживает его с 2011 года, начиная с ядер 3.7 (для серверной стороны). Windows поддерживает его с некоторых сборок Windows 10. Другие операционные системы (FreeBSD, MacOS) также в игре.

Для сервера на Linux система проверяет переменную `/proc/sys/net/ipv4/tcp_fastopen` и ведет себя в соответствии с ней. Бит 0 управляет клиентской стороной, бит 1 управляет слушателями. По умолчанию система имеет этот параметр установленным в 1, т.е. клиенты включены, слушатели отключены.

### log

<!-- example conf log -->
Настройка log указывает имя файла журнала, в который будут записываться все события времени выполнения `searchd`. Если не указано, имя по умолчанию - 'searchd.log'.

В качестве альтернативы вы можете использовать 'syslog' в качестве имени файла. В этом случае события будут отправляться демону syslog. Чтобы использовать опцию syslog, необходимо сконфигурировать Manticore с опцией `-–with-syslog` во время сборки.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
log = /var/log/searchd.log
```
<!-- end -->


### max_batch_queries

<!-- example conf max_batch_queries -->
Ограничивает количество запросов в пакете. Необязательный параметр, по умолчанию равен 32.

Заставляет searchd выполнять проверку корректности количества запросов, отправленных в одном пакете при использовании [мультизапросов](../Searching/Multi-queries.md). Установите значение 0, чтобы пропустить проверку.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_batch_queries = 256
```
<!-- end -->

### max_connections

<!-- example max_connections -->
Максимальное количество одновременных клиентских подключений. По умолчанию не ограничено. Обычно это заметно только при использовании любого вида постоянных соединений, таких как сессии cli mysql или постоянные удаленные соединения с удаленных распределенных таблиц. При превышении лимита вы все равно можете подключиться к серверу, используя [VIP-соединение](../Connecting_to_the_server/MySQL_protocol.md#VIP-connection). VIP-соединения не учитываются в лимите.

<!-- request Example -->
```ini
max_connections = 10
```

<!-- end -->

### max_threads_per_query

<!-- example max_threads_per_query -->
Глобальное для экземпляра ограничение количества потоков, которые может использовать одна операция. По умолчанию соответствующие операции могут занимать все ядра процессора, не оставляя места для других операций. Например, `call pq` для достаточно большой перколяционной таблицы может использовать все потоки в течение десятков секунд. Установка `max_threads_per_query` на, скажем, половину от [threads](../Server_settings/Searchd.md#threads) гарантирует, что вы сможете запустить пару таких операций `call pq` параллельно.

Вы также можете установить этот параметр как переменную сессии или глобальную переменную во время выполнения.

Кроме того, вы можете управлять поведением для каждого отдельного запроса с помощью опции [threads OPTION](../Searching/Options.md#threads).

<!-- intro -->
##### Пример:
<!-- request Example -->

```ini
max_threads_per_query = 4
```

<!-- end -->

### max_filters

<!-- example conf max_filters -->
Максимально допустимое количество фильтров на запрос. Этот параметр используется только для внутренних проверок корректности и не влияет напрямую на использование оперативной памяти или производительность. Необязательный параметр, по умолчанию равен 256.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_filters = 1024
```
<!-- end -->


### max_filter_values

<!-- example conf max_filter_values -->
Максимально допустимое количество значений на фильтр. Этот параметр используется только для внутренних проверок корректности и не влияет напрямую на использование оперативной памяти или производительность. Необязательный параметр, по умолчанию равен 4096.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_filter_values = 16384
```
<!-- end -->


### max_open_files

<!-- example conf max_open_files -->
Максимальное количество файлов, которое серверу разрешено открывать, называется "мягким лимитом". Обратите внимание, что обслуживание больших фрагментированных таблиц реального времени может потребовать установки высокого значения этого лимита, так как каждый дисковый чанк может занимать дюжину или более файлов. Например, таблица реального времени с 1000 чанков может потребовать одновременного открытия тысяч файлов. Если вы столкнулись с ошибкой 'Too many open files' в логах, попробуйте настроить эту опцию, так как это может помочь решить проблему.

Существует также "жесткий лимит", который не может быть превышен с помощью этой опции. Этот лимит определяется системой и может быть изменен в файле `/etc/security/limits.conf` в Linux. В других операционных системах могут быть другие подходы, поэтому обратитесь к вашим руководствам для получения дополнительной информации.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_open_files = 10000
```
<!-- end -->

<!-- example conf max_open_files max -->
Помимо прямых числовых значений, вы можете использовать волшебное слово 'max', чтобы установить лимит равным доступному текущему жесткому лимиту.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_open_files = max
```
<!-- end -->


### max_packet_size

<!-- example conf max_packet_size -->
Максимально допустимый размер сетевого пакета. Этот параметр ограничивает как пакеты запросов от клиентов, так и пакеты ответов от удаленных агентов в распределенной среде. Используется только для внутренних проверок корректности, не влияет напрямую на использование оперативной памяти или производительность. Необязательный параметр, по умолчанию равен 128M.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_packet_size = 32M
```
<!-- end -->


### mysql_version_string

<!-- example conf mysql_version_string -->
Строка версии сервера, возвращаемая по протоколу MySQL. Необязательный параметр, по умолчанию пустая (возвращает версию Manticore).

Некоторые привередливые клиентские библиотеки MySQL зависят от определенного формата номера версии, используемого MySQL, и более того, иногда выбирают другой путь выполнения на основе сообщаемого номера версии (а не указанных флагов возможностей). Например, Python MySQLdb 1.2.2 выбрасывает исключение, когда номер версии не в формате X.Y.ZZ; MySQL .NET connector 6.3.x внутренне завершается ошибкой на номерах версий 1.x в сочетании с определенной комбинацией флагов и т.д. Чтобы обойти это, вы можете использовать директиву `mysql_version_string` и заставить `searchd` сообщать другую версию клиентам, подключающимся по протоколу MySQL. (По умолчанию он сообщает свою собственную версию.)


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
mysql_version_string = 5.0.37
```
<!-- end -->


### net_workers

Количество сетевых потоков, по умолчанию 1.

Этот параметр полезен при чрезвычайно высокой частоте запросов, когда одного потока недостаточно для управления всеми входящими запросами.


### net_wait_tm

Управляет интервалом активного цикла сетевого потока. По умолчанию -1, может быть установлено в -1, 0 или положительное целое число.

В случаях, когда сервер сконфигурирован как чистый мастер и просто маршрутизирует запросы агентам, важно обрабатывать запросы без задержек и не позволять сетевому потоку спать. Для этого существует активный цикл. После входящего запроса сетевой поток использует опрос CPU в течение `10 * net_wait_tm` миллисекунд, если `net_wait_tm` является положительным числом, или опрашивает только с помощью CPU, если `net_wait_tm` равен `0`. Также активный цикл может быть отключен с помощью `net_wait_tm = -1` - в этом случае поллер устанавливает таймаут на фактическое время ожидания агентов при системном вызове опроса.

> **ВНИМАНИЕ:** Активный цикл ЦП фактически нагружает ядро процессора, поэтому установка этого значения на любое значение, отличное от значения по умолчанию, приведет к заметному использованию ЦП даже на простаивающем сервере.


### net_throttle_accept

Определяет, сколько клиентов принимается на каждой итерации сетевого цикла. По умолчанию 0 (без ограничений), что подходит для большинства пользователей. Это опция тонкой настройки для управления пропускной способностью сетевого цикла в сценариях с высокой нагрузкой.


### net_throttle_action

Определяет, сколько запросов обрабатывается на каждой итерации сетевого цикла. По умолчанию 0 (без ограничений), что подходит для большинства пользователей. Это опция тонкой настройки для управления пропускной способностью сетевого цикла в сценариях с высокой нагрузкой.

### network_timeout

<!-- example conf network_timeout -->
Таймаут чтения/записи сетевого клиентского запроса в секундах (или с [специальными суффиксами](../Server_settings/Special_suffixes.md)). Необязательный параметр, по умолчанию 5 секунд. `searchd` принудительно закроет клиентское соединение, которое не смогло отправить запрос или прочитать результат в течение этого таймаута.

Также обратите внимание на параметр [reset_network_timeout_on_packet](../Server_settings/Searchd.md#reset_network_timeout_on_packet). Этот параметр изменяет поведение `network_timeout` с применения ко всему `запросу` или `результату` на применение к отдельным пакетам. Обычно запрос/результат помещается в один или два пакета. Однако в случаях, когда требуется большой объем данных, этот параметр может оказаться бесценным для поддержания активных операций.

<!-- request Example -->

```ini
network_timeout = 10s
```
<!-- end -->

### node_address

<!-- example conf node_address -->
Эта настройка позволяет указать сетевой адрес узла. По умолчанию он устанавливается на адрес репликации [listen](../Server_settings/Searchd.md#listen). Это верно в большинстве случаев; однако бывают ситуации, когда его необходимо указать вручную:

* Узел за брандмауэром
* Включен трансляция сетевых адресов (NAT)
* Развертывания в контейнерах, таких как Docker или облачные развертывания
* Кластеры с узлами более чем в одном регионе


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
node_address = 10.101.0.10
```
<!-- end -->

### not_terms_only_allowed

<!-- example conf not_terms_only_allowed -->
Эта настройка определяет, разрешать ли запросы, содержащие только оператор полнотекстового поиска [отрицания](../Searching/Full_text_matching/Operators.md#Negation-operator). Необязательный параметр, по умолчанию 0 (запросы, содержащие только оператор NOT, завершаются ошибкой).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
not_terms_only_allowed = 1
```
<!-- end -->

### optimize_cutoff

<!-- example conf optimize_cutoff -->
Устанавливает порог уплотнения таблицы по умолчанию. Подробнее читайте здесь - [Количество оптимизированных дисковых чанков](../Securing_and_compacting_a_table/Compacting_a_table.md#Number-of-optimized-disk-chunks). Эта настройка может быть переопределена с помощью опции для каждого запроса [cutoff](../Securing_and_compacting_a_table/Compacting_a_table.md#Number-of-optimized-disk-chunks). Её также можно изменить динамически с помощью [SET GLOBAL](../Server_settings/Setting_variables_online.md#SET).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
optimize_cutoff = 4
```
<!-- end -->

### persistent_connections_limit

<!-- example conf persistent_connections_limit -->
Эта настройка определяет максимальное количество одновременных постоянных соединений с удаленными [постоянными агентами](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md). Каждый раз при подключении агента, определенного в `agent_persistent`, мы пытаемся повторно использовать существующее соединение (если оно есть) или подключиться и сохранить соединение для будущего использования. Однако в некоторых случаях имеет смысл ограничить количество таких постоянных соединений. Эта директива определяет лимит. Она влияет на количество соединений с хостом каждого агента во всех распределенных таблицах.

Разумно установить значение равным или меньшим, чем опция [max_connections](../Server_settings/Searchd.md#max_connections) в конфигурации агента.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
persistent_connections_limit = 29 # assume that each host of agents has max_connections = 30 (or 29).
```
<!-- end -->


### pid_file

<!-- example conf pid_file -->
pid_file — это обязательная опция конфигурации в Manticore Search, которая указывает путь к файлу, в котором хранится идентификатор процесса (PID) сервера `searchd`.

Файл идентификатора процесса searchd создается заново и блокируется при запуске и содержит PID главного серверного процесса, пока сервер работает. Он удаляется при завершении работы сервера.
Цель этого файла — позволить Manticore выполнять различные внутренние задачи, такие как проверка наличия уже запущенного экземпляра `searchd`, остановка `searchd` и уведомление его о необходимости ротации таблиц. Этот файл также может использоваться внешними скриптами автоматизации.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
pid_file = /run/manticore/searchd.pid
```
<!-- end -->


### predicted_time_costs

<!-- example conf predicted_time_costs -->
Затраты для модели предсказания времени выполнения запроса, в наносекундах. Необязательный параметр, по умолчанию `doc=64, hit=48, skip=2048, match=64`.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
predicted_time_costs = doc=128, hit=96, skip=4096, match=128
```
<!-- end -->

<!-- example conf predicted_time_costs 1 -->
Прерывание запросов до завершения на основе времени их выполнения (с настройкой максимального времени запроса) — это хорошая защитная сетка, но она имеет врожденный недостаток: недетерминированные (нестабильные) результаты. То есть, если вы повторите один и тот же (сложный) поисковый запрос с ограничением по времени несколько раз, ограничение по времени будет срабатывать на разных этапах, и вы получите *разные* наборы результатов.

<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
SELECT … OPTION max_query_time
```
<!-- request API -->

```api
SetMaxQueryTime()
```
<!-- end -->

Существует опция [SELECT … OPTION max_predicted_time](../Searching/Options.md#max_predicted_time), которая позволяет ограничить время выполнения запроса *и* получать стабильные, повторяемые результаты. Вместо регулярной проверки фактического текущего времени во время выполнения запроса, что является недетерминированным, она предсказывает текущее время выполнения с помощью простой линейной модели:

```ini
predicted_time =
    doc_cost * processed_documents +
    hit_cost * processed_hits +
    skip_cost * skiplist_jumps +
    match_cost * found_matches
```

Затем запрос прерывается досрочно, когда `predicted_time` достигает заданного лимита.

Конечно, это не является жестким ограничением фактически затраченного времени (однако, это жесткое ограничение на объем *обрабатываемой* работы), и простая линейная модель никоим образом не является идеально точной. Поэтому фактическое время *может* быть как меньше, так и больше целевого ограничения. Однако, погрешности вполне приемлемы: например, в наших экспериментах с целевым ограничением в 100 мсек, большинство тестовых запросов попадало в диапазон от 95 до 105 мсек, и *все* запросы находились в диапазоне от 80 до 120 мсек. Кроме того, как приятный побочный эффект, использование смоделированного времени запроса вместо измерения фактического времени выполнения также приводит к несколько меньшему количеству вызовов gettimeofday().

Ни один сервер не идентичен другому по производительности и модели, поэтому директива `predicted_time_costs` позволяет вам настроить коэффициенты для описанной выше модели. Для удобства они являются целыми числами, измеряемыми в наносекундах. (Ограничение в max_predicted_time измеряется в миллисекундах, и необходимость указывать значения затрат как 0.000128 мс вместо 128 нс несколько более подвержена ошибкам.) Не обязательно указывать все четыре коэффициента сразу, так как пропущенные примут значения по умолчанию. Однако мы настоятельно рекомендуем указывать их все для удобочитаемости.


### preopen_tables

<!-- example conf preopen_tables -->
Директива конфигурации preopen_tables указывает, следует ли принудительно предварительно открывать все таблицы при запуске. Значение по умолчанию равно 1, что означает, что все таблицы будут предварительно открыты независимо от настройки для каждой отдельной таблицы [preopen](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Other-performance-related-settings). Если установлено значение 0, настройки для отдельных таблиц могут вступить в силу, и по умолчанию они будут равны 0.

Предварительное открытие таблиц может предотвратить состояние гонки между поисковыми запросами и ротациями, которое иногда может приводить к сбоям запросов. Однако это также использует больше файловых дескрипторов. В большинстве сценариев рекомендуется предварительно открывать таблицы.

Вот пример конфигурации:

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
preopen_tables = 1
```
<!-- end -->

### pseudo_sharding

<!-- example conf pseudo_sharding -->
Опция конфигурации pseudo_sharding включает распараллеливание поисковых запросов к локальным обычным (plain) и реального времени (real-time) таблицам, независимо от того, запрашиваются ли они напрямую или через распределенную таблицу. Эта функция будет автоматически распараллеливать запросы на количество потоков, указанное в `searchd.threads`.

Обратите внимание, что если ваши рабочие потоки уже заняты, потому что у вас:
* высокая параллельность запросов
* физическое шардирование любого вида:
  - распределенная таблица из нескольких обычных/реального времени таблиц
  - таблица реального времени, состоящая из слишком большого количества дисковых чанков

то включение pseudo_sharding может не дать никаких преимуществ и даже привести к небольшому снижению пропускной способности. Если вы отдаете приоритет более высокой пропускной способности над меньшей задержкой, рекомендуется отключить эту опцию.

Включено по умолчанию.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
pseudo_sharding = 0
```
<!-- end -->


### replication_connect_timeout

Директива `replication_connect_timeout` определяет таймаут для подключения к удаленному узлу. По умолчанию значение предполагается в миллисекундах, но оно может иметь [другой суффикс](../Server_settings/Special_suffixes.md). Значение по умолчанию — 1000 (1 секунда).

При подключении к удаленному узлу Manticore будет ждать не более этого времени для успешного завершения соединения. Если таймаут достигнут, но соединение не установлено, и включены `retries`, будет инициирована повторная попытка.


### replication_query_timeout

`replication_query_timeout` устанавливает время, которое searchd будет ждать завершения запроса удаленным узлом. Значение по умолчанию — 3000 миллисекунд (3 секунды), но может быть `суффиксировано` для указания другой единицы времени.

После установления соединения Manticore будет ждать не более `replication_query_timeout` завершения работы удаленного узла. Обратите внимание, что этот таймаут отделен от `replication_connect_timeout`, и общая возможная задержка, вызванная удаленным узлом, будет суммой обоих значений.


### replication_retry_count

Эта настройка представляет собой целое число, указывающее, сколько раз Manticore попытается подключиться и выполнить запрос к удаленному узлу во время репликации, прежде чем сообщить о фатальной ошибке запроса. Значение по умолчанию — 3.


### replication_retry_delay

Эта настройка представляет собой целое число в миллисекундах (или с [special_suffixes](../Server_settings/Special_suffixes.md)), указывающее задержку перед повторной попыткой Manticore выполнить запрос к удаленному узлу в случае сбоя во время репликации. Это значение актуально только при указании ненулевого значения. Значение по умолчанию — 500.

### qcache_max_bytes

<!-- example conf qcache_max_bytes -->
Эта конфигурация устанавливает максимальный объем оперативной памяти, выделяемой для кэшированных наборов результатов, в байтах. Значение по умолчанию — 16777216, что эквивалентно 16 мегабайтам. Если значение установлено в 0, кэш запросов отключен. Для получения дополнительной информации о кэше запросов обратитесь к разделу [query cache](../Searching/Query_cache.md).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
qcache_max_bytes = 16777216
```
<!-- end -->


### qcache_thresh_msec

Целое число, в миллисекундах. Минимальный порог фактического времени для кэширования результата запроса. По умолчанию 3000, или 3 секунды. 0 означает кэшировать всё. Подробности см. в разделе [query cache](../Searching/Query_cache.md). Это значение также может быть выражено с помощью временных [special_suffixes](../Server_settings/Special_suffixes.md), но используйте это с осторожностью и не путайте с самим названием значения, содержащим '_msec'.


### qcache_ttl_sec

Целое число, в секундах. Срок действия кэшированного набора результатов. По умолчанию 60, или 1 минута. Минимально возможное значение — 1 секунда. Подробности см. в разделе [query cache](../Searching/Query_cache.md). Это значение также может быть выражено с помощью временных [special_suffixes](../Server_settings/Special_suffixes.md), но используйте это с осторожностью и не путайте с самим названием значения, содержащим '_sec'.


### query_log_format

<!-- example conf query_log_format -->
Формат журнала запросов. Необязательный параметр, допустимые значения: `plain` и `sphinxql`, по умолчанию `sphinxql`.

Режим `sphinxql` логирует корректные SQL-запросы. Режим `plain` логирует запросы в формате обычного текста (в основном подходит для чисто полнотекстовых случаев использования). Эта директива позволяет переключаться между двумя форматами при запуске поискового сервера. Формат лога также можно изменить на лету с помощью синтаксиса `SET GLOBAL query_log_format=sphinxql`. Подробнее см. в разделе [Логирование запросов](../Logging/Query_logging.md).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
query_log_format = sphinxql
```
<!-- end -->

### query_log_min_msec

Лимит (в миллисекундах), который предотвращает запись запроса в лог запросов. Необязательный параметр, значение по умолчанию — 0 (все запросы записываются в лог запросов). Эта директива указывает, что в лог будут записываться только запросы, время выполнения которых превышает указанный лимит (это значение также может быть выражено с помощью [специальных суффиксов времени](../Server_settings/Special_suffixes.md), но используйте это с осторожностью и не путайте с названием самого значения, содержащим `_msec`).

### query_log

<!-- example conf query_log -->
Имя файла лога запросов. Необязательный параметр, значение по умолчанию — пустое (не логировать запросы). Все поисковые запросы (такие как SELECT ..., но не INSERT/REPLACE/UPDATE) будут записываться в этот файл. Формат описан в разделе [Логирование запросов](../Logging/Query_logging.md). В случае формата 'plain' можно использовать 'syslog' в качестве пути к файлу лога. В этом случае все поисковые запросы будут отправляться демону syslog с приоритетом `LOG_INFO`, с префиксом '[query]' вместо временной метки. Для использования опции syslog Manticore должен быть сконфигурирован с флагом `-–with-syslog` при сборке.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
query_log = /var/log/query.log
```
<!-- end -->


### query_log_mode

<!-- example conf query_log_mode -->
Директива query_log_mode позволяет установить другие права доступа для файлов логов searchd и запросов. По умолчанию эти файлы логов создаются с правами 600, что означает, что только пользователь, под которым работает сервер, и пользователи root могут читать файлы логов.
Эта директива может быть полезна, если вы хотите разрешить другим пользователям читать файлы логов, например, решениям мониторинга, работающим под непривилегированными пользователями.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
query_log_mode  = 666
```
<!-- end -->

### read_buffer_docs

<!-- example conf read_buffer_docs -->
Директива read_buffer_docs управляет размером буфера чтения на ключевое слово для списков документов. Для каждого вхождения ключевого слова в каждом поисковом запросе есть два связанных буфера чтения: один для списка документов и один для списка хитов. Эта настройка позволяет управлять размером буфера списка документов.

Больший размер буфера может увеличить использование оперативной памяти на запрос, но возможно уменьшит время ввода-вывода. Имеет смысл устанавливать большие значения для медленных хранилищ, но для хранилищ с высокой производительностью IOPS эксперименты следует проводить в области низких значений.

Значение по умолчанию — 256K, минимальное значение — 8K. Вы также можете установить [read_buffer_docs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#read_buffer_docs) для каждой таблицы отдельно, что переопределит любые настройки на уровне конфигурации сервера.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
read_buffer_docs = 128K
```
<!-- end -->


### read_buffer_hits

<!-- example conf read_buffer_hits -->
Директива read_buffer_hits задает размер буфера чтения на ключевое слово для списков хитов в поисковых запросах. По умолчанию размер составляет 256K, минимальное значение — 8K. Для каждого вхождения ключевого слова в поисковом запросе есть два связанных буфера чтения: один для списка документов и один для списка хитов. Увеличение размера буфера может увеличить использование оперативной памяти на запрос, но уменьшить время ввода-вывода. Для медленных хранилищ имеет смысл использовать большие размеры буферов, в то время как для хранилищ с высокой производительностью IOPS эксперименты следует проводить в области низких значений.

Эту настройку также можно указать для каждой таблицы отдельно с помощью опции read_buffer_hits в [read_buffer_hits](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#read_buffer_hits), что переопределит настройку на уровне сервера.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
read_buffer_hits = 128K
```
<!-- end -->

### read_unhinted

<!-- example conf read_unhinted -->
Размер чтения без подсказки (unhinted). Необязательный параметр, значение по умолчанию — 32K, минимальное — 1K.

При выполнении запроса некоторые операции чтения заранее точно знают, сколько данных нужно прочитать, но некоторые в настоящее время не знают. Наиболее заметно, что размер списка хитов в настоящее время неизвестен заранее. Эта настройка позволяет контролировать, сколько данных читать в таких случаях. Она влияет на время ввода-вывода списка хитов, уменьшая его для списков, размер которых превышает размер чтения без подсказки, но увеличивая для меньших списков. Она **не** влияет на использование оперативной памяти, потому что буфер чтения уже будет выделен. Поэтому она не должна быть больше, чем read_buffer.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
read_unhinted = 32K
```
<!-- end -->

### reset_network_timeout_on_packet

<!-- example conf reset_network_timeout_on_packet -->
Уточняет поведение сетевых таймаутов (таких как `network_timeout` и `agent_query_timeout`).

При значении 0 таймауты ограничивают максимальное время на отправку всего запроса/запроса.
При значении 1 (по умолчанию) таймауты ограничивают максимальное время между сетевыми активностями.

При репликации узлу может потребоваться отправить большой файл (например, 100 ГБ) другому узлу. Предположим, сеть может передавать данные со скоростью 1 ГБ/с, пакетами по 4-5 МБ каждый. Для передачи всего файла потребуется 100 секунд. Таймаут по умолчанию в 5 секунд позволит передать только 5 ГБ до разрыва соединения. Увеличение таймаута может быть обходным решением, но оно не масштабируется (например, следующий файл может быть 150 ГБ, что снова приведет к сбою). Однако при значении `reset_network_timeout_on_packet` по умолчанию, равном 1, таймаут применяется не ко всей передаче, а к отдельным пакетам. Пока передача продолжается (и данные фактически принимаются по сети в течение периода таймаута), соединение остается активным. Если передача зависнет, так что между пакетами произойдет таймаут, соединение будет разорвано.

Обратите внимание, что при настройке распределённой таблицы каждый узел — и мастер, и агенты — должен быть настроен. На стороне мастера влияет параметр `agent_query_timeout`; на агентах актуален `network_timeout`.

<!-- intro -->

##### Пример:

<!-- request Example -->

```ini
reset_network_timeout_on_packet = 0
```

<!-- end -->


### rt_flush_period

<!-- example conf rt_flush_period -->
Период проверки сброса RAM-чанков RT-таблиц, в секундах (или [специальные суффиксы](../Server_settings/Special_suffixes.md)). Необязательный, по умолчанию 10 часов.

Активно обновляемые RT-таблицы, которые полностью помещаются в RAM-чанках, всё равно могут приводить к постоянно растущим бинарным логам, влияя на использование диска и время восстановления после сбоя. С этой директивой сервер поиска выполняет периодические проверки сброса, и подходящие RAM-чанки могут быть сохранены, что позволяет выполнить последующую очистку бинарных логов. Подробнее см. в [Бинарное логирование](../Logging/Binary_logging.md).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
rt_flush_period = 3600 # 1 hour
```
<!-- end -->


### rt_merge_iops

<!-- example conf rt_merge_iops -->
Максимальное количество операций ввода-вывода (в секунду), которые разрешено запускать потоку слияния RT-чанков. Необязательный, по умолчанию 0 (без ограничения).

Эта директива позволяет снизить влияние операций ввода-вывода, возникающих из-за операторов `OPTIMIZE`. Гарантируется, что все операции оптимизации RT не будут генерировать больше IOPS (операций ввода-вывода в секунду), чем установленный лимит. Ограничение rt_merge_iops может уменьшить снижение производительности поиска, вызванное слиянием.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
rt_merge_iops = 40
```
<!-- end -->

### rt_merge_maxiosize

<!-- example conf rt_merge_maxiosize -->
Максимальный размер операции ввода-вывода, которую разрешено запускать потоку слияния RT-чанков. Необязательный, по умолчанию 0 (без ограничения).

Эта директива позволяет снизить влияние операций ввода-вывода, возникающих из-за операторов `OPTIMIZE`. Операции ввода-вывода, превышающие этот лимит, будут разбиты на две или более операций, которые затем будут учитываться как отдельные операции ввода-вывода относительно ограничения [rt_merge_iops](../Server_settings/Searchd.md#rt_merge_iops). Таким образом, гарантируется, что все операции оптимизации не будут генерировать более (rt_merge_iops * rt_merge_maxiosize) байт дискового ввода-вывода в секунду.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
rt_merge_maxiosize = 1M
```
<!-- end -->


### seamless_rotate

<!-- example conf seamless_rotate -->
Предотвращает простои `searchd` при ротации таблиц с большими объёмами данных для предварительного кэширования. Необязательный, по умолчанию 1 (включить бесшовную ротацию). В системах Windows бесшовная ротация по умолчанию отключена.

Таблицы могут содержать некоторые данные, которые необходимо предварительно загрузить в оперативную память. На данный момент файлы `.spa`, `.spb`, `.spi` и `.spm` полностью предзагружаются (они содержат данные атрибутов, данные blob-атрибутов, таблицу ключевых слов и карту удалённых строк соответственно.) Без бесшовной ротации попытка ротации таблицы использует как можно меньше оперативной памяти и работает следующим образом:

1. Новые запросы временно отклоняются (с кодом ошибки "повторить");
2. `searchd` ожидает завершения всех текущих выполняемых запросов;
3. Старая таблица освобождается, и её файлы переименовываются;
4. Файлы новой таблицы переименовываются, и выделяется необходимая оперативная память;
5. Данные атрибутов и словаря новой таблицы предварительно загружаются в оперативную память;
6. `searchd` возобновляет обслуживание запросов из новой таблицы.

Однако, если данных атрибутов или словаря много, то этап предварительной загрузки может занять заметное время — до нескольких минут в случае загрузки файлов объёмом 1–5+ ГБ.

При включённой бесшовной ротации процесс работает следующим образом:

1. Выделяется хранилище оперативной памяти для новой таблицы;
2. Данные атрибутов и словаря новой таблицы асинхронно предзагружаются в оперативную память;
3. При успехе старая таблица освобождается, и файлы обеих таблиц переименовываются;
4. При неудаче новая таблица освобождается;
5. В любой момент запросы обслуживаются либо из старой, либо из новой копии таблицы.

Бесшовная ротация достигается за счёт более высокого пикового использования оперативной памяти во время ротации (поскольку и старая, и новая копии данных `.spa/.spb/.spi/.spm` должны находиться в оперативной памяти во время предзагрузки новой копии). Среднее использование остаётся прежним.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
seamless_rotate = 1
```
<!-- end -->

### secondary_index_block_cache
<!-- example conf secondary_index_block_cache -->

Эта опция определяет размер кэша блоков, используемого вторичными индексами. Необязательная, по умолчанию 8 МБ. Когда вторичные индексы работают с фильтрами, содержащими много значений (например, фильтры IN()), они читают и обрабатывают метаданные блоков для этих значений.
В объединённых запросах этот процесс повторяется для каждого пакета строк из левой таблицы, и каждый пакет может перечитывать одни и те же метаданные в рамках одного объединённого запроса. Это может серьёзно повлиять на производительность. Кэш блоков метаданных сохраняет эти блоки в памяти, чтобы
они могли быть повторно использованы последующими пакетами.

Кэш используется только в объединённых запросах и не влияет на необъединённые запросы. Обратите внимание, что ограничение размера кэша применяется для каждого атрибута и каждого вторичного индекса. Каждый атрибут внутри каждого дискового чанка работает в рамках этого ограничения. В худшем случае общее использование памяти
можно оценить, умножив лимит на количество дисковых чанков и количество атрибутов, используемых в объединённых запросах.

Установка `secondary_index_block_cache = 0` отключает кэш.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
secondary_index_block_cache = 16M
```

<!-- end -->

### secondary_indexes
<!-- example conf secondary_indexes -->

Эта опция включает/отключает использование вторичных индексов для поисковых запросов. Необязательная, по умолчанию 1 (включено). Обратите внимание, что для индексации её включать не нужно, так как она всегда включена, если установлена [Manticore Columnar Library](https://github.com/manticoresoftware/columnar). Последняя также требуется для использования индексов при поиске. Доступны три режима:

* `0`: Отключить использование вторичных индексов при поиске. Их можно включить для отдельных запросов с помощью [подсказок анализатора](../Searching/Options.md#Query-optimizer-hints)
* `1`: Включить использование вторичных индексов при поиске. Их можно отключить для отдельных запросов с помощью [подсказок анализатора](../Searching/Options.md#Query-optimizer-hints)
* `force`: То же, что и включение, но любые ошибки во время загрузки вторичных индексов будут сообщены, и весь индекс не будет загружен в демон.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
secondary_indexes = 1
```

<!-- end -->

### server_id

<!-- example conf server_id -->
Целое число, которое служит идентификатором сервера, используемым в качестве сида для генерации уникального короткого UUID для узлов, являющихся частью репликационного кластера. server_id должен быть уникальным среди узлов кластера и находиться в диапазоне от 0 до 127. Если server_id не задан, он вычисляется как хэш MAC-адреса и пути к PID-файлу, или случайное число будет использоваться в качестве сида для короткого UUID.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
server_id = 1
```
<!-- end -->


### shutdown_timeout

<!-- example conf shutdown_timeout -->
Время ожидания `searchd --stopwait` в секундах (или [специальные суффиксы](../Server_settings/Special_suffixes.md)). Опционально, по умолчанию 60 секунд.

Когда вы запускаете `searchd --stopwait`, ваш сервер должен выполнить некоторые действия перед остановкой, такие как завершение запросов, сброс RT RAM чанков, сброс атрибутов и обновление binlog. Эти задачи требуют некоторого времени. `searchd --stopwait` будет ждать до `shutdown_time` секунд, пока сервер завершит свою работу. Подходящее время зависит от размера вашей таблицы и нагрузки.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
shutdown_timeout = 3m # wait for up to 3 minutes
```
<!-- end -->


### shutdown_token

SHA1 хэш пароля, необходимого для вызова команды 'shutdown' из VIP соединения Manticore SQL. Без него [debug](../Reporting_bugs.md#DEBUG) подкоманда 'shutdown' никогда не приведет к остановке сервера. Обратите внимание, что такое простое хэширование не следует считать надежной защитой, поскольку мы не используем хэш с солью или какую-либо современную хэш-функцию. Это предназначено как простая мера предосторожности для служебных демонов в локальной сети.

### skiplist_cache_size

<!-- example conf skiplist_cache_size -->
Эта настройка задает максимальный размер кэша в оперативной памяти для распакованных списков пропуска (skiplists). Необязательный параметр, по умолчанию 64M.

Списки пропуска используются для ускорения поиска в больших списках документов. Их кэширование позволяет избежать многократной распаковки одних и тех же данных списков пропуска при разных запросах. Установите значение этого параметра в `0`, чтобы отключить кэширование.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
skiplist_cache_size = 128M
```
<!-- end -->

### snippets_file_prefix

<!-- example conf snippets_file_prefix -->
Префикс, добавляемый к локальным именам файлов при генерации сниппетов. Опционально, по умолчанию текущая рабочая папка.

Этот префикс можно использовать в распределенной генерации сниппетов вместе с опциями `load_files` или `load_files_scattered`.

Обратите внимание, что это префикс, а **не** путь! Это означает, что если префикс установлен в "server1", а запрос ссылается на "file23", `searchd` попытается открыть "server1file23" (все это без кавычек). Поэтому, если вам нужен путь, вы должны включить завершающий слеш.

После построения окончательного пути к файлу сервер разворачивает все относительные каталоги и сравнивает конечный результат со значением `snippet_file_prefix`. Если результат не начинается с префикса, такой файл будет отклонен с сообщением об ошибке.

Например, если вы установите его в `/mnt/data`, а кто-то вызовет генерацию сниппета с файлом `../../../etc/passwd` в качестве источника, он получит сообщение об ошибке:

`Файл '/mnt/data/../../../etc/passwd' выходит за пределы области '/mnt/data/'`

вместо содержимого файла.

Также, при неустановленном параметре и чтении `/etc/passwd`, он фактически прочитает /daemon/working/folder/etc/passwd, поскольку по умолчанию для параметра используется рабочая папка сервера.

Также обратите внимание, что это локальная опция; она никак не влияет на агентов. Таким образом, вы можете безопасно установить префикс на главном сервере. Запросы, перенаправленные агентам, не будут затронуты настройкой мастера. Однако на них повлияют собственные настройки агента.

Это может быть полезно, например, когда места хранения документов (будь то локальное хранилище или точки монтирования NAS) не согласованы между серверами.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
snippets_file_prefix = /mnt/common/server1/
```
<!-- end -->

> **ПРЕДУПРЕЖДЕНИЕ:** Если вы все еще хотите получить доступ к файлам из корня файловой системы, вы должны явно установить `snippets_file_prefix` в пустое значение (строкой `snippets_file_prefix=`), или в корень (строкой `snippets_file_prefix=/`).


### sphinxql_state

<!-- example conf sphinxql_state -->
Путь к файлу, в который будет сериализовано текущее состояние SQL.

При запуске сервера этот файл воспроизводится. При соответствующих изменениях состояния (например, SET GLOBAL) этот файл автоматически перезаписывается. Это может предотвратить трудно диагностируемую проблему: если вы загружаете UDF функции, но Manticore падает, то при его (автоматическом) перезапуске ваши UDF и глобальные переменные больше не будут доступны. Использование постоянного состояния помогает обеспечить плавное восстановление без таких сюрпризов.

`sphinxql_state` нельзя использовать для выполнения произвольных команд, таких как `CREATE TABLE`.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
sphinxql_state = uservars.sql
```
<!-- end -->


### sphinxql_timeout

<!-- example conf sphinxql_timeout -->
Максимальное время ожидания между запросами (в секундах или [специальные суффиксы](../Server_settings/Special_suffixes.md)) при использовании SQL интерфейса. Опционально, по умолчанию 15 минут.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
sphinxql_timeout = 15m
```
<!-- end -->


### ssl_ca

<!-- example conf ssl_ca -->
Путь к файлу сертификата центра сертификации SSL (CA) (также известному как корневой сертификат). Опционально, по умолчанию пусто. Когда не пусто, сертификат в `ssl_cert` должен быть подписан этим корневым сертификатом.

Сервер использует файл CA для проверки подписи на сертификате. Файл должен быть в формате PEM.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ssl_ca = keys/ca-cert.pem
```
<!-- end -->


### ssl_cert

<!-- example conf ssl_cert -->
Путь к SSL сертификату сервера. Опционально, по умолчанию пусто.

Сервер использует этот сертификат в качестве самоподписанного открытого ключа для шифрования HTTP трафика по SSL. Файл должен быть в формате PEM.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ssl_cert = keys/server-cert.pem
```
<!-- end -->


### ssl_key

<!-- example conf ssl_key -->
Путь к ключу SSL сертификата. Опционально, по умолчанию пусто.

Сервер использует этот приватный ключ для шифрования HTTP-трафика по SSL. Файл должен быть в формате PEM.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ssl_key = keys/server-key.pem
```
<!-- end -->


### subtree_docs_cache

<!-- example conf subtree_docs_cache -->
Максимальный размер кэша документов общего поддерева на запрос. Необязательный параметр, по умолчанию 0 (отключено).

Этот параметр ограничивает использование оперативной памяти оптимизатором общего поддерева (см. [мультизапросы](../Searching/Multi-queries.md)). Максимум, столько оперативной памяти будет потрачено на кэширование записей документов для каждого запроса. Установка лимита в 0 отключает оптимизатор.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
subtree_docs_cache = 8M
```
<!-- end -->


### subtree_hits_cache

<!-- example conf subtree_hits_cache -->
Максимальный размер кэша вхождений общего поддерева на запрос. Необязательный параметр, по умолчанию 0 (отключено).

Этот параметр ограничивает использование оперативной памяти оптимизатором общего поддерева (см. [мультизапросы](../Searching/Multi-queries.md)). Максимум, столько оперативной памяти будет потрачено на кэширование вхождений ключевых слов (хитов) для каждого запроса. Установка лимита в 0 отключает оптимизатор.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
subtree_hits_cache = 16M
```
<!-- end -->

### threads

<!-- example threads -->
Количество рабочих потоков (или размер пула потоков) для демона Manticore. Manticore создает это количество потоков ОС при запуске, и они выполняют все задачи внутри демона, такие как выполнение запросов, создание сниппетов и т.д. Некоторые операции могут быть разделены на подзадачи и выполняться параллельно, например:

* Поиск в таблице реального времени
* Поиск в распределенной таблице, состоящей из локальных таблиц
* Вызов перколяционного запроса
* и другие

По умолчанию значение равно количеству ядер ЦП на сервере. Manticore создает потоки при запуске и хранит их до остановки. Каждая подзадача может использовать один из потоков, когда это необходимо. Когда подзадача завершается, она освобождает поток, чтобы другая подзадача могла его использовать.

В случае интенсивной нагрузки типа I/O может иметь смысл установить значение выше, чем количество ядер ЦП.

<!-- request Example -->
```ini
threads = 10
```

<!-- end -->

### thread_stack

<!-- example conf thread_stack -->
Максимальный размер стека для задачи (корутины, один поисковый запрос может вызвать несколько задач/корутин). Необязательный параметр, по умолчанию 128K.

Каждая задача имеет свой собственный стек размером 128K. При запуске запроса проверяется, сколько стека ему требуется. Если стандартных 128K достаточно, он просто обрабатывается. Если нужно больше, планируется другая задача с увеличенным стеком, которая продолжает обработку. Максимальный размер такого расширенного стека ограничен этим параметром.

Установка значения на разумно высоком уровне поможет обрабатывать очень глубокие запросы без подразумевания, что общее потребление оперативной памяти вырастет слишком сильно. Например, установка значения в 1G не означает, что каждая новая задача займет 1G оперативной памяти, но если мы видим, что ей требуется, скажем, 100M стека, мы просто выделяем 100M для задачи. Другие задачи в то же время будут выполняться со своим стандартным стеком в 128K. Таким же образом мы можем выполнять еще более сложные запросы, которым нужно 500M. И только если мы **увидим** внутренне, что задаче требуется более 1G стека, мы завершимся с ошибкой и сообщим о слишком низком значении thread_stack.

Однако на практике даже запрос, которому нужно 16M стека, часто оказывается слишком сложным для разбора и потребляет слишком много времени и ресурсов для обработки. Таким образом, демон обработает его, но ограничение таких запросов с помощью настройки `thread_stack` выглядит вполне разумным.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
thread_stack = 8M
```
<!-- end -->


### unlink_old

<!-- example conf unlink_old -->
Определяет, удалять ли копии таблиц `.old` при успешной ротации. Необязательный параметр, по умолчанию 1 (удалять).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
unlink_old = 0
```
<!-- end -->


### watchdog

<!-- example conf watchdog -->
Потоковый сторожевой таймер сервера. Необязательный параметр, по умолчанию 1 (включен).

Когда запрос Manticore завершается аварийно, он может привести к падению всего сервера. При включенной функции сторожевого таймера `searchd` также поддерживает отдельный легковесный процесс, который отслеживает основной процесс сервера и автоматически перезапускает его в случае аномального завершения. Сторожевой таймер включен по умолчанию.

<!-- request Example -->

```ini
watchdog = 0 # disable watchdog
```
<!-- end -->
<!-- proofread -->

