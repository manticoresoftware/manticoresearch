# Раздел "Searchd" в конфигурации

Ниже приведены настройки, которые используются в разделе `searchd` файла конфигурации Manticore Search для управления поведением сервера. Ниже приведено краткое описание каждой настройки:

### access_plain_attrs

Эта настройка задает значения по умолчанию для всего экземпляра для [access_plain_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `mmap_preread`.

Директива `access_plain_attrs` позволяет определить значение по умолчанию для [access_plain_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Директивы для отдельных таблиц имеют более высокий приоритет и переопределяют это значение по умолчанию, обеспечивая более тонкий контроль.

### access_blob_attrs

Эта настройка задает значения по умолчанию для всего экземпляра для [access_blob_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `mmap_preread`.

Директива `access_blob_attrs` позволяет определить значение по умолчанию для [access_blob_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Директивы для отдельных таблиц имеют более высокий приоритет и переопределяют это значение по умолчанию, обеспечивая более тонкий контроль.

### access_doclists

Эта настройка задает значения по умолчанию для всего экземпляра для [access_doclists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `file`.

Директива `access_doclists` позволяет определить значение по умолчанию для [access_doclists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Директивы для отдельных таблиц имеют более высокий приоритет и переопределяют это значение по умолчанию, обеспечивая более тонкий контроль.

### access_hitlists

Эта настройка задает значения по умолчанию для всего экземпляра для [access_hitlists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `file`.

Директива `access_hitlists` позволяет определить значение по умолчанию для [access_hitlists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Директивы для отдельных таблиц имеют более высокий приоритет и переопределяют это значение по умолчанию, обеспечивая более тонкий контроль.

### access_dict

Эта настройка задает значения по умолчанию для всего экземпляра для [access_dict](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `mmap_preread`.

Директива `access_dict` позволяет определить значение по умолчанию для [access_dict](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Директивы для отдельных таблиц имеют более высокий приоритет и переопределяют это значение по умолчанию, обеспечивая более тонкий контроль.

### agent_connect_timeout

Эта настройка задает значения по умолчанию для всего экземпляра для параметра [agent_connect_timeout](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_connect_timeout).


### agent_query_timeout

Эта настройка задает значения по умолчанию для всего экземпляра для параметра [agent_query_timeout](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_query_timeout). Она может быть переопределена для каждого запроса с помощью клаузы `OPTION agent_query_timeout=XXX`.


### agent_retry_count

Эта настройка — целое число, которое указывает, сколько раз Manticore попытается подключиться и выполнить запрос к удалённым агентам через распределённую таблицу, прежде чем сообщить о фатальной ошибке запроса. Значение по умолчанию — 0 (т.е. без повторных попыток). Вы также можете задать это значение для каждого запроса с помощью клаузы `OPTION retry_count=XXX`. Если задана опция для конкретного запроса, она переопределит значение, указанное в конфигурации.

Обратите внимание, что если вы используете [agent mirrors](../Creating_a_cluster/Remote_nodes/Mirroring.md#Agent-mirrors) в определении вашей распределённой таблицы, сервер будет выбирать другой зеркальный агент для каждой попытки подключения в соответствии с выбранной стратегией [ha_strategy](../Creating_a_cluster/Remote_nodes/Load_balancing.md#ha_strategy). В этом случае `agent_retry_count` будет суммироваться для всех зеркал в наборе.

Например, если у вас 10 зеркал и установлено `agent_retry_count=5`, сервер будет пытаться до 50 раз, предполагая в среднем 5 попыток для каждого из 10 зеркал (при опции `ha_strategy = roundrobin` это будет так).

Однако значение, указанное в опции `retry_count` для [агента](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent), служит абсолютным лимитом. Другими словами, опция `[retry_count=2]` в определении агента всегда означает максимум 2 попытки, независимо от того, указали ли вы 1 или 10 зеркал для агента.

### agent_retry_delay

Эта настройка — целое число в миллисекундах (или [special_suffixes](../Server_settings/Special_suffixes.md)), которое задает задержку перед повторной попыткой запроса к удалённому агенту в случае сбоя. Это значение актуально только при ненулевом [agent_retry_count](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md) или ненулевом значении `retry_count` для конкретного запроса. Значение по умолчанию — 500. Вы также можете задать это значение для каждого запроса с помощью клаузы `OPTION retry_delay=XXX`. Если задана опция для конкретного запроса, она переопределит значение, указанное в конфигурации.


### attr_flush_period

<!-- example conf attr_flush_period -->
При использовании [Update](../Data_creation_and_modification/Updating_documents/UPDATE.md) для изменения атрибутов документа в реальном времени, изменения сначала записываются во внутреннюю копию атрибутов в памяти. Эти обновления происходят в памяти с отображением файла, то есть ОС решает, когда записывать изменения на диск. При нормальном завершении работы `searchd` (инициируется сигналом `SIGTERM`), все изменения принудительно записываются на диск.

Вы также можете настроить `searchd` на периодическую запись этих изменений на диск, чтобы предотвратить потерю данных. Интервал между этими сбросами определяется параметром `attr_flush_period`, задаваемым в секундах (или с использованием [special_suffixes](../Server_settings/Special_suffixes.md)).

По умолчанию значение равно 0, что отключает периодическую запись. Однако сброс всё равно происходит при нормальном завершении.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
attr_flush_period = 900 # persist updates to disk every 15 minutes
```
<!-- end -->

### auto_optimize

<!-- example conf auto_optimize -->
Этот параметр управляет автоматическим процессом [OPTIMIZE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE) для сжатия таблицы.

По умолчанию сжатие таблицы происходит автоматически. Вы можете изменить это поведение с помощью параметра `auto_optimize`:
* 0 — отключить автоматическое сжатие таблицы (вы всё ещё можете вызвать `OPTIMIZE` вручную)
* 1 — явно включить его
* включить с умножением порога оптимизации на 2.

По умолчанию OPTIMIZE выполняется до тех пор, пока количество дисковых чанков не станет меньше или равно числу логических ядер CPU, умноженному на 2.

Однако, если у таблицы есть атрибуты с KNN индексами, этот порог изменяется. В этом случае он равен числу физических ядер CPU, делённому на 2, чтобы улучшить производительность поиска KNN.

Обратите внимание, что включение или отключение `auto_optimize` не препятствует выполнению [OPTIMIZE TABLE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE) вручную.

<!-- intro -->
##### Пример:

<!-- request Disable -->
```ini
auto_optimize = 0 # disable automatic OPTIMIZE
```

<!-- request Throttle -->
```ini
auto_optimize = 2 # OPTIMIZE starts at 16 chunks (on 4 cpu cores server)
```

<!-- end -->

### parallel_chunk_merges

<!-- example conf parallel_chunk_merges -->
Этот параметр управляет количеством заданий слияния дисковых чанков, которые сервер может запускать параллельно во время [OPTIMIZE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE) для таблиц в реальном времени.

Это влияет только на слияние дисковых чанков (сжатие), а не на параллелизм запросов.

Установите значение в `1`, чтобы отключить параллельное слияние чанков (задания будут выполняться последовательно). Более высокие значения могут ускорить сжатие на системах с быстрым хранилищем, но увеличат конкурентный ввод-вывод диска.

По умолчанию `max(1, min(2, threads/2))`.

Это значение можно изменить во время работы с помощью `SET GLOBAL parallel_chunk_merges = N` и просмотреть через `SHOW VARIABLES`.

<!-- intro -->
##### Пример:

<!-- request Disable -->
```ini
parallel_chunk_merges = 1
```

<!-- request Increase -->
```ini
parallel_chunk_merges = 4
```

<!-- end -->

### auto_schema

<!-- example conf auto_schema -->
Manticore поддерживает автоматическое создание таблиц, которые ещё не существуют, но указаны в инструкциях INSERT. Эта функция включена по умолчанию. Чтобы отключить её, явно установите `auto_schema = 0` в конфигурации. Чтобы включить обратно, установите `auto_schema = 1` или удалите настройку `auto_schema` из конфигурации.

Имейте в виду, что HTTP endpoint `/bulk` не поддерживает автоматическое создание таблиц.

> ПРИМЕЧАНИЕ: [Функция авто-схемы](../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md#Auto-schema) требует [Manticore Buddy](../Installation/Manticore_Buddy.md). Если она не работает, убедитесь, что Buddy установлен.

<!-- request Disable -->
```ini
auto_schema = 0 # disable automatic table creation
```

<!-- request Enable -->
```ini
auto_schema = 1 # enable automatic table creation
```

<!-- end -->

### binlog_flush

<!-- example conf binlog_flush -->
Этот параметр управляет режимом сброса/синхронизации бинарного лога транзакций. Он опционален, значение по умолчанию — 2 (сброс после каждой транзакции, синхронизация каждую секунду).

Директива определяет, как часто бинарный лог будет сбрасываться в ОС и синхронизироваться с диском. Поддерживаются три режима:

*  0 — сброс и синхронизация каждую секунду. Обеспечивает лучшую производительность, но при сбое сервера или ОС/оборудования можно потерять до 1 секунды коммитов.
*  1 — сброс и синхронизация после каждой транзакции. Режим с худшей производительностью, но гарантирующий сохранность данных каждой коммитнутой транзакции.
*  2 — сброс после каждой транзакции, синхронизация каждую секунду. Обеспечивает хорошую производительность и сохранность каждой коммитнутой транзакции при сбое сервера. Однако при сбое ОС/оборудования можно потерять до 1 секунды коммитов.

Для тех, кто знаком с MySQL и InnoDB, эта директива подобна `innodb_flush_log_at_trx_commit`. В большинстве случаев режим 2 по умолчанию даёт хороший баланс скорости и безопасности, с полной защитой данных таблиц RT от сбоев сервера и некоторой защитой от сбоев оборудования.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_flush = 1 # ultimate safety, low speed
```
<!-- end -->

### binlog_common

<!-- example conf binlog_common -->
Этот параметр управляет управлением файлами бинарного лога. Он опционален, значение по умолчанию 0 (отдельный файл для каждой таблицы).

Вы можете выбрать один из двух способов управления файлами бинарного лога:

* Отдельный файл для каждой таблицы (по умолчанию, `0`): Каждая таблица сохраняет свои изменения в собственном лог-файле. Такой подход хорош, если у вас много таблиц, обновляющихся в разное время. Он позволяет обновлять таблицы без ожиданий других. Также, если возникает проблема с лог-файлом одной таблицы, это не влияет на остальные.
* Единый файл для всех таблиц (`1`): Все таблицы используют один общий файл бинарного лога. Такой метод упрощает управление файлами, потому что их меньше. Однако это может привести к тому, что файл дольше не будет удалён, если хотя бы одна таблица продолжает сохранять изменения. Эта настройка также может снизить производительность, если много таблиц обновляются одновременно, так как все изменения должны записываться в один файл.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_common = 1 # use a single binary log file for all tables
```
<!-- end -->

### binlog_max_log_size

<!-- example conf binlog_max_log_size -->
Этот параметр контролирует максимальный размер бинарного лог-файла. Он является необязательным и имеет значение по умолчанию 256 МБ.

Новый binlog-файл будет принудительно открыт, как только текущий binlog-файл достигнет этого лимита размера. Это приводит к более мелкой гранулярности логов и может привести к более эффективному использованию диска binlog в некоторых пограничных нагрузках. Значение 0 указывает, что binlog-файл не должен переоткрываться по размеру.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_max_log_size = 16M
```
<!-- end -->


### binlog_path

<!-- example conf binlog_path -->
Этот параметр определяет путь к файлам бинарного лога (также известного как транзакционный лог). Он является необязательным и по умолчанию равен каталогу данных, настроенному при сборке (например, `/var/lib/manticore/data/binlog.*` в Linux).

Бинарные логи используются для восстановления данных таблиц RT после сбоев и для обновления атрибутов простых дисковых индексов, которые в противном случае сохранялись бы только в оперативной памяти до сброса. Когда ведение логов включено, каждая транзакция, зафиксированная COMMIT в таблице RT, записывается в лог-файл. Логи автоматически воспроизводятся при запуске после некорректного завершения работы, восстанавливая залогированные изменения.

Директива `binlog_path` указывает расположение файлов бинарного лога. Она должна содержать только путь; `searchd` будет создавать и удалять несколько файлов `binlog.*` в директории по мере необходимости (включая данные binlog, метаданные и блокировки и т.д.).

Пустое значение отключает ведение бинарного лога, что улучшает производительность, но подвергает данные таблицы RT риску.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_path = # disable logging
binlog_path = /var/lib/manticore/data # /var/lib/manticore/data/binlog.001 etc will be created
```
<!-- end -->

### boolean_simplify

<!-- example conf boolean_simplify -->
Этот параметр управляет значением по умолчанию для опции поиска [boolean_simplify](../Searching/Options.md#boolean_simplify). Он необязательный, по умолчанию равен 1 (включено).

При значении 1 сервер автоматически применит [оптимизацию булевого запроса](../Searching/Full_text_matching/Boolean_optimization.md) для улучшения производительности поиска. При значении 0 запросы будут выполняться без оптимизации по умолчанию. Это значение по умолчанию можно изменить для каждого запроса с помощью соответствующей опции поиска `boolean_simplify`.

<!-- request Example -->
```ini
searchd {
    boolean_simplify = 0  # disable boolean optimization by default
}
```
<!-- end -->

### buddy_path

<!-- example conf buddy_path -->
Этот параметр определяет путь к исполняемому файлу Manticore Buddy. Он является необязательным и по умолчанию установлен в путь, определённый при сборке, который различается в разных операционных системах. Обычно изменять этот параметр не нужно. Однако это может быть полезно, если вы хотите запустить Manticore Buddy в режиме отладки, внести изменения в Manticore Buddy или реализовать новый плагин. В последнем случае вы можете `git clone` Buddy из https://github.com/manticoresoftware/manticoresearch-buddy, добавить новый плагин в каталог `./plugins/`, и запустить `composer install --prefer-source` для упрощения разработки после перехода в директорию исходников Buddy.

Для запуска `composer` на вашей машине должен быть установлен PHP 8.2 или выше с следующими расширениями:

```
--enable-dom
--with-libxml
--enable-tokenizer
--enable-xml
--enable-xmlwriter
--enable-xmlreader
--enable-simplexml
--enable-phar
--enable-bcmath
--with-gmp
--enable-debug
--with-mysqli
--enable-mysqlnd
```

Вы также можете воспользоваться специальной версией `manticore-executor-dev` для Linux amd64, доступной в релизах, например: https://github.com/manticoresoftware/executor/releases/tag/v1.0.13

Если вы пойдёте этим путём, не забудьте связать dev-версию manticore executor с `/usr/bin/php`.

Чтобы отключить Manticore Buddy, задайте пустое значение, как показано в примере.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
buddy_path = manticore-executor -n /usr/share/manticore/modules/manticore-buddy/src/main.php # use the default Manticore Buddy in Linux
buddy_path = manticore-executor -n /usr/share/manticore/modules/manticore-buddy/src/main.php --threads=1 # runs Buddy with a single worker
buddy_path = manticore-executor -n /opt/homebrew/share/manticore/modules/manticore-buddy/bin/manticore-buddy/src/main.php # use the default Manticore Buddy in MacOS arm64
buddy_path = manticore-executor -n /Users/username/manticoresearch-buddy/src/main.php # use Manticore Buddy from a non-default location
buddy_path = # disables Manticore Buddy
buddy_path = manticore-executor -n /Users/username/manticoresearch-buddy/src/main.php --skip=manticoresoftware/buddy-plugin-replace # --skip - skips plugins
buddy_path = manticore-executor -n /usr/share/manticore/modules/manticore-buddy/src/main.php --enable-plugin=manticoresoftware/buddy-plugin-show # runs Buddy with only the SHOW plugin
```
<!-- end -->

### client_timeout

<!-- example conf client_timeout -->
Этот параметр определяет максимальное время ожидания между запросами (в секундах или с использованием [special_suffixes](../Server_settings/Special_suffixes.md)) при использовании постоянных соединений. Он необязательный, значение по умолчанию — пять минут.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
client_timeout = 1h
```
<!-- end -->


### collation_libc_locale

<!-- example conf collation_libc_locale -->
Локаль libc сервера. Опционально, по умолчанию C.

Задает локаль libc, влияющую на колляции на основе libc. Подробнее см. в разделе [collations](../Searching/Collations.md).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
collation_libc_locale = fr_FR
```
<!-- end -->


### collation_server

<!-- example conf collation_server -->
Колляция сервера по умолчанию. Опционально, по умолчанию libc_ci.

Определяет колляцию по умолчанию для входящих запросов. Колляция может быть переопределена для каждого запроса. Ознакомьтесь с разделом [collations](../Searching/Collations.md) для списка доступных колляций и других подробностей.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
collation_server = utf8_ci
```
<!-- end -->


### data_dir

<!-- example conf data_dir -->
Если указан, этот параметр включает [режим реального времени](../Creating_a_table/Local_tables.md#Online-schema-management-%28RT-mode%29), который представляет собой императивный способ управления схемой данных. Значение должно быть путем к каталогу, где вы хотите хранить все свои таблицы, бинарные логи и все остальное, необходимое для правильной работы Manticore Search в этом режиме.
Индексация [простых таблиц](../Creating_a_table/Local_tables/Plain_table.md) запрещена при указании `data_dir`. Подробнее о различиях между режимом RT и простым режимом читайте в [этом разделе](../Read_this_first.md#Real-time-table-vs-plain-table).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
data_dir = /var/lib/manticore
```
<!-- end -->

### diskchunk_flush_search_timeout

<!-- example conf diskchunk_flush_search_timeout -->
Таймаут для предотвращения автоматического сброса RAM-куска, если в таблице нет поисков. Необязательный параметр, значение по умолчанию 30 секунд.

Время проверки поисков перед решением об авто-сбросе.
Автоматическая очистка произойдет только в том случае, если в таблице был хотя бы один поиск за последние `diskchunk_flush_search_timeout` секунд. Работает в связке с [diskchunk_flush_write_timeout](../Server_settings/Searchd.md#diskchunk_flush_write_timeout). Соответствующая [настройка для каждой таблицы](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#diskchunk_flush_search_timeout) имеет более высокий приоритет и переопределит это значение по умолчанию для всего инстанса, обеспечивая более точный контроль.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
diskchunk_flush_search_timeout = 120s
```
<!-- end -->

### diskchunk_flush_write_timeout

<!-- example conf diskchunk_flush_write_timeout -->
Время в секундах ожидания без записи перед автоматической очисткой RAM-чункa на диск. Необязательно, по умолчанию 1 секунда.

Если в RAM-чункe не происходит запись в течение `diskchunk_flush_write_timeout` секунд, чанк будет сброшен на диск. Работает в связке с [diskchunk_flush_search_timeout](../Server_settings/Searchd.md#diskchunk_flush_search_timeout). Чтобы отключить автоочистку, явно укажите `diskchunk_flush_write_timeout = -1` в вашей конфигурации. Соответствующая [настройка для каждой таблицы](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#diskchunk_flush_write_timeout) имеет более высокий приоритет и переопределит это значение по умолчанию для всего инстанса, обеспечивая более точный контроль.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
diskchunk_flush_write_timeout = 60s
```
<!-- end -->

### docstore_cache_size

<!-- example conf docstore_cache_size -->
Эта настройка определяет максимальный размер блоков документов из хранилища документов, которые хранятся в памяти. Необязательно, значение по умолчанию — 16m (16 мегабайт).

Когда используется `stored_fields`, блоки документов считываются с диска и распаковываются. Поскольку каждый блок обычно содержит несколько документов, он может быть повторно использован при обработке следующего документа. Для этой цели блок хранится в кешe на уровне сервера. В кеше хранятся распакованные блоки.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
docstore_cache_size = 8m
```
<!-- end -->

### engine

<!-- example conf engine -->
Движок хранения атрибутов по умолчанию, используемый при создании таблиц в режиме RT. Может быть `rowwise` (по умолчанию) или `columnar`.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
engine = columnar
```
<!-- end -->


### expansion_limit

<!-- example conf expansion_limit -->
Эта настройка определяет максимальное количество развернутых ключевых слов для одного подстановочного знака. Необязательно, значение по умолчанию 0 (без ограничения).

При выполнении поиска подстрок в таблицах, построенных с включенным `dict = keywords`, один подстановочный знак может потенциально привести к тысячам или даже миллионам совпадающих ключевых слов (подумайте о сопоставлении `a*` со всем словарем Оксфорда). Эта директива позволяет ограничить влияние таких расширений. Установка `expansion_limit = N` ограничивает расширения не более чем N наиболее частыми совпадающими ключевыми словами (для каждого подстановочного знака в запросе).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_limit = 16
```
<!-- end -->

### expansion_merge_threshold_docs

<!-- example conf expansion_merge_threshold_docs -->
Эта настройка определяет максимальное количество документов в развернутом ключевом слове, при котором допускается объединение всех таких ключевых слов. Необязательно, значение по умолчанию 32.

При выполнении поиска подстрок в таблицах, построенных с включенным `dict = keywords`, один подстановочный знак может потенциально привести к тысячам или даже миллионам совпадающих ключевых слов. Эта директива позволяет увеличить предел количества ключевых слов, которые будут объединены вместе для ускорения сопоставления, но при этом использует больше памяти в процессе поиска.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_merge_threshold_docs = 1024
```
<!-- end -->

### expansion_merge_threshold_hits

<!-- example conf expansion_merge_threshold_hits -->
Эта настройка определяет максимальное количество попаданий (hits) в развернутом ключевом слове, при котором допускается объединение всех таких ключевых слов. Необязательно, значение по умолчанию 256.

При выполнении поиска подстрок в таблицах, построенных с включенным `dict = keywords`, один подстановочный знак может потенциально привести к тысячам или даже миллионам совпадающих ключевых слов. Эта директива позволяет увеличить предел количества ключевых слов, которые будут объединены вместе для ускорения сопоставления, но при этом использует больше памяти в процессе поиска.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_merge_threshold_hits = 512
```
<!-- end -->

### expansion_phrase_limit

<!-- example conf expansion_phrase_limit -->
Эта настройка контролирует максимальное количество альтернативных вариантов фраз, генерируемых из-за операторов `OR` внутри операторов `PHRASE`, `PROXIMITY` и `QUORUM`. Необязательно, значение по умолчанию 1024.

При использовании оператора `|` (OR) внутри операторов, похожих на фразы, общее количество расширенных комбинаций может расти экспоненциально в зависимости от количества указанных альтернатив. Эта настройка помогает предотвратить чрезмерное расширение запроса, ограничивая количество перестановок, рассматриваемых при обработке запроса.

Если количество сгенерированных вариантов превышает этот предел, запрос:

- будет завершен с ошибкой (поведение по умолчанию)
- вернет частичные результаты с предупреждением, если включен `expansion_phrase_warning`

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_phrase_limit = 4096
```
<!-- end -->

### expansion_phrase_warning

<!-- example conf expansion_phrase_warning -->
Эта настройка контролирует поведение при превышении лимита расширения запроса, определенного параметром `expansion_phrase_limit`.

По умолчанию запрос завершится с сообщением об ошибке. При установке `expansion_phrase_warning` в 1 поиск продолжается с использованием частичной трансформации фразы (до настроенного предела), и сервер возвращает пользователю предупреждение вместе с набором результатов. Это позволяет запросам, которые слишком сложны для полного расширения, по-прежнему возвращать частичные результаты без полного отказа.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_phrase_warning = 1
```
<!-- end -->

### grouping_in_utc

Этот параметр указывает, будет ли временное группирование в API и SQL рассчитываться в локальном часовом поясе или в UTC. Он необязателен, по умолчанию имеет значение 0 (что означает «локальный часовой пояс»).

По умолчанию все выражения 'group by time' (такие как группировка по дню, неделе, месяцу и году в API, а также группировка по дню, месяцу, году, yearmonth, yearmonthday в SQL) выполняются с использованием локального времени. Например, если у вас есть документы с атрибутами времени `13:00 utc` и `15:00 utc`, в случае группировки они оба попадут в группы facility согласно настройке локального часового пояса. Если вы находитесь в `utc`, это будет один день, но если вы находитесь в `utc+10`, то эти документы будут сопоставлены с разными группами facility по дню (поскольку 13:00 utc в часовом поясе UTC+10 это 23:00 местного времени, а 15:00 — это 01:00 следующего дня). Иногда такое поведение неприемлемо, и желательно сделать групировку по времени независимой от часового пояса. Вы можете запустить сервер с установленной глобальной переменной окружения TZ, но это повлияет не только на группировку, но и на отметки времени в логах, что тоже может быть нежелательно. Включение этой опции (либо в конфиге, либо с использованием оператора [SET global](../Server_settings/Setting_variables_online.md#SET) в SQL) приведёт к вычислению всех выражений группировки времени в UTC, оставляя остальные функции, зависящие от времени (например, логирование сервера), в локальном часовом поясе.


### timezone

Этот параметр задаёт часовой пояс, используемый функциями, связанными с датой и временем. По умолчанию используется локальный часовой пояс, но вы можете указать другой часовой пояс в формате IANA (например, `Europe/Amsterdam`).

Обратите внимание, что этот параметр не влияет на логирование, которое всегда работает в локальном часовом поясе.

Также учтите, что если используется `grouping_in_utc`, функция 'group by time' всё равно будет использовать UTC, в то время как другие функции, связанные с датой и временем, будут использовать указанный часовой пояс. В целом не рекомендуется смешивать `grouping_in_utc` и `timezone`.

Вы можете настроить эту опцию либо в конфиге, либо с помощью оператора [SET global](../Server_settings/Setting_variables_online.md#SET) в SQL.


### ha_period_karma

<!-- example conf ha_period_karma -->
Этот параметр задаёт размер окна статистики зеркал агента в секундах (или с использованием [special_suffixes](../Server_settings/Special_suffixes.md)). Он необязателен, по умолчанию имеет значение 60 секунд.

Для распределённой таблицы с зеркалами агента (подробнее см. в разделе [agent](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md)) мастер отслеживает несколько различных счётчиков на каждое зеркало. Эти счётчики затем используются для переключения отказа и балансировки (мастер выбирает лучшее зеркало на основе счётчиков). Счётчики накапливаются блоками длительностью `ha_period_karma` секунд.

После начала нового блока мастер может ещё использовать накопленные значения из предыдущего блока, пока новый блок не будет заполнен наполовину. В результате любое предыдущее состояние перестаёт влиять на выбор зеркала спустя максимум 1.5 раза `ha_period_karma` секунд.

Хотя для выбора зеркала используется максимум два блока, до 15 последних блоков хранится для целей инструментирования. Эти блоки можно просмотреть с помощью оператора [SHOW AGENT STATUS](../Node_info_and_management/Node_status.md#SHOW-AGENT-STATUS).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ha_period_karma = 2m
```
<!-- end -->


### ha_ping_interval

<!-- example conf ha_ping_interval -->
Этот параметр задаёт интервал между пингами зеркал агента в миллисекундах (или с использованием [special_suffixes](../Server_settings/Special_suffixes.md)). Он необязателен, по умолчанию имеет значение 1000 миллисекунд.

Для распределённой таблицы с зеркалами агента (подробнее см. в разделе [agent](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md)) мастер отправляет всем зеркалам команду пинга в периоды простоя. Это нужно для отслеживания текущего статуса агента (жив или мёртв, время сетевого отклика и т.д.). Интервал между такими пингами задаётся этой директивой. Чтобы отключить пинги, установите `ha_ping_interval` в 0.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ha_ping_interval = 3s
```
<!-- end -->


### hostname_lookup

Опция `hostname_lookup` определяет стратегию обновления имён хостов. По умолчанию IP-адреса имён агентов кэшируются при запуске сервера, чтобы избежать избыточного обращения к DNS. Однако в некоторых случаях IP может динамически меняться (например, в облачном хостинге), и может быть желательно не кэшировать IP. Установка этой опции в значение `request` отключает кэширование и выполняет DNS-запрос при каждом запросе. IP-адреса также можно обновлять вручную с помощью команды `FLUSH HOSTNAMES`.

### jobs_queue_size

Параметр jobs_queue_size определяет, сколько «заданий» может одновременно находиться в очереди. По умолчанию она не ограничена.

В большинстве случаев «задание» означает один запрос к одной локальной таблице (обычной таблице или дисковому чанку таблицы в реальном времени). Например, если у вас есть распределённая таблица, состоящая из 2 локальных таблиц, или таблица в реальном времени с 2 дисковыми чанками, поисковый запрос к любой из них создаст в очереди примерно 2 задания. Затем пул потоков (размер которого задаётся параметром [threads](../Server_settings/Searchd.md#threads)) обработает их. Однако в некоторых случаях, если запрос слишком сложный, может быть создано больше заданий. Рекомендуется менять этот параметр, если [max_connections](../Server_settings/Searchd.md#max_connections) и [threads](../Server_settings/Searchd.md#threads) не хватает для достижения баланса между производительностью и нагрузкой.

### join_batch_size

Объединение таблиц работает путём накопления батча совпадений — результатов запроса, выполненного в левой таблице. Этот батч затем обрабатывается как единый запрос к правой таблице.

Эта опция позволяет регулировать размер батча. Значение по умолчанию — `1000`, установка в `0` отключает батчинг.

Больший размер батча может улучшить производительность; однако для некоторых запросов это может привести к чрезмерному потреблению памяти.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
join_batch_size = 2000
```
<!-- end -->

### join_cache_size

Каждый запрос, выполняемый по правой таблице, определяется конкретными условиями JOIN ON, которые определяют извлекаемый из правой таблицы набор результатов.

Если уникальных условий JOIN ON немного, повторное использование результатов может быть более эффективным, чем многократное выполнение запросов к правой таблице. Для этого наборы результатов сохраняются в кеше.

Эта опция позволяет настроить размер этого кеша. Значение по умолчанию — `20 MB`, а установка значения 0 отключает кеширование.

Обратите внимание, что каждый поток поддерживает свой собственный кеш, поэтому при оценке общего потребления памяти следует учитывать количество потоков, выполняющих запросы.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
join_cache_size = 10M
```
<!-- end -->

### listen_backlog

<!-- example conf listen_backlog -->
Параметр listen_backlog определяет длину очереди TCP для входящих соединений. Особенно актуально для сборок под Windows, которые обрабатывают запросы по одному. Когда очередь соединений достигает предела, новые входящие соединения отклоняются.
Для не-Windows сборок значение по умолчанию обычно подходит, и нет необходимости изменять эту настройку.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
listen_backlog = 20
```
<!-- end -->

### kibana_version_string

<!-- example conf kibana_version_string -->
Строка версии сервера, возвращаемая Kibana или OpenSearch Dashboards. Опционально — по умолчанию установлено значение `7.6.0`.

Некоторые версии Kibana и OpenSearch Dashboards ожидают, что сервер будет возвращать конкретный номер версии, и могут вести себя по-разному в зависимости от этого. Чтобы обойти такие проблемы, вы можете использовать эту настройку, которая заставляет Manticore сообщать Kibana или OpenSearch Dashboards кастомную версию.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
kibana_version_string = 1.2.3
```
<!-- end -->

### listen

<!-- example conf listen -->
Эта настройка позволяет указать IP-адрес и порт или путь к Unix-доменному сокету, на которых Manticore будет принимать соединения.

Общий синтаксис для `listen`:

```ini
listen = ( address ":" port | port | path | address ":" port start - port end ) [ ":" protocol [ "_vip" ] [ "_readonly" ] ]
```

Вы можете указать:
* либо IP-адрес (или имя хоста) и номер порта
* либо только номер порта
* либо путь к Unix-сокету (не поддерживается на Windows)
* либо IP-адрес и диапазон портов

Если указан только номер порта без адреса, `searchd` будет слушать все сетевые интерфейсы. Путь Unix-сокета определяется ведущим слэшем. Диапазон портов можно задать только для протокола репликации.

Также можно указать обработчик протокола (listener), который будет использоваться для соединений на этом сокете. Листенеры:

* **Не указан** — Manticore принимает соединения на этом порту от:
  - других агентов Manticore (например, удалённой распределённой таблицы)
  - клиентов через HTTP и HTTPS
  - [Manticore Buddy](https://manticoresearch.com/blog/manticoresearch-buddy-intro/). **Убедитесь, что у вас есть листенер этого типа (или `http` листенер, как указано ниже), чтобы избежать ограничений функциональности Manticore.**
* `mysql` — протокол MySQL для соединений от MySQL клиентов. Замечания:
  - Также поддерживается сжатый протокол.
  - Если включён [SSL](../Security/SSL.md#SSL), можно установить зашифрованное соединение.
* `replication` — протокол репликации для коммуникации между узлами. Подробнее см. в разделе [репликация](../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md). Можно указать несколько replication-листенеров, но все должны слушать на одном IP; разными могут быть только порты. Если задать replication-листенер с диапазоном портов (например, `listen = 192.168.0.1:9320-9328:replication`), Manticore не начнёт слушать порты сразу. Вместо этого будут взяты случайные свободные порты из диапазона только при начале использования репликации. Для правильной работы репликации требуется минимум 2 порта в диапазоне.
* `http` — то же, что и **Не указан**. Manticore будет принимать соединения на этом порту от удалённых агентов и клиентов через HTTP и HTTPS.
* `https` — протокол HTTPS. Manticore принимает **только** HTTPS соединения на этом порту. Подробнее в разделе [SSL](../Security/SSL.md).
* `sphinx` — устаревший бинарный протокол. Используется для обслуживания соединений от удалённых клиентов [SphinxSE](../Extensions/SphinxSE.md). Некоторые реализации клиентов API Sphinx (например, Java) требуют явного объявления листенера.

Добавление суффикса `_vip` к клиентским протоколам (всем, кроме `replication`, например `mysql_vip` или `http_vip` или просто `_vip`) заставляет создавать выделенный поток для соединения, чтобы обойти ограничения. Полезно для обслуживания узла при сильной нагрузке, когда сервер мог бы либо зависнуть, либо не позволить подключиться через обычный порт.

Суффикс `_readonly` устанавливает [режим только для чтения](../Security/Read_only.md) для листенера и ограничивает его приём только чтением запросов.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
listen = localhost
listen = localhost:5000 # listen for remote agents (binary API) and http/https requests on port 5000 at localhost
listen = 192.168.0.1:5000 # listen for remote agents (binary API) and http/https requests on port 5000 at 192.168.0.1
listen = /var/run/manticore/manticore.s # listen for binary API requests on unix socket
listen = /var/run/manticore/manticore.s:mysql # listen for mysql requests on unix socket
listen = 9312 # listen for remote agents (binary API) and http/https requests on port 9312 on any interface
listen = localhost:9306:mysql # listen for mysql requests on port 9306 at localhost
listen = localhost:9307:mysql_readonly # listen for mysql requests on port 9307 at localhost and accept only read queries
listen = 127.0.0.1:9308:http # listen for http requests as well as connections from remote agents (and binary API) on port 9308 at localhost
listen = 192.168.0.1:9320-9328:replication # listen for replication connections on ports 9320-9328 at 192.168.0.1
listen = 127.0.0.1:9443:https # listen for https requests (not http) on port 9443 at 127.0.0.1
listen = 127.0.0.1:9312:sphinx # listen for legacy Sphinx requests (e.g. from SphinxSE) on port 9312 at 127.0.0.1
```
<!-- end -->

Можно указать несколько директив `listen`. `searchd` будет слушать клиентские соединения на всех указанных портах и сокетах. Конфигурация по умолчанию, предлагаемая в пакетах Manticore, задаёт прослушивание портов:
* `9308` и `9312` для соединений от удалённых агентов и клиентов, не использующих MySQL
* и порта `9306` для MySQL соединений.

Если в конфигурации не указать ни одного `listen`, Manticore будет ожидать соединения на:
* `127.0.0.1:9306` для MySQL клиентов
* `127.0.0.1:9312` для HTTP/HTTPS и соединений от других узлов Manticore и клиентов, использующих бинарный API Manticore.

#### Прослушивание привилегированных портов

По умолчанию Linux не позволит запускать Manticore с прослушиванием порта ниже 1024 (например, `listen = 127.0.0.1:80:http` или `listen = 127.0.0.1:443:https`), если запускать `searchd` не от root. Если хотите, чтобы Manticore слушал порты ниже 1024 под непользовательским пользователем, рассмотрите следующие варианты (любой из них должен сработать):
* Выполните команду `setcap CAP_NET_BIND_SERVICE=+eip /usr/bin/searchd`
* Добавьте `AmbientCapabilities=CAP_NET_BIND_SERVICE` в systemd юнит Manticore и перезагрузите демон (`systemctl daemon-reload`).

#### Технические детали протокола Sphinx API и TFO
<details>
Устаревший протокол Sphinx состоит из 2 этапов: обмен рукопожатиями и передача данных. Рукопожатие представляет собой пакет из 4 байт от клиента и пакет из 4 байт от демона с единственной целью — клиент определяет, что удалённый узел является настоящим демоном Sphinx, демон определяет, что удалённый узел — это настоящий клиент Sphinx. Основной поток данных достаточно простой: обе стороны объявляют свои рукопожатия, и противоположная сторона их проверяет. Такой обмен короткими пакетами предполагает использование специального флага `TCP_NODELAY`, который отключает алгоритм Нагла в TCP и указывает, что TCP-соединение будет выполняться как диалог маленьких пакетов.
Однако не было строго определено, кто начинает первым в этом обмене. Исторически все клиенты, использующие бинарный API, начинают первыми: отправляют рукопожатие, затем читают 4 байта от демона, затем отправляют запрос и читают ответ от демона.
Когда мы улучшали совместимость протокола Sphinx, мы учитывали следующие моменты:

1. Обычно связь мастер-агента устанавливается от известного клиента к известному хосту на известный порт. Поэтому маловероятно, что конечная точка предоставит неправильное рукопожатие. Следовательно, мы можем неявно предполагать, что обе стороны валидны и действительно говорят на протоколе Sphinx.
2. Исходя из этого предположения, мы можем «склеить» рукопожатие с реальным запросом и отправить в одном пакете. Если бэкенд — устаревший демон Sphinx, он просто прочитает этот склеенный пакет сначала как 4 байта рукопожатия, затем тело запроса. Поскольку всё пришло в одном пакете, у сокета бэкенда есть -1 RTT, а буфер фронтенда всё равно работает как обычно.
3. Продолжая предположение: поскольку пакет «запроса» достаточно мал, а рукопожатие ещё меньше, давайте отправим их оба в начальном TCP-пакете «SYN» с помощью современной техники TFO (tcp-fast-open). То есть мы подключаемся к удалённому узлу, отправляя склеенный пакет рукопожатия + тело запроса. Демон принимает соединение и сразу имеет и рукопожатие, и тело запроса в буфере сокета, так как они пришли в самом первом TCP-пакете «SYN». Это устраняет ещё один RTT.
4. Наконец, научить демон принимать это улучшение. Фактически это означает, что на уровне приложения НЕ используется `TCP_NODELAY`. А со стороны системы нужно обеспечить, чтобы на стороне демона была активирована поддержка TFO для приёма, а на стороне клиента — для отправки. По умолчанию в современных системах клиентский TFO уже активирован, поэтому вам нужно лишь настроить серверный TFO для правильной работы.

Все эти улучшения без изменения самого протокола позволили нам сократить 1.5 RTT TCP-протокола при соединении. Если запрос и ответ могут помещаться в один TCP-пакет, это уменьшает всю сессию бинарного API с 3.5 RTT до 2 RTT — что делает сетевой обмен примерно вдвое быстрее.

Таким образом, все наши улучшения основаны на изначально неопределённом моменте: «кто говорит первым». Если клиент говорит первым, мы можем применить все эти оптимизации и эффективно обработать подключение + рукопожатие + запрос в одном TFO-пакете. Более того, мы можем взглянуть в начало полученного пакета и определить реальный протокол. Вот почему вы можете подключаться к одному и тому же порту через API/http/https. Если же демон должен говорить первым, все эти оптимизации невозможны, а мультипротокол тоже невозможен. Поэтому у нас есть выделенный порт для MySQL, который мы не объединили с другими протоколами на одном порту. Вдруг среди всех клиентов нашёлся один, написанный с предположением, что демон должен первым отправлять рукопожатие. Это — плагин SphinxSE для mysql/mariadb. Для этого единственного клиента мы выделили определение протокола `sphinx`, чтобы работать максимально наследуемым способом. А именно: обе стороны активируют `TCP_NODELAY` и обмениваются маленькими пакетами. Демон отправляет своё рукопожатие при подключении, затем клиент отправляет своё, и дальше всё работает обычно. Это не очень оптимально, но просто работает. Если вы используете SphinxSE для подключения к Manticore — вам нужно выделить слушателя с явно указанным протоколом `sphinx`. Для других клиентов избегайте использовать этот слушатель, так как он медленнее. Если у вас есть другие устаревшие клиенты Sphinx API — сначала проверьте, могут ли они работать без выделенного мультипротокольного порта. Для связки мастер-агент использование мультипротокольного порта с включённым TFO клиента и сервера работает хорошо и однозначно ускорит работу сетевого бэкенда, особенно если ваши запросы лёгкие и быстрые.
</details>

### listen_tfo

Этот параметр позволяет включить флаг TCP_FASTOPEN для всех слушателей. По умолчанию управление осуществляется системой, но его можно явно отключить установкой значения '0'.

Для общего понимания расширения TCP Fast Open, пожалуйста, обратитесь к [Wikipedia](https://en.wikipedia.org/wiki/TCP_Fast_Open). Кратко: оно позволяет устранить один раунд TCP при установлении соединения.

На практике использование TFO во многих случаях может оптимизировать эффективность сети клиент-агент, как при использовании [постоянных агентов](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md), но без удержания активных соединений и без ограничений на максимальное число соединений.

На современных ОС поддержка TFO обычно включена на уровне системы, но это лишь «возможность», а не правило. Linux (как наиболее прогрессивный) поддерживает его с 2011 года на ядрах начиная с 3.7 (сервера). Windows поддерживает его с некоторых сборок Windows 10. Другие ОС (FreeBSD, MacOS) тоже в игре.

На Linux сервер проверяет переменную `/proc/sys/net/ipv4/tcp_fastopen` и действует согласно её значению. Бит 0 управляет клиентской стороной, бит 1 — слушателями. По умолчанию системное значение равно 1, т.е. клиенты включены, слушатели отключены.

### log

<!-- example conf log -->
Параметр log указывает имя файла журнала, куда будут записываться все события выполнения `searchd`. Если не указан, используется имя по умолчанию 'searchd.log'.

Или вы можете использовать 'syslog' в качестве имени файла. В этом случае события будут отправляться демонской службе syslog. Чтобы использовать опцию syslog, необходимо настроить Manticore с опцией `-–with-syslog` при сборке.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
log = /var/log/searchd.log
```
<!-- end -->


### max_batch_queries

<!-- example conf max_batch_queries -->
Ограничивает количество запросов в одном пакете. Опционально, по умолчанию 32.

Заставляет searchd выполнять проверку количества запросов, отправленных в одном пакете при использовании [мультизапросов](../Searching/Multi-queries.md). Установите значение 0, чтобы пропустить проверку.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_batch_queries = 256
```
<!-- end -->

### max_connections

<!-- example max_connections -->
Максимальное количество одновременных подключений клиентов. По умолчанию не ограничено. Обычно это заметно только при использовании любых видов постоянных соединений, например, CLI-сессий mysql или постоянных удалённых соединений для распределённых таблиц. При превышении лимита вы всё ещё сможете подключиться к серверу используя [VIP соединение](../Connecting_to_the_server/MySQL_protocol.md#VIP-connection). VIP соединения не учитываются в лимит.

<!-- request Example -->
```ini
max_connections = 10
```

<!-- end -->

### max_threads_per_query

<!-- example max_threads_per_query -->
Глобальный лимит на количество потоков, используемых одной операцией. По умолчанию соответствующие операции могут занимать все ядра CPU, не оставляя ресурсов для других операций. Например, `call pq` для достаточно крупной таблицы percolate может использовать все потоки в течение десятков секунд. Установка `max_threads_per_query` в, скажем, половину значения [threads](../Server_settings/Searchd.md#threads) обеспечит возможность параллельного запуска пары таких операций `call pq`.

Также можно установить эту настройку как переменную сессии или глобальную переменную во время выполнения.

Кроме того, поведение можно контролировать для каждого запроса индивидуально с помощью [OPTION threads](../Searching/Options.md#threads).

<!-- intro -->
##### Пример:
<!-- request Example -->

```ini
max_threads_per_query = 4
```

<!-- end -->

### max_filters

<!-- example conf max_filters -->
Максимально допустимое количество фильтров на запрос. Эта настройка используется только для внутренних проверок корректности и не влияет напрямую на использование RAM или производительность. Опционально, по умолчанию 256.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_filters = 1024
```
<!-- end -->


### max_filter_values

<!-- example conf max_filter_values -->
Максимально допустимое количество значений в одном фильтре. Эта настройка используется только для внутренних проверок корректности и не влияет напрямую на использование RAM или производительность. Опционально, по умолчанию 4096.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_filter_values = 16384
```
<!-- end -->


### max_open_files

<!-- example conf max_open_files -->
Максимальное количество открытых файлов сервером называется "мягким лимитом". Учтите, что обслуживание больших фрагментированных таблиц реального времени может требовать высокого значения этого лимита, так как каждый диск-чанк может занимать десятки или более файлов. Например, таблица реального времени с 1000 чанками может требовать открытия тысяч файлов одновременно. Если в логах встречается ошибка 'Too many open files', попробуйте настроить эту опцию — это может помочь решить проблему.

Также существует "жёсткий лимит", который нельзя превысить с помощью опции. Этот лимит определяется системой и может быть изменён в файле `/etc/security/limits.conf` на Linux. Другие операционные системы могут иметь другие механизмы, ознакомьтесь с их документацией.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_open_files = 10000
```
<!-- end -->

<!-- example conf max_open_files max -->
Помимо числовых значений, можно использовать магическое слово 'max' для установки лимита равным доступному текущему жёсткому лимиту.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_open_files = max
```
<!-- end -->


### max_packet_size

<!-- example conf max_packet_size -->
Максимально допустимый размер сетевого пакета. Эта настройка ограничивает размер как запросов от клиентов, так и ответов от удалённых агентов в распределённой среде. Используется только для внутренних проверок корректности и не влияет напрямую на использование RAM или производительность. Опционально, по умолчанию 128M.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_packet_size = 32M
```
<!-- end -->


### mysql_version_string

<!-- example conf mysql_version_string -->
Строка версии сервера для возврата через MySQL протокол. Опционально, по умолчанию пуста (возвращает версию Manticore).

Некоторые капризные библиотеки клиентов MySQL зависят от конкретного формата номера версии MySQL и иногда выбирают разные пути выполнения на основе указанного номера версии (а не флагов возможностей). Например, Python MySQLdb 1.2.2 выбрасывает исключение, если версия не в формате X.Y.ZZ; MySQL .NET connector 6.3.x внутренне ошибается на версиях 1.x с определённой комбинацией флагов и т.д. Чтобы обойти это, можно использовать директиву `mysql_version_string` и заставить `searchd` сообщать другую версию клиентам, подключающимся по MySQL протоколу (по умолчанию сообщает свою собственную версию).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
mysql_version_string = 5.0.37
```
<!-- end -->


### net_workers

Количество сетевых потоков, по умолчанию 1.

Эта настройка полезна при экстремально высоких скоростях запросов, когда одного потока недостаточно для обработки всего входящего трафика.


### net_wait_tm

Управляет интервалом цикла занятости сетевого потока. По умолчанию -1, может принимать значения -1, 0 или положительное целое число.

В случаях, когда сервер настроен как чистый мастер и просто маршрутизирует запросы к агентам, важно обрабатывать запросы без задержек и не допускать сон сетевого потока. Для этого существует busy loop. После входящего запроса сетевой поток использует CPU poll в течение `10 * net_wait_tm` миллисекунд, если `net_wait_tm` положительное число, или опрашивает только CPU, если `net_wait_tm` равен `0`. Также busy loop можно отключить с помощью `net_wait_tm = -1` — в этом случае poller устанавливает тайм-аут равным фактическим тайм-аутам агента при системном вызове poll.

> **ПРЕДУПРЕЖДЕНИЕ:** Цикл занятости CPU фактически загружает ядро процессора, поэтому установка этого значения в отличное от значения по умолчанию приведет к заметному использованию CPU даже при простое сервера.


### net_throttle_accept

Определяет, сколько клиентов принимается на каждой итерации сетевого цикла. По умолчанию 0 (без ограничений), что подходит для большинства пользователей. Это настройка тонкой настройки для контроля пропускной способности сетевого цикла при высокой нагрузке.


### net_throttle_action

Определяет, сколько запросов обрабатывается на каждой итерации сетевого цикла. По умолчанию 0 (без ограничений), что подходит для большинства пользователей. Это настройка тонкой настройки для контроля пропускной способности сетевого цикла при высокой нагрузке.

### network_timeout

<!-- example conf network_timeout -->
Тайм-аут чтения/записи клиентского запроса в сети, в секундах (или с использованием [special_suffixes](../Server_settings/Special_suffixes.md)). Необязательно, по умолчанию 5 секунд. `searchd` принудительно закрывает клиентское соединение, которое не успевает отправить запрос или получить результат в течение этого тайм-аута.

Обратите также внимание на параметр [reset_network_timeout_on_packet](../Server_settings/Searchd.md#reset_network_timeout_on_packet). Этот параметр изменяет поведение `network_timeout` — он применяется не к всему запросу или результату, а к отдельным пакетам. Обычно запрос/результат помещается в один или два пакета. Однако в случаях, когда требуется большой объем данных, этот параметр может оказаться бесценным для поддержания активных операций.

<!-- request Example -->

```ini
network_timeout = 10s
```
<!-- end -->

### node_address

<!-- example conf node_address -->
Этот параметр позволяет указать сетевой адрес узла. По умолчанию он установлен в адрес [listen](../Server_settings/Searchd.md#listen) для репликации. В большинстве случаев это правильно; однако бывают ситуации, когда необходимо указать его вручную:

* Узел за файрволом
* Включен сетевой трансляции адресов (NAT)
* Развертывания в контейнерах, таких как Docker или облачные развертывания
* Кластеры с узлами в нескольких регионах


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
node_address = 10.101.0.10
```
<!-- end -->

### not_terms_only_allowed

<!-- example conf not_terms_only_allowed -->
Этот параметр определяет, разрешать ли запросы с использованием только оператора отрицания [negation](../Searching/Full_text_matching/Operators.md#Negation-operator) полнотекстового поиска. Необязательно, по умолчанию 0 (запросы, содержащие только оператор NOT, отклоняются).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
not_terms_only_allowed = 1
```
<!-- end -->

### optimize_cutoff

<!-- example conf optimize_cutoff -->
Устанавливает порог слияния таблиц по умолчанию. Подробнее см. здесь — [Число оптимизированных дисковых чанков](../Securing_and_compacting_a_table/Compacting_a_table.md#Number-of-optimized-disk-chunks). Этот параметр можно переопределить с помощью опции запроса [cutoff](../Securing_and_compacting_a_table/Compacting_a_table.md#Number-of-optimized-disk-chunks). Также его можно изменить динамически через [SET GLOBAL](../Server_settings/Setting_variables_online.md#SET).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
optimize_cutoff = 4
```
<!-- end -->

### persistent_connections_limit

<!-- example conf persistent_connections_limit -->
Этот параметр определяет максимальное количество одновременных постоянных соединений с удалёнными [persistent agents](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md). Каждый раз, когда устанавливается соединение с агентом, определённым в `agent_persistent`, пытаемся переиспользовать существующее соединение (если оно есть) или установить и сохранить новое соединение для будущего использования. Однако иногда разумно ограничить количество таких постоянных соединений. Эта директива определяет такой лимит. Она влияет на количество соединений с хостом каждого агента по всем распределённым таблицам.

Логично установить значение равным или меньше опции [max_connections](../Server_settings/Searchd.md#max_connections) в конфиге агента.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
persistent_connections_limit = 29 # assume that each host of agents has max_connections = 30 (or 29).
```
<!-- end -->


### pid_file

<!-- example conf pid_file -->
pid_file — обязательный параметр конфигурации в Manticore search, который указывает путь к файлу, где хранится идентификатор процесса (PID) сервера `searchd`.

Файл с PID процесса searchd пересоздаётся и блокируется при запуске, содержит PID главного процесса сервера, пока сервер работает. При остановке сервера файл удаляется.
Цель этого файла — позволить Manticore выполнять различные внутренние задачи, такие как проверка, запущен ли уже экземпляр `searchd`, остановка `searchd` и уведомление о необходимости ротации таблиц. Файл также может использоваться внешними скриптами автоматизации.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
pid_file = /run/manticore/searchd.pid
```
<!-- end -->


### predicted_time_costs

<!-- example conf predicted_time_costs -->
Затраты для модели предсказания времени выполнения запроса, в наносекундах. Необязательно, по умолчанию `doc=64, hit=48, skip=2048, match=64`.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
predicted_time_costs = doc=128, hit=96, skip=4096, match=128
```
<!-- end -->

<!-- example conf predicted_time_costs 1 -->
Принудительное завершение запросов до их выполнения на основании максимального времени запроса — хорошая страховка, но у неё есть существенный недостаток: недетерминированные (нестабильные) результаты. То есть, если повторить один и тот же (сложный) поисковый запрос с ограничением по времени несколько раз, лимит времени будет достигнут на разных этапах, и вы получите *разные* наборы результатов.

<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
SELECT … OPTION max_query_time
```
<!-- request API -->

```api
SetMaxQueryTime()
```
<!-- end -->

Существует опция, [SELECT … OPTION max_predicted_time](../Searching/Options.md#max_predicted_time), которая позволяет ограничить время запроса *и* получить стабильные, воспроизводимые результаты. Вместо того, чтобы регулярно проверять фактическое текущее время во время выполнения запроса, что является неопределённым, она предсказывает текущее время выполнения с помощью простой линейной модели:

```ini
predicted_time =
    doc_cost * processed_documents +
    hit_cost * processed_hits +
    skip_cost * skiplist_jumps +
    match_cost * found_matches
```

Запрос при этом завершается досрочно, когда `predicted_time` достигает заданного лимита.

Разумеется, это не жёсткое ограничение по фактическому времени выполнения (однако жёсткое ограничение по объёму *обработанной* работы), и простая линейная модель отнюдь не является идеально точной. Поэтому фактическое время на часах *может* быть как ниже, так и выше целевого лимита. Тем не менее, погрешности вполне приемлемы: например, в наших экспериментах с целевым лимитом 100 мс большинство тестовых запросов попадало в диапазон 95–105 мс, и *все* запросы были в диапазоне 80–120 мс. Кроме того, как приятный побочный эффект, использование смоделированного времени запроса вместо измерения фактического ведёт к уменьшению количества вызовов gettimeofday().

Нет двух одинаковых моделей и марок серверов, поэтому директива `predicted_time_costs` позволяет вам настроить стоимости для приведённой выше модели. Для удобства они задаются целыми числами в наносекундах. (Лимит в max_predicted_time задаётся в миллисекундах, и указывать значения стоимости как 0.000128 мс вместо 128 нс более подвержено ошибкам.) Задавать все четыре стоимости одновременно не обязательно, пропущенные возьмут значения по умолчанию. Однако мы настоятельно рекомендуем установить все для лучшей читаемости.


### preopen_tables

<!-- example conf preopen_tables -->
Директива конфигурации preopen_tables задаёт, нужно ли принудительно предварительно открывать все таблицы при запуске. Значение по умолчанию — 1, что означает предварительное открытие всех таблиц независимо от настройки [preopen](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Other-performance-related-settings) для каждой таблицы. Если установить 0, будут действовать настройки для отдельных таблиц, которые по умолчанию равны 0.

Предварительное открытие таблиц помогает предотвратить гонки между поисковыми запросами и ротациями, которые могут изредка приводить к сбоям запросов. Однако это также увеличивает количество открытых файловых дескрипторов. В большинстве случаев рекомендуется использовать предварительное открытие таблиц.

Пример конфигурации:

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
preopen_tables = 1
```
<!-- end -->

### pseudo_sharding

<!-- example conf pseudo_sharding -->
Опция конфигурации pseudo_sharding включает параллелизацию поисковых запросов к локальным обычным и реальным таблицам, независимо от того, запрашиваются ли они напрямую или через распределённую таблицу. Эта функция автоматически параллелит запросы до числа потоков `searchd.threads`.

Обратите внимание, что если ваши рабочие потоки уже заняты из-за:
* высокой конкуренции запросов
* любого физического шардирования:
  - распределённая таблица из нескольких обычных/реальных таблиц
  - реальная таблица, состоящая из слишком большого количества дисковых чанков

то включение pseudo_sharding может не дать выгоды и даже слегка снизить пропускную способность. Если вы предпочитаете большую пропускную способность ценой большей задержки, рекомендуется отключить эту опцию.

По умолчанию включено.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
pseudo_sharding = 0
```
<!-- end -->


### replication_connect_timeout

Директива `replication_connect_timeout` задаёт таймаут подключения к удалённому узлу. По умолчанию значение предполагается в миллисекундах, но может иметь [другой суффикс](../Server_settings/Special_suffixes.md). Значение по умолчанию — 1000 (1 секунда).

При подключении к удалённому узлу Manticore будет ждать успешного соединения не более указанного времени. Если время истекает, а соединение не установлено, и включены `retries`, выполняется повторная попытка.


### replication_query_timeout

`replication_query_timeout` задаёт время ожидания ответа удалённого узла на выполнение запроса. Значение по умолчанию — 3000 миллисекунд (3 секунды), может иметь `суффикс` для указания другой единицы времени.

После установления соединения Manticore будет ждать ответ удалённого узла не более `replication_query_timeout`. Обратите внимание, что этот таймаут отличается от `replication_connect_timeout`, и общая возможная задержка со стороны удалённого узла будет суммой обоих значений.


### replication_retry_count

Данный параметр — целое число, задающее количество попыток подключения и запроса к удалённому узлу в процессе репликации до сообщения о фатальной ошибке запроса. Значение по умолчанию — 3.


### replication_retry_delay

Этот параметр — целое число в миллисекундах (или с [специальным суффиксом](../Server_settings/Special_suffixes.md)), задаёт задержку перед повторной попыткой запроса к удалённому узлу при сбое в репликации. Значение актуально только при ненулевом значении. Значение по умолчанию — 500.

### qcache_max_bytes

<!-- example conf qcache_max_bytes -->
Эта конфигурация задаёт максимальный объём ОЗУ, выделенный под кешированные наборы результатов, в байтах. Значение по умолчанию — 16777216, что эквивалентно 16 мегабайтам. Если значение равно 0, кеш запросов отключен. Подробнее о кеше запросов смотрите в разделе [query cache](../Searching/Query_cache.md).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
qcache_max_bytes = 16777216
```
<!-- end -->


### qcache_thresh_msec

Целое число в миллисекундах. Минимальный порог времени ответа для кеширования результата запроса. По умолчанию — 3000 (3 секунды). 0 означает кешировать все. Подробности смотрите в [query cache](../Searching/Query_cache.md). Значение может задаваться и со [специальным суффиксом времени](../Server_settings/Special_suffixes.md), но используйте это аккуратно, чтобы не запутаться с именем параметра, содержащим '_msec'.


### qcache_ttl_sec

Целое число, в секундах. Период истечения срока для кэшированного результата запроса. По умолчанию 60, или 1 минута. Минимальное возможное значение — 1 секунда. Смотрите подробности в разделе [кэш запросов](../Searching/Query_cache.md). Это значение также может быть выражено с использованием временных [специальных_суффиксов](../Server_settings/Special_suffixes.md), но используйте его осторожно и не путайте с названием самого значения, содержащим '_sec'.


### query_log_format

<!-- example conf query_log_format -->
Формат журнала запросов. Опционально, допустимые значения — `plain` и `sphinxql`, по умолчанию `sphinxql`.

Режим `sphinxql` логирует валидные SQL-запросы. Режим `plain` логирует запросы в текстовом формате (в основном подходит для чисто полнотекстовых случаев использования). Эта директива позволяет переключаться между двумя форматами при запуске поискового сервера. Формат журнала также можно изменять на лету, используя синтаксис `SET GLOBAL query_log_format=sphinxql`. Подробнее смотрите в разделе [Ведение журнала запросов](../Logging/Query_logging.md).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
query_log_format = sphinxql
```
<!-- end -->

### query_log_min_msec

Ограничение (в миллисекундах), которое предотвращает запись запроса в журнал запросов. Опционально, по умолчанию 0 (все запросы записываются в журнал запросов). Эта директива задаёт, что только запросы с временем выполнения, превышающим указанный порог, будут записываться в журнал (это значение также может быть выражено с использованием временных [специальных_суффиксов](../Server_settings/Special_suffixes.md), но используйте с осторожностью и не путайте с названием самого значения, содержащим `_msec`).

### query_log

<!-- example conf query_log -->
Имя файла журнала запросов. Опционально, по умолчанию пусто (запросы не логируются). Все поисковые запросы (например, SELECT ... но не INSERT/REPLACE/UPDATE) будут записываться в этот файл. Формат описан в разделе [Ведение журнала запросов](../Logging/Query_logging.md). В случае формата 'plain' можно использовать 'syslog' в качестве пути к файлу журнала. В этом случае все поисковые запросы будут отправляться демону syslog с приоритетом `LOG_INFO`, с префиксом '[query]' вместо временной метки. Для использования опции syslog, Manticore должен быть скомпилирован с параметром `-–with-syslog`.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
query_log = /var/log/query.log
```
<!-- end -->


### query_log_mode

<!-- example conf query_log_mode -->
Директива query_log_mode позволяет установить различные права доступа для файлов searchd и журнала запросов. По умолчанию эти журналы создаются с правами 600, что означает, что только пользователь, под которым запущен сервер, и root могут читать эти файлы.
Эта директива может быть полезна, если вы хотите разрешить другим пользователям читать журналы, например, решениям мониторинга, запущенным под не-root пользователями.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
query_log_mode  = 666
```
<!-- end -->

### read_buffer_docs

<!-- example conf read_buffer_docs -->
Директива read_buffer_docs контролирует размер буфера чтения на ключевое слово для списков документов. Для каждого вхождения ключевого слова в запросе есть два связанных буфера чтения: один для списка документов и один для списка попаданий. Этот параметр позволяет контролировать размер буфера списка документов.

Увеличенный размер буфера может повысить использование оперативной памяти на запрос, но потенциально снизить время ввода-вывода. Логично задавать большие значения для медленных хранилищ, а для хранилищ с высокой производительностью IOPS стоит экспериментировать с низкими значениями.

Значение по умолчанию 256K, минимальное — 8K. Также можно задавать [read_buffer_docs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#read_buffer_docs) на уровне каждой таблицы, что переопределит настройки на уровне сервера.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
read_buffer_docs = 128K
```
<!-- end -->


### read_buffer_hits

<!-- example conf read_buffer_hits -->
Директива read_buffer_hits задаёт размер буфера чтения на ключевое слово для списков попаданий в поисковых запросах. По умолчанию размер 256K, минимальное значение 8K. Для каждого вхождения ключевого слова в запросе есть два связанных буфера чтения: один для списка документов и один для списка попаданий. Увеличение размера буфера может повысить использование ОЗУ на запрос, но снизить время ввода-вывода. Для медленных хранилищ логично использовать большие размеры буферов, а для хранилищ с высокой производительностью IOPS стоит экспериментировать с низкими значениями.

Этот параметр также можно указать на уровне каждой таблицы через опцию [read_buffer_hits](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#read_buffer_hits), что переопределит настройку на уровне сервера.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
read_buffer_hits = 128K
```
<!-- end -->

### read_unhinted

<!-- example conf read_unhinted -->
Размер неуказанного чтения. Опционально, по умолчанию 32K, минимальное 1K.

При выполнении запроса некоторые чтения заранее точно знают, сколько данных нужно считать, а некоторые — нет. Особенно это касается размера списка попаданий, который сейчас не известен заранее. Этот параметр позволяет контролировать, сколько данных читать в таких случаях. Он влияет на время ввода-вывода для списков попаданий, уменьшая его для списков, больших чем размер неуказанного чтения, но увеличивая для меньших списков. Он **не** влияет на использование оперативной памяти, так как буфер чтения уже будет выделен. Поэтому не должен быть больше, чем read_buffer.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
read_unhinted = 32K
```
<!-- end -->

### reset_network_timeout_on_packet

<!-- example conf reset_network_timeout_on_packet -->
Уточняет поведение сетевых таймаутов (например, `network_timeout` и `agent_query_timeout`).

При значении 0 таймауты ограничивают максимальное время отправки всего запроса/запроса.
При значении 1 (по умолчанию) таймауты ограничивают максимальное время между сетевой активностью.

При репликации узлу может потребоваться отправить большой файл (например, 100 ГБ) другому узлу. Предположим, что сеть может передавать данные со скоростью 1 ГБ/с, с серией пакетов размером 4-5 МБ каждый. Для передачи всего файла потребуется 100 секунд. Таймаут по умолчанию 5 секунд позволит передать только 5 ГБ, после чего соединение будет разорвано. Увеличение таймаута может быть обходным решением, но оно не масштабируемо (например, следующий файл может быть 150 ГБ, что снова приведёт к сбою). Однако при установке параметра по умолчанию `reset_network_timeout_on_packet` в 1 таймаут применяется не ко всей передаче, а к отдельным пакетам. Пока передача продолжается (и данные действительно поступают по сети в течение периода таймаута), соединение остаётся активным. Если передача зависает и таймаут происходит между пакетами, соединение будет разорвано.

Обратите внимание, что при настройке распределённой таблицы каждый узел — как мастер, так и агенты — должен быть настроен. На стороне мастера действует параметр `agent_query_timeout`, на агентах — `network_timeout`.

<!-- intro -->

##### Пример:

<!-- request Example -->

```ini
reset_network_timeout_on_packet = 0
```

<!-- end -->


### rt_flush_period

<!-- example conf rt_flush_period -->
Период проверки сброса чанков RT таблиц в ОЗУ, в секундах (или с использованием [специальных суффиксов](../Server_settings/Special_suffixes.md)). Опционально, по умолчанию 10 часов.

Активно обновляемые RT таблицы, полностью помещающиеся в чанки ОЗУ, могут приводить к постоянно увеличивающимся бинарным логам, что влияет на использование диска и время восстановления после сбоя. С помощью этой директивы поисковый сервер выполняет периодические проверки для сброса, и подходящие чанки ОЗУ могут быть сохранены, что позволяет впоследствии очищать бинарные логи. Подробнее см. в разделе [Бинарное логирование](../Logging/Binary_logging.md).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
rt_flush_period = 3600 # 1 hour
```
<!-- end -->


### rt_merge_iops

<!-- example conf rt_merge_iops -->
Максимальное количество операций ввода-вывода (в секунду), которые поток слияния чанков RT таблиц может начать. Опционально, по умолчанию 0 (без ограничений).

Данная директива позволяет ограничить влияние операций ввода-вывода, связанных с операторами `OPTIMIZE`. Гарантируется, что все операции оптимизации RT не будут генерировать больше дисковых операций ввода-вывода (IOPS) в секунду, чем заданный лимит. Ограничение rt_merge_iops может уменьшить деградацию производительности поиска, вызванную слиянием.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
rt_merge_iops = 40
```
<!-- end -->

### rt_merge_maxiosize

<!-- example conf rt_merge_maxiosize -->
Максимальный размер операции ввода-вывода, который поток слияния чанков RT таблиц может начать. Опционально, по умолчанию 0 (без ограничений).

Данная директива позволяет снизить влияние операций ввода-вывода, связанных с операторами `OPTIMIZE`. Операции ввода-вывода, превышающие данный лимит, будут разбиты на две или более операций, которые затем учитываются как отдельные операции с точки зрения ограничения [rt_merge_iops](../Server_settings/Searchd.md#rt_merge_iops). Тем самым гарантируется, что все операции оптимизации не создадут более (rt_merge_iops * rt_merge_maxiosize) байт дискового ввода-вывода в секунду.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
rt_merge_maxiosize = 1M
```
<!-- end -->


### seamless_rotate

<!-- example conf seamless_rotate -->
Предотвращает зависания `searchd` при ротации таблиц с огромным количеством данных для предзагрузки в кэш. Опционально, по умолчанию 1 (включена бесшовная ротация). На Windows-системах бесшовная ротация по умолчанию отключена.

Таблицы могут содержать данные, которые необходимо предзагрузить в ОЗУ. В настоящее время файлы `.spa`, `.spb`, `.spi` и `.spm` полностью предзагружаются (они содержат данные атрибутов, данные блоб-атрибутов, таблицу ключевых слов и карту удалённых строк соответственно). Без бесшовной ротации ротация таблицы старается использовать как можно меньше ОЗУ и работает следующим образом:

1. Новые запросы временно отклоняются (с кодом ошибки "retry");
2. `searchd` ждёт завершения всех текущих запросов;
3. Старая таблица освобождается, её файлы переименовываются;
4. Новые файлы таблицы переименовываются, выделяется необходимая ОЗУ;
5. Новые атрибуты и данные словаря таблицы предзагружаются в ОЗУ;
6. `searchd` возобновляет обслуживание запросов из новой таблицы.

Однако если данных атрибутов или словаря много, этап предзагрузки может занять заметное время — до нескольких минут для файлов размером 1-5+ ГБ.

При включённой бесшовной ротации ротация происходит так:

1. Выделяется RAM-хранилище для новой таблицы;
2. Асинхронно предзагружаются атрибуты и данные словаря новой таблицы;
3. При успешной предзагрузке старая таблица освобождается, и файлы обеих таблиц переименовываются;
4. При неудаче новая таблица освобождается;
5. В любой момент запросы обслуживаются либо из старой, либо из новой копии таблицы.

Бесшовная ротация требует большего пикового объёма памяти во время ротации (поскольку обе копии данных `.spa/.spb/.spi/.spm` — старая и новая — должны находиться в ОЗУ при предзагрузке новой копии). Среднее использование памяти остаётся прежним.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
seamless_rotate = 1
```
<!-- end -->

### secondary_index_block_cache
<!-- example conf secondary_index_block_cache -->

Этот параметр задаёт размер кэша блоков, используемых вторичными индексами. Опционально, по умолчанию 8 МБ. Вторичные индексы при работе с фильтрами, содержащими множество значений (например, фильтры IN()), читают и обрабатывают метаданные блоков для этих значений.
В объединённых запросах этот процесс повторяется для каждой партии строк из левой таблицы, и каждая партия может повторно считывать одни и те же метаданные в рамках одного объединённого запроса. Это может существенно влиять на производительность. Кэш блоков метаданных хранит эти блоки в памяти, чтобы они
могли повторно использоваться последующими партиями.

Кэш используется только в объединённых запросах и не влияет на обычные (необъединённые) запросы. Обратите внимание, что ограничение размера кэша применяется на каждый атрибут и на каждый вторичный индекс. Каждый атрибут в каждом дисковом чанке работает в пределах этого ограничения. В худшем случае общий объём
используемой памяти можно оценить, умножив лимит на количество дисковых чанков и количество атрибутов, используемых в объединённых запросах.

Установка `secondary_index_block_cache = 0` отключает кэш.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
secondary_index_block_cache = 16M
```

<!-- end -->

### secondary_indexes
<!-- example conf secondary_indexes -->

This option enables/disables the use of secondary indexes for search queries. It is optional, and the default is 1 (enabled). Note that you don't need to enable it for indexing as it is always enabled as long as the [Manticore Columnar Library](https://github.com/manticoresoftware/columnar) is installed. The latter is also required for using the indexes when searching. There are three modes available:

* `0`: Disable the use of secondary indexes on search. They can be enabled for individual queries using [analyzer hints](../Searching/Options.md#Query-optimizer-hints)
* `1`: Enable the use of secondary indexes on search. They can be disabled for individual queries using [analyzer hints](../Searching/Options.md#Query-optimizer-hints)
* `force`: Same as enable, but any errors during the loading of secondary indexes will be reported, and the whole index will not be loaded into the daemon.

<!-- intro -->
##### Example:

<!-- request Example -->

```ini
secondary_indexes = 1
```

<!-- end -->

### server_id

<!-- example conf server_id -->
Integer number that serves as a server identifier used as a seed to generate a unique short UUID for nodes that are part of a replication cluster. The server_id must be unique across the nodes of a cluster and in the range from 0 to 127. If server_id is not set, it is calculated as a hash of the MAC address and the path to the PID file or a random number will be used as a seed for the short UUID.


<!-- intro -->
##### Example:

<!-- request Example -->

```ini
server_id = 1
```
<!-- end -->


### shutdown_timeout

<!-- example conf shutdown_timeout -->
`searchd --stopwait` waiting time, in seconds (or [special_suffixes](../Server_settings/Special_suffixes.md)). Optional, default is 60 seconds.

When you run `searchd --stopwait` your server needs to perform some activities before stopping, such as finishing queries, flushing RT RAM chunks, flushing attributes, and updating the binlog. These tasks require some time. `searchd --stopwait` will wait up to `shutdown_time` seconds for the server to finish its jobs. The suitable time depends on your table size and load.


<!-- intro -->
##### Example:

<!-- request Example -->

```ini
shutdown_timeout = 3m # wait for up to 3 minutes
```
<!-- end -->


### shutdown_token

SHA1 hash of the password required to invoke the 'shutdown' command from a VIP Manticore SQL connection. Without it,[debug](../Reporting_bugs.md#DEBUG) 'shutdown' subcommand will never cause the server to stop. Note that such simple hashing should not be considered strong protection, as we don't use a salted hash or any kind of modern hash function. It is intended as a fool-proof measure for housekeeping daemons in a local network.

### snippets_file_prefix

<!-- example conf snippets_file_prefix -->
A prefix to prepend to the local file names when generating snippets. Optional, default is the current working folder.

This prefix can be used in distributed snippets generation along with `load_files` or `load_files_scattered` options.

Note that this is a prefix and **not** a path! This means that if a prefix is set to "server1" and the request refers to "file23", `searchd` will attempt to open "server1file23" (all of that without quotes). So, if you need it to be a path, you have to include the trailing slash.

After constructing the final file path, the server unwinds all relative dirs and compares the final result with the value of `snippet_file_prefix`. If the result does not begin with the prefix, such a file will be rejected with an error message.

For example, if you set it to `/mnt/data` and someone calls snippet generation with the file `../../../etc/passwd` as the source, they will get the error message:

`File '/mnt/data/../../../etc/passwd' escapes '/mnt/data/' scope`

instead of the content of the file.

Also, with a non-set parameter and reading `/etc/passwd`, it will actually read /daemon/working/folder/etc/passwd since the default for the parameter is the server's working folder.

Note also that this is a local option; it does not affect the agents in any way. So you can safely set a prefix on a master server. The requests routed to the agents will not be affected by the master's setting. They will, however, be affected by the agent's own settings.

This might be useful, for instance, when the document storage locations (whether local storage or NAS mountpoints) are inconsistent across the servers.


<!-- intro -->
##### Example:

<!-- request Example -->

```ini
snippets_file_prefix = /mnt/common/server1/
```
<!-- end -->

> **WARNING:** If you still want to access files from the FS root, you have to explicitly set `snippets_file_prefix` to empty value (by `snippets_file_prefix=` line), or to root (by `snippets_file_prefix=/`).


### sphinxql_state

<!-- example conf sphinxql_state -->
Path to a file where the current SQL state will be serialized.

On server startup, this file gets replayed. On eligible state changes (e.g., SET GLOBAL), this file gets rewritten automatically. This can prevent a hard-to-diagnose problem: If you load UDF functions but Manticore crashes, when it gets (automatically) restarted, your UDF and global variables will no longer be available. Using persistent state helps ensure a graceful recovery with no such surprises.

`sphinxql_state` cannot be used to execute arbitrary commands, such as `CREATE TABLE`.

<!-- intro -->
##### Example:

<!-- request Example -->

```ini
sphinxql_state = uservars.sql
```
<!-- end -->


### sphinxql_timeout

<!-- example conf sphinxql_timeout -->
Maximum time to wait between requests (in seconds, or [special_suffixes](../Server_settings/Special_suffixes.md)) when using the SQL interface. Optional, default is 15 minutes.


<!-- intro -->
##### Example:

<!-- request Example -->

```ini
sphinxql_timeout = 15m
```
<!-- end -->


### ssl_ca

<!-- example conf ssl_ca -->
Path to the SSL Certificate Authority (CA) certificate file (also known as root certificate). Optional, default is empty. When not empty, the certificate in `ssl_cert` should be signed by this root certificate.

Сервер использует файл CA для проверки подписи на сертификате. Файл должен быть в формате PEM.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ssl_ca = keys/ca-cert.pem
```
<!-- end -->


### ssl_cert

<!-- example conf ssl_cert -->
Путь к SSL-сертификату сервера. Опционально, по умолчанию пусто.

Сервер использует этот сертификат как самоподписанный открытый ключ для шифрования HTTP-трафика через SSL. Файл должен быть в формате PEM.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ssl_cert = keys/server-cert.pem
```
<!-- end -->


### ssl_key

<!-- example conf ssl_key -->
Путь к ключу SSL-сертификата. Опционально, по умолчанию пусто.

Сервер использует этот приватный ключ для шифрования HTTP-трафика через SSL. Файл должен быть в формате PEM.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ssl_key = keys/server-key.pem
```
<!-- end -->


### subtree_docs_cache

<!-- example conf subtree_docs_cache -->
Максимальный размер кеша документов общего поддерева на запрос. Опционально, по умолчанию 0 (отключено).

Этот параметр ограничивает использование оперативной памяти оптимизатором общего поддерева (см. [multi-queries](../Searching/Multi-queries.md)). Максимум столько ОЗУ будет потрачено на кеширование записей документов для каждого запроса. Установка лимита в 0 отключает оптимизатор.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
subtree_docs_cache = 8M
```
<!-- end -->


### subtree_hits_cache

<!-- example conf subtree_hits_cache -->
Максимальный размер кеша вхождений общего поддерева на запрос. Опционально, по умолчанию 0 (отключено).

Этот параметр ограничивает использование оперативной памяти оптимизатором общего поддерева (см. [multi-queries](../Searching/Multi-queries.md)). Максимум столько ОЗУ будет потрачено на кеширование вхождений ключевых слов (hits) для каждого запроса. Установка лимита в 0 отключает оптимизатор.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
subtree_hits_cache = 16M
```
<!-- end -->

### threads

<!-- example threads -->
Количество рабочих потоков (или размер пула потоков) для демона Manticore. Manticore создаёт такое количество потоков ОС при запуске, и они выполняют все задачи внутри демона, такие как выполнение запросов, создание сниппетов и т.д. Некоторые операции могут быть разбиты на подзадачи и выполнены параллельно, например:

* Поиск в таблице реального времени
* Поиск в распределённой таблице, состоящей из локальных таблиц
* Вызов перколирования запроса
* и другие

По умолчанию установлено количество потоков равное количеству ядер процессора на сервере. Manticore создаёт потоки при запуске и удерживает их до остановки. Каждая подзадача может использовать один из потоков, когда это нужно. Когда подзадача завершается, поток освобождается для использования другой подзадачей.

В случае интенсивной нагрузки типа ввода-вывода может иметь смысл установить значение выше количества ядер процессора.

<!-- request Example -->
```ini
threads = 10
```

<!-- end -->

### thread_stack

<!-- example conf thread_stack -->
Максимальный размер стека для задачи (корутина, один поисковый запрос может создавать несколько задач/корутин). Опционально, по умолчанию 128K.

У каждой задачи собственный стек размером 128K. При выполнении запроса проверяется, сколько стека он требует. Если 128K достаточно, задача просто обрабатывается. Если требуется больше, планируется другая задача с увеличенным стеком, которая продолжает обработку. Максимальный размер такого увеличенного стека ограничен этим параметром.

Установка значения на разумно высоком уровне поможет при обработке очень глубоких запросов без значительного увеличения общего потребления ОЗУ. Например, установка 1G не означает, что каждая новая задача будет занимать 1G ОЗУ, а лишь то, что если нужно, например, 100M стека, выделяется именно 100M для задачи. Другие задачи одновременно выполняются с их стандартным стеком 128K. Таким же образом можно выполнять более сложные запросы, требующие 500M. И только если **видим** внутренне, что задача требует стека более 1G, будет ошибка и сообщение о слишком маленьком параметре thread_stack.

Тем не менее на практике даже запросы, требующие 16M стека, часто слишком сложны для парсинга и занимают слишком много времени и ресурсов для обработки. Поэтому демон обработает их, но ограничение таких запросов параметром `thread_stack` выглядит вполне разумным.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
thread_stack = 8M
```
<!-- end -->


### unlink_old

<!-- example conf unlink_old -->
Определяет, следует ли удалять (unlink) копии таблиц с расширением `.old` после успешного ротации. Опционально, по умолчанию 1 (удалять).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
unlink_old = 0
```
<!-- end -->


### watchdog

<!-- example conf watchdog -->
Поточечный сторож сервера. Опционально, по умолчанию 1 (сторож включён).

Когда запрос Manticore аварийно завершает работу, он может привести к падению всего сервера. При включённой функции сторожа `searchd` поддерживает отдельный лёгкий процесс, который следит за основным процессом сервера и автоматически перезапускает его в случае аномального завершения. Сторож включен по умолчанию.

<!-- request Example -->

```ini
watchdog = 0 # disable watchdog
```
<!-- end -->
<!-- proofread -->
