# Раздел "Searchd" в конфигурации

Приведенные ниже настройки используются в разделе `searchd` файла конфигурации Manticore Search для управления поведением сервера. Ниже приведено краткое описание каждой настройки:

### access_plain_attrs

Эта настройка устанавливает глобальные значения по умолчанию для [access_plain_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `mmap_preread`.

Директива `access_plain_attrs` позволяет определить значение по умолчанию для [access_plain_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых данным экземпляром searchd. Директивы на уровне таблицы имеют более высокий приоритет и переопределяют это глобальное значение по умолчанию, обеспечивая более детальный контроль.

### access_blob_attrs

Эта настройка устанавливает глобальные значения по умолчанию для [access_blob_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `mmap_preread`.

Директива `access_blob_attrs` позволяет определить значение по умолчанию для [access_blob_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых данным экземпляром searchd. Директивы на уровне таблицы имеют более высокий приоритет и переопределяют это глобальное значение по умолчанию, обеспечивая более детальный контроль.

### access_doclists

Эта настройка устанавливает глобальные значения по умолчанию для [access_doclists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `file`.

Директива `access_doclists` позволяет определить значение по умолчанию для [access_doclists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых данным экземпляром searchd. Директивы на уровне таблицы имеют более высокий приоритет и переопределяют это глобальное значение по умолчанию, обеспечивая более детальный контроль.

### access_hitlists

Эта настройка устанавливает глобальные значения по умолчанию для [access_hitlists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `file`.

Директива `access_hitlists` позволяет определить значение по умолчанию для [access_hitlists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых данным экземпляром searchd. Директивы на уровне таблицы имеют более высокий приоритет и переопределяют это глобальное значение по умолчанию, обеспечивая более детальный контроль.

### access_dict

Эта настройка устанавливает глобальные значения по умолчанию для [access_dict](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `mmap_preread`.

Директива `access_dict` позволяет определить значение по умолчанию для [access_dict](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых данным экземпляром searchd. Директивы на уровне таблицы имеют более высокий приоритет и переопределяют это глобальное значение по умолчанию, обеспечивая более детальный контроль.

### agent_connect_timeout

Эта настройка устанавливает глобальные значения по умолчанию для параметра [agent_connect_timeout](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_connect_timeout).


### agent_query_timeout

Эта настройка устанавливает глобальные значения по умолчанию для параметра [agent_query_timeout](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_query_timeout). Она может быть переопределена для отдельного запроса с помощью предложения `OPTION agent_query_timeout=XXX`.


### agent_retry_count

Эта настройка представляет собой целое число, которое указывает, сколько раз Manticore будет пытаться подключиться и выполнить запрос к удаленным агентам через распределенную таблицу, прежде чем сообщить о фатальной ошибке запроса. Значение по умолчанию — 0 (т.е. без повторных попыток). Это значение также можно установить для отдельного запроса с помощью предложения `OPTION retry_count=XXX`. Если указана опция для запроса, она переопределит значение, указанное в конфигурации.

Обратите внимание, что если в определении вашей распределенной таблицы используются [зеркала агентов](../Creating_a_cluster/Remote_nodes/Mirroring.md#Agent-mirrors), сервер будет выбирать другое зеркало для каждой попытки подключения в соответствии с выбранной [ha_strategy](../Creating_a_cluster/Remote_nodes/Load_balancing.md#ha_strategy). В этом случае значение `agent_retry_count` будет агрегировано для всех зеркал в наборе.

Например, если у вас есть 10 зеркал и установлено `agent_retry_count=5`, сервер выполнит до 50 повторных попыток, предполагая в среднем по 5 попыток для каждого из 10 зеркал (при опции `ha_strategy = roundrobin` так и будет).

Однако значение, указанное в качестве опции `retry_count` для [агента](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent), служит абсолютным ограничением. Другими словами, опция `[retry_count=2]` в определении агента всегда означает максимум 2 попытки, независимо от того, указали вы для агента 1 или 10 зеркал.

### agent_retry_delay

Эта настройка представляет собой целое число в миллисекундах (или с [специальными суффиксами](../Server_settings/Special_suffixes.md)), которое указывает задержку перед повторной попыткой запроса к удаленному агенту в случае сбоя. Это значение актуально только при указании ненулевого значения [agent_retry_count](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md) или ненулевого значения `retry_count` для запроса. Значение по умолчанию — 500. Это значение также можно установить для отдельного запроса с помощью предложения `OPTION retry_delay=XXX`. Если указана опция для запроса, она переопределит значение, указанное в конфигурации.


### attr_flush_period

<!-- example conf attr_flush_period -->
При использовании [Update](../Data_creation_and_modification/Updating_documents/UPDATE.md) для изменения атрибутов документов в реальном времени, изменения сначала записываются в копию атрибутов в памяти. Эти обновления происходят в файле, отображаемом в память, что означает, что операционная система решает, когда записать изменения на диск. При нормальном завершении работы `searchd` (вызванном сигналом `SIGTERM`) все изменения принудительно записываются на диск.

Вы также можете указать `searchd` периодически записывать эти изменения обратно на диск, чтобы предотвратить потерю данных. Интервал между этими сбросами определяется параметром `attr_flush_period`, указываемым в секундах (или с использованием [специальных суффиксов](../Server_settings/Special_suffixes.md)).

По умолчанию значение равно 0, что отключает периодический сброс. Однако сброс всё равно произойдет при нормальном завершении работы.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
attr_flush_period = 900 # persist updates to disk every 15 minutes
```
<!-- end -->

### auto_optimize

<!-- example conf auto_optimize -->
Эта настройка управляет автоматическим процессом [OPTIMIZE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE) для уплотнения таблицы.

По умолчанию уплотнение таблицы происходит автоматически. Вы можете изменить это поведение с помощью настройки `auto_optimize`:
* 0 для отключения автоматического уплотнения таблицы (вы всё равно можете вызывать `OPTIMIZE` вручную)
* 1 для явного включения
* для включения с одновременным умножением порога оптимизации на 2.

По умолчанию OPTIMIZE выполняется до тех пор, пока количество дисковых чанков не станет меньше или равно количеству логических ядер ЦП, умноженному на 2.

Однако, если таблица имеет атрибуты с KNN-индексами, этот порог отличается. В этом случае он устанавливается равным количеству физических ядер ЦП, делённому на 2, для повышения производительности KNN-поиска.

Обратите внимание, что включение или отключение `auto_optimize` не мешает вам запускать [OPTIMIZE TABLE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE) вручную.

<!-- intro -->
##### Пример:

<!-- request Disable -->
```ini
auto_optimize = 0 # disable automatic OPTIMIZE
```

<!-- request Throttle -->
```ini
auto_optimize = 2 # OPTIMIZE starts at 16 chunks (on 4 cpu cores server)
```

<!-- end -->

### parallel_chunk_merges

<!-- example conf parallel_chunk_merges -->
Эта настройка определяет, сколько заданий слияния дисковых чанков серверу разрешено выполнять параллельно во время [OPTIMIZE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE) для таблиц реального времени.

Это влияет только на слияние дисковых чанков (уплотнение), а не на параллелизм запросов.

Установите значение `1`, чтобы отключить параллельное слияние чанков (задания слияния будут выполняться одно за другим). Более высокие значения могут ускорить уплотнение на системах с быстрым хранилищем, но увеличат одновременный ввод-вывод на диск.

По умолчанию используется значение `max(1, min(2, threads/2))`.

Это значение можно изменить во время выполнения с помощью `SET GLOBAL parallel_chunk_merges = N` и проверить через `SHOW VARIABLES`.

<!-- intro -->
##### Пример:

<!-- request Disable -->
```ini
parallel_chunk_merges = 1
```

<!-- request Increase -->
```ini
parallel_chunk_merges = 4
```

<!-- end -->

### merge_chunks_per_job

<!-- example conf merge_chunks_per_job -->
Эта настройка определяет, сколько дисковых чанков RT объединяется в одном задании OPTIMIZE (N-стороннее слияние). Если доступно меньше этого числа, задание объединит то, что может (минимум 2).

Более низкие значения позволяют планировать больше заданий параллельно; более высокие значения уменьшают количество заданий, но увеличивают размер каждого слияния.

По умолчанию используется значение `2`.

Это значение можно изменить во время выполнения с помощью `SET GLOBAL merge_chunks_per_job = N` и проверить через `SHOW VARIABLES`.

<!-- intro -->
##### Пример:

<!-- request Increase -->
```ini
merge_chunks_per_job = 4
```

<!-- end -->

### auto_schema

<!-- example conf auto_schema -->
Manticore поддерживает автоматическое создание таблиц, которые ещё не существуют, но указаны в операторах INSERT. Эта функция включена по умолчанию. Чтобы отключить её, явно установите `auto_schema = 0` в вашей конфигурации. Чтобы снова включить, установите `auto_schema = 1` или удалите настройку `auto_schema` из конфигурации.

Имейте в виду, что HTTP-эндпоинт `/bulk` не поддерживает автоматическое создание таблиц.

> ПРИМЕЧАНИЕ: Функция [автоматической схемы](../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md#Auto-schema) требует наличия [Manticore Buddy](../Installation/Manticore_Buddy.md). Если она не работает, убедитесь, что Buddy установлен.

<!-- request Disable -->
```ini
auto_schema = 0 # disable automatic table creation
```

<!-- request Enable -->
```ini
auto_schema = 1 # enable automatic table creation
```

<!-- end -->

### binlog_flush

<!-- example conf binlog_flush -->
Эта настройка управляет режимом сброса/синхронизации транзакций бинарного лога. Она является необязательной, по умолчанию используется значение 2 (сброс каждой транзакции, синхронизация каждую секунду).

Директива определяет, как часто бинарный лог будет сбрасываться в ОС и синхронизироваться с диском. Поддерживаются три режима:

*  0, сброс и синхронизация каждую секунду. Это обеспечивает наилучшую производительность, но до 1 секунды зафиксированных транзакций может быть потеряно в случае сбоя сервера или сбоя ОС/оборудования.
*  1, сброс и синхронизация каждой транзакции. Этот режим обеспечивает наихудшую производительность, но гарантирует сохранение данных каждой зафиксированной транзакции.
*  2, сброс каждой транзакции, синхронизация каждую секунду. Этот режим обеспечивает хорошую производительность и гарантирует сохранение каждой зафиксированной транзакции в случае сбоя сервера. Однако в случае сбоя ОС/оборудования может быть потеряно до 1 секунды зафиксированных транзакций.

Для тех, кто знаком с MySQL и InnoDB, эта директива аналогична `innodb_flush_log_at_trx_commit`. В большинстве случаев гибридный режим по умолчанию 2 обеспечивает хороший баланс скорости и безопасности, с полной защитой данных RT-таблиц от сбоев сервера и некоторой защитой от аппаратных сбоев.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_flush = 1 # ultimate safety, low speed
```
<!-- end -->

### binlog_common

<!-- example conf binlog_common -->
Эта настройка управляет тем, как управляются файлы бинарного лога. Она является необязательной, по умолчанию используется значение 0 (отдельный файл для каждой таблицы).

Вы можете выбрать между двумя способами управления файлами бинарного лога:

* Отдельный файл для каждой таблицы (по умолчанию, `0`): Каждая таблица сохраняет свои изменения в собственном лог-файле. Такая настройка хороша, если у вас много таблиц, которые обновляются в разное время. Она позволяет обновлять таблицы, не дожидаясь других. Кроме того, если возникнет проблема с лог-файлом одной таблицы, это не затронет остальные.
* Один файл для всех таблиц (`1`): Все таблицы используют один и тот же бинарный лог-файл. Этот метод упрощает управление файлами, потому что их меньше. Однако это может сохранять файлы дольше, чем необходимо, если одной таблице всё ещё нужно сохранять свои обновления. Эта настройка также может замедлить работу, если многие таблицы должны обновляться одновременно, потому что все изменения должны ждать записи в один файл.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_common = 1 # use a single binary log file for all tables
```
<!-- end -->

### binlog_max_log_size

<!-- example conf binlog_max_log_size -->
Эта настройка определяет максимальный размер бинарного лог-файла. Она является необязательной, значение по умолчанию — 256 МБ.

Новый binlog-файл будет принудительно открыт, как только текущий binlog-файл достигнет этого ограничения по размеру. Это приводит к более мелкой гранулярности логов и может обеспечить более эффективное использование диска для binlog при определённых пограничных нагрузках. Значение 0 указывает, что binlog-файл не должен переоткрываться на основе размера.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_max_log_size = 16M
```
<!-- end -->


### binlog_path

<!-- example conf binlog_path -->
Эта настройка определяет путь к файлам бинарного лога (также известного как лог транзакций). Она является необязательной, значение по умолчанию — настроенный во время сборки каталог данных (например, `/var/lib/manticore/data/binlog.*` в Linux).

Бинарные логи используются для восстановления после сбоев данных RT-таблиц и для обновления атрибутов обычных дисковых индексов, которые в противном случае хранились бы только в оперативной памяти до сброса на диск. При включённом логировании каждая транзакция, зафиксированная (COMMIT) в RT-таблице, записывается в лог-файл. Затем логи автоматически воспроизводятся при запуске после некорректного завершения работы, восстанавливая залогированные изменения.

Директива `binlog_path` указывает расположение файлов бинарного лога. Она должна содержать только путь; `searchd` создаст и удалит несколько файлов `binlog.*` в каталоге по мере необходимости (включая файлы данных binlog, метаданные, lock-файлы и т.д.).

Пустое значение отключает бинарное логирование, что повышает производительность, но подвергает данные RT-таблиц риску.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_path = # disable logging
binlog_path = /var/lib/manticore/data # /var/lib/manticore/data/binlog.001 etc will be created
```
<!-- end -->

### boolean_simplify

<!-- example conf boolean_simplify -->
Эта настройка управляет значением по умолчанию для опции поиска [boolean_simplify](../Searching/Options.md#boolean_simplify). Она является необязательной, значение по умолчанию — 1 (включено).

Если установлено значение 1, сервер автоматически применит [оптимизацию булевых запросов](../Searching/Full_text_matching/Boolean_optimization.md) для повышения производительности запросов. Если установлено значение 0, запросы по умолчанию будут выполняться без оптимизации. Это значение по умолчанию может быть переопределено для каждого запроса с помощью соответствующей опции поиска `boolean_simplify`.

<!-- request Example -->
```ini
searchd {
    boolean_simplify = 0  # disable boolean optimization by default
}
```
<!-- end -->

### buddy_path

<!-- example conf buddy_path -->
Эта настройка определяет путь к бинарному файлу Manticore Buddy. Она является необязательной, значение по умолчанию — настроенный во время сборки путь, который различается в разных операционных системах. Обычно вам не нужно изменять эту настройку. Однако она может быть полезной, если вы хотите запустить Manticore Buddy в режиме отладки, внести изменения в Manticore Buddy или реализовать новый плагин. В последнем случае вы можете выполнить `git clone` Buddy с https://github.com/manticoresoftware/manticoresearch-buddy, добавить новый плагин в каталог `./plugins/` и запустить `composer install --prefer-source` для упрощения разработки после перехода в исходный каталог Buddy.

Чтобы иметь возможность запускать `composer`, на вашей машине должна быть установлена PHP версии 8.2 или выше со следующими расширениями:

```
--enable-dom
--with-libxml
--enable-tokenizer
--enable-xml
--enable-xmlwriter
--enable-xmlreader
--enable-simplexml
--enable-phar
--enable-bcmath
--with-gmp
--enable-debug
--with-mysqli
--enable-mysqlnd
```

Вы также можете выбрать специальную версию `manticore-executor-dev` для Linux amd64, доступную в релизах, например: https://github.com/manticoresoftware/executor/releases/tag/v1.0.13

Если вы выберете этот путь, не забудьте связать dev-версию manticore executor с `/usr/bin/php`.

Чтобы отключить Manticore Buddy, установите значение пустым, как показано в примере.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
buddy_path = manticore-executor -n /usr/share/manticore/modules/manticore-buddy/src/main.php # use the default Manticore Buddy in Linux
buddy_path = manticore-executor -n /usr/share/manticore/modules/manticore-buddy/src/main.php --threads=1 # runs Buddy with a single worker
buddy_path = manticore-executor -n /opt/homebrew/share/manticore/modules/manticore-buddy/bin/manticore-buddy/src/main.php # use the default Manticore Buddy in MacOS arm64
buddy_path = manticore-executor -n /Users/username/manticoresearch-buddy/src/main.php # use Manticore Buddy from a non-default location
buddy_path = # disables Manticore Buddy
buddy_path = manticore-executor -n /Users/username/manticoresearch-buddy/src/main.php --skip=manticoresoftware/buddy-plugin-replace # --skip - skips plugins
buddy_path = manticore-executor -n /usr/share/manticore/modules/manticore-buddy/src/main.php --enable-plugin=manticoresoftware/buddy-plugin-show # runs Buddy with only the SHOW plugin
```
<!-- end -->

### client_timeout

<!-- example conf client_timeout -->
Эта настройка определяет максимальное время ожидания между запросами (в секундах или с [специальными суффиксами](../Server_settings/Special_suffixes.md)) при использовании постоянных соединений. Она является необязательной, значение по умолчанию — пять минут.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
client_timeout = 1h
```
<!-- end -->


### collation_libc_locale

<!-- example conf collation_libc_locale -->
Локаль libc сервера. Необязательная, по умолчанию C.

Определяет локаль libc, влияющую на сортировки на основе libc. Подробности см. в разделе [collations](../Searching/Collations.md).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
collation_libc_locale = fr_FR
```
<!-- end -->


### collation_server

<!-- example conf collation_server -->
Сортировка сервера по умолчанию. Необязательная, по умолчанию libc_ci.

Определяет сортировку по умолчанию, используемую для входящих запросов. Сортировка может быть переопределена для каждого запроса. Список доступных сортировок и другие детали см. в разделе [collations](../Searching/Collations.md).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
collation_server = utf8_ci
```
<!-- end -->


### data_dir

<!-- example conf data_dir -->
При указании эта настройка включает [режим реального времени](../Creating_a_table/Local_tables.md#Online-schema-management-%28RT-mode%29), который является императивным способом управления схемой данных. Значение должно быть путем к каталогу, в котором вы хотите хранить все ваши таблицы, бинарные логи и все остальное, необходимое для правильного функционирования Manticore Search в этом режиме.
Индексирование [обычных таблиц](../Creating_a_table/Local_tables/Plain_table.md) не разрешено, когда указан `data_dir`. Подробнее о разнице между режимом RT и обычным режимом читайте в [этом разделе](../Read_this_first.md#Real-time-table-vs-plain-table).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
data_dir = /var/lib/manticore
```
<!-- end -->

### attr_autoconv_strict

<!-- example conf attr_autoconv_strict -->
Эта настройка управляет режимом строгой проверки для преобразований строк в числа во время операций INSERT и REPLACE. Необязательная, по умолчанию 0 (нестрогий режим, обратно совместимый).

Когда установлено значение 1 (строгий режим), недопустимые преобразования строк в числа (например, преобразование пустой строки `''` или нечисловой строки `'a'` в атрибут bigint) будут возвращать ошибки вместо тихого преобразования в 0. Это помогает выявлять проблемы с качеством данных на раннем этапе во время вставки данных.

Когда установлено значение 0 (нестрогий режим, по умолчанию), недопустимые преобразования будут тихо преобразовываться в 0, сохраняя обратную совместимость со старыми версиями.

Строгий режим проверяет следующие случаи:
* Пустые строки или строки, которые не могут быть преобразованы
* Строки с завершающими нечисловыми символами (например, `'123abc'`)
* Числовые значения, превышающие диапазоны типа (переполнение/недополнение)

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
attr_autoconv_strict = 1  # enable strict conversion mode
```
<!-- end -->

### diskchunk_flush_search_timeout

<!-- example conf diskchunk_flush_search_timeout -->
Таймаут для предотвращения автоматической сброски RAM-чанка, если в таблице не было поисковых запросов. Необязательный, по умолчанию 30 секунд.

Время проверки наличия поисковых запросов перед определением необходимости автоматической сброски.
Автоматическая сброска произойдет только в том случае, если в таблице был хотя бы один поисковый запрос за последние `diskchunk_flush_search_timeout` секунд. Работает совместно с [diskchunk_flush_write_timeout](../Server_settings/Searchd.md#diskchunk_flush_write_timeout). Соответствующая [настройка на уровне таблицы](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#diskchunk_flush_search_timeout) имеет более высокий приоритет и переопределит это значение по умолчанию для всего экземпляра, обеспечивая более детальный контроль.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
diskchunk_flush_search_timeout = 120s
```
<!-- end -->

### diskchunk_flush_write_timeout

<!-- example conf diskchunk_flush_write_timeout -->
Время в секундах ожидания без операции записи перед автоматической сброской RAM-чанка на диск. Необязательный, по умолчанию 1 секунда.

Если в RAM-чанке не происходит операций записи в течение `diskchunk_flush_write_timeout` секунд, чанк будет сброшен на диск. Работает совместно с [diskchunk_flush_search_timeout](../Server_settings/Searchd.md#diskchunk_flush_search_timeout). Чтобы отключить автоматическую сброску, явно установите `diskchunk_flush_write_timeout = -1` в вашей конфигурации. Соответствующая [настройка на уровне таблицы](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#diskchunk_flush_write_timeout) имеет более высокий приоритет и переопределит это значение по умолчанию для всего экземпляра, обеспечивая более детальный контроль.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
diskchunk_flush_write_timeout = 60s
```
<!-- end -->

### docstore_cache_size

<!-- example conf docstore_cache_size -->
Эта настройка определяет максимальный размер блоков документов из хранилища документов, которые хранятся в памяти. Необязательная, значение по умолчанию 16m (16 мегабайт).

Когда используется `stored_fields`, блоки документов считываются с диска и распаковываются. Поскольку каждый блок обычно содержит несколько документов, он может быть повторно использован при обработке следующего документа. Для этой цели блок хранится в кэше на уровне сервера. Кэш содержит распакованные блоки.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
docstore_cache_size = 8m
```
<!-- end -->

### engine

<!-- example conf engine -->
Движок хранения атрибутов по умолчанию, используемый при создании таблиц в режиме RT. Может быть `rowwise` (по умолчанию) или `columnar`.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
engine = columnar
```
<!-- end -->


### expansion_limit

<!-- example conf expansion_limit -->
Эта настройка определяет максимальное количество расширенных ключевых слов для одного подстановочного знака. Необязательная, значение по умолчанию 0 (без ограничений).

При выполнении поиска по подстрокам в таблицах, построенных с включенным `dict = keywords`, один подстановочный знак потенциально может привести к тысячам или даже миллионам совпадающих ключевых слов (представьте себе соответствие `a*` всему Оксфордскому словарю). Эта директива позволяет ограничить влияние таких расширений. Установка `expansion_limit = N` ограничивает расширения не более чем N наиболее частыми совпадающими ключевыми словами (для каждого подстановочного знака в запросе).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_limit = 16
```
<!-- end -->

### expansion_merge_threshold_docs

<!-- example conf expansion_merge_threshold_docs -->
Эта настройка определяет максимальное количество документов в расширенном ключевом слове, которое позволяет объединить все такие ключевые слова вместе. Необязательная, значение по умолчанию 32.

При выполнении поиска по подстрокам в таблицах, построенных с включенным `dict = keywords`, один подстановочный знак потенциально может привести к тысячам или даже миллионам совпадающих ключевых слов. Эта директива позволяет увеличить лимит того, сколько ключевых слов будет объединено вместе для ускорения сопоставления, но использует больше памяти при поиске.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_merge_threshold_docs = 1024
```
<!-- end -->

### expansion_merge_threshold_hits

<!-- example conf expansion_merge_threshold_hits -->
Эта настройка определяет максимальное количество вхождений в расширенном ключевом слове, которое позволяет объединить все такие ключевые слова вместе. Необязательная, значение по умолчанию 256.

При выполнении поиска подстрок в таблицах, построенных с включенной опцией `dict = keywords`, один символ подстановки может потенциально привести к тысячам или даже миллионам совпадающих ключевых слов. Эта директива позволяет увеличить лимит на количество ключевых слов, которые будут объединены для ускорения поиска, но при этом используется больше памяти.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_merge_threshold_hits = 512
```
<!-- end -->

### expansion_phrase_limit

<!-- example conf expansion_phrase_limit -->
Эта настройка контролирует максимальное количество альтернативных вариантов фраз, генерируемых из-за операторов `OR` внутри операторов `PHRASE`, `PROXIMITY` и `QUORUM`. Она является необязательной, со значением по умолчанию 1024.

При использовании оператора `|` (OR) внутри операторов, подобных фразе, общее количество расширенных комбинаций может расти экспоненциально в зависимости от количества указанных альтернатив. Эта настройка помогает предотвратить чрезмерное расширение запроса, ограничивая количество перестановок, рассматриваемых во время обработки запроса.

Если количество сгенерированных вариантов превышает этот лимит, запрос либо:

- завершится с ошибкой (поведение по умолчанию)
- вернет частичные результаты с предупреждением, если включена опция `expansion_phrase_warning`

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_phrase_limit = 4096
```
<!-- end -->

### expansion_phrase_warning

<!-- example conf expansion_phrase_warning -->
Эта настройка управляет поведением при превышении лимита расширения запроса, определенного параметром `expansion_phrase_limit`.

По умолчанию запрос завершится с ошибкой. Когда `expansion_phrase_warning` установлен в 1, поиск продолжается с использованием частичного преобразования фразы (до настроенного лимита), и сервер возвращает пользователю предупреждающее сообщение вместе с набором результатов. Это позволяет запросам, которые слишком сложны для полного расширения, все равно возвращать частичные результаты без полного сбоя.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_phrase_warning = 1
```
<!-- end -->

### grouping_in_utc

Эта настройка определяет, будет ли группировка по времени в API и SQL рассчитываться в локальном часовом поясе или в UTC. Она является необязательной, со значением по умолчанию 0 (что означает 'локальный часовой пояс').

По умолчанию все выражения 'group by time' (например, группировка по дням, неделям, месяцам и годам в API, а также по дням, месяцам, годам, yearmonth, yearmonthday в SQL) выполняются с использованием локального времени. Например, если у вас есть документы с атрибутами времени `13:00 utc` и `15:00 utc`, при группировке они оба попадут в группы объектов в соответствии с вашей настройкой локального часового пояса. Если вы находитесь в `utc`, это будет один день, но если вы находитесь в `utc+10`, то эти документы будут сопоставлены с разными группами объектов `group by day` (поскольку 13:00 utc в часовом поясе UTC+10 — это 23:00 местного времени, а 15:00 — 01:00 следующего дня). Иногда такое поведение неприемлемо, и желательно сделать группировку по времени независимой от часового пояса. Вы можете запустить сервер с определенной глобальной переменной окружения TZ, но это повлияет не только на группировку, но и на временные метки в журналах, что также может быть нежелательно. Включение этой опции (либо в конфигурации, либо с помощью оператора [SET global](../Server_settings/Setting_variables_online.md#SET) в SQL) приведет к тому, что все выражения группировки по времени будут рассчитываться в UTC, оставляя остальные зависящие от времени функции (например, ведение журнала сервера) в локальном часовом поясе.


### timezone

Эта настройка определяет часовой пояс, используемый функциями, связанными с датой/временем. По умолчанию используется локальный часовой пояс, но вы можете указать другой часовой пояс в формате IANA (например, `Europe/Amsterdam`).

Обратите внимание, что эта настройка не влияет на ведение журнала, которое всегда работает в локальном часовом поясе.

Также обратите внимание, что если используется `grouping_in_utc`, функция 'group by time' все равно будет использовать UTC, в то время как другие функции, связанные с датой/временем, будут использовать указанный часовой пояс. В целом, не рекомендуется смешивать `grouping_in_utc` и `timezone`.

Вы можете настроить эту опцию либо в конфигурации, либо с помощью оператора [SET global](../Server_settings/Setting_variables_online.md#SET) в SQL.


### ha_period_karma

<!-- example conf ha_period_karma -->
Эта настройка определяет размер окна статистики зеркал агента в секундах (или [специальных суффиксах](../Server_settings/Special_suffixes.md)). Она является необязательной, со значением по умолчанию 60 секунд.

Для распределенной таблицы с зеркалами агентов в ней (подробнее см. в [agent](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md)), мастер отслеживает несколько различных счетчиков для каждого зеркала. Затем эти счетчики используются для отказоустойчивости и балансировки (мастер выбирает лучшее зеркало для использования на основе счетчиков). Счетчики накапливаются блоками по `ha_period_karma` секунд.

После начала нового блока мастер может все еще использовать накопленные значения из предыдущего блока, пока новый не заполнится наполовину. В результате любая предыдущая история перестает влиять на выбор зеркала максимум через 1,5 раза ha_period_karma секунд.

Несмотря на то, что для выбора зеркала используется не более двух блоков, до 15 последних блоков хранятся для целей инструментирования. Эти блоки можно проверить с помощью оператора [SHOW AGENT STATUS](../Node_info_and_management/Node_status.md#SHOW-AGENT-STATUS).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ha_period_karma = 2m
```
<!-- end -->


### ha_ping_interval

<!-- example conf ha_ping_interval -->
Эта настройка задает интервал между пингами зеркал агента в миллисекундах (или [специальных суффиксах](../Server_settings/Special_suffixes.md)). Она является необязательной, со значением по умолчанию 1000 миллисекунд.

Для распределенной таблицы с зеркалами агентов в ней (подробнее см. в [agent](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md)), мастер отправляет всем зеркалам команду ping в периоды простоя. Это необходимо для отслеживания текущего статуса агента (жив или мертв, сетевая задержка и т.д.). Интервал между такими пингами определяется этой директивой. Чтобы отключить пинги, установите ha_ping_interval в 0.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ha_ping_interval = 3s
```
<!-- end -->


### hostname_lookup

Опция `hostname_lookup` определяет стратегию обновления имён хостов. По умолчанию IP-адреса имён хостов агентов кэшируются при запуске сервера, чтобы избежать чрезмерного обращения к DNS. Однако в некоторых случаях IP может меняться динамически (например, на облачном хостинге), и может быть желательно не кэшировать IP-адреса. Установка этой опции в значение `request` отключает кэширование и запрашивает DNS для каждого запроса. IP-адреса также можно обновить вручную с помощью команды `FLUSH HOSTNAMES`.

### jobs_queue_size

Настройка jobs_queue_size определяет, сколько "заданий" может одновременно находиться в очереди. По умолчанию она не ограничена.

В большинстве случаев "задание" означает один запрос к одной локальной таблице (обычной таблице или дисковому чанку реального времени). Например, если у вас есть распределённая таблица, состоящая из 2 локальных таблиц, или таблица реального времени с 2 дисковыми чанками, поисковый запрос к любой из них в основном поместит 2 задания в очередь. Затем пул потоков (размер которого определяется параметром [threads](../Server_settings/Searchd.md#threads)) будет их обрабатывать. Однако в некоторых случаях, если запрос слишком сложный, может быть создано больше заданий. Изменение этой настройки рекомендуется, когда [max_connections](../Server_settings/Searchd.md#max_connections) и [threads](../Server_settings/Searchd.md#threads) недостаточно для нахождения баланса между желаемой производительностью.

### join_batch_size

Соединения таблиц работают путём накопления пакета совпадений, которые являются результатами запроса, выполненного по левой таблице. Затем этот пакет обрабатывается как единый запрос по правой таблице.

Эта опция позволяет настроить размер пакета. Значение по умолчанию — `1000`, а установка этой опции в `0` отключает пакетную обработку.

Больший размер пакета может повысить производительность; однако для некоторых запросов это может привести к чрезмерному потреблению памяти.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
join_batch_size = 2000
```
<!-- end -->

### join_cache_size

Каждый запрос, выполняемый по правой таблице, определяется конкретными условиями JOIN ON, которые определяют набор результатов, извлекаемый из правой таблицы.

Если существует всего несколько уникальных условий JOIN ON, повторное использование результатов может быть эффективнее, чем многократное выполнение запросов по правой таблице. Чтобы это включить, наборы результатов сохраняются в кэше.

Эта опция позволяет настроить размер этого кэша. Значение по умолчанию — `20 MB`, а установка этой опции в 0 отключает кэширование.

Обратите внимание, что каждый поток поддерживает свой собственный кэш, поэтому при оценке общего использования памяти следует учитывать количество потоков, выполняющих запросы.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
join_cache_size = 10M
```
<!-- end -->

### listen_backlog

<!-- example conf listen_backlog -->
Настройка listen_backlog определяет длину очереди прослушивания TCP для входящих соединений. Это особенно актуально для сборок под Windows, которые обрабатывают запросы по одному. Когда очередь соединений достигает своего предела, новые входящие соединения будут отклоняться.
Для сборок, отличных от Windows, значение по умолчанию должно работать нормально, и обычно нет необходимости изменять эту настройку.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
listen_backlog = 20
```
<!-- end -->

### kibana_version_string

<!-- example conf kibana_version_string -->
Строка версии сервера, возвращаемая Kibana или OpenSearch Dashboards. Необязательная — по умолчанию установлено `7.6.0`.

Некоторые версии Kibana и OpenSearch Dashboards ожидают, что сервер сообщит определённый номер версии, и могут вести себя по-разному в зависимости от него. Чтобы обойти такие проблемы, вы можете использовать эту настройку, которая заставляет Manticore сообщать Kibana или OpenSearch Dashboards пользовательскую версию.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
kibana_version_string = 1.2.3
```
<!-- end -->

### listen

<!-- example conf listen -->
Эта настройка позволяет указать IP-адрес и порт или путь к Unix-доменному сокету, на которых Manticore будет принимать соединения.

Общий синтаксис для `listen`:

```ini
listen = ( address ":" port | port | path | address ":" port start - port end ) [ ":" protocol [ "_vip" ] [ "_readonly" ] ]
```

Вы можете указать:
* либо IP-адрес (или имя хоста) и номер порта
* либо только номер порта
* либо путь к Unix-сокету (не поддерживается в Windows)
* либо IP-адрес и диапазон портов

Если вы укажете номер порта, но не адрес, `searchd` будет прослушивать все сетевые интерфейсы. Unix-путь идентифицируется начальным слэшем. Диапазон портов может быть установлен только для протокола репликации.

Вы также можете указать обработчик протокола (слушатель), который будет использоваться для соединений на этом сокете. Слушатели:

* **Не указано** - Manticore будет принимать соединения на этом порту от:
  - других агентов Manticore (т.е. удаленной распределенной таблицы)
  - клиентов через HTTP и HTTPS
  - [Manticore Buddy](https://manticoresearch.com/blog/manticoresearch-buddy-intro/). **Убедитесь, что у вас есть слушатель такого типа (или слушатель `http`, как упомянуто ниже), чтобы избежать ограничений в функциональности Manticore.**
* `mysql` Протокол MySQL для соединений от клиентов MySQL. Примечание:
  - Сжатый протокол также поддерживается.
  - Если включен [SSL](../Security/SSL.md#SSL), можно установить зашифрованное соединение.
* `replication` - протокол репликации, используемый для общения между узлами. Подробнее можно узнать в разделе [репликация](../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md). Можно указать несколько слушателей репликации, но все они должны слушать на одном IP; могут различаться только порты. Когда вы определяете слушатель репликации с диапазоном портов (например, `listen = 192.168.0.1:9320-9328:replication`), Manticore не начинает немедленно слушать на этих портах. Вместо этого он займет случайные свободные порты из указанного диапазона только тогда, когда вы начнете использовать репликацию. Для корректной работы репликации в диапазоне требуется как минимум 2 порта.
* `http` - то же самое, что и **Не указано**. Manticore будет принимать соединения на этом порту от удаленных агентов и клиентов через HTTP и HTTPS.
* `https` - протокол HTTPS. Manticore будет принимать **только** HTTPS-соединения на этом порту. Подробнее можно узнать в разделе [SSL](../Security/SSL.md).
* `sphinx` - устаревший бинарный протокол. Используется для обслуживания соединений от удаленных клиентов [SphinxSE](../Extensions/SphinxSE.md). Некоторые реализации клиентов Sphinx API (пример - Java) требуют явного объявления слушателя.

Добавление суффикса `_vip` к клиентским протоколам (то есть ко всем, кроме `replication`, например `mysql_vip` или `http_vip` или просто `_vip`) заставляет создавать выделенный поток для соединения, чтобы обойти различные ограничения. Это полезно для обслуживания узла в случае сильной перегрузки, когда сервер в противном случае либо зависнет, либо не позволит подключиться через обычный порт.

Суффикс `_readonly` устанавливает [режим только для чтения](../Security/Read_only.md) для слушателя и ограничивает его приемом только read-запросов.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
listen = localhost
listen = localhost:5000 # listen for remote agents (binary API) and http/https requests on port 5000 at localhost
listen = 192.168.0.1:5000 # listen for remote agents (binary API) and http/https requests on port 5000 at 192.168.0.1
listen = /var/run/manticore/manticore.s # listen for binary API requests on unix socket
listen = /var/run/manticore/manticore.s:mysql # listen for mysql requests on unix socket
listen = 9312 # listen for remote agents (binary API) and http/https requests on port 9312 on any interface
listen = localhost:9306:mysql # listen for mysql requests on port 9306 at localhost
listen = localhost:9307:mysql_readonly # listen for mysql requests on port 9307 at localhost and accept only read queries
listen = 127.0.0.1:9308:http # listen for http requests as well as connections from remote agents (and binary API) on port 9308 at localhost
listen = 192.168.0.1:9320-9328:replication # listen for replication connections on ports 9320-9328 at 192.168.0.1
listen = 127.0.0.1:9443:https # listen for https requests (not http) on port 9443 at 127.0.0.1
listen = 127.0.0.1:9312:sphinx # listen for legacy Sphinx requests (e.g. from SphinxSE) on port 9312 at 127.0.0.1
```
<!-- end -->

Может быть несколько директив `listen`. `searchd` будет слушать клиентские соединения на всех указанных портах и сокетах. Конфигурация по умолчанию, предоставляемая в пакетах Manticore, определяет прослушивание на портах:
* `9308` и `9312` для соединений от удаленных агентов и клиентов, не основанных на MySQL
* и на порту `9306` для MySQL-соединений.

Если вы вообще не укажете `listen` в конфигурации, Manticore будет ожидать соединений на:
* `127.0.0.1:9306` для MySQL-клиентов
* `127.0.0.1:9312` для HTTP/HTTPS и соединений от других узлов Manticore и клиентов, основанных на бинарном API Manticore.

#### Прослушивание на привилегированных портах

По умолчанию Linux не позволит вам заставить Manticore слушать на порту ниже 1024 (например, `listen = 127.0.0.1:80:http` или `listen = 127.0.0.1:443:https`), если вы не запустите searchd от имени root. Если вы все же хотите иметь возможность запускать Manticore так, чтобы он слушал на портах < 1024 под непривилегированным пользователем, рассмотрите один из следующих вариантов (любой из них должен сработать):
* Выполните команду `setcap CAP_NET_BIND_SERVICE=+eip /usr/bin/searchd`
* Добавьте `AmbientCapabilities=CAP_NET_BIND_SERVICE` в systemd-юнит Manticore и перезагрузите демон (`systemctl daemon-reload`).

#### Технические детали о протоколе Sphinx API и TFO
<details>
Устаревший протокол Sphinx имеет 2 фазы: обмен рукопожатием и поток данных. Рукопожатие состоит из пакета в 4 байта от клиента и пакета в 4 байта от демона с единственной целью - клиент определяет, что удаленная сторона является настоящим демоном Sphinx, демон определяет, что удаленная сторона является настоящим клиентом Sphinx. Основной поток данных довольно прост: пусть обе стороны объявят свои рукопожатия, а противоположная сторона проверит их. Этот обмен короткими пакетами подразумевает использование специального флага `TCP_NODELAY`, который отключает алгоритм Нагла для TCP и объявляет, что TCP-соединение будет выполняться как диалог небольших пакетов.
Однако, строго не определено, кто говорит первым в этом переговоре. Исторически все клиенты, использующие бинарный API, говорят первыми: отправляют рукопожатие, затем читают 4 байта от демона, затем отправляют запрос и читают ответ от демона.
Когда мы улучшали совместимость протокола Sphinx, мы учитывали следующее:

1. Обычно связь мастер-агент устанавливается от известного клиента к известному хосту на известном порту. Поэтому маловероятно, что конечная точка предоставит неверное рукопожатие. Таким образом, мы можем неявно предположить, что обе стороны являются валидными и действительно общаются по протоколу Sphinx.
2. Исходя из этого предположения, мы можем "склеить" рукопожатие с реальным запросом и отправить его в одном пакете. Если бэкенд - это устаревший демон Sphinx, он просто прочитает этот склеенный пакет как 4 байта рукопожатия, затем тело запроса. Поскольку они оба пришли в одном пакете, у бэкенд-сокета -1 RTT, а буфер фронтенда все еще работает обычным образом, несмотря на этот факт.
3. Продолжая предположение: поскольку пакет "запроса" довольно мал, а рукопожатие еще меньше, давайте отправим оба в начальном TCP-пакете 'SYN', используя современную технику TFO (tcp-fast-open). То есть: мы подключаемся к удаленному узлу со склеенным пакетом рукопожатия + тела. Демон принимает соединение и сразу же имеет и рукопожатие, и тело в буфере сокета, так как они пришли в самом первом TCP-пакете 'SYN'. Это устраняет еще один RTT.
4. Наконец, научим демона принимать это улучшение. Фактически, со стороны приложения это подразумевает НЕ использовать `TCP_NODELAY`. А со стороны системы это подразумевает обеспечение того, что на стороне демона активировано принятие TFO, а на стороне клиента активирована отправка TFO. По умолчанию в современных системах клиентский TFO уже активирован по умолчанию, поэтому вам нужно только настроить серверный TFO, чтобы все заработало.

Все эти улучшения без фактического изменения самого протокола позволили нам исключить 1,5 RTT протокола TCP из соединения. Что, если запрос и ответ могут быть размещены в одном TCP-пакете, уменьшает всю сессию бинарного API с 3,5 RTT до 2 RTT — что делает сетевое согласование примерно в 2 раза быстрее.

Итак, все наши улучшения основаны на изначально неопределенном утверждении: 'кто говорит первым'. Если клиент говорит первым, мы можем применить все эти оптимизации и эффективно обработать подключение + рукопожатие + запрос в одном TFO-пакете. Более того, мы можем посмотреть на начало полученного пакета и определить реальный протокол. Вот почему вы можете подключиться к одному и тому же порту через API/http/https. Если демон должен говорить первым, все эти оптимизации невозможны, и мультипротокол также невозможен. Вот почему у нас есть выделенный порт для MySQL, и мы не объединили его со всеми другими протоколами в один порт. Внезапно, среди всех клиентов, один был написан с предположением, что демон должен отправить рукопожатие первым. То есть — нет возможности для всех описанных улучшений. Это плагин SphinxSE для mysql/mariadb. Поэтому специально для этого единственного клиента мы выделили определение протокола `sphinx` для работы наиболее устаревшим способом. А именно: обе стороны активируют `TCP_NODELAY` и обмениваются маленькими пакетами. Демон отправляет свое рукопожатие при подключении, затем клиент отправляет свое, и затем все работает обычным образом. Это не очень оптимально, но просто работает. Если вы используете SphinxSE для подключения к Manticore — вам нужно выделить слушатель с явно указанным протоколом `sphinx`. Для других клиентов — избегайте использования этого слушателя, так как он медленнее. Если вы используете другие устаревшие клиенты Sphinx API — сначала проверьте, могут ли они работать с невыделенным мультипротокольным портом. Для связи мастер-агент использование невыделенного (мультипротокольного) порта и включение TFO на клиенте и сервере работает хорошо и определенно ускорит работу сетевой части, особенно если у вас очень легкие и быстрые запросы.
</details>

### listen_tfo

Эта настройка позволяет использовать флаг TCP_FASTOPEN для всех слушателей. По умолчанию она управляется системой, но может быть явно отключена установкой значения '0'.

Для общего понимания расширения TCP Fast Open, пожалуйста, обратитесь к [Википедии](https://en.wikipedia.org/wiki/TCP_Fast_Open). Вкратце, оно позволяет исключить один раунд-трип TCP при установке соединения.

На практике использование TFO во многих ситуациях может оптимизировать сетевую эффективность клиент-агент, как если бы использовались [постоянные агенты](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md), но без удержания активных соединений, а также без ограничения на максимальное количество соединений.

В современных ОС поддержка TFO обычно включена на системном уровне, но это всего лишь 'возможность', а не правило. Linux (как самый прогрессивный) поддерживает его с 2011 года, начиная с ядер 3.7 (для серверной стороны). Windows поддерживает его с некоторых сборок Windows 10. Другие операционные системы (FreeBSD, MacOS) также в игре.

Для Linux система сервера проверяет переменную `/proc/sys/net/ipv4/tcp_fastopen` и ведет себя в соответствии с ней. Бит 0 управляет клиентской стороной, бит 1 управляет слушателями. По умолчанию в системе этот параметр установлен в 1, т.е. клиенты включены, слушатели отключены.

### log

<!-- example conf log -->
Настройка log указывает имя файла журнала, в который будут записываться все события времени выполнения `searchd`. Если не указано, имя по умолчанию — 'searchd.log'.

В качестве альтернативы вы можете использовать 'syslog' в качестве имени файла. В этом случае события будут отправляться демону syslog. Чтобы использовать опцию syslog, необходимо сконфигурировать Manticore с опцией `-–with-syslog` во время сборки.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
log = /var/log/searchd.log
```
<!-- end -->


### max_batch_queries

<!-- example conf max_batch_queries -->
Ограничивает количество запросов в пакете. Необязательная настройка, по умолчанию 32.

Заставляет searchd выполнять проверку корректности количества запросов, отправленных в одном пакете при использовании [много-запросов](../Searching/Multi-queries.md). Установите значение 0, чтобы пропустить проверку.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_batch_queries = 256
```
<!-- end -->

### max_connections

<!-- example max_connections -->
Максимальное количество одновременных клиентских соединений. По умолчанию не ограничено. Обычно это заметно только при использовании любого вида постоянных соединений, таких как сессии cli mysql или постоянные удаленные соединения от удаленных распределенных таблиц. При превышении лимита вы все равно можете подключиться к серверу, используя [VIP-соединение](../Connecting_to_the_server/MySQL_protocol.md#VIP-connection). VIP-соединения не учитываются в лимите.

<!-- request Example -->
```ini
max_connections = 10
```

<!-- end -->

### max_threads_per_query

<!-- example max_threads_per_query -->
Глобальный для экземпляра лимит потоков, которые может использовать одна операция. По умолчанию соответствующие операции могут занимать все ядра CPU, не оставляя места для других операций. Например, `call pq` для достаточно большой перколяционной таблицы может использовать все потоки на десятки секунд. Установка `max_threads_per_query` на, скажем, половину от [threads](../Server_settings/Searchd.md#threads) гарантирует, что вы сможете запустить пару таких операций `call pq` параллельно.

Вы также можете установить эту настройку как переменную сессии или глобальную переменную во время выполнения.

Кроме того, вы можете управлять поведением для каждого запроса с помощью опции [threads OPTION](../Searching/Options.md#threads).

<!-- intro -->
##### Пример:
<!-- request Example -->

```ini
max_threads_per_query = 4
```

<!-- end -->

### max_filters

<!-- example conf max_filters -->
Максимально допустимое количество фильтров на запрос. Эта настройка используется только для внутренних проверок корректности и не влияет напрямую на использование RAM или производительность. Необязательная, по умолчанию 256.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_filters = 1024
```
<!-- end -->


### max_filter_values

<!-- example conf max_filter_values -->
Максимально допустимое количество значений на фильтр. Этот параметр используется только для внутренних проверок корректности и не влияет напрямую на использование оперативной памяти или производительность. Необязательный, по умолчанию 4096.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_filter_values = 16384
```
<!-- end -->


### max_open_files

<!-- example conf max_open_files -->
Максимальное количество файлов, которое серверу разрешено открывать, называется "мягким лимитом". Обратите внимание, что обслуживание больших фрагментированных таблиц в реальном времени может потребовать установки высокого значения этого лимита, так как каждый дисковый чанк может занимать дюжину или более файлов. Например, таблица в реальном времени с 1000 чанков может потребовать одновременного открытия тысяч файлов. Если в журналах возникает ошибка 'Too many open files', попробуйте изменить этот параметр, так как это может помочь решить проблему.

Также существует "жесткий лимит", который не может быть превышен с помощью этого параметра. Этот лимит определяется системой и может быть изменен в файле `/etc/security/limits.conf` в Linux. В других операционных системах могут быть другие подходы, поэтому обратитесь к руководствам для получения дополнительной информации.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_open_files = 10000
```
<!-- end -->

<!-- example conf max_open_files max -->
Помимо прямых числовых значений, вы можете использовать волшебное слово 'max', чтобы установить лимит равным доступному текущему жесткому лимиту.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_open_files = max
```
<!-- end -->


### max_packet_size

<!-- example conf max_packet_size -->
Максимально допустимый размер сетевого пакета. Этот параметр ограничивает как пакеты запросов от клиентов, так и пакеты ответов от удаленных агентов в распределенной среде. Используется только для внутренних проверок корректности, не влияет напрямую на использование оперативной памяти или производительность. Необязательный, по умолчанию 128M.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_packet_size = 32M
```
<!-- end -->


### mysql_version_string

<!-- example conf mysql_version_string -->
Строка версии сервера, возвращаемая по протоколу MySQL. Необязательный, по умолчанию пустая (возвращает версию Manticore).

Некоторые привередливые клиентские библиотеки MySQL зависят от определенного формата номера версии, используемого MySQL, и более того, иногда выбирают другой путь выполнения на основе сообщаемого номера версии (а не указанных флагов возможностей). Например, Python MySQLdb 1.2.2 выбрасывает исключение, когда номер версии не в формате X.Y.ZZ; MySQL .NET connector 6.3.x внутренне завершается ошибкой на номерах версий 1.x в сочетании с определенной комбинацией флагов и т.д. Чтобы обойти это, вы можете использовать директиву `mysql_version_string` и заставить `searchd` сообщать клиентам, подключающимся по протоколу MySQL, другую версию. (По умолчанию он сообщает свою собственную версию.)


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
mysql_version_string = 5.0.37
```
<!-- end -->


### net_workers

Количество сетевых потоков, по умолчанию 1.

Этот параметр полезен при чрезвычайно высокой частоте запросов, когда одного потока недостаточно для обработки всех входящих запросов.


### net_wait_tm

Управляет интервалом активного цикла сетевого потока. По умолчанию -1, может быть установлено в -1, 0 или положительное целое число.

В случаях, когда сервер настроен как чистый мастер и просто маршрутизирует запросы к агентам, важно обрабатывать запросы без задержек и не позволять сетевому потоку спать. Для этого существует активный цикл. После входящего запроса сетевой поток использует опрос CPU в течение `10 * net_wait_tm` миллисекунд, если `net_wait_tm` — положительное число, или опрашивает только с помощью CPU, если `net_wait_tm` равен `0`. Также активный цикл можно отключить с помощью `net_wait_tm = -1` — в этом случае поллер устанавливает таймаут на фактическое время ожидания агентов при системном вызове опроса.

> **ВНИМАНИЕ:** Активный цикл CPU фактически нагружает ядро процессора, поэтому установка этого значения в любое значение, отличное от значения по умолчанию, вызовет заметное использование CPU даже на простаивающем сервере.


### net_throttle_accept

Определяет, сколько клиентов принимается на каждой итерации сетевого цикла. По умолчанию 0 (без ограничений), что должно подходить большинству пользователей. Это параметр тонкой настройки для управления пропускной способностью сетевого цикла в сценариях высокой нагрузки.


### net_throttle_action

Определяет, сколько запросов обрабатывается на каждой итерации сетевого цикла. По умолчанию 0 (без ограничений), что должно подходить большинству пользователей. Это параметр тонкой настройки для управления пропускной способностью сетевого цикла в сценариях высокой нагрузки.

### network_timeout

<!-- example conf network_timeout -->
Таймаут чтения/записи сетевого запроса клиента, в секундах (или с [специальными суффиксами](../Server_settings/Special_suffixes.md)). Необязательный, по умолчанию 5 секунд. `searchd` принудительно закроет соединение с клиентом, который не смог отправить запрос или прочитать результат в течение этого таймаута.

Также обратите внимание на параметр [reset_network_timeout_on_packet](../Server_settings/Searchd.md#reset_network_timeout_on_packet). Этот параметр изменяет поведение `network_timeout` с применения ко всему `запросу` или `результату` на применение к отдельным пакетам. Обычно запрос/результат умещается в один или два пакета. Однако в случаях, когда требуется большой объем данных, этот параметр может оказаться бесценным для поддержания активных операций.

<!-- request Example -->

```ini
network_timeout = 10s
```
<!-- end -->

### node_address

<!-- example conf node_address -->
Этот параметр позволяет указать сетевой адрес узла. По умолчанию он устанавливается в адрес репликации [listen](../Server_settings/Searchd.md#listen). Это верно в большинстве случаев; однако бывают ситуации, когда его необходимо указать вручную:

* Узел за брандмауэром
* Включен трансляция сетевых адресов (NAT)
* Развертывания в контейнерах, такие как Docker или облачные развертывания
* Кластеры с узлами более чем в одном регионе


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
node_address = 10.101.0.10
```
<!-- end -->

### not_terms_only_allowed

<!-- example conf not_terms_only_allowed -->
Этот параметр определяет, разрешать ли запросы, содержащие только [оператор отрицания](../Searching/Full_text_matching/Operators.md#Negation-operator) полнотекстового поиска. Необязательный, по умолчанию 0 (запросы только с оператором NOT завершаются ошибкой).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
not_terms_only_allowed = 1
```
<!-- end -->

### optimize_cutoff

<!-- example conf optimize_cutoff -->
Устанавливает пороговое значение по умолчанию для компоновки таблицы. Подробнее читайте здесь - [Количество оптимизированных дисковых чанков](../Securing_and_compacting_a_table/Compacting_a_table.md#Number-of-optimized-disk-chunks). Этот параметр может быть переопределен с помощью опции для конкретного запроса [cutoff](../Securing_and_compacting_a_table/Compacting_a_table.md#Number-of-optimized-disk-chunks). Его также можно изменить динамически с помощью [SET GLOBAL](../Server_settings/Setting_variables_online.md#SET).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
optimize_cutoff = 4
```
<!-- end -->

### persistent_connections_limit

<!-- example conf persistent_connections_limit -->
Этот параметр определяет максимальное количество одновременных постоянных соединений с удаленными [постоянными агентами](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md). Каждый раз, когда происходит подключение к агенту, определенному в `agent_persistent`, мы пытаемся повторно использовать существующее соединение (если оно есть) или подключиться и сохранить соединение для будущего использования. Однако в некоторых случаях имеет смысл ограничить количество таких постоянных соединений. Эта директива определяет лимит. Она влияет на количество соединений с хостом каждого агента для всех распределенных таблиц.

Разумно установить значение равным или меньшим, чем опция [max_connections](../Server_settings/Searchd.md#max_connections) в конфигурации агента.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
persistent_connections_limit = 29 # assume that each host of agents has max_connections = 30 (or 29).
```
<!-- end -->


### pid_file

<!-- example conf pid_file -->
pid_file — это обязательная опция конфигурации в Manticore search, которая указывает путь к файлу, в котором хранится идентификатор процесса (PID) сервера `searchd`.

Файл идентификатора процесса searchd создается заново и блокируется при запуске, и содержит PID главного серверного процесса, пока сервер работает. Он удаляется при остановке сервера.
Цель этого файла — позволить Manticore выполнять различные внутренние задачи, такие как проверка наличия уже запущенного экземпляра `searchd`, остановка `searchd` и уведомление его о необходимости ротации таблиц. Этот файл также может использоваться внешними скриптами автоматизации.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
pid_file = /run/manticore/searchd.pid
```
<!-- end -->


### predicted_time_costs

<!-- example conf predicted_time_costs -->
Стоимости для модели предсказания времени выполнения запроса, в наносекундах. Необязательный параметр, по умолчанию `doc=64, hit=48, skip=2048, match=64`.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
predicted_time_costs = doc=128, hit=96, skip=4096, match=128
```
<!-- end -->

<!-- example conf predicted_time_costs 1 -->
Прерывание запросов до завершения на основе времени их выполнения (с настройкой максимального времени запроса) — это хорошая защитная сетка, но она имеет врожденный недостаток: недетерминированные (нестабильные) результаты. То есть, если вы повторите один и тот же (сложный) поисковый запрос с ограничением по времени несколько раз, ограничение будет срабатывать на разных этапах, и вы получите *разные* наборы результатов.

<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
SELECT … OPTION max_query_time
```
<!-- request API -->

```api
SetMaxQueryTime()
```
<!-- end -->

Существует опция [SELECT … OPTION max_predicted_time](../Searching/Options.md#max_predicted_time), которая позволяет ограничить время выполнения запроса *и* получать стабильные, повторяемые результаты. Вместо регулярной проверки фактического текущего времени во время выполнения запроса, что является недетерминированным, она предсказывает текущее время выполнения с помощью простой линейной модели:

```ini
predicted_time =
    doc_cost * processed_documents +
    hit_cost * processed_hits +
    skip_cost * skiplist_jumps +
    match_cost * found_matches
```

Затем запрос прерывается досрочно, когда `predicted_time` достигает заданного лимита.

Конечно, это не жесткое ограничение на фактически затраченное время (однако это жесткое ограничение на объем выполненной *обрабатывающей* работы), и простая линейная модель никоим образом не является идеально точной. Поэтому фактическое время *может* быть как ниже, так и выше целевого лимита. Однако погрешности вполне приемлемы: например, в наших экспериментах с целевым лимитом в 100 мсек большинство тестовых запросов попадало в диапазон от 95 до 105 мсек, и *все* запросы находились в диапазоне от 80 до 120 мсек. Кроме того, как приятный побочный эффект, использование смоделированного времени запроса вместо измерения фактического времени выполнения также приводит к несколько меньшему количеству вызовов gettimeofday().

Нет двух одинаковых серверов, поэтому директива `predicted_time_costs` позволяет настроить стоимости для приведенной выше модели. Для удобства они являются целыми числами, измеряемыми в наносекундах. (Лимит в max_predicted_time измеряется в миллисекундах, и указание значений стоимости как 0.000128 мс вместо 128 нс несколько более подвержено ошибкам.) Не обязательно указывать все четыре стоимости сразу, так как пропущенные примут значения по умолчанию. Однако мы настоятельно рекомендуем указывать их все для удобства чтения.


### preopen_tables

<!-- example conf preopen_tables -->
Директива конфигурации preopen_tables указывает, следует ли принудительно предварительно открывать все таблицы при запуске. Значение по умолчанию — 1, что означает, что все таблицы будут предварительно открыты независимо от настройки для конкретной таблицы [preopen](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Other-performance-related-settings). Если установлено значение 0, настройки для конкретных таблиц могут вступить в силу, и по умолчанию они будут равны 0.

Предварительное открытие таблиц может предотвратить гонки между поисковыми запросами и ротациями, которые могут иногда вызывать сбои запросов. Однако это также использует больше файловых дескрипторов. В большинстве сценариев рекомендуется предварительно открывать таблицы.

Вот пример конфигурации:

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
preopen_tables = 1
```
<!-- end -->

### pseudo_sharding

<!-- example conf pseudo_sharding -->
Опция конфигурации pseudo_sharding включает параллелизацию поисковых запросов к локальным обычным и реального времени таблицам, независимо от того, запрашиваются ли они напрямую или через распределенную таблицу. Эта функция будет автоматически распараллеливать запросы до количества потоков, указанного в `searchd.threads` # потоков.

Обратите внимание, что если ваши рабочие потоки уже заняты, потому что у вас:
* высокая параллельность запросов
* физическое шардирование любого вида:
  - распределенная таблица из нескольких обычных/реал-тайм таблиц
  - реал-тайм таблица, состоящая из слишком большого количества дисковых чанков

то включение pseudo_sharding может не дать никаких преимуществ и даже привести к небольшому снижению пропускной способности. Если вы отдаете приоритет более высокой пропускной способности над меньшей задержкой, рекомендуется отключить эту опцию.

Включено по умолчанию.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
pseudo_sharding = 0
```
<!-- end -->


### replication_connect_timeout

Директива `replication_connect_timeout` определяет таймаут для подключения к удаленному узлу. По умолчанию значение указывается в миллисекундах, но оно может иметь [другой суффикс](../Server_settings/Special_suffixes.md). Значение по умолчанию — 1000 (1 секунда).

При подключении к удаленному узлу Manticore будет ждать не более этого времени для успешного завершения соединения. Если таймаут достигнут, но соединение не установлено, и включены `retries`, будет инициирована повторная попытка.


### replication_query_timeout

`replication_query_timeout` устанавливает время, которое searchd будет ждать завершения запроса на удаленном узле. Значение по умолчанию — 3000 миллисекунд (3 секунды), но может быть `суффиксировано` для указания другой единицы времени.

После установки соединения Manticore будет ждать не более `replication_query_timeout` для завершения работы удаленного узла. Обратите внимание, что этот таймаут отделен от `replication_connect_timeout`, и общая возможная задержка, вызванная удаленным узлом, будет суммой обоих значений.


### replication_retry_count

Эта настройка представляет собой целое число, указывающее, сколько раз Manticore попытается подключиться и выполнить запрос к удаленному узлу во время репликации, прежде чем сообщить о фатальной ошибке запроса. Значение по умолчанию — 3.


### replication_retry_delay

Эта настройка представляет собой целое число в миллисекундах (или [специальные суффиксы](../Server_settings/Special_suffixes.md)), указывающее задержку перед тем, как Manticore повторно попытается выполнить запрос к удаленному узлу в случае сбоя во время репликации. Это значение актуально только при указании ненулевого значения. Значение по умолчанию — 500.

### qcache_max_bytes

<!-- example conf qcache_max_bytes -->
Эта конфигурация устанавливает максимальный объем оперативной памяти, выделяемой для кэшированных наборов результатов, в байтах. Значение по умолчанию — 16777216, что эквивалентно 16 мегабайтам. Если значение установлено в 0, кэш запросов отключен. Для получения дополнительной информации о кэше запросов обратитесь к разделу [кэш запросов](../Searching/Query_cache.md) для подробностей.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
qcache_max_bytes = 16777216
```
<!-- end -->


### qcache_thresh_msec

Целое число, в миллисекундах. Минимальный порог времени выполнения для кэширования результата запроса. По умолчанию 3000, или 3 секунды. 0 означает кэшировать все. См. [кэш запросов](../Searching/Query_cache.md) для подробностей. Это значение также может быть выражено с помощью временных [специальных суффиксов](../Server_settings/Special_suffixes.md), но используйте его с осторожностью и не путайте с названием самого значения, содержащим '_msec'.


### qcache_ttl_sec

Целое число, в секундах. Срок действия кэшированного набора результатов. По умолчанию 60, или 1 минута. Минимально возможное значение — 1 секунда. См. [кэш запросов](../Searching/Query_cache.md) для подробностей. Это значение также может быть выражено с помощью временных [специальных суффиксов](../Server_settings/Special_suffixes.md), но используйте его с осторожностью и не путайте с названием самого значения, содержащим '_sec'.


### query_log_format

<!-- example conf query_log_format -->
Формат журнала запросов. Необязательный, допустимые значения: `plain` и `sphinxql`, по умолчанию `sphinxql`.

Режим `sphinxql` записывает допустимые SQL-операторы. Режим `plain` записывает запросы в формате обычного текста (в основном подходит для чисто полнотекстовых случаев использования). Эта директива позволяет переключаться между двумя форматами при запуске поискового сервера. Формат журнала также можно изменить на лету, используя синтаксис `SET GLOBAL query_log_format=sphinxql`. См. [Журналирование запросов](../Logging/Query_logging.md) для получения дополнительной информации.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
query_log_format = sphinxql
```
<!-- end -->

### query_log_min_msec

Лимит (в миллисекундах), который предотвращает запись запроса в журнал запросов. Необязательный, по умолчанию 0 (все запросы записываются в журнал запросов). Эта директива указывает, что будут записываться в журнал только запросы с временем выполнения, превышающим указанный лимит (это значение также может быть выражено с помощью временных [специальных суффиксов](../Server_settings/Special_suffixes.md), но используйте его с осторожностью и не путайте с названием самой директивы, содержащим `_msec`).

### query_log

<!-- example conf query_log -->
Имя файла журнала запросов. Необязательный, по умолчанию пусто (не записывать запросы). Все поисковые запросы (такие как SELECT ..., но не INSERT/REPLACE/UPDATE запросы) будут записываться в этот файл. Формат описан в разделе [Журналирование запросов](../Logging/Query_logging.md). В случае формата 'plain' вы можете использовать 'syslog' в качестве пути к файлу журнала. В этом случае все поисковые запросы будут отправляться демону syslog с приоритетом `LOG_INFO`, с префиксом '[query]' вместо временной метки. Чтобы использовать опцию syslog, Manticore должен быть сконфигурирован с `-–with-syslog` при сборке.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
query_log = /var/log/query.log
```
<!-- end -->


### query_log_mode

<!-- example conf query_log_mode -->
Директива query_log_mode позволяет установить другие права доступа для файлов журналов searchd и запросов. По умолчанию эти файлы журналов создаются с правами 600, что означает, что только пользователь, под которым работает сервер, и пользователи root могут читать файлы журналов.
Эта директива может быть полезна, если вы хотите разрешить другим пользователям читать файлы журналов, например, решениям мониторинга, работающим под непривилегированными пользователями.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
query_log_mode  = 666
```
<!-- end -->

### read_buffer_docs

<!-- example conf read_buffer_docs -->
Директива read_buffer_docs управляет размером буфера чтения на ключевое слово для списков документов. Для каждого вхождения ключевого слова в каждом поисковом запросе существуют два связанных буфера чтения: один для списка документов и один для списка попаданий. Данная настройка позволяет управлять размером буфера для списка документов.

Увеличение размера буфера может повысить использование оперативной памяти на запрос, но, возможно, сократит время ввода-вывода. Имеет смысл устанавливать большие значения для медленных хранилищ, но для хранилищ с высокой производительностью IOPS эксперименты следует проводить в области низких значений.

Значение по умолчанию составляет 256K, минимальное значение — 8K. Вы также можете установить [read_buffer_docs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#read_buffer_docs) для отдельной таблицы, что переопределит любые настройки на уровне конфигурации сервера.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
read_buffer_docs = 128K
```
<!-- end -->


### read_buffer_hits

<!-- example conf read_buffer_hits -->
Директива read_buffer_hits задает размер буфера чтения на ключевое слово для списков попаданий в поисковых запросах. По умолчанию размер составляет 256K, минимальное значение — 8K. Для каждого вхождения ключевого слова в поисковом запросе существуют два связанных буфера чтения: один для списка документов и один для списка попаданий. Увеличение размера буфера может повысить использование оперативной памяти на запрос, но сократить время ввода-вывода. Для медленных хранилищ имеет смысл использовать большие размеры буфера, в то время как для хранилищ с высокой производительностью IOPS эксперименты следует проводить в области низких значений.

Эту настройку также можно указать для отдельной таблицы с помощью опции read_buffer_hits в [read_buffer_hits](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#read_buffer_hits), что переопределит настройку на уровне сервера.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
read_buffer_hits = 128K
```
<!-- end -->

### read_unhinted

<!-- example conf read_unhinted -->
Размер чтения без предварительного указания размера (unhinted read). Необязательный параметр, по умолчанию 32K, минимально 1K.

При выполнении запроса для некоторых операций чтения заранее известно точное количество данных, которое необходимо прочитать, но для других в настоящее время это неизвестно. Наиболее заметно, что размер списка попаданий в настоящее время неизвестен заранее. Данная настройка позволяет управлять объемом данных для чтения в таких случаях. Она влияет на время ввода-вывода для списка попаданий, уменьшая его для списков, размер которых превышает read_unhinted, но увеличивая для списков меньшего размера. Она **не** влияет на использование оперативной памяти, так как буфер чтения уже будет выделен. Поэтому она не должна превышать read_buffer.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
read_unhinted = 32K
```
<!-- end -->

### reset_network_timeout_on_packet

<!-- example conf reset_network_timeout_on_packet -->
Уточняет поведение сетевых таймаутов (таких как `network_timeout` и `agent_query_timeout`).

При значении 0 таймауты ограничивают максимальное время на отправку всего запроса/запроса.
При значении 1 (по умолчанию) таймауты ограничивают максимальное время между сетевыми активностями.

При репликации узлу может потребоваться отправить большой файл (например, 100 ГБ) другому узлу. Предположим, сеть может передавать данные со скоростью 1 ГБ/с, пакетами по 4-5 МБ каждый. Для передачи всего файла потребуется 100 секунд. Таймаут по умолчанию в 5 секунд позволит передать только 5 ГБ до разрыва соединения. Увеличение таймаута может быть обходным решением, но оно не масштабируется (например, следующий файл может быть 150 ГБ, что снова приведет к сбою). Однако при значении `reset_network_timeout_on_packet` по умолчанию, равном 1, таймаут применяется не ко всей передаче, а к отдельным пакетам. Пока передача продолжается (и данные фактически принимаются по сети в течение периода таймаута), соединение остается активным. Если передача зависнет, так что между пакетами произойдет таймаут, соединение будет разорвано.

Обратите внимание, что если вы настраиваете распределенную таблицу, каждый узел — как мастер, так и агенты — должен быть настроен. На стороне мастера затрагивается `agent_query_timeout`; на агентах актуален `network_timeout`.

<!-- intro -->

##### Пример:

<!-- request Example -->

```ini
reset_network_timeout_on_packet = 0
```

<!-- end -->


### rt_flush_period

<!-- example conf rt_flush_period -->
Период проверки сброса RAM-чанков RT-таблиц на диск, в секундах (или [специальные суффиксы](../Server_settings/Special_suffixes.md)). Необязательный параметр, по умолчанию 10 часов.

Активно обновляемые RT-таблицы, которые полностью помещаются в RAM-чанки, могут по-прежнему приводить к постоянному росту бинарных логов, влияя на использование диска и время восстановления после сбоя. С помощью этой директивы поисковый сервер выполняет периодические проверки сброса, и подходящие RAM-чанки могут быть сохранены, что позволяет выполнить последующую очистку бинарного лога. Подробнее см. [Бинарное логирование](../Logging/Binary_logging.md).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
rt_flush_period = 3600 # 1 hour
```
<!-- end -->


### rt_merge_iops

<!-- example conf rt_merge_iops -->
Максимальное количество операций ввода-вывода (в секунду), которое разрешено запускать потоку слияния RT-чанков. Необязательный параметр, по умолчанию 0 (без ограничений).

Эта директива позволяет ограничить влияние операций ввода-вывода, возникающих из-за операторов `OPTIMIZE`. Гарантируется, что все операции оптимизации RT не будут генерировать больше операций ввода-вывода в секунду (IOPS), чем установленный лимит. Ограничение rt_merge_iops может уменьшить снижение производительности поиска, вызванное слиянием.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
rt_merge_iops = 40
```
<!-- end -->

### rt_merge_maxiosize

<!-- example conf rt_merge_maxiosize -->
Максимальный размер операции ввода-вывода, которую разрешено запускать потоку слияния RT-чанков. Необязательный параметр, по умолчанию 0 (без ограничений).

Эта директива позволяет ограничить влияние операций ввода-вывода, возникающих из-за операторов `OPTIMIZE`. Операции ввода-вывода, превышающие этот лимит, будут разбиты на две или более операций, которые затем будут учитываться как отдельные операции ввода-вывода в отношении ограничения [rt_merge_iops](../Server_settings/Searchd.md#rt_merge_iops). Таким образом, гарантируется, что все операции оптимизации не будут генерировать более (rt_merge_iops * rt_merge_maxiosize) байт дискового ввода-вывода в секунду.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
rt_merge_maxiosize = 1M
```
<!-- end -->


### seamless_rotate

<!-- example conf seamless_rotate -->
Предотвращает зависания `searchd` при ротации таблиц с огромными объемами данных, требующими предварительного кэширования. Необязательный параметр, по умолчанию равен 1 (включить бесшовную ротацию). В системах Windows бесшовная ротация по умолчанию отключена.

Таблицы могут содержать некоторые данные, которые необходимо предварительно загрузить в оперативную память. В данный момент файлы `.spa`, `.spb`, `.spi` и `.spm` полностью предзагружаются (они содержат данные атрибутов, данные атрибутов-больших объектов, таблицу ключевых слов и карту удаленных строк соответственно.) Без бесшовной ротации ротация таблицы пытается использовать как можно меньше оперативной памяти и работает следующим образом:

1. Новые запросы временно отклоняются (с кодом ошибки "retry");
2. `searchd` ожидает завершения всех текущих выполняемых запросов;
3. Старая таблица освобождается, и ее файлы переименовываются;
4. Файлы новой таблицы переименовываются, и выделяется необходимая оперативная память;
5. Данные атрибутов и словаря новой таблицы предзагружаются в оперативную память;
6. `searchd` возобновляет обслуживание запросов из новой таблицы.

Однако, если данных атрибутов или словаря очень много, то этап предзагрузки может занять заметное время — до нескольких минут в случае предзагрузки файлов размером 1-5+ ГБ.

При включенной бесшовной ротации ротация работает следующим образом:

1. Выделяется оперативная память для хранения новой таблицы;
2. Данные атрибутов и словаря новой таблицы асинхронно предзагружаются в оперативную память;
3. В случае успеха старая таблица освобождается, и файлы обеих таблиц переименовываются;
4. В случае неудачи новая таблица освобождается;
5. В любой момент времени запросы обслуживаются либо из старой, либо из новой копии таблицы.

Бесшовная ротация достигается ценой более высокого пикового использования памяти во время ротации (поскольку данные `.spa/.spb/.spi/.spm` как старой, так и новой копии должны находиться в оперативной памяти во время предзагрузки новой копии). Среднее использование остается прежним.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
seamless_rotate = 1
```
<!-- end -->

### secondary_index_block_cache
<!-- example conf secondary_index_block_cache -->

Этот параметр задает размер блочного кэша, используемого вторичными индексами. Необязательный параметр, по умолчанию равен 8 МБ. Когда вторичные индексы работают с фильтрами, содержащими много значений (например, фильтры IN()), они читают и обрабатывают метаданные блоков для этих значений.
В объединенных запросах этот процесс повторяется для каждой партии строк из левой таблицы, и каждая партия может перечитывать одни и те же метаданные в рамках одного объединенного запроса. Это может серьезно повлиять на производительность. Кэш метаданных блоков хранит эти блоки в памяти, чтобы они
могли быть повторно использованы последующими партиями.

Кэш используется только в объединенных запросах и не влияет на необъединенные запросы. Обратите внимание, что ограничение размера кэша применяется для каждого атрибута и каждого вторичного индекса. Каждый атрибут в пределах каждого дискового чанка работает в рамках этого ограничения. В худшем случае общее использование памяти
можно оценить, умножив лимит на количество дисковых чанков и количество атрибутов, используемых в объединенных запросах.

Установка `secondary_index_block_cache = 0` отключает кэш.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
secondary_index_block_cache = 16M
```

<!-- end -->

### secondary_indexes
<!-- example conf secondary_indexes -->

Этот параметр включает/отключает использование вторичных индексов для поисковых запросов. Необязательный параметр, по умолчанию равен 1 (включено). Обратите внимание, что для индексирования его включать не нужно, так как оно всегда включено, пока установлена [Manticore Columnar Library](https://github.com/manticoresoftware/columnar). Последняя также требуется для использования индексов при поиске. Доступны три режима:

* `0`: Отключить использование вторичных индексов при поиске. Их можно включить для отдельных запросов с помощью [анализаторных подсказок](../Searching/Options.md#Query-optimizer-hints)
* `1`: Включить использование вторичных индексов при поиске. Их можно отключить для отдельных запросов с помощью [анализаторных подсказок](../Searching/Options.md#Query-optimizer-hints)
* `force`: То же, что и включение, но любые ошибки при загрузке вторичных индексов будут сообщены, и весь индекс не будет загружен в демон.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
secondary_indexes = 1
```

<!-- end -->

### server_id

<!-- example conf server_id -->
Целое число, которое служит идентификатором сервера, используемым в качестве сида для генерации уникального короткого UUID для узлов, являющихся частью кластера репликации. server_id должен быть уникальным среди узлов кластера и находиться в диапазоне от 0 до 127. Если server_id не задан, он вычисляется как хэш MAC-адреса и пути к PID-файлу, или в качестве сида для короткого UUID будет использовано случайное число.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
server_id = 1
```
<!-- end -->


### shutdown_timeout

<!-- example conf shutdown_timeout -->
Время ожидания `searchd --stopwait` в секундах (или [специальные суффиксы](../Server_settings/Special_suffixes.md)). Необязательный параметр, по умолчанию равен 60 секундам.

Когда вы запускаете `searchd --stopwait`, ваш сервер должен выполнить некоторые действия перед остановкой, такие как завершение запросов, сброс RAM-чанков RT, сброс атрибутов и обновление binlog. Эти задачи требуют некоторого времени. `searchd --stopwait` будет ждать до `shutdown_time` секунд, пока сервер завершит свою работу. Подходящее время зависит от размера вашей таблицы и нагрузки.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
shutdown_timeout = 3m # wait for up to 3 minutes
```
<!-- end -->


### shutdown_token

SHA1-хэш пароля, необходимого для вызова команды 'shutdown' из VIP-подключения Manticore SQL. Без него [отладочная](../Reporting_bugs.md#DEBUG) подкоманда 'shutdown' никогда не приведет к остановке сервера. Обратите внимание, что такое простое хэширование не следует считать надежной защитой, поскольку мы не используем хэш с солью или какую-либо современную хэш-функцию. Это предназначено как защита от случайных действий для служебных демонов в локальной сети.

### snippets_file_prefix

<!-- example conf snippets_file_prefix -->
Префикс, добавляемый к локальным именам файлов при генерации сниппетов. Необязательный параметр, по умолчанию используется текущая рабочая папка.

Этот префикс можно использовать в распределенной генерации сниппетов вместе с опциями `load_files` или `load_files_scattered`.

Обратите внимание, что это префикс, а **не** путь! Это означает, что если префикс установлен в "server1", а запрос ссылается на "file23", `searchd` попытается открыть "server1file23" (всё это без кавычек). Поэтому, если вам нужен путь, вы должны включить завершающий слэш.

После построения окончательного пути к файлу сервер разворачивает все относительные каталоги и сравнивает конечный результат со значением `snippet_file_prefix`. Если результат не начинается с префикса, такой файл будет отклонён с сообщением об ошибке.

Например, если вы установите его в `/mnt/data`, и кто-то вызовет генерацию сниппета с файлом `../../../etc/passwd` в качестве источника, он получит сообщение об ошибке:

`Файл '/mnt/data/../../../etc/passwd' выходит за пределы области '/mnt/data/'`

вместо содержимого файла.

Кроме того, при неустановленном параметре и чтении `/etc/passwd` будет фактически прочитан /daemon/working/folder/etc/passwd, поскольку значение по умолчанию для параметра — рабочая папка сервера.

Также обратите внимание, что это локальная опция; она никак не влияет на агентов. Таким образом, вы можете безопасно установить префикс на главном сервере. Запросы, направленные агентам, не будут затронуты настройкой главного сервера. Однако они будут затронуты собственными настройками агента.

Это может быть полезно, например, когда места хранения документов (будь то локальное хранилище или точки монтирования NAS) не согласованы между серверами.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
snippets_file_prefix = /mnt/common/server1/
```
<!-- end -->

> **ВНИМАНИЕ:** Если вы всё ещё хотите получить доступ к файлам из корня файловой системы, вы должны явно установить `snippets_file_prefix` в пустое значение (строкой `snippets_file_prefix=`), или в корень (строкой `snippets_file_prefix=/`).


### sphinxql_state

<!-- example conf sphinxql_state -->
Путь к файлу, в котором будет сериализовано текущее состояние SQL.

При запуске сервера этот файл воспроизводится. При соответствующих изменениях состояния (например, SET GLOBAL) этот файл автоматически перезаписывается. Это может предотвратить трудно диагностируемую проблему: если вы загружаете UDF-функции, но Manticore аварийно завершает работу, то при (автоматическом) перезапуске ваши UDF и глобальные переменные больше не будут доступны. Использование постоянного состояния помогает обеспечить корректное восстановление без таких сюрпризов.

`sphinxql_state` нельзя использовать для выполнения произвольных команд, таких как `CREATE TABLE`.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
sphinxql_state = uservars.sql
```
<!-- end -->


### sphinxql_timeout

<!-- example conf sphinxql_timeout -->
Максимальное время ожидания между запросами (в секундах или с [специальными суффиксами](../Server_settings/Special_suffixes.md)) при использовании SQL-интерфейса. Необязательный параметр, по умолчанию 15 минут.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
sphinxql_timeout = 15m
```
<!-- end -->


### ssl_ca

<!-- example conf ssl_ca -->
Путь к файлу сертификата центра сертификации (CA) SSL (также известному как корневой сертификат). Необязательный параметр, по умолчанию пустой. Если не пустой, сертификат в `ssl_cert` должен быть подписан этим корневым сертификатом.

Сервер использует файл CA для проверки подписи на сертификате. Файл должен быть в формате PEM.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ssl_ca = keys/ca-cert.pem
```
<!-- end -->


### ssl_cert

<!-- example conf ssl_cert -->
Путь к SSL-сертификату сервера. Необязательный параметр, по умолчанию пустой.

Сервер использует этот сертификат в качестве самоподписанного открытого ключа для шифрования HTTP-трафика по SSL. Файл должен быть в формате PEM.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ssl_cert = keys/server-cert.pem
```
<!-- end -->


### ssl_key

<!-- example conf ssl_key -->
Путь к ключу SSL-сертификата. Необязательный параметр, по умолчанию пустой.

Сервер использует этот закрытый ключ для шифрования HTTP-трафика по SSL. Файл должен быть в формате PEM.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ssl_key = keys/server-key.pem
```
<!-- end -->


### subtree_docs_cache

<!-- example conf subtree_docs_cache -->
Максимальный размер кэша документов общего поддерева, на запрос. Необязательный параметр, по умолчанию 0 (отключено).

Эта настройка ограничивает использование оперативной памяти оптимизатором общего поддерева (см. [множественные запросы](../Searching/Multi-queries.md)). Максимум столько оперативной памяти будет потрачено на кэширование записей документов для каждого запроса. Установка предела в 0 отключает оптимизатор.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
subtree_docs_cache = 8M
```
<!-- end -->


### subtree_hits_cache

<!-- example conf subtree_hits_cache -->
Максимальный размер кэша вхождений общего поддерева, на запрос. Необязательный параметр, по умолчанию 0 (отключено).

Эта настройка ограничивает использование оперативной памяти оптимизатором общего поддерева (см. [множественные запросы](../Searching/Multi-queries.md)). Максимум столько оперативной памяти будет потрачено на кэширование вхождений ключевых слов (хитов) для каждого запроса. Установка предела в 0 отключает оптимизатор.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
subtree_hits_cache = 16M
```
<!-- end -->

### threads

<!-- example threads -->
Количество рабочих потоков (или размер пула потоков) для демона Manticore. Manticore создаёт это количество потоков ОС при запуске, и они выполняют все задачи внутри демона, такие как выполнение запросов, создание сниппетов и т.д. Некоторые операции могут быть разделены на подзадачи и выполняться параллельно, например:

* Поиск в таблице реального времени
* Поиск в распределённой таблице, состоящей из локальных таблиц
* Вызов запроса перколяции
* и другие

По умолчанию установлено равным количеству ядер ЦП на сервере. Manticore создаёт потоки при запуске и хранит их до остановки. Каждая подзадача может использовать один из потоков, когда он ей нужен. Когда подзадача завершается, она освобождает поток, чтобы другая подзадача могла его использовать.

В случае интенсивной нагрузки типа I/O может иметь смысл установить значение выше, чем количество ядер ЦП.

<!-- request Example -->
```ini
threads = 10
```

<!-- end -->

### thread_stack

<!-- example conf thread_stack -->
Максимальный размер стека для задачи (корутины, один поисковый запрос может вызвать несколько задач/корутин). Необязательный параметр, по умолчанию 128K.

У каждого задания есть свой собственный стек размером 128K. При запуске запроса проверяется, сколько стека ему требуется. Если стандартных 128K достаточно, запрос просто обрабатывается. Если требуется больше, планируется другое задание с увеличенным стеком, которое продолжает обработку. Максимальный размер такого расширенного стека ограничен этой настройкой.

Установка значения на достаточно высокий уровень поможет обрабатывать очень глубокие запросы, не подразумевая, что общее потребление оперативной памяти вырастет слишком сильно. Например, установка значения в 1G не означает, что каждое новое задание будет занимать 1G оперативной памяти, но если мы видим, что ему требуется, скажем, 100M стека, мы просто выделяем 100M для этого задания. Другие задания в то же время будут выполняться со своим стандартным стеком в 128K. Таким же образом мы можем выполнять даже более сложные запросы, которым требуется 500M. И только если мы **увидим** внутренне, что заданию требуется более 1G стека, мы завершимся с ошибкой и сообщим о слишком низком значении `thread_stack`.

Однако на практике даже запрос, которому требуется 16M стека, часто оказывается слишком сложным для разбора и потребляет слишком много времени и ресурсов для обработки. Таким образом, демон обработает его, но ограничение таких запросов с помощью настройки `thread_stack` выглядит вполне разумным.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
thread_stack = 8M
```
<!-- end -->


### unlink_old

<!-- example conf unlink_old -->
Определяет, удалять ли копии таблиц `.old` при успешной ротации. Необязательный параметр, значение по умолчанию — 1 (удалять).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
unlink_old = 0
```
<!-- end -->


### watchdog

<!-- example conf watchdog -->
Наблюдатель (watchdog) для многопоточного сервера. Необязательный параметр, значение по умолчанию — 1 (watchdog включен).

Когда запрос Manticore завершается аварийно, он может привести к падению всего сервера. При включенной функции watchdog `searchd` также поддерживает отдельный легковесный процесс, который отслеживает основной процесс сервера и автоматически перезапускает его в случае аномального завершения. Watchdog включен по умолчанию.

<!-- request Example -->

```ini
watchdog = 0 # disable watchdog
```
<!-- end -->
<!-- proofread -->
