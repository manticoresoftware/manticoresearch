# Раздел "Searchd" в конфигурации

Ниже приведены настройки, которые используются в разделе `searchd` файла конфигурации Manticore Search для управления поведением сервера. Ниже приведено краткое описание каждой настройки:

### access_plain_attrs

Эта настройка задает значения по умолчанию для всего экземпляра для [access_plain_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `mmap_preread`.

Директива `access_plain_attrs` позволяет определить значение по умолчанию для [access_plain_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Директивы для отдельных таблиц имеют более высокий приоритет и переопределяют это значение по умолчанию, обеспечивая более тонкий контроль.

### access_blob_attrs

Эта настройка задает значения по умолчанию для всего экземпляра для [access_blob_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `mmap_preread`.

Директива `access_blob_attrs` позволяет определить значение по умолчанию для [access_blob_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Директивы для отдельных таблиц имеют более высокий приоритет и переопределяют это значение по умолчанию, обеспечивая более тонкий контроль.

### access_doclists

Эта настройка задает значения по умолчанию для всего экземпляра для [access_doclists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `file`.

Директива `access_doclists` позволяет определить значение по умолчанию для [access_doclists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Директивы для отдельных таблиц имеют более высокий приоритет и переопределяют это значение по умолчанию, обеспечивая более тонкий контроль.

### access_hitlists

Эта настройка задает значения по умолчанию для всего экземпляра для [access_hitlists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `file`.

Директива `access_hitlists` позволяет определить значение по умолчанию для [access_hitlists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Директивы для отдельных таблиц имеют более высокий приоритет и переопределяют это значение по умолчанию, обеспечивая более тонкий контроль.

### access_dict

Эта настройка задает значения по умолчанию для всего экземпляра для [access_dict](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `mmap_preread`.

Директива `access_dict` позволяет определить значение по умолчанию для [access_dict](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Директивы для отдельных таблиц имеют более высокий приоритет и переопределяют это значение по умолчанию, обеспечивая более тонкий контроль.

### agent_connect_timeout

Эта настройка задает значения по умолчанию для всего экземпляра для параметра [agent_connect_timeout](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_connect_timeout).


### agent_query_timeout

Эта настройка задает значения по умолчанию для всего экземпляра для параметра [agent_query_timeout](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_query_timeout). Она может быть переопределена для каждого запроса с помощью клаузы `OPTION agent_query_timeout=XXX`.


### agent_retry_count

Эта настройка — целое число, которое указывает, сколько раз Manticore попытается подключиться и выполнить запрос к удалённым агентам через распределённую таблицу, прежде чем сообщить о фатальной ошибке запроса. Значение по умолчанию — 0 (т.е. без повторных попыток). Вы также можете задать это значение для каждого запроса с помощью клаузы `OPTION retry_count=XXX`. Если задана опция для конкретного запроса, она переопределит значение, указанное в конфигурации.

Обратите внимание, что если вы используете [agent mirrors](../Creating_a_cluster/Remote_nodes/Mirroring.md#Agent-mirrors) в определении вашей распределённой таблицы, сервер будет выбирать другой зеркальный агент для каждой попытки подключения в соответствии с выбранной стратегией [ha_strategy](../Creating_a_cluster/Remote_nodes/Load_balancing.md#ha_strategy). В этом случае `agent_retry_count` будет суммироваться для всех зеркал в наборе.

Например, если у вас 10 зеркал и установлено `agent_retry_count=5`, сервер будет пытаться до 50 раз, предполагая в среднем 5 попыток для каждого из 10 зеркал (при опции `ha_strategy = roundrobin` это будет так).

Однако значение, указанное в опции `retry_count` для [агента](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent), служит абсолютным лимитом. Другими словами, опция `[retry_count=2]` в определении агента всегда означает максимум 2 попытки, независимо от того, указали ли вы 1 или 10 зеркал для агента.

### agent_retry_delay

Эта настройка — целое число в миллисекундах (или [special_suffixes](../Server_settings/Special_suffixes.md)), которое задает задержку перед повторной попыткой запроса к удалённому агенту в случае сбоя. Это значение актуально только при ненулевом [agent_retry_count](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md) или ненулевом значении `retry_count` для конкретного запроса. Значение по умолчанию — 500. Вы также можете задать это значение для каждого запроса с помощью клаузы `OPTION retry_delay=XXX`. Если задана опция для конкретного запроса, она переопределит значение, указанное в конфигурации.


### attr_flush_period

<!-- example conf attr_flush_period -->
При использовании [Update](../Data_creation_and_modification/Updating_documents/UPDATE.md) для изменения атрибутов документа в реальном времени, изменения сначала записываются в копию атрибутов в памяти. Эти обновления происходят в файле с отображением в память, что означает, что ОС решает, когда записывать изменения на диск. При нормальном завершении работы `searchd` (инициируемом сигналом `SIGTERM`) все изменения принудительно записываются на диск.

Вы также можете указать `searchd` периодически записывать эти изменения на диск, чтобы предотвратить потерю данных. Интервал между этими сбросами определяется параметром `attr_flush_period`, указанным в секундах (или [special_suffixes](../Server_settings/Special_suffixes.md)).

По умолчанию значение равно 0, что отключает периодический сброс. Однако сброс все равно происходит при нормальном завершении работы.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
attr_flush_period = 900 # persist updates to disk every 15 minutes
```
<!-- end -->

### auto_optimize

<!-- example conf auto_optimize -->
Этот параметр управляет автоматическим процессом [OPTIMIZE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE) для сжатия таблицы.

По умолчанию сжатие таблицы происходит автоматически. Вы можете изменить это поведение с помощью параметра `auto_optimize`:
* 0 — отключить автоматическое сжатие таблицы (вы все еще можете вызвать `OPTIMIZE` вручную)
* 1 — явно включить его
* включить с умножением порога оптимизации на 2.

По умолчанию OPTIMIZE выполняется до тех пор, пока количество дисковых чанков не станет меньше или равно количеству логических ядер CPU, умноженному на 2.

Однако, если в таблице есть атрибуты с KNN индексами, этот порог отличается. В этом случае он устанавливается равным количеству физических ядер CPU, деленному на 2, для улучшения производительности KNN поиска.

Обратите внимание, что переключение `auto_optimize` в положение вкл/выкл не мешает вам запускать [OPTIMIZE TABLE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE) вручную.

<!-- intro -->
##### Пример:

<!-- request Disable -->
```ini
auto_optimize = 0 # disable automatic OPTIMIZE
```

<!-- request Throttle -->
```ini
auto_optimize = 2 # OPTIMIZE starts at 16 chunks (on 4 cpu cores server)
```

<!-- end -->

### auto_schema

<!-- example conf auto_schema -->
Manticore поддерживает автоматическое создание таблиц, которые еще не существуют, но указаны в операторах INSERT. Эта функция включена по умолчанию. Чтобы отключить её, явно установите `auto_schema = 0` в вашей конфигурации. Чтобы снова включить, установите `auto_schema = 1` или удалите параметр `auto_schema` из конфигурации.

Имейте в виду, что HTTP-эндпоинт `/bulk` не поддерживает автоматическое создание таблиц.

> ПРИМЕЧАНИЕ: [Функциональность авто-схемы](../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md#Auto-schema) требует [Manticore Buddy](../Installation/Manticore_Buddy.md). Если она не работает, убедитесь, что Buddy установлен.

<!-- request Disable -->
```ini
auto_schema = 0 # disable automatic table creation
```

<!-- request Enable -->
```ini
auto_schema = 1 # enable automatic table creation
```

<!-- end -->

### binlog_flush

<!-- example conf binlog_flush -->
Этот параметр управляет режимом сброса/синхронизации транзакций бинарного лога. Он необязателен, значение по умолчанию — 2 (сброс каждой транзакции, синхронизация каждую секунду).

Директива определяет, как часто бинарный лог будет сбрасываться в ОС и синхронизироваться на диск. Поддерживаются три режима:

*  0 — сброс и синхронизация каждую секунду. Это обеспечивает лучшую производительность, но при сбое сервера или ОС/аппаратном сбое можно потерять до 1 секунды подтвержденных транзакций.
*  1 — сброс и синхронизация каждой транзакции. Этот режим обеспечивает худшую производительность, но гарантирует сохранение данных каждой подтвержденной транзакции.
*  2 — сброс каждой транзакции, синхронизация каждую секунду. Этот режим обеспечивает хорошую производительность и гарантирует сохранение каждой подтвержденной транзакции при сбое сервера. Однако при сбое ОС/аппаратном сбое можно потерять до 1 секунды подтвержденных транзакций.

Для тех, кто знаком с MySQL и InnoDB, эта директива похожа на `innodb_flush_log_at_trx_commit`. В большинстве случаев режим 2 по умолчанию обеспечивает хороший баланс скорости и безопасности, с полной защитой данных RT таблиц от сбоев сервера и частичной защитой от аппаратных сбоев.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_flush = 1 # ultimate safety, low speed
```
<!-- end -->

### binlog_common

<!-- example conf binlog_common -->
Этот параметр управляет тем, как управляются файлы бинарного лога. Он необязателен, значение по умолчанию — 0 (отдельный файл для каждой таблицы).

Вы можете выбрать один из двух способов управления файлами бинарного лога:

* Отдельный файл для каждой таблицы (по умолчанию, `0`): каждая таблица сохраняет свои изменения в собственном лог-файле. Эта настройка хороша, если у вас много таблиц, которые обновляются в разное время. Это позволяет обновлять таблицы без ожидания других. Также, если возникает проблема с лог-файлом одной таблицы, это не влияет на другие.
* Один файл для всех таблиц (`1`): все таблицы используют один и тот же файл бинарного лога. Этот метод упрощает управление файлами, так как их меньше. Однако это может привести к тому, что файлы будут храниться дольше, если одна таблица все еще должна сохранить свои обновления. Эта настройка также может замедлить работу, если много таблиц нужно обновить одновременно, так как все изменения должны ждать записи в один файл.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_common = 1 # use a single binary log file for all tables
```
<!-- end -->

### binlog_max_log_size

<!-- example conf binlog_max_log_size -->
Этот параметр управляет максимальным размером файла бинарного лога. Он необязателен, значение по умолчанию — 256 МБ.

Новый файл binlog будет принудительно открыт, как только текущий файл достигнет этого предела размера. Это приводит к более мелкой гранулярности логов и может привести к более эффективному использованию диска binlog при определенных пограничных нагрузках. Значение 0 означает, что файл binlog не должен переоткрываться по размеру.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_max_log_size = 16M
```
<!-- end -->


### binlog_path

<!-- example conf binlog_path -->
Этот параметр определяет путь для файлов бинарного лога (также известного как журнал транзакций). Он необязателен, значение по умолчанию — каталог данных, настроенный во время сборки (например, `/var/lib/manticore/data/binlog.*` в Linux).

Двоичные логи используются для восстановления данных таблицы RT после сбоев и для обновления атрибутов простых дисковых индексов, которые в противном случае хранились бы только в ОЗУ до сброса. Когда ведение логов включено, каждая транзакция, зафиксированная (COMMIT) в таблице RT, записывается в файл журнала. Логи затем автоматически воспроизводятся при запуске после некорректного завершения работы, восстанавливая записанные изменения.

Директива `binlog_path` указывает расположение файлов двоичных логов. Она должна содержать только путь; `searchd` будет создавать и удалять несколько файлов `binlog.*` в каталоге по мере необходимости (включая данные binlog, метаданные и файлы блокировок и т.д.).

Пустое значение отключает двоичное логирование, что улучшает производительность, но подвергает данные таблицы RT риску.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_path = # disable logging
binlog_path = /var/lib/manticore/data # /var/lib/manticore/data/binlog.001 etc will be created
```
<!-- end -->

### boolean_simplify

<!-- example conf boolean_simplify -->
Этот параметр управляет значением по умолчанию для опции поиска [boolean_simplify](../Searching/Options.md#boolean_simplify). Он необязателен, значение по умолчанию — 1 (включено).

При установке в 1 сервер автоматически применит [оптимизацию булевых запросов](../Searching/Full_text_matching/Boolean_optimization.md) для улучшения производительности запросов. При установке в 0 запросы будут выполняться без оптимизации по умолчанию. Это значение по умолчанию можно переопределить для каждого запроса с помощью соответствующей опции поиска `boolean_simplify`.

<!-- request Example -->
```ini
searchd {
    boolean_simplify = 0  # disable boolean optimization by default
}
```
<!-- end -->

### buddy_path

<!-- example conf buddy_path -->
Этот параметр определяет путь к бинарному файлу Manticore Buddy. Он необязателен, значение по умолчанию — путь, настроенный во время сборки, который варьируется в зависимости от операционной системы. Обычно нет необходимости изменять этот параметр. Однако он может быть полезен, если вы хотите запустить Manticore Buddy в режиме отладки, внести изменения в Manticore Buddy или реализовать новый плагин. В последнем случае вы можете выполнить `git clone` Buddy с https://github.com/manticoresoftware/manticoresearch-buddy, добавить новый плагин в каталог `./plugins/` и запустить `composer install --prefer-source` для упрощения разработки после перехода в каталог исходников Buddy.

Для возможности запуска `composer` на вашей машине должен быть установлен PHP версии 8.2 или выше с следующими расширениями:

```
--enable-dom
--with-libxml
--enable-tokenizer
--enable-xml
--enable-xmlwriter
--enable-xmlreader
--enable-simplexml
--enable-phar
--enable-bcmath
--with-gmp
--enable-debug
--with-mysqli
--enable-mysqlnd
```

Вы также можете выбрать специальную версию `manticore-executor-dev` для Linux amd64, доступную в релизах, например: https://github.com/manticoresoftware/executor/releases/tag/v1.0.13

Если вы выберете этот путь, не забудьте связать dev-версию исполнителя manticore с `/usr/bin/php`.

Чтобы отключить Manticore Buddy, установите значение в пустое, как показано в примере.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
buddy_path = manticore-executor -n /usr/share/manticore/modules/manticore-buddy/src/main.php # use the default Manticore Buddy in Linux
buddy_path = manticore-executor -n /usr/share/manticore/modules/manticore-buddy/src/main.php --threads=1 # runs Buddy with a single worker
buddy_path = manticore-executor -n /opt/homebrew/share/manticore/modules/manticore-buddy/bin/manticore-buddy/src/main.php # use the default Manticore Buddy in MacOS arm64
buddy_path = manticore-executor -n /Users/username/manticoresearch-buddy/src/main.php # use Manticore Buddy from a non-default location
buddy_path = # disables Manticore Buddy
buddy_path = manticore-executor -n /Users/username/manticoresearch-buddy/src/main.php --skip=manticoresoftware/buddy-plugin-replace # --skip - skips plugins
buddy_path = manticore-executor -n /usr/share/manticore/modules/manticore-buddy/src/main.php --enable-plugin=manticoresoftware/buddy-plugin-show # runs Buddy with only the SHOW plugin
```
<!-- end -->

### client_timeout

<!-- example conf client_timeout -->
Этот параметр определяет максимальное время ожидания между запросами (в секундах или с использованием [special_suffixes](../Server_settings/Special_suffixes.md)) при использовании постоянных соединений. Он необязателен, значение по умолчанию — пять минут.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
client_timeout = 1h
```
<!-- end -->


### collation_libc_locale

<!-- example conf collation_libc_locale -->
Локаль libc сервера. Необязательный параметр, по умолчанию C.

Определяет локаль libc, влияющую на сортировки, основанные на libc. Подробнее см. в разделе [collations](../Searching/Collations.md).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
collation_libc_locale = fr_FR
```
<!-- end -->


### collation_server

<!-- example conf collation_server -->
Сортировка сервера по умолчанию. Необязательный параметр, по умолчанию libc_ci.

Определяет сортировку по умолчанию, используемую для входящих запросов. Сортировку можно переопределить для каждого запроса. Список доступных сортировок и другие детали см. в разделе [collations](../Searching/Collations.md).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
collation_server = utf8_ci
```
<!-- end -->


### data_dir

<!-- example conf data_dir -->
При указании этот параметр включает [режим реального времени](../Creating_a_table/Local_tables.md#Online-schema-management-%28RT-mode%29), который является императивным способом управления схемой данных. Значение должно быть путем к каталогу, в котором вы хотите хранить все ваши таблицы, двоичные логи и все остальное, необходимое для корректной работы Manticore Search в этом режиме.
Индексация [простых таблиц](../Creating_a_table/Local_tables/Plain_table.md) не разрешена при указании `data_dir`. Подробнее о различиях между режимом RT и простым режимом читайте в [этом разделе](../Read_this_first.md#Real-time-table-vs-plain-table).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
data_dir = /var/lib/manticore
```
<!-- end -->

### diskchunk_flush_search_timeout

<!-- example conf diskchunk_flush_search_timeout -->
Таймаут для предотвращения автоматического сброса RAM-чанка, если в таблице нет поисковых запросов. Необязательный параметр, по умолчанию 30 секунд.

Время проверки наличия поисков перед решением о необходимости автоматического сброса.
Автоматический сброс произойдет только если в таблице был хотя бы один поиск за последние `diskchunk_flush_search_timeout` секунд. Работает совместно с [diskchunk_flush_write_timeout](../Server_settings/Searchd.md#diskchunk_flush_write_timeout). Соответствующая [настройка на уровне таблицы](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#diskchunk_flush_search_timeout) имеет более высокий приоритет и переопределит это значение по умолчанию, обеспечивая более тонкий контроль.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
diskchunk_flush_search_timeout = 120s
```
<!-- end -->

### diskchunk_flush_write_timeout

<!-- example conf diskchunk_flush_write_timeout -->
Время в секундах ожидания без записи перед автоматическим сбросом RAM-чанка на диск. Необязательный параметр, по умолчанию 1 секунда.

Если в течение `diskchunk_flush_write_timeout` секунд в RAM-чанк не происходит запись, чанк будет сброшен на диск. Работает совместно с [diskchunk_flush_search_timeout](../Server_settings/Searchd.md#diskchunk_flush_search_timeout). Чтобы отключить авто-сброс, явно установите `diskchunk_flush_write_timeout = -1` в вашей конфигурации. Соответствующая [настройка для каждой таблицы](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#diskchunk_flush_write_timeout) имеет более высокий приоритет и переопределит это значение по умолчанию для всего экземпляра, обеспечивая более тонкий контроль.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
diskchunk_flush_write_timeout = 60s
```
<!-- end -->

### docstore_cache_size

<!-- example conf docstore_cache_size -->
Эта настройка задает максимальный размер блоков документов из хранилища документов, которые удерживаются в памяти. Опционально, значение по умолчанию — 16m (16 мегабайт).

Когда используется `stored_fields`, блоки документов читаются с диска и распаковываются. Поскольку каждый блок обычно содержит несколько документов, он может быть повторно использован при обработке следующего документа. Для этой цели блок удерживается в кэше на уровне сервера. Кэш хранит распакованные блоки.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
docstore_cache_size = 8m
```
<!-- end -->

### engine

<!-- example conf engine -->
Движок хранения атрибутов по умолчанию, используемый при создании таблиц в режиме RT. Может быть `rowwise` (по умолчанию) или `columnar`.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
engine = columnar
```
<!-- end -->


### expansion_limit

<!-- example conf expansion_limit -->
Эта настройка определяет максимальное количество расширенных ключевых слов для одного подстановочного знака. Опционально, значение по умолчанию — 0 (без ограничений).

При выполнении поиска подстрок в таблицах с включенным `dict = keywords` один подстановочный знак может привести к тысячам или даже миллионам совпадающих ключевых слов (например, сопоставление `a*` со всем словарем Оксфорда). Эта директива позволяет ограничить влияние таких расширений. Установка `expansion_limit = N` ограничивает расширения не более чем N наиболее частыми совпадающими ключевыми словами (для каждого подстановочного знака в запросе).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_limit = 16
```
<!-- end -->

### expansion_merge_threshold_docs

<!-- example conf expansion_merge_threshold_docs -->
Эта настройка определяет максимальное количество документов в расширенном ключевом слове, при котором возможно объединение всех таких ключевых слов вместе. Опционально, значение по умолчанию — 32.

При выполнении поиска подстрок в таблицах с включенным `dict = keywords` один подстановочный знак может привести к тысячам или даже миллионам совпадающих ключевых слов. Эта директива позволяет увеличить лимит количества ключевых слов, которые будут объединены для ускорения сопоставления, но при этом используется больше памяти в поиске.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_merge_threshold_docs = 1024
```
<!-- end -->

### expansion_merge_threshold_hits

<!-- example conf expansion_merge_threshold_hits -->
Эта настройка определяет максимальное количество попаданий в расширенном ключевом слове, при котором возможно объединение всех таких ключевых слов вместе. Опционально, значение по умолчанию — 256.

При выполнении поиска подстрок в таблицах с включенным `dict = keywords` один подстановочный знак может привести к тысячам или даже миллионам совпадающих ключевых слов. Эта директива позволяет увеличить лимит количества ключевых слов, которые будут объединены для ускорения сопоставления, но при этом используется больше памяти в поиске.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_merge_threshold_hits = 512
```
<!-- end -->

### expansion_phrase_limit

<!-- example conf expansion_phrase_limit -->
Эта настройка контролирует максимальное количество альтернативных вариантов фраз, сгенерированных из-за операторов `OR` внутри операторов `PHRASE`, `PROXIMITY` и `QUORUM`. Опционально, значение по умолчанию — 1024.

При использовании оператора `|` (OR) внутри операторов, похожих на фразы, общее количество расширенных комбинаций может расти экспоненциально в зависимости от количества указанных альтернатив. Эта настройка помогает предотвратить чрезмерное расширение запроса, ограничивая количество перестановок, рассматриваемых при обработке запроса.

Если количество сгенерированных вариантов превышает этот лимит, запрос либо:

- завершится с ошибкой (поведение по умолчанию)
- вернет частичные результаты с предупреждением, если включен `expansion_phrase_warning`

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_phrase_limit = 4096
```
<!-- end -->

### expansion_phrase_warning

<!-- example conf expansion_phrase_warning -->
Эта настройка контролирует поведение при превышении лимита расширения запроса, определенного `expansion_phrase_limit`.

По умолчанию запрос завершится с сообщением об ошибке. При установке `expansion_phrase_warning` в 1 поиск продолжается с использованием частичной трансформации фразы (до настроенного лимита), и сервер возвращает пользователю предупреждающее сообщение вместе с результатами. Это позволяет запросам, слишком сложным для полного расширения, возвращать частичные результаты без полного сбоя.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_phrase_warning = 1
```
<!-- end -->

### grouping_in_utc

Эта настройка определяет, будет ли группировка по времени в API и SQL рассчитываться в локальном часовом поясе или в UTC. Опционально, значение по умолчанию — 0 (означает «локальный часовой пояс»).

По умолчанию все выражения 'group by time' (например, group by day, week, month и year в API, а также group by day, month, year, yearmonth, yearmonthday в SQL) выполняются с использованием часового пояса, настроенного для временных функций (см. настройку `timezone` или переменную окружения `TZ`). Например, если у вас есть документы с атрибутами времени `13:00 utc` и `15:00 utc`, при группировке они оба попадут в группы по объектам в соответствии с вашей настройкой часового пояса. Если вы живёте в `utc`, это будет один день, но если вы живёте в `utc+10`, то эти документы попадут в разные группы по дню (так как 13:00 utc в часовом поясе UTC+10 — это 23:00 местного времени, а 15:00 — 01:00 следующего дня). Иногда такое поведение недопустимо, и желательно сделать группировку времени независимой от часового пояса. Включение этой опции (либо в конфиге, либо с помощью оператора [SET global](../Server_settings/Setting_variables_online.md#SET) в SQL) приведёт к тому, что все выражения группировки по времени будут вычисляться в UTC независимо от настройки часового пояса.

**Примечание:** Логирование всегда использует фактический локальный часовой пояс системы (определяется по `/etc/localtime` в системах, подобных Unix), независимо от переменной окружения `TZ` или настройки `timezone`. Это гарантирует, что метки времени в логах отражают реальное системное время, что полезно для отладки и мониторинга.


### timezone

Эта настройка задаёт часовой пояс, используемый функциями, связанными с датой и временем (такими как `NOW()`, `CURTIME()`, `FROM_UNIXTIME()` и др.). По умолчанию используется локальный часовой пояс системы, но вы можете указать другой часовой пояс в формате IANA (например, `Europe/Amsterdam` или `Asia/Singapore`).

**Порядок определения часового пояса:**
1. Если явно задана настройка конфигурации `timezone`, она имеет приоритет.
2. Иначе, если задана переменная окружения `TZ`, используется она.
3. Если ни одна из них не задана, используется локальный часовой пояс системы (из `/etc/localtime` на системах типа Unix).

**Важные замечания:**
- **Логирование:** Логирование всегда использует фактический локальный часовой пояс системы (определяется по `/etc/localtime`), независимо от переменной окружения `TZ` или настройки `timezone`. Это гарантирует, что временные метки в логах отражают реальное системное время, что полезно для отладки и мониторинга.
- **Временные функции:** Функции, связанные с датой и временем, учитывают настройку `timezone` или переменную окружения `TZ`, если они заданы, иначе используют локальный часовой пояс системы.
- **Группировка:** Если включён параметр `grouping_in_utc`, то функция «group by time» будет использовать UTC, в то время как другие функции, связанные с датой и временем, будут использовать часовой пояс, указанный в этой настройке. В целом не рекомендуется смешивать `grouping_in_utc` и `timezone`.

Вы можете настроить эту опцию либо в конфигурации, либо с помощью оператора [SET global](../Server_settings/Setting_variables_online.md#SET) в SQL.


### ha_period_karma

<!-- example conf ha_period_karma -->
Эта настройка задаёт размер окна статистики агента-зеркала в секундах (или с использованием [специальных суффиксов](../Server_settings/Special_suffixes.md)). Настройка необязательная, значение по умолчанию — 60 секунд.

Для распределённой таблицы с агентскими зеркалами (смотрите подробнее в [agent](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md)) мастер отслеживает несколько разных счетчиков по каждому зеркалу. Эти счетчики затем используются для переключения и балансировки (мастер выбирает лучшее зеркало на основе счетчиков). Счетчики накапливаются блоками по `ha_period_karma` секунд.

После начала нового блока мастер всё ещё может использовать накопленные значения из предыдущего блока, пока новый блок не заполнится наполовину. В результате, любая предыдущая история перестаёт влиять на выбор зеркала максимум через 1.5 раза ha_period_karma секунд.

Хотя для выбора зеркала используется максимум два блока, для инструментирования хранится до 15 последних блоков. Эти блоки можно просмотреть с помощью оператора [SHOW AGENT STATUS](../Node_info_and_management/Node_status.md#SHOW-AGENT-STATUS).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ha_period_karma = 2m
```
<!-- end -->


### ha_ping_interval

<!-- example conf ha_ping_interval -->
Эта настройка задаёт интервал между пингами агентских зеркал в миллисекундах (или с использованием [специальных суффиксов](../Server_settings/Special_suffixes.md)). Настройка необязательная, значение по умолчанию — 1000 миллисекунд.

Для распределённой таблицы с агентскими зеркалами (смотрите подробнее в [agent](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md)) мастер посылает всем зеркалам команду пинга в периоды бездействия. Это необходимо для отслеживания текущего статуса агента (активен или неактивен, сетевой RTT и т. д.). Интервал между такими пингами задаётся этой директивой. Чтобы отключить пинги, установите ha_ping_interval в 0.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ha_ping_interval = 3s
```
<!-- end -->


### hostname_lookup

Опция `hostname_lookup` определяет стратегию обновления имён хостов. По умолчанию IP-адреса хостов агентов кэшируются при запуске сервера, чтобы избежать чрезмерного обращения к DNS. Однако в некоторых случаях IP может динамически меняться (например, в облачных хостингах), и может быть желательно не кэшировать IP-адреса. Установка этой опции в значение `request` отключает кэширование и выполняет запросы к DNS для каждого запроса. IP-адреса также можно обновлять вручную с помощью команды `FLUSH HOSTNAMES`.

### jobs_queue_size

Настройка jobs_queue_size определяет, сколько "заданий" может находиться в очереди одновременно. По умолчанию неограничено.

В большинстве случаев «задача» означает один запрос к одной локальной таблице (обычной таблице или дисковому чанку таблицы реального времени). Например, если у вас есть распределённая таблица, состоящая из 2 локальных таблиц, или таблица реального времени с 2 дисковыми чанками, запрос поиска к любой из них в основном ставит в очередь 2 задачи. Затем их обрабатывает пул потоков (размер которого определяется настройкой [threads](../Server_settings/Searchd.md#threads)). Однако в некоторых случаях, если запрос слишком сложный, может быть создано больше задач. Рекомендуется изменить эту настройку, когда [max_connections](../Server_settings/Searchd.md#max_connections) и [threads](../Server_settings/Searchd.md#threads) недостаточны для достижения баланса между желаемой производительностью.

### join_batch_size

Объединения таблиц работают путём накопления пакета совпадений, которые являются результатами запроса, выполненного по левой таблице. Этот пакет затем обрабатывается как единый запрос по правой таблице.

Эта опция позволяет настроить размер пакета. Значение по умолчанию — `1000`, а установка этого параметра в `0` отключает пакетирование.

Больший размер пакета может улучшить производительность; однако для некоторых запросов это может привести к чрезмерному потреблению памяти.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
join_batch_size = 2000
```
<!-- end -->

### join_cache_size

Каждый запрос, выполняемый по правой таблице, определяется конкретными условиями JOIN ON, которые определяют набор результатов, извлекаемых из правой таблицы.

Если уникальных условий JOIN ON немного, повторное использование результатов может быть эффективнее, чем многократное выполнение запросов по правой таблице. Для этого результаты сохраняются в кэше.

Эта опция позволяет настроить размер этого кэша. Значение по умолчанию — `20 MB`, установка этого параметра в 0 отключает кэширование.

Обратите внимание, что каждый поток поддерживает свой собственный кэш, поэтому при оценке общего использования памяти следует учитывать количество потоков, выполняющих запросы.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
join_cache_size = 10M
```
<!-- end -->

### listen_backlog

<!-- example conf listen_backlog -->
Параметр listen_backlog определяет длину очереди TCP для входящих соединений. Это особенно важно для сборок на Windows, которые обрабатывают запросы по одному. Когда очередь соединений достигает своего предела, новые входящие подключения будут отклоняться.
Для сборок, отличных от Windows, значение по умолчанию обычно работает нормально, и обычно нет необходимости изменять этот параметр.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
listen_backlog = 20
```
<!-- end -->

### kibana_version_string

<!-- example conf kibana_version_string -->
Строка версии сервера, которая возвращается Kibana или OpenSearch Dashboards. Необязательно — по умолчанию установлено `7.6.0`.

Некоторые версии Kibana и OpenSearch Dashboards ожидают, что сервер сообщит конкретный номер версии, и могут вести себя по-разному в зависимости от него. Чтобы обойти такие проблемы, можно использовать эту настройку, которая заставляет Manticore сообщать Kibana или OpenSearch Dashboards пользовательскую версию.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
kibana_version_string = 1.2.3
```
<!-- end -->

### listen

<!-- example conf listen -->
Эта настройка позволяет указать IP-адрес и порт, или путь Unix-домена сокета, на которых Manticore будет принимать соединения.

Общий синтаксис для `listen`:

```ini
listen = ( address ":" port | port | path | address ":" port start - port end ) [ ":" protocol [ "_vip" ] [ "_readonly" ] ]
```

Можно указать:
* либо IP-адрес (или имя хоста) и номер порта
* либо только номер порта
* либо путь Unix-сокета (не поддерживается на Windows)
* либо IP-адрес и диапазон портов

Если указан номер порта без адреса, `searchd` будет слушать на всех сетевых интерфейсах. Путь Unix определяется ведущим слешем. Диапазон портов может быть задан только для протокола репликации.

Также можно указать обработчик протокола (слушатель), который будет использоваться для соединений на этом сокете. Слушатели:

* **Не указано** — Manticore будет принимать соединения на этом порту от:
  - других агентов Manticore (то есть удалённой распределённой таблицы)
  - клиентов через HTTP и HTTPS
  - [Manticore Buddy](https://manticoresearch.com/blog/manticoresearch-buddy-intro/). **Убедитесь, что у вас есть слушатель такого типа (или слушатель `http`, как указано ниже), чтобы избежать ограничений в функциональности Manticore.**
* `mysql` — протокол MySQL для соединений с MySQL-клиентами. Примечание:
  - Поддерживается также сжатый протокол.
  - Если включён [SSL](../Security/SSL.md#SSL), можно установить зашифрованное соединение.
* `replication` — протокол репликации для общения между узлами. Подробности в разделе [репликация](../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md). Можно указать несколько слушателей для репликации, но все они должны слушать на одном IP, различаться могут только порты. Если вы задаёте слушатель репликации с диапазоном портов (например, `listen = 192.168.0.1:9320-9328:replication`), Manticore не начинает слушать эти порты сразу. Вместо этого он будет брать случайные свободные порты из указанного диапазона только при использовании репликации. Для правильной работы репликации требуется как минимум 2 порта в диапазоне.
* `http` — то же, что и **Не указано**. Manticore будет принимать соединения на этом порту от удалённых агентов и клиентов через HTTP и HTTPS.
* `https` — протокол HTTPS. Manticore будет принимать **только** HTTPS-соединения на этом порту. Подробнее в разделе [SSL](../Security/SSL.md).
* `sphinx` — устаревший бинарный протокол. Используется для обслуживания соединений от удалённых клиентов [SphinxSE](../Extensions/SphinxSE.md). Некоторые реализации клиентов API Sphinx (например, Java) требуют явного объявления слушателя.

Добавление суффикса `_vip` к клиентским протоколам (то есть ко всем, кроме `replication`, например `mysql_vip` или `http_vip` или просто `_vip`) заставляет создавать отдельный поток для подключения, чтобы обойти различные ограничения. Это полезно для обслуживания узлов в случае серьёзной перегрузки, когда сервер иначе мог бы зависать или не дать подключиться через обычный порт.

Суффикс `_readonly` устанавливает для слушателя [режим только для чтения](../Security/Read_only.md) и ограничивает приём только запросами на чтение.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
listen = localhost
listen = localhost:5000 # listen for remote agents (binary API) and http/https requests on port 5000 at localhost
listen = 192.168.0.1:5000 # listen for remote agents (binary API) and http/https requests on port 5000 at 192.168.0.1
listen = /var/run/manticore/manticore.s # listen for binary API requests on unix socket
listen = /var/run/manticore/manticore.s:mysql # listen for mysql requests on unix socket
listen = 9312 # listen for remote agents (binary API) and http/https requests on port 9312 on any interface
listen = localhost:9306:mysql # listen for mysql requests on port 9306 at localhost
listen = localhost:9307:mysql_readonly # listen for mysql requests on port 9307 at localhost and accept only read queries
listen = 127.0.0.1:9308:http # listen for http requests as well as connections from remote agents (and binary API) on port 9308 at localhost
listen = 192.168.0.1:9320-9328:replication # listen for replication connections on ports 9320-9328 at 192.168.0.1
listen = 127.0.0.1:9443:https # listen for https requests (not http) on port 9443 at 127.0.0.1
listen = 127.0.0.1:9312:sphinx # listen for legacy Sphinx requests (e.g. from SphinxSE) on port 9312 at 127.0.0.1
```
<!-- end -->

Может быть несколько директив `listen`. `searchd` будет прослушивать клиентские подключения на всех указанных портах и сокетах. Конфигурация по умолчанию, предоставляемая в пакетах Manticore, задает прослушивание на портах:
* `9308` и `9312` для подключений от удаленных агентов и клиентов, не основанных на MySQL
* и на порту `9306` для MySQL-подключений.

Если вы совсем не укажете `listen` в конфигурации, Manticore будет ждать подключения на:
* `127.0.0.1:9306` для MySQL-клиентов
* `127.0.0.1:9312` для HTTP/HTTPS и подключений от других узлов Manticore и клиентов, основанных на бинарном API Manticore.

#### Прослушивание на привилегированных портах

По умолчанию Linux не позволяет запускать Manticore с прослушкой порта ниже 1024 (например, `listen = 127.0.0.1:80:http` или `listen = 127.0.0.1:443:https`), если вы не запускаете searchd под root. Если вы все же хотите запускать Manticore, чтобы он слушал порты < 1024 под непривилегированным пользователем, рассмотрите один из следующих вариантов (любой из них должен работать):
* Выполните команду `setcap CAP_NET_BIND_SERVICE=+eip /usr/bin/searchd`
* Добавьте `AmbientCapabilities=CAP_NET_BIND_SERVICE` в systemd-юнит Manticore и перезагрузите демон (`systemctl daemon-reload`).

#### Технические детали о протоколе Sphinx API и TFO
<details>
Устаревший протокол Sphinx имеет 2 фазы: обмен рукопожатием и поток данных. Рукопожатие состоит из пакета в 4 байта от клиента и пакета в 4 байта от демона с единственной целью — клиент определяет, что с другой стороны настоящий демон Sphinx, а демон определяет, что с другой стороны настоящий клиент Sphinx. Основной поток данных довольно прост: обе стороны обмениваются рукопожатиями, и противоположная сторона их проверяет. Такой обмен короткими пакетами подразумевает использование специального флага `TCP_NODELAY`, который отключает алгоритм Нагла TCP и говорит, что TCP-соединение будет выполняться как диалог маленьких пакетов.
Однако не строго определено, кто говорит первым в этом переговоре. Исторически все клиенты, использующие бинарный API, говорят первыми: посылают рукопожатие, затем читают 4 байта от демона, затем отправляют запрос и читают ответ от демона.
Когда мы улучшали совместимость протокола Sphinx, мы учли следующее:

1. Обычно связь master-agent устанавливается от известного клиента к известному хосту на известный порт. Так что вполне невозможно, что конечная точка предоставит неправильное рукопожатие. Следовательно, мы можем неявно предполагать, что обе стороны валидны и действительно работают по протоколу Sphinx.
2. Учитывая это предположение, мы можем «склеить» рукопожатие с реальным запросом и отправить в одном пакете. Если бекенд — устаревший демон Sphinx, он просто прочитает этот «склеенный» пакет как 4 байта рукопожатия, затем тело запроса. Поскольку они пришли в одном пакете, у бекенда на сокете -1 RTT, а буфер клиента продолжит работать обычным способом несмотря на это.
3. Продолжая предположение: поскольку пакет 'запроса' достаточно мал, а рукопожатие еще меньше, давайте отправим оба в первоначальном TCP-пакете 'SYN' с использованием современной техники TFO (tcp-fast-open). То есть мы подключаемся к удаленному узлу с «склеенным» пакетом рукопожатия + тела. Демон принимает соединение и сразу получает и рукопожатие, и тело в буфере сокета, так как они пришли в самом первом TCP-пакете 'SYN'. Это устраняет еще одно RTT.
4. Наконец, научить демон принимать это улучшение. На уровне приложения это подразумевает НЕ использовать `TCP_NODELAY`. На уровне системы это значит убедиться, что на стороне демона включен прием TFO, а на стороне клиента — отправка TFO тоже включена. По умолчанию в современных системах клиентский TFO уже включен по умолчанию, поэтому вам нужно настроить только серверный TFO для корректной работы.

Все эти улучшения без изменения самого протокола позволили нам сократить 1.5 RTT протокола TCP при соединении. Если запрос и ответ могут поместиться в один TCP-пакет, это уменьшает всю сессию бинарного API с 3.5 RTT до 2 RTT — что делает сетевой обмен почти в 2 раза быстрее.

Итак, все наши улучшения основаны на изначально неопределенном утверждении: «кто говорит первым». Если клиент говорит первым, мы можем применить все эти оптимизации и эффективно обработать коннект + рукопожатие + запрос в одном TFO-пакете. Более того, мы можем посмотреть в начало полученного пакета и определить реальный протокол. Вот почему вы можете подключаться к одному и тому же порту через API/http/https. Если же демон должен говорить первым, все эти оптимизации невозможны, и мультипротокол тоже невозможен. Вот почему у нас отдельный порт для MySQL, и мы его не объединяли со всеми другими протоколами в один порт. Вдруг среди всех клиентов оказался один, написанный с предположением, что демон должен сначала отправить рукопожатие. Это — плагин SphinxSE для mysql/mariadb. Специально для этого клиента мы выделили `sphinx` proto, чтобы работать максимально по старому сценарию. А именно: обе стороны активируют `TCP_NODELAY` и обмениваются малыми пакетами. Демон отправляет рукопожатие при подключении, клиент отвечает своим, и затем все работает как обычно. Это не очень оптимально, но работает. Если вы используете SphinxSE для подключения к Manticore — нужно выделить слушатель с явно указанным `sphinx` proto. Для других клиентов избегайте использования этого слушателя, так как он медленнее. Если вы используете другие устаревшие клиенты Sphinx API — сначала проверьте, могут ли они работать с недедicated мультипротокольным портом. Для связки master-agent использование недедicated (мультипротокольного) порта с включенным TFO на клиенте и сервере работает хорошо и определенно ускорит работу сетевого бекенда, особенно если у вас очень легкие и быстрые запросы.
</details>

### listen_tfo

Этот параметр позволяет установить флаг TCP_FASTOPEN для всех слушателей. По умолчанию он управляется системой, но может быть явно выключен установкой значения '0'.

Для общего ознакомления с расширением TCP Fast Open обратитесь, пожалуйста, к [Wikipedia](https://en.wikipedia.org/wiki/TCP_Fast_Open). Кратко, оно позволяет устранить один TCP раунд-трип при установлении соединения.

На практике использование TFO во многих ситуациях может оптимизировать сетевую эффективность клиент-агента, как если бы использовались [персистентные агенты](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md), но без удержания активных соединений, а также без ограничения максимального количества соединений.

В современных ОС поддержка TFO обычно включена на системном уровне, но это просто «возможность», а не правило. Linux (как самая прогрессивная) поддерживает его с 2011 года, начиная с ядра 3.7 (для серверной стороны). Windows поддерживает его с некоторых сборок Windows 10. Другие операционные системы (FreeBSD, MacOS) также участвуют.

Для Linux сервер проверяет переменную `/proc/sys/net/ipv4/tcp_fastopen` и ведет себя согласно ей. Бит 0 управляет клиентской стороной, бит 1 — слушателями. По умолчанию этот параметр установлен в 1, т.е. клиенты включены, слушатели отключены.

### log

<!-- example conf log -->
Параметр log определяет имя файла журнала, в который будут записываться все события работы `searchd`. Если не указано, по умолчанию имя — 'searchd.log'.

В качестве имени файла можно указать 'syslog'. В этом случае события будут отправляться демону syslog. Чтобы использовать опцию syslog, нужно настроить Manticore с параметром `-–with-syslog` при сборке.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
log = /var/log/searchd.log
```
<!-- end -->


### max_batch_queries

<!-- example conf max_batch_queries -->
Ограничивает количество запросов в одном пакете. Необязательно, по умолчанию 32.

Обеспечивает проверку здравости количества запросов, подаваемых в одном пакете при использовании [мультизапросов](../Searching/Multi-queries.md). Установите 0, чтобы отключить проверку.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_batch_queries = 256
```
<!-- end -->

### max_connections

<!-- example max_connections -->
Максимальное количество одновременных клиентских подключений. По умолчанию неограничено. Обычно это заметно только при использовании любых персистентных соединений, например, cli mysql сессий или персистентных удалённых соединений из распределённых таблиц. При превышении лимита вы всё ещё можете подключиться к серверу, используя [VIP-соединение](../Connecting_to_the_server/MySQL_protocol.md#VIP-connection). VIP-соединения не учитываются в лимите.

<!-- request Example -->
```ini
max_connections = 10
```

<!-- end -->

### max_threads_per_query

<!-- example max_threads_per_query -->
Глобальный лимит потоков, которые может использовать одна операция. По умолчанию соответствующие операции могут занимать все ядра CPU, не оставляя места для других операций. Например, `call pq` по достаточно большой таблице перколяции может использовать все потоки на десятки секунд. Установка `max_threads_per_query`, например, в половину от значения [threads](../Server_settings/Searchd.md#threads) гарантирует, что вы сможете запускать несколько таких `call pq` операций параллельно.

Эту настройку также можно установить как сессионную или глобальную переменную во время работы.

Дополнительно поведение можно контролировать на уровне отдельного запроса с помощью опции [threads OPTION](../Searching/Options.md#threads).

<!-- intro -->
##### Пример:
<!-- request Example -->

```ini
max_threads_per_query = 4
```

<!-- end -->

### max_filters

<!-- example conf max_filters -->
Максимально допустимое количество фильтров на запрос. Эта настройка используется только для внутренних проверок и напрямую не влияет на использование ОЗУ или производительность. Необязательно, по умолчанию 256.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_filters = 1024
```
<!-- end -->


### max_filter_values

<!-- example conf max_filter_values -->
Максимально допустимое количество значений на фильтр. Эта настройка используется только для внутренних проверок и напрямую не влияет на использование ОЗУ или производительность. Необязательно, по умолчанию 4096.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_filter_values = 16384
```
<!-- end -->


### max_open_files

<!-- example conf max_open_files -->
Максимальное количество файлов, которые сервер может открыть, называется «мягким лимитом». Обратите внимание, что обслуживание больших фрагментированных таблиц реального времени может потребовать установки этого лимита высоко, так как каждый диск-чанк может занимать десятки или более файлов. Например, таблица реального времени с 1000 чанков может потребовать открытия тысяч файлов одновременно. Если вы видите ошибку 'Too many open files' в журналах, попробуйте изменить эту опцию — она может помочь.

Существует также «жесткий лимит», который нельзя превысить с помощью опции. Этот предел задаётся системой и может быть изменён в файле `/etc/security/limits.conf` в Linux. Для других ОС могут применяться другие подходы, обратитесь к документации.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_open_files = 10000
```
<!-- end -->

<!-- example conf max_open_files max -->
Кроме прямых числовых значений, можно использовать магическое слово 'max', чтобы установить лимит равным текущему доступному жёсткому лимиту.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_open_files = max
```
<!-- end -->


### max_packet_size

<!-- example conf max_packet_size -->
Максимально допустимый размер сетевого пакета. Эта настройка ограничивает как пакеты запросов от клиентов, так и пакеты ответов от удалённых агентов в распределённой среде. Используется только для внутренних проверок, не влияет напрямую на использование ОЗУ или производительность. Необязательно, по умолчанию 128M.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_packet_size = 32M
```
<!-- end -->


### mysql_version_string

<!-- example conf mysql_version_string -->
Строка версии сервера, возвращаемая через MySQL протокол. Необязательно, по умолчанию пустая (возвращается версия Manticore).

Некоторые придирчивые клиенты MySQL зависят от определённого формата номера версии, используемого MySQL, и, более того, иногда выбирают другой путь выполнения в зависимости от указанного номера версии (а не от указанных флагов возможностей). Например, Python MySQLdb 1.2.2 выдает исключение, если номер версии не в формате X.Y.ZZ; MySQL .NET connector 6.3.x внутренне падает при номерах версий 1.x вместе с определённой комбинацией флагов и т.д. Чтобы обойти это, можно использовать директиву `mysql_version_string` и заставить `searchd` сообщать другой номер версии клиентам, подключающимся по протоколу MySQL. (По умолчанию он сообщает собственную версию.)


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
mysql_version_string = 5.0.37
```
<!-- end -->


### net_workers

Количество сетевых потоков, значение по умолчанию — 1.

Этот параметр полезен при чрезвычайно высокой частоте запросов, когда одного потока недостаточно для управления всеми входящими запросами.


### net_wait_tm

Управляет интервалом busy loop сетевого потока. По умолчанию равно -1, может быть установлено в -1, 0 или положительное целое число.

В случаях, когда сервер настроен как чистый мастер и просто маршрутизирует запросы к агентам, важно обрабатывать запросы без задержек и не позволять сетевому потоку заснуть. Для этого используется busy loop. После входящего запроса сетевой поток использует CPU polling в течение `10 * net_wait_tm` миллисекунд, если `net_wait_tm` положительно, или поллинг только с CPU, если `net_wait_tm` равно `0`. Также busy loop может быть отключен с помощью `net_wait_tm = -1` — в этом случае poller устанавливает таймауты исходя из фактических таймаутов агентов при системном вызове опроса.

> **ВНИМАНИЕ:** CPU busy loop действительно грузит ядро процессора, поэтому установка этого параметра в любое ненулевое значение приведёт к заметному использованию CPU даже при простое сервера.


### net_throttle_accept

Определяет, сколько клиентов принимается за каждую итерацию сетевого цикла. По умолчанию 0 (без ограничений), что подходит большинству пользователей. Это опция тонкой настройки для управления пропускной способностью сетевого цикла в условиях высокой нагрузки.


### net_throttle_action

Определяет, сколько запросов обрабатывается за каждую итерацию сетевого цикла. По умолчанию 0 (без ограничений), что подходит большинству пользователей. Это опция тонкой настройки для управления пропускной способностью сетевого цикла в условиях высокой нагрузки.

### network_timeout

<!-- example conf network_timeout -->
Таймаут чтения/записи клиентского запроса, в секундах (или с [специальными суффиксами](../Server_settings/Special_suffixes.md)). Необязательно, по умолчанию 5 секунд. `searchd` принудительно закрывает клиентское соединение, которое не отправляет запрос или не читает результат в течение этого таймаута.

Также обратите внимание на параметр [reset_network_timeout_on_packet](../Server_settings/Searchd.md#reset_network_timeout_on_packet). Он изменяет поведение `network_timeout` с применения ко всему `запросу` или `результату` на применение к отдельным пакетам. Обычно запрос/результат помещается в один или два пакета. Однако в случаях, когда требуется большое количество данных, этот параметр может быть крайне полезен для поддержания активности операций.

<!-- request Example -->

```ini
network_timeout = 10s
```
<!-- end -->

### node_address

<!-- example conf node_address -->
Этот параметр позволяет указать сетевой адрес узла. По умолчанию установлен на адрес репликации [listen](../Server_settings/Searchd.md#listen). Это правильно в большинстве случаев; однако есть ситуации, когда нужно указать его вручную:

* Узел за файрволом
* Включён транслятор сетевых адресов (NAT)
* Развёртывания в контейнерах, таких как Docker или облачные развертывания
* Кластеры с узлами в нескольких регионах


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
node_address = 10.101.0.10
```
<!-- end -->

### not_terms_only_allowed

<!-- example conf not_terms_only_allowed -->
Этот параметр определяет, разрешить ли запросы, содержащие только оператор полного текста [отрицания](../Searching/Full_text_matching/Operators.md#Negation-operator). Необязательно, по умолчанию 0 (запросы с только оператором NOT не разрешены).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
not_terms_only_allowed = 1
```
<!-- end -->

### optimize_cutoff

<!-- example conf optimize_cutoff -->
Устанавливает порог оптимизации компакции таблицы по умолчанию. Подробнее здесь — [Число оптимизированных дисковых чанков](../Securing_and_compacting_a_table/Compacting_a_table.md#Number-of-optimized-disk-chunks). Этот параметр можно переопределить с помощью опции [cutoff](../Securing_and_compacting_a_table/Compacting_a_table.md#Number-of-optimized-disk-chunks) для конкретного запроса. Также может быть изменён динамически через [SET GLOBAL](../Server_settings/Setting_variables_online.md#SET).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
optimize_cutoff = 4
```
<!-- end -->

### persistent_connections_limit

<!-- example conf persistent_connections_limit -->
Этот параметр определяет максимальное количество одновременных постоянных соединений к удалённым [постоянным агентам](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md). Каждый раз при подключении к агенту, определённому в `agent_persistent`, система пытается использовать существующее соединение (если оно есть), или соединяется и сохраняет соединение для будущего использования. Однако в некоторых случаях разумно ограничить количество таких постоянных соединений. Эта директива именно для этого. Она влияет на количество соединений к хосту каждого агента во всех распределённых таблицах.

Рекомендуется устанавливать значение равным или меньше параметра [max_connections](../Server_settings/Searchd.md#max_connections) в конфиге агента.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
persistent_connections_limit = 29 # assume that each host of agents has max_connections = 30 (or 29).
```
<!-- end -->


### pid_file

<!-- example conf pid_file -->
pid_file — обязательный параметр конфигурации в Manticore Search, который указывает путь к файлу, в котором хранится идентификатор процесса (PID) сервера `searchd`.

Файл PID процесса searchd пересоздаётся и блокируется при старте, содержит PID главного процесса сервера во время работы сервера. При остановке сервера файл удаляется.
Цель этого файла — позволить Manticore выполнять различные внутренние задачи, такие как проверка уже запущенного экземпляра `searchd`, остановка `searchd` и уведомление его о необходимости ротировать таблицы. Файл также может быть использован для внешних скриптов автоматизации.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
pid_file = /run/manticore/searchd.pid
```
<!-- end -->


### predicted_time_costs

<!-- example conf predicted_time_costs -->
Затраты для модели предсказания времени запроса, в наносекундах. Опционально, значение по умолчанию — `doc=64, hit=48, skip=2048, match=64`.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
predicted_time_costs = doc=128, hit=96, skip=4096, match=128
```
<!-- end -->

<!-- example conf predicted_time_costs 1 -->
Преждевременное завершение запросов на основе времени их выполнения (с помощью настройки максимального времени запроса) — это хороший механизм безопасности, но он имеет внутренний недостаток: неопределённые (нестабильные) результаты. То есть, если вы повторите точно такой же (сложный) поисковый запрос с ограничением по времени несколько раз, время ограничения будет достигаться на разных этапах, и вы получите *разные* наборы результатов.

<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
SELECT … OPTION max_query_time
```
<!-- request API -->

```api
SetMaxQueryTime()
```
<!-- end -->

Существует опция, [SELECT … OPTION max_predicted_time](../Searching/Options.md#max_predicted_time), которая позволяет ограничить время запроса *и* получить стабильные, повторяемые результаты. Вместо того, чтобы регулярно проверять текущее реальное время во время выполнения запроса, что является неопределённым, она предсказывает текущее время выполнения с помощью простой линейной модели:

```ini
predicted_time =
    doc_cost * processed_documents +
    hit_cost * processed_hits +
    skip_cost * skiplist_jumps +
    match_cost * found_matches
```

Запрос затем преждевременно завершается, когда `predicted_time` достигает заданного лимита.

Конечно, это не жёсткое ограничение на фактическое затраченное время (это, однако, жёсткое ограничение на количество выполненной *обработки*), и простая линейная модель никак не является идеально точной. Поэтому реальное время *может* быть как ниже, так и выше целевого лимита. Тем не менее, погрешности вполне приемлемы: например, в наших экспериментах с целевым лимитом 100 мс большинство тестовых запросов попадали в диапазон 95–105 мс, а *все* запросы были в диапазоне 80–120 мс. Также приятный побочный эффект — использование смоделированного времени запроса вместо измерения реального времени выполнения приводит к несколько меньшему числу вызовов gettimeofday().

Нет двух одинаковых моделей и производителей серверов, поэтому директива `predicted_time_costs` позволяет настроить затраты для вышеуказанной модели. Для удобства они заданы целыми числами и считаются в наносекундах. (Лимит в max_predicted_time считается в миллисекундах, и указывать значения затрат как 0.000128 мс вместо 128 нс несколько более подвержено ошибкам.) Не обязательно указывать все четыре стоимости сразу, пропущенные будут установлены в значения по умолчанию. Тем не менее, мы настоятельно рекомендуем указывать все для удобства чтения.


### preopen_tables

<!-- example conf preopen_tables -->
Директива конфигурации preopen_tables определяет, следует ли принудительно предварительно открывать все таблицы при запуске. Значение по умолчанию — 1, что означает, что все таблицы будут предварительно открыты независимо от индивидуальной настройки [preopen](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Other-performance-related-settings) по каждой таблице. Если установить в 0, будут применяться индивидуальные настройки для таблиц, которые по умолчанию равны 0.

Предварительное открытие таблиц может предотвратить гонки между поисковыми запросами и ротациями, которые могут иногда приводить к сбоям запросов. Однако оно использует больше дескрипторов файлов. В большинстве сценариев рекомендуется предварительно открывать таблицы.

Вот пример конфигурации:

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
preopen_tables = 1
```
<!-- end -->

### pseudo_sharding

<!-- example conf pseudo_sharding -->
Опция конфигурации pseudo_sharding включает параллелизацию поисковых запросов к локальным обычным и реал-тайм таблицам, независимо от того, запрашиваются ли они напрямую или через распределённую таблицу. Эта функция автоматически параллелит запросы до количества потоков, заданных в `searchd.threads`.

Обратите внимание, что если ваши рабочие потоки уже заняты, например, из-за:
* высокой конкуренции запросов
* физического шардирования любого типа:
  - распределённая таблица из нескольких обычных/реал-тайм таблиц
  - реал-тайм таблица, состоящая из слишком большого количества дисковых чанков

то включение pseudo_sharding может не дать никакой выгоды и даже привести к небольшому снижению пропускной способности. Если вы отдаёте приоритет более высокой пропускной способности вместо низкой задержки, рекомендуется отключить эту опцию.

Включена по умолчанию.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
pseudo_sharding = 0
```
<!-- end -->


### replication_connect_timeout

Директива `replication_connect_timeout` определяет тайм-аут для подключения к удалённому узлу. По умолчанию значение предполагается в миллисекундах, но может иметь [другой суффикс](../Server_settings/Special_suffixes.md). Значение по умолчанию — 1000 (1 секунда).

При подключении к удалённому узлу Manticore будет ждать не более этого времени для успешного установления соединения. Если тайм-аут наступает, но соединение не установлено, и `retries` включены, будет предпринята повторная попытка.


### replication_query_timeout

`replication_query_timeout` задаёт время, которое searchd будет ждать завершения запроса удалённым узлом. Значение по умолчанию — 3000 миллисекунд (3 секунды), но может иметь `суффикс` для указания другой единицы времени.

После установления соединения Manticore будет ждать не более `replication_query_timeout`, пока удалённый узел завершит запрос. Обратите внимание, что этот тайм-аут отличается от `replication_connect_timeout`, и общая возможная задержка со стороны удалённого узла будет суммой обоих значений.


### replication_retry_count

Эта настройка — целое число, указывающее, сколько раз Manticore попытается подключиться и выполнить запрос к удалённому узлу при репликации до выдачи фатальной ошибки запроса. Значение по умолчанию — 3.


### replication_retry_delay

Этот параметр является целым числом в миллисекундах (или [special_suffixes](../Server_settings/Special_suffixes.md)), который задает задержку перед повторной попыткой Manticore запроса удаленного узла в случае ошибки при репликации. Это значение актуально только при указании ненулевого значения. Значение по умолчанию — 500.

### qcache_max_bytes

<!-- example conf qcache_max_bytes -->
Данная настройка задает максимальный объем оперативной памяти, выделяемой для кэшированных наборов результатов в байтах. Значение по умолчанию — 16777216, что эквивалентно 16 мегабайтам. Если значение установлено в 0, кэш запросов отключается. Для получения дополнительной информации о кэше запросов смотрите раздел [query cache](../Searching/Query_cache.md).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
qcache_max_bytes = 16777216
```
<!-- end -->


### qcache_thresh_msec

Целое число в миллисекундах. Минимальный порог времени выполнения запроса для его кэширования. По умолчанию 3000, или 3 секунды. Значение 0 означает кэшировать все. Подробнее см. в разделе [query cache](../Searching/Query_cache.md). Это значение также может быть выражено с помощью временных [special_suffixes](../Server_settings/Special_suffixes.md), однако используйте их с осторожностью, чтобы не путать с названием самого параметра, содержащего '_msec'.


### qcache_ttl_sec

Целое число в секундах. Время жизни кэшированного набора результатов. По умолчанию 60, или 1 минута. Минимальное возможное значение — 1 секунда. Подробнее в разделе [query cache](../Searching/Query_cache.md). Это значение также может быть выражено с помощью временных [special_suffixes](../Server_settings/Special_suffixes.md), но используйте их с осторожностью, чтобы не путать с названием самого параметра, содержащего '_sec'.


### query_log_format

<!-- example conf query_log_format -->
Формат журнала запросов. Необязательно, допустимые значения — `plain` и `sphinxql`, по умолчанию `sphinxql`.

Режим `sphinxql` записывает корректные SQL-запросы. Режим `plain` записывает запросы в простом текстовом формате (в основном подходит для полностью полнотекстовых случаев использования). Эта директива позволяет переключаться между двумя форматами при запуске поискового сервера. Формат журнала также можно изменить на лету с помощью синтаксиса `SET GLOBAL query_log_format=sphinxql`. Подробнее смотрите в [Query logging](../Logging/Query_logging.md).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
query_log_format = sphinxql
```
<!-- end -->

### query_log_min_msec

Порог (в миллисекундах), ниже которого запрос не будет записан в журнал запросов. Необязательно, по умолчанию 0 (все запросы записываются в журнал). Эта директива задает, что будут записываться только запросы, время выполнения которых превышает указанный лимит (это значение также может быть выражено с временными [special_suffixes](../Server_settings/Special_suffixes.md), однако используйте их с осторожностью и не путайте с названием параметра, содержащего `_msec`).

### query_log

<!-- example conf query_log -->
Имя файла журнала запросов. Необязательно, по умолчанию пусто (логирование запросов отключено). Все поисковые запросы (например, SELECT ..., но не запросы INSERT/REPLACE/UPDATE) будут записываться в этот файл. Формат описан в [Query logging](../Logging/Query_logging.md). В случае формата 'plain' можно указать 'syslog' в качестве пути к файлу журнала. В этом случае все поисковые запросы будут отправлены демону syslog с приоритетом `LOG_INFO` и префиксом '[query]' вместо временной метки. Чтобы использовать опцию syslog, Manticore должен быть собран с параметром `--with-syslog`.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
query_log = /var/log/query.log
```
<!-- end -->


### query_log_mode

<!-- example conf query_log_mode -->
Директива query_log_mode позволяет задать разные права доступа для файлов searchd и журнала запросов. По умолчанию файлы этих журналов создаются с правами 600, что означает, что читать их могут только пользователь, под которым запущен сервер, и пользователи root.
Эта директива полезна, если вы хотите разрешить другим пользователям читать журналы, например, решениям для мониторинга, работающим под непривилегированными пользователями.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
query_log_mode  = 666
```
<!-- end -->

### read_buffer_docs

<!-- example conf read_buffer_docs -->
Директива read_buffer_docs управляет размером буфера чтения на слово для списков документов. Для каждого вхождения ключевого слова в каждом поисковом запросе существует два связанных буфера чтения: один для списка документов и один для списка попаданий. Эта настройка позволяет контролировать размер буфера списка документов.

Больший размер буфера может увеличить использование ОЗУ на запрос, но возможно уменьшит время ввода-вывода. Логично задавать большие значения для медленных хранилищ, а для хранилищ с высокой производительностью по операциям ввода-вывода стоит проводить эксперименты с малыми значениями.

Значение по умолчанию — 256K, минимальное значение — 8K. Кроме того, вы можете задать [read_buffer_docs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#read_buffer_docs) на уровне конкретной таблицы, что переопределит настройки на уровне сервера.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
read_buffer_docs = 128K
```
<!-- end -->


### read_buffer_hits

<!-- example conf read_buffer_hits -->
Директива read_buffer_hits задает размер буфера чтения на слово для списков попаданий в поисковых запросах. По умолчанию размер равен 256K, минимальное значение — 8K. Для каждого вхождения ключевого слова в поисковом запросе существует два связанных буфера чтения: один для списка документов, другой для списка попаданий. Увеличение размера буфера может повысить использование ОЗУ на запрос, но уменьшить время ввода-вывода. Для медленных хранилищ разумно устанавливать большие размеры буферов, для быстрых хранилищ с высокой производительностью ввода-вывода стоит экспериментировать с малыми значениями.

Эту настройку можно задать на уровне конкретной таблицы, используя опцию read_buffer_hits в [read_buffer_hits](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#read_buffer_hits), которая переопределит установку на уровне сервера.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
read_buffer_hits = 128K
```
<!-- end -->

### read_unhinted

<!-- example conf read_unhinted -->
Размер незаданного буфера чтения. Необязательно, по умолчанию 32K, минимальное значение 1K

При выполнении запроса некоторые операции чтения заранее знают, сколько именно данных нужно прочитать, но некоторые — пока нет. Наиболее заметно это для размера списка попаданий (hit list), который в настоящее время заранее не известен. Этот параметр позволяет контролировать, сколько данных читать в таких случаях. Он влияет на время ввода-вывода списка попаданий, сокращая его для списков, больших, чем неуказанный размер чтения, но увеличивая для меньших списков. Он **не** влияет на использование оперативной памяти, поскольку буфер чтения уже будет выделен. Поэтому он не должен превышать read_buffer.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
read_unhinted = 32K
```
<!-- end -->

### reset_network_timeout_on_packet

<!-- example conf reset_network_timeout_on_packet -->
Уточняет поведение сетевых тайм-аутов (например, `network_timeout` и `agent_query_timeout`).

При значении 0 тайм-ауты ограничивают максимальное время на отправку всего запроса/запроса.
При значении 1 (по умолчанию) тайм-ауты ограничивают максимальное время между сетевой активностью.

При репликации узлу может потребоваться отправить большой файл (например, 100 ГБ) на другой узел. Предположим, что сеть может передавать данные со скоростью 1 ГБ/с, с серией пакетов по 4-5 МБ каждый. Для передачи всего файла потребуется 100 секунд. Тайм-аут по умолчанию в 5 секунд позволит передать только 5 ГБ, после чего соединение будет разорвано. Увеличение тайм-аута может быть обходным решением, но это не масштабируется (например, следующий файл может быть 150 ГБ, что снова приведет к сбою). Однако с включенным по умолчанию `reset_network_timeout_on_packet` со значением 1 тайм-аут применяется не к всей передаче, а к отдельным пакетам. Пока передача продолжается (и данные действительно поступают по сети в течение периода тайм-аута), соединение поддерживается. Если передача застревает так, что происходит тайм-аут между пакетами, соединение разрывается.

Обратите внимание, что при настройке распределенной таблицы каждый узел — как мастер, так и агенты — должен быть настроен. На стороне мастера затрагивается `agent_query_timeout`; на агентах актуален `network_timeout`.

<!-- intro -->

##### Пример:

<!-- request Example -->

```ini
reset_network_timeout_on_packet = 0
```

<!-- end -->


### rt_flush_period

<!-- example conf rt_flush_period -->
Период проверки сброса чанков ОЗУ в RT-таблицах, в секундах (или [специальных_суффиксах](../Server_settings/Special_suffixes.md)). Опционально, по умолчанию 10 часов.

Активно обновляемые RT-таблицы, полностью помещающиеся в чанки ОЗУ, могут приводить к постоянно растущим бинарным логам, влияющим на использование диска и время восстановления после сбоев. С помощью этой директивы поисковый сервер периодически выполняет проверку сброса, и подходящие чанки ОЗУ могут быть сохранены, что позволяет потом очищать бинарные логи. Подробнее см. в разделе [Бинарное логирование](../Logging/Binary_logging.md).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
rt_flush_period = 3600 # 1 hour
```
<!-- end -->


### rt_merge_iops

<!-- example conf rt_merge_iops -->
Максимальное количество операций ввода-вывода (в секунду), которые поток слияния чанков RT может начать. Опционально, по умолчанию 0 (без ограничений).

Эта директива позволяет ограничить воздействие операций ввода-вывода, вызываемых командами `OPTIMIZE`. Гарантируется, что все операции оптимизации RT не будут генерировать больше операций IOPS (операций ввода-вывода в секунду), чем заданный лимит. Ограничение rt_merge_iops может уменьшить деградацию производительности поиска, вызванную слиянием.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
rt_merge_iops = 40
```
<!-- end -->

### rt_merge_maxiosize

<!-- example conf rt_merge_maxiosize -->
Максимальный размер операции ввода-вывода, которую поток слияния чанков RT может начать. Опционально, по умолчанию 0 (без ограничений).

Эта директива позволяет ограничить воздействие операций ввода-вывода, вызываемых командами `OPTIMIZE`. Операции ввода-вывода, превышающие этот лимит, будут разбиты на две или более операций, которые затем будут учитываться как отдельные операции с точки зрения лимита [rt_merge_iops](../Server_settings/Searchd.md#rt_merge_iops). Таким образом, гарантируется, что все операции оптимизации не будут генерировать более чем (rt_merge_iops * rt_merge_maxiosize) байт дискового ввода-вывода в секунду.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
rt_merge_maxiosize = 1M
```
<!-- end -->


### seamless_rotate

<!-- example conf seamless_rotate -->
Предотвращает остановки `searchd` при ротации таблиц с огромным объемом данных для предварительного кэширования. Опционально, по умолчанию 1 (включена бесшовная ротация). В системах Windows бесшовная ротация отключена по умолчанию.

Таблицы могут содержать данные, которые нужно предварительно закешировать в ОЗУ. В настоящее время файлы `.spa`, `.spb`, `.spi` и `.spm` полностью предварительно кешируются (в них содержатся данные атрибутов, данные блоб-атрибутов, таблица ключевых слов и карта удаленных строк соответственно). Без бесшовной ротации ротация таблицы старается использовать как можно меньше ОЗУ и работает следующим образом:

1. Новые запросы временно отклоняются (с кодом ошибки "retry");
2. `searchd` ожидает завершения всех текущих выполняемых запросов;
3. Старый стол освобождается, и его файлы переименовываются;
4. Файлы новой таблицы переименовываются, и необходимая память ОЗУ выделяется;
5. Данные атрибутов и словаря новой таблицы предварительно загружаются в ОЗУ;
6. `searchd` возобновляет обслуживание запросов из новой таблицы.

Однако, если объем данных атрибутов или словаря большой, этап предварительной загрузки может занять заметное время — до нескольких минут при загрузке файлов от 1 до 5+ ГБ.

При включенной бесшовной ротации ротация работает следующим образом:

1. Выделяется память ОЗУ для новой таблицы;
2. Данные атрибутов и словаря новой таблицы асинхронно предварительно загружаются в ОЗУ;
3. В случае успеха старый стол освобождается, и файлы обеих таблиц переименовываются;
4. В случае ошибки новая таблица освобождается;
5. В любой момент запросы обслуживаются либо со старой, либо с новой копии таблицы.

Бесшовная ротация увеличивает пиковое использование памяти во время ротации (поскольку обе копии данных `.spa/.spb/.spi/.spm` — старая и новая — должны находиться в ОЗУ во время предварительной загрузки новой копии). Среднее использование памяти остается прежним.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
seamless_rotate = 1
```
<!-- end -->

### secondary_index_block_cache
<!-- example conf secondary_index_block_cache -->

Этот параметр задает размер кэша блоков, используемого вторичными индексами. Он необязателен, значение по умолчанию — 8 МБ. Когда вторичные индексы работают с фильтрами, содержащими много значений (например, фильтры IN()), они читают и обрабатывают блоки метаданных для этих значений.
В объединенных запросах этот процесс повторяется для каждой партии строк из левой таблицы, и каждая партия может повторно читать те же метаданные в рамках одного объединенного запроса. Это может значительно повлиять на производительность. Кэш блоков метаданных сохраняет эти блоки в памяти, чтобы
они могли быть использованы повторно последующими партиями.

Кэш используется только в объединенных запросах и не влияет на запросы без объединений. Обратите внимание, что ограничение размера кэша применяется на каждый атрибут и на каждый вторичный индекс. Каждый атрибут в каждом дисковом куске работает в рамках этого лимита. В худшем случае общий объем
используемой памяти можно оценить, умножив лимит на количество дисковых кусков и число атрибутов, используемых в объединенных запросах.

Установка `secondary_index_block_cache = 0` отключает кэш.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
secondary_index_block_cache = 16M
```

<!-- end -->

### secondary_indexes
<!-- example conf secondary_indexes -->

Этот параметр включает/отключает использование вторичных индексов для поисковых запросов. Он необязателен, значение по умолчанию — 1 (включено). Обратите внимание, что включать его для индексации не нужно, так как он всегда включен, если установлена [Manticore Columnar Library](https://github.com/manticoresoftware/columnar). Последняя также обязательна для использования индексов при поиске. Доступно три режима:

* `0`: Отключить использование вторичных индексов в поиске. Их можно включать для отдельных запросов с помощью [подсказок анализатора](../Searching/Options.md#Query-optimizer-hints)
* `1`: Включить использование вторичных индексов в поиске. Их можно отключать для отдельных запросов с помощью [подсказок анализатора](../Searching/Options.md#Query-optimizer-hints)
* `force`: Аналогично включению, но любые ошибки при загрузке вторичных индексов будут сообщены, и весь индекс не будет загружен в демон.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
secondary_indexes = 1
```

<!-- end -->

### server_id

<!-- example conf server_id -->
Целое число, служащее идентификатором сервера, которое используется как начальное значение (seed) для генерации уникального короткого UUID для узлов в составе кластера репликации. server_id должен быть уникальным среди узлов кластера и находиться в диапазоне от 0 до 127. Если server_id не установлен, он вычисляется как хэш MAC-адреса и пути к PID-файлу или в качестве начального значения для короткого UUID будет использовано случайное число.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
server_id = 1
```
<!-- end -->


### shutdown_timeout

<!-- example conf shutdown_timeout -->
Время ожидания `searchd --stopwait` в секундах (или с использованием [special_suffixes](../Server_settings/Special_suffixes.md)). Необязательный параметр, по умолчанию 60 секунд.

Когда вы запускаете `searchd --stopwait`, сервер должен выполнить некоторые действия перед остановкой, например, завершить запросы, сбросить RT RAM-куски, сбросить атрибуты и обновить binlog. Эти задачи требуют времени. `searchd --stopwait` будет ждать до `shutdown_time` секунд, чтобы сервер завершил свои операции. Подходящее время зависит от размера таблицы и нагрузки.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
shutdown_timeout = 3m # wait for up to 3 minutes
```
<!-- end -->


### shutdown_token

SHA1-хэш пароля, необходимого для вызова команды 'shutdown' из VIP-подключения Manticore SQL. Без него,[debug](../Reporting_bugs.md#DEBUG) подкоманда 'shutdown' никогда не остановит сервер. Обратите внимание, что такой простой хэш не следует считать надежной защитой, так как мы не используем соль или современные хэш-функции. Это предназначено как предохранительная мера для служб обслуживания в локальной сети.

### snippets_file_prefix

<!-- example conf snippets_file_prefix -->
Префикс для добавления к локальным именам файлов при генерации сниппетов. Необязательный параметр, по умолчанию текущая рабочая папка.

Этот префикс можно использовать в распределенной генерации сниппетов вместе с опциями `load_files` или `load_files_scattered`.

Обратите внимание, что это именно префикс, а **не** путь! Это означает, что если префикс установлен как "server1", а запрос подразумевает файл "file23", `searchd` попытается открыть файл "server1file23" (без кавычек). Если вам нужен путь, необходимо включить завершающий слеш.

После формирования итогового пути сервера убирает все относительные директории и сравнивает результат с значением `snippet_file_prefix`. Если результат не начинается с префикса, такой файл будет отклонен с сообщением об ошибке.

Например, если вы установите префикс `/mnt/data`, а кто-то запросит генерацию сниппета с файлом `../../../etc/passwd`, будет выведено сообщение об ошибке:

`File '/mnt/data/../../../etc/passwd' escapes '/mnt/data/' scope`

вместо чтения содержимого файла.

Также, при неустановленном параметре и чтении `/etc/passwd`, фактически будет читаться `/daemon/working/folder/etc/passwd`, так как значение параметра по умолчанию — рабочая папка сервера.

Отметим также, что это локальная опция; она никак не влияет на агентов. Вы можете безопасно задать префикс на мастер-сервере. Запросы, направленные на агентов, не будут затронуты настройкой мастера, но будут зависеть от собственных параметров агентов.

Это может быть полезно, например, когда места хранения документов (локальное хранение или монтирования NAS) различаются на серверах.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
snippets_file_prefix = /mnt/common/server1/
```
<!-- end -->

> **ВНИМАНИЕ:** Если вы все же хотите иметь доступ к файлам из корня файловой системы, необходимо явно установить `snippets_file_prefix` в пустое значение (через строку `snippets_file_prefix=`) или в корень (через строку `snippets_file_prefix=/`).


### sphinxql_state

<!-- example conf sphinxql_state -->
Путь к файлу, в который будет сериализовано текущее состояние SQL.

При запуске сервера этот файл воспроизводится. При подходящих изменениях состояния (например, SET GLOBAL) этот файл автоматически перезаписывается. Это может предотвратить трудно диагностируемую проблему: если вы загрузили UDF-функции, но Manticore аварийно завершил работу, при (автоматическом) перезапуске ваши UDF и глобальные переменные станут недоступны. Использование постоянного состояния помогает обеспечить плавное восстановление без таких сюрпризов.

`sphinxql_state` нельзя использовать для выполнения произвольных команд, таких как `CREATE TABLE`.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
sphinxql_state = uservars.sql
```
<!-- end -->


### sphinxql_timeout

<!-- example conf sphinxql_timeout -->
Максимальное время ожидания между запросами (в секундах или [специальные_суффиксы](../Server_settings/Special_suffixes.md)) при использовании SQL-интерфейса. Опционально, по умолчанию 15 минут.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
sphinxql_timeout = 15m
```
<!-- end -->


### ssl_ca

<!-- example conf ssl_ca -->
Путь к файлу сертификата Центра Сертификации (CA) SSL (также известен как корневой сертификат). Опционально, по умолчанию пусто. Если не пусто, сертификат в `ssl_cert` должен быть подписан этим корневым сертификатом.

Сервер использует файл CA для проверки подписи сертификата. Файл должен быть в формате PEM.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ssl_ca = keys/ca-cert.pem
```
<!-- end -->


### ssl_cert

<!-- example conf ssl_cert -->
Путь к SSL-сертификату сервера. Опционально, по умолчанию пусто.

Сервер использует этот сертификат как самоподписанный открытый ключ для шифрования HTTP-трафика через SSL. Файл должен быть в формате PEM.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ssl_cert = keys/server-cert.pem
```
<!-- end -->


### ssl_key

<!-- example conf ssl_key -->
Путь к ключу SSL-сертификата. Опционально, по умолчанию пусто.

Сервер использует этот приватный ключ для шифрования HTTP-трафика через SSL. Файл должен быть в формате PEM.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ssl_key = keys/server-key.pem
```
<!-- end -->


### subtree_docs_cache

<!-- example conf subtree_docs_cache -->
Максимальный размер кеша документов общего поддерева на запрос. Опционально, по умолчанию 0 (выключено).

Этот параметр ограничивает использование оперативной памяти оптимизатора общего поддерева (см. [мультизапросы](../Searching/Multi-queries.md)). Максимум столько оперативной памяти будет потрачено на кеширование записей документов для каждого запроса. Установка значения 0 отключает оптимизатор.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
subtree_docs_cache = 8M
```
<!-- end -->


### subtree_hits_cache

<!-- example conf subtree_hits_cache -->
Максимальный размер кеша попаданий общего поддерева на запрос. Опционально, по умолчанию 0 (выключено).

Этот параметр ограничивает использование оперативной памяти оптимизатора общего поддерева (см. [мультизапросы](../Searching/Multi-queries.md)). Максимум столько оперативной памяти будет потрачено на кеширование появлений ключевых слов (попаданий) для каждого запроса. Установка значения 0 отключает оптимизатор.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
subtree_hits_cache = 16M
```
<!-- end -->

### threads

<!-- example threads -->
Количество рабочих потоков (или размер пула потоков) для демона Manticore. Manticore при запуске создаёт указанное количество потоков ОС, которые выполняют все задачи внутри демона, такие как выполнение запросов, создание сниппетов и т.д. Некоторые операции могут разбиваться на подзадачи и выполняться параллельно, например:

* Поиск в таблице реального времени
* Поиск в распределённой таблице, состоящей из локальных таблиц
* Вызов перколации запроса
* и другие

По умолчанию установлено в количество ядер процессора на сервере. Manticore создаёт потоки при запуске и держит их до остановки. Каждая подзадача может использовать один из потоков по необходимости. Когда подзадача завершена, она освобождает поток для другой подзадачи.

В случае интенсивной нагрузки типа ввода-вывода возможно целесообразно поставить значение выше числа ядер процессора.

<!-- request Example -->
```ini
threads = 10
```

<!-- end -->

### thread_stack

<!-- example conf thread_stack -->
Максимальный размер стека для задачи (корутины, один поисковый запрос может вызвать несколько задач/корутин). Опционально, по умолчанию 128K.

Каждая задача имеет собственный стек размером 128K. При запуске запроса проверяется, сколько стека требуется. Если 128K достаточно, запрос просто обрабатывается. Если нужно больше, планируется другая задача с увеличенным стеком, которая продолжает обработку. Максимальный размер такого расширенного стека ограничивается этим параметром.

Установка значения на разумно высоком уровне поможет обрабатывать очень глубокие запросы без чрезмерного увеличения общего потребления оперативной памяти. Например, установка в 1Г не означает, что каждая новая задача занимает 1Г оперативной памяти, а если мы видим, что требуется, скажем, 100М, мы выделяем именно 100М для задачи. Другие задачи в это время будут работать со стеком по умолчанию в 128К. Аналогично, можно запускать более сложные запросы, требующие 500М. И только если мы **увидим** внутренне, что задача требует более 1Г стека, произойдёт сбой и будет сообщено о слишком низком значении thread_stack.

Тем не менее, на практике даже запросы, требующие 16М стека, часто слишком сложны для парсинга и требуют слишком много времени и ресурсов для обработки. Так что демон обработает их, но ограничение таких запросов настройкой `thread_stack` выглядит вполне разумным.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
thread_stack = 8M
```
<!-- end -->


### unlink_old

<!-- example conf unlink_old -->
Определяет, удалять ли копии таблиц с расширением `.old` при успешной ротации. Опционально, по умолчанию 1 (удалять).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
unlink_old = 0
```
<!-- end -->


### watchdog

<!-- example conf watchdog -->
Поточный сторожевой таймер сервера. Опционально, по умолчанию 1 (сторожевой таймер включён).

Когда запрос Manticore падает, это может привести к краху всего сервера. При включённом сторожевом таймере `searchd` поддерживает отдельный лёгкий процесс, который следит за основным процессом сервера и автоматически перезапускает его в случае аномального завершения. Сторожевой таймер включён по умолчанию.

<!-- request Example -->

```ini
watchdog = 0 # disable watchdog
```
<!-- end -->
<!-- proofread -->

