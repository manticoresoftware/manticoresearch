# Раздел "Searchd" в конфигурации

Ниже приведены настройки, которые следует использовать в разделе `searchd` файла конфигурации Manticore Search для управления поведением сервера. Ниже приводится краткое описание каждой настройки:

### access_plain_attrs

Эта настройка задает общесерверные значения по умолчанию для [access_plain_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `mmap_preread`.

Директива `access_plain_attrs` позволяет определить значение по умолчанию для [access_plain_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Настройки на уровне таблицы имеют более высокий приоритет и переопределяют это общее значение, обеспечивая более тонкий контроль.

### access_blob_attrs

Эта настройка задает общесерверные значения по умолчанию для [access_blob_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `mmap_preread`.

Директива `access_blob_attrs` позволяет определить значение по умолчанию для [access_blob_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Настройки на уровне таблицы имеют более высокий приоритет и переопределяют это общее значение, обеспечивая более тонкий контроль.

### access_doclists

Эта настройка задает общесерверные значения по умолчанию для [access_doclists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `file`.

Директива `access_doclists` позволяет определить значение по умолчанию для [access_doclists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Настройки на уровне таблицы имеют более высокий приоритет и переопределяют это общее значение, обеспечивая более тонкий контроль.

### access_hitlists

Эта настройка задает общесерверные значения по умолчанию для [access_hitlists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `file`.

Директива `access_hitlists` позволяет определить значение по умолчанию для [access_hitlists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Настройки на уровне таблицы имеют более высокий приоритет и переопределяют это общее значение, обеспечивая более тонкий контроль.

### access_dict

Эта настройка задает общесерверные значения по умолчанию для [access_dict](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Она является необязательной, значение по умолчанию — `mmap_preread`.

Директива `access_dict` позволяет определить значение по умолчанию для [access_dict](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Настройки на уровне таблицы имеют более высокий приоритет и переопределяют это общее значение, обеспечивая более тонкий контроль.

### agent_connect_timeout

Эта настройка задает общесерверные значения по умолчанию для параметра [agent_connect_timeout](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_connect_timeout).


### agent_query_timeout

Эта настройка задает общесерверные значения по умолчанию для параметра [agent_query_timeout](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_query_timeout). Может быть переопределена для каждого запроса с помощью конструкции `OPTION agent_query_timeout=XXX`.


### agent_retry_count

Эта настройка является целым числом, указывающим, сколько раз Manticore будет пытаться подключиться и выполнить запрос к удалённым агентам через распределённую таблицу, прежде чем сообщить о фатальной ошибке запроса. Значение по умолчанию — 0 (т.е. без повторных попыток). Также можно задать это значение для каждого запроса с помощью конструкции `OPTION retry_count=XXX`. Если опция указана для конкретного запроса, она переопределит значение, указанное в конфигурации.

Обратите внимание, что если вы используете [agent mirrors](../Creating_a_cluster/Remote_nodes/Mirroring.md#Agent-mirrors) в определении вашей распределённой таблицы, сервер будет выбирать разные зеркала для каждой попытки подключения в соответствии с выбранной [ha_strategy](../Creating_a_cluster/Remote_nodes/Load_balancing.md#ha_strategy). В этом случае `agent_retry_count` будет суммироваться за все зеркала в наборе.

Например, если у вас 10 зеркал и задано `agent_retry_count=5`, сервер повторит попытки до 50 раз, предполагая в среднем 5 попыток на каждое из 10 зеркал (при опции `ha_strategy = roundrobin` это так и будет).

Однако значение, заданное как опция `retry_count` для [агента](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent), служит абсолютным лимитом. Другими словами, опция `[retry_count=2]` в определении агента всегда означает максимум 2 попытки, независимо от того, указали ли вы 1 или 10 зеркал для агента.

### agent_retry_delay

Эта настройка — целое число в миллисекундах (или с использованием [special_suffixes](../Server_settings/Special_suffixes.md)), указывающее задержку перед повторной попыткой запроса к удалённому агенту в случае сбоя. Это значение имеет смысл только при ненулевом [agent_retry_count](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md) или ненулевом уровне повтора для конкретного запроса `retry_count`. Значение по умолчанию — 500. Также можно задать это значение для каждого запроса с помощью конструкции `OPTION retry_delay=XXX`. Если опция указана для конкретного запроса, она переопределит значение, указанное в конфигурации.


### attr_flush_period

<!-- example conf attr_flush_period -->
При использовании [Update](../Data_creation_and_modification/Updating_documents/UPDATE.md) для изменения атрибутов документа в реальном времени, изменения сначала записываются во внутреннюю копию атрибутов в памяти. Эти обновления происходят в файле с отображением в память, что означает, что ОС решает, когда записывать изменения на диск. При нормальном завершении работы `searchd` (инициируемом сигналом `SIGTERM`) все изменения принудительно записываются на диск.

Вы также можете указать `searchd` периодически записывать эти изменения на диск, чтобы предотвратить потерю данных. Интервал между этими сбросами определяется параметром `attr_flush_period`, указанным в секундах (или [special_suffixes](../Server_settings/Special_suffixes.md)).

По умолчанию значение равно 0, что отключает периодический сброс. Тем не менее, сброс будет происходить при нормальном завершении работы.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
attr_flush_period = 900 # persist updates to disk every 15 minutes
```
<!-- end -->

### auto_optimize

<!-- example conf auto_optimize -->
Этот параметр управляет автоматическим процессом [OPTIMIZE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE) для сжатия таблицы.

По умолчанию сжатие таблицы происходит автоматически. Вы можете изменить это поведение с помощью параметра `auto_optimize`:
* 0 чтобы отключить автоматическое сжатие таблицы (вы все еще можете вызывать `OPTIMIZE` вручную)
* 1 чтобы явно включить его
* чтобы включить его с умножением порога оптимизации на 2.

По умолчанию OPTIMIZE запускается до тех пор, пока количество чанков на диске не станет меньше или равно двойному количеству логических ядер CPU.

Однако если в таблице есть атрибуты с индексами KNN, этот порог отличается. В этом случае он устанавливается как половина количества физических ядер CPU для улучшения производительности поиска KNN.

Обратите внимание, что переключение `auto_optimize` в положение вкл. или выкл. не мешает вам запускать [OPTIMIZE TABLE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE) вручную.

<!-- intro -->
##### Пример:

<!-- request Disable -->
```ini
auto_optimize = 0 # disable automatic OPTIMIZE
```

<!-- request Throttle -->
```ini
auto_optimize = 2 # OPTIMIZE starts at 16 chunks (on 4 cpu cores server)
```

<!-- end -->

### auto_schema

<!-- example conf auto_schema -->
Manticore поддерживает автоматическое создание таблиц, которые еще не существуют, но указаны в операторах INSERT. Эта функция включена по умолчанию. Чтобы отключить её, явно установите `auto_schema = 0` в вашей конфигурации. Чтобы снова включить, задайте `auto_schema = 1` или удалите параметр `auto_schema` из конфигурации.

Помните, что HTTP эндпоинт `/bulk` не поддерживает автоматическое создание таблиц.

> ПРИМЕЧАНИЕ: [Функциональность авто-схемы](../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md#Auto-schema) требует [Manticore Buddy](../Installation/Manticore_Buddy.md). Если она не работает, убедитесь, что Buddy установлен.

<!-- request Disable -->
```ini
auto_schema = 0 # disable automatic table creation
```

<!-- request Enable -->
```ini
auto_schema = 1 # enable automatic table creation
```

<!-- end -->

### binlog_flush

<!-- example conf binlog_flush -->
Этот параметр управляет режимом сброса/синхронизации транзакций в бинарном логе. Он необязателен, по умолчанию установлен в значение 2 (сброс после каждой транзакции, синхронизация каждую секунду).

Директива определяет, как часто бинарный лог будет сбрасываться в ОС и синхронизироваться на диск. Есть три поддерживаемых режима:

*  0, сброс и синхронизация каждую секунду. Это обеспечивает лучшую производительность, но при сбое сервера или ОС/аппаратуры могут быть потеряны данные за период до 1 секунды.
*  1, сброс и синхронизация после каждой транзакции. Этот режим обеспечивает худшую производительность, но гарантирует сохранение данных каждой завершённой транзакции.
*  2, сброс после каждой транзакции, синхронизация каждую секунду. Этот режим обеспечивает хорошую производительность и сохранность каждой транзакции при сбое сервера. Однако при сбое ОС/аппаратуры до 1 секунды транзакций может быть потеряно.

Для тех, кто знаком с MySQL и InnoDB, эта директива похожа на `innodb_flush_log_at_trx_commit`. В большинстве случаев значение по умолчанию 2 обеспечивает хороший баланс между скоростью и безопасностью, с полной защитой данных RT-таблиц при сбоях сервера и частичной — при аппаратных сбоях.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_flush = 1 # ultimate safety, low speed
```
<!-- end -->

### binlog_common

<!-- example conf binlog_common -->
Этот параметр управляет тем, как управляются файлы бинарного лога. Он необязателен, по умолчанию установлен в 0 (отдельный файл для каждой таблицы).

Можно выбрать один из двух способов управления файлами бинарного лога:

* Отдельный файл для каждой таблицы (по умолчанию, `0`): Каждая таблица сохраняет свои изменения в собственном лог-файле. Этот подход хорош, если у вас много таблиц, обновляющихся в разное время. Он позволяет обновлять таблицы без ожидания других. Также, если возникает проблема с лог-файлом одной таблицы, это не влияет на другие.
* Общий файл для всех таблиц (`1`): Все таблицы используют один и тот же файл бинарного лога. Это облегчает управление файлами, так как их меньше. Однако такой подход может удерживать файлы дольше, если одна из таблиц еще должна сохранить свои обновления. Кроме того, это может замедлить процесс, если одновременно нужно обновить много таблиц, так как все изменения должны ждать записи в один файл.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_common = 1 # use a single binary log file for all tables
```
<!-- end -->

### binlog_max_log_size

<!-- example conf binlog_max_log_size -->
Этот параметр управляет максимальным размером файла бинарного лога. Он необязателен, по умолчанию равен 256 МБ.

Новый файл бинарного лога будет принудительно открыт, когда текущий файл достижет этот предел по размеру. Это позволяет добиться более точного разделения логов и может привести к более эффективному использованию диска при определенных граничных нагрузках. Значение 0 означает, что файл бинарного лога не будет перезапускаться по размеру.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_max_log_size = 16M
```
<!-- end -->


### binlog_path

<!-- example conf binlog_path -->
Этот параметр определяет путь для файлов бинарного лога (также известного как журнал транзакций). Он необязателен, по умолчанию указывается директория для данных, настроенная во время сборки (например, `/var/lib/manticore/data/binlog.*` в Linux).

Двоичные логи используются для восстановления после сбоев данных таблицы RT и для обновлений атрибутов обычных индексов на диске, которые в противном случае хранились бы только в оперативной памяти до сброса. Когда ведение логов включено, каждая транзакция, выполненная COMMIT в таблицу RT, записывается в файл лога. Логи затем автоматически воспроизводятся при запуске после некорректного завершения работы, восстанавливая залогированные изменения.

Директива `binlog_path` задает расположение файлов двоичных логов. Она должна содержать только путь; `searchd` будет создавать и удалять несколько файлов `binlog.*` в каталоге по мере необходимости (включая данные binlog, метаданные, файлы блокировки и т.д.).

Пустое значение отключает двоичное логирование, что улучшает производительность, но ставит данные RT таблиц под риск.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_path = # disable logging
binlog_path = /var/lib/manticore/data # /var/lib/manticore/data/binlog.001 etc will be created
```
<!-- end -->

### boolean_simplify

<!-- example conf boolean_simplify -->
Этот параметр управляет значением по умолчанию для опции поиска [boolean_simplify](../Searching/Options.md#boolean_simplify). Он необязательный, со значением по умолчанию 1 (включено).

При установке в 1 сервер автоматически применит [оптимизацию булевого запроса](../Searching/Full_text_matching/Boolean_optimization.md) для улучшения производительности запроса. При установке в 0 запросы будут выполняться без оптимизации по умолчанию. Это поведение можно изменить для каждого запроса отдельно с помощью соответствующей опции поиска `boolean_simplify`.

<!-- request Example -->
```ini
searchd {
    boolean_simplify = 0  # disable boolean optimization by default
}
```
<!-- end -->

### buddy_path

<!-- example conf buddy_path -->
Этот параметр задает путь к бинарнику Manticore Buddy. Он необязательный, со значением по умолчанию, установленным при сборке, которое различается в зависимости от операционной системы. Обычно менять этот параметр не нужно. Однако это может быть полезно, если вы хотите запустить Manticore Buddy в режиме отладки, внести изменения в Manticore Buddy или разработать новый плагин. В последнем случае вы можете сделать `git clone` Buddy из https://github.com/manticoresoftware/manticoresearch-buddy, добавить новый плагин в директорию `./plugins/` и запустить `composer install --prefer-source` для удобной разработки, предварительно перейдя в директорию с исходниками Buddy.

Для возможности запускать `composer` на вашей машине должен быть установлен PHP 8.2 или выше с следующими расширениями:

```
--enable-dom
--with-libxml
--enable-tokenizer
--enable-xml
--enable-xmlwriter
--enable-xmlreader
--enable-simplexml
--enable-phar
--enable-bcmath
--with-gmp
--enable-debug
--with-mysqli
--enable-mysqlnd
```

Вы также можете выбрать специальную версию `manticore-executor-dev` для Linux amd64, доступную в релизах, например: https://github.com/manticoresoftware/executor/releases/tag/v1.0.13

Если вы выберете этот вариант, не забудьте связать dev-версию исполнителя manticore с `/usr/bin/php`.

Чтобы отключить Manticore Buddy, установите значение параметра как пустое, как показано в примере.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
buddy_path = manticore-executor -n /usr/share/manticore/modules/manticore-buddy/src/main.php # use the default Manticore Buddy in Linux
buddy_path = manticore-executor -n /usr/share/manticore/modules/manticore-buddy/src/main.php --threads=1 # runs Buddy with a single worker
buddy_path = manticore-executor -n /opt/homebrew/share/manticore/modules/manticore-buddy/bin/manticore-buddy/src/main.php # use the default Manticore Buddy in MacOS arm64
buddy_path = manticore-executor -n /Users/username/manticoresearch-buddy/src/main.php # use Manticore Buddy from a non-default location
buddy_path = # disables Manticore Buddy
buddy_path = manticore-executor -n /Users/username/manticoresearch-buddy/src/main.php --skip=manticoresoftware/buddy-plugin-replace # --skip - skips plugins
buddy_path = manticore-executor -n /usr/share/manticore/modules/manticore-buddy/src/main.php --enable-plugin=manticoresoftware/buddy-plugin-show # runs Buddy with only the SHOW plugin
```
<!-- end -->

### client_timeout

<!-- example conf client_timeout -->
Этот параметр задает максимальное время ожидания между запросами (в секундах или с использованием [special_suffixes](../Server_settings/Special_suffixes.md)) при использовании постоянных соединений. Он необязательный, со значением по умолчанию - пять минут.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
client_timeout = 1h
```
<!-- end -->


### collation_libc_locale

<!-- example conf collation_libc_locale -->
Локаль libc сервера. Необязательный параметр, по умолчанию C.

Определяет локаль libc, влияющую на колации, основанные на libc. Подробности в разделе [collations](../Searching/Collations.md).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
collation_libc_locale = fr_FR
```
<!-- end -->


### collation_server

<!-- example conf collation_server -->
Колация сервера по умолчанию. Необязательный параметр, по умолчанию libc_ci.

Задает стандартную колацию, используемую для входящих запросов. Колация может быть переопределена для каждого запроса отдельно. См. раздел [collations](../Searching/Collations.md) для списка доступных колаций и других подробностей.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
collation_server = utf8_ci
```
<!-- end -->


### data_dir

<!-- example conf data_dir -->
При указании этого параметра включается [режим реального времени](../Creating_a_table/Local_tables.md#Online-schema-management-%28RT-mode%29), представляющий собой императивный способ управления схемой данных. Значение должно быть путем к директории, где вы хотите хранить все свои таблицы, двоичные логи и все остальное, необходимое для корректной работы Manticore Search в этом режиме.
Индексирование [обычных таблиц](../Creating_a_table/Local_tables/Plain_table.md) не допускается при указании `data_dir`. Подробнее о различии между RT режимом и обычным режимом можно прочитать в [этом разделе](../Read_this_first.md#Real-time-table-vs-plain-table).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
data_dir = /var/lib/manticore
```
<!-- end -->

### diskchunk_flush_search_timeout

<!-- example conf diskchunk_flush_search_timeout -->
Тайм-аут для предотвращения авто-сброса RAM-фрагмента, если в таблице отсутствуют поисковые запросы. Необязательный параметр, по умолчанию 30 секунд.

Время проверки наличия поисков перед определением необходимости авто-сброса.
Авто-сброс произойдет только если за последние `diskchunk_flush_search_timeout` секунд в таблице был хотя бы один поиск. Работает совместно с [diskchunk_flush_write_timeout](../Server_settings/Searchd.md#diskchunk_flush_write_timeout). Соответствующая [настройка для каждой таблицы](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#diskchunk_flush_search_timeout) имеет более высокий приоритет и переопределит это значение по умолчанию на уровне всего инстанса, предоставляя более тонкий контроль.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
diskchunk_flush_search_timeout = 120s
```
<!-- end -->

### diskchunk_flush_write_timeout

<!-- example conf diskchunk_flush_write_timeout -->
Время в секундах ожидания без записи перед авто-сбросом RAM-фрагмента на диск. Необязательный параметр, по умолчанию 1 секунда.

Если в течение `diskchunk_flush_write_timeout` секунд в RAM-блоке не происходит запись, блок будет сброшен на диск. Работает совместно с [diskchunk_flush_search_timeout](../Server_settings/Searchd.md#diskchunk_flush_search_timeout). Чтобы отключить авто-сброс, явно установите `diskchunk_flush_write_timeout = -1` в вашей конфигурации. Соответствующая [настройка для каждой таблицы](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#diskchunk_flush_write_timeout) имеет более высокий приоритет и переопределит это системное значение, обеспечивая более тонкий контроль.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
diskchunk_flush_write_timeout = 60s
```
<!-- end -->

### docstore_cache_size

<!-- example conf docstore_cache_size -->
Эта настройка определяет максимальный размер блоков документов из хранилища документов, которые удерживаются в памяти. Является необязательной, значение по умолчанию — 16m (16 мегабайт).

Когда используется `stored_fields`, блоки документов читаются с диска и распаковываются. Так как каждый блок обычно содержит несколько документов, он может быть переиспользован при обработке следующего документа. Для этого блок удерживается в кеше сервера. Кеш хранит распакованные блоки.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
docstore_cache_size = 8m
```
<!-- end -->

### engine

<!-- example conf engine -->
Движок хранения атрибутов по умолчанию, используемый при создании таблиц в режиме RT. Может быть `rowwise` (по умолчанию) или `columnar`.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
engine = columnar
```
<!-- end -->


### expansion_limit

<!-- example conf expansion_limit -->
Эта настройка определяет максимальное количество расширенных ключевых слов для одного подстановочного знака. Является необязательной, значение по умолчанию — 0 (без ограничения).

При выполнении поиска подстрок в таблицах с включённым `dict = keywords` один подстановочный знак может привести к тысячам или даже миллионам совпадающих ключевых слов (например, сопоставление `a*` с целым Оксфордским словарём). Эта директива позволяет ограничить влияние таких расширений. Установка `expansion_limit = N` ограничивает расширения не более чем N наиболее частотными совпадающими ключевыми словами (для каждого подстановочного знака в запросе).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_limit = 16
```
<!-- end -->

### expansion_merge_threshold_docs

<!-- example conf expansion_merge_threshold_docs -->
Эта настройка определяет максимальное количество документов в расширенном ключевом слове, позволяющее объединять все такие ключевые слова вместе. Является необязательной, значение по умолчанию — 32.

При выполнении поиска подстрок в таблицах с включённым `dict = keywords` один подстановочный знак может привести к тысячам или даже миллионам совпадающих ключевых слов. Данная директива позволяет увеличить лимит количества ключевых слов, которые будут объединены для ускорения сопоставления, но требует больше памяти при поиске.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_merge_threshold_docs = 1024
```
<!-- end -->

### expansion_merge_threshold_hits

<!-- example conf expansion_merge_threshold_hits -->
Эта настройка определяет максимальное количество попаданий в расширенном ключевом слове, позволяющее объединять все такие ключевые слова вместе. Является необязательной, значение по умолчанию — 256.

При выполнении поиска подстрок в таблицах с включённым `dict = keywords` один подстановочный знак может привести к тысячам или даже миллионам совпадающих ключевых слов. Данная директива позволяет увеличить лимит количества ключевых слов, которые будут объединены для ускорения сопоставления, но требует больше памяти при поиске.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_merge_threshold_hits = 512
```
<!-- end -->

### expansion_phrase_limit

<!-- example conf expansion_phrase_limit -->
Эта настройка контролирует максимальное количество альтернативных вариантов фразы, сгенерированных из-за операторов `OR` внутри операторов `PHRASE`, `PROXIMITY` и `QUORUM`. Является необязательной, значение по умолчанию — 1024.

При использовании оператора `|` (OR) внутри операторов, подобных фразам, общее количество расширенных комбинаций может расти экспоненциально в зависимости от количества указанных альтернатив. Эта настройка помогает предотвратить чрезмерное расширение запроса, ограничивая количество рассматриваемых перестановок во время обработки запроса. Если количество сгенерированных вариантов превысит этот предел, запрос завершится с ошибкой.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_phrase_limit = 4096
```
<!-- end -->

### grouping_in_utc

Эта настройка указывает, будет ли группировка по времени в API и SQL рассчитываться в локальном часовом поясе или в UTC. Является необязательной, значение по умолчанию — 0 (что означает «локальный часовой пояс»).

По умолчанию все выражения «group by time» (например, group by day, week, month, year в API, а также group by day, month, year, yearmonth, yearmonthday в SQL) выполняются с использованием локального времени. Например, если у вас есть документы с атрибутами времени `13:00 utc` и `15:00 utc`, при группировке они попадут в соответствующие группы согласно вашему локальному часовому поясу. Если вы находитесь в `utc`, это будет один день, но если в `utc+10`, эти документы попадут в разные группы по «group by day» (поскольку 13:00 utc в UTC+10 — это 23:00 локального времени, а 15:00 — уже 01:00 следующего дня). Иногда такое поведение неприемлемо, и желательно, чтобы группировка по времени не зависела от часового пояса. Вы можете запускать сервер с определённой глобальной переменной окружения TZ, но это повлияет не только на группировку, но и на отметки времени в логах, что также может быть нежелательно. Включение этой опции (в конфиге или с помощью оператора [SET global](../Server_settings/Setting_variables_online.md#SET) в SQL) заставит все выражения группировки времени рассчитываться в UTC, при этом остальные функции, зависящие от времени (например, логирование сервера), останутся в локальном часовом поясе.


### timezone

Эта настройка определяет часовой пояс, используемый функциями, связанными с датой и временем. По умолчанию используется локальный часовой пояс, но вы можете указать другой часовой пояс в формате IANA (например, `Europe/Amsterdam`).

Обратите внимание, что эта настройка не влияет на логирование, которое всегда происходит в локальном часовом поясе.

Также обратите внимание, что если используется `grouping_in_utc`, функция 'group by time' по-прежнему будет использовать UTC, в то время как другие функции, связанные с датой/временем, будут использовать указанную временную зону. В целом не рекомендуется смешивать `grouping_in_utc` и `timezone`.

Вы можете настроить этот параметр либо в конфигурации, либо с помощью оператора [SET global](../Server_settings/Setting_variables_online.md#SET) в SQL.


### ha_period_karma

<!-- example conf ha_period_karma -->
Этот параметр задаёт размер окна статистики зеркал агентов в секундах (или [special_suffixes](../Server_settings/Special_suffixes.md)). Является необязательным, значение по умолчанию — 60 секунд.

Для распределённой таблицы с зеркалами агентов (подробнее см. в [agent](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md)) мастер отслеживает несколько разных счётчиков для каждого зеркала. Эти счётчики используются для отказоустойчивости и балансировки (мастер выбирает лучшее зеркало на основе счётчиков). Счётчики накапливаются блоками по `ha_period_karma` секунд.

После начала нового блока, мастер может еще использовать накопленные значения из предыдущего, пока новый блок не заполнится наполовину. В результате история предыдущих периодов перестаёт влиять на выбор зеркала спустя максимум 1,5 раза `ha_period_karma`.

Хотя для выбора зеркала используется не более двух блоков, до 15 последних блоков сохраняются для инструментальных целей. Эти блоки можно просмотреть с помощью оператора [SHOW AGENT STATUS](../Node_info_and_management/Node_status.md#SHOW-AGENT-STATUS).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ha_period_karma = 2m
```
<!-- end -->


### ha_ping_interval

<!-- example conf ha_ping_interval -->
Этот параметр настраивает интервал между пингами зеркал агентов в миллисекундах (или [special_suffixes](../Server_settings/Special_suffixes.md)). Является необязательным, значение по умолчанию — 1000 миллисекунд.

Для распределённой таблицы с зеркалами агентов (подробнее см. в [agent](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md)) мастер посылает всем зеркалам команду пинга в периоды простоя. Это необходимо для отслеживания текущего статуса агента (активен или нет, время отклика сети и т.п.). Интервал между такими пингами задаётся этой директивой. Чтобы отключить пинги, установите `ha_ping_interval` в 0.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ha_ping_interval = 3s
```
<!-- end -->


### hostname_lookup

Опция `hostname_lookup` определяет стратегию обновления имён хостов. По умолчанию IP-адреса имён агентов кэшируются при запуске сервера для избежания чрезмерных обращений к DNS. Однако в некоторых случаях IP может динамически меняться (например, при облачном размещении), и может быть желательным не кэшировать IP. Установка этой опции в `request` отключает кэширование и выполняет DNS-запросы при каждом запросе. IP-адреса также можно вручную обновить с помощью команды `FLUSH HOSTNAMES`.

### jobs_queue_size

Параметр `jobs_queue_size` задаёт, сколько "заданий" может находиться в очереди одновременно. По умолчанию нет никаких ограничений.

В большинстве случаев "задание" означает один запрос к одной локальной таблице (обычной или куску на диске таблицы реального времени). Например, если у вас есть распределённая таблица, состоящая из 2 локальных таблиц или таблица реального времени с 2 дисковыми кусками, поисковый запрос к этой таблице будет в основном создавать 2 задания в очереди. Затем пул потоков (размер которого задаётся параметром [threads](../Server_settings/Searchd.md#threads)) обрабатывает их. Однако в некоторых случаях, если запрос слишком сложный, может создаваться больше заданий. Рекомендуется изменять этот параметр, когда [max_connections](../Server_settings/Searchd.md#max_connections) и [threads](../Server_settings/Searchd.md#threads) недостаточны для достижения баланса между производительностью и загрузкой.

### join_batch_size

Объединения таблиц работают путём накопления партии совпадений, которые являются результатами запроса выполненного к левой таблице. Эта партия затем обрабатывается как один запрос к правой таблице.

Эта опция позволяет настроить размер партии. Значение по умолчанию — `1000`, а установка в `0` отключает пакетирование.

Больший размер партии может улучшить производительность; однако для некоторых запросов это может привести к чрезмерному потреблению памяти.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
join_batch_size = 2000
```
<!-- end -->

### join_cache_size

Каждый запрос, выполняемый по правой таблице, определяется особыми условиями JOIN ON, которые определяют набор данных, извлекаемый из правой таблицы.

Если существует лишь несколько уникальных условий JOIN ON, повторное использование результатов может быть эффективнее, чем повторное выполнение запросов к правой таблице. Чтобы это обеспечить, наборы результатов сохраняются в кэше.

Эта опция позволяет настроить размер этого кэша. Значение по умолчанию — `20 MB`, установка в 0 отключает кэширование.

Обратите внимание, что каждый поток поддерживает свой собственный кэш, поэтому при оценке общего потребления памяти следует учитывать количество потоков, выполняющих запросы.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
join_cache_size = 10M
```
<!-- end -->

### listen_backlog

<!-- example conf listen_backlog -->
Параметр `listen_backlog` определяет длину очереди прослушивания TCP для входящих соединений. Это особенно важно для сборок под Windows, которые обрабатывают запросы по одному. Когда очередь соединений достигает своего лимита, новые входящие подключения будут отвергнуты.
Для сборок не под Windows значение по умолчанию обычно подходит, и обычно нет необходимости изменять этот параметр.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
listen_backlog = 20
```
<!-- end -->

### kibana_version_string

<!-- example conf kibana_version_string -->
Строка версии сервера для возврата в Kibana или OpenSearch Dashboards. Опционально — по умолчанию установлена в `7.6.0`.

Некоторые версии Kibana и OpenSearch Dashboards ожидают от сервера конкретную версию и могут вести себя по-разному в зависимости от неё. Чтобы обойти такие проблемы, вы можете использовать этот параметр, который заставит Manticore сообщать Kibana или OpenSearch Dashboards кастомную версию.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
kibana_version_string = 1.2.3
```
<!-- end -->

### listen

<!-- example conf listen -->
Этот параметр позволяет указать IP-адрес и порт или путь к Unix-доменному сокету, на которых Manticore будет принимать соединения.

Общий синтаксис для `listen`:

```ini
listen = ( address ":" port | port | path | address ":" port start - port end ) [ ":" protocol [ "_vip" ] [ "_readonly" ] ]
```

Вы можете указать:
* либо IP-адрес (или имя хоста) и номер порта
* либо просто номер порта
* либо путь к Unix-сокету (не поддерживается в Windows)
* либо IP-адрес и диапазон портов

Если вы указали номер порта, но не указали адрес, `searchd` будет слушать на всех сетевых интерфейсах. Путь Unix-сокета определяется ведущим слэшем. Диапазон портов можно задать только для протокола репликации.

Также можно указать обработчик протокола (listener), который будет использоваться для соединений на этом сокете. Слушатели:

* **Не указан** - Manticore будет принимать соединения на этом порту от:
  - других агентов Manticore (т.е., удалённая распределённая таблица)
  - клиентов через HTTP и HTTPS
  - [Manticore Buddy](https://manticoresearch.com/blog/manticoresearch-buddy-intro/). **Убедитесь, что у вас есть такой слушатель (или http-слушатель, как указано ниже), чтобы избежать ограничений в функциональности Manticore.**
* `mysql` протокол MySQL для соединений от MySQL клиентов. Примечания:
  - Также поддерживается сжатый протокол.
  - Если включён [SSL](../Security/SSL.md#SSL), можно установить зашифрованное соединение.
* `replication` - протокол репликации для общения узлов. Подробнее можно найти в разделе [репликация](../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md). Можно указать несколько слушателей репликации, но все они должны слушать на одном IP; различаться могут только порты. Если вы задаёте слушатель репликации с диапазоном портов (например, `listen = 192.168.0.1:9320-9328:replication`), Manticore не начнёт слушать их сразу. Он будет брать случайные свободные порты из указанного диапазона только когда вы начнёте использовать репликацию. Для правильной работы репликации в диапазоне должно быть не менее 2 портов.
* `http` - то же самое, что **Не указан**. Manticore будет принимать соединения на этом порту от удалённых агентов и клиентов через HTTP и HTTPS.
* `https` - протокол HTTPS. Manticore будет принимать **только** HTTPS соединения на этом порту. Подробнее см. раздел [SSL](../Security/SSL.md).
* `sphinx` - устаревший бинарный протокол. Используется для обслуживания соединений от удалённых клиентов [SphinxSE](../Extensions/SphinxSE.md). Некоторые реализации клиентов Sphinx API (например, Java-клиент) требуют явного указания слушателя.

Добавление суффикса `_vip` к протоколам клиентов (то есть ко всем, кроме `replication`, например, `mysql_vip` или `http_vip` или просто `_vip`) заставляет создать выделенный поток для соединения, чтобы обойти различные ограничения. Это полезно для обслуживания узла в случае серьёзной перегрузки, когда сервер иначе мог бы зависнуть или отказать в подключении через обычный порт.

Суффикс `_readonly` устанавливает [режим только для чтения](../Security/Read_only.md) для слушателя и ограничивает его приём запросов только на чтение.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
listen = localhost
listen = localhost:5000 # listen for remote agents (binary API) and http/https requests on port 5000 at localhost
listen = 192.168.0.1:5000 # listen for remote agents (binary API) and http/https requests on port 5000 at 192.168.0.1
listen = /var/run/manticore/manticore.s # listen for binary API requests on unix socket
listen = /var/run/manticore/manticore.s:mysql # listen for mysql requests on unix socket
listen = 9312 # listen for remote agents (binary API) and http/https requests on port 9312 on any interface
listen = localhost:9306:mysql # listen for mysql requests on port 9306 at localhost
listen = localhost:9307:mysql_readonly # listen for mysql requests on port 9307 at localhost and accept only read queries
listen = 127.0.0.1:9308:http # listen for http requests as well as connections from remote agents (and binary API) on port 9308 at localhost
listen = 192.168.0.1:9320-9328:replication # listen for replication connections on ports 9320-9328 at 192.168.0.1
listen = 127.0.0.1:9443:https # listen for https requests (not http) on port 9443 at 127.0.0.1
listen = 127.0.0.1:9312:sphinx # listen for legacy Sphinx requests (e.g. from SphinxSE) on port 9312 at 127.0.0.1
```
<!-- end -->

Может быть несколько директив `listen`. `searchd` будет принимать подключения клиентов на всех указанных портах и сокетах. Конфигурация по умолчанию, входящая в пакеты Manticore, определяет прослушивание портов:
* `9308` и `9312` для соединений от удалённых агентов и клиентов, не использующих MySQL
* и порта `9306` для MySQL соединений.

Если вы не укажете ни одного `listen` в конфигурации, Manticore будет ждать соединений на:
* `127.0.0.1:9306` для MySQL клиентов
* `127.0.0.1:9312` для HTTP/HTTPS и соединений от других узлов Manticore и клиентов, основанных на бинарном API Manticore.

#### Прослушивание на привилегированных портах

По умолчанию Linux не позволит Manticore слушать на порту ниже 1024 (например, `listen = 127.0.0.1:80:http` или `listen = 127.0.0.1:443:https`), если вы не запускаете searchd от root. Если вы всё же хотите запускать Manticore под непривилегированным пользователем, чтобы он слушал порты < 1024, рассмотрите один из следующих вариантов (любой из них должен работать):
* Выполните команду `setcap CAP_NET_BIND_SERVICE=+eip /usr/bin/searchd`
* Добавьте `AmbientCapabilities=CAP_NET_BIND_SERVICE` в системный unit Manticore для systemd и перезагрузите демон (`systemctl daemon-reload`).

#### Технические детали о протоколе Sphinx API и TFO
<details>
Устаревший протокол Sphinx состоит из 2 фаз: обмена рукопожатием и передачи данных. Рукопожатие — это пакет из 4 байт от клиента и пакет из 4 байт от демона с единственной целью — клиент определяет, что удалённый — реальный демон Sphinx, демонах — что клиент — настоящий клиент Sphinx. Основной поток данных довольно простой: обе стороны обмениваются рукопожатиями, и противоположная сторона проверяет их. Такой обмен короткими пакетами предполагает использование специального флага `TCP_NODELAY`, который отключает алгоритм TCP Нагла и указывает, что TCP-соединение будет осуществляться как диалог маленьких пакетов.
Однако чётко не определено, кто первым начинает этот обмен. Исторически все клиенты, использующие бинарный API, начинают первыми: отправляют рукопожатие, затем читают 4 байта от демона, затем отправляют запрос и читают ответ от демона.
Когда мы улучшали совместимость с протоколом Sphinx, мы учитывали следующее:

1. Обычно связь мастер-агент устанавливается с известного клиента на известный хост и порт. Следовательно, практически невозможно, чтобы конечная точка предоставила неправильное рукопожатие. Поэтому можно неявно предположить, что обе стороны валидны и действительно используют протокол Sphinx.
2. Исходя из этого, мы можем «слепить» рукопожатие вместе с настоящим запросом и отправить одним пакетом. Если бекенд — устаревший демон Sphinx, он просто прочитает этот слепленный пакет как 4 байта рукопожатия, затем тело запроса. Поскольку они пришли в одном пакете, сокет бекенда имеет -1 RTT, а буфер фронтенда при этом работает обычным способом несмотря на это.
3. Продолжая предположение: поскольку пакет 'query' довольно маленький, а рукопожатие (handshake) еще меньше, давайте отправим оба в начальном TCP-пакете 'SYN' с использованием современной техники TFO (tcp-fast-open). То есть: мы подключаемся к удаленному узлу с "склеенным" пакетом рукопожатия + тела запроса. Демон принимает соединение и сразу получает и рукопожатие, и тело в буфере сокета, так как они пришли в самом первом TCP-пакете 'SYN'. Это исключает еще один RTT.
4. Наконец, научите демон принимать это улучшение. Фактически, с точки зрения приложения это означает НЕ использовать `TCP_NODELAY`. А со стороны системы это означает обеспечить, чтобы на стороне демона было активировано принятие TFO, а на стороне клиента — отправка TFO. По умолчанию в современных системах клиентский TFO уже активирован, поэтому нужно настроить серверный TFO, чтобы все работало.

Все эти улучшения без фактического изменения самого протокола позволили нам устранить 1.5 RTT протокола TCP из установления соединения. Если запрос и ответ могут быть помещены в один TCP-пакет, это уменьшает всю сессию бинарного API с 3.5 RTT до 2 RTT — что делает сетевой обмен примерно в 2 раза быстрее.

Так что все наши улучшения вращаются вокруг изначально неопределенного утверждения: 'кто говорит первым'. Если клиент говорит первым, мы можем применить все эти оптимизации и эффективно обработать соединение + рукопожатие + запрос в одном TFO-пакете. Более того, мы можем взглянуть в начало полученного пакета и определить реальный протокол. Поэтому можно подключаться к одному и тому же порту через API/http/https. Если демон должен говорить первым, все эти оптимизации невозможны, и мультипротокольность тоже невозможна. Вот почему у нас выделен отдельный порт для MySQL, который не объединен с другими протоколами на одном порту. Вдруг среди всех клиентов оказался тот, кто написан с предположением, что демон должен послать рукопожатие первым. Это — нет возможности реализовать описанные улучшения. Это плагин SphinxSE для mysql/mariadb. Поэтому специально для этого клиента мы выделили определение протокола `sphinx` для работы в максимально наследуемом режиме. А именно: обе стороны активируют `TCP_NODELAY` и обмениваются маленькими пакетами. Демон посылает рукопожатие при подключении, затем клиент отправляет свое, и затем всё работает как обычно. Это не очень оптимально, но работает. Если вы используете SphinxSE для подключения к Manticore — нужно выделить слушатель с явно указанным протоколом `sphinx`. Для других клиентов — избегайте использовать этот слушатель, так как он медленнее. Если вы используете других наследуемых Sphinx API клиентов — сначала проверьте, могут ли они работать через недедицированный мультипротокольный порт. Для связи мастер-агент через недедицированный (мультипротокольный) порт и активации клиентского и серверного TFO работает хорошо и обязательно ускорит работу сетевого бэкенда, особенно если у вас очень легкие и быстрые запросы.
</details>

### listen_tfo

Этот параметр позволяет установить флаг TCP_FASTOPEN для всех слушателей. По умолчанию он управляется системой, но может быть явно отключен установкой значения '0'.

Общую информацию о расширении TCP Fast Open смотрите в [Википедии](https://en.wikipedia.org/wiki/TCP_Fast_Open). Вкратце, оно позволяет устранить один TCP раунд-трип при установлении соединения.

На практике использование TFO во многих случаях может оптимизировать сетевой обмен между клиентом и агентом, как если бы использовались [постоянные агенты](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md), но без удержания активных соединений, и без ограничения максимального количества соединений.

В современных ОС поддержка TFO обычно включена на уровне системы, но это скорее "возможность", а не правило. Linux (как самая прогрессивная система) поддерживает его с 2011 года, на ядрах начиная с 3.7 (для серверной стороны). Windows поддерживает его с некоторых сборок Windows 10. Другие ОС (FreeBSD, MacOS) также участвую в этой технологии.

Для Linux систем сервер проверяет переменную `/proc/sys/net/ipv4/tcp_fastopen` и ведет себя согласно ей. Бит 0 управляет клиентской стороной, бит 1 — слушателями. По умолчанию система устанавливает параметр в 1, т.е. клиенты включены, слушатели выключены.

### log

<!-- example conf log -->
Параметр log задает имя файла журнала, в который будут записываться все события выполнения `searchd`. Если не указано, по умолчанию имя — 'searchd.log'.

Вместо этого можно указать имя файла 'syslog'. В этом случае события будут отправляться в демон syslog. Для использования опции syslog нужно собрать Manticore с опцией `-–with-syslog`.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
log = /var/log/searchd.log
```
<!-- end -->


### max_batch_queries

<!-- example conf max_batch_queries -->
Ограничивает количество запросов в одном пакете. Опционально, по умолчанию — 32.

Заставляет searchd выполнять проверку разумности количества запросов, отправленных в одном пакете при использовании [мульти-запросов](../Searching/Multi-queries.md). Установите значение 0, чтобы пропустить эту проверку.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_batch_queries = 256
```
<!-- end -->

### max_connections

<!-- example max_connections -->
Максимальное количество одновременных клиентских соединений. По умолчанию неограничено. Это обычно становится заметно только при использовании любых видов постоянных соединений, например cli mysql сессий или постоянных удаленных соединений с распределенных таблиц. При превышении лимита вы все еще можете подключаться к серверу через [VIP connection](../Connecting_to_the_server/MySQL_protocol.md#VIP-connection). VIP соединения не учитываются в лимите.

<!-- request Example -->
```ini
max_connections = 10
```

<!-- end -->

### max_threads_per_query

<!-- example max_threads_per_query -->
Глобальное ограничение по количеству потоков, которые может использовать одна операция. По умолчанию соответствующие операции могут занимать все ядра ЦПУ, не оставляя места для других операций. Например, `call pq` по достаточно большой таблице percolate может использовать все потоки в течение десятков секунд. Установка `max_threads_per_query`, скажем, на половину от [threads](../Server_settings/Searchd.md#threads) обеспечит возможность запуска пары таких операций `call pq` параллельно.

Вы также можете установить этот параметр как сессионную или глобальную переменную во время работы.

Кроме того, вы можете управлять поведением для каждого запроса с помощью [threads OPTION](../Searching/Options.md#threads).

<!-- intro -->
##### Пример:
<!-- request Example -->

```ini
max_threads_per_query = 4
```

<!-- end -->

### max_filters

<!-- example conf max_filters -->
Максимальное разрешённое количество фильтров на запрос. Этот параметр используется только для внутренних проверок и не влияет напрямую на использование ОЗУ или производительность. Необязательно, по умолчанию — 256.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_filters = 1024
```
<!-- end -->


### max_filter_values

<!-- example conf max_filter_values -->
Максимально разрешённое количество значений одного фильтра. Этот параметр используется только для внутренних проверок и не влияет напрямую на использование ОЗУ или производительность. Необязательно, по умолчанию — 4096.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_filter_values = 16384
```
<!-- end -->


### max_open_files

<!-- example conf max_open_files -->
Максимальное количество файлов, которые серверу разрешено одновременно открывать, называется «мягким лимитом». Обратите внимание, что обслуживание больших сильно фрагментированных таблиц real-time может требовать установки этого лимита достаточно высоким, поскольку каждый кусок на диске может занимать десятки и более файлов. Например, real-time таблица с 1000 кусочков может потребовать открытия тысяч файлов одновременно. Если вы столкнулись с ошибкой «Too many open files» в логах, попробуйте настроить эту опцию — это может помочь решить проблему.

Существует также «жесткий лимит», который нельзя превысить с помощью этой опции. Этот лимит определяется системой и может быть изменён в файле `/etc/security/limits.conf` на Linux. В других операционных системах могут использоваться различные подходы, поэтому смотрите соответствующую документацию.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_open_files = 10000
```
<!-- end -->

<!-- example conf max_open_files max -->
Помимо прямых числовых значений, можно использовать magic слово 'max' для установки лимита равным доступному текущему жёсткому лимиту.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_open_files = max
```
<!-- end -->


### max_packet_size

<!-- example conf max_packet_size -->
Максимально разрешённый размер сетевого пакета. Этот параметр ограничивает как пакет запроса от клиента, так и пакет ответа от удаленных агентов в распределённой среде. Используется только для внутренних проверок и не влияет напрямую на использование ОЗУ или производительность. Необязательно, по умолчанию — 128M.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_packet_size = 32M
```
<!-- end -->


### mysql_version_string

<!-- example conf mysql_version_string -->
Строка версии сервера, возвращаемая по протоколу MySQL. Необязательно, по умолчанию — пусто (возвращается версия Manticore).

Некоторые требовательные библиотеки клиентов MySQL зависят от конкретного формата номера версии, используемого MySQL, и более того, иногда выбирают разный путь выполнения на основе указанного номера версии (а не на основе флагов возможностей). Например, Python MySQLdb 1.2.2 выбрасывает исключение, если номер версии не в формате X.Y.ZZ; MySQL .NET connector 6.3.x внутренне падает на номерах версий 1.x вместе с определённой комбинацией флагов и т.д. Чтобы обойти это, можно использовать директиву `mysql_version_string` и настроить `searchd` так, чтобы он сообщал клиентам, подключающимся по MySQL-протоколу, другую версию. (По умолчанию он сообщает собственную версию.)


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
mysql_version_string = 5.0.37
```
<!-- end -->


### net_workers

Количество сетевых потоков, по умолчанию — 1.

Этот параметр полезен при чрезвычайно высоких скоростях запросов, когда одного потока недостаточно для обработки всех входящих запросов.


### net_wait_tm

Управляет интервалом busy loop сетевого потока. Значение по умолчанию -1, может быть установлено в -1, 0 или положительное целое число.

В случаях, когда сервер настроен как чистый мастер и просто маршрутизирует запросы агентам, важно обрабатывать запросы без задержек и не допускать сна сетевого потока. Для этого используется busy loop. После входящего запроса сетевой поток использует CPU poll на `10 * net_wait_tm` миллисекунд, если `net_wait_tm` положительно, или опрашивает только с CPU, если `net_wait_tm` равен `0`. Кроме того, busy loop может быть отключён с помощью `net_wait_tm = -1` — в этом случае poller устанавливает таймаут, соответствующий таймаутам агентов на системном вызове опроса.

> **ВНИМАНИЕ:** Busy loop загружает ядро CPU, поэтому установка этого значения в любое не дефолтное значение приведёт к заметному использованию CPU даже при простое сервера.


### net_throttle_accept

Определяет, сколько клиентов принимается на каждую итерацию сетевого цикла. По умолчанию 0 (без ограничений), что подходит для большинства пользователей. Это тонкая настройка для управления пропускной способностью сетевого цикла в условиях высокой нагрузки.


### net_throttle_action

Определяет, сколько запросов обрабатывается на каждую итерацию сетевого цикла. По умолчанию 0 (без ограничений), что подходит для большинства пользователей. Это тонкая настройка для управления пропускной способностью сетевого цикла в условиях высокой нагрузки.

### network_timeout

<!-- example conf network_timeout -->
Таймаут чтения/записи сетевого запроса клиента в секундах (или с [special_suffixes](../Server_settings/Special_suffixes.md)). Необязательно, по умолчанию — 5 секунд. `searchd` принудительно закроет соединение клиента, который не отправил запрос или не получил ответ в течение этого таймаута.

Обратите внимание также на параметр [reset_network_timeout_on_packet](../Server_settings/Searchd.md#reset_network_timeout_on_packet). Этот параметр изменяет поведение `network_timeout` — он применяется не ко всему `query` или `result`, а к отдельным пакетам. Обычно запрос/результат помещается в один или два пакета. Однако в случаях, когда необходимо большое количество данных, этот параметр может быть незаменим для поддержания активной работы.

<!-- request Example -->

```ini
network_timeout = 10s
```
<!-- end -->

### node_address

<!-- example conf node_address -->
Этот параметр позволяет указать сетевой адрес узла. По умолчанию он установлен на адрес репликации [listen](../Server_settings/Searchd.md#listen). В большинстве случаев это корректно, однако существуют ситуации, когда необходимо указать его вручную:

* Узел за файрволом
* Включен сетевой транслятор адресов (NAT)
* Развертывание в контейнерах, таких как Docker или облачные среды
* Кластеры с узлами в нескольких регионах


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
node_address = 10.101.0.10
```
<!-- end -->

### not_terms_only_allowed

<!-- example conf not_terms_only_allowed -->
Этот параметр определяет, разрешать ли запросы, содержащие только оператор [отрицания](../Searching/Full_text_matching/Operators.md#Negation-operator) полнотекстового поиска. Необязательный, по умолчанию 0 (запросы с только оператором NOT завершаются с ошибкой).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
not_terms_only_allowed = 1
```
<!-- end -->

### optimize_cutoff

<!-- example conf optimize_cutoff -->
Устанавливает порог сжатия таблицы по умолчанию. Подробнее здесь — [Number of optimized disk chunks](../Securing_and_compacting_a_table/Compacting_a_table.md#Number-of-optimized-disk-chunks). Этот параметр может быть переопределён опцией запроса [cutoff](../Securing_and_compacting_a_table/Compacting_a_table.md#Number-of-optimized-disk-chunks). Также его можно изменить динамически через [SET GLOBAL](../Server_settings/Setting_variables_online.md#SET).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
optimize_cutoff = 4
```
<!-- end -->

### persistent_connections_limit

<!-- example conf persistent_connections_limit -->
Этот параметр задаёт максимальное количество одновременных постоянных соединений с удалёнными [persistent agents](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md). Каждый раз при подключении агента, определённого в `agent_persistent`, происходит попытка повторно использовать существующее соединение (если есть) или установить новое и сохранить его для будущего использования. Однако в некоторых случаях имеет смысл ограничить число таких постоянных соединений. Этот директив задаёт это ограничение. Оно влияет на количество соединений с хостом каждого агента во всех распределённых таблицах.

Рекомендуется установить значение равным или меньшим, чем опция [max_connections](../Server_settings/Searchd.md#max_connections) в конфигурации агента.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
persistent_connections_limit = 29 # assume that each host of agents has max_connections = 30 (or 29).
```
<!-- end -->


### pid_file

<!-- example conf pid_file -->
pid_file — обязательный параметр конфигурации в Manticore search, задающий путь к файлу, в котором хранится идентификатор процесса (PID) сервера `searchd`.

Файл PID процесса searchd пересоздаётся и блокируется при запуске, в нём хранится PID основного процесса сервера, пока сервер работает. При остановке сервера файл удаляется.
Назначение этого файла — позволить Manticore выполнять различные внутренние задачи, такие как проверка запущенного экземпляра `searchd`, остановка `searchd` и уведомление о необходимости ротации таблиц. Файл также может использоваться внешними скриптами автоматизации.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
pid_file = /var/run/manticore/searchd.pid
```
<!-- end -->


### predicted_time_costs

<!-- example conf predicted_time_costs -->
Затраты для модели прогнозирования времени выполнения запроса, в наносекундах. Необязательный, по умолчанию `doc=64, hit=48, skip=2048, match=64`.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
predicted_time_costs = doc=128, hit=96, skip=4096, match=128
```
<!-- end -->

<!-- example conf predicted_time_costs 1 -->
Прерывание запросов до их завершения на основе времени выполнения (с помощью настройки max query time) — хороший защитный механизм, но с одним существенным недостатком: неопределённые (нестабильные) результаты. То есть если повторять один и тот же (сложный) поисковый запрос с ограничением по времени несколько раз, лимит времени будет достигаться на разных этапах, и вы получите *разные* наборы результатов.

<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
SELECT … OPTION max_query_time
```
<!-- request API -->

```api
SetMaxQueryTime()
```
<!-- end -->

Существует опция [SELECT … OPTION max_predicted_time](../Searching/Options.md#max_predicted_time), которая позволяет ограничить время выполнения запроса *и* получать стабильные, повторяемые результаты. Вместо регулярной проверки фактического текущего времени во время выполнения запроса, что является неопределённым, используется прогноз текущего времени выполнения по простой линейной модели:

```ini
predicted_time =
    doc_cost * processed_documents +
    hit_cost * processed_hits +
    skip_cost * skiplist_jumps +
    match_cost * found_matches
```

Затем запрос досрочно прерывается, когда `predicted_time` достигает заданного предела.

Разумеется, это не жёсткое ограничение фактического затраченного времени (однако это жёсткий предел затрат *на обработку*), и простая линейная модель никак не является идеально точной. Поэтому реальное время может быть как ниже, так и выше целевого предела. Тем не менее, погрешности довольно приемлемы: например, в наших экспериментах с целевым лимитом 100 мс большинство тестовых запросов укладывались в интервал 95-105 мс, и *все* запросы попадали в диапазон 80-120 мс. Также приятным побочным эффектом использования моделируемого времени вместо измерения реального времени является небольшое уменьшение количества вызовов gettimeofday().

Ни одна пара моделей и производителей серверов не идентичны, поэтому директива `predicted_time_costs` позволяет вам настроить стоимости для приведенной выше модели. Для удобства они выражены целыми числами, измеряемыми в наносекундах. (Ограничение в max_predicted_time считается в миллисекундах, и указывать значения стоимости как 0.000128 мс вместо 128 нс несколько более подвержено ошибкам.) Нет необходимости указывать все четыре стоимости одновременно, так как пропущенные будут иметь значения по умолчанию. Однако мы настоятельно рекомендуем указывать все для удобочитаемости.


### preopen_tables

<!-- example conf preopen_tables -->
Директива конфигурации preopen_tables указывает, следует ли принудительно предварительно открывать все таблицы при запуске. Значение по умолчанию — 1, что означает, что все таблицы будут предварительно открыты независимо от настройки [preopen](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Other-performance-related-settings) на уровне каждой таблицы. Если установлено значение 0, настройки на уровне таблиц могут вступить в силу, и по умолчанию они равны 0.

Предварительное открытие таблиц может предотвратить гонки между поисковыми запросами и ротациями, которые могут время от времени приводить к сбоям запросов. Однако это также использует больше файловых дескрипторов. В большинстве сценариев рекомендуется предварительно открывать таблицы.

Вот пример конфигурации:

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
preopen_tables = 1
```
<!-- end -->

### pseudo_sharding

<!-- example conf pseudo_sharding -->
Опция конфигурации pseudo_sharding включает параллелизацию поисковых запросов к локальным обычным и реальным таблицам, независимо от того, запрашиваются ли они напрямую или через распределенную таблицу. Эта функция автоматически параллелит запросы до числа потоков, указанного в `searchd.threads` # потоков.

Обратите внимание, что если ваши рабочие потоки уже заняты, потому что у вас:
* высокая конкуренция запросов
* физический шардирование любого типа:
  - распределенная таблица из нескольких обычных/реальных таблиц
  - реальная таблица, состоящая из слишком многих дисковых чанков

то включение pseudo_sharding может не принести никаких преимуществ, а даже привести к небольшому снижению пропускной способности. Если вы отдаете приоритет более высокой пропускной способности над меньшей задержкой, рекомендуется отключить эту опцию.

Включено по умолчанию.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
pseudo_sharding = 0
```
<!-- end -->


### replication_connect_timeout

Директива `replication_connect_timeout` определяет таймаут подключения к удалённому узлу. По умолчанию значение предполагается в миллисекундах, но может иметь [другой суффикс](../Server_settings/Special_suffixes.md). Значение по умолчанию — 1000 (1 секунда).

При подключении к удалённому узлу Manticore будет ждать успешного подключения не более указанного времени. Если таймаут истекает, но соединение не установлено, и включены `retries`, будет инициирована повторная попытка.


### replication_query_timeout

`replication_query_timeout` задает время ожидания searchd для ответа удалённого узла на запрос. Значение по умолчанию — 3000 миллисекунд (3 секунды), но может иметь `суффикс` для указания другой единицы времени.

После установления соединения Manticore будет ждать максимум `replication_query_timeout` для завершения работы удалённого узла. Обратите внимание, что этот таймаут отличается от `replication_connect_timeout`, и суммарная возможная задержка из-за удалённого узла будет равна сумме двух значений.


### replication_retry_count

Этот параметр — целое число, определяющее, сколько раз Manticore попытается подключиться и выполнить запрос к удалённому узлу во время репликации, прежде чем сообщить об ошибке запроса. Значение по умолчанию — 3.


### replication_retry_delay

Этот параметр — целое число в миллисекундах (или [special_suffixes](../Server_settings/Special_suffixes.md)), задает задержку перед повторной попыткой запроса к удалённому узлу при сбое во время репликации. Значение актуально только при значении, отличном от нуля. Значение по умолчанию — 500.

### qcache_max_bytes

<!-- example conf qcache_max_bytes -->
Эта конфигурация задает максимальный объём оперативной памяти, выделенной для кэшированных результатов запросов в байтах. Значение по умолчанию — 16777216, что эквивалентно 16 мегабайтам. Если значение установлено в 0, кэш запросов отключен. Подробнее о кэше запросов смотрите в разделе [query cache](../Searching/Query_cache.md).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
qcache_max_bytes = 16777216
```
<!-- end -->


### qcache_thresh_msec

Целое число, в миллисекундах. Минимальный порог времени выполнения запроса, при котором результат будет закэширован. По умолчанию 3000 (3 секунды). 0 означает кэшировать всё. Подробности в разделе [query cache](../Searching/Query_cache.md). Это значение также может быть представлено с использованием временных [special_suffixes](../Server_settings/Special_suffixes.md), но используйте это с осторожностью и не путайте с названием самого параметра, содержащим '_msec'.


### qcache_ttl_sec

Целое число, в секундах. Время жизни закэшированного результата запроса. Значение по умолчанию 60 (1 минута). Минимальное возможное значение — 1 секунда. Подробнее в разделе [query cache](../Searching/Query_cache.md). Значение также может быть выражено с помощью временных [special_suffixes](../Server_settings/Special_suffixes.md), но используйте с осторожностью и не путайте с названием параметра, содержащим '_sec'.


### query_log_format

<!-- example conf query_log_format -->
Формат журнала запросов. Необязательно, допустимые значения — `plain` и `sphinxql`, по умолчанию `sphinxql`.

Режим `sphinxql` логирует корректные SQL-запросы. Режим `plain` логирует запросы в виде обычного текста (в основном подходит для чисто полнотекстовых сценариев). Эта директива позволяет переключаться между двумя форматами при запуске сервера поиска. Формат журнала также можно менять на лету с помощью синтаксиса `SET GLOBAL query_log_format=sphinxql`. Подробнее см. в разделе [Query logging](../Logging/Query_logging.md).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
query_log_format = sphinxql
```
<!-- end -->

### query_log_min_msec

Лимит (в миллисекундах), который предотвращает запись запроса в журнал запросов. Необязательно, по умолчанию 0 (все запросы записываются в журнал запросов). Эта директива указывает, что в журнал будут записываться только те запросы, время выполнения которых превышает указанный лимит (это значение также может быть выражено с помощью временных [специальных_суффиксов](../Server_settings/Special_suffixes.md), но используйте это с осторожностью и не путайте с именем самого значения, содержащим `_msec`).

### query_log

<!-- example conf query_log -->
Имя файла журнала запросов. Необязательно, по умолчанию пусто (запросы не логируются). Все поисковые запросы (например, SELECT ..., но не INSERT/REPLACE/UPDATE) будут записываться в этот файл. Формат описан в разделе [Логирование запросов](../Logging/Query_logging.md). В случае формата 'plain' вы можете использовать 'syslog' в качестве пути к файлу журнала. В этом случае все поисковые запросы будут отправляться демону syslog с приоритетом `LOG_INFO`, с префиксом '[query]' вместо метки времени. Для использования опции syslog Manticore должен быть собран с опцией  `-–with-syslog`.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
query_log = /var/log/query.log
```
<!-- end -->


### query_log_mode

<!-- example conf query_log_mode -->
Директива query_log_mode позволяет установить разные права доступа для файлов журнала searchd и журнала запросов. По умолчанию эти журналы создаются с разрешениями 600, что означает, что читать журналы может только пользователь, под которым запущен сервер, и пользователи root.
Эта директива полезна, если вы хотите разрешить другим пользователям читать журналы, например, решениям мониторинга, работающим не от root.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
query_log_mode  = 666
```
<!-- end -->

### read_buffer_docs

<!-- example conf read_buffer_docs -->
Директива read_buffer_docs контролирует размер буфера чтения на ключевое слово для списков документов. Для каждого вхождения ключевого слова в каждом поисковом запросе существует два связанных буфера чтения: один для списка документов и один для списка попаданий. Эта настройка позволяет контролировать размер буфера для списка документов.

Больший размер буфера может увеличить использование оперативной памяти на запрос, но потенциально уменьшить время ввода-вывода. Имеет смысл устанавливать большие значения для медленных хранилищ, но для хранилищ с высокой IOPS рекомендуется экспериментировать с малыми значениями.

Значение по умолчанию — 256K, минимальное значение — 8K. Также можно установить [read_buffer_docs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#read_buffer_docs) для каждой таблицы отдельно, что переопределит настройки на уровне сервера.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
read_buffer_docs = 128K
```
<!-- end -->


### read_buffer_hits

<!-- example conf read_buffer_hits -->
Директива read_buffer_hits задаёт размер буфера чтения на ключевое слово для списков попаданий в поисковых запросах. По умолчанию размер равен 256K, минимальное значение — 8K. Для каждого вхождения ключевого слова в поисковом запросе существует два связанных буфера чтения: один для списка документов и один для списка попаданий. Увеличение размера буфера может увеличить использование оперативной памяти на запрос, но уменьшить время ввода-вывода. Для медленных хранилищ имеет смысл устанавливать большие размеры буфера, а для хранилищ с высокой IOPS рекомендуется экспериментировать с малыми значениями.

Эту настройку также можно задать для каждой таблицы отдельно, используя опцию read_buffer_hits в [read_buffer_hits](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#read_buffer_hits), что переопределит настройку на уровне сервера.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
read_buffer_hits = 128K
```
<!-- end -->

### read_unhinted

<!-- example conf read_unhinted -->
Размер неуказанного чтения. Необязательно, по умолчанию 32K, минимальный 1K.

При запросах некоторые чтения заранее точно знают, сколько данных нужно прочитать, а некоторые пока нет. Особенно это касается размера списка попаданий, который сейчас заранее неизвестен. Эта настройка позволяет контролировать, сколько данных читать в таких случаях. Она влияет на время ввода-вывода списка попаданий, снижая его для списков, больших чем размер неуказанного чтения, но увеличивая для меньших списков. Она **не** влияет на использование оперативной памяти, так как буфер чтения уже будет выделен. Поэтому её не следует устанавливать больше, чем read_buffer.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
read_unhinted = 32K
```
<!-- end -->

### reset_network_timeout_on_packet

<!-- example conf reset_network_timeout_on_packet -->
Уточняет поведение таймаутов сети (таких как `network_timeout`, `read_timeout` и `agent_query_timeout`).

Если установить в 0, таймауты ограничивают максимальное время отправки всего запроса/запроса.
Если установить в 1 (по умолчанию), таймауты ограничивают максимальное время между сетевой активностью.

При репликации узлу может потребоваться отправить большой файл (например, 100 ГБ) другому узлу. Предположим, что сеть передает данные со скоростью 1 ГБ/с, с серией пакетов по 4-5 МБ каждый. Для передачи всего файла потребуется 100 секунд. По умолчанию таймаут в 5 секунд позволит передать только 5 ГБ, после чего соединение будет разорвано. Увеличение таймаута может быть временным решением, но оно не масштабируется (например, следующий файл может быть 150 ГБ, что снова приведёт к сбою). Однако, при значении по умолчанию `reset_network_timeout_on_packet` равном 1 таймаут применяется не к всей передаче, а к отдельным пакетам. Пока передача продолжается (и данные действительно принимаются в течение периода таймаута), соединение поддерживается. Если же передача застрянет и произойдет таймаут между пакетами, соединение будет разорвано.

Обратите внимание, что если вы настроите распределённую таблицу, каждый узел — и мастер, и агенты — должен быть настроен. На стороне мастера влияет `agent_query_timeout`, на агентах — `network_timeout`.

<!-- intro -->

##### Пример:

<!-- request Example -->

```ini
reset_network_timeout_on_packet = 0
```

<!-- end -->


### rt_flush_period

<!-- example conf rt_flush_period -->
Период проверки сброса чанков оперативной памяти RT-таблиц, в секундах (или с использованием [специальных_суффиксов](../Server_settings/Special_suffixes.md)). Необязательно, по умолчанию 10 часов.

Активно обновляемые RT таблицы, которые полностью помещаются в фрагменты оперативной памяти, все равно могут привести к постоянно растущим бинарным журналам, что влияет на использование диска и время восстановления после сбоев. С помощью данной директивы поисковый сервер выполняет периодические проверки сброса, и подходящие фрагменты оперативной памяти могут быть сохранены, что позволяет впоследствии очистить бинарные журналы. Подробнее см. в разделе [Binary logging](../Logging/Binary_logging.md).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
rt_flush_period = 3600 # 1 hour
```
<!-- end -->


### rt_merge_iops

<!-- example conf rt_merge_iops -->
Максимальное количество операций ввода-вывода (в секунду), которые поток слияния фрагментов RT может начать. Опционально, по умолчанию 0 (без ограничений).

Данная директива позволяет ограничить влияние операций ввода-вывода, возникающих из-за операторов `OPTIMIZE`. Гарантируется, что все операции оптимизации RT не будут генерировать больше операций ввода-вывода в секунду, чем установленный лимит. Ограничение rt_merge_iops может уменьшить деградацию производительности поиска, вызванную слиянием.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
rt_merge_iops = 40
```
<!-- end -->

### rt_merge_maxiosize

<!-- example conf rt_merge_maxiosize -->
Максимальный размер операции ввода-вывода, которую поток слияния фрагментов RT может начать. Опционально, по умолчанию 0 (без ограничений).

Данная директива позволяет ограничить воздействие операций ввода-вывода, возникающих из-за операторов `OPTIMIZE`. Операции ввода-вывода, превышающие этот лимит, будут разбиты на две или более операций ввода-вывода, которые далее учитываются как отдельные операции с точки зрения лимита [rt_merge_iops](../Server_settings/Searchd.md#rt_merge_iops). Таким образом, гарантируется, что все операции оптимизации не сгенерируют более (rt_merge_iops * rt_merge_maxiosize) байт ввода-вывода на диск в секунду.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
rt_merge_maxiosize = 1M
```
<!-- end -->


### seamless_rotate

<!-- example conf seamless_rotate -->
Предотвращает зависания `searchd` при ротации таблиц с огромными объемами данных для предзагрузки в кэш. Опционально, по умолчанию 1 (включена бесшовная ротация). В системах Windows бесшовная ротация отключена по умолчанию.

Таблицы могут содержать данные, которые необходимо предзагрузить в оперативную память. В данный момент файлы `.spa`, `.spb`, `.spi` и `.spm` полностью предзагружаются (они содержат данные атрибутов, данные блоб-атрибутов, таблицу ключевых слов и карту удаленных строк соответственно). Без бесшовной ротации процесс ротации таблицы пытается использовать минимальное количество оперативной памяти и работает следующим образом:

1. Новые запросы временно отклоняются (с кодом ошибки "retry");
2. `searchd` ожидает завершения всех текущих запросов;
3. Старая таблица освобождается, и её файлы переименовываются;
4. Новые файлы таблицы переименовываются, и выделяется необходимая оперативная память;
5. Новые данные атрибутов и словаря загружаются в оперативную память;
6. `searchd` возобновляет обработку запросов по новой таблице.

Однако, если объем данных атрибутов или словаря велик, то этап предзагрузки может занять заметное время — вплоть до нескольких минут при предзагрузке файлов размером 1-5+ ГБ.

С включенной бесшовной ротацией процесс ротации работает следующим образом:

1. Выделяется оперативная память для новой таблицы;
2. Данные атрибутов и словаря новой таблицы загружаются в оперативную память асинхронно;
3. В случае успеха старая таблица освобождается, и файлы обеих таблиц переименовываются;
4. В случае ошибки новая таблица освобождается;
5. В любой момент запросы обслуживаются либо из старой, либо из новой копии таблицы.

Бесшовная ротация достигается за счет большего пикового использования памяти во время ротации (поскольку обе копии данных `.spa/.spb/.spi/.spm` — старая и новая — должны находиться в оперативной памяти во время предзагрузки новой копии). Среднее использование памяти остается неизменным.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
seamless_rotate = 1
```
<!-- end -->

### secondary_indexes
<!-- example conf secondary_indexes -->

Эта опция включает или отключает использование вторичных индексов для поисковых запросов. Опционально, по умолчанию 1 (включено). Обратите внимание, что включать её для индексации не нужно, так как она всегда включена, если установлен [Manticore Columnar Library](https://github.com/manticoresoftware/columnar). Она также необходима для использования индексов при поиске. Доступны три режима:

* `0`: Отключить использование вторичных индексов при поиске. Их можно включить для отдельных запросов с помощью [аналитических подсказок](../Searching/Options.md#Query-optimizer-hints)
* `1`: Включить использование вторичных индексов при поиске. Их можно отключить для отдельных запросов с помощью [аналитических подсказок](../Searching/Options.md#Query-optimizer-hints)
* `force`: То же, что и включено, но любые ошибки при загрузке вторичных индексов будут зафиксированы, и весь индекс не будет загружен в демон.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
secondary_indexes = 1
```

<!-- end -->

### server_id

<!-- example conf server_id -->
Целочисленное значение, служащее идентификатором сервера и используемое как зерно для генерации уникального короткого UUID для узлов, входящих в кластер репликации. server_id должен быть уникальным среди узлов кластера и находиться в диапазоне от 0 до 127. Если server_id не установлен, он вычисляется как хэш MAC-адреса и пути к PID-файлу или для короткого UUID будет использовано случайное число.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
server_id = 1
```
<!-- end -->


### shutdown_timeout

<!-- example conf shutdown_timeout -->
Время ожидания `searchd --stopwait` в секундах (или [special_suffixes](../Server_settings/Special_suffixes.md)). Опционально, по умолчанию 60 секунд.

При запуске `searchd --stopwait` вашему серверу нужно выполнить ряд операций перед остановкой, таких как завершение запросов, сброс фрагментов RT из оперативной памяти, сброс атрибутов и обновление бинарного лога. Эти задачи требуют некоторого времени. `searchd --stopwait` будет ждать до `shutdown_time` секунд, пока сервер не завершит работу. Подходящее время зависит от размера ваших таблиц и нагрузки.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
shutdown_timeout = 3m # wait for up to 3 minutes
```
<!-- end -->


### shutdown_token

SHA1 хэш пароля, необходимого для вызова команды 'shutdown' из соединения VIP Manticore SQL. Без него,[debug](../Reporting_bugs.md#DEBUG) подкоманда 'shutdown' никогда не приведет к остановке сервера. Обратите внимание, что такое простое хэширование не следует считать надежной защитой, поскольку мы не используем соленый хэш или какие-либо современные функции хэширования. Это предназначено как неубиваемая мера для служебных демонов в локальной сети.

### snippets_file_prefix

<!-- example conf snippets_file_prefix -->
Префикс, который добавляется к локальным именам файлов при генерации сниппетов. Необязательно, по умолчанию это текущая рабочая папка.

Этот префикс может использоваться при распределенной генерации сниппетов вместе с опциями `load_files` или `load_files_scattered`.

Обратите внимание, что это именно префикс, а **не** путь! Это означает, что если задан префикс "server1" и запрос ссылается на "file23", `searchd` попытается открыть "server1file23" (все это без кавычек). Так что если вам нужен путь, вам нужно включить завершающий слэш.

После построения окончательного пути к файлу сервер разворачивает все относительные директории и сравнивает итоговый результат со значением `snippet_file_prefix`. Если результат не начинается с префикса, такой файл будет отклонен с сообщением об ошибке.

Например, если вы установите `/mnt/data`, и кто-то вызовет генерацию сниппета с файлом `../../../etc/passwd` в качестве источника, он получит сообщение об ошибке:

`File '/mnt/data/../../../etc/passwd' escapes '/mnt/data/' scope`

вместо содержимого файла.

Также при неустановленном параметре и чтении `/etc/passwd` фактически будет прочитан файл /daemon/working/folder/etc/passwd, так как значение по умолчанию для параметра — рабочая папка сервера.

Обратите внимание, что это локальная опция; она никак не влияет на агентов. Поэтому вы можете безопасно установить префикс на мастер-сервере. Запросы, маршрутизируемые к агентам, не будут затронуты настройкой мастера. Однако они будут влиять на собственные настройки агента.

Это может быть полезно, например, если расположения хранилищ документов (локальное хранилище или точки монтирования NAS) различаются на серверах.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
snippets_file_prefix = /mnt/common/server1/
```
<!-- end -->

> **ПРЕДУПРЕЖДЕНИЕ:** Если вы все же хотите получить доступ к файлам из корня файловой системы, вам нужно явно установить `snippets_file_prefix` в пустое значение (строкой `snippets_file_prefix=`) или в корень (строкой `snippets_file_prefix=/`).


### sphinxql_state

<!-- example conf sphinxql_state -->
Путь к файлу, в котором будет сериализовано текущее состояние SQL.

При запуске сервера этот файл воспроизводится. При соответствующих изменениях состояния (например, SET GLOBAL) этот файл автоматически перезаписывается. Это может предотвратить трудно диагностируемую проблему: если вы загружаете UDF-функции, но Manticore аварийно завершается, при автоматическом перезапуске ваши UDF и глобальные переменные будут недоступны. Использование сохраняемого состояния помогает обеспечить корректное восстановление без подобных сюрпризов.

`sphinxql_state` нельзя использовать для выполнения произвольных команд, таких как `CREATE TABLE`.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
sphinxql_state = uservars.sql
```
<!-- end -->


### sphinxql_timeout

<!-- example conf sphinxql_timeout -->
Максимальное время ожидания между запросами (в секундах или с [специальными суффиксами](../Server_settings/Special_suffixes.md)) при использовании SQL-интерфейса. Необязательно, значение по умолчанию — 15 минут.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
sphinxql_timeout = 15m
```
<!-- end -->


### ssl_ca

<!-- example conf ssl_ca -->
Путь к файлу сертификата Центра Сертификации (CA) SSL (также известного как корневой сертификат). Необязательно, по умолчанию пусто. При непустом значении сертификат в `ssl_cert` должен быть подписан этим корневым сертификатом.

Сервер использует файл CA для проверки подписи на сертификате. Файл должен быть в формате PEM.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ssl_ca = keys/ca-cert.pem
```
<!-- end -->


### ssl_cert

<!-- example conf ssl_cert -->
Путь к SSL-сертификату сервера. Необязательно, по умолчанию пусто.

Сервер использует этот сертификат в качестве самоподписанного открытого ключа для шифрования HTTP-трафика по SSL. Файл должен быть в формате PEM.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ssl_cert = keys/server-cert.pem
```
<!-- end -->


### ssl_key

<!-- example conf ssl_key -->
Путь к закрытому ключу SSL-сертификата. Необязательно, по умолчанию пусто.

Сервер использует этот приватный ключ для шифрования HTTP-трафика по SSL. Файл должен быть в формате PEM.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ssl_key = keys/server-key.pem
```
<!-- end -->


### subtree_docs_cache

<!-- example conf subtree_docs_cache -->
Максимальный размер кэша документов общего поддерева на запрос. Необязательно, по умолчанию 0 (отключено).

Эта настройка ограничивает использование ОЗУ оптимизатором общего поддерева (см. [multi-queries](../Searching/Multi-queries.md)). Не более этого объема памяти будет использовано для кэширования записей документов в каждом запросе. Установка лимита в 0 отключает оптимизатор.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
subtree_docs_cache = 8M
```
<!-- end -->


### subtree_hits_cache

<!-- example conf subtree_hits_cache -->
Максимальный размер кэша попаданий общего поддерева на запрос. Необязательно, по умолчанию 0 (отключено).

Эта настройка ограничивает использование ОЗУ оптимизатором общего поддерева (см. [multi-queries](../Searching/Multi-queries.md)). Не более этого объема памяти будет использовано для кэширования попаданий ключевых слов (хитов) в каждом запросе. Установка лимита в 0 отключает оптимизатор.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
subtree_hits_cache = 16M
```
<!-- end -->

### threads

<!-- example threads -->
Количество рабочих потоков (размер пула потоков) для демона Manticore. Manticore создаёт такое количество потоков ОС при запуске, и они выполняют все задачи внутри демона, такие как выполнение запросов, создание сниппетов и т. д. Некоторые операции могут быть разделены на подзадачи и выполняться параллельно, например:

* Поиск в таблице с данными в реальном времени
* Поиск в распределенной таблице, состоящей из локальных таблиц
* Вызов запроса перколяции
* и другие

По умолчанию установлено количество равное числу ядер CPU на сервере. Manticore создаёт потоки при запуске и держит их до остановки. Каждая подзадача может использовать один из потоков, когда ей это нужно. Когда подзадача завершается, поток освобождается, чтобы другая подзадача могла его использовать.

В случае интенсивной нагрузки типа ввода-вывода может иметь смысл установить значение выше количества ядер CPU.

<!-- request Example -->
```ini
threads = 10
```

<!-- end -->

### thread_stack

<!-- example conf thread_stack -->
Максимальный размер стека для задачи (корутина, один поисковый запрос может вызывать несколько задач/корутин). Необязательно, по умолчанию 128K.

Каждая задача имеет свой собственный стек размером 128K. При выполнении запроса проверяется, сколько стека он требует. Если стандартных 128K достаточно, запрос просто обрабатывается. Если требуется больше, планируется другая задача с увеличенным стеком, которая продолжает обработку. Максимальный размер такого расширенного стека ограничен этой настройкой.

Установка значения на разумно высоком уровне поможет при обработке очень глубоких запросов, не подразумевая чрезмерного роста общего потребления ОЗУ. Например, установка значения в 1G не означает, что каждая новая задача будет занимать 1G ОЗУ, а если мы видим, что требуется, скажем, 100M стека, мы просто выделяем 100M для задачи. Другие задачи в это время будут работать с их стандартным стеком в 128K. Таким же образом можно запускать ещё более сложные запросы, которым нужно 500M. И только если мы **увидим** внутренне, что задаче требуется больше 1G стека, произойдёт ошибка с сообщением о слишком низком `thread_stack`.

Однако на практике даже запрос, который требует 16M стека, часто бывает слишком сложным для парсинга и потребляет слишком много времени и ресурсов для обработки. Так что демон будет его обрабатывать, но ограничение таких запросов настройкой `thread_stack` выглядит вполне разумным.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
thread_stack = 8M
```
<!-- end -->


### unlink_old

<!-- example conf unlink_old -->
Определяет, следует ли удалять копии таблиц с расширением `.old` после успешной ротации. Необязательно, по умолчанию 1 (удалять).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
unlink_old = 0
```
<!-- end -->


### watchdog

<!-- example conf watchdog -->
Поточный watchdog сервера. Необязательно, по умолчанию 1 (watchdog включён).

Когда запрос в Manticore аварийно завершается, он может повлечь за собой падение всего сервера. При включённом watchdog, `searchd` поддерживает отдельный легковесный процесс, который следит за основным серверным процессом и автоматически перезапускает его в случае ненормального завершения. Watchdog включён по умолчанию.

<!-- request Example -->

```ini
watchdog = 0 # disable watchdog
```
<!-- end -->
<!-- proofread -->

