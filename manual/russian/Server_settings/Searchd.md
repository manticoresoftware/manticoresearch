# Раздел "Searchd" в конфигурации

Ниже приведены настройки, которые используются в разделе `searchd` конфигурационного файла Manticore Search для управления поведением сервера. Ниже представлено краткое описание каждой настройки:

### access_plain_attrs

Эта настройка задает глобальные значения по умолчанию для [access_plain_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Является необязательной, значение по умолчанию — `mmap_preread`.

Директива `access_plain_attrs` позволяет определить значение по умолчанию для [access_plain_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Директивы на уровне каждой таблицы имеют более высокий приоритет и переопределяют эти глобальные настройки, обеспечивая более тонкий контроль.

### access_blob_attrs

Эта настройка задает глобальные значения по умолчанию для [access_blob_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Является необязательной, значение по умолчанию — `mmap_preread`.

Директива `access_blob_attrs` позволяет определить значение по умолчанию для [access_blob_attrs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Директивы на уровне каждой таблицы имеют более высокий приоритет и переопределяют эти глобальные настройки, обеспечивая более тонкий контроль.

### access_doclists

Эта настройка задает глобальные значения по умолчанию для [access_doclists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Является необязательной, значение по умолчанию — `file`.

Директива `access_doclists` позволяет определить значение по умолчанию для [access_doclists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Директивы на уровне каждой таблицы имеют более высокий приоритет и переопределяют эти глобальные настройки, обеспечивая более тонкий контроль.

### access_hitlists

Эта настройка задает глобальные значения по умолчанию для [access_hitlists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Является необязательной, значение по умолчанию — `file`.

Директива `access_hitlists` позволяет определить значение по умолчанию для [access_hitlists](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Директивы на уровне каждой таблицы имеют более высокий приоритет и переопределяют эти глобальные настройки, обеспечивая более тонкий контроль.

### access_dict

Эта настройка задает глобальные значения по умолчанию для [access_dict](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files). Является необязательной, значение по умолчанию — `mmap_preread`.

Директива `access_dict` позволяет определить значение по умолчанию для [access_dict](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Accessing-table-files) для всех таблиц, управляемых этим экземпляром searchd. Директивы на уровне каждой таблицы имеют более высокий приоритет и переопределяют эти глобальные настройки, обеспечивая более тонкий контроль.

### agent_connect_timeout

Эта настройка задает глобальные значения по умолчанию для параметра [agent_connect_timeout](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_connect_timeout).


### agent_query_timeout

Эта настройка задает глобальные значения по умолчанию для параметра [agent_query_timeout](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent_query_timeout). Может быть переопределена для каждого запроса с помощью клаузы `OPTION agent_query_timeout=XXX`.


### agent_retry_count

Эта настройка — целое число, указывающее, сколько раз Manticore попытается подключиться и выполнить запрос к удаленным агентам через распределенную таблицу, прежде чем сообщить о фатальной ошибке запроса. Значение по умолчанию — 0 (то есть без повторных попыток). Вы также можете задать это значение для каждого запроса с помощью клаузы `OPTION retry_count=XXX`. Если опция для запроса указана, она переопределит значение, указанное в конфигурации.

Обратите внимание, что если вы используете [зеркала агентов](../Creating_a_cluster/Remote_nodes/Mirroring.md#Agent-mirrors) в определении вашей распределенной таблицы, сервер будет выбирать разные зеркала для каждой попытки подключения согласно выбранной [ha_strategy](../Creating_a_cluster/Remote_nodes/Load_balancing.md#ha_strategy). В этом случае значение `agent_retry_count` будет суммировано для всех зеркал в наборе.

Например, если у вас 10 зеркал и вы установили `agent_retry_count=5`, сервер будет делать до 50 попыток (по 5 для каждого из 10 зеркал в среднем, при опции `ha_strategy = roundrobin` это так и будет).

Однако значение, указанное в опции `retry_count` для [агента](../Creating_a_table/Creating_a_distributed_table/Remote_tables.md#agent), служит абсолютным ограничением. Другими словами, опция `[retry_count=2]` в определении агента всегда означает максимум 2 попытки, независимо от того, указали вы 1 или 10 зеркал для агента.

### agent_retry_delay

Эта настройка — целое число в миллисекундах (или [special_suffixes](../Server_settings/Special_suffixes.md)), указывающее задержку перед повторной попыткой запроса к удаленному агенту в случае ошибки. Это значение актуально только при ненулевом [agent_retry_count](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md) или ненулевом параметре `retry_count` для отдельного запроса. Значение по умолчанию — 500. Вы также можете задать это значение для каждого запроса с помощью клаузы `OPTION retry_delay=XXX`. Если опция для запроса указана, она переопределит значение, указанное в конфигурации.


### attr_flush_period

<!-- example conf attr_flush_period -->
При использовании [Update](../Data_creation_and_modification/Updating_documents/UPDATE.md) для изменения атрибутов документа в режиме реального времени, изменения сначала записываются в копию атрибутов в памяти. Эти обновления происходят в файле с отображением в память, то есть операционная система решает, когда записывать изменения на диск. При нормальном завершении работы `searchd` (инициируемом сигналом `SIGTERM`) все изменения принудительно записываются на диск.

Вы также можете указать `searchd` периодически записывать эти изменения на диск, чтобы избежать потери данных. Интервал между такими сбросами задаётся параметром `attr_flush_period` в секундах (или с использованием [special_suffixes](../Server_settings/Special_suffixes.md)).

По умолчанию значение равно 0, что отключает периодическую запись. Однако сброс всё равно произойдёт при обычном завершении работы.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
attr_flush_period = 900 # persist updates to disk every 15 minutes
```
<!-- end -->

### auto_optimize

<!-- example conf auto_optimize -->
Этот параметр управляет автоматическим процессом [OPTIMIZE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE) для компактирования таблицы.

По умолчанию компактирование таблицы происходит автоматически. Вы можете изменить это поведение с помощью параметра `auto_optimize`:
* 0 для отключения автоматического компактирования таблицы (вы всё ещё можете вызвать `OPTIMIZE` вручную)
* 1 для явного включения
* для включения с умножением порога оптимизации на 2.

По умолчанию OPTIMIZE выполняется до тех пор, пока число файлов на диске не станет меньше или равно числу логических ядер ЦП, умноженному на 2.

Однако, если в таблице есть атрибуты с KNN индексами, порог другой. В этом случае он устанавливается как количество физических ядер ЦП, делённое на 2, чтобы улучшить производительность KNN поиска.

Обратите внимание, что переключение `auto_optimize` в положение вкл/выкл не мешает вам запускать [OPTIMIZE TABLE](../Securing_and_compacting_a_table/Compacting_a_table.md#OPTIMIZE-TABLE) вручную.

<!-- intro -->
##### Пример:

<!-- request Disable -->
```ini
auto_optimize = 0 # disable automatic OPTIMIZE
```

<!-- request Throttle -->
```ini
auto_optimize = 2 # OPTIMIZE starts at 16 chunks (on 4 cpu cores server)
```

<!-- end -->

### auto_schema

<!-- example conf auto_schema -->
Manticore поддерживает автоматическое создание таблиц, которых ещё нет, но которые указаны в запросах INSERT. Эта функция включена по умолчанию. Чтобы отключить её, явно установите в конфигурации `auto_schema = 0`. Для повторного включения установите `auto_schema = 1` или удалите параметр `auto_schema` из конфигурации.

Имейте в виду, что HTTP-эндпоинт `/bulk` не поддерживает автоматическое создание таблиц.

> ПРИМЕЧАНИЕ: Функциональность [auto schema](../Data_creation_and_modification/Adding_documents_to_a_table/Adding_documents_to_a_real-time_table.md#Auto-schema) требует [Manticore Buddy](../Installation/Manticore_Buddy.md). Если она не работает, убедитесь, что Buddy установлен.

<!-- request Disable -->
```ini
auto_schema = 0 # disable automatic table creation
```

<!-- request Enable -->
```ini
auto_schema = 1 # enable automatic table creation
```

<!-- end -->

### binlog_flush

<!-- example conf binlog_flush -->
Этот параметр контролирует режим сброса/синхронизации бинарного лога транзакций. Он опциональный, с значением по умолчанию 2 (сброс каждого транзакционного изменения, синхронизация каждую секунду).

Директива определяет, как часто бинарный лог будет сбрасываться в ОС и синхронизироваться с диском. Поддерживается три режима:

*  0 — сброс и синхронизация каждую секунду. Обеспечивает лучшую производительность, однако при сбое сервера или сбое ОС/оборудования можно потерять до 1 секунды подтвержденных транзакций.
*  1 — сброс и синхронизация после каждой транзакции. Этот режим обеспечит худшую производительность, но гарантирует сохранение данных каждой подтвержденной транзакции.
*  2 — сброс после каждой транзакции, синхронизация каждую секунду. Этот режим обеспечивает хорошую производительность и гарантирует сохранность каждой подтверждённой транзакции при сбое сервера. Однако при сбое ОС/оборудования можно потерять до 1 секунды подтверждённых транзакций.

Для тех, кто знаком с MySQL и InnoDB, эта директива похожа на `innodb_flush_log_at_trx_commit`. В большинстве случаев гибридный режим 2 по умолчанию обеспечивает хороший баланс между скоростью и безопасностью, с полной защитой данных RT-таблиц от сбоев сервера и частичной защитой от сбоев оборудования.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_flush = 1 # ultimate safety, low speed
```
<!-- end -->

### binlog_common

<!-- example conf binlog_common -->
Этот параметр управляет способом управления файлами бинарного лога. Он опциональный, по умолчанию 0 (отдельный файл для каждой таблицы).

Вы можете выбрать один из двух способов управления файлами бинарного лога:

* Отдельный файл для каждой таблицы (по умолчанию, `0`): каждая таблица сохраняет свои изменения в собственном лог-файле. Это хорошо, если у вас много таблиц, обновляемых в разное время. Так таблицы обновляются независимо друг от друга. Также если возникает проблема с лог-файлом одной таблицы, это не влияет на остальные.
* Один файл для всех таблиц (`1`): все таблицы используют один и тот же файл бинарного лога. Это упрощает управление файлами, так как их меньше. Однако это может привести к тому, что файлы будут храниться дольше, чем нужно, если какая-то таблица продолжает сохранять обновления. Такой режим также может замедлить работу, если много таблиц обновляются одновременно, так как все изменения должны ожидать записи в один файл.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_common = 1 # use a single binary log file for all tables
```
<!-- end -->

### binlog_max_log_size

<!-- example conf binlog_max_log_size -->
Этот параметр контролирует максимальный размер файла бинарного лога. Он опциональный, с значением по умолчанию 256 МБ.

Новый файл binlog будет принудительно открыт, как только текущий файл достигнет этого предела. Это обеспечивает более мелкую гранулярность логов и может привести к более эффективному использованию диска для binlog при определённых пограничных нагрузках. Значение 0 означает, что файл binlog не будет повторно открыт по размеру.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_max_log_size = 16M
```
<!-- end -->


### binlog_path

<!-- example conf binlog_path -->
Этот параметр определяет путь к файлам бинарного лога (также известного как журнал транзакций). Он опциональный, по умолчанию установлен в директорию данных, настроенную при сборке (например, `/var/lib/manticore/data/binlog.*` в Linux).

Бинарные логи используются для восстановления данных RT-таблиц после сбоев и для обновления атрибутов простых дисковых индексов, которые в противном случае хранились бы только в оперативной памяти до сброса. Когда ведение логов включено, каждая транзакция, зафиксированная в RT-таблице, записывается в файл журнала. Логи затем автоматически воспроизводятся при запуске после некорректного завершения работы, восстанавливая зафиксированные изменения.

Директива `binlog_path` указывает расположение файлов бинарных логов. Она должна содержать только путь; `searchd` создаст и удалит несколько файлов `binlog.*` в каталоге по мере необходимости (включая данные бинлогов, метаданные и файлы блокировок и т.д.).

Пустое значение отключает бинарное логирование, что улучшает производительность, но подвергает данные RT-таблиц риску.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
binlog_path = # disable logging
binlog_path = /var/lib/manticore/data # /var/lib/manticore/data/binlog.001 etc will be created
```
<!-- end -->


### buddy_path

<!-- example conf buddy_path -->
Этот параметр определяет путь к binary-файлу Manticore Buddy. Он является необязательным, при этом значение по умолчанию — это путь, конфигурируемый во время сборки, который может отличаться в разных операционных системах. Обычно нет необходимости изменять этот параметр. Однако это может быть полезно, если вы хотите запустить Manticore Buddy в режиме отладки, внести изменения в Manticore Buddy или реализовать новый плагин. В последнем случае вы можете клонировать Buddy с https://github.com/manticoresoftware/manticoresearch-buddy, добавить новый плагин в каталог `./plugins/` и выполнить `composer install --prefer-source` для облегчения разработки после перехода в каталог исходников Buddy.

Для возможности запуска `composer` на вашей машине должен быть установлен PHP версии 8.2 или выше с следующими расширениями:

```
--enable-dom
--with-libxml
--enable-tokenizer
--enable-xml
--enable-xmlwriter
--enable-xmlreader
--enable-simplexml
--enable-phar
--enable-bcmath
--with-gmp
--enable-debug
--with-mysqli
--enable-mysqlnd
```

Вы также можете использовать специальную версию `manticore-executor-dev` для Linux amd64, доступную в релизах, например: https://github.com/manticoresoftware/executor/releases/tag/v1.0.13

Если вы пойдёте этим путём, не забудьте создать ссылку на dev-версию исполняемого файла manticore в `/usr/bin/php`.

Чтобы отключить Manticore Buddy, установите значение в пустую строку, как показано в примере.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
buddy_path = manticore-executor -n /usr/share/manticore/modules/manticore-buddy/src/main.php --debug # use the default Manticore Buddy in Linux, but run it in debug mode
buddy_path = manticore-executor -n /opt/homebrew/share/manticore/modules/manticore-buddy/bin/manticore-buddy/src/main.php --debug # use the default Manticore Buddy in MacOS arm64, but run it in debug mode
buddy_path = manticore-executor -n /Users/username/manticoresearch-buddy/src/main.php --debug # use Manticore Buddy from a non-default location
buddy_path = # disables Manticore Buddy
buddy_path = manticore-executor -n /Users/username/manticoresearch-buddy/src/main.php --debugv --skip=manticoresoftware/buddy-plugin-replace # debugv - enables more detailed logging, --skip - skips plugins
```
<!-- end -->

### client_timeout

<!-- example conf client_timeout -->
Этот параметр определяет максимальное время ожидания между запросами (в секундах или с использованием [special_suffixes](../Server_settings/Special_suffixes.md)) при использовании постоянных соединений. Опционально, значение по умолчанию — пять минут.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
client_timeout = 1h
```
<!-- end -->


### collation_libc_locale

<!-- example conf collation_libc_locale -->
Локаль libc сервера. Необязательно, по умолчанию C.

Определяет локаль libc, влияющую на сортировки, основанные на libc. Подробности смотрите в разделе [collations](../Searching/Collations.md).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
collation_libc_locale = fr_FR
```
<!-- end -->


### collation_server

<!-- example conf collation_server -->
Колляция сервера по умолчанию. Необязательно, по умолчанию libc_ci.

Определяет колляцию, используемую для входящих запросов по умолчанию. Колляция может быть переопределена для каждого запроса отдельно. Для списка доступных колляций и других подробностей смотрите раздел [collations](../Searching/Collations.md).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
collation_server = utf8_ci
```
<!-- end -->


### data_dir

<!-- example conf data_dir -->
При указании этот параметр активирует [режим реального времени](../Creating_a_table/Local_tables.md#Online-schema-management-%28RT-mode%29), позволяющий императивно управлять схемой данных. Значение должно быть путём к каталогу, в котором вы хотите хранить все ваши таблицы, бинарные логи и всё остальное, необходимое для нормальной работы Manticore Search в этом режиме.
Индексация [простых таблиц](../Creating_a_table/Local_tables/Plain_table.md) не разрешена, если указан `data_dir`. Подробнее о различиях между режимом RT и простым режимом смотрите в [этом разделе](../Read_this_first.md#Real-time-table-vs-plain-table).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
data_dir = /var/lib/manticore
```
<!-- end -->

### diskchunk_flush_search_timeout

<!-- example conf diskchunk_flush_search_timeout -->
Тайм-аут предотвращения автоматического сброса оперативной памяти, если в таблице нет поисковых запросов. Необязательно, значение по умолчанию 30 секунд.

Время проверки наличия поисков перед решением о необходимости автосброса.
Автоматический сброс будет происходить только если за последние `diskchunk_flush_search_timeout` секунд в таблице был хотя бы один поиск. Работает совместно с [diskchunk_flush_write_timeout](../Server_settings/Searchd.md#diskchunk_flush_write_timeout). Соответствующая [параметр на уровне таблицы](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#diskchunk_flush_search_timeout) имеет более высокий приоритет и переопределит это значение по умолчанию на уровне экземпляра, предоставляя более точный контроль.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
diskchunk_flush_search_timeout = 120s
```
<!-- end -->

### diskchunk_flush_write_timeout

<!-- example conf diskchunk_flush_write_timeout -->
Время в секундах ожидания без записи перед автоматическим сбросом из оперативной памяти на диск. Необязательно, значение по умолчанию 1 секунда.

Если запись в оперативном куске не происходит в течение `diskchunk_flush_write_timeout` секунд, этот кусок будет сброшен на диск. Работает совместно с [diskchunk_flush_search_timeout](../Server_settings/Searchd.md#diskchunk_flush_search_timeout). Чтобы отключить автосброс, явно установите `diskchunk_flush_write_timeout = -1` в вашей конфигурации. Соответствующая [параметр на уровне таблицы](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#diskchunk_flush_write_timeout) имеет более высокий приоритет и переопределит это значение по умолчанию на уровне экземпляра, предоставляя более точный контроль.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
diskchunk_flush_write_timeout = 60s
```
<!-- end -->

### docstore_cache_size

<!-- example conf docstore_cache_size -->
Этот параметр задаёт максимальный размер блоков документов из хранилища документов, удерживаемых в памяти. Необязательно, значение по умолчанию 16m (16 мегабайт).

Когда используется `stored_fields`, блоки документов читаются с диска и распаковываются. Поскольку каждый блок обычно содержит несколько документов, он может быть использован повторно при обработке следующего документа. Для этой цели блок хранится в кэше на уровне сервера. Кэш содержит распакованные блоки.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
docstore_cache_size = 8m
```
<!-- end -->

### engine

<!-- example conf engine -->
Движок хранения атрибутов по умолчанию, используемый при создании таблиц в режиме RT. Может быть `rowwise` (по умолчанию) или `columnar`.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
engine = columnar
```
<!-- end -->


### expansion_limit

<!-- example conf expansion_limit -->
Этот параметр определяет максимальное количество расширенных ключевых слов для одного шаблона с подстановочным знаком. Является необязательным, значение по умолчанию — 0 (без ограничений).

При выполнении поиска подстроки по таблицам, построенным с включённой опцией `dict = keywords`, один подстановочный знак может привести к тысячам или даже миллионам совпадающих ключевых слов (например, при сопоставлении `a*` со всем словарём Оксфорда). Эта директива позволяет ограничить влияние таких расширений. Установка `expansion_limit = N` ограничивает расширения не более чем N наиболее часто встречающимися совпадающими ключевыми словами (для каждого подстановочного знака в запросе).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_limit = 16
```
<!-- end -->

### expansion_merge_threshold_docs

<!-- example conf expansion_merge_threshold_docs -->
Этот параметр определяет максимальное количество документов в расширенном ключевом слове, при котором возможно объединение всех таких ключевых слов вместе. Является необязательным, значение по умолчанию — 32.

При выполнении поиска подстроки по таблицам с включённым `dict = keywords` один подстановочный знак может привести к тысячам или даже миллионам совпадающих ключевых слов. Эта директива позволяет увеличить предел количества ключевых слов, которые будут объединены для ускорения сопоставления, но при этом используется больше памяти во время поиска.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_merge_threshold_docs = 1024
```
<!-- end -->

### expansion_merge_threshold_hits

<!-- example conf expansion_merge_threshold_hits -->
Этот параметр определяет максимальное количество попаданий в расширенном ключевом слове, при котором возможно объединение всех таких ключевых слов вместе. Является необязательным, значение по умолчанию — 256.

При выполнении поиска подстроки по таблицам с включённым `dict = keywords` один подстановочный знак может привести к тысячам или даже миллионам совпадающих ключевых слов. Эта директива позволяет увеличить предел количества ключевых слов, которые будут объединены для ускорения сопоставления, но при этом используется больше памяти во время поиска.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
expansion_merge_threshold_hits = 512
```
<!-- end -->

### grouping_in_utc

Этот параметр указывает, будет ли группировка по времени в API и SQL вычисляться по локальному часовому поясу или по UTC. Является необязательным, значение по умолчанию — 0 (что означает «локальный часовой пояс»).

По умолчанию все выражения «group by time» (например, группировка по дню, неделе, месяцу и году в API, а также группировка по дню, месяцу, году, yearmonth, yearmonthday в SQL) выполняются с использованием локального времени. Например, если у вас есть документы с атрибутами времени `13:00 utc` и `15:00 utc`, при группировке они оба попадут в группы в соответствии с вашим локальным часовым поясом. Если вы находитесь в зоне `utc`, это будет один день, но если вы в `utc+10`, тогда эти документы попадут в разные группировки `group by day` (поскольку 13:00 по utc в часовом поясе UTC+10 — это 23:00 по местному времени, а 15:00 — это 01:00 следующего дня). Иногда такое поведение неприемлемо, и желательно, чтобы группировка по времени не зависела от часового пояса. Вы можете запустить сервер с установленной глобальной переменной среды TZ, но это повлияет не только на группировку, но и на отметки времени в логах, что тоже может быть нежелательным. Включение этой опции (в конфигурации или с помощью оператора [SET global](../Server_settings/Setting_variables_online.md#SET) в SQL) приведёт к тому, что все выражения группировки времени будут вычисляться в UTC, оставляя остальные функции, зависящие от времени (например, логирование сервера), в локальном часовом поясе.


### timezone

Этот параметр указывает часовой пояс, который будет использоваться в функциях, связанных с датой и временем. По умолчанию используется локальный часовой пояс, но вы можете указать другой часовой пояс в формате IANA (например, `Europe/Amsterdam`).

Обратите внимание, что этот параметр не влияет на логирование, которое всегда ведётся в локальном часовом поясе.

Также учтите, что если используется `grouping_in_utc`, функция «group by time» всё равно будет использовать UTC, в то время как другие функции, связанные с датой и временем, будут использовать указанный часовой пояс. В целом, не рекомендуется смешивать `grouping_in_utc` и `timezone`.

Вы можете настроить эту опцию либо в конфигурации, либо с помощью оператора [SET global](../Server_settings/Setting_variables_online.md#SET) в SQL.


### ha_period_karma

<!-- example conf ha_period_karma -->
Этот параметр задаёт размер окна статистики агента-дзеркала в секундах (или с использованием [special_suffixes](../Server_settings/Special_suffixes.md)). Является необязательным, значение по умолчанию — 60 секунд.

Для распределённой таблицы с агентами-дзеркалами (подробнее см. в [agent](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md)) мастер отслеживает несколько различных счётчиков по каждому зеркалу. Эти счётчики используются для переключения отказов и балансировки (мастер выбирает лучшее зеркало на основе этих счётчиков). Счётчики аккумулируются блоками по `ha_period_karma` секунд.

После начала нового блока мастер может использовать накопленные значения из предыдущего блока до тех пор, пока новый блок не будет заполнен наполовину. В результате история предыдущего блока перестаёт влиять на выбор зеркала не позднее чем через 1,5 раза от `ha_period_karma` секунд.

Хотя для выбора зеркала используются не более двух блоков, до 15 последних блоков сохраняются для целей инструментирования. Эти блоки можно просмотреть с помощью оператора [SHOW AGENT STATUS](../Node_info_and_management/Node_status.md#SHOW-AGENT-STATUS).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ha_period_karma = 2m
```
<!-- end -->


### ha_ping_interval

<!-- example conf ha_ping_interval -->
Эта настройка конфигурирует интервал между пингами зеркал агента, в миллисекундах (или [special_suffixes](../Server_settings/Special_suffixes.md)). Она является необязательной, значение по умолчанию — 1000 миллисекунд.

Для распределённой таблицы с агент-зеркалами (см. подробнее в [agent](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md)) мастер во время простоя отправляет всем зеркалам команду ping. Это делается для отслеживания текущего статуса агента (жив он или нет, время сетевого отклика и т. п.). Интервал между такими пингами определяется этой директивой. Чтобы отключить пинги, установите ha_ping_interval в 0.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ha_ping_interval = 3s
```
<!-- end -->


### hostname_lookup

Опция `hostname_lookup` определяет стратегию обновления имён хостов. По умолчанию IP-адреса имён хостов агентов кешируются при запуске сервера, чтобы избежать частого обращения к DNS. Однако в некоторых случаях IP может динамически изменяться (например, в облачном хостинге), и может потребоваться не кешировать IP. Установка этой опции в `request` отключает кеширование и выполняет DNS-запросы при каждом обращении. IP-адреса также можно вручную обновить с помощью команды `FLUSH HOSTNAMES`.

### jobs_queue_size

Настройка jobs_queue_size определяет, сколько "задач" может находиться в очереди одновременно. По умолчанию ограничение отсутствует.

В большинстве случаев "задача" означает один запрос к одной локальной таблице (простая таблица или диск-чанк таблицы с реальным временем обновления). Например, если у вас есть распределённая таблица, состоящая из 2 локальных таблиц или таблица с реальным временем с 2 дисковыми чанками, поиск по любой из них поставит в очередь преимущественно 2 задачи. Затем пул потоков (размер которого определяется настройкой [threads](../Server_settings/Searchd.md#threads)) их обработает. Однако в некоторых случаях, если запрос слишком сложный, может создаваться больше задач. Изменение этой настройки рекомендуется, когда [max_connections](../Server_settings/Searchd.md#max_connections) и [threads](../Server_settings/Searchd.md#threads) недостаточны для достижения нужного баланса производительности.

### join_batch_size

Соединения таблиц работают путем накопления пакета совпадений (matches), которые являются результатами запроса, выполненного к левой таблице. Этот пакет затем обрабатывается как единый запрос к правой таблице.

Эта опция позволяет настроить размер пакета. Значение по умолчанию — `1000`, установка значения `0` отключает пакетную обработку.

Более крупный размер пакета может улучшить производительность; однако для некоторых запросов это может привести к чрезмерному потреблению памяти.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
join_batch_size = 2000
```
<!-- end -->

### join_cache_size

Каждый запрос, выполненный к правой таблице, определяется конкретными условиями JOIN ON, которые определяют набор результатов, получаемых из правой таблицы.

Если уникальных условий JOIN ON немного, повторное использование результатов может быть эффективнее, чем многократное выполнение запросов к правой таблице. Для этого результат сохраняется в кеше.

Эта опция позволяет настроить размер этого кеша. Значение по умолчанию — `20 MB`, установка значения 0 отключает кеширование.

Обратите внимание, что каждый поток поддерживает собственный кеш, поэтому при оценке общего потребления памяти следует учитывать количество потоков, выполняющих запросы.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
join_cache_size = 10M
```
<!-- end -->

### listen_backlog

<!-- example conf listen_backlog -->
Настройка listen_backlog определяет длину очереди TCP listen backlog для входящих соединений. Это особенно важно для сборок на Windows, которые обрабатывают запросы по одному. Когда очередь соединений достигает лимита, новые входящие соединения будут отклонены.
Для небазированных на Windows сборок значение по умолчанию обычно подходит, и необходимость менять эту настройку обычно отсутствует.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
listen_backlog = 20
```
<!-- end -->

### kibana_version_string

<!-- example conf kibana_version_string -->
Строка версии сервера, возвращаемая Kibana или OpenSearch Dashboards. Необязательно — по умолчанию установлено значение `7.6.0`.

Некоторые версии Kibana и OpenSearch Dashboards ожидают, что сервер сообщит конкретный номер версии и могут вести себя по-разному в зависимости от него. Чтобы обходить подобные проблемы, вы можете использовать эту настройку, которая заставляет Manticore сообщать Kibana или OpenSearch Dashboards пользовательскую версию.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
kibana_version_string = 1.2.3
```
<!-- end -->

### listen

<!-- example conf listen -->
Эта настройка позволяет указать IP-адрес и порт или путь Unix-доменного сокета, по которым Manticore будет принимать соединения.

Общий синтаксис для `listen`:

```ini
listen = ( address ":" port | port | path | address ":" port start - port end ) [ ":" protocol [ "_vip" ] [ "_readonly" ] ]
```

Вы можете указать:
* либо IP-адрес (или имя хоста) и номер порта
* либо только номер порта
* либо путь Unix сокета (не поддерживается на Windows)
* либо IP-адрес и диапазон портов

Если указан номер порта, но не указан адрес, `searchd` будет слушать на всех сетевых интерфейсах. Путь Unix сокета определяется ведущим слэшем. Диапазон портов можно задавать только для протокола репликации.

Также можно указать обработчик протокола (listener), который будет использоваться для соединений на этом сокете. Слушатели:

* **Не указан** — Manticore будет принимать соединения на этом порту от:
  - других агентов Manticore (то есть удалённой распределённой таблицы)
  - клиентов через HTTP и HTTPS
  - [Manticore Buddy](https://manticoresearch.com/blog/manticoresearch-buddy-intro/). **Обязательно убедитесь, что у вас есть слушатель такого типа (или `http` слушатель, как указано ниже), чтобы избежать ограничений в функциональности Manticore.**
* `mysql` — протокол MySQL для подключений клиентов MySQL. Обратите внимание:
  - поддерживается также сжатый протокол.
  - Если включён [SSL](../Security/SSL.md#SSL), можно установить защищённое соединение.
* `replication` - протокол репликации, используемый для коммуникации между узлами. Подробнее можно узнать в разделе [replication](../Creating_a_cluster/Setting_up_replication/Setting_up_replication.md). Можно указать несколько слушателей репликации, но они должны слушать на одном и том же IP; различаться могут только порты. При определении слушателя репликации с диапазоном портов (например, `listen = 192.168.0.1:9320-9328:replication`), Manticore не начинает сразу слушать эти порты. Вместо этого он будет выбирать случайные свободные порты из указанного диапазона только при запуске использования репликации. Для корректной работы репликации требуется минимум 2 порта в диапазоне.
* `http` - то же, что и **Не задано**. Manticore будет принимать подключения на этом порту от удалённых агентов и клиентов через HTTP и HTTPS.
* `https` - протокол HTTPS. Manticore будет принимать **только** HTTPS-подключения на этом порту. Подробнее см. в разделе [SSL](../Security/SSL.md).
* `sphinx` - устаревший бинарный протокол. Используется для обслуживания подключений удалённых клиентов [SphinxSE](../Extensions/SphinxSE.md). Некоторые реализации клиентов Sphinx API (например, на Java) требуют явного объявления слушателя.

Добавление суффикса `_vip` к протоколам клиентов (то есть ко всем, кроме `replication`, например, `mysql_vip` или `http_vip` или просто `_vip`) заставляет создавать отдельный поток для подключения, чтобы избежать различных ограничений. Это полезно для обслуживания узла при сильных перегрузках, когда сервер иначе зависал бы или не позволял подключаться по обычному порту.

Суффикс `_readonly` устанавливает для слушателя [режим только для чтения](../Security/Read_only.md) и ограничивает его только приёмом запросов на чтение.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
listen = localhost
listen = localhost:5000 # listen for remote agents (binary API) and http/https requests on port 5000 at localhost
listen = 192.168.0.1:5000 # listen for remote agents (binary API) and http/https requests on port 5000 at 192.168.0.1
listen = /var/run/manticore/manticore.s # listen for binary API requests on unix socket
listen = /var/run/manticore/manticore.s:mysql # listen for mysql requests on unix socket
listen = 9312 # listen for remote agents (binary API) and http/https requests on port 9312 on any interface
listen = localhost:9306:mysql # listen for mysql requests on port 9306 at localhost
listen = localhost:9307:mysql_readonly # listen for mysql requests on port 9307 at localhost and accept only read queries
listen = 127.0.0.1:9308:http # listen for http requests as well as connections from remote agents (and binary API) on port 9308 at localhost
listen = 192.168.0.1:9320-9328:replication # listen for replication connections on ports 9320-9328 at 192.168.0.1
listen = 127.0.0.1:9443:https # listen for https requests (not http) on port 9443 at 127.0.0.1
listen = 127.0.0.1:9312:sphinx # listen for legacy Sphinx requests (e.g. from SphinxSE) on port 9312 at 127.0.0.1
```
<!-- end -->

Может быть несколько директив `listen`. `searchd` будет слушать клиентские подключения на всех указанных портах и сокетах. Стандартная конфигурация, поставляемая в пакетах Manticore, определяет прослушивание на портах:
* `9308` и `9312` для подключений от удалённых агентов и клиентов, не основанных на MySQL
* и на порту `9306` для MySQL-подключений.

Если в конфигурации вообще не указать `listen`, Manticore будет ждать подключения на:
* `127.0.0.1:9306` для клиентов MySQL
* `127.0.0.1:9312` для HTTP/HTTPS и подключений от других узлов Manticore и клиентов, использующих бинарный API Manticore.

#### Прослушивание привилегированных портов

По умолчанию Linux не позволит Manticore слушать порт ниже 1024 (например, `listen = 127.0.0.1:80:http` или `listen = 127.0.0.1:443:https`), если `searchd` не запущен с правами root. Если вы всё же хотите запускать Manticore под непользовательским root, чтобы слушать порты ниже 1024, рассмотрите один из вариантов (любой из них должен сработать):
* Выполните команду `setcap CAP_NET_BIND_SERVICE=+eip /usr/bin/searchd`
* Добавьте `AmbientCapabilities=CAP_NET_BIND_SERVICE` в systemd-юнит Manticore и перезагрузите демон (`systemctl daemon-reload`).

#### Технические детали протокола Sphinx API и TFO
<details>
Устаревший протокол Sphinx имеет 2 фазы: обмен рукопожатием и передачу данных. Рукопожатие состоит из 4-байтового пакета от клиента и 4-байтового пакета от демона, цель которого — клиент удостоверяется, что удалённый узел — настоящий демон Sphinx, а демон удостоверяется, что удалённый клиент — настоящий клиент Sphinx. Основной поток данных довольно прост: обе стороны обмениваются рукопожатиями, а противоположная сторона проверяет их. Этот обмен короткими пакетами подразумевает использование специального флага `TCP_NODELAY`, который отключает алгоритм Nagle TCP и сообщает, что TCP-соединение будет вестись диалогом из маленьких пакетов.
Однако не строго определено, кто должен говорить первым в этом переговоре. Исторически все клиенты, использующие бинарный API, говорят первыми: посылают рукопожатие, затем читают 4 байта от демона, затем отправляют запрос и читают ответ от демона.
При улучшении совместимости протокола Sphinx мы учли следующее:

1. Обычно связь master-agent устанавливается от известного клиента к известному хосту на известном порту. Поэтому маловероятно, что конечная точка предоставит неправильное рукопожатие. Можно предположить, что обе стороны валидны и действительно используют протокол Sphinx.
2. Исходя из этого, мы можем «склеить» рукопожатие с реальным запросом и отправить одним пакетом. Если бэкенд — устаревший демон Sphinx, он просто прочитает этот склеенный пакет как 4 байта рукопожатия, затем тело запроса. Поскольку они пришли одним пакетом, на стороне бэкенда сокет теряет один RTT, а буфер клиента продолжает работать как обычно.
3. Продолжая предположение: так как пакет 'query' достаточно мал, а рукопожатие ещё меньше, отправим оба в начальном TCP-пакете 'SYN' с использованием техники TFO (tcp-fast-open). То есть: мы подключаемся к удалённому узлу с пакетом рукопожатия + тела, склеенным вместе. Демон принимает соединение и сразу получает рукопожатие и тело запроса в буфере сокета, так как они пришли в первом TCP-пакете 'SYN'. Это устраняет ещё один RTT.
4. Наконец, нужно обучить демон принимать такое улучшение. С точки зрения приложения это означает НЕ использовать `TCP_NODELAY`. С системной стороны — обеспечить, чтобы на стороне демона было включено принятие TFO, а на клиентской стороне — отправка TFO. По умолчанию в современных системах клиентский TFO уже включен, поэтому нужно настроить только серверный TFO, чтобы всё работало.

Все эти улучшения, не меняя сам протокол, позволили убрать 1.5 RTT из TCP-соединения. Если запрос и ответ помещаются в один TCP-пакет, это сокращает всю сессию бинарного API с 3.5 RTT до 2 RTT — что делает сетевой обмен примерно в 2 раза быстрее.

Итак, все наши улучшения построены вокруг изначально не определенного утверждения: «кто говорит первым». Если первым говорит клиент, мы можем применить все эти оптимизации и эффективно обработать connect + handshake + query в одном пакете TFO. Более того, мы можем посмотреть в начало полученного пакета и определить реальный протокол. Вот почему вы можете подключаться к одному и тому же порту через API/http/https. Если первому говорить должен демон, все эти оптимизации невозможны, и мультипротокол тоже невозможен. Поэтому у нас есть выделенный порт для MySQL, и мы не объединили его со всеми другими протоколами в один порт. Внезапно среди всех клиентов был написан один, подразумевающий, что демон должен сначала отправить handshake. Это означает отсутствие возможности для всех описанных улучшений. Это плагин SphinxSE для mysql/mariadb. Поэтому специально для этого единственного клиента мы выделили `sphinx` определение протокола, чтобы работать максимально наследуемым способом. А именно: обе стороны активируют `TCP_NODELAY` и обмениваются малыми пакетами. Демон отправляет handshake при подключении, затем клиент отправляет свой, и дальше всё работает обычным способом. Это не очень оптимально, но просто работает. Если вы используете SphinxSE для подключения к Manticore — вам нужно выделить слушатель с явно указанным протоколом `sphinx`. Для других клиентов избегайте использования этого слушателя, так как он работает медленнее. Если вы используете других клиентов с наследуемым Sphinx API — сначала проверьте, могут ли они работать с невыделенным мультипротокольным портом. Для связи мастер-агент через невыделенный (мультипротокольный) порт и с включённым TFO для клиента и сервера всё работает хорошо и обязательно ускорит работу сетевой подсистемы, особенно если у вас очень лёгкие и быстрые запросы.
</details>

### listen_tfo

Этот параметр позволяет включить флаг TCP_FASTOPEN для всех слушателей. По умолчанию он управляется системой, но может быть явно отключен установкой значения '0'.

Для общего понимания расширения TCP Fast Open, пожалуйста, обратитесь к [Wikipedia](https://en.wikipedia.org/wiki/TCP_Fast_Open). Кратко: оно позволяет устранить один круговой обход TCP при установлении соединения.

На практике использование TFO во многих случаях может оптимизировать сетевую эффективность клиент-агент, как если бы использовались [постоянные агенты](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md), но без удержания активных соединений, а также без ограничения максимального количества соединений.

На современных ОС поддержка TFO обычно включена на уровне системы, но это лишь «возможность», а не правило. Linux (как самая прогрессивная) поддерживает её с 2011 года, начиная с ядер 3.7 (для стороны сервера). Windows поддерживает её с некоторых сборок Windows 10. Другие ОС (FreeBSD, MacOS) тоже поддерживают.

Для серверов на Linux проверяется переменная `/proc/sys/net/ipv4/tcp_fastopen` и ведет себя в соответствии с ней. Бит 0 управляет клиентской стороной, бит 1 – слушателями. По умолчанию система установлена в 1, т.е. клиенты включены, слушатели – выключены.

### log

<!-- example conf log -->
Параметр log задаёт имя файла журнала, в который будут записаны все события выполнения `searchd`. Если не указано, используется имя по умолчанию 'searchd.log'.

В качестве альтернативы можно использовать 'syslog' в качестве имени файла. В этом случае события будут отправляться демону syslog. Чтобы использовать опцию syslog, нужно скомпилировать Manticore с параметром `--with-syslog`.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
log = /var/log/searchd.log
```
<!-- end -->


### max_batch_queries

<!-- example conf max_batch_queries -->
Ограничивает количество запросов в одном пакете. Необязательно, по умолчанию 32.

Заставляет searchd выполнять проверку разумности количества запросов, переданных в одном пакете при использовании [мультизапросов](../Searching/Multi-queries.md). Установите 0, чтобы отключить проверку.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_batch_queries = 256
```
<!-- end -->

### max_connections

<!-- example max_connections -->
Максимальное количество одновременных клиентских соединений. По умолчанию неограничено. Обычно становится заметным только при использовании каких-либо устойчивых соединений, таких как cli mysql сессии или устойчивые удалённые соединения из удалённых распределённых таблиц. Если лимит превышен, вы всё равно можете подключиться к серверу используя [VIP соединение](../Connecting_to_the_server/MySQL_protocol.md#VIP-connection). VIP-соединения не учитываются в лимит.

<!-- request Example -->
```ini
max_connections = 10
```

<!-- end -->

### max_threads_per_query

<!-- example max_threads_per_query -->
Ограничение количества потоков для одной операции на уровне всего экземпляра. По умолчанию соответствующие операции могут занимать все ядра ЦП, не оставляя места для других операций. Например, `call pq` по достаточно большой percolate-таблице может использовать все потоки на десятки секунд. Установка `max_threads_per_query` в, скажем, половину от [threads](../Server_settings/Searchd.md#threads) обеспечит возможность запуска пары таких `call pq` параллельно.

Также можно установить этот параметр как переменную сессии или глобально во время работы.

Кроме того, можно управлять поведением для каждого запроса отдельно с помощью опции [threads OPTION](../Searching/Options.md#threads).

<!-- intro -->
##### Пример:
<!-- request Example -->

```ini
max_threads_per_query = 4
```

<!-- end -->

### max_filters

<!-- example conf max_filters -->
Максимально допустимое количество фильтров на запрос. Этот параметр используется только для внутренних проверок и непосредственно не влияет на использование оперативной памяти или производительность. Необязательно, по умолчанию 256.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_filters = 1024
```
<!-- end -->


### max_filter_values

<!-- example conf max_filter_values -->
Максимально допустимое количество значений на фильтр. Этот параметр используется только для внутренних проверок и непосредственно не влияет на использование оперативной памяти или производительность. Необязательно, по умолчанию 4096.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_filter_values = 16384
```
<!-- end -->


### max_open_files

<!-- example conf max_open_files -->
Максимальное количество файлов, которые сервер может открыть, называется «мягким лимитом». Обратите внимание, что для обслуживания больших фрагментированных таблиц реального времени этот лимит может потребоваться установить на высоком уровне, так как каждый дисковый кусок может занимать дюжину или более файлов. Например, таблица реального времени с 1000 кусками может потребовать одновременного открытия тысяч файлов. Если в логах возникает ошибка «Too many open files», попробуйте настроить эту опцию — это может помочь решить проблему.

Существует также «жёсткий лимит», который нельзя превысить с помощью параметра. Этот лимит задаётся системой и может быть изменён в файле `/etc/security/limits.conf` на Linux. В других операционных системах могут применяться другие подходы, поэтому ознакомьтесь с документацией для получения дополнительной информации.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_open_files = 10000
```
<!-- end -->

<!-- example conf max_open_files max -->
Кроме прямых числовых значений, можно использовать магическое слово «max», чтобы установить лимит равным текущему доступному жёсткому лимиту.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_open_files = max
```
<!-- end -->


### max_packet_size

<!-- example conf max_packet_size -->
Максимально допустимый размер сетевого пакета. Эта настройка ограничивает как пакеты запросов от клиентов, так и пакеты ответов от удалённых агентов в распределённой среде. Используется только для внутренних проверок целостности, не влияет напрямую на использование ОЗУ или производительность. Необязательно, по умолчанию 128M.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
max_packet_size = 32M
```
<!-- end -->


### mysql_version_string

<!-- example conf mysql_version_string -->
Строка версии сервера, которая возвращается через протокол MySQL. Необязательно, по умолчанию пусто (возвращается версия Manticore).

Некоторые придирчивые библиотеки клиентов MySQL зависят от определённого формата номера версии, используемого MySQL, и более того, иногда выбирают другой путь выполнения на основе указанного номера версии (а не флагов возможностей). Например, Python MySQLdb 1.2.2 вызывает исключение, если номер версии не в формате X.Y.ZZ; MySQL .NET connector 6.3.x внутренне не работает с номерами версий 1.x вместе с определённой комбинацией флагов и т.п. Чтобы обойти это, вы можете использовать директиву `mysql_version_string` и заставить `searchd` передавать клиентам по протоколу MySQL другой номер версии. (По умолчанию он сообщает свою собственную версию.)


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
mysql_version_string = 5.0.37
```
<!-- end -->


### net_workers

Количество сетевых потоков, значение по умолчанию — 1.

Эта настройка полезна при экстремально высокой частоте запросов, когда одного потока недостаточно для управления всеми входящими запросами.


### net_wait_tm

Управляет интервалом цикла ожидания сетевого потока. Значение по умолчанию — -1, можно задать -1, 0 или положительное целое число.

Если сервер настроен как чистый мастер и только маршрутизирует запросы агенты, важно обрабатывать запросы без задержек и не позволять сетевому потоку переходить в спящий режим. Для этого используется цикл ожидания. После входящего запроса сетевой поток использует CPU-поллинг в течение `10 * net_wait_tm` миллисекунд, если `net_wait_tm` положительно, или выполняет только CPU-поллинг, если `net_wait_tm` равно `0`. Также цикл ожидания можно отключить, задав `net_wait_tm = -1` — в этом случае poller устанавливает таймауты, соответствующие фактическим таймаутам агента при системных вызовах опроса.

> **ВНИМАНИЕ:** Цикл занятости CPU фактически нагружает ядро процессора, поэтому установка этого значения в любое значение, отличное от стандартного, приведёт к заметному использованию CPU даже при бездействии сервера.


### net_throttle_accept

Определяет, сколько клиентов принимается на каждой итерации сетевого цикла. По умолчанию 0 (без ограничений), что подходит для большинства пользователей. Опция тонкой настройки для управления пропускной способностью сетевого цикла при высокой нагрузке.


### net_throttle_action

Определяет, сколько запросов обрабатывается на каждой итерации сетевого цикла. По умолчанию 0 (без ограничений), что подходит для большинства пользователей. Опция тонкой настройки для управления пропускной способностью сетевого цикла при высокой нагрузке.

### network_timeout

<!-- example conf network_timeout -->
Таймаут чтения/записи клиентского сетевого запроса, в секундах (или [special_suffixes](../Server_settings/Special_suffixes.md)). Необязательно, по умолчанию 5 секунд. `searchd` принудительно закроет соединение с клиентом, если тот не отправит запрос или не получит результат в течение этого таймаута.

Обратите внимание также на параметр [reset_network_timeout_on_packet](../Server_settings/Searchd.md#reset_network_timeout_on_packet). Этот параметр изменяет поведение `network_timeout` с применения на весь `query` или `result` на индивидуальные пакеты. Обычно запрос/результат помещается в один или два пакета. Однако в случаях, когда требуется большое количество данных, этот параметр может быть очень полезен для поддержания активных операций.

<!-- request Example -->

```ini
network_timeout = 10s
```
<!-- end -->

### node_address

<!-- example conf node_address -->
Эта настройка позволяет указать сетевой адрес узла. По умолчанию установлен адрес репликации [listen](../Server_settings/Searchd.md#listen). Это корректно в большинстве случаев; однако бывают ситуации, когда его нужно задавать вручную:

* Узел за брандмауэром
* Включён трансляция сетевых адресов (NAT)
* Развёртывание в контейнерах, таких как Docker или облачные развертывания
* Кластеры с узлами в нескольких регионах


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
node_address = 10.101.0.10
```
<!-- end -->

### not_terms_only_allowed

<!-- example conf not_terms_only_allowed -->
Эта настройка определяет, разрешать ли запросы только с оператором полного текста [отрицания](../Searching/Full_text_matching/Operators.md#Negation-operator). Необязательно, по умолчанию 0 (запрещать запросы, содержащие только оператор NOT).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
not_terms_only_allowed = 1
```
<!-- end -->

### optimize_cutoff

<!-- example conf optimize_cutoff -->
Устанавливает порог слияния таблицы по умолчанию. Подробнее читайте здесь - [Number of optimized disk chunks](../Securing_and_compacting_a_table/Compacting_a_table.md#Number-of-optimized-disk-chunks). Этот параметр можно переопределить с помощью опции для отдельного запроса [cutoff](../Securing_and_compacting_a_table/Compacting_a_table.md#Number-of-optimized-disk-chunks). Его также можно изменить динамически через [SET GLOBAL](../Server_settings/Setting_variables_online.md#SET).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
optimize_cutoff = 4
```
<!-- end -->

### persistent_connections_limit

<!-- example conf persistent_connections_limit -->
Этот параметр определяет максимальное количество одновременных постоянных соединений с удалёнными [persistent agents](../Creating_a_table/Creating_a_distributed_table/Creating_a_local_distributed_table.md). Каждый раз при подключении агента, определённого под `agent_persistent`, мы пытаемся повторно использовать существующее соединение (если оно есть), или подключиться и сохранить соединение для будущего использования. Однако в некоторых случаях имеет смысл ограничить количество таких постоянных соединений. Эта директива задаёт такое ограничение. Она влияет на количество соединений к хосту каждого агента по всем распределённым таблицам.

Рекомендуется установить значение, равное или меньшее, чем значение опции [max_connections](../Server_settings/Searchd.md#max_connections) в конфигурации агента.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
persistent_connections_limit = 29 # assume that each host of agents has max_connections = 30 (or 29).
```
<!-- end -->


### pid_file

<!-- example conf pid_file -->
pid_file — обязательный параметр конфигурации в Manticore search, который указывает путь к файлу, где хранится идентификатор процесса сервера `searchd`.

Файл с идентификатором процесса searchd создаётся заново и блокируется при запуске, и содержит PID главного процесса сервера, пока сервер работает. Файл удаляется при завершении работы сервера.
Назначение этого файла — позволить Manticore выполнять различные внутренние задачи, такие как проверка, запущен ли уже экземпляр `searchd`, остановка `searchd` и уведомление о необходимости провести ротацию таблиц. Файл также может использоваться внешними автоматизированными скриптами.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
pid_file = /var/run/manticore/searchd.pid
```
<!-- end -->


### predicted_time_costs

<!-- example conf predicted_time_costs -->
Затраты для модели предсказания времени выполнения запроса в наносекундах. Опционально, по умолчанию `doc=64, hit=48, skip=2048, match=64`.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
predicted_time_costs = doc=128, hit=96, skip=4096, match=128
```
<!-- end -->

<!-- example conf predicted_time_costs 1 -->
Прерывание запросов до их завершения на основе времени выполнения (с помощью настройки максимального времени запроса) — это хорошая страховка, но с этим связана внутренняя проблема: неопределённые (нестабильные) результаты. То есть если вы несколько раз подряд выполните один и тот же (сложный) поисковый запрос с ограничением по времени, оно будет достигаться на разных этапах, и вы получите *разные* наборы результатов.

<!-- intro -->
##### SQL:

<!-- request SQL -->

```sql
SELECT … OPTION max_query_time
```
<!-- request API -->

```api
SetMaxQueryTime()
```
<!-- end -->

Есть новая опция, [SELECT … OPTION max_predicted_time](../Searching/Options.md#max_predicted_time), которая позволяет ограничить время выполнения запроса *и* получать устойчивые, повторяемые результаты. Вместо регулярной проверки текущего реального времени во время оценки запроса, что даёт неопределённость, она предсказывает текущее время выполнения с помощью простой линейной модели:

```ini
predicted_time =
    doc_cost * processed_documents +
    hit_cost * processed_hits +
    skip_cost * skiplist_jumps +
    match_cost * found_matches
```

Запрос прерывается заранее, когда `predicted_time` достигает определённого лимита.

Конечно, это не жёсткое ограничение на реальное потраченное время (хотя это жёсткий лимит по объёму *обработанной* работы), а простая линейная модель вовсе не является идеально точной. Поэтому фактическое время по часам *может* как быть ниже, так и превышать целевое ограничение. Однако погрешности весьма приемлемые: например, в наших экспериментах с целевым лимитом 100 мс большинство тестовых запросов укладывались в диапазон 95-105 мс, а *все* запросы — в диапазон 80-120 мс. Кроме того, приятным побочным эффектом использования моделированного времени запроса вместо измерения фактического времени выполнения стало некоторое снижение количества вызовов gettimeofday().

Нет двух одинаковых моделей серверов, поэтому директива `predicted_time_costs` позволяет настроить затраты для указанной выше модели. Для удобства они заданы целочисленными, в наносекундах. (Лимит в max_predicted_time считается в миллисекундах, и указывать значения затрат как 0.000128 мс вместо 128 нс более подвержено ошибкам.) Не обязательно указывать все четыре значения сразу, пропущенные примут значения по умолчанию. Однако настоятельно рекомендуется задать их все для читаемости.


### preopen_tables

<!-- example conf preopen_tables -->
Директива конфигурации preopen_tables определяет, будет ли принудительно предварительно открываться все таблицы при запуске. Значение по умолчанию — 1, что означает, что все таблицы будут предварительно открыты независимо от настройки [preopen](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#Other-performance-related-settings) для каждой таблицы. Если установить 0, будут действовать настройки для каждой таблицы, которые по умолчанию равны 0.

Предварительное открытие таблиц может предотвратить гонки между поисковыми запросами и ротациями, которые могут время от времени приводить к сбоям запросов. Однако это увеличивает количество используемых дескрипторов файлов. В большинстве случаев рекомендуется использовать предварительное открытие таблиц.

Пример конфигурации:

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
preopen_tables = 1
```
<!-- end -->

### pseudo_sharding

<!-- example conf pseudo_sharding -->
Опция конфигурации pseudo_sharding включает параллелизацию поисковых запросов к локальным plain и real-time таблицам, вне зависимости от того, запрашиваются ли они напрямую или через распределённую таблицу. Эта функция автоматически параллелит запросы до количества потоков, указанного в параметре `searchd.threads`.

Обратите внимание, что если ваши рабочие потоки уже заняты, потому что у вас:
* высокая конкуренция запросов
* физическое шардирование любого типа:
  - распределённая таблица из нескольких plain/real-time таблиц
  - real-time таблица, состоящая из слишком большого числа дисковых чанков

тогда включение pseudo_sharding может не дать никаких преимуществ и даже привести к небольшому снижению пропускной способности. Если вы отдаёте приоритет более высокой пропускной способности, а не более низкой задержке, рекомендуется отключить эту опцию.

Включено по умолчанию.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
pseudo_sharding = 0
```
<!-- end -->


### replication_connect_timeout

Директива `replication_connect_timeout` определяет тайм-аут на подключение к удалённому узлу. По умолчанию значение предполагается в миллисекундах, но может иметь [другой суффикс](../Server_settings/Special_suffixes.md). Значение по умолчанию — 1000 (1 секунда).

При подключении к удалённому узлу Manticore будет ждать максимум указанное количество времени для успешного установления соединения. Если тайм-аут достигнут, но соединение не установлено, и `retries` включены, будет выполнена попытка повторного подключения.


### replication_query_timeout

Параметр `replication_query_timeout` задаёт время, в течение которого searchd будет ждать удалённый узел для завершения запроса. Значение по умолчанию — 3000 миллисекунд (3 секунды), но может иметь `суффикс`, обозначающий другую единицу времени.

После установления соединения Manticore будет ждать максимум `replication_query_timeout` для завершения удалённым узлом. Обратите внимание, что этот тайм-аут отдельный от `replication_connect_timeout`, и общая возможная задержка со стороны удалённого узла будет суммой обоих значений.


### replication_retry_count

Этот параметр — целое число, указывающее, сколько раз Manticore будет пытаться подключиться и выполнить запрос к удалённому узлу во время репликации перед тем, как сообщить о фатальной ошибке запроса. Значение по умолчанию — 3.


### replication_retry_delay

Этот параметр — целое число в миллисекундах (или [special_suffixes](../Server_settings/Special_suffixes.md)), задающее задержку перед повторной попыткой запроса к удалённому узлу при неудаче во время репликации. Значение актуально только если задано отличное от нуля. Значение по умолчанию — 500.

### qcache_max_bytes

<!-- example conf qcache_max_bytes -->
Эта настройка задаёт максимальное количество ОЗУ, выделяемое под кэшированные наборы результатов в байтах. Значение по умолчанию — 16777216, что соответствует 16 мегабайтам. Если значение установлено в 0, кэш запросов отключён. Для более подробной информации о кэше запросов обратитесь к [query cache](../Searching/Query_cache.md).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
qcache_max_bytes = 16777216
```
<!-- end -->


### qcache_thresh_msec

Целое число в миллисекундах. Минимальный порог времени выполнения запроса для его кэширования. По умолчанию 3000 (3 секунды). Значение 0 означает кэшировать всё. Подробнее смотрите в [query cache](../Searching/Query_cache.md). Это значение также может быть выражено с использованием временных [special_suffixes](../Server_settings/Special_suffixes.md), однако используйте это осторожно и не путайте с названием параметра, содержащим '_msec'.


### qcache_ttl_sec

Целое число в секундах. Период хранения кэшированного набора результатов. По умолчанию 60 (1 минута). Минимальное значение — 1 секунда. Подробнее смотрите в [query cache](../Searching/Query_cache.md). Значение также может выражаться с помощью временных [special_suffixes](../Server_settings/Special_suffixes.md), но пользуйтесь этим осторожно, не путая с названием параметра, содержащим '_sec'.


### query_log_format

<!-- example conf query_log_format -->
Формат лога запросов. Опционально, допустимые значения — `plain` и `sphinxql`, по умолчанию `sphinxql`.

Режим `sphinxql` записывает валидные SQL-запросы. Режим `plain` логирует запросы в виде простого текста (в основном подходит для полнотекстовых случаев). Эта директива позволяет переключаться между двумя форматами при запуске поискового сервера. Формат также можно менять «на лету» с помощью синтаксиса `SET GLOBAL query_log_format=sphinxql`. Подробнее — [Query logging](../Logging/Query_logging.md).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
query_log_format = sphinxql
```
<!-- end -->

### query_log_min_msec

Порог (в миллисекундах), ниже которого запрос не будет записан в лог запросов. Опционально, значение по умолчанию 0 (все запросы записываются). Эта директива указывает, что в лог попадут только запросы, время выполнения которых превышает заданный порог (значение также может выражаться при помощи временных [special_suffixes](../Server_settings/Special_suffixes.md), но используйте с осторожностью и не путайте с названием параметра, содержащим `_msec`).

### query_log

<!-- example conf query_log -->
Имя файла лога запросов. Опционально, по умолчанию пустое (запись запросов не ведется). Все поисковые запросы (например, SELECT ..., но не INSERT/REPLACE/UPDATE) будут записываться в этот файл. Формат описан в [Query logging](../Logging/Query_logging.md). В режиме 'plain' можно указать 'syslog' как путь к файлу лога. В этом случае все поисковые запросы будут отправляться в syslog-демон c приоритетом `LOG_INFO`, с префиксом '[query]' вместо временной метки. Для использования опции syslog Manticore должен быть собран с опцией `-–with-syslog`.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
query_log = /var/log/query.log
```
<!-- end -->


### query_log_mode

<!-- example conf query_log_mode -->
Директива query_log_mode позволяет задать различные права доступа для файлов searchd и query логов. По умолчанию эти файлы создаются с правами 600, что означает, что читать их могут только пользователь, под которым запущен сервер, и root-пользователи.
Эта директива будет полезна, если вы хотите разрешить другим пользователям читать логи, например, решениям мониторинга, работающим под не-root пользователями.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
query_log_mode  = 666
```
<!-- end -->

### read_buffer_docs

<!-- example conf read_buffer_docs -->
Директива read_buffer_docs управляет размером буфера чтения по ключевым словам для списков документов. Для каждого вхождения ключевого слова в каждом поисковом запросе существует два связанных буфера чтения: один для списка документов и один для списка попаданий (hits). Эта настройка позволяет контролировать размер буфера для списка документов.

Больший размер буфера может увеличить использование ОЗУ на запрос, но при этом, возможно, сократит время ввода-вывода. Имеет смысл устанавливать большие значения для медленных хранилищ, а для хранилищ с высокой производительностью IOPS лучше экспериментировать с малым значением.

Значение по умолчанию — 256K, минимальное значение — 8K. Также можно задать [read_buffer_docs](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#read_buffer_docs) для каждой таблицы отдельно, что переопределит настройку на уровне конфигурации сервера.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
read_buffer_docs = 128K
```
<!-- end -->


### read_buffer_hits

<!-- example conf read_buffer_hits -->
Директива read_buffer_hits задаёт размер буфера чтения на ключевое слово для списков попаданий в поисковых запросах. По умолчанию размер равен 256K, минимальное значение — 8K. Для каждого вхождения ключевого слова в поисковом запросе имеется два связанных буфера чтения: один для списка документов и один для списка попаданий. Увеличение размера буфера может повысить использование ОЗУ на запрос, но сократить время ввода-вывода. Для медленных хранилищ разумно применять большие размеры буфера, для хранилищ с высокой производительностью IOPS рекомендуется экспериментировать с малыми значениями.

Эта настройка может быть также указана на уровне отдельной таблицы с помощью опции read_buffer_hits в [read_buffer_hits](../Creating_a_table/Local_tables/Plain_and_real-time_table_settings.md#read_buffer_hits), что переопределит серверную настройку.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
read_buffer_hits = 128K
```
<!-- end -->

### read_unhinted

<!-- example conf read_unhinted -->
Размер неопределённого чтения. Опционально, по умолчанию 32K, минимальное значение 1K

При выполнении запроса некоторые чтения заранее знают точный размер данных для чтения, но некоторые пока нет. Особенно это касается размера списка попаданий, который в данный момент не известен заранее. Эта настройка позволяет управлять объёмом данных для чтения в таких случаях. Она влияет на время ввода-вывода списка попаданий, уменьшая его для списков, превышающих размер неопределённого чтения, и увеличивая для меньших списков. Это **не** влияет на использование ОЗУ, так как буфер чтения уже выделен. Поэтому значение не должно быть больше, чем read_buffer.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
read_unhinted = 32K
```
<!-- end -->

### reset_network_timeout_on_packet

<!-- example conf reset_network_timeout_on_packet -->
Уточняет поведение таймаутов сети (например, `network_timeout`, `read_timeout` и `agent_query_timeout`).

При значении 0 таймауты ограничивают максимальное время на отправку всего запроса/запроса.
При значении 1 (по умолчанию) таймауты ограничивают максимальное время между сетевой активностью.

При репликации узлу может потребоваться отправить большой файл (например, 100ГБ) другому узлу. Предположим, что сеть передает данные со скоростью 1ГБ/с, пакетами по 4-5МБ. Для передачи всего файла понадобится 100 секунд. Таймаут по умолчанию в 5 секунд позволит передать только 5ГБ, после чего соединение будет сброшено. Увеличение таймаута может быть временным решением, но оно не масштабируется (например, следующий файл может быть 150ГБ, что снова приведёт к сбою). При включённом параметре `reset_network_timeout_on_packet` в 1 таймаут применяется не ко всей передаче, а к отдельным пакетам. Пока передача продолжается (и данные действительно принимаются в течение таймаута), соединение сохраняется. Если передача зависает и возникает таймаут между пакетами, соединение разрывается.

Обратите внимание, что для распределённой таблицы следует настраивать все узлы — и мастер, и агенты. На стороне мастера влияет `agent_query_timeout`, на агентах — `network_timeout`.

<!-- intro -->

##### Пример:

<!-- request Example -->

```ini
reset_network_timeout_on_packet = 0
```

<!-- end -->


### rt_flush_period

<!-- example conf rt_flush_period -->
Период проверки сброса чанков ОЗУ для RT таблиц, в секундах (или с использованием [special_suffixes](../Server_settings/Special_suffixes.md)). Опционально, значение по умолчанию — 10 часов.

Активно обновляемые RT таблицы, полностью помещающиеся в чанках ОЗУ, тем не менее могут приводить к бесконечному росту бинарных логов, что влияет на использование диска и время восстановления после сбоя. С помощью этой директивы сервер поиска периодически проверяет возможность сброса, и подходящие чанки ОЗУ могут быть сохранены, что позволяет позднее очистить бинарные логи. Подробнее см. [Binary logging](../Logging/Binary_logging.md).

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
rt_flush_period = 3600 # 1 hour
```
<!-- end -->


### rt_merge_iops

<!-- example conf rt_merge_iops -->
Максимальное количество операций ввода-вывода (в секунду), которые поток слияния чанков RT может начать. Опционально, по умолчанию 0 (без ограничений).

Эта директива позволяет ограничивать нагрузку на ввод-вывод от операторов `OPTIMIZE`. Гарантируется, что все операции оптимизации RT не вызовут превышения настроенного лимита по дисковым IOPS. Ограничение rt_merge_iops может снизить деградацию производительности поиска, вызванную слиянием.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
rt_merge_iops = 40
```
<!-- end -->

### rt_merge_maxiosize

<!-- example conf rt_merge_maxiosize -->
Максимальный размер операции ввода-вывода, которую поток слияния чанков RT может начать. Опционально, по умолчанию 0 (без ограничений).

Эта директива позволяет ограничивать нагрузку на ввод-вывод от операторов `OPTIMIZE`. Операции ввода-вывода, превышающие этот размер, будут разбиты на две или более операций, которые будут учитываться отдельно в пределах лимита [rt_merge_iops](../Server_settings/Searchd.md#rt_merge_iops). Таким образом, гарантируется, что все операции оптимизации не вызовут более (rt_merge_iops * rt_merge_maxiosize) байт дискового ввода-вывода в секунду.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
rt_merge_maxiosize = 1M
```
<!-- end -->


### seamless_rotate

<!-- example conf seamless_rotate -->
Предотвращает зависания `searchd` при ротации таблиц с огромным объёмом данных для предварительного кэширования. Опционально, по умолчанию 1 (включить бесшовную ротацию). На системах Windows бесшовная ротация отключена по умолчанию.

Таблицы могут содержать некоторые данные, которые необходимо заранее кэшировать в ОЗУ. В настоящее время файлы `.spa`, `.spb`, `.spi` и `.spm` полностью предварительно кэшируются (они содержат данные атрибутов, данные блоб-атрибутов, таблицу ключевых слов и карту удалённых строк соответственно). Без бесшовного поворота поворот таблицы старается использовать как можно меньше ОЗУ и работает следующим образом:

1. Новые запросы временно отклоняются (с кодом ошибки "retry");
2. `searchd` ждёт завершения всех текущих выполняющихся запросов;
3. Старая таблица деаллочируется, а её файлы переименовываются;
4. Новые файлы таблицы переименовываются, и выделяется необходимая ОЗУ;
5. Новые данные атрибутов таблицы и словарные данные загружаются в ОЗУ;
6. `searchd` возобновляет обслуживание запросов из новой таблицы.

Однако, если данных атрибутов или словарных данных много, этап предварительной загрузки может занять заметное время — до нескольких минут в случае предварительной загрузки 1-5+ ГБ файлов.

При включённом бесшовном повороте, поворот работает следующим образом:

1. Выделяется ОЗУ для новой таблицы;
2. Данные атрибутов и словарные данные новой таблицы асинхронно загружаются в ОЗУ;
3. При успешной загрузке старая таблица деаллочируется, и файлы обеих таблиц переименовываются;
4. При ошибке новая таблица деаллочивается;
5. В любой момент запросы обслуживаются либо из старой, либо из новой копии таблицы.

Бесшовный поворот обходится повышенным пиковым использованием памяти во время поворота (поскольку обе копии данных `.spa/.spb/.spi/.spm` — старая и новая — должны находиться в ОЗУ во время загрузки новой копии). Среднее использование памяти остаётся прежним.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
seamless_rotate = 1
```
<!-- end -->

### secondary_indexes
<!-- example conf secondary_indexes -->

Этот параметр включает/отключает использование вторичных индексов для поисковых запросов. Опционально, по умолчанию включено (1). Обратите внимание, что включать его для индексации не нужно, так как он всегда включён, если установлена [Manticore Columnar Library](https://github.com/manticoresoftware/columnar). Последняя также необходима для использования индексов при поиске. Доступны три режима:

* `0`: Отключить использование вторичных индексов при поиске. Их можно включить для отдельных запросов с помощью [анализаторных подсказок](../Searching/Options.md#Query-optimizer-hints)
* `1`: Включить использование вторичных индексов при поиске. Их можно отключить для отдельных запросов с помощью [анализаторных подсказок](../Searching/Options.md#Query-optimizer-hints)
* `force`: То же, что и включено, но любые ошибки при загрузке вторичных индексов будут сообщены, и весь индекс не будет загружен в демон.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
secondary_indexes = 1
```

<!-- end -->

### server_id

<!-- example conf server_id -->
Целое число, которое служит идентификатором сервера и используется в качестве начального значения для генерации уникального короткого UUID для узлов, входящих в кластер репликации. server_id должен быть уникальным среди узлов кластера и находиться в диапазоне от 0 до 127. Если server_id не установлен, он вычисляется как хеш MAC-адреса и пути к PID-файлу или используется случайное число как исходное значение для короткого UUID.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
server_id = 1
```
<!-- end -->


### shutdown_timeout

<!-- example conf shutdown_timeout -->
Время ожидания `searchd --stopwait` в секундах (или [special_suffixes](../Server_settings/Special_suffixes.md)). Опционально, по умолчанию 60 секунд.

Когда вы запускаете `searchd --stopwait`, серверу нужно выполнить некоторые действия перед остановкой, такие как завершение запросов, сброс RT RAM чанков, сброс атрибутов и обновление binlog. Эти задачи требуют времени. `searchd --stopwait` будет ждать до `shutdown_time` секунд, пока сервер не завершит свои задачи. Подходящее время зависит от размера и нагрузки таблицы.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
shutdown_timeout = 3m # wait for up to 3 minutes
```
<!-- end -->


### shutdown_token

SHA1-хеш пароля, необходимого для вызова команды 'shutdown' из VIP Manticore SQL подключения. Без него,[debug](../Reporting_bugs.md#DEBUG) подкоманда 'shutdown' никогда не остановит сервер. Обратите внимание, что такое простое хеширование не следует считать надёжной защитой, так как мы не используем солёный хеш или современные хеш-функции. Это предназначено как простая предохранительная мера для служебных демонов в локальной сети.

### snippets_file_prefix

<!-- example conf snippets_file_prefix -->
Префикс, который добавляется к локальным именам файлов при генерации сниппетов. Опционально, по умолчанию это текущая рабочая папка.

Этот префикс можно использовать при распределённом создании сниппетов вместе с опциями `load_files` или `load_files_scattered`.

Обратите внимание, что это префикс, а **не** путь! Это означает, что если префикс установлен в "server1", а в запросе указан "file23", `searchd` попытается открыть "server1file23" (без кавычек). Поэтому, если нужно именно путь, необходимо включить завершающий слэш.

После построения итогового пути к файлу сервер разворачивает все относительные каталоги и сравнивает итоговый результат со значением `snippet_file_prefix`. Если результат не начинается с префикса, такой файл будет отклонён с сообщением об ошибке.

Например, если установлен `/mnt/data` и кто-то вызывает генерацию сниппетов с файлом `../../../etc/passwd` как источником, он получит сообщение об ошибке:

`File '/mnt/data/../../../etc/passwd' escapes '/mnt/data/' scope`

вместо содержимого файла.

Также, при неустановленном параметре и чтении `/etc/passwd`, фактически будет читаться `/daemon/working/folder/etc/passwd`, поскольку по умолчанию параметр — рабочая папка сервера.

Обратите также внимание, что это локальная опция; она никак не влияет на агенты. Поэтому вы можете безопасно установить префикс на мастер-сервере. Запросы, направляемые агентам, не будут затронуты настройкой мастера. Однако они будут зависеть от настроек самого агента.

Это может быть полезно, например, когда расположения хранения документов (локальное или точки монтирования NAS) различаются между серверами.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
snippets_file_prefix = /mnt/common/server1/
```
<!-- end -->

> **ВНИМАНИЕ:** Если вы все еще хотите получить доступ к файлам из корня FS, вы должны явно задать `snippets_file_prefix` пустым значением (через строку `snippets_file_prefix=`) или установить его в корень (через `snippets_file_prefix=/`).


### sphinxql_state

<!-- example conf sphinxql_state -->
Путь к файлу, в котором будет сериализовано текущее состояние SQL.

При запуске сервера этот файл воспроизводится. При подходящих изменениях состояния (например, SET GLOBAL) файл автоматически перезаписывается. Это помогает избежать труднодиагностируемой проблемы: если вы загрузили функции UDF, но Manticore аварийно завершил работу, при автоматическом перезапуске ваши UDF и глобальные переменные станут недоступны. Использование постоянного состояния помогает обеспечить плавное восстановление без таких сюрпризов.

`sphinxql_state` нельзя использовать для выполнения произвольных команд, таких как `CREATE TABLE`.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
sphinxql_state = uservars.sql
```
<!-- end -->


### sphinxql_timeout

<!-- example conf sphinxql_timeout -->
Максимальное время ожидания между запросами (в секундах или с [специальными_суффиксами](../Server_settings/Special_suffixes.md)) при использовании SQL-интерфейса. Опционально, по умолчанию 15 минут.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
sphinxql_timeout = 15m
```
<!-- end -->


### ssl_ca

<!-- example conf ssl_ca -->
Путь к файлу сертификата Центра Сертификации (CA) SSL (также известному как корневой сертификат). Опционально, по умолчанию пусто. Если не пусто, сертификат в `ssl_cert` должен быть подписан этим корневым сертификатом.

Сервер использует файл CA для проверки подписи сертификата. Файл должен быть в формате PEM.

<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ssl_ca = keys/ca-cert.pem
```
<!-- end -->


### ssl_cert

<!-- example conf ssl_cert -->
Путь к SSL-сертификату сервера. Опционально, по умолчанию пусто.

Сервер использует этот сертификат как самоподписанный публичный ключ для шифрования HTTP-трафика через SSL. Файл должен быть в формате PEM.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ssl_cert = keys/server-cert.pem
```
<!-- end -->


### ssl_key

<!-- example conf ssl_key -->
Путь к ключу SSL-сертификата. Опционально, по умолчанию пусто.

Сервер использует этот приватный ключ для шифрования HTTP-трафика через SSL. Файл должен быть в формате PEM.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
ssl_key = keys/server-key.pem
```
<!-- end -->


### subtree_docs_cache

<!-- example conf subtree_docs_cache -->
Максимальный размер кэша документов общего поддерева, на запрос. Опционально, по умолчанию 0 (отключено).

Этот параметр ограничивает использование ОЗУ оптимизатором общего поддерева (см. [multi-queries](../Searching/Multi-queries.md)). Максимум столько ОЗУ будет потрачено на кэширование записей документов для каждого запроса. Установка лимита в 0 отключает оптимизатор.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
subtree_docs_cache = 8M
```
<!-- end -->


### subtree_hits_cache

<!-- example conf subtree_hits_cache -->
Максимальный размер кэша совпадений общего поддерева, на запрос. Опционально, по умолчанию 0 (отключено).

Этот параметр ограничивает использование ОЗУ оптимизатором общего поддерева (см. [multi-queries](../Searching/Multi-queries.md)). Максимум столько ОЗУ будет потрачено на кэширование вхождений ключевых слов (совпадений) для каждого запроса. Установка лимита в 0 отключает оптимизатор.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
subtree_hits_cache = 16M
```
<!-- end -->

### threads

<!-- example threads -->
Количество рабочих нитей (или размер пула нитей) для демона Manticore. Manticore создает такое количество ОС-нитей при запуске, они выполняют все задачи внутри демона, такие как выполнение запросов, создание сниппетов и т.д. Некоторые операции могут быть разбиты на подзадачи и выполняться параллельно, например:

* Поиск в таблице реального времени
* Поиск в распределённой таблице, состоящей из локальных таблиц
* Вызов перколяции запроса
* и другие

По умолчанию устанавливается равным количеству ядер процессора на сервере. Manticore создает нити при запуске и удерживает их до остановки. Каждая подзадача может использовать одну из нитей при необходимости. Когда подзадача завершается, она освобождает нить для использования другой подзадачей.

В случаях интенсивной нагрузки ввода-вывода имеет смысл установить значение выше количества ядер ЦП.

<!-- request Example -->
```ini
threads = 10
```

<!-- end -->

### thread_stack

<!-- example conf thread_stack -->
Максимальный размер стека для задачи (корутины, один поисковый запрос может порождать несколько задач/корутин). Опционально, по умолчанию 128K.

Каждая задача имеет свой собственный стек размером 128K. При запуске запроса проверяется, сколько стека он требует. Если стандартных 128K достаточно, запрос просто обрабатывается. Если нужно больше, запланируется другая задача с увеличенным стеком, которая продолжит обработку. Максимальный размер такого расширенного стека ограничен этой настройкой.

Установка значения на разумно высоком уровне поможет обрабатывать очень глубокие запросы без значительного увеличения общего потребления ОЗУ. Например, установка в 1ГБ не означает, что каждая новая задача будет занимать 1ГБ ОЗУ, но если задача требует, скажем, 100М стека, для нее выделяется ровно 100М. При этом другие задачи одновременно запускаются с их стандартным стеком в 128K. Аналогично можно запускать более сложные запросы, которым надо, например, 500М. Только если внутренне будет требоваться стек более 1ГБ, задача завершится с ошибкой и сообщением о слишком маленьком thread_stack.

Тем не менее, на практике запрос, которому требуется стек в 16М, часто уже слишком сложен для разбора и требует слишком много времени и ресурсов. Так что демон обработает его, но ограничение таких запросов настройкой `thread_stack` выглядит вполне разумным.


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
thread_stack = 8M
```
<!-- end -->


### unlink_old

<!-- example conf unlink_old -->
Определяет, нужно ли удалять `.old` копии таблиц при успешной ротации. Опционально, по умолчанию 1 (удалять).


<!-- intro -->
##### Пример:

<!-- request Example -->

```ini
unlink_old = 0
```
<!-- end -->


### watchdog

<!-- example conf watchdog -->
Монитор сервера с использованием нити. Опционально, по умолчанию 1 (монитор включен).

Когда запрос Manticore завершается с ошибкой, он может привести к сбою всего сервера. При включенной функции watchdog, `searchd` также поддерживает отдельный легковесный процесс, который контролирует основной процесс сервера и автоматически перезапускает его в случае ненормального завершения. Watchdog включен по умолчанию.

<!-- request Example -->

```ini
watchdog = 0 # disable watchdog
```
<!-- end -->
<!-- proofread -->

