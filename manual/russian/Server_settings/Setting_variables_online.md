# Установка переменных онлайн

## УСТАНОВИТЕ
```sql
SET [GLOBAL] server_variable_name = value
SET [INDEX table_name] GLOBAL @user_variable_name = (int_val1 [, int_val2, ...])
SET NAMES value [COLLATE value]
SET @@dummy_variable = ignored_value
```

Оператор `SET` в Manticore Search позволяет изменять значения переменных. Имена переменных нечувствительны к регистру, и изменения значений переменных не сохранятся после перезапуска сервера.

Manticore Search поддерживает оператор `SET NAMES` и синтаксис `SET @@variable_name` для совместимости с сторонними библиотеками клиентского MySQL, соединителями и фреймворками, которые могут требовать выполнения этих операторов при подключении. Однако эти операторы не оказывают никакого эффекта на сам Manticore Search.

В Manticore Search имеется четыре класса переменных:

1.  Переменная сервера на сеанс: `set var_name = value`
2.  Глобальная переменная сервера: `set global var_name = value`
3.  Глобальная переменная пользователя: `set global @var_name = (value)`
4.  Глобальная распределенная переменная: `set index dist_table_name global @var_name = (value)`

Глобальные переменные пользователя разделяются между параллельными сеансами. Единственным поддерживаемым типом значения является список BIGINT, и эти переменные могут быть использованы с оператором IN() для целей фильтрации. Основное применение этой функции заключается в загрузке больших списков значений в `searchd` один раз и повторном использовании их несколько раз позже, что снижает сетевую нагрузку. Глобальные переменные пользователя могут быть переданы всем агентам распределенной таблицы или установлены локально в случае локальной таблицы, определенной в распределенной таблице. Пример:

```sql
// в сеансе 1
mysql> SET GLOBAL @myfilter=(2,3,5,7,11,13);
Запрос выполнен, 0 строк затронуто (0,00 сек)

// позже в сеансе 2
mysql> SELECT * FROM test1 WHERE group_id IN @myfilter;
+------+--------+----------+------------+-----------------+------+
| id   | weight | group_id | date_added | title           | tag  |
+------+--------+----------+------------+-----------------+------+
|    3 |      1 |        2 | 1299338153 | другой документ | 15   |
|    4 |      1 |        2 | 1299338153 | документ номер четыре | 7,40 |
+------+--------+----------+------------+-----------------+------+
2 строки в результате (0,02 сек)
```

Manticore Search поддерживает переменные сервера для сеансов и глобальные переменные сервера, которые влияют на определенные настройки сервера в соответствующих областях. Ниже приведен список известных переменных сервера для сеансов и глобальных переменных сервера:

Известные переменные сервера на сеанс:

* `AUTOCOMMIT = {0 | 1}` определяет, должны ли операторы изменения данных неявно оборачиваться в `BEGIN` и `COMMIT`.
* `COLLATION_CONNECTION = collation_name` выбирает коллейшен для `ORDER BY` или `GROUP BY` по строковым значениям в последующих запросах. См. [Коллейшены](../Searching/Collations.md) для списка известных имен коллейшенов.
* `MAX_THREADS_PER_QUERY = <POSITIVE_INT_VALUE>` переопределяет [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query) во время выполнения. Переменная для сеанса влияет только на запросы, выполняемые в одном и том же сеансе (соединении), т.е. до отключения. Значение 0 означает «нет предела». Если установлены как переменные для сеансов, так и глобальные переменные, переменная для сеанса имеет более высокий приоритет.
* `net_write_timeout = <value>`: Настраивает тайм-аут сети для операций записи, т.е. отправки данных. Глобальное значение можно изменить только с правами VIP.
* `optimize_by_id = {0 | 1}`: Внутренний флаг, используемый в некоторых командах `debug`.
* `PROFILING = {0 | 1}` включает профилирование запросов в текущем сеансе. По умолчанию 0. См. также [show profile](../Node_info_and_management/Profiling/Query_profile.md).
* `ro = {1 | 0}` переключает сеанс в режим только для чтения или обратно. В выводе `show variables` переменная отображается с именем `session_read_only`.
* `throttling_period = <INT_VALUE>`: Интервал (в миллисекундах), в течение которого текущий выполняющийся запрос будет перенесен. Значение 0 отключает ограничение частоты, что означает, что запрос будет использовать процессорные ядра, пока не завершится. Если параллельные запросы приходят из других соединений одновременно, они будут выделены на свободные ядра или будут приостановлены до освобождения ядра. Указание отрицательного значения (-1) сбрасывает ограничение частоты до значения по умолчанию (100 мс), что означает, что запрос будет перенесен каждые 100 мс, предоставляя возможность выполнения параллельным запросам. Глобальное значение (установленное через `set global`) можно установить только на VIP-соединении.
* `thread_stack = <value>`: Изменяет значение по умолчанию на лету, что ограничивает размер стека, предоставляемого одной задаче. Обратите внимание, что здесь «поток» не относится к потоку ОС, а к потоку пользовательского пространства, также известному как корутина. Это может быть полезно, если, например, вы загружаете таблицу перколяции с неожиданно высокими требованиями. В таких случаях опция 'call pq' завершится с сообщением о недостаточном размере стека. Обычно рекомендуется остановить демон, увеличить значение в конфигурации, а затем перезапустить. Однако вы также можете попробовать новое значение без перезапуска, установив новое с помощью этой переменной. Глобальное значение также может быть изменено онлайн с помощью `set global thread_stack`, но это доступно только с VIP-соединения.
* `threads_ex` (диагностическое): Заставляет Manticore вести себя так, как будто он работает на ЦП с предоставленным профилем. В качестве короткого примера, `set threads_ex='4/2+6/3'` указывает 'у вас 4 свободных процессорных ядра, при планировании нескольких запросов они должны группироваться по 2. Также у вас есть 6 свободных процессорных ядер для псевдораспределения, части должны группироваться по 3'. Эта опция является диагностической, так как она очень полезна, например, чтобы увидеть, как ваш запрос будет выполняться на конфигурации, которой у вас нет локально. Например, на 128-ядерном ЦП. Или, наоборот, быстро ограничить демон для работы в одно-поточном режиме, чтобы найти узкое место или исследовать сбой.

  <details>

	По умолчанию Manticore запускает пул потоков с рассчитанным количеством ядер ЦП. Все типичные задачи распределяются по этому пулу потоков, чтобы обеспечить максимальную загрузку ЦП. Например, когда у таблицы реального времени есть несколько дисковых чанков, поиск будет параллелизирован по ядрам ЦП. Точно так же, для одного полнотекстового запроса по одному индексу демон попытается оптимизировать выполнение поиска параллельно, используя метод, называемый "псевдо-шардированием". Оба этих аспекта сильно зависят от общего числа ядер ЦП и количества свободных ядер, доступных для немедленного использования.

	Этот подход повышает производительность, но может сделать расследование инцидентов более сложным. Например, запрос, выполняющий `COUNT(*)`, может вернуть приблизительный результат (например, более 100 совпадений), а при последующем выполнении того же запроса может дать точный результат (например, ровно 120 совпадений). Эта изменчивость зависит от доступных ядер, но поскольку этот фактор непредсказуем, это обычно приводит к нерепродуцируемым результатам. Хотя это обычно приемлемо, иногда это может быть проблемой. Опция `threads_ex` задает желаемую конфигурацию ядер ЦП, что делает запросы с этой конфигурацией воспроизводимыми.

	`threads_ex` устанавливает шаблон ЦП для стандартных задач и для псевдо-шардирования, так как псевдо-шардирование может быть частью стандартного процесса параллелизации. Например, если есть несколько дисковых чанков, они будут запрашиваться параллельно, но каждый может быть дополнительно параллелизирован с использованием псевдо-шардирования. Таким образом, чтобы эффективно управлять этой ситуацией, вам нужно несколько шаблонов для каждого типа задач.

	Шаблон – это строка, такая как `10/3`, где 10 представляет собой параллелизм, а 3 – размер пакета. Если количество параллельных потоков равно 0, будет использоваться значение по умолчанию. Если размер пакета равен 0, будет использоваться тривиальный шаблон по умолчанию. Любое нулевое значение может быть пропущено или заменено на `*`. Шаблон по умолчанию (тривиальный) можно описать как `''`, а также как `*/*`, `0/0`, `0/`, `*/`, `/0`, `*` и т. д. Это означает, что демон использует все доступные ядра ЦП без специальных ограничений на пакетирование.

	Тривиальный шаблон с 20 потоками может быть выражен как `20/*`, `20/0`, `20/`, или просто `20`. Шаблон кругового распределения с размером пакета 2 - это `*/2`, `0/2`, или просто `/2`. Шаблон кругового распределителя с 20 потоками и размером пакета 3 - это `20/3`.

	`threads_ex` - это шаблон для базовых задач и для псевдо-шардирования, разделённый знаком `+`, например:

	* `30+3` - тривиальная база из 30 потоков + тривиальное псевдо-шардирование из 3 потоков
	* `+/2` - тривиальная база + круглосуточное псевдо-шардирование с потоками по умолчанию и размером пакета = 2
	* `10` - тривиальная база из 10 потоков + тривиальное псевдо-шардирование по умолчанию
	* `/1+10` - базовый круговой с потоками по умолчанию и размером пакета = 1 + тривиальное псевдо-шардирование с 10 потоками
	* `4/2+2/1` - базовый круговой с 4 потоками и размером пакета = 2 + круговое псевдо-шардирование с 2 потоками и размером пакета = 1
	* `1+1` - самый детерминированный случай. Ровно 1 поток + 1 псевдошард, т. е. никакой параллелизации вообще. С этой настройкой вы можете воспроизводимо повторить тот же проблемный запрос и исследовать детали поведения. Более того, если вы установите `throttling_period=0`, ваш запрос будет "прикреплен" к текущему потоку и никогда не будет переназначен во время выполнения, создавая идеальную среду для решения проблем.

	Опция может быть установлена глобально извне в виде переменной окружения `MANTICORE_THREADS_EX`, как:

	```bash
	export MANTICORE_THREADS_EX=8
	export MANTICORE_THREADS_EX='16+8/2'
  ```

  Или через MySQL CLI, как:
  ```sql
  SET threads_ex='16';
	SET GLOBAL threads_ex='/2';
  ```

  Или в виде параметра запроса, как:
  ```sql
  SELECT ... OPTION threads_ex='1+1';
  ```

  Конфигурация `threads_ex` подчиняется иерархии: сначала переменные окружения, затем глобальная переменная, и наконец опции запроса, позволяя конкретным настройкам переопределять общие.

  </details>
* `WAIT_TIMEOUT/net_read_timeout = <value>` устанавливает тайм-аут соединения, либо для сессии, либо общий. Глобальный можно установить только на VIP-соединении.

Известные глобальные серверные переменные:

* `ACCURATE_AGGREGATION`: Устанавливает значение по умолчанию для опции [accurate_aggregation](../Searching/Options.md#accurate_aggregation) будущих запросов.
* `AUTO_OPTIMIZE = {1|0}` Включает/выключает [auto_optimize](../Server_settings/Searchd.md#auto_optimize).
* `cluster_user = name` Устанавливает имя пользователя, используемое с `mysqldump` / `mariadb-dump` для [включения режима репликации](../Securing_and_compacting_a_table/Backup_and_restore.md#Backup-and-restore-with-mysqldump).
* `COREDUMP= {1|0}` Включает/выключает сохранение файла дампа памяти или минидампа сервера при сбое. Дополнительные сведения [здесь](../Starting_the_server/Manually.md#searchd-command-line-options).
* `CPUSTATS= {1|0}` Включает/выключает [отслеживание времени ЦП](../Starting_the_server/Manually.md#searchd-command-line-options).
* `DISTINCT_PRECISION_THRESHOLD`: Устанавливает значение по умолчанию для опции [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) будущих запросов.
* `ES_COMPAT = {on/off/dashboards}` Когда установлено в `on` (по умолчанию), поддерживаются запросы на запись, похожие на Elasticsearch; `off` отключает поддержку; `dashboards` включает поддержку и также позволяет запросы из Kibana (эта функциональность экспериментальна).
* `EXPANSION_MERGE_THRESHOLD_DOCS`: Изменяет значение параметра конфигурации [expansion_merge_threshold_docs](Server_settings/Searchd.md#expansion_merge_threshold_docs) на лету.
* `EXPANSION_MERGE_THRESHOLD_HITS`: Изменяет значение параметра конфигурации [expansion_merge_threshold_hits](Server_settings/Searchd.md#expansion_merge_threshold_hits) на лету.
* `GROUPING_IN_UTC = {0 | 1}` Когда установлено на 1, приводит к тому, что функции группировки времени (day(), month(), year(), yearmonth(), yearmonthday()) вычисляются в UTC. Читайте документацию для параметров конфигурации [grouping_in_utc](../Server_settings/Searchd.md) для получения дополнительных сведений.
* `IOSTATS = {0 | 1}` Включает или отключает отчет о операциях ввода/вывода (за исключением атрибутов) в журнале запросов.
* `LOG_DEBUG_FILTER = <string value>` Фильтрует избыточные сообщения журнала. Если значение установлено, все журналы с уровнем > INFO (т.е., `DEBUG`, `DEBUGV` и т.д.) будут сравнены со строкой и выведены только в том случае, если они начинают с указанного значения.
* `LOG_LEVEL = {info | debug | replication | debugv | debugvv}` Изменяет текущий уровень детализации журнала.
* `MAINTENANCE = {0 | 1}` При установке в 1, переводит сервер в режим обслуживания. Только клиенты с VIP-соединениями могут выполнять запросы в этом режиме. Все новые входящие соединения не с VIP отклоняются. Существующие соединения остаются нетронутыми.
* `MAX_THREADS_PER_QUERY = <POSITIVE_INT_VALUE>` Переопределяет [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query) во время выполнения. Как глобальная, она изменяет поведение для всех сеансов. Значение 0 означает 'без предела'. Если заданы как сеансовая, так и глобальная переменные, приоритет имеет сеансовая.
* `NET_WAIT = {-1 | 0 | POSITIVE_INT_VALUE}` Изменяет значение [net_wait_tm](../Server_settings/Searchd.md#net_wait_tm) настроек searchd.
* `OPTIMIZE_CUTOFF = <value>`: Изменяет значение настройки [optimize_cutoff](../Server_settings/Searchd.md#optimize_cutoff) конфигурации на лету.
* `PSEUDO_SHARDING = {1|0}` Включает/выключает [псевдо-ши́рдинг](../Server_settings/Searchd.md#pseudo_sharding).
* `QCACHE_MAX_BYTES = <value>` Изменяет лимит использования ОЗУ [query_cache](../Searching/Query_cache.md) на данное значение.
* `QCACHE_THRESH_MSEC = <value>` Изменяет минимальный порог времени в миллисекундах [query_cache](../Searching/Query_cache.md) до данного значения.
* `QCACHE_TTL_SEC = <value>` Изменяет TTL [query_cache](../Searching/Query_cache.md) для кэшированного результата до данного значения.
* `QUERY_LOG_FORMAT = {plain | sphinxql}` Изменяет текущий формат журнала.
* `QUERY_LOG_MIN_MSEC = <value>` Изменяет значение [query_log_min_msec](../Server_settings/Searchd.md#query_log_min_msec) настроек searchd. В этом случае значение ожидается именно в миллисекундах и не анализирует суффиксы времени, как в конфигурации.
  > Предупреждение: это очень специфическая и 'жесткая' переменная; отфильтрованные сообщения просто будут отброшены и не записаны в журнал вовсе. Лучше просто отфильтровать ваш журнал с помощью чего-то вроде 'grep', в этом случае у вас будет, по крайней мере, полный оригинальный журнал в качестве резервной копии.
* `RESET_NETWORK_TIMEOUT_ON_PACKET = {1|0}` изменяет параметр [reset_network_timeout_on_packet](../Server_settings/Searchd.md#reset_network_timeout_on_packet). Только клиенты с VIP-соединениями могут изменять эту переменную.
* `SECONDARY_INDEXES = {1|0}` Включает/выключает [вторичные индексы](../Server_settings/Searchd.md#secondary_indexes) для поисковых запросов.
* `TIMEZONE = <value>` Указывает часовой пояс, используемый функциями, связанными с датой/временем. Ознакомьтесь с документацией по параметру конфигурации [timezone](../Server_settings/Searchd.md) для получения дополнительной информации.

Примеры:

```sql
mysql> SET autocommit=0;
Query OK, 0 rows affected (0.00 sec)

mysql> SET GLOBAL query_log_format=sphinxql;
Query OK, 0 rows affected (0.00 sec)

mysql> SET GLOBAL @banned=(1,2,3);
Query OK, 0 rows affected (0.01 sec)

mysql> SET INDEX users GLOBAL @banned=(1,2,3);
Query OK, 0 rows affected (0.01 sec)
```

Чтобы сделать переменные пользователя постоянными, убедитесь, что [sphinxql_state](../Server_settings/Searchd.md#sphinxql_state) включен.
<!-- proofread -->
