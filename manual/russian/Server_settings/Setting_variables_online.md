# Установка переменных онлайн

## SET
```sql
SET [GLOBAL] server_variable_name = value
SET [INDEX table_name] GLOBAL @user_variable_name = (int_val1 [, int_val2, ...])
SET NAMES value [COLLATE value]
SET @@dummy_variable = ignored_value
```

Оператор `SET` в Manticore Search позволяет изменять значения переменных. Имена переменных не зависят от регистра, и изменения значений переменных не сохраняются после перезапуска сервера.

Manticore Search поддерживает оператор `SET NAMES` и синтаксис `SET @@variable_name` для совместимости с внешними MySQL клиентскими библиотеками, коннекторами и фреймворками, которые могут требовать выполнения этих операторов при подключении. Однако эти операторы не влияют на сам Manticore Search.

В Manticore Search существует четыре класса переменных:

1.  Переменная сервера для сессии: `set var_name = value`
2.  Глобальная переменная сервера: `set global var_name = value`
3.  Глобальная пользовательская переменная: `set global @var_name = (value)`
4.  Глобальная распределённая переменная: `set index dist_table_name global @var_name = (value)`

Глобальные пользовательские переменные разделяются между одновременными сессиями. Единственным поддерживаемым типом значения является список BIGINT, и эти переменные могут использоваться с оператором IN() для фильтрации. Основное применение этой функции — загрузить большие списки значений в `searchd` один раз и повторно использовать их несколько раз, снижая сетевые затраты. Глобальные пользовательские переменные могут быть переданы всем агентам распределённой таблицы или установлены локально в случае локальной таблицы, определённой в распределённой таблице. Пример:

```sql
// in session 1
mysql> SET GLOBAL @myfilter=(2,3,5,7,11,13);
Query OK, 0 rows affected (0.00 sec)

// later in session 2
mysql> SELECT * FROM test1 WHERE group_id IN @myfilter;
+------+--------+----------+------------+-----------------+------+
| id   | weight | group_id | date_added | title           | tag  |
+------+--------+----------+------------+-----------------+------+
|    3 |      1 |        2 | 1299338153 | another doc     | 15   |
|    4 |      1 |        2 | 1299338153 | doc number four | 7,40 |
+------+--------+----------+------------+-----------------+------+
2 rows in set (0.02 sec)
```

Manticore Search поддерживает переменные сервера для сессии и глобальные переменные сервера, которые влияют на конкретные настройки сервера в соответствующих областях видимости. Ниже приведён список известных переменных сервера для сессии и глобальных переменных сервера:

Известные пер-сессионные переменные сервера:

* `AUTOCOMMIT = {0 | 1}` определяет, должны ли операторы модификации данных автоматически обрамляться в `BEGIN` и `COMMIT`.
* `COLLATION_CONNECTION = collation_name` выбирает сортировку для `ORDER BY` или `GROUP BY` по строковым значениям в последующих запросах. См. [Collations](../Searching/Collations.md) для списка известных имён сортировок.
* `MAX_THREADS_PER_QUERY = <POSITIVE_INT_VALUE>` переопределяет [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query) во время выполнения. Переменная для сессии влияет только на запросы, выполняемые в той же сессии (подключении), то есть до отключения. Значение 0 означает 'без ограничений'. Если установлены оба значения — для сессии и глобальное — приоритет у переменной сессии.
* `net_write_timeout = <value>`: Настраивает сетевой тайм-аут для операций записи, то есть отправки данных. Глобальное значение может быть изменено только с правами VIP.
* `optimize_by_id = {0 | 1}`: Внутренний флаг, используемый в некоторых командах `debug`.
* `PROFILING = {0 | 1}` включает профилирование запросов в текущей сессии. По умолчанию 0. См. также [show profile](../Node_info_and_management/Profiling/Query_profile.md).
* `ro = {1 | 0}` переключает сессию в режим только для чтения или обратно. В выводе `show variables` переменная отображается под именем `session_read_only`.
* `throttling_period = <INT_VALUE>`: Интервал (в миллисекундах), с которым текущий выполняющийся запрос будет перепланирован. Значение 0 отключает ограничение пропускной способности, что означает, что запрос будет занимать CPU до завершения. Если одновременно поступают параллельные запросы с других подключений, они будут направлены на свободные ядра или приостановлены до освобождения ядра. Ввод отрицательного значения (-1) сбрасывает ограничение до значения по умолчанию (100 мс), что означает перепланирование запроса каждые 100 мс, давая шанс выполнения параллельным запросам. Глобальное значение (установленное через `set global`) может быть установлено только с VIP-подключения.
* `thread_stack = <value>`: Изменяет значение по умолчанию на лету, ограничивающее размер стека, выделенный для одной задачи. Обратите внимание, что здесь 'поток' означает не поток ОС, а пользовательский поток (корутину). Это может пригодиться, например, если у вас возникли неожиданные большие требования при загрузке таблицы percolate. В таких случаях вызов 'call pq' может завершиться ошибкой из-за недостаточного размера стека. Обычно рекомендуется остановить демон, увеличить значение в конфиге и затем перезапустить. Однако можно попробовать новое значение без перезапуска, установив переменную с помощью этой настройки. Глобальное значение также можно изменить онлайн с помощью `set global thread_stack`, но это доступно только с VIP-подключения.
* `threads_ex` (диагностическая): Заставляет Manticore вести себя так, как если бы он работал на ЦПУ с указанным профилем. Например, `set threads_ex='4/2+6/3'` означает: 'у вас есть 4 свободных ядра CPU, при планировании нескольких запросов их следует группировать по 2. Также у вас есть 6 свободных ядер CPU для псевдо-шардинга, части должны группироваться по 3'. Эта опция диагностическая, так как помогает увидеть, как ваш запрос будет выполняться на конфигурации, которой у вас нет локально. Например, на 128-ядерном ЦПУ. Или, наоборот, быстро ограничить демон к однопоточному режиму, чтобы найти узкое место или исследовать сбой.

  <details>

По умолчанию, Manticore запускает пул потоков с рассчитанным количеством ядер CPU. Все типичные задачи затем распределяются в этот пул потоков для максимального использования CPU. Например, если у таблицы real-time несколько дисковых чанков, поиск будет распараллелен по ядрам CPU. Аналогично, для полнотекстового поиска по одному индексу демон пытается оптимизировать выполнение поисков параллельно, используя технику, называемую «псевдо-шардинг». Обе функции сильно зависят от общего количества ядер CPU и количества свободных ядер для немедленного использования.

Этот подход улучшает производительность, но усложняет расследование инцидентов. Например, запрос с `COUNT(*)` может возвратить приблизительный результат (например, более 100 совпадений), а при повторном выполнении того же запроса — точный результат (например, ровно 120 совпадений). Такая вариативность зависит от доступных ядер, и поскольку этот фактор непредсказуем, это обычно ведёт к неповторяемым результатам. Хотя это обычно приемлемо, иногда это может вызывать проблемы. Опция `threads_ex` задаёт желаемую конфигурацию ядер CPU, делая запросы с этой конфигурацией воспроизводимыми.

`threads_ex` задаёт шаблон CPU для стандартных задач и для псевдошардирования, так как псевдошардирование может быть частью стандартного процесса параллелизации. Например, если есть несколько дисковых чанков, они будут опрошены параллельно, но каждый из них может быть дополнительно распараллелен с помощью псевдошардирования. Таким образом, для эффективного управления этой ситуацией нужны пара шаблонов для каждого типа задач.

Шаблон — это строка вида `10/3`, где 10 обозначает уровень конкуренции (concurrency), а 3 — размер батча (batch size). Если concurrency равен 0, используется значение конкуренции по умолчанию. Если размер батча равен 0, используется тривиальный шаблон по умолчанию. Любое значение 0 можно опустить или заменить на `*`. Шаблон по умолчанию (тривиальный) можно описать как `''`, а также как `*/*`, `0/0`, `0/`, `*/`, `/0`, `*` и т.п. Это значит, что демон использует все доступные ядра CPU без особых ограничений на пакетирование.

Тривиальный шаблон с 20 потоками можно выразить как `20/*`, `20/0`, `20/`, или просто `20`. Шаблон кругового распределения с размером батча 2 — это `*/2`, `0/2`, или просто `/2`. Диспетчер кругового распределения с 20 потоками и батчем 3 — `20/3`.

`threads_ex` — это шаблон для базовых задач и для псевдошардирования, разделённый `+`, например:

* `30+3` — тривиальная база из 30 потоков + тривиальное псевдошардирование из 3 потоков
* `+/2` — тривиальная база + псевдошардирование кругового распределения с потоками по умолчанию и батчем=2
* `10` — тривиальная база из 10 потоков + тривиальное псевдошардирование по умолчанию
* `/1+10` — база кругового распределения с потоками по умолчанию и батчем=1 + тривиальное псевдошардирование с 10 потоками
* `4/2+2/1` — база кругового распределения с 4 потоками и батчем=2 + псевдошардирование кругового распределения с 2 потоками и батчем=1
* `1+1` — наиболее детерминированный случай. Ровно 1 поток + 1 псевдошард, то есть никакой параллелизации вообще. С этим параметром вы можете устойчиво повторять одинаковый проблемный запрос и изучать детали поведения. Кроме того, если установить `throttling_period=0`, ваш запрос будет «прилипать» к текущему потоку и никогда не будет перепланирован во время выполнения, создавая идеальную среду для отладки.

Опция может быть задана глобально из внешней среды как переменная окружения `MANTICORE_THREADS_EX`, например:

```bash
export MANTICORE_THREADS_EX=8
export MANTICORE_THREADS_EX='16+8/2'
  ```

  Либо через CLI MySQL, так:
  ```sql
  SET threads_ex='16';
SET GLOBAL threads_ex='/2';
  ```

  Или как параметр запроса, например:
  ```sql
  SELECT ... OPTION threads_ex='1+1';
  ```

  Конфигурация `threads_ex` следует иерархии: сначала переменные окружения, затем глобальная переменная, и в последнюю очередь опции запроса, что позволяет конкретным настройкам переопределять общие.

  </details>
* `WAIT_TIMEOUT/net_read_timeout = <value>` задаёт таймаут соединения, либо для сессии, либо глобально. Глобально можно установить только для VIP-подключения.

Известные глобальные переменные сервера:

* `ACCURATE_AGGREGATION`: Задаёт значение по умолчанию для опции [accurate_aggregation](../Searching/Options.md#accurate_aggregation) будущих запросов.
* `AUTO_OPTIMIZE = {1|0}` Включает/отключает [auto_optimize](../Server_settings/Searchd.md#auto_optimize).
* `cluster_user = name` Устанавливает имя пользователя, которое используется с `mysqldump` / `mariadb-dump` для [включения режима репликации](../Securing_and_compacting_a_table/Backup_and_restore.md#Backup-and-restore-with-mysqldump).
* `COREDUMP= {1|0}` Включает/отключает сохранение core-файла или минидампа сервера при сбое. Подробнее [здесь](../Starting_the_server/Manually.md#searchd-command-line-options).
* `CPUSTATS= {1|0}` Включает/отключает [отслеживание времени CPU](../Starting_the_server/Manually.md#searchd-command-line-options).
* `DISTINCT_PRECISION_THRESHOLD`: Задаёт значение по умолчанию для опции [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) будущих запросов.
* `ES_COMPAT = {on/off/dashboards}` При установке в `on` (по умолчанию) поддерживаются записи, похожие на Elasticsearch; `off` отключает поддержку; `dashboards` включает поддержку и разрешает запросы из Kibana (эта функциональность экспериментальная).
* `EXPANSION_MERGE_THRESHOLD_DOCS`: Изменяет значение настройки конфига [expansion_merge_threshold_docs](../Server_settings/Searchd.md#expansion_merge_threshold_docs) на лету.
* `EXPANSION_MERGE_THRESHOLD_HITS`: Изменяет значение настройки конфига [expansion_merge_threshold_hits](../Server_settings/Searchd.md#expansion_merge_threshold_hits) на лету.
* `GROUPING_IN_UTC = {0 | 1}` Если установлено в 1, вызывает вычисление временных группирующих функций (day(), month(), year(), yearmonth(), yearmonthday()) в UTC. Подробности в документации по параметру конфигурации [grouping_in_utc](../Server_settings/Searchd.md).
* `IOSTATS = {0 | 1}` Включает или отключает отчёты о операциях ввода-вывода (кроме атрибутов) в лог запросов.
* `LOG_DEBUG_FILTER = <string value>` Фильтрует избыточные сообщения лога. Если значение установлено, все логи с уровнем > INFO (например, `DEBUG`, `DEBUGV` и т.п.) будут сравниваться со строкой и выводиться только в случае, если они начинаются с данного значения.
* `LOG_LEVEL = {info | debug | replication | debugv | debugvv}` Изменяет текущий уровень детализации лога.
* `MAINTENANCE = {0 | 1}` Если установлено в 1, переводит сервер в режим обслуживания. Только клиенты с VIP-подключениями могут выполнять запросы в этом режиме. Все новые не-VIP соединения отклоняются. Существующие соединения сохраняются.
* `MAX_THREADS_PER_QUERY = <POSITIVE_INT_VALUE>` Переопределяет [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query) во время работы. В глобальном виде меняет поведение для всех сессий. Значение 0 означает «без ограничений». Если заданы и переменные для сессии, и глобальные, приоритет выше у сессионной переменной.
* `NET_WAIT = {-1 | 0 | POSITIVE_INT_VALUE}` Изменяет значение настройки [net_wait_tm](../Server_settings/Searchd.md#net_wait_tm) в searchd.
* `OPTIMIZE_CUTOFF = <value>`: Изменяет значение настройки конфигурации [optimize_cutoff](../Server_settings/Searchd.md#optimize_cutoff) на лету.
* `PSEUDO_SHARDING = {1|0}` Включает/выключает поиск с [псевдошардированием](../Server_settings/Searchd.md#pseudo_sharding).
* `QCACHE_MAX_BYTES = <value>` Изменяет лимит использования RAM для [query_cache](../Searching/Query_cache.md) на заданное значение.
* `QCACHE_THRESH_MSEC = <value>` Изменяет минимальный порог времени отклика в миллисекундах для [query_cache](../Searching/Query_cache.md) на заданное значение.
* `QCACHE_TTL_SEC = <value>` Изменяет TTL для кэшированного результата в [query_cache](../Searching/Query_cache.md) на заданное значение.
* `QUERY_LOG_FORMAT = {plain | sphinxql}` Изменяет текущий формат логов.
* `QUERY_LOG_MIN_MSEC = <value>` Изменяет значение параметра [query_log_min_msec](../Server_settings/Searchd.md#query_log_min_msec) в настройках searchd. В данном случае ожидается значение именно в миллисекундах, без разбора суффиксов времени, как в конфиге.
  > Внимание: это очень специфическая и «жесткая» переменная; отфильтрованные сообщения просто не будут записаны в лог. Лучше фильтровать лог с помощью чего-то вроде 'grep', тогда у вас будет хотя бы полный оригинальный лог в качестве резервной копии.
* `RESET_NETWORK_TIMEOUT_ON_PACKET = {1|0}` изменяет параметр [reset_network_timeout_on_packet](../Server_settings/Searchd.md#reset_network_timeout_on_packet). Изменять эту переменную могут только клиенты с VIP подключениями.
* `SECONDARY_INDEXES = {1|0}` Включает/выключает [вторичные индексы](../Server_settings/Searchd.md#secondary_indexes) для поисковых запросов.
* `TIMEZONE = <value>` Задает часовой пояс, используемый функциями, связанными с датой и временем. Для дополнительных сведений смотрите документацию по параметру конфигурации [timezone](../Server_settings/Searchd.md).

Примеры:

```sql
mysql> SET autocommit=0;
Query OK, 0 rows affected (0.00 sec)

mysql> SET GLOBAL query_log_format=sphinxql;
Query OK, 0 rows affected (0.00 sec)

mysql> SET GLOBAL @banned=(1,2,3);
Query OK, 0 rows affected (0.01 sec)

mysql> SET INDEX users GLOBAL @banned=(1,2,3);
Query OK, 0 rows affected (0.01 sec)
```

Чтобы сделанные пользователем переменные были постоянными, убедитесь, что включен [sphinxql_state](../Server_settings/Searchd.md#sphinxql_state). 
<!-- proofread -->

