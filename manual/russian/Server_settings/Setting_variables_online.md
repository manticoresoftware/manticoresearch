# Установка переменных онлайн

## SET
```sql
SET [GLOBAL] server_variable_name = value
SET [INDEX table_name] GLOBAL @user_variable_name = (int_val1 [, int_val2, ...])
SET NAMES value [COLLATE value]
SET @@dummy_variable = ignored_value
```

Оператор `SET` в Manticore Search позволяет изменять значения переменных. Имена переменных не чувствительны к регистру, и изменения значений переменных не сохраняются после перезапуска сервера.

Manticore Search поддерживает оператор `SET NAMES` и синтаксис `SET @@variable_name` для совместимости с клиентскими библиотеками MySQL, коннекторами и фреймворками сторонних разработчиков, которые могут требовать выполнения этих операторов при подключении. Однако эти операторы не влияют на сам Manticore Search.

В Manticore Search существует четыре класса переменных:

1.  Переменная сервера на сессию: `set var_name = value`
2.  Глобальная переменная сервера: `set global var_name = value`
3.  Глобальная пользовательская переменная: `set global @var_name = (value)`
4.  Глобальная распределённая переменная: `set index dist_table_name global @var_name = (value)`

Глобальные пользовательские переменные разделяются между параллельными сессиями. Единственный поддерживаемый тип значения — список BIGINT, и эти переменные можно использовать с оператором IN() для фильтрации. Основное применение этой функции — загрузка больших списков значений в `searchd` один раз с последующим многократным использованием, что снижает сетевые накладные расходы. Глобальные пользовательские переменные могут передаваться всем агентам распределённой таблицы или устанавливаться локально в случае локальной таблицы, определённой в распределённой таблице. Пример:

```sql
// in session 1
mysql> SET GLOBAL @myfilter=(2,3,5,7,11,13);
Query OK, 0 rows affected (0.00 sec)

// later in session 2
mysql> SELECT * FROM test1 WHERE group_id IN @myfilter;
+------+--------+----------+------------+-----------------+------+
| id   | weight | group_id | date_added | title           | tag  |
+------+--------+----------+------------+-----------------+------+
|    3 |      1 |        2 | 1299338153 | another doc     | 15   |
|    4 |      1 |        2 | 1299338153 | doc number four | 7,40 |
+------+--------+----------+------------+-----------------+------+
2 rows in set (0.02 sec)
```

Manticore Search поддерживает переменные сервера на сессию и глобальные переменные сервера, которые влияют на определённые настройки сервера в соответствующих областях видимости. Ниже приведён список известных переменных сервера на сессию и глобальных переменных сервера:

Известные переменные сервера на сессию:

* `AUTOCOMMIT = {0 | 1}` определяет, должны ли операторы изменения данных автоматически оборачиваться в `BEGIN` и `COMMIT`.
* `COLLATION_CONNECTION = collation_name` выбирает сортировку для `ORDER BY` или `GROUP BY` по строковым значениям в последующих запросах. Список известных имён сортировок см. в разделе [Collations](../Searching/Collations.md).
* `MAX_THREADS_PER_QUERY = <POSITIVE_INT_VALUE>` переопределяет [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query) во время выполнения. Переменная на сессию влияет только на запросы, выполняемые в той же сессии (подключении), то есть до отключения. Значение 0 означает «без ограничений». Если установлены обе переменные — на сессию и глобальная, приоритет выше у переменной на сессию.
* `net_write_timeout = <value>`: Настраивает сетевой таймаут для операций записи, то есть отправки данных. Глобальное значение можно изменить только с привилегиями VIP.
* `optimize_by_id = {0 | 1}`: Внутренний флаг, используемый в некоторых командах `debug`.
* `PROFILING = {0 | 1}` включает профилирование запросов в текущей сессии. По умолчанию 0. См. также [show profile](../Node_info_and_management/Profiling/Query_profile.md).
* `ro = {1 | 0}` переключает сессию в режим только для чтения или обратно. В выводе `show variables` переменная отображается под именем `session_read_only`.
* `throttling_period = <INT_VALUE>`: Интервал (в миллисекундах), через который текущий выполняющийся запрос будет перепланирован. Значение 0 отключает ограничение, то есть запрос будет занимать CPU до завершения. Если в это время поступают параллельные запросы из других подключений, они будут распределены на свободные ядра или приостановлены до освобождения ядра. Указание отрицательного значения (-1) сбрасывает ограничение до значения по умолчанию, заданного при компиляции (100 мс), что означает перепланирование запроса каждые 100 мс, давая возможность выполнять параллельные запросы. Глобальное значение (устанавливаемое через `set global`) можно задать только с VIP-подключения.
* `thread_stack = <value>`: Изменяет значение по умолчанию на лету, ограничивающее размер стека, выделяемого одной задаче. Обратите внимание, что здесь «поток» — это не поток ОС, а поток в пространстве пользователя, также известный как корутина. Это может быть полезно, например, если вы загружаете таблицу percolate с неожиданно высокими требованиями. В таких случаях 'call pq' может завершиться с сообщением о недостаточном размере стека. Обычно следует остановить демон, увеличить значение в конфиге и перезапустить. Однако можно попробовать новое значение без перезапуска, установив его через эту переменную. Глобальное значение также можно изменить онлайн с помощью `set global thread_stack`, но это доступно только с VIP-подключения.
* `threads_ex` (диагностическая): Заставляет Manticore вести себя так, как если бы он работал на CPU с указанным профилем. Краткий пример: `set threads_ex='4/2+6/3'` означает «у вас 4 свободных ядра CPU, при планировании нескольких запросов их следует группировать по 2. Также у вас есть 6 свободных ядер для псевдо-шардинга, части следует группировать по 3». Эта опция диагностическая, так как очень полезна, например, чтобы увидеть, как ваш запрос будет выполняться на конфигурации, которой у вас нет локально. Например, на 128-ядерном CPU. Или, наоборот, быстро ограничить демон однопоточным режимом, чтобы найти узкое место или исследовать сбой.

  <details>

	По умолчанию Manticore запускает пул потоков с рассчитанным числом ядер CPU. Все типичные задачи затем распределяются в этот пул потоков для обеспечения максимального использования CPU. Например, если у таблицы реального времени несколько дисковых чанков, поиск будет распараллелен по ядрам CPU. Аналогично, для одного полнотекстового поиска по одному индексу демон попытается оптимизировать выполнение поиска параллельно, используя технику, называемую «псевдо-шардинг». Обе функции сильно зависят от общего числа ядер CPU и количества свободных ядер, доступных для немедленного использования.

	Такой подход повышает производительность, но может усложнить расследование инцидентов. Например, запрос с `COUNT(*)` может вернуть приблизительный результат (например, больше 100 совпадений), а последующее выполнение того же запроса — точный результат (например, ровно 120 совпадений). Эта изменчивость зависит от доступных ядер, но поскольку этот фактор непредсказуем, обычно приводит к нерепродуцируемым результатам. Хотя это обычно приемлемо, иногда может создавать проблемы. Опция `threads_ex` задаёт желаемую конфигурацию ядер CPU, делая запросы с этой конфигурацией воспроизводимыми.

`threads_ex` задаёт шаблон CPU для стандартных задач и для псевдо-шардинга, так как псевдо-шардинг может быть частью стандартного процесса параллелизации. Например, если есть несколько дисковых чанков, они будут опрашиваться параллельно, но каждый из них может быть дополнительно распараллелен с помощью псевдо-шардинга. Таким образом, для эффективного управления этой ситуацией нужны несколько шаблонов для каждого типа задач.

Шаблон — это строка вида `10/3`, где 10 обозначает параллелизм, а 3 — размер батча. Если параллелизм равен 0, будет использован параллелизм по умолчанию. Если размер батча равен 0, будет использован шаблон по умолчанию (тривиальный). Любое значение 0 можно опустить или заменить на `*`. Шаблон по умолчанию (тривиальный) можно описать как `''`, а также как `*/*`, `0/0`, `0/`, `*/`, `/0`, `*` и т. п. Это означает, что демон использует все доступные ядра CPU без специальных ограничений на батчи.

Тривиальный шаблон с 20 потоками можно выразить как `20/*`, `20/0`, `20/` или просто `20`. Шаблон round-robin с размером батча 2 — это `*/2`, `0/2` или просто `/2`. Диспетчер round-robin с 20 потоками и размером батча 3 — `20/3`.

`threads_ex` — это шаблон для базовых задач и для псевдо-шардинга, разделённые знаком `+`, например:

* `30+3` — тривиальная база из 30 потоков + тривиальный псевдо-шардинг из 3 потоков
* `+/2` — тривиальная база + round-robin псевдо-шардинг с потоками по умолчанию и размером батча 2
* `10` — тривиальная база из 10 потоков + тривиальный псевдо-шардинг по умолчанию
* `/1+10` — round-robin база с потоками по умолчанию и размером батча 1 + тривиальный псевдо-шардинг с 10 потоками
* `4/2+2/1` — round-robin база с 4 потоками и размером батча 2 + round-robin псевдо-шардинг с 2 потоками и размером батча 1
* `1+1` — самый детерминированный случай. Ровно 1 поток + 1 псевдо-шард, то есть никакой параллелизации вообще. С этой настройкой можно воспроизводимо повторять один и тот же проблемный запрос и исследовать детали поведения. Более того, если установить `throttling_period=0`, ваш запрос «прилипнет» к текущему потоку и никогда не будет перепланирован во время выполнения, создавая идеальную среду для отладки.

Опция может быть установлена глобально извне как переменная окружения `MANTICORE_THREADS_EX`, например:

```bash
export MANTICORE_THREADS_EX=8
export MANTICORE_THREADS_EX='16+8/2'
```

Или через MySQL CLI, например:
```sql
SET threads_ex='16';
SET GLOBAL threads_ex='/2';
```

Или как параметр запроса, например:
```sql
SELECT ... OPTION threads_ex='1+1';
```

Конфигурация `threads_ex` следует иерархии: сначала переменные окружения, затем глобальная переменная, и наконец, опции запроса, что позволяет конкретным настройкам переопределять общие.

</details>
* `WAIT_TIMEOUT/net_read_timeout = <value>` задаёт таймаут соединения, либо для сессии, либо глобально. Глобально можно установить только на VIP-соединении.

Известные глобальные переменные сервера:

* `ACCURATE_AGGREGATION`: задаёт значение по умолчанию для опции [accurate_aggregation](../Searching/Options.md#accurate_aggregation) будущих запросов.
* `AUTO_OPTIMIZE = {1|0}` Включает/выключает [auto_optimize](../Server_settings/Searchd.md#auto_optimize).
* `cluster_user = name` Задаёт имя пользователя, используемое с `mysqldump` / `mariadb-dump` для [включения режима репликации](../Securing_and_compacting_a_table/Backup_and_restore.md#Backup-and-restore-with-mysqldump).
* `COREDUMP= {1|0}` Включает/выключает сохранение core-файла или минидампа сервера при сбое. Подробнее [здесь](../Starting_the_server/Manually.md#searchd-command-line-options).
* `CPUSTATS= {1|0}` Включает/выключает [отслеживание времени CPU](../Starting_the_server/Manually.md#searchd-command-line-options).
* `DISTINCT_PRECISION_THRESHOLD`: задаёт значение по умолчанию для опции [distinct_precision_threshold](../Searching/Options.md#distinct_precision_threshold) будущих запросов.
* `ES_COMPAT = {on/off/dashboards}` При установке в `on` (по умолчанию) поддерживаются запросы на запись, похожие на Elasticsearch; `off` отключает поддержку; `dashboards` включает поддержку и также разрешает запросы из Kibana (эта функциональность экспериментальная).
* `EXPANSION_MERGE_THRESHOLD_DOCS`: изменяет значение настройки конфигурации [expansion_merge_threshold_docs](../Server_settings/Searchd.md#expansion_merge_threshold_docs) на лету.
* `EXPANSION_MERGE_THRESHOLD_HITS`: изменяет значение настройки конфигурации [expansion_merge_threshold_hits](../Server_settings/Searchd.md#expansion_merge_threshold_hits) на лету.
* `GROUPING_IN_UTC = {0 | 1}` При установке в 1 функции группировки по времени (day(), month(), year(), yearmonth(), yearmonthday()) вычисляются в UTC. Подробнее см. документацию по параметрам конфигурации [grouping_in_utc](../Server_settings/Searchd.md).
* `IOSTATS = {0 | 1}` Включает или отключает отчётность о I/O операциях (кроме атрибутов) в журнале запросов.
* `LOG_DEBUG_FILTER = <string value>` Фильтрует избыточные сообщения журнала. Если значение установлено, то все логи с уровнем > INFO (то есть `DEBUG`, `DEBUGV` и т. п.) будут сравниваться со строкой и выводиться только если начинаются с данного значения.
* `LOG_LEVEL = {info | debug | replication | debugv | debugvv}` Изменяет текущий уровень подробности журнала.
* `MAINTENANCE = {0 | 1}` При установке в 1 переводит сервер в режим обслуживания. В этом режиме запросы могут выполнять только клиенты с VIP-соединениями. Все новые не-VIP соединения отклоняются. Существующие соединения остаются без изменений.
* `MAX_THREADS_PER_QUERY = <POSITIVE_INT_VALUE>` Переопределяет [max_threads_per_query](../Server_settings/Searchd.md#max_threads_per_query) во время работы. Как глобальная переменная, изменяет поведение для всех сессий. Значение 0 означает «без ограничений». Если установлены и переменная на сессию, и глобальная, приоритет выше у переменной на сессию.
* `NET_WAIT = {-1 | 0 | POSITIVE_INT_VALUE}` Изменяет значение настройки [net_wait_tm](../Server_settings/Searchd.md#net_wait_tm) searchd.
* `OPTIMIZE_CUTOFF = <value>`: изменяет значение настройки конфигурации [optimize_cutoff](../Server_settings/Searchd.md#optimize_cutoff) на лету.
* `PSEUDO_SHARDING = {1|0}` Включает/выключает поиск с использованием [псевдо-шардинга](../Server_settings/Searchd.md#pseudo_sharding).
* `QCACHE_MAX_BYTES = <value>` Изменяет лимит использования оперативной памяти [query_cache](../Searching/Query_cache.md) на заданное значение.
* `QCACHE_THRESH_MSEC = <value>` Изменяет минимальный порог времени выполнения [query_cache](../Searching/Query_cache.md) на заданное значение.
* `QCACHE_TTL_SEC = <value>` Изменяет TTL для кэшированного результата в [query_cache](../Searching/Query_cache.md) на заданное значение.
* `QUERY_LOG_FORMAT = {plain | sphinxql}` Изменяет текущий формат журнала.
* `QUERY_LOG_MIN_MSEC = <value>` Изменяет значение настройки [query_log_min_msec](../Server_settings/Searchd.md#query_log_min_msec) для searchd. В этом случае ожидается значение именно в миллисекундах, и суффиксы времени, как в конфиге, не обрабатываются.
  > Внимание: это очень специфичная и «жёсткая» переменная; отфильтрованные сообщения просто не будут записаны в журнал. Лучше фильтровать журнал с помощью чего-то вроде 'grep', в этом случае у вас будет хотя бы полный оригинальный журнал в резервной копии.
* `RESET_NETWORK_TIMEOUT_ON_PACKET = {1|0}` изменяет параметр [reset_network_timeout_on_packet](../Server_settings/Searchd.md#reset_network_timeout_on_packet). Изменять эту переменную могут только клиенты с VIP-подключениями.
* `SECONDARY_INDEXES = {1|0}` Включает/выключает [вторичные индексы](../Server_settings/Searchd.md#secondary_indexes) для поисковых запросов.
* `TIMEZONE = <value>` Указывает часовой пояс, используемый функциями, связанными с датой и временем. Подробнее см. документацию по параметру конфигурации [timezone](../Server_settings/Searchd.md).

Примеры:

```sql
mysql> SET autocommit=0;
Query OK, 0 rows affected (0.00 sec)

mysql> SET GLOBAL query_log_format=sphinxql;
Query OK, 0 rows affected (0.00 sec)

mysql> SET GLOBAL @banned=(1,2,3);
Query OK, 0 rows affected (0.01 sec)

mysql> SET INDEX users GLOBAL @banned=(1,2,3);
Query OK, 0 rows affected (0.01 sec)
```

Чтобы сделать пользовательские переменные постоянными, убедитесь, что включён [sphinxql_state](../Server_settings/Searchd.md#sphinxql_state).
<!-- proofread -->

