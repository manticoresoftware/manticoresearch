# Test LOCK TABLES compatibility with mysqldump and batch operations
# Ensures LOCK/UNLOCK work correctly for database backup and restore scenarios
# Issue: https://github.com/manticoresoftware/manticoresearch/issues/3047

––– block: ../base/start-searchd –––
––– comment –––
Create test table for mysqldump compatibility testing
––– input –––
mysql -h0 -P9306 -e "DROP TABLE IF EXISTS test_dump; CREATE TABLE test_dump (id BIGINT, name TEXT, value INTEGER);"
––– output –––
––– comment –––
Insert sample data
––– input –––
mysql -h0 -P9306 -e "INSERT INTO test_dump VALUES (1, 'first', 100), (2, 'second', 200), (3, 'third', 300);"
––– output –––
––– comment –––
Show table structure (similar to what mysqldump does)
––– input –––
mysql -h0 -P9306 -e "SHOW CREATE TABLE test_dump\G"
––– output –––
*************************** 1. row ***************************
       Table: test_dump
Create Table: CREATE TABLE test_dump (
id bigint,
name text,
value integer
)
––– comment –––
Lock table for reading (like mysqldump does before dump)
––– input –––
mysql -h0 -P9306 -e "LOCK TABLES test_dump READ;"
––– output –––
––– comment –––
Read all data while locked
––– input –––
mysql -h0 -P9306 -e "SELECT * FROM test_dump ORDER BY id;"
––– output –––
+------+--------+-------+
| id   | name   | value |
+------+--------+-------+
|    1 | first  |   100 |
|    2 | second |   200 |
|    3 | third  |   300 |
+------+--------+-------+
––– comment –––
Release lock after reading
––– input –––
mysql -h0 -P9306 -e "UNLOCK TABLES;"
––– output –––
––– comment –––
Check if mysqldump is available
––– input –––
which mysqldump
––– output –––
#!/.*mysqldump/!#
––– comment –––
Run mysqldump without lock tables to test basic compatibility
Extract only relevant SQL statements (CREATE, INSERT)
––– input –––
mysqldump -h0 -P9306 --no-tablespaces --skip-lock-tables test_dump 2>&1 | grep -E "(LOCK|UNLOCK|INSERT|CREATE)" | head -20
––– output –––
CREATE TABLE `test_dump` (
  `id` bigint DEFAULT NULL,
  `name` text,
  `value` int DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
INSERT INTO `test_dump` VALUES (1,'first',100),(2,'second',200),(3,'third',300);
––– comment –––
Test batch insert operations within LOCK/UNLOCK (typical restore scenario)
Lock table, insert multiple records, then unlock
––– input –––
mysql -h0 -P9306 << 'EOF'
LOCK TABLES test_dump WRITE;
INSERT INTO test_dump VALUES (4, 'fourth', 400);
INSERT INTO test_dump VALUES (5, 'fifth', 500);
UNLOCK TABLES;
EOF
––– output –––
––– comment –––
Verify batch insert worked
––– input –––
mysql -h0 -P9306 -e "SELECT COUNT(*) FROM test_dump;"
––– output –––
+----------+
| count(*) |
+----------+
|        5 |
+----------+
––– comment –––
Test reading within LOCK/UNLOCK block using heredoc
––– input –––
mysql -h0 -P9306 << 'EOF'
LOCK TABLES test_dump READ;
SELECT * FROM test_dump WHERE id > 3 ORDER BY id;
UNLOCK TABLES;
EOF
––– output –––
+------+--------+-------+
| id   | name   | value |
+------+--------+-------+
|    4 | fourth |   400 |
|    5 | fifth  |   500 |
+------+--------+-------+
––– comment –––
Test typical restore scenario: create table, lock, batch insert, unlock, verify
––– input –––
mysql -h0 -P9306 << 'EOF'
DROP TABLE IF EXISTS batch_test;
CREATE TABLE batch_test (id BIGINT, data TEXT);
LOCK TABLES batch_test WRITE;
INSERT INTO batch_test VALUES (1, 'a');
INSERT INTO batch_test VALUES (2, 'b');
INSERT INTO batch_test VALUES (3, 'c');
UNLOCK TABLES;
SELECT * FROM batch_test ORDER BY id;
EOF
––– output –––
+------+------+
| id   | data |
+------+------+
|    1 | a    |
|    2 | b    |
|    3 | c    |
+------+------+
––– comment –––
Test OPTIMIZE TABLE under WRITE lock (maintenance operation)
––– input –––
mysql -h0 -P9306 -e "LOCK TABLES test_dump WRITE; OPTIMIZE TABLE test_dump; UNLOCK TABLES;"
––– output –––
––– comment –––
Verify data integrity after OPTIMIZE
––– input –––
mysql -h0 -P9306 -e "SELECT * FROM test_dump ORDER BY id;"
––– output –––
+------+--------+-------+
| id   | name   | value |
+------+--------+-------+
|    1 | first  |   100 |
|    2 | second |   200 |
|    3 | third  |   300 |
|    4 | fourth |   400 |
|    5 | fifth  |   500 |
+------+--------+-------+
––– comment –––
Test TRUNCATE followed by INSERT under WRITE lock (restore scenario)
––– input –––
mysql -h0 -P9306 << 'EOF'
LOCK TABLES test_dump WRITE;
TRUNCATE TABLE test_dump;
INSERT INTO test_dump VALUES (10, 'new', 1000);
UNLOCK TABLES;
EOF
––– output –––
––– comment –––
Verify table was truncated and new data inserted
––– input –––
mysql -h0 -P9306 -e "SELECT * FROM test_dump;"
––– output –––
+------+------+-------+
| id   | name | value |
+------+------+-------+
|   10 | new  |  1000 |
+------+------+-------+
––– comment –––
Cleanup test tables
––– input –––
mysql -h0 -P9306 -e "DROP TABLE IF EXISTS test_dump, batch_test;"
––– output –––
